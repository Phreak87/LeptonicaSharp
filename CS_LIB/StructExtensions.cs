using Enumerations;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using LeptonicaSharp ;
using System;

public partial class Numa
{
	// dnafunc1.c (187, 1)
	// numaConvertToDna(na) as L_Dna
	// numaConvertToDna(NUMA *) as L_DNA *
	///  <summary>
	/// numaConvertToDna
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaConvertToDna/*"/>
	///   <returns>da, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public L_Dna ConvertToDna ()
	{
		L_Dna RetObj = _All.numaConvertToDna(this);
		return RetObj;
	}

	// enhance.c (366, 1)
	// numaGammaTRC(gamma, minval, maxval) as Numa
	// numaGammaTRC(l_float32, l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) The map is returned as a numa values are clipped to [0, 255].<para/>
	///
	/// (2) To force all intensities into a range within fraction delta
	/// of white, use: minval = -256  (1 - delta) / delta
	/// maxval = 255<para/>
	///
	/// (3) To force all intensities into a range within fraction delta
	/// of black, use: minval = 0
	/// maxval = 256  (1 - delta) / delta
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGammaTRC/*"/>
	///  <param name="gamma">[in] - gamma factor must be  is greater  0.0</param>
	///  <param name="minval">[in] - input value that gives 0 for output</param>
	///  <param name="maxval">[in] - input value that gives 255 for output</param>
	///   <returns>na, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GammaTRC (Single gamma,
						  int minval,
						  int maxval)
	{
		Numa RetObj = _All.numaGammaTRC(gamma, minval, maxval);
		return RetObj;
	}

	// enhance.c (557, 1)
	// numaContrastTRC(factor) as Numa
	// numaContrastTRC(l_float32) as NUMA *
	///  <summary>
	/// (1) The mapping is monotonic increasing, where 0 is mapped
	/// to 0 and 255 is mapped to 255.<para/>
	///
	/// (2) As 'factor' is increased from 0.0 (where the mapping is linear),
	/// the map gets closer to its limit as a step function that
	/// jumps from 0 to 255 at the center (input value = 127).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaContrastTRC/*"/>
	///  <param name="factor">[in] - generally between 0.0 [no enhancement] and 1.0, but can be larger than 1.0</param>
	///   <returns>na, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa ContrastTRC (Single factor)
	{
		Numa RetObj = _All.numaContrastTRC(factor);
		return RetObj;
	}

	// enhance.c (714, 1)
	// numaEqualizeTRC(pix, fract, factor) as Numa
	// numaEqualizeTRC(PIX *, l_float32, l_int32) as NUMA *
	///  <summary>
	/// (1) If fract == 0.0, no equalization will be performed.
	/// If fract == 1.0, equalization is complete.<para/>
	///
	/// (2) Set the subsampling factor  is greater  1 to reduce the amount of computation.<para/>
	///
	/// (3) The map is returned as a numa with 256 values, specifying
	/// the equalized value (array value) for every input value
	/// (the array index).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaEqualizeTRC/*"/>
	///  <param name="pix">[in] - 8 bpp, no colormap</param>
	///  <param name="fract">[in] - fraction of equalization movement of pixel values</param>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///   <returns>nad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa EqualizeTRC (Pix pix,
							 Single fract,
							 int factor)
	{
		Numa RetObj = _All.numaEqualizeTRC(pix, fract, factor);
		return RetObj;
	}

	// numabasic.c (187, 1)
	// numaCreate(n) as Numa
	// numaCreate(l_int32) as NUMA *
	///  <summary>
	/// numaCreate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaCreate/*"/>
	///  <param name="n">[in] - size of number array to be alloc'd 0 for default</param>
	///   <returns>na, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa Create (int n)
	{
		Numa RetObj = _All.numaCreate(n);
		return RetObj;
	}

	// numabasic.c (228, 1)
	// numaCreateFromIArray(iarray, size) as Numa
	// numaCreateFromIArray(l_int32 *, l_int32) as NUMA *
	///  <summary>
	/// (1) We can't insert this int array into the numa, because a numa
	/// takes a float array.  So this just copies the data from the
	/// input array into the numa.  The input array continues to be
	/// owned by the caller.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaCreateFromIArray/*"/>
	///  <param name="iarray">[in] - integer</param>
	///  <param name="size">[in] - of the array</param>
	///   <returns>na, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa CreateFromIArray (int[] iarray,
								  int size)
	{
		Numa RetObj = _All.numaCreateFromIArray(iarray, size);
		return RetObj;
	}

	// numabasic.c (265, 1)
	// numaCreateFromFArray(farray, size, copyflag) as Numa
	// numaCreateFromFArray(l_float32 *, l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) With L_INSERT, ownership of the input array is transferred
	/// to the returned numa, and all %size elements are considered
	/// to be valid.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaCreateFromFArray/*"/>
	///  <param name="farray">[in] - float</param>
	///  <param name="size">[in] - of the array</param>
	///  <param name="copyflag">[in] - L_INSERT or L_COPY</param>
	///   <returns>na, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa CreateFromFArray (Single[] farray,
								  int size,
								  int copyflag)
	{
		Numa RetObj = _All.numaCreateFromFArray(farray, size, copyflag);
		return RetObj;
	}

	// numabasic.c (309, 1)
	// numaCreateFromString(str) as Numa
	// numaCreateFromString(const char *) as NUMA *
	///  <summary>
	/// (1) The numbers can be ints or floats they will be interpreted
	/// and stored as floats.  To use them as integers (e.g., for
	/// indexing into arrays), use numaGetIValue(...).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaCreateFromString/*"/>
	///  <param name="str">[in] - string of comma-separated numbers</param>
	///   <returns>na, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa CreateFromString (String str)
	{
		Numa RetObj = _All.numaCreateFromString(str);
		return RetObj;
	}

	// numabasic.c (360, 1)
	// numaDestroy(pna) as Object
	// numaDestroy(NUMA **) as void
	///  <summary>
	/// (1) Decrements the ref count and, if 0, destroys the numa.<para/>
	///
	/// (2) Always nulls the input ptr.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaDestroy/*"/>
	///  <param name="pna">[in,out] - to be nulled if it exists</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref Numa pna)
	{
		_All.numaDestroy(ref pna);
	}

	// numabasic.c (394, 1)
	// numaCopy(na) as Numa
	// numaCopy(NUMA *) as NUMA *
	///  <summary>
	/// numaCopy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaCopy/*"/>
	///   <returns>copy of numa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa Copy ()
	{
		Numa RetObj = _All.numaCopy(this);
		return RetObj;
	}

	// numabasic.c (423, 1)
	// numaClone(na) as Numa
	// numaClone(NUMA *) as NUMA *
	///  <summary>
	/// numaClone()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaClone/*"/>
	///   <returns>ptr to same numa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa Clone ()
	{
		Numa RetObj = _All.numaClone(this);
		return RetObj;
	}

	// numabasic.c (449, 1)
	// numaEmpty(na) as int
	// numaEmpty(NUMA *) as l_ok
	///  <summary>
	/// (1) This does not change the allocation of the array.
	/// It just clears the number of stored numbers, so that
	/// the array appears to be empty.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaEmpty/*"/>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Empty ()
	{
		int RetObj = _All.numaEmpty(this);
		return RetObj;
	}

	// numabasic.c (473, 1)
	// numaAddNumber(na, val) as int
	// numaAddNumber(NUMA *, l_float32) as l_ok
	///  <summary>
	/// numaAddNumber()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaAddNumber/*"/>
	///  <param name="val">[in] - float or int to be added stored as a float</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddNumber (Single val)
	{
		int RetObj = _All.numaAddNumber(this, val);
		return RetObj;
	}

	// numabasic.c (534, 1)
	// numaInsertNumber(na, index, val) as int
	// numaInsertNumber(NUMA *, l_int32, l_float32) as l_ok
	///  <summary>
	/// (1) This shifts na[i] to na[i + 1] for all i greater or equal index,
	/// and then inserts val as na[index].<para/>
	///
	/// (2) It should not be used repeatedly on large arrays,
	/// because the function is O(n).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaInsertNumber/*"/>
	///  <param name="index">[in] - location in na to insert new value</param>
	///  <param name="val">[in] - float32 or integer to be added</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int InsertNumber (int index,
							 Single val)
	{
		int RetObj = _All.numaInsertNumber(this, index, val);
		return RetObj;
	}

	// numabasic.c (573, 1)
	// numaRemoveNumber(na, index) as int
	// numaRemoveNumber(NUMA *, l_int32) as l_ok
	///  <summary>
	/// (1) This shifts na[i] to na[i - 1] for all i  is greater  index.<para/>
	///
	/// (2) It should not be used repeatedly on large arrays,
	/// because the function is O(n).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaRemoveNumber/*"/>
	///  <param name="index">[in] - element to be removed</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RemoveNumber (int index)
	{
		int RetObj = _All.numaRemoveNumber(this, index);
		return RetObj;
	}

	// numabasic.c (602, 1)
	// numaReplaceNumber(na, index, val) as int
	// numaReplaceNumber(NUMA *, l_int32, l_float32) as l_ok
	///  <summary>
	/// numaReplaceNumber()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaReplaceNumber/*"/>
	///  <param name="index">[in] - element to be replaced</param>
	///  <param name="val">[in] - new value to replace old one</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ReplaceNumber (int index,
							  Single val)
	{
		int RetObj = _All.numaReplaceNumber(this, index, val);
		return RetObj;
	}

	// numabasic.c (631, 1)
	// numaGetCount(na) as int
	// numaGetCount(NUMA *) as l_int32
	///  <summary>
	/// numaGetCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetCount/*"/>
	///   <returns>count, or 0 if no numbers or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCount ()
	{
		int RetObj = _All.numaGetCount(this);
		return RetObj;
	}

	// numabasic.c (658, 1)
	// numaSetCount(na, newcount) as int
	// numaSetCount(NUMA *, l_int32) as l_ok
	///  <summary>
	/// (1) If newcount smaller or equal natonalloc, this resets naton.
	/// Using newcount = 0 is equivalent to numaEmpty().<para/>
	///
	/// (2) If newcount  is greater  natonalloc, this causes a realloc
	/// to a size natonalloc = newcount.<para/>
	///
	/// (3) All the previously unused values in na are set to 0.0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSetCount/*"/>
	///  <param name="newcount">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetCount (int newcount)
	{
		int RetObj = _All.numaSetCount(this, newcount);
		return RetObj;
	}

	// numabasic.c (692, 1)
	// numaGetFValue(na, index, pval) as int
	// numaGetFValue(NUMA *, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// (1) Caller may need to check the function return value to
	/// decide if a 0.0 in the returned ival is valid.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetFValue/*"/>
	///  <param name="index">[in] - into numa</param>
	///  <param name="pval">[out] - float value 0.0 on error</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetFValue (int index,
						  out Single pval)
	{
		int RetObj = _All.numaGetFValue(this, index, out pval);
		return RetObj;
	}

	// numabasic.c (727, 1)
	// numaGetIValue(na, index, pival) as int
	// numaGetIValue(NUMA *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) Caller may need to check the function return value to
	/// decide if a 0 in the returned ival is valid.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetIValue/*"/>
	///  <param name="index">[in] - into numa</param>
	///  <param name="pival">[out] - integer value 0 on error</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetIValue (int index,
						  out int pival)
	{
		int RetObj = _All.numaGetIValue(this, index, out pival);
		return RetObj;
	}

	// numabasic.c (759, 1)
	// numaSetValue(na, index, val) as int
	// numaSetValue(NUMA *, l_int32, l_float32) as l_ok
	///  <summary>
	/// numaSetValue()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSetValue/*"/>
	///  <param name="index">[in] - to element to be set</param>
	///  <param name="val">[in] - to set element</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetValue (int index,
						 Single val)
	{
		int RetObj = _All.numaSetValue(this, index, val);
		return RetObj;
	}

	// numabasic.c (784, 1)
	// numaShiftValue(na, index, diff) as int
	// numaShiftValue(NUMA *, l_int32, l_float32) as l_ok
	///  <summary>
	/// numaShiftValue()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaShiftValue/*"/>
	///  <param name="index">[in] - to element to change relative to the current value</param>
	///  <param name="diff">[in] - increment if diff  is greater  0 or decrement if diff  is smaller 0</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ShiftValue (int index,
						   Single diff)
	{
		int RetObj = _All.numaShiftValue(this, index, diff);
		return RetObj;
	}

	// numabasic.c (820, 1)
	// numaGetIArray(na) as int[]
	// numaGetIArray(NUMA *) as l_int32 *
	///  <summary>
	/// (1) A copy of the array is always made, because we need to
	/// generate an integer array from the bare float array.
	/// The caller is responsible for freeing the array.<para/>
	///
	/// (2) The array size is determined by the number of stored numbers,
	/// not by the size of the allocated array in the Numa.<para/>
	///
	/// (3) This function is provided to simplify calculations
	/// using the bare internal array, rather than continually
	/// calling accessors on the numa.  It is typically used
	/// on an array of size 256.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetIArray/*"/>
	///   <returns>a copy of the bare internal array, integerized by rounding, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int[] GetIArray ()
	{
		int[] RetObj = _All.numaGetIArray(this);
		return RetObj;
	}

	// numabasic.c (865, 1)
	// numaGetFArray(na, copyflag) as Single[]
	// numaGetFArray(NUMA *, l_int32) as l_float32 *
	///  <summary>
	/// (1) If copyflag == L_COPY, it makes a copy which the caller
	/// is responsible for freeing.  Otherwise, it operates
	/// directly on the bare array of the numa.<para/>
	///
	/// (2) Very important: for L_NOCOPY, any writes to the array
	/// will be in the numa.  Do not write beyond the size of
	/// the count field, because it will not be accessible
	/// from the numa!  If necessary, be sure to set the count
	/// field to a larger number (such as the alloc size)
	/// BEFORE calling this function.  Creating with numaMakeConstant()
	/// is another way to insure full initialization.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetFArray/*"/>
	///  <param name="copyflag">[in] - L_NOCOPY or L_COPY</param>
	///   <returns>either the bare internal array or a copy of it, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Single[] GetFArray (int copyflag)
	{
		Single[] RetObj = _All.numaGetFArray(this, copyflag);
		return RetObj;
	}

	// numabasic.c (897, 1)
	// numaGetRefcount(na) as int
	// numaGetRefcount(NUMA *) as l_int32
	///  <summary>
	/// numaGetRefCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetRefcount/*"/>
	///   <returns>refcount, or UNDEF on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRefcount ()
	{
		int RetObj = _All.numaGetRefcount(this);
		return RetObj;
	}

	// numabasic.c (915, 1)
	// numaChangeRefcount(na, delta) as int
	// numaChangeRefcount(NUMA *, l_int32) as l_ok
	///  <summary>
	/// numaChangeRefCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaChangeRefcount/*"/>
	///  <param name="delta">[in] - change to be applied</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ChangeRefcount (int delta)
	{
		int RetObj = _All.numaChangeRefcount(this, delta);
		return RetObj;
	}

	// numabasic.c (936, 1)
	// numaGetParameters(na, pstartx, pdelx) as int
	// numaGetParameters(NUMA *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// numaGetParameters()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetParameters/*"/>
	///  <param name="pstartx">[out][optional] - startx</param>
	///  <param name="pdelx">[out][optional] - delx</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetParameters (out Single pstartx,
							  out Single pdelx)
	{
		int RetObj = _All.numaGetParameters(this, out pstartx, out pdelx);
		return RetObj;
	}

	// numabasic.c (966, 1)
	// numaSetParameters(na, startx, delx) as int
	// numaSetParameters(NUMA *, l_float32, l_float32) as l_ok
	///  <summary>
	/// numaSetParameters()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSetParameters/*"/>
	///  <param name="startx">[in] - x value corresponding to na[0]</param>
	///  <param name="delx">[in] - difference in x values for the situation where the elements of na correspond to the evaulation of a function at equal intervals of size %delx</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetParameters (Single startx,
							  Single delx)
	{
		int RetObj = _All.numaSetParameters(this, startx, delx);
		return RetObj;
	}

	// numabasic.c (989, 1)
	// numaCopyParameters(nad, nas) as int
	// numaCopyParameters(NUMA *, NUMA *) as l_ok
	///  <summary>
	/// numaCopyParameters()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaCopyParameters/*"/>
	///  <param name="nad">[in] - destination Numa</param>
	///  <param name="nas">[in] - source Numa</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CopyParameters (Numa nad,
							   Numa nas)
	{
		int RetObj = _All.numaCopyParameters(nad, nas);
		return RetObj;
	}

	// numabasic.c (1027, 1)
	// numaConvertToSarray(na, size1, size2, addzeros, type) as Sarray
	// numaConvertToSarray(NUMA *, l_int32, l_int32, l_int32, l_int32) as SARRAY *
	///  <summary>
	/// (1) For integer conversion, size2 is ignored.
	/// For float conversion, addzeroes is ignored.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaConvertToSarray/*"/>
	///  <param name="size1">[in] - size of conversion field</param>
	///  <param name="size2">[in] - for float conversion: size of field to the right of the decimal point</param>
	///  <param name="addzeros">[in] - for integer conversion: to add lead zeros</param>
	///  <param name="type">[in] - L_INTEGER_VALUE, L_FLOAT_VALUE</param>
	///   <returns>a sarray of the float values converted to strings representing either integer or float values or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray ConvertToSarray (int size1,
								   int size2,
								   int addzeros,
								   int type)
	{
		Sarray RetObj = _All.numaConvertToSarray(this, size1, size2, addzeros, type);
		return RetObj;
	}

	// numabasic.c (1083, 1)
	// numaRead(filename) as Numa
	// numaRead(const char *) as NUMA *
	///  <summary>
	/// numaRead()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaRead/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>na, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa Read (String filename)
	{
		Numa RetObj = _All.numaRead(filename);
		return RetObj;
	}

	// numabasic.c (1110, 1)
	// numaReadStream(fp) as Numa
	// numaReadStream(FILE *) as NUMA *
	///  <summary>
	/// numaReadStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>numa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa ReadStream (FILE fp)
	{
		Numa RetObj = _All.numaReadStream(fp);
		return RetObj;
	}

	// numabasic.c (1156, 1)
	// numaReadMem(data, size) as Numa
	// numaReadMem(const l_uint8 *, size_t) as NUMA *
	///  <summary>
	/// numaReadMem()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaReadMem/*"/>
	///  <param name="data">[in] - numa serialization in ascii</param>
	///  <param name="size">[in] - of data can use strlen to get it</param>
	///   <returns>na, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa ReadMem (Byte[] data,
						 uint size)
	{
		Numa RetObj = _All.numaReadMem(data, size);
		return RetObj;
	}

	// numabasic.c (1193, 1)
	// numaWriteDebug(filename, na) as int
	// numaWriteDebug(const char *, NUMA *) as l_ok
	///  <summary>
	/// (1) Debug version, intended for use in the library when writing
	/// to files in a temp directory with names that are compiled in.
	/// This is used instead of numaWrite() for all such library calls.<para/>
	///
	/// (2) The global variable LeptDebugOK defaults to 0, and can be set
	/// or cleared by the function setLeptDebugOK().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaWriteDebug/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteDebug (String filename)
	{
		int RetObj = _All.numaWriteDebug(filename, this);
		return RetObj;
	}

	// numabasic.c (1214, 1)
	// numaWrite(filename, na) as int
	// numaWrite(const char *, NUMA *) as l_ok
	///  <summary>
	/// numaWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaWrite/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String filename)
	{
		int RetObj = _All.numaWrite(filename, this);
		return RetObj;
	}

	// numabasic.c (1245, 1)
	// numaWriteStream(fp, na) as int
	// numaWriteStream(FILE *, NUMA *) as l_ok
	///  <summary>
	/// numaWriteStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaWriteStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp)
	{
		int RetObj = _All.numaWriteStream(fp, this);
		return RetObj;
	}

	// numabasic.c (1288, 1)
	// numaWriteMem(pdata, psize, na) as int
	// numaWriteMem(l_uint8 **, size_t *, NUMA *) as l_ok
	///  <summary>
	/// (1) Serializes a numa in memory and puts the result in a buffer.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaWriteMem/*"/>
	///  <param name="pdata">[out] - data of serialized numa ascii</param>
	///  <param name="psize">[out] - size of returned data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMem (out Byte[] pdata,
						 out uint psize)
	{
		int RetObj = _All.numaWriteMem(out pdata, out psize, this);
		return RetObj;
	}

	// numafunc1.c (153, 1)
	// numaArithOp(nad, na1, na2, op) as Numa
	// numaArithOp(NUMA *, NUMA *, NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) The sizes of na1 and na2 must be equal.<para/>
	///
	/// (2) nad can only null or equal to na1.<para/>
	///
	/// (3) To add a constant to a numa, or to multipy a numa by
	/// a constant, use numaTransform().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaArithOp/*"/>
	///  <param name="nad">[in][optional] - can be null or equal to na1 (in-place</param>
	///  <param name="na1">[in] - </param>
	///  <param name="na2">[in] - </param>
	///  <param name="op">[in] - L_ARITH_ADD, L_ARITH_SUBTRACT, L_ARITH_MULTIPLY, L_ARITH_DIVIDE</param>
	///   <returns>nad always: operation applied to na1 and na2</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa ArithOp (Numa na1,
						 Numa na2,
						 int op,
						 Numa nad)
	{
		Numa RetObj = _All.numaArithOp(nad, na1, na2, op);
		return RetObj;
	}

	// numafunc1.c (233, 1)
	// numaLogicalOp(nad, na1, na2, op) as Numa
	// numaLogicalOp(NUMA *, NUMA *, NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) The sizes of na1 and na2 must be equal.<para/>
	///
	/// (2) nad can only be null or equal to na1.<para/>
	///
	/// (3) This is intended for use with indicator arrays (0s and 1s).
	/// Input data is extracted as integers (0 == false, anything
	/// else == true) output results are 0 and 1.<para/>
	///
	/// (4) L_SUBTRACTION is subtraction of val2 from val1.  For bit logical
	/// arithmetic this is (val1 [and] ~val2), but because these values
	/// are integers, we use (val1 [and][and] !val2).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaLogicalOp/*"/>
	///  <param name="nad">[in][optional] - can be null or equal to na1 (in-place</param>
	///  <param name="na1">[in] - </param>
	///  <param name="na2">[in] - </param>
	///  <param name="op">[in] - L_UNION, L_INTERSECTION, L_SUBTRACTION, L_EXCLUSIVE_OR</param>
	///   <returns>nad always: operation applied to na1 and na2</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa LogicalOp (Numa na1,
						   Numa na2,
						   int op,
						   Numa nad)
	{
		Numa RetObj = _All.numaLogicalOp(nad, na1, na2, op);
		return RetObj;
	}

	// numafunc1.c (306, 1)
	// numaInvert(nad, nas) as Numa
	// numaInvert(NUMA *, NUMA *) as NUMA *
	///  <summary>
	/// (1) This is intended for use with indicator arrays (0s and 1s).
	/// It gives a boolean-type output, taking the input as
	/// an integer and inverting it:
	/// 0  to  1
	/// anything else  to 0
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaInvert/*"/>
	///  <param name="nad">[in][optional] - can be null or equal to nas (in-place</param>
	///  <param name="nas">[in] - </param>
	///   <returns>nad always: 'inverts' nas</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa Invert (Numa nas,
						Numa nad)
	{
		Numa RetObj = _All.numaInvert(nad, nas);
		return RetObj;
	}

	// numafunc1.c (351, 1)
	// numaSimilar(na1, na2, maxdiff, psimilar) as int
	// numaSimilar(NUMA *, NUMA *, l_float32, l_int32 *) as l_int32
	///  <summary>
	/// (1) Float values can differ slightly due to roundoff and
	/// accumulated errors.  Using %maxdiff  is greater  0.0 allows similar
	/// arrays to be identified.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSimilar/*"/>
	///  <param name="na1">[in] - </param>
	///  <param name="na2">[in] - </param>
	///  <param name="maxdiff">[in] - use 0.0 for exact equality</param>
	///  <param name="psimilar">[out] - 1 if similar 0 if different</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Similar (Numa na1,
						Numa na2,
						Single maxdiff,
						out int psimilar)
	{
		int RetObj = _All.numaSimilar(na1, na2, maxdiff, out psimilar);
		return RetObj;
	}

	// numafunc1.c (400, 1)
	// numaAddToNumber(na, index, val) as int
	// numaAddToNumber(NUMA *, l_int32, l_float32) as l_ok
	///  <summary>
	/// (1) This is useful for accumulating sums, regardless of the index
	/// order in which the values are made available.<para/>
	///
	/// (2) Before use, the numa has to be filled up to %index.  This would
	/// typically be used by creating the numa with the full sized
	/// array, initialized to 0.0, using numaMakeConstant().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaAddToNumber/*"/>
	///  <param name="index">[in] - element to be changed</param>
	///  <param name="val">[in] - new value to be added</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddToNumber (int index,
							Single val)
	{
		int RetObj = _All.numaAddToNumber(this, index, val);
		return RetObj;
	}

	// numafunc1.c (431, 1)
	// numaGetMin(na, pminval, piminloc) as int
	// numaGetMin(NUMA *, l_float32 *, l_int32 *) as l_ok
	///  <summary>
	/// numaGetMin()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetMin/*"/>
	///  <param name="pminval">[out][optional] - min value</param>
	///  <param name="piminloc">[out][optional] - index of min location</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMin (out Single pminval,
					   out int piminloc)
	{
		int RetObj = _All.numaGetMin(this, out pminval, out piminloc);
		return RetObj;
	}

	// numafunc1.c (473, 1)
	// numaGetMax(na, pmaxval, pimaxloc) as int
	// numaGetMax(NUMA *, l_float32 *, l_int32 *) as l_ok
	///  <summary>
	/// numaGetMax()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetMax/*"/>
	///  <param name="pmaxval">[out][optional] - max value</param>
	///  <param name="pimaxloc">[out][optional] - index of max location</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMax (out Single pmaxval,
					   out int pimaxloc)
	{
		int RetObj = _All.numaGetMax(this, out pmaxval, out pimaxloc);
		return RetObj;
	}

	// numafunc1.c (514, 1)
	// numaGetSum(na, psum) as int
	// numaGetSum(NUMA *, l_float32 *) as l_ok
	///  <summary>
	/// numaGetSum()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetSum/*"/>
	///  <param name="psum">[out] - sum of values</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetSum (out Single psum)
	{
		int RetObj = _All.numaGetSum(this, out psum);
		return RetObj;
	}

	// numafunc1.c (553, 1)
	// numaGetPartialSums(na) as Numa
	// numaGetPartialSums(NUMA *) as NUMA *
	///  <summary>
	/// (1) nasum[i] is the sum for all j smaller or equal i of na[j].
	/// So nasum[0] = na[0].<para/>
	///
	/// (2) If you want to generate a rank function, where rank[0] - 0.0,
	/// insert a 0.0 at the beginning of the nasum array.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetPartialSums/*"/>
	///   <returns>nasum, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetPartialSums ()
	{
		Numa RetObj = _All.numaGetPartialSums(this);
		return RetObj;
	}

	// numafunc1.c (586, 1)
	// numaGetSumOnInterval(na, first, last, psum) as int
	// numaGetSumOnInterval(NUMA *, l_int32, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// numaGetSumOnInterval()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetSumOnInterval/*"/>
	///  <param name="first">[in] - beginning index</param>
	///  <param name="last">[in] - final index</param>
	///  <param name="psum">[out] - sum of values in the index interval range</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetSumOnInterval (int first,
								 int last,
								 out Single psum)
	{
		int RetObj = _All.numaGetSumOnInterval(this, first, last, out psum);
		return RetObj;
	}

	// numafunc1.c (632, 1)
	// numaHasOnlyIntegers(na, maxsamples, pallints) as int
	// numaHasOnlyIntegers(NUMA *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) Set %maxsamples == 0 to check every integer in na.  Otherwise,
	/// this samples no more than %maxsamples.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaHasOnlyIntegers/*"/>
	///  <param name="maxsamples">[in] - maximum number of samples to check</param>
	///  <param name="pallints">[out] - 1 if all sampled values are ints else 0</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int HasOnlyIntegers (int maxsamples,
								out int pallints)
	{
		int RetObj = _All.numaHasOnlyIntegers(this, maxsamples, out pallints);
		return RetObj;
	}

	// numafunc1.c (673, 1)
	// numaSubsample(nas, subfactor) as Numa
	// numaSubsample(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// numaSubsample()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSubsample/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="subfactor">[in] - subsample factor, greater or equal 1</param>
	///   <returns>nad evenly sampled values from nas, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa Subsample (Numa nas,
						   int subfactor)
	{
		Numa RetObj = _All.numaSubsample(nas, subfactor);
		return RetObj;
	}

	// numafunc1.c (707, 1)
	// numaMakeDelta(nas) as Numa
	// numaMakeDelta(NUMA *) as NUMA *
	///  <summary>
	/// numaMakeDelta()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaMakeDelta/*"/>
	///  <param name="nas">[in] - input numa</param>
	///   <returns>numa of difference values val[i+1] - val[i], or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa MakeDelta (Numa nas)
	{
		Numa RetObj = _All.numaMakeDelta(nas);
		return RetObj;
	}

	// numafunc1.c (737, 1)
	// numaMakeSequence(startval, increment, size) as Numa
	// numaMakeSequence(l_float32, l_float32, l_int32) as NUMA *
	///  <summary>
	/// numaMakeSequence()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaMakeSequence/*"/>
	///  <param name="startval">[in] - </param>
	///  <param name="increment">[in] - </param>
	///  <param name="size">[in] - of sequence</param>
	///   <returns>numa of sequence of evenly spaced values, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa MakeSequence (Single startval,
							  Single increment,
							  int size)
	{
		Numa RetObj = _All.numaMakeSequence(startval, increment, size);
		return RetObj;
	}

	// numafunc1.c (768, 1)
	// numaMakeConstant(val, size) as Numa
	// numaMakeConstant(l_float32, l_int32) as NUMA *
	///  <summary>
	/// numaMakeConstant()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaMakeConstant/*"/>
	///  <param name="val">[in] - </param>
	///  <param name="size">[in] - of numa</param>
	///   <returns>numa of given size with all entries equal to 'val', or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa MakeConstant (Single val,
							  int size)
	{
		Numa RetObj = _All.numaMakeConstant(val, size);
		return RetObj;
	}

	// numafunc1.c (784, 1)
	// numaMakeAbsValue(nad, nas) as Numa
	// numaMakeAbsValue(NUMA *, NUMA *) as NUMA *
	///  <summary>
	/// numaMakeAbsValue()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaMakeAbsValue/*"/>
	///  <param name="nad">[in]can be null - for new array, or the same as nas for inplace</param>
	///  <param name="nas">[in] - input numa</param>
	///   <returns>nad with all numbers being the absval of the input, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa MakeAbsValue (Numa nas,
							  Numa nad)
	{
		Numa RetObj = _All.numaMakeAbsValue(nad, nas);
		return RetObj;
	}

	// numafunc1.c (818, 1)
	// numaAddBorder(nas, left, right, val) as Numa
	// numaAddBorder(NUMA *, l_int32, l_int32, l_float32) as NUMA *
	///  <summary>
	/// numaAddBorder()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaAddBorder/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="left">[in] - number of elements to add on each side</param>
	///  <param name="right">[in] - number of elements to add on each side</param>
	///  <param name="val">[in] - initialize border elements</param>
	///   <returns>nad with added elements at left and right, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa AddBorder (Numa nas,
						   int left,
						   int right,
						   Single val)
	{
		Numa RetObj = _All.numaAddBorder(nas, left, right, val);
		return RetObj;
	}

	// numafunc1.c (860, 1)
	// numaAddSpecifiedBorder(nas, left, right, type) as Numa
	// numaAddSpecifiedBorder(NUMA *, l_int32, l_int32, l_int32) as NUMA *
	///  <summary>
	/// numaAddSpecifiedBorder()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaAddSpecifiedBorder/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="left">[in] - number of elements to add on each side</param>
	///  <param name="right">[in] - number of elements to add on each side</param>
	///  <param name="type">[in] - L_CONTINUED_BORDER, L_MIRRORED_BORDER</param>
	///   <returns>nad with added elements at left and right, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa AddSpecifiedBorder (Numa nas,
									int left,
									int right,
									int type)
	{
		Numa RetObj = _All.numaAddSpecifiedBorder(nas, left, right, type);
		return RetObj;
	}

	// numafunc1.c (910, 1)
	// numaRemoveBorder(nas, left, right) as Numa
	// numaRemoveBorder(NUMA *, l_int32, l_int32) as NUMA *
	///  <summary>
	/// numaRemoveBorder()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaRemoveBorder/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="left">[in] - number of elements to remove from each side</param>
	///  <param name="right">[in] - number of elements to remove from each side</param>
	///   <returns>nad with removed elements at left and right, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa RemoveBorder (Numa nas,
							  int left,
							  int right)
	{
		Numa RetObj = _All.numaRemoveBorder(nas, left, right);
		return RetObj;
	}

	// numafunc1.c (951, 1)
	// numaCountNonzeroRuns(na, pcount) as int
	// numaCountNonzeroRuns(NUMA *, l_int32 *) as l_ok
	///  <summary>
	/// numaCountNonzeroRuns()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaCountNonzeroRuns/*"/>
	///  <param name="pcount">[out] - number of nonzero runs</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CountNonzeroRuns (out int pcount)
	{
		int RetObj = _All.numaCountNonzeroRuns(this, out pcount);
		return RetObj;
	}

	// numafunc1.c (990, 1)
	// numaGetNonzeroRange(na, eps, pfirst, plast) as int
	// numaGetNonzeroRange(NUMA *, l_float32, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// numaGetNonzeroRange()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetNonzeroRange/*"/>
	///  <param name="eps">[in] - largest value considered to be zero</param>
	///  <param name="pfirst">[out] - interval of array indices where values are nonzero</param>
	///  <param name="plast">[out] - interval of array indices where values are nonzero</param>
	///   <returns>0 if OK, 1 on error or if no nonzero range is found.</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetNonzeroRange (Single eps,
								out int pfirst,
								out int plast)
	{
		int RetObj = _All.numaGetNonzeroRange(this, eps, out pfirst, out plast);
		return RetObj;
	}

	// numafunc1.c (1041, 1)
	// numaGetCountRelativeToZero(na, type, pcount) as int
	// numaGetCountRelativeToZero(NUMA *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// numaGetCountRelativeToZero()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetCountRelativeToZero/*"/>
	///  <param name="type">[in] - L_LESS_THAN_ZERO, L_EQUAL_TO_ZERO, L_GREATER_THAN_ZERO</param>
	///  <param name="pcount">[out] - count of values of given type</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCountRelativeToZero (int type,
									   out int pcount)
	{
		int RetObj = _All.numaGetCountRelativeToZero(this, type, out pcount);
		return RetObj;
	}

	// numafunc1.c (1089, 1)
	// numaClipToInterval(nas, first, last) as Numa
	// numaClipToInterval(NUMA *, l_int32, l_int32) as NUMA *
	///  <summary>
	/// If you want the indices of the array values to be unchanged,
	/// use first = 0.
	/// Usage:
	/// This is useful to clip a histogram that has a few nonzero
	/// values to its nonzero range.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaClipToInterval/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="first">[in] - clipping interval</param>
	///  <param name="last">[in] - clipping interval</param>
	///   <returns>numa with the same values as the input, but clipped to the specified interval</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa ClipToInterval (Numa nas,
								int first,
								int last)
	{
		Numa RetObj = _All.numaClipToInterval(nas, first, last);
		return RetObj;
	}

	// numafunc1.c (1137, 1)
	// numaMakeThresholdIndicator(nas, thresh, type) as Numa
	// numaMakeThresholdIndicator(NUMA *, l_float32, l_int32) as NUMA *
	///  <summary>
	/// (1) For each element in nas, if the constraint given by 'type'
	/// correctly specifies its relation to thresh, a value of 1
	/// is recorded in nad.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaMakeThresholdIndicator/*"/>
	///  <param name="nas">[in] - input numa</param>
	///  <param name="thresh">[in] - threshold value</param>
	///  <param name="type">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Numa MakeThresholdIndicator (Numa nas,
										Single thresh,
										int type)
	{
		Numa RetObj = _All.numaMakeThresholdIndicator(nas, thresh, type);
		return RetObj;
	}

	// numafunc1.c (1193, 1)
	// numaUniformSampling(nas, nsamp) as Numa
	// numaUniformSampling(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) This resamples the values in the array, using %nsamp
	/// equal divisions.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaUniformSampling/*"/>
	///  <param name="nas">[in] - input numa</param>
	///  <param name="nsamp">[in] - number of samples</param>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Numa UniformSampling (Numa nas,
								 int nsamp)
	{
		Numa RetObj = _All.numaUniformSampling(nas, nsamp);
		return RetObj;
	}

	// numafunc1.c (1258, 1)
	// numaReverse(nad, nas) as Numa
	// numaReverse(NUMA *, NUMA *) as NUMA *
	///  <summary>
	/// (1) Usage:
	/// numaReverse(nas, nas) // in-place
	/// nad = numaReverse(NULL, nas)  // makes a new one
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaReverse/*"/>
	///  <param name="nad">[in][optional] - can be null or equal to nas</param>
	///  <param name="nas">[in] - input numa</param>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Numa Reverse (Numa nas,
						 Numa nad)
	{
		Numa RetObj = _All.numaReverse(nad, nas);
		return RetObj;
	}

	// numafunc1.c (1313, 1)
	// numaLowPassIntervals(nas, thresh, maxn) as Numa
	// numaLowPassIntervals(NUMA *, l_float32, l_float32) as NUMA *
	///  <summary>
	/// (1) For each interval where the value is less than a specified
	/// fraction of the maximum, this records the left and right "x"
	/// value.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaLowPassIntervals/*"/>
	///  <param name="nas">[in] - input numa</param>
	///  <param name="thresh">[in] - threshold fraction of max in [0.0 ... 1.0]</param>
	///  <param name="maxn">[in] - for normalizing set maxn = 0.0 to use the max in nas</param>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Numa LowPassIntervals (Numa nas,
								  Single thresh,
								  Single maxn)
	{
		Numa RetObj = _All.numaLowPassIntervals(nas, thresh, maxn);
		return RetObj;
	}

	// numafunc1.c (1389, 1)
	// numaThresholdEdges(nas, thresh1, thresh2, maxn) as Numa
	// numaThresholdEdges(NUMA *, l_float32, l_float32, l_float32) as NUMA *
	///  <summary>
	/// (1) For each edge interval, where where the value is less
	/// than %thresh1 on one side, greater than %thresh2 on
	/// the other, and between these thresholds throughout the
	/// interval, this records a triplet of values: the
	/// 'left' and 'right' edges, and either +1 or -1, depending
	/// on whether the edge is rising or falling.<para/>
	///
	/// (2) No assumption is made about the value outside the array,
	/// so if the value at the array edge is between the threshold
	/// values, it is not considered part of an edge.  We start
	/// looking for edge intervals only after leaving the thresholded
	/// band.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaThresholdEdges/*"/>
	///  <param name="nas">[in] - input numa</param>
	///  <param name="thresh1">[in] - low threshold as fraction of max in [0.0 ... 1.0]</param>
	///  <param name="thresh2">[in] - high threshold as fraction of max in [0.0 ... 1.0]</param>
	///  <param name="maxn">[in] - for normalizing set maxn = 0.0 to use the max in nas</param>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Numa ThresholdEdges (Numa nas,
								Single thresh1,
								Single thresh2,
								Single maxn)
	{
		Numa RetObj = _All.numaThresholdEdges(nas, thresh1, thresh2, maxn);
		return RetObj;
	}

	// numafunc1.c (1509, 1)
	// numaGetSpanValues(na, span, pstart, pend) as int
	// numaGetSpanValues(NUMA *, l_int32, l_int32 *, l_int32 *) as l_int32
	///  <summary>
	/// numaGetSpanValues()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetSpanValues/*"/>
	///  <param name="span">[in] - span number, zero-based</param>
	///  <param name="pstart">[out][optional] - location of start of transition</param>
	///  <param name="pend">[out][optional] - location of end of transition</param>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetSpanValues (int span,
							  out int pstart,
							  out int pend)
	{
		int RetObj = _All.numaGetSpanValues(this, span, out pstart, out pend);
		return RetObj;
	}

	// numafunc1.c (1545, 1)
	// numaGetEdgeValues(na, edge, pstart, pend, psign) as int
	// numaGetEdgeValues(NUMA *, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_int32
	///  <summary>
	/// numaGetEdgeValues()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetEdgeValues/*"/>
	///  <param name="edge">[in] - edge number, zero-based</param>
	///  <param name="pstart">[out][optional] - location of start of transition</param>
	///  <param name="pend">[out][optional] - location of end of transition</param>
	///  <param name="psign">[out][optional] - transition sign: +1 is rising, -1 is falling</param>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetEdgeValues (int edge,
							  out int pstart,
							  out int pend,
							  out int psign)
	{
		int RetObj = _All.numaGetEdgeValues(this, edge, out pstart, out pend, out psign);
		return RetObj;
	}

	// numafunc1.c (1602, 1)
	// numaInterpolateEqxVal(startx, deltax, nay, type, xval, pyval) as int
	// numaInterpolateEqxVal(l_float32, l_float32, NUMA *, l_int32, l_float32, l_float32 *) as l_ok
	///  <summary>
	/// (1) Considering nay as a function of x, the x values
	/// are equally spaced<para/>
	///
	/// (2) Caller should check for valid return.
	/// For linear Lagrangian interpolation (through 2 data pts):
	/// y(x) = y1(x-x2)/(x1-x2) + y2(x-x1)/(x2-x1)
	/// For quadratic Lagrangian interpolation (through 3 data pts):
	/// y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +
	/// y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +
	/// y3(x-x1)(x-x2)/((x3-x1)(x3-x2))
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaInterpolateEqxVal/*"/>
	///  <param name="startx">[in] - xval corresponding to first element in array</param>
	///  <param name="deltax">[in] - x increment between array elements</param>
	///  <param name="nay">[in] - numa of ordinate values, assumed equally spaced</param>
	///  <param name="type">[in] - L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
	///  <param name="xval">[in] - </param>
	///  <param name="pyval">[out] - interpolated value</param>
	///   <returns>0 if OK, 1 on error e.g., if xval is outside range</returns>
	// CreateAdditiveFunction: Function/Else
	public int InterpolateEqxVal (Single startx,
								  Single deltax,
								  Numa nay,
								  int type,
								  Single xval,
								  out Single pyval)
	{
		int RetObj = _All.numaInterpolateEqxVal(startx, deltax, nay, type, xval, out pyval);
		return RetObj;
	}

	// numafunc1.c (1695, 1)
	// numaInterpolateArbxVal(nax, nay, type, xval, pyval) as int
	// numaInterpolateArbxVal(NUMA *, NUMA *, l_int32, l_float32, l_float32 *) as l_ok
	///  <summary>
	/// (1) The values in nax must be sorted in increasing order.
	/// If, additionally, they are equally spaced, you can use
	/// numaInterpolateEqxVal().<para/>
	///
	/// (2) Caller should check for valid return.<para/>
	///
	/// (3) Uses lagrangian interpolation.  See numaInterpolateEqxVal()
	/// for formulas.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaInterpolateArbxVal/*"/>
	///  <param name="nax">[in] - numa of abscissa values</param>
	///  <param name="nay">[in] - numa of ordinate values, corresponding to nax</param>
	///  <param name="type">[in] - L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
	///  <param name="xval">[in] - </param>
	///  <param name="pyval">[out] - interpolated value</param>
	///   <returns>0 if OK, 1 on error e.g., if xval is outside range</returns>
	// CreateAdditiveFunction: Function/Else
	public int InterpolateArbxVal (Numa nax,
								   Numa nay,
								   int type,
								   Single xval,
								   out Single pyval)
	{
		int RetObj = _All.numaInterpolateArbxVal(nax, nay, type, xval, out pyval);
		return RetObj;
	}

	// numafunc1.c (1812, 1)
	// numaInterpolateEqxInterval(startx, deltax, nasy, type, x0, x1, npts, pnax, pnay) as int
	// numaInterpolateEqxInterval(l_float32, l_float32, NUMA *, l_int32, l_float32, l_float32, l_int32, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// (1) Considering nasy as a function of x, the x values
	/// are equally spaced.<para/>
	///
	/// (2) This creates nay (and optionally nax) of interpolated
	/// values over the specified interval (x0, x1).<para/>
	///
	/// (3) If the interval (x0, x1) lies partially outside the array
	/// nasy (as interpreted by startx and deltax), it is an
	/// error and returns 1.<para/>
	///
	/// (4) Note that deltax is the intrinsic x-increment for the input
	/// array nasy, whereas delx is the intrinsic x-increment for the
	/// output interpolated array nay.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaInterpolateEqxInterval/*"/>
	///  <param name="startx">[in] - xval corresponding to first element in nas</param>
	///  <param name="deltax">[in] - x increment between array elements in nas</param>
	///  <param name="nasy">[in] - numa of ordinate values, assumed equally spaced</param>
	///  <param name="type">[in] - L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
	///  <param name="x0">[in] - start value of interval</param>
	///  <param name="x1">[in] - end value of interval</param>
	///  <param name="npts">[in] - number of points to evaluate function in interval</param>
	///  <param name="pnax">[out][optional] - array of x values in interval</param>
	///  <param name="pnay">[out] - array of y values in interval</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int InterpolateEqxInterval (Single startx,
									   Single deltax,
									   Numa nasy,
									   int type,
									   Single x0,
									   Single x1,
									   int npts,
									   out Numa pnay,
									   out Numa pnax)
	{
		int RetObj = _All.numaInterpolateEqxInterval(startx, deltax, nasy, type, x0, x1, npts, out pnax, out pnay);
		return RetObj;
	}

	// numafunc1.c (1900, 1)
	// numaInterpolateArbxInterval(nax, nay, type, x0, x1, npts, pnadx, pnady) as int
	// numaInterpolateArbxInterval(NUMA *, NUMA *, l_int32, l_float32, l_float32, l_int32, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// (1) The values in nax must be sorted in increasing order.
	/// If they are not sorted, we do it here, and complain.<para/>
	///
	/// (2) If the values in nax are equally spaced, you can use
	/// numaInterpolateEqxInterval().<para/>
	///
	/// (3) Caller should check for valid return.<para/>
	///
	/// (4) We don't call numaInterpolateArbxVal() for each output
	/// point, because that requires an O(n) search for
	/// each point.  Instead, we do a single O(n) pass through
	/// nax, saving the indices to be used for each output yval.<para/>
	///
	/// (5) Uses lagrangian interpolation.  See numaInterpolateEqxVal()
	/// for formulas.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaInterpolateArbxInterval/*"/>
	///  <param name="nax">[in] - numa of abscissa values</param>
	///  <param name="nay">[in] - numa of ordinate values, corresponding to nax</param>
	///  <param name="type">[in] - L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
	///  <param name="x0">[in] - start value of interval</param>
	///  <param name="x1">[in] - end value of interval</param>
	///  <param name="npts">[in] - number of points to evaluate function in interval</param>
	///  <param name="pnadx">[out][optional] - array of x values in interval</param>
	///  <param name="pnady">[out] - array of y values in interval</param>
	///   <returns>0 if OK, 1 on error e.g., if x0 or x1 is outside range</returns>
	// CreateAdditiveFunction: Function/Else
	public int InterpolateArbxInterval (Numa nax,
										Numa nay,
										int type,
										Single x0,
										Single x1,
										int npts,
										out Numa pnady,
										out Numa pnadx)
	{
		int RetObj = _All.numaInterpolateArbxInterval(nax, nay, type, x0, x1, npts, out pnadx, out pnady);
		return RetObj;
	}

	// numafunc1.c (2061, 1)
	// numaFitMax(na, pmaxval, naloc, pmaxloc) as int
	// numaFitMax(NUMA *, l_float32 *, NUMA *, l_float32 *) as l_ok
	///  <summary>
	/// If %naloc is given, there is no requirement that the
	/// data points are evenly spaced.  Lagrangian interpolation
	/// handles that.  The only requirement is that the
	/// data points are ordered so that the values in naloc
	/// are either increasing or decreasing.  We test to make
	/// sure that the sizes of na and naloc are equal, and it
	/// is assumed that the correspondences %na[i] as a function
	/// of %naloc[i] are properly arranged for all i.
	/// The formula for Lagrangian interpolation through 3 data pts is:
	/// y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +
	/// y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +
	/// y3(x-x1)(x-x2)/((x3-x1)(x3-x2))
	/// Then the derivative, using the constants (c1,c2,c3) defined below,
	/// is set to 0:
	/// y'(x) = 2x(c1+c2+c3) - c1(x2+x3) - c2(x1+x3) - c3(x1+x2) = 0
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaFitMax/*"/>
	///  <param name="pmaxval">[out] - max value</param>
	///  <param name="naloc">[in][optional] - associated numa of abscissa values</param>
	///  <param name="pmaxloc">[out] - abscissa value that gives max value in na if naloc == null, this is given as an interpolated index value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FitMax (out Single pmaxval,
					   out Single pmaxloc,
					   Numa naloc)
	{
		int RetObj = _All.numaFitMax(this, out pmaxval, naloc, out pmaxloc);
		return RetObj;
	}

	// numafunc1.c (2166, 1)
	// numaDifferentiateInterval(nax, nay, x0, x1, npts, pnadx, pnady) as int
	// numaDifferentiateInterval(NUMA *, NUMA *, l_float32, l_float32, l_int32, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// (1) The values in nax must be sorted in increasing order.
	/// If they are not sorted, it is done in the interpolation
	/// step, and a warning is issued.<para/>
	///
	/// (2) Caller should check for valid return.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaDifferentiateInterval/*"/>
	///  <param name="nax">[in] - numa of abscissa values</param>
	///  <param name="nay">[in] - numa of ordinate values, corresponding to nax</param>
	///  <param name="x0">[in] - start value of interval</param>
	///  <param name="x1">[in] - end value of interval</param>
	///  <param name="npts">[in] - number of points to evaluate function in interval</param>
	///  <param name="pnadx">[out][optional] - array of x values in interval</param>
	///  <param name="pnady">[out] - array of derivatives in interval</param>
	///   <returns>0 if OK, 1 on error e.g., if x0 or x1 is outside range</returns>
	// CreateAdditiveFunction: Function/Else
	public int DifferentiateInterval (Numa nax,
									  Numa nay,
									  Single x0,
									  Single x1,
									  int npts,
									  out Numa pnady,
									  out Numa pnadx)
	{
		int RetObj = _All.numaDifferentiateInterval(nax, nay, x0, x1, npts, out pnadx, out pnady);
		return RetObj;
	}

	// numafunc1.c (2249, 1)
	// numaIntegrateInterval(nax, nay, x0, x1, npts, psum) as int
	// numaIntegrateInterval(NUMA *, NUMA *, l_float32, l_float32, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// (1) The values in nax must be sorted in increasing order.
	/// If they are not sorted, it is done in the interpolation
	/// step, and a warning is issued.<para/>
	///
	/// (2) Caller should check for valid return.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaIntegrateInterval/*"/>
	///  <param name="nax">[in] - numa of abscissa values</param>
	///  <param name="nay">[in] - numa of ordinate values, corresponding to nax</param>
	///  <param name="x0">[in] - start value of interval</param>
	///  <param name="x1">[in] - end value of interval</param>
	///  <param name="npts">[in] - number of points to evaluate function in interval</param>
	///  <param name="psum">[out] - integral of function over interval</param>
	///   <returns>0 if OK, 1 on error e.g., if x0 or x1 is outside range</returns>
	// CreateAdditiveFunction: Function/Else
	public int IntegrateInterval (Numa nax,
								  Numa nay,
								  Single x0,
								  Single x1,
								  int npts,
								  out Single psum)
	{
		int RetObj = _All.numaIntegrateInterval(nax, nay, x0, x1, npts, out psum);
		return RetObj;
	}

	// numafunc1.c (2354, 1)
	// numaSortGeneral(na, pnasort, pnaindex, pnainvert, sortorder, sorttype) as int
	// numaSortGeneral(NUMA *, NUMA **, NUMA **, NUMA **, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) Sorting can be confusing.  Here's an array of five values with
	/// the results shown for the 3 output arrays.
	/// na  nasort naindex nainvert
	/// -----------------------------------
	/// 3 9 2 3
	/// 4 6 3 2
	/// 9 4 1 0
	/// 6 3 0 1
	/// 1 1 4 4
	/// Note that naindex is a LUT into na for the sorted array values,
	/// and nainvert directly gives the sorted index values for the
	/// input array.  It is useful to view naindex is as a map:
	/// 0  to  2
	/// 1  to  3
	/// 2  to  1
	/// 3  to  0
	/// 4  to  4
	/// and nainvert, the inverse of this map:
	/// 0  to  3
	/// 1  to  2
	/// 2  to  0
	/// 3  to  1
	/// 4  to  4
	/// We can write these relations symbolically as:
	/// nasort[i] = na[naindex[i]]
	/// na[i] = nasort[nainvert[i]]
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSortGeneral/*"/>
	///  <param name="pnasort">[out][optional] - sorted numa</param>
	///  <param name="pnaindex">[out][optional] - index of elements in na associated with each element of nasort</param>
	///  <param name="pnainvert">[out][optional] - index of elements in nasort associated with each element of na</param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING or L_SORT_DECREASING</param>
	///  <param name="sorttype">[in] - L_SHELL_SORT or L_BIN_SORT</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SortGeneral (int sortorder,
							int sorttype,
							out Numa pnasort,
							out Numa pnaindex,
							out Numa pnainvert)
	{
		int RetObj = _All.numaSortGeneral(this, out pnasort, out pnaindex, out pnainvert, sortorder, sorttype);
		return RetObj;
	}

	// numafunc1.c (2408, 1)
	// numaSortAutoSelect(nas, sortorder) as Numa
	// numaSortAutoSelect(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) This does either a shell sort or a bin sort, depending on
	/// the number of elements in nas and the dynamic range.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSortAutoSelect/*"/>
	///  <param name="nas">[in] - input numa</param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING or L_SORT_DECREASING</param>
	///   <returns>naout output sorted numa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa SortAutoSelect (Numa nas,
								int sortorder)
	{
		Numa RetObj = _All.numaSortAutoSelect(nas, sortorder);
		return RetObj;
	}

	// numafunc1.c (2444, 1)
	// numaSortIndexAutoSelect(nas, sortorder) as Numa
	// numaSortIndexAutoSelect(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) This does either a shell sort or a bin sort, depending on
	/// the number of elements in nas and the dynamic range.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSortIndexAutoSelect/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING or L_SORT_DECREASING</param>
	///   <returns>nad indices of nas, sorted by value in nas, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa SortIndexAutoSelect (Numa nas,
									 int sortorder)
	{
		Numa RetObj = _All.numaSortIndexAutoSelect(nas, sortorder);
		return RetObj;
	}

	// numafunc1.c (2480, 1)
	// numaChooseSortType(nas) as int
	// numaChooseSortType(NUMA *) as l_int32
	///  <summary>
	/// (1) This selects either a shell sort or a bin sort, depending on
	/// the number of elements in nas and the dynamic range.<para/>
	///
	/// (2) If there are negative values in nas, it selects shell sort.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaChooseSortType/*"/>
	///  <param name="nas">[in] - to be sorted</param>
	///   <returns>sorttype L_SHELL_SORT or L_BIN_SORT, or UNDEF on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int ChooseSortType (Numa nas)
	{
		int RetObj = _All.numaChooseSortType(nas);
		return RetObj;
	}

	// numafunc1.c (2531, 1)
	// numaSort(naout, nain, sortorder) as Numa
	// numaSort(NUMA *, NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) Set naout = nain for in-place otherwise, set naout = NULL.<para/>
	///
	/// (2) Source: Shell sort, modified from K[and]R, 2nd edition, p.62.
	/// Slow but simple O(n logn) sort.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSort/*"/>
	///  <param name="naout">[in] - output numa can be NULL or equal to nain</param>
	///  <param name="nain">[in] - input numa</param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING or L_SORT_DECREASING</param>
	///   <returns>naout output sorted numa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa Sort (Numa naout,
					  Numa nain,
					  int sortorder)
	{
		Numa RetObj = _All.numaSort(naout, nain, sortorder);
		return RetObj;
	}

	// numafunc1.c (2593, 1)
	// numaBinSort(nas, sortorder) as Numa
	// numaBinSort(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) Because this uses a bin sort with buckets of size 1, it
	/// is not appropriate for sorting either small arrays or
	/// arrays containing very large integer values.  For such
	/// arrays, use a standard general sort function like
	/// numaSort().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaBinSort/*"/>
	///  <param name="nas">[in] - of non-negative integers with a max that is typically less than 50,000</param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING or L_SORT_DECREASING</param>
	///   <returns>na sorted, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa BinSort (Numa nas,
						 int sortorder)
	{
		Numa RetObj = _All.numaBinSort(nas, sortorder);
		return RetObj;
	}

	// numafunc1.c (2621, 1)
	// numaGetSortIndex(na, sortorder) as Numa
	// numaGetSortIndex(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// numaGetSortIndex()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetSortIndex/*"/>
	///  <param name="sortorder">[in] - L_SORT_INCREASING or L_SORT_DECREASING</param>
	///   <returns>na giving an array of indices that would sort the input array, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetSortIndex (int sortorder)
	{
		Numa RetObj = _All.numaGetSortIndex(this, sortorder);
		return RetObj;
	}

	// numafunc1.c (2697, 1)
	// numaGetBinSortIndex(nas, sortorder) as Numa
	// numaGetBinSortIndex(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) This creates an array (or lookup table) that contains
	/// the sorted position of the elements in the input Numa.<para/>
	///
	/// (2) Because it uses a bin sort with buckets of size 1, it
	/// is not appropriate for sorting either small arrays or
	/// arrays containing very large integer values.  For such
	/// arrays, use a standard general sort function like
	/// numaGetSortIndex().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetBinSortIndex/*"/>
	///  <param name="nas">[in] - of non-negative integers with a max that is typically less than 1,000,000</param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING or L_SORT_DECREASING</param>
	///   <returns>na sorted, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetBinSortIndex (Numa nas,
								 int sortorder)
	{
		Numa RetObj = _All.numaGetBinSortIndex(nas, sortorder);
		return RetObj;
	}

	// numafunc1.c (2770, 1)
	// numaSortByIndex(nas, naindex) as Numa
	// numaSortByIndex(NUMA *, NUMA *) as NUMA *
	///  <summary>
	/// numaSortByIndex()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSortByIndex/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="naindex">[in] - na that maps from the new numa to the input numa</param>
	///   <returns>nad sorted, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa SortByIndex (Numa nas,
							 Numa naindex)
	{
		Numa RetObj = _All.numaSortByIndex(nas, naindex);
		return RetObj;
	}

	// numafunc1.c (2812, 1)
	// numaIsSorted(nas, sortorder, psorted) as int
	// numaIsSorted(NUMA *, l_int32, l_int32 *) as l_int32
	///  <summary>
	/// (1) This is a quick O(n) test if nas is sorted.  It is useful
	/// in situations where the array is likely to be already
	/// sorted, and a sort operation can be avoided.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaIsSorted/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING or L_SORT_DECREASING</param>
	///  <param name="psorted">[out] - 1 if sorted 0 if not</param>
	///   <returns>1 if OK 0 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int IsSorted (Numa nas,
						 int sortorder,
						 out int psorted)
	{
		int RetObj = _All.numaIsSorted(nas, sortorder, out psorted);
		return RetObj;
	}

	// numafunc1.c (2859, 1)
	// numaSortPair(nax, nay, sortorder, pnasx, pnasy) as int
	// numaSortPair(NUMA *, NUMA *, l_int32, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// (1) This function sorts the two input arrays, nax and nay,
	/// together, using nax as the key for sorting.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSortPair/*"/>
	///  <param name="nax">[in] - input arrays</param>
	///  <param name="nay">[in] - input arrays</param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING or L_SORT_DECREASING</param>
	///  <param name="pnasx">[out] - sorted</param>
	///  <param name="pnasy">[out] - sorted exactly in order of nasx</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SortPair (Numa nax,
						 Numa nay,
						 int sortorder,
						 out Numa pnasx,
						 out Numa pnasy)
	{
		int RetObj = _All.numaSortPair(nax, nay, sortorder, out pnasx, out pnasy);
		return RetObj;
	}

	// numafunc1.c (2910, 1)
	// numaInvertMap(nas) as Numa
	// numaInvertMap(NUMA *) as NUMA *
	///  <summary>
	/// (1) This requires that nas contain each integer from 0 to n-1.
	/// The array is typically an index array into a sort or permutation
	/// of another array.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaInvertMap/*"/>
	///  <param name="nas">[in] - </param>
	///   <returns>nad the inverted map, or NULL on error or if not invertible</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa InvertMap (Numa nas)
	{
		Numa RetObj = _All.numaInvertMap(nas);
		return RetObj;
	}

	// numafunc1.c (2969, 1)
	// numaPseudorandomSequence(size, seed) as Numa
	// numaPseudorandomSequence(l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) This uses the Durstenfeld shuffle.
	/// See: http://en.wikipedia.org/wiki/FisherYates_shuffle.
	/// Result is a pseudorandom permutation of the sequence of integers
	/// from 0 to size - 1.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaPseudorandomSequence/*"/>
	///  <param name="size">[in] - of sequence</param>
	///  <param name="seed">[in] - for random number generation</param>
	///   <returns>na pseudorandom on {0,...,size - 1}, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa PseudorandomSequence (int size,
									  int seed)
	{
		Numa RetObj = _All.numaPseudorandomSequence(size, seed);
		return RetObj;
	}

	// numafunc1.c (3008, 1)
	// numaRandomPermutation(nas, seed) as Numa
	// numaRandomPermutation(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// numaRandomPermutation()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaRandomPermutation/*"/>
	///  <param name="nas">[in] - input array</param>
	///  <param name="seed">[in] - for random number generation</param>
	///   <returns>nas randomly shuffled array, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa RandomPermutation (Numa nas,
								   int seed)
	{
		Numa RetObj = _All.numaRandomPermutation(nas, seed);
		return RetObj;
	}

	// numafunc1.c (3065, 1)
	// numaGetRankValue(na, fract, nasort, usebins, pval) as int
	// numaGetRankValue(NUMA *, l_float32, NUMA *, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// (1) Computes the rank value of a number in the %na, which is
	/// the number that is a fraction %fract from the small
	/// end of the sorted version of %na.<para/>
	///
	/// (2) If you do this multiple times for different rank values,
	/// sort the array in advance and use that for %nasort
	/// if you're only calling this once, input %nasort == NULL.<para/>
	///
	/// (3) If %usebins == 1, this uses a bin sorting method.
	/// Use this only where:
	/// the numbers are non-negative integers
	/// there are over 100 numbers
	/// the maximum value is less than about 50,000<para/>
	///
	/// (4) The advantage of using a bin sort is that it is O(n),
	/// instead of O(nlogn) for general sort routines.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetRankValue/*"/>
	///  <param name="fract">[in] - use 0.0 for smallest, 1.0 for largest</param>
	///  <param name="nasort">[in][optional] - increasing sorted version of na</param>
	///  <param name="usebins">[in] - 0 for general sort 1 for bin sort</param>
	///  <param name="pval">[out] - rank val</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRankValue (Single fract,
							 int usebins,
							 out Single pval,
							 Numa nasort)
	{
		int RetObj = _All.numaGetRankValue(this, fract, nasort, usebins, out pval);
		return RetObj;
	}

	// numafunc1.c (3119, 1)
	// numaGetMedian(na, pval) as int
	// numaGetMedian(NUMA *, l_float32 *) as l_ok
	///  <summary>
	/// (1) Computes the median value of the numbers in the numa, by
	/// sorting and finding the middle value in the sorted array.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetMedian/*"/>
	///  <param name="pval">[out] - median value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMedian (out Single pval)
	{
		int RetObj = _All.numaGetMedian(this, out pval);
		return RetObj;
	}

	// numafunc1.c (3150, 1)
	// numaGetBinnedMedian(na, pval) as int
	// numaGetBinnedMedian(NUMA *, l_int32 *) as l_ok
	///  <summary>
	/// (1) Computes the median value of the numbers in the numa,
	/// using bin sort and finding the middle value in the sorted array.<para/>
	///
	/// (2) See numaGetRankValue() for conditions on na for which
	/// this should be used.  Otherwise, use numaGetMedian().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetBinnedMedian/*"/>
	///  <param name="pval">[out] - integer median value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetBinnedMedian (out int pval)
	{
		int RetObj = _All.numaGetBinnedMedian(this, out pval);
		return RetObj;
	}

	// numafunc1.c (3187, 1)
	// numaGetMode(na, pval, pcount) as int
	// numaGetMode(NUMA *, l_float32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) Computes the mode value of the numbers in the numa, by
	/// sorting and finding the value of the number with the
	/// largest count.<para/>
	///
	/// (2) Optionally, also returns that count.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetMode/*"/>
	///  <param name="pval">[out] - mode val</param>
	///  <param name="pcount">[out][optional] - mode count</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMode (out Single pval,
						out int pcount)
	{
		int RetObj = _All.numaGetMode(this, out pval, out pcount);
		return RetObj;
	}

	// numafunc1.c (3266, 1)
	// numaGetMedianVariation(na, pmedval, pmedvar) as int
	// numaGetMedianVariation(NUMA *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) Finds the median of the absolute value of the variation from
	/// the median value in the array.  Why take the absolute value?
	/// Consider the case where you have values equally distributed
	/// about both sides of a median value.  Without taking the absolute
	/// value of the differences, you will get 0 for the variation,
	/// and this is not useful.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetMedianVariation/*"/>
	///  <param name="pmedval">[out][optional] - median value</param>
	///  <param name="pmedvar">[out] - median variation from median val</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMedianVariation (out Single pmedvar,
								   out Single pmedval)
	{
		int RetObj = _All.numaGetMedianVariation(this, out pmedval, out pmedvar);
		return RetObj;
	}

	// numafunc1.c (3319, 1)
	// numaJoin(nad, nas, istart, iend) as int
	// numaJoin(NUMA *, NUMA *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) istart  is smaller 0 is taken to mean 'read from the start' (istart = 0)<para/>
	///
	/// (2) iend  is smaller 0 means 'read to the end'<para/>
	///
	/// (3) if nas == NULL, this is a no-op
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaJoin/*"/>
	///  <param name="nad">[in] - dest numa add to this one</param>
	///  <param name="nas">[in][optional] - source numa add from this one</param>
	///  <param name="istart">[in] - starting index in nas</param>
	///  <param name="iend">[in] - ending index in nas use -1 to cat all</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Join (Numa nad,
					 int istart,
					 int iend,
					 Numa nas)
	{
		int RetObj = _All.numaJoin(nad, nas, istart, iend);
		return RetObj;
	}

	// numafunc2.c (165, 1)
	// numaErode(nas, size) as Numa
	// numaErode(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) The structuring element (sel) is linear, all "hits"<para/>
	///
	/// (2) If size == 1, this returns a copy<para/>
	///
	/// (3) General comment.  The morphological operations are equivalent
	/// to those that would be performed on a 1-dimensional fpix.
	/// However, because we have not implemented morphological
	/// operations on fpix, we do this here.  Because it is only
	/// 1 dimensional, there is no reason to use the more
	/// complicated van Herk/Gil-Werman algorithm, and we do it
	/// by brute force.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaErode/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="size">[in] - of sel greater than 0, odd origin implicitly in center</param>
	///   <returns>nad eroded, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa Erode (Numa nas,
					   int size)
	{
		Numa RetObj = _All.numaErode(nas, size);
		return RetObj;
	}

	// numafunc2.c (233, 1)
	// numaDilate(nas, size) as Numa
	// numaDilate(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) The structuring element (sel) is linear, all "hits"<para/>
	///
	/// (2) If size == 1, this returns a copy
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaDilate/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="size">[in] - of sel greater than 0, odd origin implicitly in center</param>
	///   <returns>nad dilated, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa Dilate (Numa nas,
						int size)
	{
		Numa RetObj = _All.numaDilate(nas, size);
		return RetObj;
	}

	// numafunc2.c (301, 1)
	// numaOpen(nas, size) as Numa
	// numaOpen(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) The structuring element (sel) is linear, all "hits"<para/>
	///
	/// (2) If size == 1, this returns a copy
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaOpen/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="size">[in] - of sel greater than 0, odd origin implicitly in center</param>
	///   <returns>nad opened, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa Open (Numa nas,
					  int size)
	{
		Numa RetObj = _All.numaOpen(nas, size);
		return RetObj;
	}

	// numafunc2.c (347, 1)
	// numaClose(nas, size) as Numa
	// numaClose(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) The structuring element (sel) is linear, all "hits"<para/>
	///
	/// (2) If size == 1, this returns a copy<para/>
	///
	/// (3) We add a border before doing this operation, for the same
	/// reason that we add a border to a pix before doing a safe closing.
	/// Without the border, a small component near the border gets
	/// clipped at the border on dilation, and can be entirely removed
	/// by the following erosion, violating the basic extensivity
	/// property of closing.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaClose/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="size">[in] - of sel greater than 0, odd origin implicitly in center</param>
	///   <returns>nad opened, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa Close (Numa nas,
					   int size)
	{
		Numa RetObj = _All.numaClose(nas, size);
		return RetObj;
	}

	// numafunc2.c (394, 1)
	// numaTransform(nas, shift, scale) as Numa
	// numaTransform(NUMA *, l_float32, l_float32) as NUMA *
	///  <summary>
	/// (1) Each number is shifted before scaling.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaTransform/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="shift">[in] - add this to each number</param>
	///  <param name="scale">[in] - multiply each number by this</param>
	///   <returns>nad with all values shifted and scaled, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa Transform (Numa nas,
						   Single shift,
						   Single scale)
	{
		Numa RetObj = _All.numaTransform(nas, shift, scale);
		return RetObj;
	}

	// numafunc2.c (431, 1)
	// numaSimpleStats(na, first, last, pmean, pvar, prvar) as int
	// numaSimpleStats(NUMA *, l_int32, l_int32, l_float32 *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// numaSimpleStats()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSimpleStats/*"/>
	///  <param name="first">[in] - first element to use</param>
	///  <param name="last">[in] - last element to use 0 to go to the end</param>
	///  <param name="pmean">[out][optional] - mean value</param>
	///  <param name="pvar">[out][optional] - variance</param>
	///  <param name="prvar">[out][optional] - rms deviation from the mean</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SimpleStats (int first,
							int last,
							out Single pmean,
							out Single pvar,
							out Single prvar)
	{
		int RetObj = _All.numaSimpleStats(this, first, last, out pmean, out pvar, out prvar);
		return RetObj;
	}

	// numafunc2.c (511, 1)
	// numaWindowedStats(nas, wc, pnam, pnams, pnav, pnarv) as int
	// numaWindowedStats(NUMA *, l_int32, NUMA **, NUMA **, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// (1) This is a high-level convenience function for calculating
	/// any or all of these derived arrays.<para/>
	///
	/// (2) These statistical measures over the values in the
	/// rectangular window are:
	/// ~ average value: [x]  (nam)
	/// ~ average squared value: [xx] (nams)
	/// ~ variance: [(x - [x])(x - [x])] = [xx] - [x][x]  (nav)
	/// ~ square-root of variance: (narv)
	/// where the brackets [ .. ] indicate that the average value is
	/// to be taken over the window.<para/>
	///
	/// (3) Note that the variance is just the mean square difference from
	/// the mean value and the square root of the variance is the
	/// root mean square difference from the mean, sometimes also
	/// called the 'standard deviation'.<para/>
	///
	/// (4) Internally, use mirrored borders to handle values near the
	/// end of each array.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaWindowedStats/*"/>
	///  <param name="nas">[in] - input numa</param>
	///  <param name="wc">[in] - half width of the window</param>
	///  <param name="pnam">[out][optional] - mean value in window</param>
	///  <param name="pnams">[out][optional] - mean square value in window</param>
	///  <param name="pnav">[out][optional] - variance in window</param>
	///  <param name="pnarv">[out][optional] - rms deviation from the mean</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WindowedStats (Numa nas,
							  int wc,
							  out Numa pnam,
							  out Numa pnams,
							  out Numa pnav,
							  out Numa pnarv)
	{
		int RetObj = _All.numaWindowedStats(nas, wc, out pnam, out pnams, out pnav, out pnarv);
		return RetObj;
	}

	// numafunc2.c (562, 1)
	// numaWindowedMean(nas, wc) as Numa
	// numaWindowedMean(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) This is a convolution.  The window has width = 2  %wc + 1.<para/>
	///
	/// (2) We add a mirrored border of size %wc to each end of the array.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaWindowedMean/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="wc">[in] - half width of the convolution window</param>
	///   <returns>nad after low-pass filtering, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa WindowedMean (Numa nas,
							  int wc)
	{
		Numa RetObj = _All.numaWindowedMean(nas, wc);
		return RetObj;
	}

	// numafunc2.c (622, 1)
	// numaWindowedMeanSquare(nas, wc) as Numa
	// numaWindowedMeanSquare(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) The window has width = 2  %wc + 1.<para/>
	///
	/// (2) We add a mirrored border of size %wc to each end of the array.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaWindowedMeanSquare/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="wc">[in] - half width of the window</param>
	///   <returns>nad containing windowed mean square values, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa WindowedMeanSquare (Numa nas,
									int wc)
	{
		Numa RetObj = _All.numaWindowedMeanSquare(nas, wc);
		return RetObj;
	}

	// numafunc2.c (690, 1)
	// numaWindowedVariance(nam, nams, pnav, pnarv) as int
	// numaWindowedVariance(NUMA *, NUMA *, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// (1) The numas of windowed mean and mean square are precomputed,
	/// using numaWindowedMean() and numaWindowedMeanSquare().<para/>
	///
	/// (2) Either or both of the variance and square-root of variance
	/// are returned, where the variance is the average over the
	/// window of the mean square difference of the pixel value
	/// from the mean:
	/// [(x - [x])(x - [x])] = [xx] - [x][x]
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaWindowedVariance/*"/>
	///  <param name="nam">[in] - windowed mean values</param>
	///  <param name="nams">[in] - windowed mean square values</param>
	///  <param name="pnav">[out][optional] - numa of variance -- the ms deviation from the mean</param>
	///  <param name="pnarv">[out][optional] - numa of rms deviation from the mean</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WindowedVariance (Numa nam,
								 Numa nams,
								 out Numa pnav,
								 out Numa pnarv)
	{
		int RetObj = _All.numaWindowedVariance(nam, nams, out pnav, out pnarv);
		return RetObj;
	}

	// numafunc2.c (758, 1)
	// numaWindowedMedian(nas, halfwin) as Numa
	// numaWindowedMedian(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) The requested window has width = 2  %halfwin + 1.<para/>
	///
	/// (2) If the input nas has less then 3 elements, return a copy.<para/>
	///
	/// (3) If the filter is too small (%halfwin smaller or equal 0), return a copy.<para/>
	///
	/// (4) If the filter is too large, it is reduced in size.<para/>
	///
	/// (5) We add a mirrored border of size %halfwin to each end of
	/// the array to simplify the calculation by avoiding end-effects.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaWindowedMedian/*"/>
	///  <param name="nas">[in] - </param>
	///  <param name="halfwin">[in] - half width of window over which the median is found</param>
	///   <returns>nad after windowed median filtering, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa WindowedMedian (Numa nas,
								int halfwin)
	{
		Numa RetObj = _All.numaWindowedMedian(nas, halfwin);
		return RetObj;
	}

	// numafunc2.c (807, 1)
	// numaConvertToInt(nas) as Numa
	// numaConvertToInt(NUMA *) as NUMA *
	///  <summary>
	/// numaConvertToInt()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaConvertToInt/*"/>
	///  <param name="nas">[in] - source numa</param>
	///   <returns>na with all values rounded to nearest integer, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa ConvertToInt (Numa nas)
	{
		Numa RetObj = _All.numaConvertToInt(nas);
		return RetObj;
	}

	// numafunc2.c (859, 1)
	// numaMakeHistogram(na, maxbins, pbinsize, pbinstart) as Numa
	// numaMakeHistogram(NUMA *, l_int32, l_int32 *, l_int32 *) as NUMA *
	///  <summary>
	/// (1) This simple interface is designed for integer data.
	/// The bins are of integer width and start on integer boundaries,
	/// so the results on float data will not have high precision.<para/>
	///
	/// (2) Specify the max number of input bins. Then %binsize,
	/// the size of bins necessary to accommodate the input data,
	/// is returned.  It is one of the sequence:
	/// {1, 2, 5, 10, 20, 50, ...}.<para/>
	///
	/// (3) If [and]binstart is given, all values are accommodated,
	/// and the min value of the starting bin is returned.
	/// Otherwise, all negative values are discarded and
	/// the histogram bins start at 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaMakeHistogram/*"/>
	///  <param name="maxbins">[in] - max number of histogram bins</param>
	///  <param name="pbinsize">[out] - size of histogram bins</param>
	///  <param name="pbinstart">[out][optional] - start val of minimum bin input NULL to force start at 0</param>
	///   <returns>na consisiting of histogram of integerized values, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa MakeHistogram (int maxbins,
							   out int pbinsize,
							   out int pbinstart)
	{
		Numa RetObj = _All.numaMakeHistogram(this, maxbins, out pbinsize, out pbinstart);
		return RetObj;
	}

	// numafunc2.c (971, 1)
	// numaMakeHistogramAuto(na, maxbins) as Numa
	// numaMakeHistogramAuto(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// (1) This simple interface is designed for accurate binning
	/// of both integer and float data.<para/>
	///
	/// (2) If the array data is integers, and the range of integers
	/// is smaller than %maxbins, they are binned as they fall,
	/// with binsize = 1.<para/>
	///
	/// (3) If the range of data, (maxval - minval), is larger than
	/// %maxbins, or if the data is floats, they are binned into
	/// exactly %maxbins bins.<para/>
	///
	/// (4) Unlike numaMakeHistogram(), these bins in general have
	/// non-integer location and width, even for integer data.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaMakeHistogramAuto/*"/>
	///  <param name="maxbins">[in] - max number of histogram bins greater or equal 1</param>
	///   <returns>na consisiting of histogram of quantized float values, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa MakeHistogramAuto (int maxbins)
	{
		Numa RetObj = _All.numaMakeHistogramAuto(this, maxbins);
		return RetObj;
	}

	// numafunc2.c (1055, 1)
	// numaMakeHistogramClipped(na, binsize, maxsize) as Numa
	// numaMakeHistogramClipped(NUMA *, l_float32, l_float32) as NUMA *
	///  <summary>
	/// (1) This simple function generates a histogram of values
	/// from na, discarding all values  is smaller 0.0 or greater than
	/// min(%maxsize, maxval), where maxval is the maximum value in na.
	/// The histogram data is put in bins of size delx = %binsize,
	/// starting at x = 0.0.  We use as many bins as are
	/// needed to hold the data.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaMakeHistogramClipped/*"/>
	///  <param name="binsize">[in] - typically 1.0</param>
	///  <param name="maxsize">[in] - of histogram ordinate</param>
	///   <returns>na histogram of bins of size %binsize, starting with the na[0] (x = 0.0 and going up to a maximum of x = %maxsize, by increments of %binsize), or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa MakeHistogramClipped (Single binsize,
									  Single maxsize)
	{
		Numa RetObj = _All.numaMakeHistogramClipped(this, binsize, maxsize);
		return RetObj;
	}

	// numafunc2.c (1104, 1)
	// numaRebinHistogram(nas, newsize) as Numa
	// numaRebinHistogram(NUMA *, l_int32) as NUMA *
	///  <summary>
	/// numaRebinHistogram()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaRebinHistogram/*"/>
	///  <param name="nas">[in] - input histogram</param>
	///  <param name="newsize">[in] - number of old bins contained in each new bin</param>
	///   <returns>nad more coarsely re-binned histogram, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa RebinHistogram (Numa nas,
								int newsize)
	{
		Numa RetObj = _All.numaRebinHistogram(nas, newsize);
		return RetObj;
	}

	// numafunc2.c (1153, 1)
	// numaNormalizeHistogram(nas, tsum) as Numa
	// numaNormalizeHistogram(NUMA *, l_float32) as NUMA *
	///  <summary>
	/// numaNormalizeHistogram()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaNormalizeHistogram/*"/>
	///  <param name="nas">[in] - input histogram</param>
	///  <param name="tsum">[in] - target sum of all numbers in dest histogram e.g., use %tsum= 1.0 if this represents a probability distribution</param>
	///   <returns>nad normalized histogram, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa NormalizeHistogram (Numa nas,
									Single tsum)
	{
		Numa RetObj = _All.numaNormalizeHistogram(nas, tsum);
		return RetObj;
	}

	// numafunc2.c (1235, 1)
	// numaGetStatsUsingHistogram(na, maxbins, pmin, pmax, pmean, pvariance, pmedian, rank, prval, phisto) as int
	// numaGetStatsUsingHistogram(NUMA *, l_int32, l_float32 *, l_float32 *, l_float32 *, l_float32 *, l_float32 *, l_float32, l_float32 *, NUMA **) as l_ok
	///  <summary>
	/// (1) This is a simple interface for gathering statistics
	/// from a numa, where a histogram is used 'under the covers'
	/// to avoid sorting if a rank value is requested.  In that case,
	/// by using a histogram we are trading speed for accuracy, because
	/// the values in %na are quantized to the center of a set of bins.<para/>
	///
	/// (2) If the median, other rank value, or histogram are not requested,
	/// the calculation is all performed on the input Numa.<para/>
	///
	/// (3) The variance is the average of the square of the
	/// difference from the mean.  The median is the value in na
	/// with rank 0.5.<para/>
	///
	/// (4) There are two situations where this gives rank results with
	/// accuracy comparable to computing stastics directly on the input
	/// data, without binning into a histogram:
	/// (a) the data is integers and the range of data is less than
	/// %maxbins, and
	/// (b) the data is floats and the range is small compared to
	/// %maxbins, so that the binsize is much less than 1.<para/>
	///
	/// (5) If a histogram is used and the numbers in the Numa extend
	/// over a large range, you can limit the required storage by
	/// specifying the maximum number of bins in the histogram.
	/// Use %maxbins == 0 to force the bin size to be 1.<para/>
	///
	/// (6) This optionally returns the median and one arbitrary rank value.
	/// If you need several rank values, return the histogram and use
	/// numaHistogramGetValFromRank(nah, rank, [and]rval)
	/// multiple times.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetStatsUsingHistogram/*"/>
	///  <param name="maxbins">[in] - the maximum number of bins to be allowed in the histogram use an integer larger than the largest number in %na for consecutive integer bins</param>
	///  <param name="pmin">[out][optional] - min value of set</param>
	///  <param name="pmax">[out][optional] - max value of set</param>
	///  <param name="pmean">[out][optional] - mean value of set</param>
	///  <param name="pvariance">[out][optional] - variance</param>
	///  <param name="pmedian">[out][optional] - median value of set</param>
	///  <param name="rank">[in] - in [0.0 ... 1.0] median has a rank 0.5 ignored if [and]rval == NULL</param>
	///  <param name="prval">[out][optional] - value in na corresponding to %rank</param>
	///  <param name="phisto">[out][optional] - Numa histogram use NULL to prevent</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetStatsUsingHistogram (int maxbins,
									   Single rank,
									   out Single pmin,
									   out Single pmax,
									   out Single pmean,
									   out Single pvariance,
									   out Single pmedian,
									   out Single prval,
									   out Numa phisto)
	{
		int RetObj = _All.numaGetStatsUsingHistogram(this, maxbins, out pmin, out pmax, out pmean, out pvariance, out pmedian, rank, out prval, out phisto);
		return RetObj;
	}

	// numafunc2.c (1326, 1)
	// numaGetHistogramStats(nahisto, startx, deltax, pxmean, pxmedian, pxmode, pxvariance) as int
	// numaGetHistogramStats(NUMA *, l_float32, l_float32, l_float32 *, l_float32 *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) If the histogram represents the relation y(x), the
	/// computed values that are returned are the x values.
	/// These are NOT the bucket indices i they are related to the
	/// bucket indices by
	/// x(i) = startx + i  deltax
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetHistogramStats/*"/>
	///  <param name="nahisto">[in] - histogram: y(x(i)), i = 0 ... nbins - 1</param>
	///  <param name="startx">[in] - x value of first bin: x(0)</param>
	///  <param name="deltax">[in] - x increment between bins the bin size x(1) - x(0)</param>
	///  <param name="pxmean">[out][optional] - mean value of histogram</param>
	///  <param name="pxmedian">[out][optional] - median value of histogram</param>
	///  <param name="pxmode">[out][optional] - mode value of histogram: xmode = x(imode), where y(xmode) greater or equal y(x(i)) for all i != imode</param>
	///  <param name="pxvariance">[out][optional] - variance of x</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetHistogramStats (Numa nahisto,
								  Single startx,
								  Single deltax,
								  out Single pxmean,
								  out Single pxmedian,
								  out Single pxmode,
								  out Single pxvariance)
	{
		int RetObj = _All.numaGetHistogramStats(nahisto, startx, deltax, out pxmean, out pxmedian, out pxmode, out pxvariance);
		return RetObj;
	}

	// numafunc2.c (1375, 1)
	// numaGetHistogramStatsOnInterval(nahisto, startx, deltax, ifirst, ilast, pxmean, pxmedian, pxmode, pxvariance) as int
	// numaGetHistogramStatsOnInterval(NUMA *, l_float32, l_float32, l_int32, l_int32, l_float32 *, l_float32 *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) If the histogram represents the relation y(x), the
	/// computed values that are returned are the x values.
	/// These are NOT the bucket indices i they are related to the
	/// bucket indices by
	/// x(i) = startx + i  deltax
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetHistogramStatsOnInterval/*"/>
	///  <param name="nahisto">[in] - histogram: y(x(i)), i = 0 ... nbins - 1</param>
	///  <param name="startx">[in] - x value of first bin: x(0)</param>
	///  <param name="deltax">[in] - x increment between bins the bin size x(1) - x(0)</param>
	///  <param name="ifirst">[in] - first bin to use for collecting stats</param>
	///  <param name="ilast">[in] - last bin for collecting stats use 0 to go to the end</param>
	///  <param name="pxmean">[out][optional] - mean value of histogram</param>
	///  <param name="pxmedian">[out][optional] - median value of histogram</param>
	///  <param name="pxmode">[out][optional] - mode value of histogram: xmode = x(imode), where y(xmode) greater or equal y(x(i)) for all i != imode</param>
	///  <param name="pxvariance">[out][optional] - variance of x</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetHistogramStatsOnInterval (Numa nahisto,
											Single startx,
											Single deltax,
											int ifirst,
											int ilast,
											out Single pxmean,
											out Single pxmedian,
											out Single pxmode,
											out Single pxvariance)
	{
		int RetObj = _All.numaGetHistogramStatsOnInterval(nahisto, startx, deltax, ifirst, ilast, out pxmean, out pxmedian, out pxmode, out pxvariance);
		return RetObj;
	}

	// numafunc2.c (1462, 1)
	// numaMakeRankFromHistogram(startx, deltax, nasy, npts, pnax, pnay) as int
	// numaMakeRankFromHistogram(l_float32, l_float32, NUMA *, l_int32, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// numaMakeRankFromHistogram()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaMakeRankFromHistogram/*"/>
	///  <param name="startx">[in] - xval corresponding to first element in nay</param>
	///  <param name="deltax">[in] - x increment between array elements in nay</param>
	///  <param name="nasy">[in] - input histogram, assumed equally spaced</param>
	///  <param name="npts">[in] - number of points to evaluate rank function</param>
	///  <param name="pnax">[out][optional] - array of x values in range</param>
	///  <param name="pnay">[out] - rank array of specified npts</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int MakeRankFromHistogram (Single startx,
									  Single deltax,
									  Numa nasy,
									  int npts,
									  out Numa pnay,
									  out Numa pnax)
	{
		int RetObj = _All.numaMakeRankFromHistogram(startx, deltax, nasy, npts, out pnax, out pnay);
		return RetObj;
	}

	// numafunc2.c (1530, 1)
	// numaHistogramGetRankFromVal(na, rval, prank) as int
	// numaHistogramGetRankFromVal(NUMA *, l_float32, l_float32 *) as l_ok
	///  <summary>
	/// (1) If we think of the histogram as a function y(x), normalized
	/// to 1, for a given input value of x, this computes the
	/// rank of x, which is the integral of y(x) from the start
	/// value of x to the input value.<para/>
	///
	/// (2) This function only makes sense when applied to a Numa that
	/// is a histogram.  The values in the histogram can be ints and
	/// floats, and are computed as floats.  The rank is returned
	/// as a float between 0.0 and 1.0.<para/>
	///
	/// (3) The numa parameters startx and binsize are used to
	/// compute x from the Numa index i.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaHistogramGetRankFromVal/*"/>
	///  <param name="rval">[in] - value of input sample for which we want the rank</param>
	///  <param name="prank">[out] - fraction of total samples below rval</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int HistogramGetRankFromVal (Single rval,
										out Single prank)
	{
		int RetObj = _All.numaHistogramGetRankFromVal(this, rval, out prank);
		return RetObj;
	}

	// numafunc2.c (1601, 1)
	// numaHistogramGetValFromRank(na, rank, prval) as int
	// numaHistogramGetValFromRank(NUMA *, l_float32, l_float32 *) as l_ok
	///  <summary>
	/// (1) If we think of the histogram as a function y(x), this returns
	/// the value x such that the integral of y(x) from the start
	/// value to x gives the fraction 'rank' of the integral
	/// of y(x) over all bins.<para/>
	///
	/// (2) This function only makes sense when applied to a Numa that
	/// is a histogram.  The values in the histogram can be ints and
	/// floats, and are computed as floats.  The val is returned
	/// as a float, even though the buckets are of integer width.<para/>
	///
	/// (3) The numa parameters startx and binsize are used to
	/// compute x from the Numa index i.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaHistogramGetValFromRank/*"/>
	///  <param name="rank">[in] - fraction of total samples</param>
	///  <param name="prval">[out] - approx. to the bin value</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int HistogramGetValFromRank (Single rank,
										out Single prval)
	{
		int RetObj = _All.numaHistogramGetValFromRank(this, rank, out prval);
		return RetObj;
	}

	// numafunc2.c (1681, 1)
	// numaDiscretizeRankAndIntensity(na, nbins, pnarbin, pnam, pnar, pnabb) as int
	// numaDiscretizeRankAndIntensity(NUMA *, l_int32, NUMA **, NUMA **, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// (1) We are inverting the rank(intensity) function to get
	/// the intensity(rank) function at %nbins equally spaced
	/// values of rank between 0.0 and 1.0.  We save integer values
	/// for the intensity.<para/>
	///
	/// (2) We are using the word "intensity" to describe the type of
	/// array values, but any array of non-negative numbers will work.<para/>
	///
	/// (3) The output arrays give the following mappings, where the
	/// input is a normalized histogram of array values:
	/// array values to  rank bin number  (narbin)
	/// rank bin number  to  median array value in bin (nam)
	/// array values to  cumulative norm = rank  (nar)
	/// rank bin number  to  array value at right bin edge (nabb)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaDiscretizeRankAndIntensity/*"/>
	///  <param name="nbins">[in] - number of bins at which the rank is divided</param>
	///  <param name="pnarbin">[out][optional] - rank bin value vs intensity</param>
	///  <param name="pnam">[out][optional] - median intensity in a bin vs rank bin value, with %nbins of discretized rank values</param>
	///  <param name="pnar">[out][optional] - rank vs intensity this is a cumulative norm histogram</param>
	///  <param name="pnabb">[out][optional] - intensity at the right bin boundary vs rank bin</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int DiscretizeRankAndIntensity (int nbins,
										   out Numa pnarbin,
										   out Numa pnam,
										   out Numa pnar,
										   out Numa pnabb)
	{
		int RetObj = _All.numaDiscretizeRankAndIntensity(this, nbins, out pnarbin, out pnam, out pnar, out pnabb);
		return RetObj;
	}

	// numafunc2.c (1829, 1)
	// numaGetRankBinValues(na, nbins, pnarbin, pnam) as int
	// numaGetRankBinValues(NUMA *, l_int32, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// (1) Simple interface for getting a binned rank representation
	/// of an input array of values.  This returns two mappings:
	/// array value to  rank bin number  (narbin)
	/// rank bin number to  median array value in each rank bin (nam)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaGetRankBinValues/*"/>
	///  <param name="nbins">[in] - number of bins at which the rank is divided</param>
	///  <param name="pnarbin">[out][optional] - rank bin value vs array value</param>
	///  <param name="pnam">[out][optional] - median intensity in a bin vs rank bin value, with %nbins of discretized rank values</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRankBinValues (int nbins,
								 out Numa pnarbin,
								 out Numa pnam)
	{
		int RetObj = _All.numaGetRankBinValues(this, nbins, out pnarbin, out pnam);
		return RetObj;
	}

	// numafunc2.c (1924, 1)
	// numaSplitDistribution(na, scorefract, psplitindex, pave1, pave2, pnum1, pnum2, pnascore) as int
	// numaSplitDistribution(NUMA *, l_float32, l_int32 *, l_float32 *, l_float32 *, l_float32 *, l_float32 *, NUMA **) as l_ok
	///  <summary>
	/// (1) This function is intended to be used on a distribution of
	/// values that represent two sets, such as a histogram of
	/// pixel values for an image with a fg and bg, and the goal
	/// is to determine the averages of the two sets and the
	/// best splitting point.<para/>
	///
	/// (2) The Otsu method finds a split point that divides the distribution
	/// into two parts by maximizing a score function that is the
	/// product of two terms:
	/// (a) the square of the difference of centroids, (ave1 - ave2)^2
	/// (b) fract1  (1 - fract1)
	/// where fract1 is the fraction in the lower distribution.<para/>
	///
	/// (3) This works well for images where the fg and bg are
	/// each relatively homogeneous and well-separated in color.
	/// However, if the actual fg and bg sets are very different
	/// in size, and the bg is highly varied, as can occur in some
	/// scanned document images, this will bias the split point
	/// into the larger "bump" (i.e., toward the point where the
	/// (b) term reaches its maximum of 0.25 at fract1 = 0.5.
	/// To avoid this, we define a range of values near the
	/// maximum of the score function, and choose the value within
	/// this range such that the histogram itself has a minimum value.
	/// The range is determined by scorefract: we include all abscissa
	/// values to the left and right of the value that maximizes the
	/// score, such that the score stays above (1 - scorefract)  maxscore.
	/// The intuition behind this modification is to try to find
	/// a split point that both has a high variance score and is
	/// at or near a minimum in the histogram, so that the histogram
	/// slope is small at the split point.<para/>
	///
	/// (4) We normalize the score so that if the two distributions
	/// were of equal size and at opposite ends of the numa, the
	/// score would be 1.0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSplitDistribution/*"/>
	///  <param name="scorefract">[in] - fraction of the max score, used to determine the range over which the histogram min is searched</param>
	///  <param name="psplitindex">[out][optional] - index for splitting</param>
	///  <param name="pave1">[out][optional] - average of lower distribution</param>
	///  <param name="pave2">[out][optional] - average of upper distribution</param>
	///  <param name="pnum1">[out][optional] - population of lower distribution</param>
	///  <param name="pnum2">[out][optional] - population of upper distribution</param>
	///  <param name="pnascore">[out][optional] - for debugging otherwise use NULL</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SplitDistribution (Single scorefract,
								  out int psplitindex,
								  out Single pave1,
								  out Single pave2,
								  out Single pnum1,
								  out Single pnum2,
								  out Numa pnascore)
	{
		int RetObj = _All.numaSplitDistribution(this, scorefract, out psplitindex, out pave1, out pave2, out pnum1, out pnum2, out pnascore);
		return RetObj;
	}

	// numafunc2.c (2152, 1)
	// numaEarthMoverDistance(na1, na2, pdist) as int
	// numaEarthMoverDistance(NUMA *, NUMA *, l_float32 *) as l_ok
	///  <summary>
	/// (1) The two numas must have the same size.  They do not need to be
	/// normalized to the same sum before applying the function.<para/>
	///
	/// (2) For a 1D discrete function, the implementation of the EMD
	/// is trivial.  Just keep filling or emptying buckets in one numa
	/// to match the amount in the other, moving sequentially along
	/// both arrays.<para/>
	///
	/// (3) We divide the sum of the absolute value of everything moved
	/// (by 1 unit at a time) by the sum of the numa (amount of "earth")
	/// to get the average distance that the "earth" was moved.
	/// This is the value returned here.<para/>
	///
	/// (4) The caller can do a further normalization, by the number of
	/// buckets (minus 1), to get the EM distance as a fraction of
	/// the maximum possible distance, which is n-1.  This fraction
	/// is 1.0 for the situation where all the 'earth' in the first
	/// array is at one end, and all in the second array is at the
	/// other end.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaEarthMoverDistance/*"/>
	///  <param name="na1">[in] - two numas of the same size, typically histograms</param>
	///  <param name="na2">[in] - two numas of the same size, typically histograms</param>
	///  <param name="pdist">[out] - EM distance</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int EarthMoverDistance (Numa na1,
								   Numa na2,
								   out Single pdist)
	{
		int RetObj = _All.numaEarthMoverDistance(na1, na2, out pdist);
		return RetObj;
	}

	// numafunc2.c (2333, 1)
	// numaFindPeaks(nas, nmax, fract1, fract2) as Numa
	// numaFindPeaks(NUMA *, l_int32, l_float32, l_float32) as NUMA *
	///  <summary>
	/// (1) The returned na consists of sets of four numbers representing
	/// the peak, in the following order:
	/// left edge peak center right edge normalized peak area
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaFindPeaks/*"/>
	///  <param name="nas">[in] - source numa</param>
	///  <param name="nmax">[in] - max number of peaks to be found</param>
	///  <param name="fract1">[in] - min fraction of peak value</param>
	///  <param name="fract2">[in] - min slope</param>
	///   <returns>peak na, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa FindPeaks (Numa nas,
						   int nmax,
						   Single fract1,
						   Single fract2)
	{
		Numa RetObj = _All.numaFindPeaks(nas, nmax, fract1, fract2);
		return RetObj;
	}

	// numafunc2.c (2448, 1)
	// numaFindExtrema(nas, delta, pnav) as Numa
	// numaFindExtrema(NUMA *, l_float32, NUMA **) as NUMA *
	///  <summary>
	/// (1) This returns a sequence of extrema (peaks and valleys).<para/>
	///
	/// (2) The algorithm is analogous to that for determining
	/// mountain peaks.  Suppose we have a local peak, with
	/// bumps on the side.  Under what conditions can we consider
	/// those 'bumps' to be actual peaks?  The answer: if the
	/// bump is separated from the peak by a saddle that is at
	/// least 500 feet below the bump.<para/>
	///
	/// (3) Operationally, suppose we are looking for a peak.
	/// We are keeping the largest value we've seen since the
	/// last valley, and are looking for a value that is delta
	/// BELOW our current peak.  When we find such a value,
	/// we label the peak, use the current value to label the
	/// valley, and then do the same operation in reverse (looking
	/// for a valley).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaFindExtrema/*"/>
	///  <param name="nas">[in] - input values</param>
	///  <param name="delta">[in] - relative amount to resolve peaks and valleys</param>
	///  <param name="pnav">[out][optional] - values of extrema</param>
	///   <returns>nad (locations of extrema, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa FindExtrema (Numa nas,
							 Single delta,
							 out Numa pnav)
	{
		Numa RetObj = _All.numaFindExtrema(nas, delta, out pnav);
		return RetObj;
	}

	// numafunc2.c (2544, 1)
	// numaCountReversals(nas, minreversal, pnr, pnrpl) as int
	// numaCountReversals(NUMA *, l_float32, l_int32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) The input numa is can be generated from pixExtractAlongLine().
	/// If so, the x parameters can be used to find the reversal
	/// frequency along a line.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaCountReversals/*"/>
	///  <param name="nas">[in] - input values</param>
	///  <param name="minreversal">[in] - relative amount to resolve peaks and valleys</param>
	///  <param name="pnr">[out][optional] - number of reversals</param>
	///  <param name="pnrpl">[out] - ([optional] reversal density: reversals/length</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CountReversals (Numa nas,
							   Single minreversal,
							   out int pnr,
							   out Single pnrpl)
	{
		int RetObj = _All.numaCountReversals(nas, minreversal, out pnr, out pnrpl);
		return RetObj;
	}

	// numafunc2.c (2606, 1)
	// numaSelectCrossingThreshold(nax, nay, estthresh, pbestthresh) as int
	// numaSelectCrossingThreshold(NUMA *, NUMA *, l_float32, l_float32 *) as l_ok
	///  <summary>
	/// (1) When a valid threshold is used, the number of crossings is
	/// a maximum, because none are missed.  If no threshold intersects
	/// all the crossings, the crossings must be determined with
	/// numaCrossingsByPeaks().<para/>
	///
	/// (2) %estthresh is an input estimate of the threshold that should
	/// be used.  We compute the crossings with 41 thresholds
	/// (20 below and 20 above).  There is a range in which the
	/// number of crossings is a maximum.  Return a threshold
	/// in the center of this stable plateau of crossings.
	/// This can then be used with numaCrossingsByThreshold()
	/// to get a good estimate of crossing locations.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaSelectCrossingThreshold/*"/>
	///  <param name="nax">[in][optional] - numa of abscissa values can be NULL</param>
	///  <param name="nay">[in] - signal</param>
	///  <param name="estthresh">[in] - estimated pixel threshold for crossing: e.g., for images, white  is smallerto black typ. ~120</param>
	///  <param name="pbestthresh">[out] - robust estimate of threshold to use</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SelectCrossingThreshold (Numa nay,
										Single estthresh,
										out Single pbestthresh,
										Numa nax)
	{
		int RetObj = _All.numaSelectCrossingThreshold(nax, nay, estthresh, out pbestthresh);
		return RetObj;
	}

	// numafunc2.c (2713, 1)
	// numaCrossingsByThreshold(nax, nay, thresh) as Numa
	// numaCrossingsByThreshold(NUMA *, NUMA *, l_float32) as NUMA *
	///  <summary>
	/// (1) If nax == NULL, we use startx and delx from nay to compute
	/// the crossing values in nad.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaCrossingsByThreshold/*"/>
	///  <param name="nax">[in][optional] - numa of abscissa values can be NULL</param>
	///  <param name="nay">[in] - numa of ordinate values, corresponding to nax</param>
	///  <param name="thresh">[in] - threshold value for nay</param>
	///   <returns>nad abscissa pts at threshold, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa CrossingsByThreshold (Numa nay,
									  Single thresh,
									  Numa nax)
	{
		Numa RetObj = _All.numaCrossingsByThreshold(nax, nay, thresh);
		return RetObj;
	}

	// numafunc2.c (2778, 1)
	// numaCrossingsByPeaks(nax, nay, delta) as Numa
	// numaCrossingsByPeaks(NUMA *, NUMA *, l_float32) as NUMA *
	///  <summary>
	/// (1) If nax == NULL, we use startx and delx from nay to compute
	/// the crossing values in nad.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaCrossingsByPeaks/*"/>
	///  <param name="nax">[in][optional] - numa of abscissa values</param>
	///  <param name="nay">[in] - numa of ordinate values, corresponding to nax</param>
	///  <param name="delta">[in] - parameter used to identify when a new peak can be found</param>
	///   <returns>nad abscissa pts at threshold, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa CrossingsByPeaks (Numa nay,
								  Single delta,
								  Numa nax)
	{
		Numa RetObj = _All.numaCrossingsByPeaks(nax, nay, delta);
		return RetObj;
	}

	// numafunc2.c (2890, 1)
	// numaEvalBestHaarParameters(nas, relweight, nwidth, nshift, minwidth, maxwidth, pbestwidth, pbestshift, pbestscore) as int
	// numaEvalBestHaarParameters(NUMA *, l_float32, l_int32, l_int32, l_float32, l_float32, l_float32 *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) This does a linear sweep of widths, evaluating at %nshift
	/// shifts for each width, computing the score from a convolution
	/// with a long comb, and finding the (width, shift) pair that
	/// gives the maximum score.  The best width is the "half-wavelength"
	/// of the signal.<para/>
	///
	/// (2) The convolving function is a comb of alternating values
	/// +1 and -1  relweight, separated by the width and phased by
	/// the shift.  This is similar to a Haar transform, except
	/// there the convolution is performed with a square wave.<para/>
	///
	/// (3) The function is useful for finding the line spacing
	/// and strength of line signal from pixel sum projections.<para/>
	///
	/// (4) The score is normalized to the size of nas divided by
	/// the number of half-widths.  For image applications, the input is
	/// typically an array of pixel projections, so one should
	/// normalize by dividing the score by the image width in the
	/// pixel projection direction.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaEvalBestHaarParameters/*"/>
	///  <param name="nas">[in] - numa of non-negative signal values</param>
	///  <param name="relweight">[in] - relative weight of (-1 comb) / (+1 comb) contributions to the 'convolution'.  In effect, the convolution kernel is a comb consisting of alternating +1 and -weight.</param>
	///  <param name="nwidth">[in] - number of widths to consider</param>
	///  <param name="nshift">[in] - number of shifts to consider for each width</param>
	///  <param name="minwidth">[in] - smallest width to consider</param>
	///  <param name="maxwidth">[in] - largest width to consider</param>
	///  <param name="pbestwidth">[out] - width giving largest score</param>
	///  <param name="pbestshift">[out] - shift giving largest score</param>
	///  <param name="pbestscore">[out][optional] - convolution with "Haar"-like comb</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int EvalBestHaarParameters (Numa nas,
									   Single relweight,
									   int nwidth,
									   int nshift,
									   Single minwidth,
									   Single maxwidth,
									   out Single pbestwidth,
									   out Single pbestshift,
									   out Single pbestscore)
	{
		int RetObj = _All.numaEvalBestHaarParameters(nas, relweight, nwidth, nshift, minwidth, maxwidth, out pbestwidth, out pbestshift, out pbestscore);
		return RetObj;
	}

	// numafunc2.c (2975, 1)
	// numaEvalHaarSum(nas, width, shift, relweight, pscore) as int
	// numaEvalHaarSum(NUMA *, l_float32, l_float32, l_float32, l_float32 *) as l_ok
	///  <summary>
	/// (1) This does a convolution with a comb of alternating values
	/// +1 and -relweight, separated by the width and phased by the shift.
	/// This is similar to a Haar transform, except that for Haar,<para/>
	///
	/// (1) the convolution kernel is symmetric about 0, so the
	/// relweight is 1.0, and<para/>
	///
	/// (2) the convolution is performed with a square wave.<para/>
	///
	/// (2) The score is normalized to the size of nas divided by
	/// twice the "width".  For image applications, the input is
	/// typically an array of pixel projections, so one should
	/// normalize by dividing the score by the image width in the
	/// pixel projection direction.<para/>
	///
	/// (3) To get a Haar-like result, use relweight = 1.0.  For detecting
	/// signals where you expect every other sample to be close to
	/// zero, as with barcodes or filtered text lines, you can
	/// use relweight  is greater  1.0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaEvalHaarSum/*"/>
	///  <param name="nas">[in] - numa of non-negative signal values</param>
	///  <param name="width">[in] - distance between +1 and -1 in convolution comb</param>
	///  <param name="shift">[in] - phase of the comb: location of first +1</param>
	///  <param name="relweight">[in] - relative weight of (-1 comb) / (+1 comb) contributions to the 'convolution'.  In effect, the convolution kernel is a comb consisting of alternating +1 and -weight.</param>
	///  <param name="pscore">[out] - convolution with "Haar"-like comb</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int EvalHaarSum (Numa nas,
							Single width,
							Single shift,
							Single relweight,
							out Single pscore)
	{
		int RetObj = _All.numaEvalHaarSum(nas, width, shift, relweight, out pscore);
		return RetObj;
	}

	// ptafunc1.c (2232, 1)
	// numaConvertToPta1(na) as Pta
	// numaConvertToPta1(NUMA *) as PTA *
	///  <summary>
	/// numaConvertToPta1()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaConvertToPta1/*"/>
	///   <returns>pta if OK null on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta ConvertToPta1 ()
	{
		Pta RetObj = _All.numaConvertToPta1(this);
		return RetObj;
	}

	// ptafunc1.c (2262, 1)
	// numaConvertToPta2(nax, nay) as Pta
	// numaConvertToPta2(NUMA *, NUMA *) as PTA *
	///  <summary>
	/// numaConvertToPta2()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaConvertToPta2/*"/>
	///  <param name="nax">[in] - </param>
	///  <param name="nay">[in] - </param>
	///   <returns>pta if OK null on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta ConvertToPta2 (Numa nax,
							  Numa nay)
	{
		Pta RetObj = _All.numaConvertToPta2(nax, nay);
		return RetObj;
	}

	// readbarcode.c (837, 1)
	// numaQuantizeCrossingsByWidth(nas, binfract, pnaehist, pnaohist, debugflag) as Numa
	// numaQuantizeCrossingsByWidth(NUMA *, l_float32, NUMA **, NUMA **, l_int32) as NUMA *
	///  <summary>
	/// (1) This first computes the histogram of black and white bar widths,
	/// binned in appropriate units.  There should be well-defined
	/// peaks, each corresponding to a specific width.  The sequence
	/// of barcode widths (namely, the integers from the set {1,2,3,4})
	/// is returned.<para/>
	///
	/// (2) The optional returned histograms are binned in width units
	/// that are inversely proportional to %binfract.  For example,
	/// if %binfract = 0.25, there are 4.0 bins in the distance of
	/// the width of the narrowest bar.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaQuantizeCrossingsByWidth/*"/>
	///  <param name="nas">[in] - numa of crossing locations, in pixel units</param>
	///  <param name="binfract">[in] - histo binsize as a fraction of minsize e.g., 0.25</param>
	///  <param name="pnaehist">[out][optional] - histo of even (black) bar widths</param>
	///  <param name="pnaohist">[out][optional] - histo of odd (white) bar widths</param>
	///  <param name="debugflag">[in] - 1 to generate plots of histograms of bar widths</param>
	///   <returns>nad sequence of widths, in unit sizes, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa QuantizeCrossingsByWidth (Numa nas,
										  Single binfract,
										  int debugflag,
										  out Numa pnaehist,
										  out Numa pnaohist)
	{
		Numa RetObj = _All.numaQuantizeCrossingsByWidth(nas, binfract, out pnaehist, out pnaohist, debugflag);
		return RetObj;
	}

	// readbarcode.c (1267, 1)
	// numaQuantizeCrossingsByWindow(nas, ratio, pwidth, pfirstloc, pnac, debugflag) as Numa
	// numaQuantizeCrossingsByWindow(NUMA *, l_float32, l_float32 *, l_float32 *, NUMA **, l_int32) as NUMA *
	///  <summary>
	/// (1) The minimum size of the window is set by the minimum
	/// distance between zero crossings.<para/>
	///
	/// (2) The optional return signal %nac is a sequence of 0s, 1s,
	/// and perhaps a few 2s, giving the number of crossings in each window.
	/// On the occasion where there is a '2', it is interpreted as
	/// ending two runs: the previous one and another one that has length 1.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaQuantizeCrossingsByWindow/*"/>
	///  <param name="nas">[in] - numa of crossing locations</param>
	///  <param name="ratio">[in] - of max window size over min window size in search typ. 2.0</param>
	///  <param name="pwidth">[out][optional] - best window width</param>
	///  <param name="pfirstloc">[out][optional] - center of window for first xing</param>
	///  <param name="pnac">[out][optional] - array of window crossings (0, 1, 2)</param>
	///  <param name="debugflag">[in] - 1 to generate various plots of intermediate results</param>
	///   <returns>nad sequence of widths, in unit sizes, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa QuantizeCrossingsByWindow (Numa nas,
										   Single ratio,
										   int debugflag,
										   out Single pwidth,
										   out Single pfirstloc,
										   out Numa pnac)
	{
		Numa RetObj = _All.numaQuantizeCrossingsByWindow(nas, ratio, out pwidth, out pfirstloc, out pnac, debugflag);
		return RetObj;
	}


}
public partial class Numaa
{
	// classapp.c (603, 1)
	// numaaCompareImagesByBoxes(naa1, naa2, nperline, nreq, maxshiftx, maxshifty, delx, dely, psame, debugflag) as int
	// numaaCompareImagesByBoxes(NUMAA *, NUMAA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32 *, l_int32) as l_ok
	///  <summary>
	/// (1) Each input numaa describes a set of sorted bounding boxes
	/// (sorted by textline and, within each textline, from
	/// left to right) in the images from which they are derived.
	/// See boxaExtractSortedPattern() for a description of the data
	/// format in each of the input numaa.<para/>
	///
	/// (2) This function does an alignment between the input
	/// descriptions of bounding boxes for two images. The
	/// input parameter %nperline specifies the number of boxes
	/// to consider in each line when testing for a match, and
	/// %nreq is the required number of lines that must be well-aligned
	/// to get a match.<para/>
	///
	/// (3) Testing by alignment has 3 steps:
	/// (a) Generating the location of word bounding boxes from the
	/// images (prior to calling this function).
	/// (b) Listing all possible pairs of aligned rows, based on
	/// tolerances in horizontal and vertical positions of
	/// the boxes.  Specifically, all pairs of rows are enumerated
	/// whose first %nperline boxes can be brought into close
	/// alignment, based on the delx parameter for boxes in the
	/// line and within the overall the %maxshiftx and %maxshifty
	/// constraints.
	/// (c) Each pair, starting with the first, is used to search
	/// for a set of %nreq - 1 other pairs that can all be aligned
	/// with a difference in global translation of not more
	/// than (%delx, %dely).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaCompareImagesByBoxes/*"/>
	///  <param name="naa1">[in] - for image 1, formatted by boxaExtractSortedPattern()</param>
	///  <param name="naa2">[in] - ditto for image 2</param>
	///  <param name="nperline">[in] - number of box regions to be used in each textline</param>
	///  <param name="nreq">[in] - number of complete row matches required</param>
	///  <param name="maxshiftx">[in] - max allowed x shift between two patterns, in pixels</param>
	///  <param name="maxshifty">[in] - max allowed y shift between two patterns, in pixels</param>
	///  <param name="delx">[in] - max allowed difference in x data, after alignment</param>
	///  <param name="dely">[in] - max allowed difference in y data, after alignment</param>
	///  <param name="psame">[out] - 1 if %nreq row matches are found 0 otherwise</param>
	///  <param name="debugflag">[in] - 1 for debug output</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CompareImagesByBoxes (Numaa naa1,
									 Numaa naa2,
									 int nperline,
									 int nreq,
									 int maxshiftx,
									 int maxshifty,
									 int delx,
									 int dely,
									 out int psame,
									 int debugflag)
	{
		int RetObj = _All.numaaCompareImagesByBoxes(naa1, naa2, nperline, nreq, maxshiftx, maxshifty, delx, dely, out psame, debugflag);
		return RetObj;
	}

	// numabasic.c (1339, 1)
	// numaaCreate(n) as Numaa
	// numaaCreate(l_int32) as NUMAA *
	///  <summary>
	/// numaaCreate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaCreate/*"/>
	///  <param name="n">[in] - size of numa ptr array to be alloc'd 0 for default</param>
	///   <returns>naa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numaa Create (int n)
	{
		Numaa RetObj = _All.numaaCreate(n);
		return RetObj;
	}

	// numabasic.c (1377, 1)
	// numaaCreateFull(nptr, n) as Numaa
	// numaaCreateFull(l_int32, l_int32) as NUMAA *
	///  <summary>
	/// (1) This allocates numaa and fills the array with allocated numas.
	/// In use, after calling this function, use
	/// numaaAddNumber(naa, index, val)
	/// to add val to the index-th numa in naa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaCreateFull/*"/>
	///  <param name="nptr">[in] - : size of numa ptr array to be alloc'd</param>
	///  <param name="n">[in] - : size of individual numa arrays to be alloc'd 0 for default</param>
	///   <returns>naa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numaa CreateFull (int nptr,
							 int n)
	{
		Numaa RetObj = _All.numaaCreateFull(nptr, n);
		return RetObj;
	}

	// numabasic.c (1408, 1)
	// numaaTruncate(naa) as int
	// numaaTruncate(NUMAA *) as l_ok
	///  <summary>
	/// (1) This identifies the largest index containing a numa that
	/// has any numbers within it, destroys all numa beyond that
	/// index, and resets the count.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaTruncate/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Truncate ()
	{
		int RetObj = _All.numaaTruncate(this);
		return RetObj;
	}

	// numabasic.c (1442, 1)
	// numaaDestroy(pnaa) as Object
	// numaaDestroy(NUMAA **) as void
	///  <summary>
	/// numaaDestroy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaDestroy/*"/>
	///  <param name="pnaa">[in,out] - to be nulled if it exists</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref Numaa pnaa)
	{
		_All.numaaDestroy(ref pnaa);
	}

	// numabasic.c (1480, 1)
	// numaaAddNuma(naa, na, copyflag) as int
	// numaaAddNuma(NUMAA *, NUMA *, l_int32) as l_ok
	///  <summary>
	/// numaaAddNuma()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaAddNuma/*"/>
	///  <param name="na">[in] - to be added</param>
	///  <param name="copyflag">[in] - L_INSERT, L_COPY, L_CLONE</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddNuma (Numa na,
						int copyflag)
	{
		int RetObj = _All.numaaAddNuma(this, na, copyflag);
		return RetObj;
	}

	// numabasic.c (1548, 1)
	// numaaGetCount(naa) as int
	// numaaGetCount(NUMAA *) as l_int32
	///  <summary>
	/// numaaGetCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaGetCount/*"/>
	///   <returns>count number of numa, or 0 if no numa or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCount ()
	{
		int RetObj = _All.numaaGetCount(this);
		return RetObj;
	}

	// numabasic.c (1566, 1)
	// numaaGetNumaCount(naa, index) as int
	// numaaGetNumaCount(NUMAA *, l_int32) as l_int32
	///  <summary>
	/// numaaGetNumaCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaGetNumaCount/*"/>
	///  <param name="index">[in] - of numa in naa</param>
	///   <returns>count of numbers in the referenced numa, or 0 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetNumaCount (int index)
	{
		int RetObj = _All.numaaGetNumaCount(this, index);
		return RetObj;
	}

	// numabasic.c (1587, 1)
	// numaaGetNumberCount(naa) as int
	// numaaGetNumberCount(NUMAA *) as l_int32
	///  <summary>
	/// numaaGetNumberCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaGetNumberCount/*"/>
	///   <returns>count total number of numbers in the numaa, or 0 if no numbers or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetNumberCount ()
	{
		int RetObj = _All.numaaGetNumberCount(this);
		return RetObj;
	}

	// numabasic.c (1636, 1)
	// numaaGetPtrArray(naa) as Numa
	// numaaGetPtrArray(NUMAA *) as NUMA **
	///  <summary>
	/// (1) This function is convenient for doing direct manipulation on
	/// a fixed size array of Numas.  To do this, it sets the count
	/// to the full size of the allocated array of Numa ptrs.
	/// The originating Numaa owns this array: DO NOT free it!<para/>
	///
	/// (2) Intended usage:
	/// Numaa naa = numaaCreate(n)
	/// Numa array = numaaGetPtrArray(naa)
	/// ...  [manipulate Numas directly on the array]
	/// numaaDestroy([and]naa)<para/>
	///
	/// (3) Cautions:
	/// ~ Do not free this array it is owned by tne Numaa.
	/// ~ Do not call any functions on the Numaa, other than
	/// numaaDestroy() when you're finished with the array.
	/// Adding a Numa will force a resize, destroying the ptr array.
	/// ~ Do not address the array outside its allocated size.
	/// With the bare array, there are no protections.  If the
	/// allocated size is n, array[n] is an error.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaGetPtrArray/*"/>
	///   <returns>the internal array of ptrs to Numa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetPtrArray ()
	{
		Numa RetObj = _All.numaaGetPtrArray(this);
		return RetObj;
	}

	// numabasic.c (1657, 1)
	// numaaGetNuma(naa, index, accessflag) as Numa
	// numaaGetNuma(NUMAA *, l_int32, l_int32) as NUMA *
	///  <summary>
	/// numaaGetNuma()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaGetNuma/*"/>
	///  <param name="index">[in] - to the index-th numa</param>
	///  <param name="accessflag">[in] - L_COPY or L_CLONE</param>
	///   <returns>numa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetNuma (int index,
						 int accessflag)
	{
		Numa RetObj = _All.numaaGetNuma(this, index, accessflag);
		return RetObj;
	}

	// numabasic.c (1693, 1)
	// numaaReplaceNuma(naa, index, na) as int
	// numaaReplaceNuma(NUMAA *, l_int32, NUMA *) as l_ok
	///  <summary>
	/// (1) Any existing numa is destroyed, and the input one
	/// is inserted in its place.<para/>
	///
	/// (2) If the index is invalid, return 1 (error)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaReplaceNuma/*"/>
	///  <param name="index">[in] - to the index-th numa</param>
	///  <param name="na">[in] - insert and replace any existing one</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ReplaceNuma (int index,
							Numa na)
	{
		int RetObj = _All.numaaReplaceNuma(this, index, na);
		return RetObj;
	}

	// numabasic.c (1726, 1)
	// numaaGetValue(naa, i, j, pfval, pival) as int
	// numaaGetValue(NUMAA *, l_int32, l_int32, l_float32 *, l_int32 *) as l_ok
	///  <summary>
	/// numaaGetValue()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaGetValue/*"/>
	///  <param name="i">[in] - index of numa within numaa</param>
	///  <param name="j">[in] - index into numa</param>
	///  <param name="pfval">[out][optional] - float value</param>
	///  <param name="pival">[out][optional] - int value</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetValue (int i,
						 int j,
						 out Single pfval,
						 out int pival)
	{
		int RetObj = _All.numaaGetValue(this, i, j, out pfval, out pival);
		return RetObj;
	}

	// numabasic.c (1769, 1)
	// numaaAddNumber(naa, index, val) as int
	// numaaAddNumber(NUMAA *, l_int32, l_float32) as l_ok
	///  <summary>
	/// (1) Adds to an existing numa only.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaAddNumber/*"/>
	///  <param name="index">[in] - of numa within numaa</param>
	///  <param name="val">[in] - float or int to be added stored as a float</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddNumber (int index,
						  Single val)
	{
		int RetObj = _All.numaaAddNumber(this, index, val);
		return RetObj;
	}

	// numabasic.c (1801, 1)
	// numaaRead(filename) as Numaa
	// numaaRead(const char *) as NUMAA *
	///  <summary>
	/// numaaRead()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaRead/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>naa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numaa Read (String filename)
	{
		Numaa RetObj = _All.numaaRead(filename);
		return RetObj;
	}

	// numabasic.c (1828, 1)
	// numaaReadStream(fp) as Numaa
	// numaaReadStream(FILE *) as NUMAA *
	///  <summary>
	/// numaaReadStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>naa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numaa ReadStream (FILE fp)
	{
		Numaa RetObj = _All.numaaReadStream(fp);
		return RetObj;
	}

	// numabasic.c (1873, 1)
	// numaaReadMem(data, size) as Numaa
	// numaaReadMem(const l_uint8 *, size_t) as NUMAA *
	///  <summary>
	/// numaaReadMem()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaReadMem/*"/>
	///  <param name="data">[in] - numaa serialization in ascii</param>
	///  <param name="size">[in] - of data can use strlen to get it</param>
	///   <returns>naa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numaa ReadMem (Byte[] data,
						  uint size)
	{
		Numaa RetObj = _All.numaaReadMem(data, size);
		return RetObj;
	}

	// numabasic.c (1900, 1)
	// numaaWrite(filename, naa) as int
	// numaaWrite(const char *, NUMAA *) as l_ok
	///  <summary>
	/// numaaWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaWrite/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String filename)
	{
		int RetObj = _All.numaaWrite(filename, this);
		return RetObj;
	}

	// numabasic.c (1931, 1)
	// numaaWriteStream(fp, naa) as int
	// numaaWriteStream(FILE *, NUMAA *) as l_ok
	///  <summary>
	/// numaaWriteStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaWriteStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp)
	{
		int RetObj = _All.numaaWriteStream(fp, this);
		return RetObj;
	}

	// numabasic.c (1973, 1)
	// numaaWriteMem(pdata, psize, naa) as int
	// numaaWriteMem(l_uint8 **, size_t *, NUMAA *) as l_ok
	///  <summary>
	/// (1) Serializes a numaa in memory and puts the result in a buffer.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaWriteMem/*"/>
	///  <param name="pdata">[out] - data of serialized numaa ascii</param>
	///  <param name="psize">[out] - size of returned data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMem (out Byte[] pdata,
						 out uint psize)
	{
		int RetObj = _All.numaaWriteMem(out pdata, out psize, this);
		return RetObj;
	}

	// numafunc1.c (3368, 1)
	// numaaJoin(naad, naas, istart, iend) as int
	// numaaJoin(NUMAA *, NUMAA *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) istart  is smaller 0 is taken to mean 'read from the start' (istart = 0)<para/>
	///
	/// (2) iend  is smaller 0 means 'read to the end'<para/>
	///
	/// (3) if naas == NULL, this is a no-op
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaJoin/*"/>
	///  <param name="naad">[in] - dest naa add to this one</param>
	///  <param name="naas">[in][optional] - source naa add from this one</param>
	///  <param name="istart">[in] - starting index in nas</param>
	///  <param name="iend">[in] - ending index in naas use -1 to cat all</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Join (Numaa naad,
					 int istart,
					 int iend,
					 Numaa naas)
	{
		int RetObj = _All.numaaJoin(naad, naas, istart, iend);
		return RetObj;
	}

	// numafunc1.c (3416, 1)
	// numaaFlattenToNuma(naa) as Numa
	// numaaFlattenToNuma(NUMAA *) as NUMA *
	///  <summary>
	/// (1) This 'flattens' the Numaa to a Numa, by joining successively
	/// each Numa in the Numaa.<para/>
	///
	/// (2) It doesn't make any assumptions about the location of the
	/// Numas in the Numaa array, unlike most Numaa functions.<para/>
	///
	/// (3) It leaves the input Numaa unchanged.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/numaaFlattenToNuma/*"/>
	///   <returns>numa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa FlattenToNuma ()
	{
		Numa RetObj = _All.numaaFlattenToNuma(this);
		return RetObj;
	}


}
public partial class Sarray
{
	// psio1.c (201, 1)
	// sarrayConvertFilesToPS(sa, res, fileout) as int
	// sarrayConvertFilesToPS(SARRAY *, l_int32, const char *) as l_ok
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayConvertFilesToPS/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int ConvertFilesToPS (int res,
								 String fileout)
	{
		int RetObj = _All.sarrayConvertFilesToPS(this, res, fileout);
		return RetObj;
	}

	// psio1.c (321, 1)
	// sarrayConvertFilesFittedToPS(sa, xpts, ypts, fileout) as int
	// sarrayConvertFilesFittedToPS(SARRAY *, l_float32, l_float32, const char *) as l_ok
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayConvertFilesFittedToPS/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int ConvertFilesFittedToPS (Single xpts,
									   Single ypts,
									   String fileout)
	{
		int RetObj = _All.sarrayConvertFilesFittedToPS(this, xpts, ypts, fileout);
		return RetObj;
	}

	// sarray1.c (163, 1)
	// sarrayCreate(n) as Sarray
	// sarrayCreate(l_int32) as SARRAY *
	///  <summary>
	/// sarrayCreate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayCreate/*"/>
	///  <param name="n">[in] - size of string ptr array to be alloc'd use 0 for default</param>
	///   <returns>sarray, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray Create (int n)
	{
		Sarray RetObj = _All.sarrayCreate(n);
		return RetObj;
	}

	// sarray1.c (193, 1)
	// sarrayCreateInitialized(n, initstr) as Sarray
	// sarrayCreateInitialized(l_int32, const char *) as SARRAY *
	///  <summary>
	/// sarrayCreateInitialized()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayCreateInitialized/*"/>
	///  <param name="n">[in] - size of string ptr array to be alloc'd</param>
	///  <param name="initstr">[in] - string to be initialized on the full array</param>
	///   <returns>sarray, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray CreateInitialized (int n,
									 String initstr)
	{
		Sarray RetObj = _All.sarrayCreateInitialized(n, initstr);
		return RetObj;
	}

	// sarray1.c (226, 1)
	// sarrayCreateWordsFromString(string) as Sarray
	// sarrayCreateWordsFromString(const char *) as SARRAY *
	///  <summary>
	/// (1) This finds the number of word substrings, creates an sarray
	/// of this size, and puts copies of each substring into the sarray.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayCreateWordsFromString/*"/>
	///   <returns>sarray, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray CreateWordsFromString (String _string_)
	{
		Sarray RetObj = _All.sarrayCreateWordsFromString(_string_);
		return RetObj;
	}

	// sarray1.c (276, 1)
	// sarrayCreateLinesFromString(string, blankflag) as Sarray
	// sarrayCreateLinesFromString(const char *, l_int32) as SARRAY *
	///  <summary>
	/// (1) This finds the number of line substrings, each of which
	/// ends with a newline, and puts a copy of each substring
	/// in a new sarray.<para/>
	///
	/// (2) The newline characters are removed from each substring.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayCreateLinesFromString/*"/>
	///  <param name="blankflag">[in] - 0 to exclude blank lines 1 to include</param>
	///   <returns>sarray, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray CreateLinesFromString (String _string_,
										 int blankflag)
	{
		Sarray RetObj = _All.sarrayCreateLinesFromString(_string_, blankflag);
		return RetObj;
	}

	// sarray1.c (355, 1)
	// sarrayDestroy(psa) as Object
	// sarrayDestroy(SARRAY **) as void
	///  <summary>
	/// (1) Decrements the ref count and, if 0, destroys the sarray.<para/>
	///
	/// (2) Always nulls the input ptr.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayDestroy/*"/>
	///  <param name="psa">[in,out] - to be nulled</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref Sarray psa)
	{
		_All.sarrayDestroy(ref psa);
	}

	// sarray1.c (393, 1)
	// sarrayCopy(sa) as Sarray
	// sarrayCopy(SARRAY *) as SARRAY *
	///  <summary>
	/// sarrayCopy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayCopy/*"/>
	///   <returns>copy of sarray, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray Copy ()
	{
		Sarray RetObj = _All.sarrayCopy(this);
		return RetObj;
	}

	// sarray1.c (420, 1)
	// sarrayClone(sa) as Sarray
	// sarrayClone(SARRAY *) as SARRAY *
	///  <summary>
	/// sarrayClone()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayClone/*"/>
	///   <returns>ptr to same sarray, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray Clone ()
	{
		Sarray RetObj = _All.sarrayClone(this);
		return RetObj;
	}

	// sarray1.c (446, 1)
	// sarrayAddString(sa, string, copyflag) as int
	// sarrayAddString(SARRAY *, const char *, l_int32) as l_ok
	///  <summary>
	/// (1) See usage comments at the top of this file.  L_INSERT is
	/// equivalent to L_NOCOPY.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayAddString/*"/>
	///  <param name="copyflag">[in] - L_INSERT, L_NOCOPY or L_COPY</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddString (String _string_,
						  int copyflag)
	{
		int RetObj = _All.sarrayAddString(this, _string_, copyflag);
		return RetObj;
	}

	// sarray1.c (506, 1)
	// sarrayRemoveString(sa, index) as String
	// sarrayRemoveString(SARRAY *, l_int32) as char *
	///  <summary>
	/// sarrayRemoveString()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayRemoveString/*"/>
	///  <param name="index">[in] - of string within sarray</param>
	///   <returns>removed string, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public String RemoveString (int index)
	{
		String RetObj = _All.sarrayRemoveString(this, index);
		return RetObj;
	}

	// sarray1.c (557, 1)
	// sarrayReplaceString(sa, index, newstr, copyflag) as int
	// sarrayReplaceString(SARRAY *, l_int32, char *, l_int32) as l_ok
	///  <summary>
	/// (1) This destroys an existing string and replaces it with
	/// the new string or a copy of it.<para/>
	///
	/// (2) By design, an sarray is always compacted, so there are
	/// never any holes (null ptrs) in the ptr array up to the
	/// current count.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayReplaceString/*"/>
	///  <param name="index">[in] - of string within sarray to be replaced</param>
	///  <param name="newstr">[in] - string to replace existing one</param>
	///  <param name="copyflag">[in] - L_INSERT, L_COPY</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ReplaceString (int index,
							  String newstr,
							  int copyflag)
	{
		int RetObj = _All.sarrayReplaceString(this, index, newstr, copyflag);
		return RetObj;
	}

	// sarray1.c (594, 1)
	// sarrayClear(sa) as int
	// sarrayClear(SARRAY *) as l_ok
	///  <summary>
	/// sarrayClear()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayClear/*"/>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Clear ()
	{
		int RetObj = _All.sarrayClear(this);
		return RetObj;
	}

	// sarray1.c (621, 1)
	// sarrayGetCount(sa) as int
	// sarrayGetCount(SARRAY *) as l_int32
	///  <summary>
	/// sarrayGetCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayGetCount/*"/>
	///   <returns>count, or 0 if no strings or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCount ()
	{
		int RetObj = _All.sarrayGetCount(this);
		return RetObj;
	}

	// sarray1.c (646, 1)
	// sarrayGetArray(sa, pnalloc, pn) as String[]
	// sarrayGetArray(SARRAY *, l_int32 *, l_int32 *) as char **
	///  <summary>
	/// (1) Caution: the returned array is not a copy, so caller
	/// must not destroy it!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayGetArray/*"/>
	///  <param name="pnalloc">[out][optional] - number allocated string ptrs</param>
	///  <param name="pn">[out][optional] - number allocated strings</param>
	///   <returns>ptr to string array, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public String[] GetArray (out int pnalloc,
							  out int pn)
	{
		String[] RetObj = _All.sarrayGetArray(this, out pnalloc, out pn);
		return RetObj;
	}

	// sarray1.c (681, 1)
	// sarrayGetString(sa, index, copyflag) as String
	// sarrayGetString(SARRAY *, l_int32, l_int32) as char *
	///  <summary>
	/// (1) See usage comments at the top of this file.<para/>
	///
	/// (2) To get a pointer to the string itself, use L_NOCOPY.
	/// To get a copy of the string, use L_COPY.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayGetString/*"/>
	///  <param name="index">[in] - to the index-th string</param>
	///  <param name="copyflag">[in] - L_NOCOPY or L_COPY</param>
	///   <returns>string, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public String GetString (int index,
							 int copyflag)
	{
		String RetObj = _All.sarrayGetString(this, index, copyflag);
		return RetObj;
	}

	// sarray1.c (708, 1)
	// sarrayGetRefcount(sa) as int
	// sarrayGetRefcount(SARRAY *) as l_int32
	///  <summary>
	/// sarrayGetRefCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayGetRefcount/*"/>
	///   <returns>refcount, or UNDEF on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRefcount ()
	{
		int RetObj = _All.sarrayGetRefcount(this);
		return RetObj;
	}

	// sarray1.c (726, 1)
	// sarrayChangeRefcount(sa, delta) as int
	// sarrayChangeRefcount(SARRAY *, l_int32) as l_ok
	///  <summary>
	/// sarrayChangeRefCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayChangeRefcount/*"/>
	///  <param name="delta">[in] - change to be applied</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ChangeRefcount (int delta)
	{
		int RetObj = _All.sarrayChangeRefcount(this, delta);
		return RetObj;
	}

	// sarray1.c (763, 1)
	// sarrayToString(sa, addnlflag) as String
	// sarrayToString(SARRAY *, l_int32) as char *
	///  <summary>
	/// (1) Concatenates all the strings in the sarray, preserving
	/// all white space.<para/>
	///
	/// (2) If addnlflag != 0, adds either a '\n' or a ' ' after
	/// each substring.<para/>
	///
	/// (3) This function was NOT implemented as:
	/// for (i = 0 i  is smaller n i++)
	/// strcat(dest, sarrayGetString(sa, i, L_NOCOPY))
	/// Do you see why?
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayToString/*"/>
	///  <param name="addnlflag">[in] - flag: 0 adds nothing to each substring 1 adds '\n' to each substring 2 adds ' ' to each substring</param>
	///   <returns>dest string, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public String ToString (int addnlflag)
	{
		String RetObj = _All.sarrayToString(this, addnlflag);
		return RetObj;
	}

	// sarray1.c (798, 1)
	// sarrayToStringRange(sa, first, nstrings, addnlflag) as String
	// sarrayToStringRange(SARRAY *, l_int32, l_int32, l_int32) as char *
	///  <summary>
	/// (1) Concatenates the specified strings inthe sarray, preserving
	/// all white space.<para/>
	///
	/// (2) If addnlflag != 0, adds either a '\n' or a ' ' after
	/// each substring.<para/>
	///
	/// (3) If the sarray is empty, this returns a string with just
	/// the character corresponding to %addnlflag.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayToStringRange/*"/>
	///  <param name="first">[in] - index of first string to use starts with 0</param>
	///  <param name="nstrings">[in] - number of strings to append into the result use 0 to append to the end of the sarray</param>
	///  <param name="addnlflag">[in] - flag: 0 adds nothing to each substring 1 adds '\n' to each substring 2 adds ' ' to each substring</param>
	///   <returns>dest string, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public String ToStringRange (int first,
								 int nstrings,
								 int addnlflag)
	{
		String RetObj = _All.sarrayToStringRange(this, first, nstrings, addnlflag);
		return RetObj;
	}

	// sarray1.c (880, 1)
	// sarrayJoin(sa1, sa2) as int
	// sarrayJoin(SARRAY *, SARRAY *) as l_ok
	///  <summary>
	/// (1) Copies of the strings in sarray2 are added to sarray1.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayJoin/*"/>
	///  <param name="sa1">[in] - to be added to</param>
	///  <param name="sa2">[in] - append to sa1</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Join (Sarray sa1,
					 Sarray sa2)
	{
		int RetObj = _All.sarrayJoin(sa1, sa2);
		return RetObj;
	}

	// sarray1.c (920, 1)
	// sarrayAppendRange(sa1, sa2, start, end) as int
	// sarrayAppendRange(SARRAY *, SARRAY *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) Copies of the strings in sarray2 are added to sarray1.<para/>
	///
	/// (2) The [start ... end] range is truncated if necessary.<para/>
	///
	/// (3) Use end == -1 to append to the end of sa2.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayAppendRange/*"/>
	///  <param name="sa1">[in] - to be added to</param>
	///  <param name="sa2">[in] - append specified range of strings in sa2 to sa1</param>
	///  <param name="start">[in] - index of first string of sa2 to append</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AppendRange (Sarray sa1,
							Sarray sa2,
							int start,
							int _end_)
	{
		int RetObj = _All.sarrayAppendRange(sa1, sa2, start, _end_);
		return RetObj;
	}

	// sarray1.c (972, 1)
	// sarrayPadToSameSize(sa1, sa2, padstring) as int
	// sarrayPadToSameSize(SARRAY *, SARRAY *, const char *) as l_ok
	///  <summary>
	/// (1) If two sarrays have different size, this adds enough
	/// instances of %padstring to the smaller so that they are
	/// the same size.  It is useful when two or more sarrays
	/// are being sequenced in parallel, and it is necessary to
	/// find a valid string at each index.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayPadToSameSize/*"/>
	///  <param name="sa1">[in] - </param>
	///  <param name="sa2">[in] - </param>
	///  <param name="padstring">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int PadToSameSize (Sarray sa1,
							  Sarray sa2,
							  String padstring)
	{
		int RetObj = _All.sarrayPadToSameSize(sa1, sa2, padstring);
		return RetObj;
	}

	// sarray1.c (1029, 1)
	// sarrayConvertWordsToLines(sa, linesize) as Sarray
	// sarrayConvertWordsToLines(SARRAY *, l_int32) as SARRAY *
	///  <summary>
	/// sarrayConvertWordsToLines()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayConvertWordsToLines/*"/>
	///  <param name="linesize">[in] - max num of chars in each line</param>
	///   <returns>saout sa of formatted lines, or NULL on error This is useful for re-typesetting text to a specific maximum line length.  The individual words in the input sarray are concatenated into textlines.  An input word string of zero length is taken to be a paragraph separator.  Each time such a string is found, the current line is ended and a new line is also produced that contains just the string of zero length "".  When the output sarray of lines is eventually converted to a string with newlines typically appended to each line string, the empty strings are just converted to newlines, producing the visible paragraph separation. What happens when a word is larger than linesize? We write it out as a single line anyway!  Words preceding or following this long word are placed on lines preceding or following the line with the long word.  Why this choice? Long "words" found in text documents are typically URLs, and it's often desirable not to put newlines in the middle of a URL. The text display program e.g., text editor will typically wrap the long "word" to fit in the window.</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray ConvertWordsToLines (int linesize)
	{
		Sarray RetObj = _All.sarrayConvertWordsToLines(this, linesize);
		return RetObj;
	}

	// sarray1.c (1098, 1)
	// sarraySplitString(sa, str, separators) as int
	// sarraySplitString(SARRAY *, const char *, const char *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarraySplitString/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int SplitString (String str,
							String separators)
	{
		int RetObj = _All.sarraySplitString(this, str, separators);
		return RetObj;
	}

	// sarray1.c (1145, 1)
	// sarraySelectBySubstring(sain, substr) as Sarray
	// sarraySelectBySubstring(SARRAY *, const char *) as SARRAY *
	///  <summary>
	/// (1) This selects all strings in sain that have substr as a substring.
	/// Note that we can't use strncmp() because we're looking for
	/// a match to the substring anywhere within each filename.<para/>
	///
	/// (2) If substr == NULL, returns a copy of the sarray.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarraySelectBySubstring/*"/>
	///  <param name="sain">[in] - input sarray</param>
	///  <param name="substr">[in][optional] - substring for matching can be NULL</param>
	///   <returns>saout output sarray, filtered with substring or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray SelectBySubstring (Sarray sain,
									 String substr)
	{
		Sarray RetObj = _All.sarraySelectBySubstring(sain, substr);
		return RetObj;
	}

	// sarray1.c (1191, 1)
	// sarraySelectByRange(sain, first, last) as Sarray
	// sarraySelectByRange(SARRAY *, l_int32, l_int32) as SARRAY *
	///  <summary>
	/// (1) This makes %saout consisting of copies of all strings in %sain
	/// in the index set [first ... last].  Use %last == 0 to get all
	/// strings from %first to the last string in the sarray.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarraySelectByRange/*"/>
	///  <param name="sain">[in] - input sarray</param>
	///  <param name="first">[in] - index of first string to be selected</param>
	///  <param name="last">[in] - index of last string to be selected use 0 to go to the end of the sarray</param>
	///   <returns>saout output sarray, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray SelectByRange (Sarray sain,
								 int first,
								 int last)
	{
		Sarray RetObj = _All.sarraySelectByRange(sain, first, last);
		return RetObj;
	}

	// sarray1.c (1260, 1)
	// sarrayParseRange(sa, start, pactualstart, pend, pnewstart, substr, loc) as int
	// sarrayParseRange(SARRAY *, l_int32, l_int32 *, l_int32 *, l_int32 *, const char *, l_int32) as l_int32
	///  <summary>
	/// (1) This finds the range of the next set of strings in SA,
	/// beginning the search at 'start', that does NOT have
	/// the substring 'substr' either at the indicated location
	/// in the string or anywhere in the string.  The input
	/// variable 'loc' is the specified offset within the string
	/// use -1 to indicate 'anywhere in the string'.<para/>
	///
	/// (2) Always check the return value to verify that a valid range
	/// was found.<para/>
	///
	/// (3) If a valid range is not found, the values of actstart,
	/// end and newstart are all set to the size of sa.<para/>
	///
	/// (4) If this is the last valid range, newstart returns the value n.
	/// In use, this should be tested before calling the function.<para/>
	///
	/// (5) Usage example.  To find all the valid ranges in a file
	/// where the invalid lines begin with two dashes, copy each
	/// line in the file to a string in an sarray, and do:
	/// start = 0
	/// while (!sarrayParseRange(sa, start, [and]actstart, [and]end, [and]start,
	/// "--", 0))
	/// fprintf(stderr, "start = %d, end = %d\n", actstart, end)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayParseRange/*"/>
	///  <param name="start">[in] - index to start range search</param>
	///  <param name="pactualstart">[out] - index of actual start may be  is greater  'start'</param>
	///  <param name="pend">[out] - index of end</param>
	///  <param name="pnewstart">[out] - index of start of next range</param>
	///  <param name="substr">[in] - substring for matching at beginning of string</param>
	///  <param name="loc">[in] - byte offset within the string for the pattern use -1 if the location does not matter</param>
	///   <returns>0 if valid range found 1 otherwise</returns>
	// CreateAdditiveFunction: Function/Else
	public int ParseRange (int start,
						   out int pactualstart,
						   out int pend,
						   out int pnewstart,
						   String substr,
						   int loc)
	{
		int RetObj = _All.sarrayParseRange(this, start, out pactualstart, out pend, out pnewstart, substr, loc);
		return RetObj;
	}

	// sarray1.c (1345, 1)
	// sarrayRead(filename) as Sarray
	// sarrayRead(const char *) as SARRAY *
	///  <summary>
	/// sarrayRead()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayRead/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>sarray, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray Read (String filename)
	{
		Sarray RetObj = _All.sarrayRead(filename);
		return RetObj;
	}

	// sarray1.c (1382, 1)
	// sarrayReadStream(fp) as Sarray
	// sarrayReadStream(FILE *) as SARRAY *
	///  <summary>
	/// (1) We store the size of each string along with the string.
	/// The limit on the number of strings is 2^24.
	/// The limit on the size of any string is 2^30 bytes.<para/>
	///
	/// (2) This allows a string to have embedded newlines.  By reading
	/// the entire string, as determined by its size, we are
	/// not affected by any number of embedded newlines.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>sarray, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray ReadStream (FILE fp)
	{
		Sarray RetObj = _All.sarrayReadStream(fp);
		return RetObj;
	}

	// sarray1.c (1449, 1)
	// sarrayReadMem(data, size) as Sarray
	// sarrayReadMem(const l_uint8 *, size_t) as SARRAY *
	///  <summary>
	/// sarrayReadMem()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayReadMem/*"/>
	///  <param name="data">[in] - serialization in ascii</param>
	///  <param name="size">[in] - of data can use strlen to get it</param>
	///   <returns>sarray, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray ReadMem (Byte[] data,
						   uint size)
	{
		Sarray RetObj = _All.sarrayReadMem(data, size);
		return RetObj;
	}

	// sarray1.c (1477, 1)
	// sarrayWrite(filename, sa) as int
	// sarrayWrite(const char *, SARRAY *) as l_ok
	///  <summary>
	/// sarrayWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayWrite/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String filename)
	{
		int RetObj = _All.sarrayWrite(filename, this);
		return RetObj;
	}

	// sarray1.c (1514, 1)
	// sarrayWriteStream(fp, sa) as int
	// sarrayWriteStream(FILE *, SARRAY *) as l_ok
	///  <summary>
	/// (1) This appends a '\n' to each string, which is stripped
	/// off by sarrayReadStream().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayWriteStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp)
	{
		int RetObj = _All.sarrayWriteStream(fp, this);
		return RetObj;
	}

	// sarray1.c (1553, 1)
	// sarrayWriteMem(pdata, psize, sa) as int
	// sarrayWriteMem(l_uint8 **, size_t *, SARRAY *) as l_ok
	///  <summary>
	/// (1) Serializes a sarray in memory and puts the result in a buffer.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayWriteMem/*"/>
	///  <param name="pdata">[out] - data of serialized sarray ascii</param>
	///  <param name="psize">[out] - size of returned data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMem (out Byte[] pdata,
						 out uint psize)
	{
		int RetObj = _All.sarrayWriteMem(out pdata, out psize, this);
		return RetObj;
	}

	// sarray1.c (1601, 1)
	// sarrayAppend(filename, sa) as int
	// sarrayAppend(const char *, SARRAY *) as l_ok
	///  <summary>
	/// sarrayAppend()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayAppend/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Append (String filename)
	{
		int RetObj = _All.sarrayAppend(filename, this);
		return RetObj;
	}

	// sarray2.c (95, 1)
	// sarraySort(saout, sain, sortorder) as Sarray
	// sarraySort(SARRAY *, SARRAY *, l_int32) as SARRAY *
	///  <summary>
	/// (1) Set saout = sain for in-place otherwise, set naout = NULL.<para/>
	///
	/// (2) Shell sort, modified from K[and]R, 2nd edition, p.62.
	/// Slow but simple O(n logn) sort.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarraySort/*"/>
	///  <param name="saout">[in] - output sarray can be NULL or equal to sain</param>
	///  <param name="sain">[in] - input sarray</param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING or L_SORT_DECREASING</param>
	///   <returns>saout output sarray, sorted by ascii value, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray Sort (Sarray saout,
						Sarray sain,
						int sortorder)
	{
		Sarray RetObj = _All.sarraySort(saout, sain, sortorder);
		return RetObj;
	}

	// sarray2.c (145, 1)
	// sarraySortByIndex(sain, naindex) as Sarray
	// sarraySortByIndex(SARRAY *, NUMA *) as SARRAY *
	///  <summary>
	/// sarraySortByIndex()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarraySortByIndex/*"/>
	///  <param name="sain">[in] - </param>
	///  <param name="naindex">[in] - na that maps from the new sarray to the input sarray</param>
	///   <returns>saout sorted, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray SortByIndex (Sarray sain,
							   Numa naindex)
	{
		Sarray RetObj = _All.sarraySortByIndex(sain, naindex);
		return RetObj;
	}

	// sarray2.c (237, 1)
	// sarrayUnionByAset(sa1, sa2) as Sarray
	// sarrayUnionByAset(SARRAY *, SARRAY *) as SARRAY *
	///  <summary>
	/// (1) Duplicates are removed from the concatenation of the two arrays.<para/>
	///
	/// (2) The key for each string is a 64-bit hash.<para/>
	///
	/// (2) Algorithm: Concatenate the two sarrays.  Then build a set,
	/// using hashed strings as keys.  As the set is built, first do
	/// a find if not found, add the key to the set and add the string
	/// to the output sarray.  This is O(nlogn).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayUnionByAset/*"/>
	///  <param name="sa1">[in] - </param>
	///  <param name="sa2">[in] - </param>
	///   <returns>sad with the union of the string set, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray UnionByAset (Sarray sa1,
							   Sarray sa2)
	{
		Sarray RetObj = _All.sarrayUnionByAset(sa1, sa2);
		return RetObj;
	}

	// sarray2.c (277, 1)
	// sarrayRemoveDupsByAset(sas) as Sarray
	// sarrayRemoveDupsByAset(SARRAY *) as SARRAY *
	///  <summary>
	/// (1) This is O(nlogn), considerably slower than
	/// sarrayRemoveDupsByHash() for large string arrays.<para/>
	///
	/// (2) The key for each string is a 64-bit hash.<para/>
	///
	/// (3) Build a set, using hashed strings as keys.  As the set is
	/// built, first do a find if not found, add the key to the
	/// set and add the string to the output sarray.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayRemoveDupsByAset/*"/>
	///  <param name="sas">[in] - </param>
	///   <returns>sad with duplicates removed, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray RemoveDupsByAset (Sarray sas)
	{
		Sarray RetObj = _All.sarrayRemoveDupsByAset(sas);
		return RetObj;
	}

	// sarray2.c (328, 1)
	// sarrayIntersectionByAset(sa1, sa2) as Sarray
	// sarrayIntersectionByAset(SARRAY *, SARRAY *) as SARRAY *
	///  <summary>
	/// (1) Algorithm: put the larger sarray into a set, using the string
	/// hashes as the key values.  Then run through the smaller sarray,
	/// building an output sarray and a second set from the strings
	/// in the larger array: if a string is in the first set but
	/// not in the second, add the string to the output sarray and hash
	/// it into the second set.  The second set is required to make
	/// sure only one instance of each string is put into the output sarray.
	/// This is O(mlogn), {m,n} = sizes of {smaller,larger} input arrays.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayIntersectionByAset/*"/>
	///  <param name="sa1">[in] - </param>
	///  <param name="sa2">[in] - </param>
	///   <returns>sad with the intersection of the string set, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray IntersectionByAset (Sarray sa1,
									  Sarray sa2)
	{
		Sarray RetObj = _All.sarrayIntersectionByAset(sa1, sa2);
		return RetObj;
	}

	// sarray2.c (431, 1)
	// sarrayRemoveDupsByHash(sas, psad, pdahash) as int
	// sarrayRemoveDupsByHash(SARRAY *, SARRAY **, L_DNAHASH **) as l_ok
	///  <summary>
	/// (1) Generates a sarray with unique values.<para/>
	///
	/// (2) The dnahash is built up with sad to assure uniqueness.
	/// It can be used to find if a string is in the set:
	/// sarrayFindValByHash(sad, dahash, str, [and]index)<para/>
	///
	/// (3) The hash of the string location is simple and fast.  It scales
	/// up with the number of buckets to insure a fairly random
	/// bucket selection input strings.<para/>
	///
	/// (4) This is faster than sarrayRemoveDupsByAset(), because the
	/// bucket lookup is O(n), although there is a double-loop
	/// lookup within the dna in each bucket.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayRemoveDupsByHash/*"/>
	///  <param name="sas">[in] - </param>
	///  <param name="psad">[out] - unique set of strings duplicates removed</param>
	///  <param name="pdahash">[out][optional] - dnahash used for lookup</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RemoveDupsByHash (Sarray sas,
								 out Sarray psad,
								 out L_DnaHash pdahash)
	{
		int RetObj = _All.sarrayRemoveDupsByHash(sas, out psad, out pdahash);
		return RetObj;
	}

	// sarray2.c (488, 1)
	// sarrayIntersectionByHash(sa1, sa2) as Sarray
	// sarrayIntersectionByHash(SARRAY *, SARRAY *) as SARRAY *
	///  <summary>
	/// (1) This is faster than sarrayIntersectionByAset(), because the
	/// bucket lookup is O(n).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayIntersectionByHash/*"/>
	///  <param name="sa1">[in] - </param>
	///  <param name="sa2">[in] - </param>
	///   <returns>sad intersection of the strings, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray IntersectionByHash (Sarray sa1,
									  Sarray sa2)
	{
		Sarray RetObj = _All.sarrayIntersectionByHash(sa1, sa2);
		return RetObj;
	}

	// sarray2.c (563, 1)
	// sarrayFindStringByHash(sa, dahash, str, pindex) as int
	// sarrayFindStringByHash(SARRAY *, L_DNAHASH *, const char *, l_int32 *) as l_ok
	///  <summary>
	/// (1) Fast lookup in dnaHash associated with a sarray, to see if a
	/// random string %str is already stored in the hash table.<para/>
	///
	/// (2) We use a strong hash function to minimize the chance that
	/// two different strings hash to the same key value.<para/>
	///
	/// (3) We select the number of buckets to be about 5% of the size
	/// of the input sarray, so that when fully populated, each
	/// bucket (dna) will have about 20 entries, each being an index
	/// into sa.  In lookup, after hashing to the key, and then
	/// again to the bucket, we traverse the bucket (dna), using the
	/// index into sa to check if %str has been found before.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayFindStringByHash/*"/>
	///  <param name="dahash">[in] - built from sa</param>
	///  <param name="str">[in] - arbitrary string</param>
	///  <param name="pindex">[out] - index into %sa if %str is in %sa -1 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindStringByHash (L_DnaHash dahash,
								 String str,
								 out int pindex)
	{
		int RetObj = _All.sarrayFindStringByHash(this, dahash, str, out pindex);
		return RetObj;
	}

	// sarray2.c (648, 1)
	// sarrayGenerateIntegers(n) as Sarray
	// sarrayGenerateIntegers(l_int32) as SARRAY *
	///  <summary>
	/// sarrayGenerateIntegers()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayGenerateIntegers/*"/>
	///  <param name="n">[in] - </param>
	///   <returns>sa  (of printed numbers, 1 - n, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray GenerateIntegers (int n)
	{
		Sarray RetObj = _All.sarrayGenerateIntegers(n);
		return RetObj;
	}

	// sarray2.c (688, 1)
	// sarrayLookupCSKV(sa, keystring, pvalstring) as int
	// sarrayLookupCSKV(SARRAY *, const char *, char **) as l_ok
	///  <summary>
	/// (1) The input %sa can have other strings that are not in
	/// comma-separated key-value format.  These will be ignored.<para/>
	///
	/// (2) This returns a copy of the first value string in %sa whose
	/// key string matches the input %keystring.<para/>
	///
	/// (3) White space is not ignored all white space before the ','
	/// is used for the keystring in matching.  This allows the
	/// key and val strings to have white space (e.g., multiple words).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sarrayLookupCSKV/*"/>
	///  <param name="keystring">[in] - (an input string to match with each key in %sa</param>
	///  <param name="pvalstring">[out] - (the returned value string corresponding to the input key string, if found otherwise NULL)</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int LookupCSKV (String keystring,
						   out String[] pvalstring)
	{
		int RetObj = _All.sarrayLookupCSKV(this, keystring, out pvalstring);
		return RetObj;
	}


}
public partial class L_Bytea
{
	// bytearray.c (93, 1)
	// l_byteaCreate(nbytes) as L_Bytea
	// l_byteaCreate(size_t) as L_BYTEA *
	///  <summary>
	/// (1) The allocated array is n + 1 bytes.  This allows room
	/// for null termination.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaCreate/*"/>
	///  <param name="nbytes">[in] - determines initial size of data array</param>
	// CreateAdditiveFunction: Constructor
	public L_Bytea (uint nbytes)
	{
		L_Bytea RetObj = _All.l_byteaCreate(nbytes);
		Pointer = RetObj.Pointer;
	}

	// bytearray.c (122, 1)
	// l_byteaInitFromMem(data, size) as L_Bytea
	// l_byteaInitFromMem(const l_uint8 *, size_t) as L_BYTEA *
	///  <summary>
	/// l_byteaInitFromMem()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaInitFromMem/*"/>
	///  <param name="data">[in] - to be copied to the array</param>
	///  <param name="size">[in] - amount of data</param>
	// CreateAdditiveFunction: Constructor
	public L_Bytea (Byte[] data,
					uint size)
	{
		L_Bytea RetObj = _All.l_byteaInitFromMem(data, size);
		Pointer = RetObj.Pointer;
	}

	// bytearray.c (149, 1)
	// l_byteaInitFromFile(fname) as L_Bytea
	// l_byteaInitFromFile(const char *) as L_BYTEA *
	///  <summary>
	/// l_byteaInitFromFile()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaInitFromFile/*"/>
	///  <param name="fname">[in] - </param>
	// CreateAdditiveFunction: Constructor
	public L_Bytea (String fname)
	{
		L_Bytea RetObj = _All.l_byteaInitFromFile(fname);
		Pointer = RetObj.Pointer;
	}

	// bytearray.c (176, 1)
	// l_byteaInitFromStream(fp) as L_Bytea
	// l_byteaInitFromStream(FILE *) as L_BYTEA *
	///  <summary>
	/// l_byteaInitFromStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaInitFromStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>l_bytea, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public L_Bytea InitFromStream (FILE fp)
	{
		L_Bytea RetObj = _All.l_byteaInitFromStream(fp);
		return RetObj;
	}

	// bytearray.c (213, 1)
	// l_byteaCopy(bas, copyflag) as L_Bytea
	// l_byteaCopy(L_BYTEA *, l_int32) as L_BYTEA *
	///  <summary>
	/// (1) If cloning, up the refcount and return a ptr to %bas.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaCopy/*"/>
	///  <param name="bas">[in] - source lba</param>
	///  <param name="copyflag">[in] - L_COPY, L_CLONE</param>
	///   <returns>clone or copy of bas, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public L_Bytea Copy (L_Bytea bas,
						 int copyflag)
	{
		L_Bytea RetObj = _All.l_byteaCopy(bas, copyflag);
		return RetObj;
	}

	// bytearray.c (245, 1)
	// l_byteaDestroy(pba) as Object
	// l_byteaDestroy(L_BYTEA **) as void
	///  <summary>
	/// (1) Decrements the ref count and, if 0, destroys the lba.<para/>
	///
	/// (2) Always nulls the input ptr.<para/>
	///
	/// (3) If the data has been previously removed, the lba will
	/// have been nulled, so this will do nothing.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaDestroy/*"/>
	///  <param name="pba">[in,out] - will be set to null before returning</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref L_Bytea pba)
	{
		_All.l_byteaDestroy(ref pba);
	}

	// bytearray.c (281, 1)
	// l_byteaGetSize(ba) as uint
	// l_byteaGetSize(L_BYTEA *) as size_t
	///  <summary>
	/// l_byteaGetSize()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaGetSize/*"/>
	///   <returns>size of stored byte array, or 0 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public uint GetSize ()
	{
		uint RetObj = _All.l_byteaGetSize(this);
		return RetObj;
	}

	// bytearray.c (304, 1)
	// l_byteaGetData(ba, psize) as Byte[]
	// l_byteaGetData(L_BYTEA *, size_t *) as l_uint8 *
	///  <summary>
	/// (1) The returned ptr is owned by %ba.  Do not free it!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaGetData/*"/>
	///  <param name="psize">[out] - size of data in lba</param>
	///   <returns>ptr to existing data array, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Byte[] GetData (out uint psize)
	{
		Byte[] RetObj = _All.l_byteaGetData(this, out psize);
		return RetObj;
	}

	// bytearray.c (333, 1)
	// l_byteaCopyData(ba, psize) as Byte[]
	// l_byteaCopyData(L_BYTEA *, size_t *) as l_uint8 *
	///  <summary>
	/// (1) The returned data is owned by the caller.  The input %ba
	/// still owns the original data array.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaCopyData/*"/>
	///  <param name="psize">[out] - size of data in lba</param>
	///   <returns>copy of data in use in the data array, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Byte[] CopyData (out uint psize)
	{
		Byte[] RetObj = _All.l_byteaCopyData(this, out psize);
		return RetObj;
	}

	// bytearray.c (363, 1)
	// l_byteaAppendData(ba, newdata, newbytes) as int
	// l_byteaAppendData(L_BYTEA *, const l_uint8 *, size_t) as l_ok
	///  <summary>
	/// l_byteaAppendData()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaAppendData/*"/>
	///  <param name="newdata">[in] - byte array to be appended</param>
	///  <param name="newbytes">[in] - size of data array</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AppendData (Byte[] newdata,
						   uint newbytes)
	{
		int RetObj = _All.l_byteaAppendData(this, newdata, newbytes);
		return RetObj;
	}

	// bytearray.c (396, 1)
	// l_byteaAppendString(ba, str) as int
	// l_byteaAppendString(L_BYTEA *, const char *) as l_ok
	///  <summary>
	/// l_byteaAppendString()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaAppendString/*"/>
	///  <param name="str">[in] - null-terminated string to be appended</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AppendString (String str)
	{
		int RetObj = _All.l_byteaAppendString(this, str);
		return RetObj;
	}

	// bytearray.c (465, 1)
	// l_byteaJoin(ba1, pba2) as int
	// l_byteaJoin(L_BYTEA *, L_BYTEA **) as l_ok
	///  <summary>
	/// (1) It is a no-op, not an error, for %ba2 to be null.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaJoin/*"/>
	///  <param name="ba1">[in] - </param>
	///  <param name="pba2">[in,out] - data array is added to the one in ba1, and then ba2 is destroyed</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Join (L_Bytea ba1,
					 ref L_Bytea pba2)
	{
		int RetObj = _All.l_byteaJoin(ba1, ref pba2);
		return RetObj;
	}

	// bytearray.c (497, 1)
	// l_byteaSplit(ba1, splitloc, pba2) as int
	// l_byteaSplit(L_BYTEA *, size_t, L_BYTEA **) as l_ok
	///  <summary>
	/// l_byteaSplit()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaSplit/*"/>
	///  <param name="ba1">[in] - lba to split array bytes nulled beyond the split loc</param>
	///  <param name="splitloc">[in] - location in ba1 to split ba2 begins there</param>
	///  <param name="pba2">[out] - with data starting at splitloc</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Split (L_Bytea ba1,
					  uint splitloc,
					  out L_Bytea pba2)
	{
		int RetObj = _All.l_byteaSplit(ba1, splitloc, out pba2);
		return RetObj;
	}

	// bytearray.c (540, 1)
	// l_byteaFindEachSequence(ba, sequence, seqlen, pda) as int
	// l_byteaFindEachSequence(L_BYTEA *, const l_uint8 *, size_t, L_DNA **) as l_ok
	///  <summary>
	/// l_byteaFindEachSequence()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaFindEachSequence/*"/>
	///  <param name="sequence">[in] - subarray of bytes to find in data</param>
	///  <param name="seqlen">[in] - length of sequence, in bytes</param>
	///  <param name="pda">[out] - byte positions of each occurrence of %sequence</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindEachSequence (Byte[] sequence,
								 uint seqlen,
								 out L_Dna pda)
	{
		int RetObj = _All.l_byteaFindEachSequence(this, sequence, seqlen, out pda);
		return RetObj;
	}

	// bytearray.c (578, 1)
	// l_byteaWrite(fname, ba, startloc, endloc) as int
	// l_byteaWrite(const char *, L_BYTEA *, size_t, size_t) as l_ok
	///  <summary>
	/// l_byteaWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaWrite/*"/>
	///  <param name="fname">[in] - output file</param>
	///  <param name="startloc">[in] - first byte to output</param>
	///  <param name="endloc">[in] - last byte to output use 0 to write to the end of the data array</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String fname,
					  uint startloc,
					  uint endloc)
	{
		int RetObj = _All.l_byteaWrite(fname, this, startloc, endloc);
		return RetObj;
	}

	// bytearray.c (612, 1)
	// l_byteaWriteStream(fp, ba, startloc, endloc) as int
	// l_byteaWriteStream(FILE *, L_BYTEA *, size_t, size_t) as l_ok
	///  <summary>
	/// l_byteaWriteStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/l_byteaWriteStream/*"/>
	///  <param name="fp">[in] - file stream opened for binary write</param>
	///  <param name="startloc">[in] - first byte to output</param>
	///  <param name="endloc">[in] - last byte to output use 0 to write to the end of the data array</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp,
							uint startloc,
							uint endloc)
	{
		int RetObj = _All.l_byteaWriteStream(fp, this, startloc, endloc);
		return RetObj;
	}


}
public partial class L_Ptra
{
	// pdfio1.c (2069, 1)
	// ptraConcatenatePdf(pa, fileout) as int
	// ptraConcatenatePdf(L_PTRA *, const char *) as l_ok
	///  <summary>
	/// (1) This only works with leptonica-formatted single-page pdf files.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraConcatenatePdf/*"/>
	///  <param name="fileout">[in] - concatenated pdf file</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConcatenatePdf (String fileout)
	{
		int RetObj = _All.ptraConcatenatePdf(this, fileout);
		return RetObj;
	}

	// pdfio2.c (307, 1)
	// ptraConcatenatePdfToData(pa_data, sa, pdata, pnbytes) as int
	// ptraConcatenatePdfToData(L_PTRA *, SARRAY *, l_uint8 **, size_t *) as l_ok
	///  <summary>
	/// (1) This only works with leptonica-formatted single-page pdf files.
	/// pdf files generated by other programs will have unpredictable
	/// (and usually bad) results.  The requirements for each pdf file:
	/// (a) The Catalog and Info objects are the first two.
	/// (b) Object 3 is Pages
	/// (c) Object 4 is Page
	/// (d) The remaining objects are Contents, XObjects, and ColorSpace<para/>
	///
	/// (2) We remove trailers from each page, and append the full trailer
	/// for all pages at the end.<para/>
	///
	/// (3) For all but the first file, remove the ID and the first 3
	/// objects (catalog, info, pages), so that each subsequent
	/// file has only objects of these classes:
	/// Page, Contents, XObject, ColorSpace (Indexed RGB).
	/// For those objects, we substitute these refs to objects
	/// in the local file:
	/// Page:  Parent(object 3), Contents, XObject(typically multiple)
	/// XObject:  [ColorSpace if indexed]
	/// The Pages object on the first page (object 3) has a Kids array
	/// of references to all the Page objects, with a Count equal
	/// to the number of pages.  Each Page object refers back to
	/// this parent.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraConcatenatePdfToData/*"/>
	///  <param name="pa_data">[in] - ptra array of pdf strings, each for a single-page pdf file</param>
	///  <param name="sa">[in] - string array [optional] of pathnames for input pdf files</param>
	///  <param name="pdata">[out] - concatenated pdf data in memory</param>
	///  <param name="pnbytes">[out] - number of bytes in pdf data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConcatenatePdfToData (L_Ptra pa_data,
									 out Byte[] pdata,
									 out uint pnbytes,
									 Sarray sa)
	{
		int RetObj = _All.ptraConcatenatePdfToData(pa_data, sa, out pdata, out pnbytes);
		return RetObj;
	}

	// ptra.c (139, 1)
	// ptraCreate(n) as L_Ptra
	// ptraCreate(l_int32) as L_PTRA *
	///  <summary>
	/// ptraCreate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraCreate/*"/>
	///  <param name="n">[in] - size of ptr array to be alloc'd 0 for default</param>
	///   <returns>pa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public L_Ptra Create (int n)
	{
		L_Ptra RetObj = _All.ptraCreate(n);
		return RetObj;
	}

	// ptra.c (185, 1)
	// ptraDestroy(ppa, freeflag, warnflag) as Object
	// ptraDestroy(L_PTRA **, l_int32, l_int32) as void
	///  <summary>
	/// (1) If %freeflag == TRUE, frees each item in the array.<para/>
	///
	/// (2) If %freeflag == FALSE and %warnflag == TRUE, and there are
	/// items on the array, this gives a warning and destroys the array.
	/// If these items are not owned elsewhere, this will cause
	/// a memory leak of all the items that were on the array.
	/// So if the items are not owned elsewhere and require their
	/// own destroy function, they must be destroyed before the ptra.<para/>
	///
	/// (3) If %warnflag == FALSE, no warnings will be issued.  This is
	/// useful if the items are owned elsewhere, such as a
	/// PixMemoryStore().<para/>
	///
	/// (4) To destroy the ptra, we destroy the ptr array, then
	/// the ptra, and then null the contents of the input ptr.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraDestroy/*"/>
	///  <param name="ppa">[in,out] - ptra to be nulled</param>
	///  <param name="freeflag">[in] - TRUE to free each remaining item in the array</param>
	///  <param name="warnflag">[in] - TRUE to warn if any remaining items are not destroyed</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref L_Ptra ppa,
						 int freeflag,
						 int warnflag)
	{
		_All.ptraDestroy(ref ppa, freeflag, warnflag);
	}

	// ptra.c (242, 1)
	// ptraAdd(pa, item) as int
	// ptraAdd(L_PTRA *, void *) as l_ok
	///  <summary>
	/// (1) This adds the element to the next location beyond imax,
	/// which is the largest occupied ptr in the array.  This is
	/// what you expect from a stack, where all ptrs up to and
	/// including imax are occupied, but here the occuption of
	/// items in the array is entirely arbitrary.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraAdd/*"/>
	///  <param name="item">[in] - generic ptr to a struct</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Add (Object item)
	{
		int RetObj = _All.ptraAdd(this, item);
		return RetObj;
	}

	// ptra.c (336, 1)
	// ptraInsert(pa, index, item, shiftflag) as int
	// ptraInsert(L_PTRA *, l_int32, void *, l_int32) as l_ok
	///  <summary>
	/// (1) This checks first to see if the location is valid, and
	/// then if there is presently an item there.  If there is not,
	/// it is simply inserted into that location.<para/>
	///
	/// (2) If there is an item at the insert location, items must be
	/// moved down to make room for the insert.  In the downward
	/// shift there are three options, given by %shiftflag.
	/// ~ If %shiftflag == L_AUTO_DOWNSHIFT, a decision is made
	/// whether, in a cascade of items, to downshift a minimum
	/// amount or for all items above %index.  The decision is
	/// based on the expectation of finding holes (null ptrs)
	/// between %index and the bottom of the array.
	/// Assuming the holes are distributed uniformly, if 2 or more
	/// holes are expected, we do a minimum shift.
	/// ~ If %shiftflag == L_MIN_DOWNSHIFT, the downward shifting
	/// cascade of items progresses a minimum amount, until
	/// the first empty slot is reached.  This mode requires
	/// some computation before the actual shifting is done.
	/// ~ If %shiftflag == L_FULL_DOWNSHIFT, a shifting cascade is
	/// performed where pa[i] to pa[i + 1] for all i greater or equal index.
	/// Then, the item is inserted at pa[index].<para/>
	///
	/// (3) If you are not using L_AUTO_DOWNSHIFT, the rule of thumb is
	/// to use L_FULL_DOWNSHIFT if the array is compacted (each
	/// element points to an item), and to use L_MIN_DOWNSHIFT
	/// if there are a significant number of null pointers.
	/// There is no penalty to using L_MIN_DOWNSHIFT for a
	/// compacted array, however, because the full shift is required
	/// and we don't do the O(n) computation to look for holes.<para/>
	///
	/// (4) This should not be used repeatedly on large arrays,
	/// because the function is generally O(n).<para/>
	///
	/// (5) However, it can be used repeatedly if we start with an empty
	/// ptr array and insert only once at each location.  For example,
	/// you can support an array of Numa, where at each ptr location
	/// you store either 0 or 1 Numa, and the Numa can be added
	/// randomly to the ptr array.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraInsert/*"/>
	///  <param name="index">[in] - location in ptra to insert new value</param>
	///  <param name="item">[in] - generic ptr to a struct can be null</param>
	///  <param name="shiftflag">[in] - L_AUTO_DOWNSHIFT, L_MIN_DOWNSHIFT, L_FULL_DOWNSHIFT</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Insert (int index,
					   Object item,
					   int shiftflag)
	{
		int RetObj = _All.ptraInsert(this, index, item, shiftflag);
		return RetObj;
	}

	// ptra.c (434, 1)
	// ptraRemove(pa, index, flag) as Object
	// ptraRemove(L_PTRA *, l_int32, l_int32) as void *
	///  <summary>
	/// (1) If flag == L_NO_COMPACTION, this removes the item and
	/// nulls the ptr on the array.  If it takes the last item
	/// in the array, paton is reduced to the next item.<para/>
	///
	/// (2) If flag == L_COMPACTION, this compacts the array for
	/// for all i greater or equal index.  It should not be used repeatedly on
	/// large arrays, because compaction is O(n).<para/>
	///
	/// (3) The ability to remove without automatic compaction allows
	/// removal with cost O(1).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraRemove/*"/>
	///  <param name="index">[in] - element to be removed</param>
	///  <param name="flag">[in] - L_NO_COMPACTION, L_COMPACTION</param>
	// CreateAdditiveFunction: Sub/Default
	public void Remove (int index,
						int flag)
	{
		_All.ptraRemove(this, index, flag);
	}

	// ptra.c (483, 1)
	// ptraRemoveLast(pa) as Object
	// ptraRemoveLast(L_PTRA *) as void *
	///  <summary>
	/// ptraRemoveLast()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraRemoveLast/*"/>
	// CreateAdditiveFunction: Sub/Default
	public void RemoveLast ()
	{
		_All.ptraRemoveLast(this);
	}

	// ptra.c (512, 1)
	// ptraReplace(pa, index, item, freeflag) as Object
	// ptraReplace(L_PTRA *, l_int32, void *, l_int32) as void *
	///  <summary>
	/// ptraReplace()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraReplace/*"/>
	///  <param name="index">[in] - element to be replaced</param>
	///  <param name="item">[in] - new generic ptr to a struct can be null</param>
	///  <param name="freeflag">[in] - TRUE to free old item FALSE to return it</param>
	// CreateAdditiveFunction: Sub/Default
	public void Replace (int index,
						 Object item,
						 int freeflag)
	{
		_All.ptraReplace(this, index, item, freeflag);
	}

	// ptra.c (553, 1)
	// ptraSwap(pa, index1, index2) as int
	// ptraSwap(L_PTRA *, l_int32, l_int32) as l_ok
	///  <summary>
	/// ptraSwap()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraSwap/*"/>
	///  <param name="index1">[in] - </param>
	///  <param name="index2">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Swap (int index1,
					 int index2)
	{
		int RetObj = _All.ptraSwap(this, index1, index2);
		return RetObj;
	}

	// ptra.c (590, 1)
	// ptraCompactArray(pa) as int
	// ptraCompactArray(L_PTRA *) as l_ok
	///  <summary>
	/// (1) This compacts the items on the array, filling any empty ptrs.<para/>
	///
	/// (2) This does not change the size of the array of ptrs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraCompactArray/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CompactArray ()
	{
		int RetObj = _All.ptraCompactArray(this);
		return RetObj;
	}

	// ptra.c (625, 1)
	// ptraReverse(pa) as int
	// ptraReverse(L_PTRA *) as l_ok
	///  <summary>
	/// ptraReverse()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraReverse/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Reverse ()
	{
		int RetObj = _All.ptraReverse(this);
		return RetObj;
	}

	// ptra.c (649, 1)
	// ptraJoin(pa1, pa2) as int
	// ptraJoin(L_PTRA *, L_PTRA *) as l_ok
	///  <summary>
	/// ptraJoin()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraJoin/*"/>
	///  <param name="pa1">[in] - add to this one</param>
	///  <param name="pa2">[in] - appended to pa1, and emptied of items can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Join (L_Ptra pa1,
					 L_Ptra pa2)
	{
		int RetObj = _All.ptraJoin(pa1, pa2);
		return RetObj;
	}

	// ptra.c (699, 1)
	// ptraGetMaxIndex(pa, pmaxindex) as int
	// ptraGetMaxIndex(L_PTRA *, l_int32 *) as l_ok
	///  <summary>
	/// (1) The largest index to an item in the array is %maxindex.
	/// %maxindex is one less than the number of items that would be
	/// in the array if there were no null pointers between 0
	/// and %maxindex - 1.  However, because the internal ptr array
	/// need not be compacted, there may be NULL pointers at
	/// indices below %maxindex for example, if items have
	/// been removed.<para/>
	///
	/// (2) When an item is added to the end of the array, it goes
	/// into patoarray[maxindex + 1], and maxindex is then
	/// incremented by 1.<para/>
	///
	/// (3) If there are no items in the array, this returns %maxindex = -1.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraGetMaxIndex/*"/>
	///  <param name="pmaxindex">[out] - index of last item in the array</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMaxIndex (out int pmaxindex)
	{
		int RetObj = _All.ptraGetMaxIndex(this, out pmaxindex);
		return RetObj;
	}

	// ptra.c (727, 1)
	// ptraGetActualCount(pa, pcount) as int
	// ptraGetActualCount(L_PTRA *, l_int32 *) as l_ok
	///  <summary>
	/// (1) The actual number of items on the ptr array, patonactual,
	/// will be smaller than paton if the array is not compacted.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraGetActualCount/*"/>
	///  <param name="pcount">[out] - actual number of items on the ptr array</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetActualCount (out int pcount)
	{
		int RetObj = _All.ptraGetActualCount(this, out pcount);
		return RetObj;
	}

	// ptra.c (759, 1)
	// ptraGetPtrToItem(pa, index) as Object
	// ptraGetPtrToItem(L_PTRA *, l_int32) as void *
	///  <summary>
	/// (1) This returns a ptr to the item.  You must cast it to
	/// the type of item.  Do not destroy it the item belongs
	/// to the Ptra.<para/>
	///
	/// (2) This can access all possible items on the ptr array.
	/// If an item doesn't exist, it returns null.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraGetPtrToItem/*"/>
	///  <param name="index">[in] - of element to be retrieved</param>
	// CreateAdditiveFunction: Sub/Default
	public void GetPtrToItem (int index)
	{
		_All.ptraGetPtrToItem(this, index);
	}


}
public partial class L_Ptraa
{
	// ptra.c (790, 1)
	// ptraaCreate(n) as L_Ptraa
	// ptraaCreate(l_int32) as L_PTRAA *
	///  <summary>
	/// (1) The ptraa is generated with a fixed size, that can not change.
	/// The ptra can be generated and inserted randomly into this array.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraaCreate/*"/>
	///  <param name="n">[in] - size of ptr array to be alloc'd</param>
	///   <returns>paa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public L_Ptraa Create (int n)
	{
		L_Ptraa RetObj = _All.ptraaCreate(n);
		return RetObj;
	}

	// ptra.c (826, 1)
	// ptraaDestroy(ppaa, freeflag, warnflag) as Object
	// ptraaDestroy(L_PTRAA **, l_int32, l_int32) as void
	///  <summary>
	/// (1) See ptraDestroy() for use of %freeflag and %warnflag.<para/>
	///
	/// (2) To destroy the ptraa, we destroy each ptra, then the ptr array,
	/// then the ptraa, and then null the contents of the input ptr.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraaDestroy/*"/>
	///  <param name="ppaa">[in,out] - to be nulled</param>
	///  <param name="freeflag">[in] - TRUE to free each remaining item in each ptra</param>
	///  <param name="warnflag">[in] - TRUE to warn if any remaining items are not destroyed</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref L_Ptraa ppaa,
						 int freeflag,
						 int warnflag)
	{
		_All.ptraaDestroy(ref ppaa, freeflag, warnflag);
	}

	// ptra.c (867, 1)
	// ptraaGetSize(paa, psize) as int
	// ptraaGetSize(L_PTRAA *, l_int32 *) as l_ok
	///  <summary>
	/// ptraaGetSize()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraaGetSize/*"/>
	///  <param name="psize">[out] - size of ptr array</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetSize (out int psize)
	{
		int RetObj = _All.ptraaGetSize(this, out psize);
		return RetObj;
	}

	// ptra.c (898, 1)
	// ptraaInsertPtra(paa, index, pa) as int
	// ptraaInsertPtra(L_PTRAA *, l_int32, L_PTRA *) as l_ok
	///  <summary>
	/// (1) Caller should check return value.  On success, the Ptra
	/// is inserted in the Ptraa and is owned by it.  However,
	/// on error, the Ptra remains owned by the caller.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraaInsertPtra/*"/>
	///  <param name="index">[in] - location in array for insertion</param>
	///  <param name="pa">[in] - to be inserted</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int InsertPtra (int index,
						   L_Ptra pa)
	{
		int RetObj = _All.ptraaInsertPtra(this, index, pa);
		return RetObj;
	}

	// ptra.c (941, 1)
	// ptraaGetPtra(paa, index, accessflag) as L_Ptra
	// ptraaGetPtra(L_PTRAA *, l_int32, l_int32) as L_PTRA *
	///  <summary>
	/// (1) This returns the ptra ptr.  If %accessflag == L_HANDLE_ONLY,
	/// the ptra is left on the ptraa.  If %accessflag == L_REMOVE,
	/// the ptr in the ptraa is set to NULL, and the caller
	/// is responsible for disposing of the ptra (either putting it
	/// back on the ptraa, or destroying it).<para/>
	///
	/// (2) This returns NULL if there is no Ptra at the index location.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraaGetPtra/*"/>
	///  <param name="index">[in] - location in array</param>
	///  <param name="accessflag">[in] - L_HANDLE_ONLY, L_REMOVE</param>
	///   <returns>ptra at index location, or NULL on error or if there is no ptra there.</returns>
	// CreateAdditiveFunction: Function/Else
	public L_Ptra GetPtra (int index,
						   int accessflag)
	{
		L_Ptra RetObj = _All.ptraaGetPtra(this, index, accessflag);
		return RetObj;
	}

	// ptra.c (983, 1)
	// ptraaFlattenToPtra(paa) as L_Ptra
	// ptraaFlattenToPtra(L_PTRAA *) as L_PTRA *
	///  <summary>
	/// (1) This 'flattens' the ptraa to a ptra, taking the items in
	/// each ptra, in order, starting with the first ptra, etc.<para/>
	///
	/// (2) As a side-effect, the ptra are all removed from the ptraa
	/// and destroyed, leaving an empty ptraa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptraaFlattenToPtra/*"/>
	///   <returns>ptra, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public L_Ptra FlattenToPtra ()
	{
		L_Ptra RetObj = _All.ptraaFlattenToPtra(this);
		return RetObj;
	}


}
public partial class GPlot
{
	// gplot.c (138, 1)
	// gplotCreate(rootname, outformat, title, xlabel, ylabel) as GPlot
	// gplotCreate(const char *, l_int32, const char *, const char *, const char *) as GPLOT *
	///  <summary>
	/// (1) This initializes the plot.<para/>
	///
	/// (2) The 'title', 'xlabel' and 'ylabel' strings can have spaces,
	/// double quotes and backquotes, but not single quotes.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotCreate/*"/>
	///  <param name="rootname">[in] - root for all output files</param>
	///  <param name="outformat">[in] - GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	///  <param name="title">[in][optional] - overall title</param>
	///  <param name="xlabel">[in][optional] - x axis label</param>
	///  <param name="ylabel">[in][optional] - y axis label</param>
	///   <returns>gplot, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public GPlot Create (String rootname,
						 int outformat,
						 String title,
						 String xlabel,
						 String ylabel)
	{
		GPlot RetObj = _All.gplotCreate(rootname, outformat, title, xlabel, ylabel);
		return RetObj;
	}

	// gplot.c (197, 1)
	// gplotDestroy(pgplot) as Object
	// gplotDestroy(GPLOT **) as void
	///  <summary>
	/// gplotDestroy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotDestroy/*"/>
	///  <param name="pgplot">[in,out] - to be nulled</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref GPlot pgplot)
	{
		_All.gplotDestroy(ref pgplot);
	}

	// gplot.c (263, 1)
	// gplotAddPlot(gplot, nax, nay, plotstyle, plottitle) as int
	// gplotAddPlot(GPLOT *, NUMA *, NUMA *, l_int32, const char *) as l_ok
	///  <summary>
	/// (1) There are 2 options for (x,y) values:
	/// o  To plot an array vs a linear function of the
	/// index, set nax = NULL.
	/// o  To plot one array vs another, use both nax and nay.<para/>
	///
	/// (2) If nax is NULL, the x value corresponding to the i-th
	/// value of nay is found from the startx and delx fields
	/// in nay:
	/// x = startx + i  delx
	/// These are set with numaSetParameters().  Their default
	/// values are startx = 0.0, delx = 1.0.<para/>
	///
	/// (3) If nax is defined, it must be the same size as nay, and
	/// must have at least one number.<para/>
	///
	/// (4) The 'plottitle' string can have spaces, double
	/// quotes and backquotes, but not single quotes.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotAddPlot/*"/>
	///  <param name="nax">[in][optional] - numa: set to null for Y_VS_I required for Y_VS_X</param>
	///  <param name="nay">[in] - numa: required for both Y_VS_I and Y_VS_X</param>
	///  <param name="plotstyle">[in] - GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES, GPLOT_LINESPOINTS, GPLOT_DOTS</param>
	///  <param name="plottitle">[in][optional] - title for individual plot</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddPlot (Numa nay,
						int plotstyle,
						Numa nax,
						String plottitle)
	{
		int RetObj = _All.gplotAddPlot(this, nax, nay, plotstyle, plottitle);
		return RetObj;
	}

	// gplot.c (343, 1)
	// gplotSetScaling(gplot, scaling) as int
	// gplotSetScaling(GPLOT *, l_int32) as l_ok
	///  <summary>
	/// (1) By default, the x and y axis scaling is linear.<para/>
	///
	/// (2) Call this function to set semi-log or log-log scaling.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotSetScaling/*"/>
	///  <param name="scaling">[in] - GPLOT_LINEAR_SCALE, GPLOT_LOG_SCALE_X, GPLOT_LOG_SCALE_Y, GPLOT_LOG_SCALE_X_Y</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetScaling (int scaling)
	{
		int RetObj = _All.gplotSetScaling(this, scaling);
		return RetObj;
	}

	// gplot.c (379, 1)
	// gplotMakeOutput(gplot) as int
	// gplotMakeOutput(GPLOT *) as l_ok
	///  <summary>
	/// (1) This uses gplot and the new arrays to add a plot
	/// to the output, by writing a new data file and appending
	/// the appropriate plot commands to the command file.<para/>
	///
	/// (2) This is the only function in this file that requires the
	/// gnuplot executable, to actually generate the plot.<para/>
	///
	/// (3) The command file name for unix is canonical (i.e., directory /tmp)
	/// but the temp filename paths in the command file must be correct.<para/>
	///
	/// (4) The gnuplot program for windows is wgnuplot.exe.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotMakeOutput/*"/>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int MakeOutput ()
	{
		int RetObj = _All.gplotMakeOutput(this);
		return RetObj;
	}

	// gplot.c (422, 1)
	// gplotGenCommandFile(gplot) as int
	// gplotGenCommandFile(GPLOT *) as l_ok
	///  <summary>
	/// gplotGenCommandFile()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotGenCommandFile/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GenCommandFile ()
	{
		int RetObj = _All.gplotGenCommandFile(this);
		return RetObj;
	}

	// gplot.c (528, 1)
	// gplotGenDataFiles(gplot) as int
	// gplotGenDataFiles(GPLOT *) as l_ok
	///  <summary>
	/// (1) The pathnames in the gplot command file are actual pathnames,
	/// which can be in temp directories.  Consequently, they must not be
	/// rewritten by calling fopenWriteStream(), and we use fopen().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotGenDataFiles/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GenDataFiles ()
	{
		int RetObj = _All.gplotGenDataFiles(this);
		return RetObj;
	}

	// gplot.c (575, 1)
	// gplotSimple1(na, outformat, outroot, title) as int
	// gplotSimple1(NUMA *, l_int32, const char *, const char *) as l_ok
	///  <summary>
	/// (1) This gives a line plot of a numa, where the array value
	/// is plotted vs the array index.  The plot is generated
	/// in the specified output format the title  is optional.<para/>
	///
	/// (2) When calling these simple plot functions more than once, use
	/// different %outroot to avoid overwriting the output files.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotSimple1/*"/>
	///  <param name="na">[in] - numa plot Y_VS_I</param>
	///  <param name="outformat">[in] - GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	///  <param name="outroot">[in] - root of output files</param>
	///  <param name="title">[in][optional] - , can be NULL</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Simple1 (Numa na,
						int outformat,
						String outroot,
						String title)
	{
		int RetObj = _All.gplotSimple1(na, outformat, outroot, title);
		return RetObj;
	}

	// gplot.c (604, 1)
	// gplotSimple2(na1, na2, outformat, outroot, title) as int
	// gplotSimple2(NUMA *, NUMA *, l_int32, const char *, const char *) as l_ok
	///  <summary>
	/// (1) This gives a line plot of two numa, where the array values
	/// are each plotted vs the array index.  The plot is generated
	/// in the specified output format the title  is optional.<para/>
	///
	/// (2) When calling these simple plot functions more than once, use
	/// different %outroot to avoid overwriting the output files.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotSimple2/*"/>
	///  <param name="na1">[in] - numa plotted with Y_VS_I</param>
	///  <param name="na2">[in] - ditto</param>
	///  <param name="outformat">[in] - GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	///  <param name="outroot">[in] - root of output files</param>
	///  <param name="title">[in][optional] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Simple2 (Numa na1,
						Numa na2,
						int outformat,
						String outroot,
						String title)
	{
		int RetObj = _All.gplotSimple2(na1, na2, outformat, outroot, title);
		return RetObj;
	}

	// gplot.c (635, 1)
	// gplotSimpleN(naa, outformat, outroot, title) as int
	// gplotSimpleN(NUMAA *, l_int32, const char *, const char *) as l_ok
	///  <summary>
	/// (1) This gives a line plot of all numas in a numaa (array of numa),
	/// where the array values are each plotted vs the array index.
	/// The plot is generated in the specified output format
	/// the title  is optional.<para/>
	///
	/// (2) When calling these simple plot functions more than once, use
	/// different %outroot to avoid overwriting the output files.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotSimpleN/*"/>
	///  <param name="naa">[in] - numaa we plotted with Y_VS_I for each numa</param>
	///  <param name="outformat">[in] - GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	///  <param name="outroot">[in] - root of output files</param>
	///  <param name="title">[in][optional] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SimpleN (Numaa naa,
						int outformat,
						String outroot,
						String title)
	{
		int RetObj = _All.gplotSimpleN(naa, outformat, outroot, title);
		return RetObj;
	}

	// gplot.c (668, 1)
	// gplotSimpleXY1(nax, nay, plotstyle, outformat, outroot, title) as int
	// gplotSimpleXY1(NUMA *, NUMA *, l_int32, l_int32, const char *, const char *) as l_ok
	///  <summary>
	/// (1) This gives a plot of a %nay vs %nax, generated in
	/// the specified output format.  The title is optional.<para/>
	///
	/// (2) Use 0 for default plotstyle (lines).<para/>
	///
	/// (3) %nax is optional.  If NULL, %nay is plotted against
	/// the array index.<para/>
	///
	/// (4) When calling these simple plot functions more than once, use
	/// different %outroot to avoid overwriting the output files.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotSimpleXY1/*"/>
	///  <param name="nax">[in][optional] - </param>
	///  <param name="nay">[in] - </param>
	///  <param name="plotstyle">[in] - GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES, GPLOT_LINESPOINTS, GPLOT_DOTS</param>
	///  <param name="outformat">[in] - GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	///  <param name="outroot">[in] - root of output files</param>
	///  <param name="title">[in][optional] - , can be NULL</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SimpleXY1 (Numa nay,
						  int plotstyle,
						  int outformat,
						  String outroot,
						  Numa nax,
						  String title)
	{
		int RetObj = _All.gplotSimpleXY1(nax, nay, plotstyle, outformat, outroot, title);
		return RetObj;
	}

	// gplot.c (723, 1)
	// gplotSimpleXY2(nax, nay1, nay2, plotstyle, outformat, outroot, title) as int
	// gplotSimpleXY2(NUMA *, NUMA *, NUMA *, l_int32, l_int32, const char *, const char *) as l_ok
	///  <summary>
	/// (1) This gives plots of %nay1 and %nay2 against nax, generated
	/// in the specified output format.  The title is optional.<para/>
	///
	/// (2) Use 0 for default plotstyle (lines).<para/>
	///
	/// (3) %nax is optional.  If NULL, %nay1 and %nay2 are plotted
	/// against the array index.<para/>
	///
	/// (4) When calling these simple plot functions more than once, use
	/// different %outroot to avoid overwriting the output files.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotSimpleXY2/*"/>
	///  <param name="nax">[in] - is smalleroptional can be NULL</param>
	///  <param name="nay1">[in] - </param>
	///  <param name="nay2">[in] - </param>
	///  <param name="plotstyle">[in] - GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES, GPLOT_LINESPOINTS, GPLOT_DOTS</param>
	///  <param name="outformat">[in] - GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	///  <param name="outroot">[in] - root of output files</param>
	///  <param name="title">[in][optional] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SimpleXY2 (Numa nax,
						  Numa nay1,
						  Numa nay2,
						  int plotstyle,
						  int outformat,
						  String outroot,
						  String title)
	{
		int RetObj = _All.gplotSimpleXY2(nax, nay1, nay2, plotstyle, outformat, outroot, title);
		return RetObj;
	}

	// gplot.c (779, 1)
	// gplotSimpleXYN(nax, naay, plotstyle, outformat, outroot, title) as int
	// gplotSimpleXYN(NUMA *, NUMAA *, l_int32, l_int32, const char *, const char *) as l_ok
	///  <summary>
	/// (1) This gives plots of each Numa in %naa against nax,
	/// generated in the specified output format.  The title is optional.<para/>
	///
	/// (2) Use 0 for default plotstyle (lines).<para/>
	///
	/// (3) %nax is optional.  If NULL, each Numa array is plotted against
	/// the array index.<para/>
	///
	/// (4) When calling these simple plot functions more than once, use
	/// different %outroot to avoid overwriting the output files.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotSimpleXYN/*"/>
	///  <param name="nax">[in][optional] - can be NULL</param>
	///  <param name="naay">[in] - numaa of arrays to plot against %nax</param>
	///  <param name="plotstyle">[in] - GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES, GPLOT_LINESPOINTS, GPLOT_DOTS</param>
	///  <param name="outformat">[in] - GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	///  <param name="outroot">[in] - root of output files</param>
	///  <param name="title">[in][optional] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SimpleXYN (Numaa naay,
						  int plotstyle,
						  int outformat,
						  String outroot,
						  Numa nax,
						  String title)
	{
		int RetObj = _All.gplotSimpleXYN(nax, naay, plotstyle, outformat, outroot, title);
		return RetObj;
	}

	// gplot.c (827, 1)
	// gplotRead(filename) as GPlot
	// gplotRead(const char *) as GPLOT *
	///  <summary>
	/// gplotRead()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotRead/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>gplot, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public GPlot Read (String filename)
	{
		GPlot RetObj = _All.gplotRead(filename);
		return RetObj;
	}

	// gplot.c (912, 1)
	// gplotWrite(filename, gplot) as int
	// gplotWrite(const char *, GPLOT *) as l_ok
	///  <summary>
	/// gplotWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/gplotWrite/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String filename)
	{
		int RetObj = _All.gplotWrite(filename, this);
		return RetObj;
	}


}
public partial class Sel
{
	// sel1.c (306, 1)
	// selCreate(height, width, name) as Sel
	// selCreate(l_int32, l_int32, const char *) as SEL *
	///  <summary>
	/// (1) selCreate() initializes all values to 0.<para/>
	///
	/// (2) After this call, (cy,cx) and nonzero data values must be
	/// assigned.  If a text name is not assigned here, it will
	/// be needed later when the sel is put into a sela.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selCreate/*"/>
	///  <param name="height">[in] - </param>
	///  <param name="width">[in] - </param>
	///  <param name="name">[in][optional] - sel name can be null</param>
	///   <returns>sel, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel Create (int height,
					   int width,
					   String name)
	{
		Sel RetObj = _All.selCreate(height, width, name);
		return RetObj;
	}

	// sel1.c (337, 1)
	// selDestroy(psel) as Object
	// selDestroy(SEL **) as void
	///  <summary>
	/// selDestroy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selDestroy/*"/>
	///  <param name="psel">[in,out] - to be nulled</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref Sel psel)
	{
		_All.selDestroy(ref psel);
	}

	// sel1.c (370, 1)
	// selCopy(sel) as Sel
	// selCopy(SEL *) as SEL *
	///  <summary>
	/// selCopy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selCopy/*"/>
	///   <returns>a copy of the sel, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel Copy (Sel sel)
	{
		Sel RetObj = _All.selCopy(this);
		return RetObj;
	}

	// sel1.c (418, 1)
	// selCreateBrick(h, w, cy, cx, type) as Sel
	// selCreateBrick(l_int32, l_int32, l_int32, l_int32, l_int32) as SEL *
	///  <summary>
	/// (1) This is a rectangular sel of all hits, misses or don't cares.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selCreateBrick/*"/>
	///  <param name="h">[in] - height, width</param>
	///  <param name="w">[in] - height, width</param>
	///  <param name="cy">[in] - origin, relative to UL corner at 0,0</param>
	///  <param name="cx">[in] - origin, relative to UL corner at 0,0</param>
	///  <param name="type">[in] - SEL_HIT, SEL_MISS, or SEL_DONT_CARE</param>
	///   <returns>sel, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel CreateBrick (int h,
							int w,
							int cy,
							int cx,
							int type)
	{
		Sel RetObj = _All.selCreateBrick(h, w, cy, cx, type);
		return RetObj;
	}

	// sel1.c (462, 1)
	// selCreateComb(factor1, factor2, direction) as Sel
	// selCreateComb(l_int32, l_int32, l_int32) as SEL *
	///  <summary>
	/// (1) This generates a comb Sel of hits with the origin as
	/// near the center as possible.<para/>
	///
	/// (2) In use, this is complemented by a brick sel of size %factor1,
	/// Both brick and comb sels are made by selectComposableSels().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selCreateComb/*"/>
	///  <param name="factor1">[in] - contiguous space between comb tines</param>
	///  <param name="factor2">[in] - number of comb tines</param>
	///  <param name="direction">[in] - L_HORIZ, L_VERT</param>
	///   <returns>sel, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel CreateComb (int factor1,
						   int factor2,
						   int direction)
	{
		Sel RetObj = _All.selCreateComb(factor1, factor2, direction);
		return RetObj;
	}

	// sel1.c (685, 1)
	// selGetName(sel) as String
	// selGetName(SEL *) as char *
	///  <summary>
	/// selGetName()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selGetName/*"/>
	///   <returns>sel name not copied, or NULL if no name or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public String GetName ()
	{
		String RetObj = _All.selGetName(this);
		return RetObj;
	}

	// sel1.c (710, 1)
	// selSetName(sel, name) as int
	// selSetName(SEL *, const char *) as l_ok
	///  <summary>
	/// (1) Always frees the existing sel name, if defined.<para/>
	///
	/// (2) If name is not defined, just clears any existing sel name.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selSetName/*"/>
	///  <param name="name">[in][optional] - can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetName (String name)
	{
		int RetObj = _All.selSetName(this, name);
		return RetObj;
	}

	// sel1.c (781, 1)
	// selGetElement(sel, row, col, ptype) as int
	// selGetElement(SEL *, l_int32, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// selGetElement()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selGetElement/*"/>
	///  <param name="row">[in] - </param>
	///  <param name="col">[in] - </param>
	///  <param name="ptype">[out] - SEL_HIT, SEL_MISS, SEL_DONT_CARE</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetElement (int row,
						   int col,
						   out int ptype)
	{
		int RetObj = _All.selGetElement(this, row, col, out ptype);
		return RetObj;
	}

	// sel1.c (821, 1)
	// selSetElement(sel, row, col, type) as int
	// selSetElement(SEL *, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) Because we use row and column to index into an array,
	/// they are always non-negative.  The location of the origin
	/// (and the type of operation) determine the actual
	/// direction of the rasterop.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selSetElement/*"/>
	///  <param name="row">[in] - </param>
	///  <param name="col">[in] - </param>
	///  <param name="type">[in] - SEL_HIT, SEL_MISS, SEL_DONT_CARE</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetElement (int row,
						   int col,
						   int type)
	{
		int RetObj = _All.selSetElement(this, row, col, type);
		return RetObj;
	}

	// sel1.c (850, 1)
	// selGetParameters(sel, psy, psx, pcy, pcx) as int
	// selGetParameters(SEL *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// selGetParameters()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selGetParameters/*"/>
	///  <param name="psy">[out][optional] - each can be null</param>
	///  <param name="psx">[out][optional] - each can be null</param>
	///  <param name="pcy">[out][optional] - each can be null</param>
	///  <param name="pcx">[out][optional] - each can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetParameters (out int psy,
							  out int psx,
							  out int pcy,
							  out int pcx)
	{
		int RetObj = _All.selGetParameters(this, out psy, out psx, out pcy, out pcx);
		return RetObj;
	}

	// sel1.c (880, 1)
	// selSetOrigin(sel, cy, cx) as int
	// selSetOrigin(SEL *, l_int32, l_int32) as l_ok
	///  <summary>
	/// selSetOrigin()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selSetOrigin/*"/>
	///  <param name="cy">[in] - </param>
	///  <param name="cx">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetOrigin (int cy,
						  int cx)
	{
		int RetObj = _All.selSetOrigin(this, cy, cx);
		return RetObj;
	}

	// sel1.c (902, 1)
	// selGetTypeAtOrigin(sel, ptype) as int
	// selGetTypeAtOrigin(SEL *, l_int32 *) as l_ok
	///  <summary>
	/// selGetTypeAtOrigin()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selGetTypeAtOrigin/*"/>
	///  <param name="ptype">[out] - SEL_HIT, SEL_MISS, SEL_DONT_CARE</param>
	///   <returns>0 if OK 1 on error or if origin is not found</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetTypeAtOrigin (out int ptype)
	{
		int RetObj = _All.selGetTypeAtOrigin(this, out ptype);
		return RetObj;
	}

	// sel1.c (1193, 1)
	// selFindMaxTranslations(sel, pxp, pyp, pxn, pyn) as int
	// selFindMaxTranslations(SEL *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// These are the maximum shifts for the erosion operation.
	/// For example, when j  is smaller cx, the shift of the image
	/// is +x to the cx.  This is a positive xp shift.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selFindMaxTranslations/*"/>
	///  <param name="pxp">[out] - max shifts</param>
	///  <param name="pyp">[out] - max shifts</param>
	///  <param name="pxn">[out] - max shifts</param>
	///  <param name="pyn">[out] - max shifts</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindMaxTranslations (out int pxp,
									out int pyp,
									out int pxn,
									out int pyn)
	{
		int RetObj = _All.selFindMaxTranslations(this, out pxp, out pyp, out pxn, out pyn);
		return RetObj;
	}

	// sel1.c (1243, 1)
	// selRotateOrth(sel, quads) as Sel
	// selRotateOrth(SEL *, l_int32) as SEL *
	///  <summary>
	/// selRotateOrth()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selRotateOrth/*"/>
	///  <param name="quads">[in] - 0 - 4 number of 90 degree cw rotations</param>
	///   <returns>seld, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel RotateOrth (int quads,
						   Sel sel)
	{
		Sel RetObj = _All.selRotateOrth(this, quads);
		return RetObj;
	}

	// sel1.c (1380, 1)
	// selRead(fname) as Sel
	// selRead(const char *) as SEL *
	///  <summary>
	/// selRead()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selRead/*"/>
	///  <param name="fname">[in] - filename</param>
	///   <returns>sel, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel Read (String fname)
	{
		Sel RetObj = _All.selRead(fname);
		return RetObj;
	}

	// sel1.c (1409, 1)
	// selReadStream(fp) as Sel
	// selReadStream(FILE *) as SEL *
	///  <summary>
	/// selReadStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>sel, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel ReadStream (FILE fp)
	{
		Sel RetObj = _All.selReadStream(fp);
		return RetObj;
	}

	// sel1.c (1526, 1)
	// selWrite(fname, sel) as int
	// selWrite(const char *, SEL *) as l_ok
	///  <summary>
	/// selWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selWrite/*"/>
	///  <param name="fname">[in] - filename</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String fname)
	{
		int RetObj = _All.selWrite(fname, this);
		return RetObj;
	}

	// sel1.c (1555, 1)
	// selWriteStream(fp, sel) as int
	// selWriteStream(FILE *, SEL *) as l_ok
	///  <summary>
	/// selWriteStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selWriteStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp)
	{
		int RetObj = _All.selWriteStream(fp, this);
		return RetObj;
	}

	// sel1.c (1616, 1)
	// selCreateFromString(text, h, w, name) as Sel
	// selCreateFromString(const char *, l_int32, l_int32, const char *) as SEL *
	///  <summary>
	/// (1) The text is an array of chars (in row-major order) where
	/// each char can be one of the following:
	/// 'x': hit
	/// 'o': miss
	/// ' ': don't-care<para/>
	///
	/// (2) When the origin falls on a hit or miss, use an upper case
	/// char (e.g., 'X' or 'O') to indicate it.  When the origin
	/// falls on a don't-care, indicate this with a 'C'.
	/// The string must have exactly one origin specified.<para/>
	///
	/// (3) The advantage of this method is that the text can be input
	/// in a format that shows the 2D layout of the Sel e.g.,
	/// \code
	/// static const char seltext = "x  "
	/// "x Oo "
	/// "x  "
	/// "xxxxx"
	/// \endcode
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selCreateFromString/*"/>
	///  <param name="text">[in] - </param>
	///  <param name="h">[in] - height, width</param>
	///  <param name="w">[in] - height, width</param>
	///  <param name="name">[in][optional] - sel name can be null</param>
	///   <returns>sel of the given size, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel CreateFromString (String text,
								 int h,
								 int w,
								 String name)
	{
		Sel RetObj = _All.selCreateFromString(text, h, w, name);
		return RetObj;
	}

	// sel1.c (1704, 1)
	// selPrintToString(sel) as String
	// selPrintToString(SEL *) as char *
	///  <summary>
	/// (1) This is an inverse function of selCreateFromString.
	/// It prints a textual representation of the SEL to a malloc'd
	/// string.  The format is the same as selCreateFromString
	/// except that newlines are inserted into the output
	/// between rows.<para/>
	///
	/// (2) This is useful for debugging.  However, if you want to
	/// save some Sels in a file, put them in a Sela and write
	/// them out with selaWrite().  They can then be read in
	/// with selaRead().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selPrintToString/*"/>
	///   <returns>str string caller must free</returns>
	// CreateAdditiveFunction: Function/Else
	public String PrintToString ()
	{
		String RetObj = _All.selPrintToString(this);
		return RetObj;
	}

	// sel1.c (1959, 1)
	// selCreateFromPta(pta, cy, cx, name) as Sel
	// selCreateFromPta(PTA *, l_int32, l_int32, const char *) as SEL *
	///  <summary>
	/// (1) The origin and all points in the pta must be positive.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selCreateFromPta/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="cy">[in] - origin of sel</param>
	///  <param name="cx">[in] - origin of sel</param>
	///  <param name="name">[in][optional] - sel name can be null</param>
	///   <returns>sel of minimum required size, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel CreateFromPta (Pta pta,
							  int cy,
							  int cx,
							  String name)
	{
		Sel RetObj = _All.selCreateFromPta(pta, cy, cx, name);
		return RetObj;
	}

	// sel1.c (2009, 1)
	// selCreateFromPix(pix, cy, cx, name) as Sel
	// selCreateFromPix(PIX *, l_int32, l_int32, const char *) as SEL *
	///  <summary>
	/// (1) The origin must be positive.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selCreateFromPix/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="cy">[in] - origin of sel</param>
	///  <param name="cx">[in] - origin of sel</param>
	///  <param name="name">[in][optional] - sel name can be null</param>
	///   <returns>sel, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel CreateFromPix (Pix pix,
							  int cy,
							  int cx,
							  String name)
	{
		Sel RetObj = _All.selCreateFromPix(pix, cy, cx, name);
		return RetObj;
	}

	// sel1.c (2060, 1)
	// selReadFromColorImage(pathname) as Sel
	// selReadFromColorImage(const char *) as SEL *
	///  <summary>
	/// (1) Loads an image from a file and creates a (hit-miss) sel.<para/>
	///
	/// (2) The sel name is taken from the pathname without the directory
	/// and extension.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selReadFromColorImage/*"/>
	///  <param name="pathname">[in] - </param>
	///   <returns>sel if OK NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel ReadFromColorImage (String pathname)
	{
		Sel RetObj = _All.selReadFromColorImage(pathname);
		return RetObj;
	}

	// sel1.c (2109, 1)
	// selCreateFromColorPix(pixs, selname) as Sel
	// selCreateFromColorPix(PIX *, const char *) as SEL *
	///  <summary>
	/// (1) The sel size is given by the size of pixs.<para/>
	///
	/// (2) In pixs, hits are represented by green pixels, misses by red
	/// pixels, and don't-cares by white pixels.<para/>
	///
	/// (3) In pixs, there may be no misses, but there must be at least 1 hit.<para/>
	///
	/// (4) At most there can be only one origin pixel, which is optionally
	/// specified by using a lower-intensity pixel:
	/// if a hit:  dark green
	/// if a miss: dark red
	/// if a don't care: gray
	/// If there is no such pixel, the origin defaults to the approximate
	/// center of the sel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selCreateFromColorPix/*"/>
	///  <param name="pixs">[in] - cmapped or rgb</param>
	///  <param name="selname">[in][optional] - sel name can be null</param>
	///   <returns>sel if OK, NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel CreateFromColorPix (Pix pixs,
								   String selname)
	{
		Sel RetObj = _All.selCreateFromColorPix(pixs, selname);
		return RetObj;
	}

	// sel1.c (2200, 1)
	// selDisplayInPix(sel, size, gthick) as Pix
	// selDisplayInPix(SEL *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This gives a visual representation of a general (hit-miss) sel.<para/>
	///
	/// (2) The empty sel is represented by a grid of intersecting lines.<para/>
	///
	/// (3) Three different patterns are generated for the sel elements:
	/// ~ hit (solid black circle)
	/// ~ miss (black ring inner radius is radius2)
	/// ~ origin (cross, XORed with whatever is there)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selDisplayInPix/*"/>
	///  <param name="size">[in] - of grid interiors odd minimum size of 13 is enforced</param>
	///  <param name="gthick">[in] - grid thickness minimum size of 2 is enforced</param>
	///   <returns>pix display of sel, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayInPix (int size,
							 int gthick)
	{
		Pix RetObj = _All.selDisplayInPix(this, size, gthick);
		return RetObj;
	}


}
public partial class Sela
{
	// ccthin.c (341, 1)
	// selaMakeThinSets(index, debug) as Sela
	// selaMakeThinSets(l_int32, l_int32) as SELA *
	///  <summary>
	/// (1) These are specific sets of HMTs to be used in parallel for
	/// for thinning from each of four directions.<para/>
	///
	/// (2) The sets are indexed as follows:
	/// For thinning (e.g., run to completion):
	/// index = 1 sel_4_1, sel_4_2, sel_4_3
	/// index = 2 sel_4_1, sel_4_5, sel_4_6
	/// index = 3 sel_4_1, sel_4_7, sel_4_7_rot
	/// index = 4 sel_48_1, sel_48_1_rot, sel_48_2
	/// index = 5 sel_8_2, sel_8_3, sel_8_5, sel_8_6
	/// index = 6 sel_8_2, sel_8_3, sel_48_2
	/// index = 7 sel_8_1, sel_8_5, sel_8_6
	/// index = 8 sel_8_2, sel_8_3, sel_8_8, sel_8_9
	/// index = 9 sel_8_5, sel_8_6, sel_8_7, sel_8_7_rot
	/// For thickening (e.g., just a few iterations):
	/// index = 10  sel_4_2, sel_4_3
	/// index = 11  sel_8_4<para/>
	///
	/// (3) For a very smooth skeleton, use set 1 for 4 connected and
	/// set 5 for 8 connected thins.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaMakeThinSets/*"/>
	///  <param name="index">[in] - into specific sets</param>
	///  <param name="debug">[in] - 1 to output display of sela</param>
	///   <returns>sela, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela MakeThinSets (int index,
							  DebugOnOff debug)
	{
		Sela RetObj = _All.selaMakeThinSets(index, debug);
		return RetObj;
	}

	// sel1.c (239, 1)
	// selaCreate(n) as Sela
	// selaCreate(l_int32) as SELA *
	///  <summary>
	/// selaCreate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaCreate/*"/>
	///  <param name="n">[in] - initial number of sel ptrs use 0 for default</param>
	///   <returns>sela, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela Create (int n)
	{
		Sela RetObj = _All.selaCreate(n);
		return RetObj;
	}

	// sel1.c (272, 1)
	// selaDestroy(psela) as Object
	// selaDestroy(SELA **) as void
	///  <summary>
	/// selaDestroy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaDestroy/*"/>
	///  <param name="psela">[in,out] - to be nulled</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref Sela psela)
	{
		_All.selaDestroy(ref psela);
	}

	// sel1.c (566, 1)
	// selaAddSel(sela, sel, selname, copyflag) as int
	// selaAddSel(SELA *, SEL *, const char *, l_int32) as l_ok
	///  <summary>
	/// (1) This adds a sel, either inserting or making a copy.<para/>
	///
	/// (2) Because every sel in a sela must have a name, it copies
	/// the input name if necessary.  You can input NULL for
	/// selname if the sel already has a name.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaAddSel/*"/>
	///  <param name="sel">[in] - to be added</param>
	///  <param name="selname">[in] - ignored if already defined in sel req'd in sel when added to a sela</param>
	///  <param name="copyflag">[in] - L_INSERT or L_COPY</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddSel (Sel sel,
					   String selname,
					   int copyflag)
	{
		int RetObj = _All.selaAddSel(this, sel, selname, copyflag);
		return RetObj;
	}

	// sel1.c (639, 1)
	// selaGetCount(sela) as int
	// selaGetCount(SELA *) as l_int32
	///  <summary>
	/// selaGetCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaGetCount/*"/>
	///   <returns>count, or 0 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCount ()
	{
		int RetObj = _All.selaGetCount(this);
		return RetObj;
	}

	// sel1.c (664, 1)
	// selaGetSel(sela, i) as Sel
	// selaGetSel(SELA *, l_int32) as SEL *
	///  <summary>
	/// (1) This returns a ptr to the sel, not a copy, so the caller
	/// must not destroy it!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaGetSel/*"/>
	///  <param name="i">[in] - index of sel to be retrieved not copied</param>
	///   <returns>sel, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel GetSel (int i)
	{
		Sel RetObj = _All.selaGetSel(this, i);
		return RetObj;
	}

	// sel1.c (732, 1)
	// selaFindSelByName(sela, name, pindex, psel) as int
	// selaFindSelByName(SELA *, const char *, l_int32 *, SEL **) as l_ok
	///  <summary>
	/// selaFindSelByName()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaFindSelByName/*"/>
	///  <param name="name">[in] - sel name</param>
	///  <param name="pindex">[out][optional] - </param>
	///  <param name="psel">[in][optional] - sel (not a copy)</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindSelByName (String name,
							  out int pindex,
							  List<Sel> psel)
	{
		int RetObj = _All.selaFindSelByName(this, name, out pindex, psel);
		return RetObj;
	}

	// sel1.c (937, 1)
	// selaGetBrickName(sela, hsize, vsize) as String
	// selaGetBrickName(SELA *, l_int32, l_int32) as char *
	///  <summary>
	/// selaGetBrickName()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaGetBrickName/*"/>
	///  <param name="hsize">[in] - of brick sel</param>
	///  <param name="vsize">[in] - of brick sel</param>
	///   <returns>sel name new string, or NULL if no name or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public String GetBrickName (int hsize,
								int vsize)
	{
		String RetObj = _All.selaGetBrickName(this, hsize, vsize);
		return RetObj;
	}

	// sel1.c (976, 1)
	// selaGetCombName(sela, size, direction) as String
	// selaGetCombName(SELA *, l_int32, l_int32) as char *
	///  <summary>
	/// (1) Combs are by definition 1-dimensional, either horiz or vert.<para/>
	///
	/// (2) Use this with comb Sels e.g., from selaAddDwaCombs().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaGetCombName/*"/>
	///  <param name="size">[in] - the product of sizes of the brick and comb parts</param>
	///  <param name="direction">[in] - L_HORIZ, L_VERT</param>
	///   <returns>sel name new string, or NULL if name not found or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public String GetCombName (int size,
							   int direction)
	{
		String RetObj = _All.selaGetCombName(this, size, direction);
		return RetObj;
	}

	// sel1.c (1148, 1)
	// selaGetSelnames(sela) as Sarray
	// selaGetSelnames(SELA *) as SARRAY *
	///  <summary>
	/// selaGetSelnames()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaGetSelnames/*"/>
	///   <returns>sa of all sel names, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray GetSelnames ()
	{
		Sarray RetObj = _All.selaGetSelnames(this);
		return RetObj;
	}

	// sel1.c (1310, 1)
	// selaRead(fname) as Sela
	// selaRead(const char *) as SELA *
	///  <summary>
	/// selaRead()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaRead/*"/>
	///  <param name="fname">[in] - filename</param>
	///   <returns>sela, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela Read (String fname)
	{
		Sela RetObj = _All.selaRead(fname);
		return RetObj;
	}

	// sel1.c (1339, 1)
	// selaReadStream(fp) as Sela
	// selaReadStream(FILE *) as SELA *
	///  <summary>
	/// selaReadStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>sela, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela ReadStream (FILE fp)
	{
		Sela RetObj = _All.selaReadStream(fp);
		return RetObj;
	}

	// sel1.c (1464, 1)
	// selaWrite(fname, sela) as int
	// selaWrite(const char *, SELA *) as l_ok
	///  <summary>
	/// selaWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaWrite/*"/>
	///  <param name="fname">[in] - filename</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String fname)
	{
		int RetObj = _All.selaWrite(fname, this);
		return RetObj;
	}

	// sel1.c (1493, 1)
	// selaWriteStream(fp, sela) as int
	// selaWriteStream(FILE *, SELA *) as l_ok
	///  <summary>
	/// selaWriteStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaWriteStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp)
	{
		int RetObj = _All.selaWriteStream(fp, this);
		return RetObj;
	}

	// sel1.c (1779, 1)
	// selaCreateFromFile(filename) as Sela
	// selaCreateFromFile(const char *) as SELA *
	///  <summary>
	/// (1) The file contains a sequence of Sel descriptions.<para/>
	///
	/// (2) Each Sel is formatted as follows:
	/// ~ Any number of comment lines starting with '#' are ignored
	/// ~ The next line contains the selname
	/// ~ The next lines contain the Sel data.  They must be
	/// formatted similarly to the string format in
	/// selCreateFromString(), with each line beginning and
	/// ending with a double-quote, and showing the 2D layout.
	/// ~ Each Sel ends when a blank line, a comment line, or
	/// the end of file is reached.<para/>
	///
	/// (3) See selCreateFromString() for a description of the string
	/// format for the Sel data.  As an example, here are the lines
	/// of is a valid file for a single Sel.  In the file, all lines
	/// are left-justified:
	/// # diagonal sel
	/// sel_5diag
	/// "x  "
	/// " x "
	/// "  X  "
	/// " x "
	/// "  x"
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaCreateFromFile/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>sela, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela CreateFromFile (String filename)
	{
		Sela RetObj = _All.selaCreateFromFile(filename);
		return RetObj;
	}

	// sel1.c (2318, 1)
	// selaDisplayInPix(sela, size, gthick, spacing, ncols) as Pix
	// selaDisplayInPix(SELA *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This gives a visual representation of all the sels in a sela.<para/>
	///
	/// (2) See notes in selDisplayInPix() for display params of each sel.<para/>
	///
	/// (3) This gives the nicest results when all sels in the sela
	/// are the same size.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaDisplayInPix/*"/>
	///  <param name="size">[in] - of grid interiors odd minimum size of 13 is enforced</param>
	///  <param name="gthick">[in] - grid thickness minimum size of 2 is enforced</param>
	///  <param name="spacing">[in] - between sels, both horizontally and vertically</param>
	///  <param name="ncols">[in] - number of sels per "line"</param>
	///   <returns>pix display of all sels in sela, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayInPix (int size,
							 int gthick,
							 int spacing,
							 int ncols)
	{
		Pix RetObj = _All.selaDisplayInPix(this, size, gthick, spacing, ncols);
		return RetObj;
	}

	// sel2.c (92, 1)
	// selaAddBasic(sela) as Sela
	// selaAddBasic(SELA *) as SELA *
	///  <summary>
	/// (1) Adds the following sels:
	/// ~ all linear (horiz, vert) brick sels that are
	/// necessary for decomposable sels up to size 63
	/// ~ square brick sels up to size 10
	/// ~ 4 diagonal sels
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaAddBasic/*"/>
	///   <returns>sela with additional sels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela AddBasic (Sela sela)
	{
		Sela RetObj = _All.selaAddBasic(this);
		return RetObj;
	}

	// sel2.c (181, 1)
	// selaAddHitMiss(sela) as Sela
	// selaAddHitMiss(SELA *) as SELA *
	///  <summary>
	/// selaAddHitMiss()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaAddHitMiss/*"/>
	///   <returns>sela with additional sels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela AddHitMiss (Sela sela)
	{
		Sela RetObj = _All.selaAddHitMiss(this);
		return RetObj;
	}

	// sel2.c (319, 1)
	// selaAddDwaLinear(sela) as Sela
	// selaAddDwaLinear(SELA *) as SELA *
	///  <summary>
	/// (1) Adds all linear (horizontal, vertical) sels from
	/// 2 to 63 pixels in length, which are the sizes over
	/// which dwa code can be generated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaAddDwaLinear/*"/>
	///   <returns>sela with additional sels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela AddDwaLinear (Sela sela)
	{
		Sela RetObj = _All.selaAddDwaLinear(this);
		return RetObj;
	}

	// sel2.c (361, 1)
	// selaAddDwaCombs(sela) as Sela
	// selaAddDwaCombs(SELA *) as SELA *
	///  <summary>
	/// (1) Adds all comb (horizontal, vertical) Sels that are
	/// used in composite linear morphological operations
	/// up to 63 pixels in length, which are the sizes over
	/// which dwa code can be generated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaAddDwaCombs/*"/>
	///   <returns>sela with additional sels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela AddDwaCombs (Sela sela)
	{
		Sela RetObj = _All.selaAddDwaCombs(this);
		return RetObj;
	}

	// sel2.c (423, 1)
	// selaAddCrossJunctions(sela, hlsize, mdist, norient, debugflag) as Sela
	// selaAddCrossJunctions(SELA *, l_float32, l_float32, l_int32, l_int32) as SELA *
	///  <summary>
	/// (1) Adds hitmiss Sels for the intersection of two lines.
	/// If the lines are very thin, they must be nearly orthogonal
	/// to register.<para/>
	///
	/// (2) The number of Sels generated is equal to %norient.<para/>
	///
	/// (3) If %norient == 2, this generates 2 Sels of crosses, each with
	/// two perpendicular lines of hits.  One Sel has horizontal and
	/// vertical hits the other has hits along lines at +-45 degrees.
	/// Likewise, if %norient == 3, this generates 3 Sels of crosses
	/// oriented at 30 degrees with each other.<para/>
	///
	/// (4) It is suggested that %hlsize be chosen at least 1 greater
	/// than %mdist.  Try values of (%hlsize, %mdist) such as
	/// (6,5), (7,6), (8,7), (9,7), etc.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaAddCrossJunctions/*"/>
	///  <param name="hlsize">[in] - length of each line of hits from origin</param>
	///  <param name="mdist">[in] - distance of misses from the origin</param>
	///  <param name="norient">[in] - number of orientations max of 8</param>
	///  <param name="debugflag">[in] - 1 for debug output</param>
	///   <returns>sela with additional sels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela AddCrossJunctions (Single hlsize,
								   Single mdist,
								   int norient,
								   int debugflag,
								   Sela sela)
	{
		Sela RetObj = _All.selaAddCrossJunctions(this, hlsize, mdist, norient, debugflag);
		return RetObj;
	}

	// sel2.c (548, 1)
	// selaAddTJunctions(sela, hlsize, mdist, norient, debugflag) as Sela
	// selaAddTJunctions(SELA *, l_float32, l_float32, l_int32, l_int32) as SELA *
	///  <summary>
	/// (1) Adds hitmiss Sels for the T-junction of two lines.
	/// If the lines are very thin, they must be nearly orthogonal
	/// to register.<para/>
	///
	/// (2) The number of Sels generated is 4  %norient.<para/>
	///
	/// (3) It is suggested that %hlsize be chosen at least 1 greater
	/// than %mdist.  Try values of (%hlsize, %mdist) such as
	/// (6,5), (7,6), (8,7), (9,7), etc.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/selaAddTJunctions/*"/>
	///  <param name="hlsize">[in] - length of each line of hits from origin</param>
	///  <param name="mdist">[in] - distance of misses from the origin</param>
	///  <param name="norient">[in] - number of orientations max of 8</param>
	///  <param name="debugflag">[in] - 1 for debug output</param>
	///   <returns>sela with additional sels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela AddTJunctions (Single hlsize,
							   Single mdist,
							   int norient,
							   int debugflag,
							   Sela sela)
	{
		Sela RetObj = _All.selaAddTJunctions(this, hlsize, mdist, norient, debugflag);
		return RetObj;
	}

	// sel2.c (749, 1)
	// sela4ccThin(sela) as Sela
	// sela4ccThin(SELA *) as SELA *
	///  <summary>
	/// (1) Adds the 9 basic sels for 4-cc thinning.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sela4ccThin/*"/>
	///   <returns>sela with additional sels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela _4ccThin (Sela sela)
	{
		Sela RetObj = _All.sela4ccThin(this);
		return RetObj;
	}

	// sel2.c (790, 1)
	// sela8ccThin(sela) as Sela
	// sela8ccThin(SELA *) as SELA *
	///  <summary>
	/// (1) Adds the 9 basic sels for 8-cc thinning.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sela8ccThin/*"/>
	///   <returns>sela with additional sels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela _8ccThin (Sela sela)
	{
		Sela RetObj = _All.sela8ccThin(this);
		return RetObj;
	}

	// sel2.c (831, 1)
	// sela4and8ccThin(sela) as Sela
	// sela4and8ccThin(SELA *) as SELA *
	///  <summary>
	/// (1) Adds the 2 basic sels for either 4-cc or 8-cc thinning.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/sela4and8ccThin/*"/>
	///   <returns>sela with additional sels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sela _4and8ccThin (Sela sela)
	{
		Sela RetObj = _All.sela4and8ccThin(this);
		return RetObj;
	}


}
public partial class Pix
{
	// readfile.c (189, 1)
	// pixRead(filename) as Pix
	// pixRead(const char *) as PIX *
	///  <summary>
	/// (1) See at top of file for supported formats.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRead/*"/>
	///  <param name="filename">[in] - with full pathname or in local directory</param>
	// CreateAdditiveFunction: Constructor
	public Pix (String filename)
	{
		Pix RetObj = _All.pixRead(filename);
		Pointer = RetObj.Pointer;
	}

	// pix1.c (302, 1)
	// pixCreate(width, height, depth) as Pix
	// pixCreate(l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixCreate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCreate/*"/>
	///  <param name="width">[in] - </param>
	///  <param name="height">[in] - </param>
	///  <param name="depth">[in] - </param>
	// CreateAdditiveFunction: Constructor
	public Pix (int width,
				int height,
				int depth)
	{
		Pix RetObj = _All.pixCreate(width, height, depth);
		Pointer = RetObj.Pointer;
	}

	// pix1.c (367, 1)
	// pixCreateTemplate(pixs) as Pix
	// pixCreateTemplate(PIX *) as PIX *
	///  <summary>
	/// (1) Makes a Pix of the same size as the input Pix, with the
	/// data array allocated and initialized to 0.<para/>
	///
	/// (2) Copies the other fields, including colormap if it exists.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCreateTemplate/*"/>
	// CreateAdditiveFunction: Constructor
	public Pix ()
	{
		Pix RetObj = _All.pixCreateTemplate(this);
		Pointer = RetObj.Pointer;
	}

	// pix1.c (1545, 1)
	// pixGetColormap(pix) as PixColormap
	// pixGetColormap(PIX *) as PIXCMAP *
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetColormap/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Return
	public PixColormap pixGetColormap ()
	{
		PixColormap RetObj = _All.pixGetColormap(this);
		return RetObj;
	}

	// jpegio.c (732, 1)
	// pixWriteJpeg(filename, pix, quality, progressive) as int
	// pixWriteJpeg(const char *, PIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixWriteJpeg()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteJpeg/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="quality">[in] - 1 - 100 75 is default</param>
	///  <param name="progressive">[in] - 0 for baseline sequential 1 for progressive</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Return
	public int pixWriteJpeg (String filename,
							 int quality,
							 int progressive)
	{
		int RetObj = _All.pixWriteJpeg(filename, this, quality, progressive);
		return RetObj;
	}

	// pix1.c (1571, 1)
	// pixSetColormap(pix, colormap) as int
	// pixSetColormap(PIX *, PIXCMAP *) as l_ok
	///  <summary>
	/// (1) Unlike with the pix data field, pixSetColormap() destroys
	/// any existing colormap before assigning the new one.
	/// Because colormaps are not ref counted, it is important that
	/// the new colormap does not belong to any other pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetColormap/*"/>
	///  <param name="colormap">[in] - to be assigned</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Return
	public int pixSetColormap (PixColormap colormap)
	{
		int RetObj = _All.pixSetColormap(this, colormap);
		return RetObj;
	}

	// dewarp4.c (97, 1)
	// dewarpSinglePage(pixs, thresh, adaptive, useboth, check_columns, ppixd, pdewa, debug) as int
	// dewarpSinglePage(PIX *, l_int32, l_int32, l_int32, l_int32, PIX **, L_DEWARPA **, l_int32) as l_ok
	///  <summary>
	/// (1) Dewarps pixs and returns the result in [and]pixd.<para/>
	///
	/// (2) This uses default values for all model parameters.<para/>
	///
	/// (3) If pixs is 1 bpp, the parameters %adaptive and %thresh are ignored.<para/>
	///
	/// (4) If it can't build a model, returns a copy of pixs in [and]pixd.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dewarpSinglePage/*"/>
	///  <param name="thresh">[in] - for global thresholding to 1 bpp ignored otherwise</param>
	///  <param name="adaptive">[in] - 1 for adaptive thresholding 0 for global threshold</param>
	///  <param name="useboth">[in] - 1 for horizontal and vertical 0 for vertical only</param>
	///  <param name="check_columns">[in] - 1 to skip horizontal if multiple columns 0 otherwise default is to skip</param>
	///  <param name="pdewa">[out][optional] - dewa with single page NULL to skip</param>
	///  <param name="debug">[in] - 1 for debugging output, 0 otherwise</param>
	///   <returns>0 if OK, 1 on error list of page numbers, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int dewarpSinglePage (int thresh,
								 int adaptive,
								 int useboth,
								 int check_columns,
								 out Pix ppixd,
								 out L_Dewarpa pdewa,
								 DebugOnOff debug)
	{
		int RetObj = _All.dewarpSinglePage(this, thresh, adaptive, useboth, check_columns, out ppixd, out pdewa, debug);
		return RetObj;
	}

	// adaptmap.c (185, 1)
	// pixCleanBackgroundToWhite(pixs, pixim, pixg, gamma, blackval, whiteval) as Pix
	// pixCleanBackgroundToWhite(PIX *, PIX *, PIX *, l_float32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This is a simplified interface for cleaning an image.
	/// For comparison, see pixAdaptThresholdToBinaryGen().<para/>
	///
	/// (2) The suggested default values for the input parameters are:
	/// gamma:  1.0  (reduce this to increase the contrast e.g.,
	/// for light text)
	/// blackval 70  (a bit more than 60)
	/// whiteval  190  (a bit less than 200)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCleanBackgroundToWhite/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null</param>
	///  <param name="pixg">[in][optional] - 8 bpp grayscale version can be null</param>
	///  <param name="gamma">[in] - gamma correction must be  is greater  0.0 typically ~1.0</param>
	///  <param name="blackval">[in] - dark value to set to black (0)</param>
	///  <param name="whiteval">[in] - light value to set to white (255)</param>
	///   <returns>pixd 8 bpp or 32 bpp rgb, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CleanBackgroundToWhite (Pix pixim,
									   Pix pixg,
									   Single gamma,
									   int blackval,
									   int whiteval)
	{
		Pix RetObj = _All.pixCleanBackgroundToWhite(this, pixim, pixg, gamma, blackval, whiteval);
		return RetObj;
	}

	// adaptmap.c (231, 1)
	// pixBackgroundNormSimple(pixs, pixim, pixg) as Pix
	// pixBackgroundNormSimple(PIX *, PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) This is a simplified interface to pixBackgroundNorm(),
	/// where seven parameters are defaulted.<para/>
	///
	/// (2) The input image is either grayscale or rgb.<para/>
	///
	/// (3) See pixBackgroundNorm() for usage and function.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBackgroundNormSimple/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null</param>
	///  <param name="pixg">[in][optional] - 8 bpp grayscale version can be null</param>
	///   <returns>pixd 8 bpp or 32 bpp rgb, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BackgroundNormSimple (Pix pixim,
									 Pix pixg)
	{
		Pix RetObj = _All.pixBackgroundNormSimple(this, pixim, pixg);
		return RetObj;
	}

	// adaptmap.c (302, 1)
	// pixBackgroundNorm(pixs, pixim, pixg, sx, sy, thresh, mincount, bgval, smoothx, smoothy) as Pix
	// pixBackgroundNorm(PIX *, PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This is a top-level interface for normalizing the image intensity
	/// by mapping the image so that the background is near the input
	/// value 'bgval'.<para/>
	///
	/// (2) The input image is either grayscale or rgb.<para/>
	///
	/// (3) For each component in the input image, the background value
	/// in each tile is estimated using the values in the tile that
	/// are not part of the foreground, where the foreground is
	/// determined by the input 'thresh' argument.<para/>
	///
	/// (4) An optional binary mask can be specified, with the foreground
	/// pixels typically over image regions.  The resulting background
	/// map values will be determined by surrounding pixels that are
	/// not under the mask foreground.  The origin (0,0) of this mask
	/// is assumed to be aligned with the origin of the input image.
	/// This binary mask must not fully cover pixs, because then there
	/// will be no pixels in the input image available to compute
	/// the background.<para/>
	///
	/// (5) An optional grayscale version of the input pixs can be supplied.
	/// The only reason to do this is if the input is RGB and this
	/// grayscale version can be used elsewhere.  If the input is RGB
	/// and this is not supplied, it is made internally using only
	/// the green component, and destroyed after use.<para/>
	///
	/// (6) The dimensions of the pixel tile (sx, sy) give the amount by
	/// by which the map is reduced in size from the input image.<para/>
	///
	/// (7) The threshold is used to binarize the input image, in order to
	/// locate the foreground components.  If this is set too low,
	/// some actual foreground may be used to determine the maps
	/// if set too high, there may not be enough background
	/// to determine the map values accurately.  Typically, it's
	/// better to err by setting the threshold too high.<para/>
	///
	/// (8) A 'mincount' threshold is a minimum count of pixels in a
	/// tile for which a background reading is made, in order for that
	/// pixel in the map to be valid.  This number should perhaps be
	/// at least 1/3 the size of the tile.<para/>
	///
	/// (9) A 'bgval' target background value for the normalized image.  This
	/// should be at least 128.  If set too close to 255, some
	/// clipping will occur in the result.<para/>
	///
	/// (10) Two factors, 'smoothx' and 'smoothy', are input for smoothing
	/// the map.  Each low-pass filter kernel dimension is
	/// is 2  (smoothing factor) + 1, so a
	/// value of 0 means no smoothing. A value of 1 or 2 is recommended.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBackgroundNorm/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null</param>
	///  <param name="pixg">[in][optional] - 8 bpp grayscale version can be null</param>
	///  <param name="sx">[in] - tile size in pixels</param>
	///  <param name="sy">[in] - tile size in pixels</param>
	///  <param name="thresh">[in] - threshold for determining foreground</param>
	///  <param name="mincount">[in] - min threshold on counts in a tile</param>
	///  <param name="bgval">[in] - target bg val typ.  is greater  128</param>
	///  <param name="smoothx">[in] - half-width of block convolution kernel width</param>
	///  <param name="smoothy">[in] - half-width of block convolution kernel height</param>
	///   <returns>pixd 8 bpp or 32 bpp rgb, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BackgroundNorm (int sx,
							   int sy,
							   int thresh,
							   int mincount,
							   int bgval,
							   int smoothx,
							   int smoothy,
							   Pix pixim,
							   Pix pixg)
	{
		Pix RetObj = _All.pixBackgroundNorm(this, pixim, pixg, sx, sy, thresh, mincount, bgval, smoothx, smoothy);
		return RetObj;
	}

	// adaptmap.c (443, 1)
	// pixBackgroundNormMorph(pixs, pixim, reduction, size, bgval) as Pix
	// pixBackgroundNormMorph(PIX *, PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This is a top-level interface for normalizing the image intensity
	/// by mapping the image so that the background is near the input
	/// value 'bgval'.<para/>
	///
	/// (2) The input image is either grayscale or rgb.<para/>
	///
	/// (3) For each component in the input image, the background value
	/// is estimated using a grayscale closing hence the 'Morph'
	/// in the function name.<para/>
	///
	/// (4) An optional binary mask can be specified, with the foreground
	/// pixels typically over image regions.  The resulting background
	/// map values will be determined by surrounding pixels that are
	/// not under the mask foreground.  The origin (0,0) of this mask
	/// is assumed to be aligned with the origin of the input image.
	/// This binary mask must not fully cover pixs, because then there
	/// will be no pixels in the input image available to compute
	/// the background.<para/>
	///
	/// (5) The map is computed at reduced size (given by 'reduction')
	/// from the input pixs and optional pixim.  At this scale,
	/// pixs is closed to remove the background, using a square Sel
	/// of odd dimension.  The product of reduction  size should be
	/// large enough to remove most of the text foreground.<para/>
	///
	/// (6) No convolutional smoothing needs to be done on the map before
	/// inverting it.<para/>
	///
	/// (7) A 'bgval' target background value for the normalized image.  This
	/// should be at least 128.  If set too close to 255, some
	/// clipping will occur in the result.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBackgroundNormMorph/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null</param>
	///  <param name="reduction">[in] - at which morph closings are done between 2 and 16</param>
	///  <param name="size">[in] - of square Sel for the closing use an odd number</param>
	///  <param name="bgval">[in] - target bg val typ.  is greater  128</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BackgroundNormMorph (int reduction,
									int size,
									int bgval,
									Pix pixim)
	{
		Pix RetObj = _All.pixBackgroundNormMorph(this, pixim, reduction, size, bgval);
		return RetObj;
	}

	// adaptmap.c (554, 1)
	// pixBackgroundNormGrayArray(pixs, pixim, sx, sy, thresh, mincount, bgval, smoothx, smoothy, ppixd) as int
	// pixBackgroundNormGrayArray(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, PIX **) as l_ok
	///  <summary>
	/// (1) See notes in pixBackgroundNorm().<para/>
	///
	/// (2) This returns a 16 bpp pix that can be used by
	/// pixApplyInvBackgroundGrayMap() to generate a normalized version
	/// of the input pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBackgroundNormGrayArray/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null</param>
	///  <param name="sx">[in] - tile size in pixels</param>
	///  <param name="sy">[in] - tile size in pixels</param>
	///  <param name="thresh">[in] - threshold for determining foreground</param>
	///  <param name="mincount">[in] - min threshold on counts in a tile</param>
	///  <param name="bgval">[in] - target bg val typ.  is greater  128</param>
	///  <param name="smoothx">[in] - half-width of block convolution kernel width</param>
	///  <param name="smoothy">[in] - half-width of block convolution kernel height</param>
	///  <param name="ppixd">[out] - 16 bpp array of inverted background value</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int BackgroundNormGrayArray (int sx,
										int sy,
										int thresh,
										int mincount,
										int bgval,
										int smoothx,
										int smoothy,
										out Pix ppixd,
										Pix pixim)
	{
		int RetObj = _All.pixBackgroundNormGrayArray(this, pixim, sx, sy, thresh, mincount, bgval, smoothx, smoothy, out ppixd);
		return RetObj;
	}

	// adaptmap.c (631, 1)
	// pixBackgroundNormRGBArrays(pixs, pixim, pixg, sx, sy, thresh, mincount, bgval, smoothx, smoothy, ppixr, ppixg, ppixb) as int
	// pixBackgroundNormRGBArrays(PIX *, PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) See notes in pixBackgroundNorm().<para/>
	///
	/// (2) This returns a set of three 16 bpp pix that can be used by
	/// pixApplyInvBackgroundGrayMap() to generate a normalized version
	/// of each component of the input pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBackgroundNormRGBArrays/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null</param>
	///  <param name="pixg">[in][optional] - 8 bpp grayscale version can be null</param>
	///  <param name="sx">[in] - tile size in pixels</param>
	///  <param name="sy">[in] - tile size in pixels</param>
	///  <param name="thresh">[in] - threshold for determining foreground</param>
	///  <param name="mincount">[in] - min threshold on counts in a tile</param>
	///  <param name="bgval">[in] - target bg val typ.  is greater  128</param>
	///  <param name="smoothx">[in] - half-width of block convolution kernel width</param>
	///  <param name="smoothy">[in] - half-width of block convolution kernel height</param>
	///  <param name="ppixr">[out] - 16 bpp array of inverted R background value</param>
	///  <param name="ppixg">[out] - 16 bpp array of inverted G background value</param>
	///  <param name="ppixb">[out] - 16 bpp array of inverted B background value</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int BackgroundNormRGBArrays (int sx,
										int sy,
										int thresh,
										int mincount,
										int bgval,
										int smoothx,
										int smoothy,
										out Pix ppixr,
										out Pix ppixg,
										out Pix ppixb,
										Pix pixim,
										Pix pixg)
	{
		int RetObj = _All.pixBackgroundNormRGBArrays(this, pixim, pixg, sx, sy, thresh, mincount, bgval, smoothx, smoothy, out ppixr, out ppixg, out ppixb);
		return RetObj;
	}

	// adaptmap.c (714, 1)
	// pixBackgroundNormGrayArrayMorph(pixs, pixim, reduction, size, bgval, ppixd) as int
	// pixBackgroundNormGrayArrayMorph(PIX *, PIX *, l_int32, l_int32, l_int32, PIX **) as l_ok
	///  <summary>
	/// (1) See notes in pixBackgroundNormMorph().<para/>
	///
	/// (2) This returns a 16 bpp pix that can be used by
	/// pixApplyInvBackgroundGrayMap() to generate a normalized version
	/// of the input pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBackgroundNormGrayArrayMorph/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null</param>
	///  <param name="reduction">[in] - at which morph closings are done between 2 and 16</param>
	///  <param name="size">[in] - of square Sel for the closing use an odd number</param>
	///  <param name="bgval">[in] - target bg val typ.  is greater  128</param>
	///  <param name="ppixd">[out] - 16 bpp array of inverted background value</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int BackgroundNormGrayArrayMorph (int reduction,
											 int size,
											 int bgval,
											 out Pix ppixd,
											 Pix pixim)
	{
		int RetObj = _All.pixBackgroundNormGrayArrayMorph(this, pixim, reduction, size, bgval, out ppixd);
		return RetObj;
	}

	// adaptmap.c (779, 1)
	// pixBackgroundNormRGBArraysMorph(pixs, pixim, reduction, size, bgval, ppixr, ppixg, ppixb) as int
	// pixBackgroundNormRGBArraysMorph(PIX *, PIX *, l_int32, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) See notes in pixBackgroundNormMorph().<para/>
	///
	/// (2) This returns a set of three 16 bpp pix that can be used by
	/// pixApplyInvBackgroundGrayMap() to generate a normalized version
	/// of each component of the input pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBackgroundNormRGBArraysMorph/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null</param>
	///  <param name="reduction">[in] - at which morph closings are done between 2 and 16</param>
	///  <param name="size">[in] - of square Sel for the closing use an odd number</param>
	///  <param name="bgval">[in] - target bg val typ.  is greater  128</param>
	///  <param name="ppixr">[out] - 16 bpp array of inverted R background value</param>
	///  <param name="ppixg">[out] - 16 bpp array of inverted G background value</param>
	///  <param name="ppixb">[out] - 16 bpp array of inverted B background value</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int BackgroundNormRGBArraysMorph (int reduction,
											 int size,
											 int bgval,
											 out Pix ppixr,
											 out Pix ppixg,
											 out Pix ppixb,
											 Pix pixim)
	{
		int RetObj = _All.pixBackgroundNormRGBArraysMorph(this, pixim, reduction, size, bgval, out ppixr, out ppixg, out ppixb);
		return RetObj;
	}

	// adaptmap.c (856, 1)
	// pixGetBackgroundGrayMap(pixs, pixim, sx, sy, thresh, mincount, ppixd) as int
	// pixGetBackgroundGrayMap(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, PIX **) as l_ok
	///  <summary>
	/// (1) The background is measured in regions that don't have
	/// images.  It is then propagated into the image regions,
	/// and finally smoothed in each image region.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetBackgroundGrayMap/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null it should not have all foreground pixels</param>
	///  <param name="sx">[in] - tile size in pixels</param>
	///  <param name="sy">[in] - tile size in pixels</param>
	///  <param name="thresh">[in] - threshold for determining foreground</param>
	///  <param name="mincount">[in] - min threshold on counts in a tile</param>
	///  <param name="ppixd">[out] - 8 bpp grayscale map</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetBackgroundGrayMap (int sx,
									 int sy,
									 int thresh,
									 int mincount,
									 out Pix ppixd,
									 Pix pixim)
	{
		int RetObj = _All.pixGetBackgroundGrayMap(this, pixim, sx, sy, thresh, mincount, out ppixd);
		return RetObj;
	}

	// adaptmap.c (1034, 1)
	// pixGetBackgroundRGBMap(pixs, pixim, pixg, sx, sy, thresh, mincount, ppixmr, ppixmg, ppixmb) as int
	// pixGetBackgroundRGBMap(PIX *, PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) If pixg, which is a grayscale version of pixs, is provided,
	/// use this internally to generate the foreground mask.
	/// Otherwise, a grayscale version of pixs will be generated
	/// from the green component only, used, and destroyed.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetBackgroundRGBMap/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null it should not have all foreground pixels</param>
	///  <param name="pixg">[in][optional] - 8 bpp grayscale version can be null</param>
	///  <param name="sx">[in] - tile size in pixels</param>
	///  <param name="sy">[in] - tile size in pixels</param>
	///  <param name="thresh">[in] - threshold for determining foreground</param>
	///  <param name="mincount">[in] - min threshold on counts in a tile</param>
	///  <param name="ppixmr">[out] - rgb maps</param>
	///  <param name="ppixmg">[out] - rgb maps</param>
	///  <param name="ppixmb">[out] - rgb maps</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetBackgroundRGBMap (int sx,
									int sy,
									int thresh,
									int mincount,
									out Pix ppixmr,
									out Pix ppixmg,
									out Pix ppixmb,
									Pix pixim,
									Pix pixg)
	{
		int RetObj = _All.pixGetBackgroundRGBMap(this, pixim, pixg, sx, sy, thresh, mincount, out ppixmr, out ppixmg, out ppixmb);
		return RetObj;
	}

	// adaptmap.c (1219, 1)
	// pixGetBackgroundGrayMapMorph(pixs, pixim, reduction, size, ppixm) as int
	// pixGetBackgroundGrayMapMorph(PIX *, PIX *, l_int32, l_int32, PIX **) as l_ok
	///  <summary>
	/// pixGetBackgroundGrayMapMorph()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetBackgroundGrayMapMorph/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null it should not have all foreground pixels</param>
	///  <param name="reduction">[in] - factor at which closing is performed</param>
	///  <param name="size">[in] - of square Sel for the closing use an odd number</param>
	///  <param name="ppixm">[out] - grayscale map</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetBackgroundGrayMapMorph (int reduction,
										  int size,
										  out Pix ppixm,
										  Pix pixim)
	{
		int RetObj = _All.pixGetBackgroundGrayMapMorph(this, pixim, reduction, size, out ppixm);
		return RetObj;
	}

	// adaptmap.c (1310, 1)
	// pixGetBackgroundRGBMapMorph(pixs, pixim, reduction, size, ppixmr, ppixmg, ppixmb) as int
	// pixGetBackgroundRGBMapMorph(PIX *, PIX *, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
	///  <summary>
	/// pixGetBackgroundRGBMapMorph()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetBackgroundRGBMapMorph/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null it should not have all foreground pixels</param>
	///  <param name="reduction">[in] - factor at which closing is performed</param>
	///  <param name="size">[in] - of square Sel for the closing use an odd number</param>
	///  <param name="ppixmr">[out] - red component map</param>
	///  <param name="ppixmg">[out] - green component map</param>
	///  <param name="ppixmb">[out] - blue component map</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetBackgroundRGBMapMorph (int reduction,
										 int size,
										 out Pix ppixmr,
										 out Pix ppixmg,
										 out Pix ppixmb,
										 Pix pixim)
	{
		int RetObj = _All.pixGetBackgroundRGBMapMorph(this, pixim, reduction, size, out ppixmr, out ppixmg, out ppixmb);
		return RetObj;
	}

	// adaptmap.c (1464, 1)
	// pixFillMapHoles(pix, nx, ny, filltype) as int
	// pixFillMapHoles(PIX *, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place operation on pix (the map).  pix is
	/// typically a low-resolution version of some other image
	/// from which it was derived, where each pixel in pix
	/// corresponds to a rectangular tile (say, m x n) of pixels
	/// in the larger image.  All we need to know about the larger
	/// image is whether or not the rightmost column and bottommost
	/// row of pixels in pix correspond to tiles that are
	/// only partially covered by pixels in the larger image.<para/>
	///
	/// (2) Typically, some number of pixels in the input map are
	/// not known, and their values must be determined by near
	/// pixels that are known.  These unknown pixels are the 'holes'.
	/// They can take on only two values, 0 and 255, and the
	/// instruction about which to fill is given by the filltype flag.<para/>
	///
	/// (3) The "holes" can come from two sources.  The first is when there
	/// are not enough foreground or background pixels in a tile
	/// the second is when a tile is at least partially covered
	/// by an image mask.  If we're filling holes in a fg mask,
	/// the holes are initialized to black (0) and use L_FILL_BLACK.
	/// For filling holes in a bg mask, initialize the holes to
	/// white (255) and use L_FILL_WHITE.<para/>
	///
	/// (4) If w is the map width, nx = w or nx = w - 1 ditto for h and ny.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFillMapHoles/*"/>
	///  <param name="pix">[in] - 8 bpp a map, with one pixel for each tile in a larger image</param>
	///  <param name="nx">[in] - number of horizontal pixel tiles that are entirely covered with pixels in the original source image</param>
	///  <param name="ny">[in] - ditto for the number of vertical pixel tiles</param>
	///  <param name="filltype">[in] - L_FILL_WHITE or L_FILL_BLACK</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FillMapHoles (Pix pix,
							 int nx,
							 int ny,
							 int filltype)
	{
		int RetObj = _All.pixFillMapHoles(pix, nx, ny, filltype);
		return RetObj;
	}

	// adaptmap.c (1576, 1)
	// pixExtendByReplication(pixs, addw, addh) as Pix
	// pixExtendByReplication(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The pixel values are extended to the left and down, as required.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExtendByReplication/*"/>
	///  <param name="addw">[in] - number of extra pixels horizontally to add</param>
	///  <param name="addh">[in] - number of extra pixels vertically to add</param>
	///   <returns>pixd extended with replicated pixel values, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ExtendByReplication (int addw,
									int addh)
	{
		Pix RetObj = _All.pixExtendByReplication(this, addw, addh);
		return RetObj;
	}

	// adaptmap.c (1639, 1)
	// pixSmoothConnectedRegions(pixs, pixm, factor) as int
	// pixSmoothConnectedRegions(PIX *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) The pixels in pixs corresponding to those in each
	/// 8-connected region in the mask are set to the average value.<para/>
	///
	/// (2) This is required for adaptive mapping to avoid the
	/// generation of stripes in the background map, due to
	/// variations in the pixel values near the edges of mask regions.<para/>
	///
	/// (3) This function is optimized for background smoothing, where
	/// there are a relatively small number of components.  It will
	/// be inefficient if used where there are many small components.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSmoothConnectedRegions/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp if null, this is a no-op</param>
	///  <param name="factor">[in] - subsampling factor for getting average greater or equal 1</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SmoothConnectedRegions (int factor,
									   Pix pixm)
	{
		int RetObj = _All.pixSmoothConnectedRegions(this, pixm, factor);
		return RetObj;
	}

	// adaptmap.c (1840, 1)
	// pixGetInvBackgroundMap(pixs, bgval, smoothx, smoothy) as Pix
	// pixGetInvBackgroundMap(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) bgval should typically be  is greater  120 and  is smaller 240<para/>
	///
	/// (2) pixd is a normalization image the original image is
	/// multiplied by pixd and the result is divided by 256.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetInvBackgroundMap/*"/>
	///  <param name="bgval">[in] - target bg val typ.  is greater  128</param>
	///  <param name="smoothx">[in] - half-width of block convolution kernel width</param>
	///  <param name="smoothy">[in] - half-width of block convolution kernel height</param>
	///   <returns>pixd 16 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GetInvBackgroundMap (int bgval,
									int smoothx,
									int smoothy)
	{
		Pix RetObj = _All.pixGetInvBackgroundMap(this, bgval, smoothx, smoothy);
		return RetObj;
	}

	// adaptmap.c (1903, 1)
	// pixApplyInvBackgroundGrayMap(pixs, pixm, sx, sy) as Pix
	// pixApplyInvBackgroundGrayMap(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixApplyInvBackgroundGrayMap()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixApplyInvBackgroundGrayMap/*"/>
	///  <param name="pixm">[in] - 16 bpp, inverse background map</param>
	///  <param name="sx">[in] - tile width in pixels</param>
	///  <param name="sy">[in] - tile height in pixels</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ApplyInvBackgroundGrayMap (Pix pixm,
										  int sx,
										  int sy)
	{
		Pix RetObj = _All.pixApplyInvBackgroundGrayMap(this, pixm, sx, sy);
		return RetObj;
	}

	// adaptmap.c (1969, 1)
	// pixApplyInvBackgroundRGBMap(pixs, pixmr, pixmg, pixmb, sx, sy) as Pix
	// pixApplyInvBackgroundRGBMap(PIX *, PIX *, PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixApplyInvBackgroundRGBMap()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixApplyInvBackgroundRGBMap/*"/>
	///  <param name="pixmr">[in] - 16 bpp, red inverse background map</param>
	///  <param name="pixmg">[in] - 16 bpp, green inverse background map</param>
	///  <param name="pixmb">[in] - 16 bpp, blue inverse background map</param>
	///  <param name="sx">[in] - tile width in pixels</param>
	///  <param name="sy">[in] - tile height in pixels</param>
	///   <returns>pixd 32 bpp rbg, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ApplyInvBackgroundRGBMap (Pix pixmr,
										 Pix pixmg,
										 Pix pixmb,
										 int sx,
										 int sy)
	{
		Pix RetObj = _All.pixApplyInvBackgroundRGBMap(this, pixmr, pixmg, pixmb, sx, sy);
		return RetObj;
	}

	// adaptmap.c (2067, 1)
	// pixApplyVariableGrayMap(pixs, pixg, target) as Pix
	// pixApplyVariableGrayMap(PIX *, PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Suppose you have an image that you want to transform based
	/// on some photometric measurement at each point, such as the
	/// threshold value for binarization.  Representing the photometric
	/// measurement as an image pixg, you can threshold in input image
	/// using pixVarThresholdToBinary().  Alternatively, you can map
	/// the input image pointwise so that the threshold over the
	/// entire image becomes a constant, such as 128.  For example,
	/// if a pixel in pixg is 150 and the target is 128, the
	/// corresponding pixel in pixs is mapped linearly to a value
	/// (128/150) of the input value.  If the resulting mapped image
	/// pixd were then thresholded at 128, you would obtain the
	/// same result as a direct binarization using pixg with
	/// pixVarThresholdToBinary().<para/>
	///
	/// (2) The sizes of pixs and pixg must be equal.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixApplyVariableGrayMap/*"/>
	///  <param name="pixg">[in] - 8 bpp, variable map</param>
	///  <param name="target">[in] - typ. 128 for threshold</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ApplyVariableGrayMap (Pix pixg,
									 int target)
	{
		Pix RetObj = _All.pixApplyVariableGrayMap(this, pixg, target);
		return RetObj;
	}

	// adaptmap.c (2185, 1)
	// pixGlobalNormRGB(pixd, pixs, rval, gval, bval, mapval) as Pix
	// pixGlobalNormRGB(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The value of pixd determines if the results are written to a
	/// new pix (use NULL), in-place to pixs (use pixs), or to some
	/// other existing pix.<para/>
	///
	/// (2) This does a global normalization of an image where the
	/// r,g,b color components are not balanced.  Thus, white in pixs is
	/// represented by a set of r,g,b values that are not all 255.<para/>
	///
	/// (3) The input values (rval, gval, bval) should be chosen to
	/// represent the gray color (mapval, mapval, mapval) in src.
	/// Thus, this function will map (rval, gval, bval) to that gray color.<para/>
	///
	/// (4) Typically, mapval = 255, so that (rval, gval, bval)
	/// corresponds to the white point of src.  In that case, these
	/// parameters should be chosen so that few pixels have higher values.<para/>
	///
	/// (5) In all cases, we do a linear TRC separately on each of the
	/// components, saturating at 255.<para/>
	///
	/// (6) If the input pix is 8 bpp without a colormap, you can get
	/// this functionality with mapval = 255 by calling:
	/// pixGammaTRC(pixd, pixs, 1.0, 0, bgval)
	/// where bgval is the value you want to be mapped to 255.
	/// Or more generally, if you want bgval to be mapped to mapval:
	/// pixGammaTRC(pixd, pixs, 1.0, 0, 255  bgval / mapval)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGlobalNormRGB/*"/>
	///  <param name="pixd">[in][optional] - null, existing or equal to pixs</param>
	///  <param name="rval">[in] - pixel values in pixs that are linearly mapped to mapval</param>
	///  <param name="gval">[in] - pixel values in pixs that are linearly mapped to mapval</param>
	///  <param name="bval">[in] - pixel values in pixs that are linearly mapped to mapval</param>
	///  <param name="mapval">[in] - use 255 for mapping to white</param>
	///   <returns>pixd 32 bpp rgb or colormapped, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GlobalNormRGB (int rval,
							  int gval,
							  int bval,
							  int mapval,
							  Pix pixd)
	{
		Pix RetObj = _All.pixGlobalNormRGB(pixd, this, rval, gval, bval, mapval);
		return RetObj;
	}

	// adaptmap.c (2294, 1)
	// pixGlobalNormNoSatRGB(pixd, pixs, rval, gval, bval, factor, rank) as Pix
	// pixGlobalNormNoSatRGB(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_float32) as PIX *
	///  <summary>
	/// (1) This is a version of pixGlobalNormRGB(), where the output
	/// intensity is scaled back so that a controlled fraction of
	/// pixel components is allowed to saturate.  See comments in
	/// pixGlobalNormRGB().<para/>
	///
	/// (2) The value of pixd determines if the results are written to a
	/// new pix (use NULL), in-place to pixs (use pixs), or to some
	/// other existing pix.<para/>
	///
	/// (3) This does a global normalization of an image where the
	/// r,g,b color components are not balanced.  Thus, white in pixs is
	/// represented by a set of r,g,b values that are not all 255.<para/>
	///
	/// (4) The input values (rval, gval, bval) can be chosen to be the
	/// color that, after normalization, becomes white background.
	/// For images that are mostly background, the closer these values
	/// are to the median component values, the closer the resulting
	/// background will be to gray, becoming white at the brightest places.<para/>
	///
	/// (5) The mapval used in pixGlobalNormRGB() is computed here to
	/// avoid saturation of any component in the image (save for a
	/// fraction of the pixels given by the input rank value).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGlobalNormNoSatRGB/*"/>
	///  <param name="pixd">[in][optional] - null, existing or equal to pixs</param>
	///  <param name="rval">[in] - pixel values in pixs that are linearly mapped to mapval but see below</param>
	///  <param name="gval">[in] - pixel values in pixs that are linearly mapped to mapval but see below</param>
	///  <param name="bval">[in] - pixel values in pixs that are linearly mapped to mapval but see below</param>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///  <param name="rank">[in] - between 0.0 and 1.0 typ. use a value near 1.0</param>
	///   <returns>pixd 32 bpp rgb, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GlobalNormNoSatRGB (int rval,
								   int gval,
								   int bval,
								   int factor,
								   Single rank,
								   Pix pixd)
	{
		Pix RetObj = _All.pixGlobalNormNoSatRGB(pixd, this, rval, gval, bval, factor, rank);
		return RetObj;
	}

	// adaptmap.c (2394, 1)
	// pixThresholdSpreadNorm(pixs, filtertype, edgethresh, smoothx, smoothy, gamma, minval, maxval, targetthresh, ppixth, ppixb, ppixd) as int
	// pixThresholdSpreadNorm(PIX *, l_int32, l_int32, l_int32, l_int32, l_float32, l_int32, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) The basis of this approach is the use of seed spreading
	/// on a (possibly) sparse set of estimates for the local threshold.
	/// The resulting dense estimates are smoothed by convolution
	/// and used to either threshold the input image or normalize it
	/// with a local transformation that linearly maps the pixels so
	/// that the local threshold estimate becomes constant over the
	/// resulting image.  This approach is one of several that
	/// have been suggested (and implemented) by Ray Smith.<para/>
	///
	/// (2) You can use either the Sobel or TwoSided edge filters.
	/// The results appear to be similar, using typical values
	/// of edgethresh in the rang 10-20.<para/>
	///
	/// (3) To skip the trc enhancement, use gamma = 1.0, minval = 0
	/// and maxval = 255.<para/>
	///
	/// (4) For the normalized image pixd, each pixel is linearly mapped
	/// in such a way that the local threshold is equal to targetthresh.<para/>
	///
	/// (5) The full width and height of the convolution kernel
	/// are (2  smoothx + 1) and (2  smoothy + 1).<para/>
	///
	/// (6) This function can be used with the pixtiling utility if the
	/// images are too large.  See pixOtsuAdaptiveThreshold() for
	/// an example of this.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixThresholdSpreadNorm/*"/>
	///  <param name="filtertype">[in] - L_SOBEL_EDGE or L_TWO_SIDED_EDGE</param>
	///  <param name="edgethresh">[in] - threshold on magnitude of edge filter typ 10-20</param>
	///  <param name="smoothx">[in] - half-width of convolution kernel applied to spread threshold: use 0 for no smoothing</param>
	///  <param name="smoothy">[in] - half-width of convolution kernel applied to spread threshold: use 0 for no smoothing</param>
	///  <param name="gamma">[in] - gamma correction typ. about 0.7</param>
	///  <param name="minval">[in] - input value that gives 0 for output typ. -25</param>
	///  <param name="maxval">[in] - input value that gives 255 for output typ. 255</param>
	///  <param name="targetthresh">[in] - target threshold for normalization</param>
	///  <param name="ppixth">[out][optional] - computed local threshold value</param>
	///  <param name="ppixb">[out][optional] - thresholded normalized image</param>
	///  <param name="ppixd">[out][optional] - normalized image</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ThresholdSpreadNorm (int filtertype,
									int edgethresh,
									int smoothx,
									int smoothy,
									Single gamma,
									int minval,
									int maxval,
									int targetthresh,
									out Pix ppixth,
									out Pix ppixb,
									out Pix ppixd)
	{
		int RetObj = _All.pixThresholdSpreadNorm(this, filtertype, edgethresh, smoothx, smoothy, gamma, minval, maxval, targetthresh, out ppixth, out ppixb, out ppixd);
		return RetObj;
	}

	// adaptmap.c (2500, 1)
	// pixBackgroundNormFlex(pixs, sx, sy, smoothx, smoothy, delta) as Pix
	// pixBackgroundNormFlex(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This does adaptation flexibly to a quickly varying background.
	/// For that reason, all input parameters should be small.<para/>
	///
	/// (2) sx and sy give the tile size they should be in [5 - 7].<para/>
	///
	/// (3) The full width and height of the convolution kernel
	/// are (2  smoothx + 1) and (2  smoothy + 1).  They
	/// should be in [1 - 2].<para/>
	///
	/// (4) Basin filling is used to fill the large fg regions.  The
	/// parameter %delta measures the height that the black
	/// background is raised from the local minima.  By raising
	/// the background, it is possible to threshold the large
	/// fg regions to foreground.  If %delta is too large,
	/// bg regions will be lifted, causing thickening of
	/// the fg regions.  Use 0 to skip.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBackgroundNormFlex/*"/>
	///  <param name="sx">[in] - desired tile dimensions actual size may vary use values between 3 and 10</param>
	///  <param name="sy">[in] - desired tile dimensions actual size may vary use values between 3 and 10</param>
	///  <param name="smoothx">[in] - half-width of convolution kernel applied to threshold array: use values between 1 and 3</param>
	///  <param name="smoothy">[in] - half-width of convolution kernel applied to threshold array: use values between 1 and 3</param>
	///  <param name="delta">[in] - difference parameter in basin filling use 0 to skip</param>
	///   <returns>pixd 8 bpp, background-normalized), or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BackgroundNormFlex (int sx,
								   int sy,
								   int smoothx,
								   int smoothy,
								   int delta)
	{
		Pix RetObj = _All.pixBackgroundNormFlex(this, sx, sy, smoothx, smoothy, delta);
		return RetObj;
	}

	// adaptmap.c (2595, 1)
	// pixContrastNorm(pixd, pixs, sx, sy, mindiff, smoothx, smoothy) as Pix
	// pixContrastNorm(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This function adaptively attempts to expand the contrast
	/// to the full dynamic range in each tile.  If the contrast in
	/// a tile is smaller than %mindiff, it uses the min and max
	/// pixel values from neighboring tiles.  It also can use
	/// convolution to smooth the min and max values from
	/// neighboring tiles.  After all that processing, it is
	/// possible that the actual pixel values in the tile are outside
	/// the computed [min ... max] range for local contrast
	/// normalization.  Such pixels are taken to be at either 0
	/// (if below the min) or 255 (if above the max).<para/>
	///
	/// (2) pixd can be equal to pixs (in-place operation) or
	/// null (makes a new pixd).<para/>
	///
	/// (3) sx and sy give the tile size they are typically at least 20.<para/>
	///
	/// (4) mindiff is used to eliminate results for tiles where it is
	/// likely that either fg or bg is missing.  A value around 50
	/// or more is reasonable.<para/>
	///
	/// (5) The full width and height of the convolution kernel
	/// are (2  smoothx + 1) and (2  smoothy + 1).  Some smoothing
	/// is typically useful, and we limit the smoothing half-widths
	/// to the range from 0 to 8.<para/>
	///
	/// (6) A linear TRC (gamma = 1.0) is applied to increase the contrast
	/// in each tile.  The result can subsequently be globally corrected,
	/// by applying pixGammaTRC() with arbitrary values of gamma
	/// and the 0 and 255 points of the mapping.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixContrastNorm/*"/>
	///  <param name="pixd">[in][optional] - 8 bpp null or equal to pixs</param>
	///  <param name="sx">[in] - tile dimensions</param>
	///  <param name="sy">[in] - tile dimensions</param>
	///  <param name="mindiff">[in] - minimum difference to accept as valid</param>
	///  <param name="smoothx">[in] - half-width of convolution kernel applied to min and max arrays: use 0 for no smoothing</param>
	///  <param name="smoothy">[in] - half-width of convolution kernel applied to min and max arrays: use 0 for no smoothing</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ContrastNorm (int sx,
							 int sy,
							 int mindiff,
							 int smoothx,
							 int smoothy,
							 Pix pixd)
	{
		Pix RetObj = _All.pixContrastNorm(pixd, this, sx, sy, mindiff, smoothx, smoothy);
		return RetObj;
	}

	// adaptmap.c (2655, 1)
	// pixMinMaxTiles(pixs, sx, sy, mindiff, smoothx, smoothy, ppixmin, ppixmax) as int
	// pixMinMaxTiles(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) This computes filtered and smoothed values for the min and
	/// max pixel values in each tile of the image.<para/>
	///
	/// (2) See pixContrastNorm() for usage.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMinMaxTiles/*"/>
	///  <param name="sx">[in] - tile dimensions</param>
	///  <param name="sy">[in] - tile dimensions</param>
	///  <param name="mindiff">[in] - minimum difference to accept as valid</param>
	///  <param name="smoothx">[in] - half-width of convolution kernel applied to min and max arrays: use 0 for no smoothing</param>
	///  <param name="smoothy">[in] - half-width of convolution kernel applied to min and max arrays: use 0 for no smoothing</param>
	///  <param name="ppixmin">[out] - tiled minima</param>
	///  <param name="ppixmax">[out] - tiled maxima</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int MinMaxTiles (int sx,
							int sy,
							int mindiff,
							int smoothx,
							int smoothy,
							out Pix ppixmin,
							out Pix ppixmax)
	{
		int RetObj = _All.pixMinMaxTiles(this, sx, sy, mindiff, smoothx, smoothy, out ppixmin, out ppixmax);
		return RetObj;
	}

	// adaptmap.c (2746, 1)
	// pixSetLowContrast(pixs1, pixs2, mindiff) as int
	// pixSetLowContrast(PIX *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) This compares corresponding pixels in pixs1 and pixs2.
	/// When they differ by less than %mindiff, set the pixel
	/// values to 0 in each.  Each pixel typically represents a tile
	/// in a larger image, and a very small difference between
	/// the min and max in the tile indicates that the min and max
	/// values are not to be trusted.<para/>
	///
	/// (2) If contrast (pixel difference) detection is expected to fail,
	/// caller should check return value.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetLowContrast/*"/>
	///  <param name="pixs1">[in] - 8 bpp</param>
	///  <param name="pixs2">[in] - 8 bpp</param>
	///  <param name="mindiff">[in] - minimum difference to accept as valid</param>
	///   <returns>0 if OK 1 if no pixel diffs are large enough, or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetLowContrast (Pix pixs1,
							   Pix pixs2,
							   int mindiff)
	{
		int RetObj = _All.pixSetLowContrast(pixs1, pixs2, mindiff);
		return RetObj;
	}

	// adaptmap.c (2829, 1)
	// pixLinearTRCTiled(pixd, pixs, sx, sy, pixmin, pixmax) as Pix
	// pixLinearTRCTiled(PIX *, PIX *, l_int32, l_int32, PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) pixd can be equal to pixs (in-place operation) or
	/// null (makes a new pixd).<para/>
	///
	/// (2) sx and sy give the tile size they are typically at least 20.<para/>
	///
	/// (3) pixmin and pixmax are generated by pixMinMaxTiles()<para/>
	///
	/// (4) For each tile, this does a linear expansion of the dynamic
	/// range so that the min value in the tile becomes 0 and the
	/// max value in the tile becomes 255.<para/>
	///
	/// (5) The LUTs that do the mapping are generated as needed
	/// and stored for reuse in an integer array within the ptr array iaa[].
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixLinearTRCTiled/*"/>
	///  <param name="pixd">[in][optional] - 8 bpp</param>
	///  <param name="sx">[in] - tile dimensions</param>
	///  <param name="sy">[in] - tile dimensions</param>
	///  <param name="pixmin">[in] - pix of min values in tiles</param>
	///  <param name="pixmax">[in] - pix of max values in tiles</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix LinearTRCTiled (int sx,
							   int sy,
							   Pix pixmin,
							   Pix pixmax,
							   Pix pixd)
	{
		Pix RetObj = _All.pixLinearTRCTiled(pixd, this, sx, sy, pixmin, pixmax);
		return RetObj;
	}

	// affine.c (280, 1)
	// pixAffineSampledPta(pixs, ptad, ptas, incolor) as Pix
	// pixAffineSampledPta(PIX *, PTA *, PTA *, l_int32) as PIX *
	///  <summary>
	/// (1) Brings in either black or white pixels from the boundary.<para/>
	///
	/// (2) Retains colormap, which you can do for a sampled transform..<para/>
	///
	/// (3) The 3 points must not be collinear.<para/>
	///
	/// (4) The order of the 3 points is arbitrary however, to compare
	/// with the sequential transform they must be in these locations
	/// and in this order: origin, x-axis, y-axis.<para/>
	///
	/// (5) For 1 bpp images, this has much better quality results
	/// than pixAffineSequential(), particularly for text.
	/// It is about 3x slower, but does not require additional
	/// border pixels.  The poor quality of pixAffineSequential()
	/// is due to repeated quantized transforms.  It is strongly
	/// recommended that pixAffineSampled() be used for 1 bpp images.<para/>
	///
	/// (6) For 8 or 32 bpp, much better quality is obtained by the
	/// somewhat slower pixAffinePta().  See that function
	/// for relative timings between sampled and interpolated.<para/>
	///
	/// (7) To repeat, use of the sequential transform,
	/// pixAffineSequential(), for any images, is discouraged.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAffineSampledPta/*"/>
	///  <param name="ptad">[in] - 3 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 3 pts of initial coordinate space</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AffineSampledPta (Pta ptad,
								 Pta ptas,
								 int incolor)
	{
		Pix RetObj = _All.pixAffineSampledPta(this, ptad, ptas, incolor);
		return RetObj;
	}

	// affine.c (330, 1)
	// pixAffineSampled(pixs, vc, incolor) as Pix
	// pixAffineSampled(PIX *, l_float32 *, l_int32) as PIX *
	///  <summary>
	/// (1) Brings in either black or white pixels from the boundary.<para/>
	///
	/// (2) Retains colormap, which you can do for a sampled transform..<para/>
	///
	/// (3) For 8 or 32 bpp, much better quality is obtained by the
	/// somewhat slower pixAffine().  See that function
	/// for relative timings between sampled and interpolated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAffineSampled/*"/>
	///  <param name="vc">[in] - vector of 6 coefficients for affine transformation</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AffineSampled (Single[] vc,
							  int incolor)
	{
		Pix RetObj = _All.pixAffineSampled(this, vc, incolor);
		return RetObj;
	}

	// affine.c (423, 1)
	// pixAffinePta(pixs, ptad, ptas, incolor) as Pix
	// pixAffinePta(PIX *, PTA *, PTA *, l_int32) as PIX *
	///  <summary>
	/// (1) Brings in either black or white pixels from the boundary<para/>
	///
	/// (2) Removes any existing colormap, if necessary, before transforming
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAffinePta/*"/>
	///  <param name="ptad">[in] - 3 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 3 pts of initial coordinate space</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AffinePta (Pta ptad,
						  Pta ptas,
						  int incolor)
	{
		Pix RetObj = _All.pixAffinePta(this, ptad, ptas, incolor);
		return RetObj;
	}

	// affine.c (493, 1)
	// pixAffine(pixs, vc, incolor) as Pix
	// pixAffine(PIX *, l_float32 *, l_int32) as PIX *
	///  <summary>
	/// (1) Brings in either black or white pixels from the boundary<para/>
	///
	/// (2) Removes any existing colormap, if necessary, before transforming
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAffine/*"/>
	///  <param name="vc">[in] - vector of 6 coefficients for affine transformation</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Affine (Single[] vc,
					   int incolor)
	{
		Pix RetObj = _All.pixAffine(this, vc, incolor);
		return RetObj;
	}

	// affine.c (549, 1)
	// pixAffinePtaColor(pixs, ptad, ptas, colorval) as Pix
	// pixAffinePtaColor(PIX *, PTA *, PTA *, l_uint32) as PIX *
	///  <summary>
	/// pixAffinePtaColor()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAffinePtaColor/*"/>
	///  <param name="ptad">[in] - 3 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 3 pts of initial coordinate space</param>
	///  <param name="colorval">[in] - e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AffinePtaColor (Pta ptad,
							   Pta ptas,
							   uint colorval)
	{
		Pix RetObj = _All.pixAffinePtaColor(this, ptad, ptas, colorval);
		return RetObj;
	}

	// affine.c (590, 1)
	// pixAffineColor(pixs, vc, colorval) as Pix
	// pixAffineColor(PIX *, l_float32 *, l_uint32) as PIX *
	///  <summary>
	/// pixAffineColor()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAffineColor/*"/>
	///  <param name="vc">[in] - vector of 6 coefficients for affine transformation</param>
	///  <param name="colorval">[in] - e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AffineColor (Single[] vc,
							uint colorval)
	{
		Pix RetObj = _All.pixAffineColor(this, vc, colorval);
		return RetObj;
	}

	// affine.c (652, 1)
	// pixAffinePtaGray(pixs, ptad, ptas, grayval) as Pix
	// pixAffinePtaGray(PIX *, PTA *, PTA *, l_uint8) as PIX *
	///  <summary>
	/// pixAffinePtaGray()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAffinePtaGray/*"/>
	///  <param name="ptad">[in] - 3 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 3 pts of initial coordinate space</param>
	///  <param name="grayval">[in] - 0 to bring in BLACK, 255 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AffinePtaGray (Pta ptad,
							  Pta ptas,
							  byte grayval)
	{
		Pix RetObj = _All.pixAffinePtaGray(this, ptad, ptas, grayval);
		return RetObj;
	}

	// affine.c (694, 1)
	// pixAffineGray(pixs, vc, grayval) as Pix
	// pixAffineGray(PIX *, l_float32 *, l_uint8) as PIX *
	///  <summary>
	/// pixAffineGray()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAffineGray/*"/>
	///  <param name="vc">[in] - vector of 6 coefficients for affine transformation</param>
	///  <param name="grayval">[in] - 0 to bring in BLACK, 255 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AffineGray (Single[] vc,
						   byte grayval)
	{
		Pix RetObj = _All.pixAffineGray(this, vc, grayval);
		return RetObj;
	}

	// affine.c (782, 1)
	// pixAffinePtaWithAlpha(pixs, ptad, ptas, pixg, fract, border) as Pix
	// pixAffinePtaWithAlpha(PIX *, PTA *, PTA *, PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) The alpha channel is transformed separately from pixs,
	/// and aligns with it, being fully transparent outside the
	/// boundary of the transformed pixs.  For pixels that are fully
	/// transparent, a blending function like pixBlendWithGrayMask()
	/// will give zero weight to corresponding pixels in pixs.<para/>
	///
	/// (2) If pixg is NULL, it is generated as an alpha layer that is
	/// partially opaque, using %fract.  Otherwise, it is cropped
	/// to pixs if required and %fract is ignored.  The alpha channel
	/// in pixs is never used.<para/>
	///
	/// (3) Colormaps are removed.<para/>
	///
	/// (4) When pixs is transformed, it doesn't matter what color is brought
	/// in because the alpha channel will be transparent (0) there.<para/>
	///
	/// (5) To avoid losing source pixels in the destination, it may be
	/// necessary to add a border to the source pix before doing
	/// the affine transformation.  This can be any non-negative number.<para/>
	///
	/// (6) The input %ptad and %ptas are in a coordinate space before
	/// the border is added.  Internally, we compensate for this
	/// before doing the affine transform on the image after the border
	/// is added.<para/>
	///
	/// (7) The default setting for the border values in the alpha channel
	/// is 0 (transparent) for the outermost ring of pixels and
	/// (0.5  fract  255) for the second ring.  When blended over
	/// a second image, this
	/// (a) shrinks the visible image to make a clean overlap edge
	/// with an image below, and
	/// (b) softens the edges by weakening the aliasing there.
	/// Use l_setAlphaMaskBorder() to change these values.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAffinePtaWithAlpha/*"/>
	///  <param name="ptad">[in] - 3 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 3 pts of initial coordinate space</param>
	///  <param name="pixg">[in][optional] - 8 bpp, can be null</param>
	///  <param name="fract">[in] - between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	///  <param name="border">[in] - of pixels added to capture transformed source pixels</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AffinePtaWithAlpha (Pta ptad,
								   Pta ptas,
								   Single fract,
								   int border,
								   Pix pixg)
	{
		Pix RetObj = _All.pixAffinePtaWithAlpha(this, ptad, ptas, pixg, fract, border);
		return RetObj;
	}

	// affine.c (1470, 1)
	// pixAffineSequential(pixs, ptad, ptas, bw, bh) as Pix
	// pixAffineSequential(PIX *, PTA *, PTA *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The 3 pts must not be collinear.<para/>
	///
	/// (2) The 3 pts must be given in this order:
	/// ~ origin
	/// ~ a location along the x-axis
	/// ~ a location along the y-axis.<para/>
	///
	/// (3) You must guess how much border must be added so that no
	/// pixels are lost in the transformations from src to
	/// dest coordinate space.  (This can be calculated but it
	/// is a lot of work!)  For coordinate spaces that are nearly
	/// at right angles, on a 300 ppi scanned page, the addition
	/// of 1000 pixels on each side is usually sufficient.<para/>
	///
	/// (4) This is here for pedagogical reasons.  It is about 3x faster
	/// on 1 bpp images than pixAffineSampled(), but the results
	/// on text are much inferior.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAffineSequential/*"/>
	///  <param name="ptad">[in] - 3 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 3 pts of initial coordinate space</param>
	///  <param name="bw">[in] - pixels of additional border width during computation</param>
	///  <param name="bh">[in] - pixels of additional border height during computation</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AffineSequential (Pta ptad,
								 Pta ptas,
								 int bw,
								 int bh)
	{
		Pix RetObj = _All.pixAffineSequential(this, ptad, ptas, bw, bh);
		return RetObj;
	}

	// baseline.c (113, 1)
	// pixFindBaselines(pixs, ppta, pixadb) as Numa
	// pixFindBaselines(PIX *, PTA **, PIXA *) as NUMA *
	///  <summary>
	/// (1) Input binary image must have text lines already aligned
	/// horizontally.  This can be done by either rotating the
	/// image with pixDeskew(), or, if a projective transform
	/// is required, by doing pixDeskewLocal() first.<para/>
	///
	/// (2) Input null for [and]pta if you don't want this returned.
	/// The pta will come in pairs of points (left and right end
	/// of each baseline).<para/>
	///
	/// (3) Caution: this will not work properly on text with multiple
	/// columns, where the lines are not aligned between columns.
	/// If there are multiple columns, they should be extracted
	/// separately before finding the baselines.<para/>
	///
	/// (4) This function constructs different types of output
	/// for baselines namely, a set of raster line values and
	/// a set of end points of each baseline.<para/>
	///
	/// (5) This function was designed to handle short and long text lines
	/// without using dangerous thresholds on the peak heights.  It does
	/// this by combining the differential signal with a morphological
	/// analysis of the locations of the text lines.  One can also
	/// combine this data to normalize the peak heights, by weighting
	/// the differential signal in the region of each baseline
	/// by the inverse of the width of the text line found there.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindBaselines/*"/>
	///  <param name="ppta">[out][optional] - pairs of pts corresponding to approx. ends of each text line</param>
	///  <param name="pixadb">[in] - for debug output use NULL to skip</param>
	///   <returns>na of baseline y values, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa FindBaselines (Pixa pixadb,
							   out Pta ppta)
	{
		Numa RetObj = _All.pixFindBaselines(this, out ppta, pixadb);
		return RetObj;
	}

	// baseline.c (320, 1)
	// pixDeskewLocal(pixs, nslices, redsweep, redsearch, sweeprange, sweepdelta, minbsdelta) as Pix
	// pixDeskewLocal(PIX *, l_int32, l_int32, l_int32, l_float32, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) This function allows deskew of a page whose skew changes
	/// approximately linearly with vertical position.  It uses
	/// a projective transform that in effect does a differential
	/// shear about the LHS of the page, and makes all text lines
	/// horizontal.<para/>
	///
	/// (2) The origin of the keystoning can be either a cheap document
	/// feeder that rotates the page as it is passed through, or a
	/// camera image taken from either the left or right side
	/// of the vertical.<para/>
	///
	/// (3) The image transformation is a projective warping,
	/// not a rotation.  Apart from this function, the text lines
	/// must be properly aligned vertically with respect to each
	/// other.  This can be done by pre-processing the page e.g.,
	/// by rotating or horizontally shearing it.
	/// Typically, this can be achieved by vertically aligning
	/// the page edge.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDeskewLocal/*"/>
	///  <param name="nslices">[in] - the number of horizontal overlapping slices must be larger than 1 and not exceed 20 use 0 for default</param>
	///  <param name="redsweep">[in] - sweep reduction factor: 1, 2, 4 or 8 use 0 for default value</param>
	///  <param name="redsearch">[in] - search reduction factor: 1, 2, 4 or 8, and not larger than redsweep use 0 for default value</param>
	///  <param name="sweeprange">[in] - half the full range, assumed about 0 in degrees use 0.0 for default value</param>
	///  <param name="sweepdelta">[in] - angle increment of sweep in degrees use 0.0 for default value</param>
	///  <param name="minbsdelta">[in] - min binary search increment angle in degrees use 0.0 for default value</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DeskewLocal (int nslices,
							int redsweep,
							int redsearch,
							Single sweeprange,
							Single sweepdelta,
							Single minbsdelta)
	{
		Pix RetObj = _All.pixDeskewLocal(this, nslices, redsweep, redsearch, sweeprange, sweepdelta, minbsdelta);
		return RetObj;
	}

	// baseline.c (388, 1)
	// pixGetLocalSkewTransform(pixs, nslices, redsweep, redsearch, sweeprange, sweepdelta, minbsdelta, pptas, pptad) as int
	// pixGetLocalSkewTransform(PIX *, l_int32, l_int32, l_int32, l_float32, l_float32, l_float32, PTA **, PTA **) as l_ok
	///  <summary>
	/// (1) This generates two pairs of points in the src, each pair
	/// corresponding to a pair of points that would lie along
	/// the same raster line in a transformed (dewarped) image.<para/>
	///
	/// (2) The sets of 4 src and 4 dest points returned by this function
	/// can then be used, in a projective or bilinear transform,
	/// to remove keystoning in the src.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetLocalSkewTransform/*"/>
	///  <param name="nslices">[in] - the number of horizontal overlapping slices must be larger than 1 and not exceed 20 use 0 for default</param>
	///  <param name="redsweep">[in] - sweep reduction factor: 1, 2, 4 or 8 use 0 for default value</param>
	///  <param name="redsearch">[in] - search reduction factor: 1, 2, 4 or 8, and not larger than redsweep use 0 for default value</param>
	///  <param name="sweeprange">[in] - half the full range, assumed about 0 in degrees use 0.0 for default value</param>
	///  <param name="sweepdelta">[in] - angle increment of sweep in degrees use 0.0 for default value</param>
	///  <param name="minbsdelta">[in] - min binary search increment angle in degrees use 0.0 for default value</param>
	///  <param name="pptas">[out] - 4 points in the source</param>
	///  <param name="pptad">[out] - the corresponding 4 pts in the dest</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetLocalSkewTransform (int nslices,
									  out Pta pptas,
									  out Pta pptad,
									  int redsweep,
									  int redsearch,
									  Single sweeprange,
									  Single sweepdelta,
									  Single minbsdelta)
	{
		int RetObj = _All.pixGetLocalSkewTransform(this, nslices, redsweep, redsearch, sweeprange, sweepdelta, minbsdelta, out pptas, out pptad);
		return RetObj;
	}

	// baseline.c (506, 1)
	// pixGetLocalSkewAngles(pixs, nslices, redsweep, redsearch, sweeprange, sweepdelta, minbsdelta, pa, pb, debug) as Numa
	// pixGetLocalSkewAngles(PIX *, l_int32, l_int32, l_int32, l_float32, l_float32, l_float32, l_float32 *, l_float32 *, l_int32) as NUMA *
	///  <summary>
	/// (1) The local skew is measured in a set of overlapping strips.
	/// We then do a least square linear fit parameters to get
	/// the slope and intercept parameters a and b in
	/// skew-angle = a  y + b  (degrees)
	/// for the local skew as a function of raster line y.
	/// This is then used to make naskew, which can be interpreted
	/// as the computed skew angle (in degrees) at the left edge
	/// of each raster line.<para/>
	///
	/// (2) naskew can then be used to find the baselines of text, because
	/// each text line has a baseline that should intersect
	/// the left edge of the image with the angle given by this
	/// array, evaluated at the raster line of intersection.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetLocalSkewAngles/*"/>
	///  <param name="nslices">[in] - the number of horizontal overlapping slices must be larger than 1 and not exceed 20 0 for default</param>
	///  <param name="redsweep">[in] - sweep reduction factor: 1, 2, 4 or 8 use 0 for default value</param>
	///  <param name="redsearch">[in] - search reduction factor: 1, 2, 4 or 8, and not larger than redsweep use 0 for default value</param>
	///  <param name="sweeprange">[in] - half the full range, assumed about 0 in degrees use 0.0 for default value</param>
	///  <param name="sweepdelta">[in] - angle increment of sweep in degrees use 0.0 for default value</param>
	///  <param name="minbsdelta">[in] - min binary search increment angle in degrees use 0.0 for default value</param>
	///  <param name="pa">[out][optional] - slope of skew as fctn of y</param>
	///  <param name="pb">[out][optional] - intercept at y=0 of skew as fctn of y</param>
	///  <param name="debug">[in] - 1 for generating plot of skew angle vs. y 0 otherwise</param>
	///   <returns>naskew, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetLocalSkewAngles (int nslices,
									int redsweep,
									int redsearch,
									Single sweeprange,
									Single sweepdelta,
									Single minbsdelta,
									out Single pa,
									out Single pb,
									DebugOnOff debug)
	{
		Numa RetObj = _All.pixGetLocalSkewAngles(this, nslices, redsweep, redsearch, sweeprange, sweepdelta, minbsdelta, out pa, out pb, debug);
		return RetObj;
	}

	// bilateral.c (150, 1)
	// pixBilateral(pixs, spatial_stdev, range_stdev, ncomps, reduction) as Pix
	// pixBilateral(PIX *, l_float32, l_float32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This performs a relatively fast, separable bilateral
	/// filtering operation.  The time is proportional to ncomps
	/// and varies inversely approximately as the cube of the
	/// reduction factor.  See bilateral.h for algorithm details.<para/>
	///
	/// (2) We impose minimum values for range_stdev and ncomps to
	/// avoid nasty artifacts when either are too small.  We also
	/// impose a constraint on their product:
	/// ncomps  range_stdev greater or equal 100.
	/// So for values of range_stdev greater or equal 25, ncomps can be as small as 4.
	/// Here is a qualitative, intuitive explanation for this constraint.
	/// Call the difference in k values between the J(k) == 'delta', where
	/// 'delta' ~ 200 / ncomps
	/// Then this constraint is roughly equivalent to the condition:
	/// 'delta'  is smaller 2  range_stdev
	/// Note that at an intensity difference of (2  range_stdev), the
	/// range part of the kernel reduces the effect by the factor 0.14.
	/// This constraint requires that we have a sufficient number of
	/// PCBs (i.e, a small enough 'delta'), so that for any value of
	/// image intensity I, there exists a k (and a PCB, J(k), such that
	/// |I - k|  is smaller range_stdev
	/// Any fewer PCBs and we don't have enough to support this condition.<para/>
	///
	/// (3) The upper limit of 30 on ncomps is imposed because the
	/// gain in accuracy is not worth the extra computation.<para/>
	///
	/// (4) The size of the gaussian kernel is twice the spatial_stdev
	/// on each side of the origin.  The minimum value of
	/// spatial_stdev, 0.5, is required to have a finite sized
	/// spatial kernel.  In practice, a much larger value is used.<para/>
	///
	/// (5) Computation of the intermediate images goes inversely
	/// as the cube of the reduction factor.  If you can use a
	/// reduction of 2 or 4, it is well-advised.<para/>
	///
	/// (6) The range kernel is defined over the absolute value of pixel
	/// grayscale differences, and hence must have size 256 x 1.
	/// Values in the array represent the multiplying weight
	/// depending on the absolute gray value difference between
	/// the source pixel and the neighboring pixel, and should
	/// be monotonically decreasing.<para/>
	///
	/// (7) Interesting observation.  Run this on prog/fish24.jpg, with
	/// range_stdev = 60, ncomps = 6, and spatial_dev = {10, 30, 50}.
	/// As spatial_dev gets larger, we get the counter-intuitive
	/// result that the body of the red fish becomes less blurry.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBilateral/*"/>
	///  <param name="spatial_stdev">[in] - of gaussian kernel in pixels,  is greater  0.5</param>
	///  <param name="range_stdev">[in] - of gaussian range kernel  is greater  5.0 typ. 50.0</param>
	///  <param name="ncomps">[in] - number of intermediate sums J(k,x) in [4 ... 30]</param>
	///  <param name="reduction">[in] - 1, 2 or 4</param>
	///   <returns>pixd bilateral filtered image, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Bilateral (Single spatial_stdev,
						  Single range_stdev,
						  int ncomps,
						  int reduction)
	{
		Pix RetObj = _All.pixBilateral(this, spatial_stdev, range_stdev, ncomps, reduction);
		return RetObj;
	}

	// bilateral.c (220, 1)
	// pixBilateralGray(pixs, spatial_stdev, range_stdev, ncomps, reduction) as Pix
	// pixBilateralGray(PIX *, l_float32, l_float32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See pixBilateral() for constraints on the input parameters.<para/>
	///
	/// (2) See pixBilateral() for algorithm details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBilateralGray/*"/>
	///  <param name="spatial_stdev">[in] - of gaussian kernel in pixels,  is greater  0.5</param>
	///  <param name="range_stdev">[in] - of gaussian range kernel  is greater  5.0 typ. 50.0</param>
	///  <param name="ncomps">[in] - number of intermediate sums J(k,x) in [4 ... 30]</param>
	///  <param name="reduction">[in] - 1, 2 or 4</param>
	///   <returns>pixd 8 bpp bilateral filtered image, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BilateralGray (Single spatial_stdev,
							  Single range_stdev,
							  int ncomps,
							  int reduction)
	{
		Pix RetObj = _All.pixBilateralGray(this, spatial_stdev, range_stdev, ncomps, reduction);
		return RetObj;
	}

	// bilateral.c (580, 1)
	// pixBilateralExact(pixs, spatial_kel, range_kel) as Pix
	// pixBilateralExact(PIX *, L_KERNEL *, L_KERNEL *) as PIX *
	///  <summary>
	/// (1) The spatial_kel is a conventional smoothing kernel, typically a
	/// 2-d Gaussian kernel or other block kernel.  It can be either
	/// normalized or not, but must be everywhere positive.<para/>
	///
	/// (2) The range_kel is defined over the absolute value of pixel
	/// grayscale differences, and hence must have size 256 x 1.
	/// Values in the array represent the multiplying weight for each
	/// gray value difference between the target pixel and center of the
	/// kernel, and should be monotonically decreasing.<para/>
	///
	/// (3) If range_kel == NULL, a constant weight is applied regardless
	/// of the range value difference.  This degenerates to a regular
	/// pixConvolve() with a normalized kernel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBilateralExact/*"/>
	///  <param name="spatial_kel">[in] - gaussian kernel</param>
	///  <param name="range_kel">[in][optional] - 256 x 1, monotonically decreasing</param>
	///   <returns>pixd 8 bpp bilateral filtered image</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BilateralExact (L_Kernel spatial_kel,
							   L_Kernel range_kel)
	{
		Pix RetObj = _All.pixBilateralExact(this, spatial_kel, range_kel);
		return RetObj;
	}

	// bilateral.c (634, 1)
	// pixBilateralGrayExact(pixs, spatial_kel, range_kel) as Pix
	// pixBilateralGrayExact(PIX *, L_KERNEL *, L_KERNEL *) as PIX *
	///  <summary>
	/// (1) See pixBilateralExact().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBilateralGrayExact/*"/>
	///  <param name="spatial_kel">[in] - gaussian kernel</param>
	///  <param name="range_kel">[in][optional] - 256 x 1, monotonically decreasing</param>
	///   <returns>pixd 8 bpp bilateral filtered image</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BilateralGrayExact (L_Kernel spatial_kel,
								   L_Kernel range_kel)
	{
		Pix RetObj = _All.pixBilateralGrayExact(this, spatial_kel, range_kel);
		return RetObj;
	}

	// bilateral.c (735, 1)
	// pixBlockBilateralExact(pixs, spatial_stdev, range_stdev) as Pix
	// pixBlockBilateralExact(PIX *, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) See pixBilateralExact().  This provides an interface using
	/// the standard deviations of the spatial and range filters.<para/>
	///
	/// (2) The convolution window halfwidth is 2  spatial_stdev,
	/// and the square filter size is 4  spatial_stdev + 1.
	/// The kernel captures 95% of total energy.  This is compensated
	/// by normalization.<para/>
	///
	/// (3) The range_stdev is analogous to spatial_halfwidth in the
	/// grayscale domain [0...255], and determines how much damping of the
	/// smoothing operation is applied across edges.  The larger this
	/// value is, the smaller the damping.  The smaller the value, the
	/// more edge details are preserved.  These approximations are useful
	/// for deciding the appropriate cutoff.
	/// kernel[1  stdev] ~= 0.6 kernel[0]
	/// kernel[2  stdev] ~= 0.14  kernel[0]
	/// kernel[3  stdev] ~= 0.01  kernel[0]
	/// If range_stdev is infinite there is no damping, and this
	/// becomes a conventional gaussian smoothing.
	/// This value does not affect the run time.<para/>
	///
	/// (4) If range_stdev is negative or zero, the range kernel is
	/// ignored and this degenerates to a straight gaussian convolution.<para/>
	///
	/// (5) This is very slow for large spatial filters.  The time
	/// on a 3GHz pentium is roughly
	/// T = 1.2  10^-8  (A  sh^2)  sec
	/// where A = # of pixels, sh = spatial halfwidth of filter.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlockBilateralExact/*"/>
	///  <param name="spatial_stdev">[in] - is greater  0.0</param>
	///  <param name="range_stdev">[in] - is greater  0.0</param>
	///   <returns>pixd 8 bpp or 32 bpp bilateral filtered image</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlockBilateralExact (Single spatial_stdev,
									Single range_stdev)
	{
		Pix RetObj = _All.pixBlockBilateralExact(this, spatial_stdev, range_stdev);
		return RetObj;
	}

	// bilinear.c (143, 1)
	// pixBilinearSampledPta(pixs, ptad, ptas, incolor) as Pix
	// pixBilinearSampledPta(PIX *, PTA *, PTA *, l_int32) as PIX *
	///  <summary>
	/// (1) Brings in either black or white pixels from the boundary.<para/>
	///
	/// (2) Retains colormap, which you can do for a sampled transform..<para/>
	///
	/// (3) No 3 of the 4 points may be collinear.<para/>
	///
	/// (4) For 8 and 32 bpp pix, better quality is obtained by the
	/// somewhat slower pixBilinearPta().  See that
	/// function for relative timings between sampled and interpolated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBilinearSampledPta/*"/>
	///  <param name="ptad">[in] - 4 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 4 pts of initial coordinate space</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BilinearSampledPta (Pta ptad,
								   Pta ptas,
								   int incolor)
	{
		Pix RetObj = _All.pixBilinearSampledPta(this, ptad, ptas, incolor);
		return RetObj;
	}

	// bilinear.c (193, 1)
	// pixBilinearSampled(pixs, vc, incolor) as Pix
	// pixBilinearSampled(PIX *, l_float32 *, l_int32) as PIX *
	///  <summary>
	/// (1) Brings in either black or white pixels from the boundary.<para/>
	///
	/// (2) Retains colormap, which you can do for a sampled transform..<para/>
	///
	/// (3) For 8 or 32 bpp, much better quality is obtained by the
	/// somewhat slower pixBilinear().  See that function
	/// for relative timings between sampled and interpolated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBilinearSampled/*"/>
	///  <param name="vc">[in] - vector of 8 coefficients for bilinear transformation</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BilinearSampled (Single[] vc,
								int incolor)
	{
		Pix RetObj = _All.pixBilinearSampled(this, vc, incolor);
		return RetObj;
	}

	// bilinear.c (286, 1)
	// pixBilinearPta(pixs, ptad, ptas, incolor) as Pix
	// pixBilinearPta(PIX *, PTA *, PTA *, l_int32) as PIX *
	///  <summary>
	/// (1) Brings in either black or white pixels from the boundary<para/>
	///
	/// (2) Removes any existing colormap, if necessary, before transforming
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBilinearPta/*"/>
	///  <param name="ptad">[in] - 4 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 4 pts of initial coordinate space</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BilinearPta (Pta ptad,
							Pta ptas,
							int incolor)
	{
		Pix RetObj = _All.pixBilinearPta(this, ptad, ptas, incolor);
		return RetObj;
	}

	// bilinear.c (356, 1)
	// pixBilinear(pixs, vc, incolor) as Pix
	// pixBilinear(PIX *, l_float32 *, l_int32) as PIX *
	///  <summary>
	/// (1) Brings in either black or white pixels from the boundary<para/>
	///
	/// (2) Removes any existing colormap, if necessary, before transforming
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBilinear/*"/>
	///  <param name="vc">[in] - vector of 8 coefficients for bilinear transformation</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Bilinear (Single[] vc,
						 int incolor)
	{
		Pix RetObj = _All.pixBilinear(this, vc, incolor);
		return RetObj;
	}

	// bilinear.c (412, 1)
	// pixBilinearPtaColor(pixs, ptad, ptas, colorval) as Pix
	// pixBilinearPtaColor(PIX *, PTA *, PTA *, l_uint32) as PIX *
	///  <summary>
	/// pixBilinearPtaColor()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBilinearPtaColor/*"/>
	///  <param name="ptad">[in] - 4 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 4 pts of initial coordinate space</param>
	///  <param name="colorval">[in] - e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BilinearPtaColor (Pta ptad,
								 Pta ptas,
								 uint colorval)
	{
		Pix RetObj = _All.pixBilinearPtaColor(this, ptad, ptas, colorval);
		return RetObj;
	}

	// bilinear.c (453, 1)
	// pixBilinearColor(pixs, vc, colorval) as Pix
	// pixBilinearColor(PIX *, l_float32 *, l_uint32) as PIX *
	///  <summary>
	/// pixBilinearColor()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBilinearColor/*"/>
	///  <param name="vc">[in] - vector of 8 coefficients for bilinear transformation</param>
	///  <param name="colorval">[in] - e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BilinearColor (Single[] vc,
							  uint colorval)
	{
		Pix RetObj = _All.pixBilinearColor(this, vc, colorval);
		return RetObj;
	}

	// bilinear.c (515, 1)
	// pixBilinearPtaGray(pixs, ptad, ptas, grayval) as Pix
	// pixBilinearPtaGray(PIX *, PTA *, PTA *, l_uint8) as PIX *
	///  <summary>
	/// pixBilinearPtaGray()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBilinearPtaGray/*"/>
	///  <param name="ptad">[in] - 4 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 4 pts of initial coordinate space</param>
	///  <param name="grayval">[in] - 0 to bring in BLACK, 255 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BilinearPtaGray (Pta ptad,
								Pta ptas,
								byte grayval)
	{
		Pix RetObj = _All.pixBilinearPtaGray(this, ptad, ptas, grayval);
		return RetObj;
	}

	// bilinear.c (556, 1)
	// pixBilinearGray(pixs, vc, grayval) as Pix
	// pixBilinearGray(PIX *, l_float32 *, l_uint8) as PIX *
	///  <summary>
	/// pixBilinearGray()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBilinearGray/*"/>
	///  <param name="vc">[in] - vector of 8 coefficients for bilinear transformation</param>
	///  <param name="grayval">[in] - 0 to bring in BLACK, 255 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BilinearGray (Single[] vc,
							 byte grayval)
	{
		Pix RetObj = _All.pixBilinearGray(this, vc, grayval);
		return RetObj;
	}

	// bilinear.c (644, 1)
	// pixBilinearPtaWithAlpha(pixs, ptad, ptas, pixg, fract, border) as Pix
	// pixBilinearPtaWithAlpha(PIX *, PTA *, PTA *, PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) The alpha channel is transformed separately from pixs,
	/// and aligns with it, being fully transparent outside the
	/// boundary of the transformed pixs.  For pixels that are fully
	/// transparent, a blending function like pixBlendWithGrayMask()
	/// will give zero weight to corresponding pixels in pixs.<para/>
	///
	/// (2) If pixg is NULL, it is generated as an alpha layer that is
	/// partially opaque, using %fract.  Otherwise, it is cropped
	/// to pixs if required and %fract is ignored.  The alpha channel
	/// in pixs is never used.<para/>
	///
	/// (3) Colormaps are removed.<para/>
	///
	/// (4) When pixs is transformed, it doesn't matter what color is brought
	/// in because the alpha channel will be transparent (0) there.<para/>
	///
	/// (5) To avoid losing source pixels in the destination, it may be
	/// necessary to add a border to the source pix before doing
	/// the bilinear transformation.  This can be any non-negative number.<para/>
	///
	/// (6) The input %ptad and %ptas are in a coordinate space before
	/// the border is added.  Internally, we compensate for this
	/// before doing the bilinear transform on the image after
	/// the border is added.<para/>
	///
	/// (7) The default setting for the border values in the alpha channel
	/// is 0 (transparent) for the outermost ring of pixels and
	/// (0.5  fract  255) for the second ring.  When blended over
	/// a second image, this
	/// (a) shrinks the visible image to make a clean overlap edge
	/// with an image below, and
	/// (b) softens the edges by weakening the aliasing there.
	/// Use l_setAlphaMaskBorder() to change these values.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBilinearPtaWithAlpha/*"/>
	///  <param name="ptad">[in] - 4 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 4 pts of initial coordinate space</param>
	///  <param name="pixg">[in][optional] - 8 bpp, can be null</param>
	///  <param name="fract">[in] - between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	///  <param name="border">[in] - of pixels added to capture transformed source pixels</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BilinearPtaWithAlpha (Pta ptad,
									 Pta ptas,
									 Single fract,
									 int border,
									 Pix pixg)
	{
		Pix RetObj = _All.pixBilinearPtaWithAlpha(this, ptad, ptas, pixg, fract, border);
		return RetObj;
	}

	// binarize.c (140, 1)
	// pixOtsuAdaptiveThreshold(pixs, sx, sy, smoothx, smoothy, scorefract, ppixth, ppixd) as int
	// pixOtsuAdaptiveThreshold(PIX *, l_int32, l_int32, l_int32, l_int32, l_float32, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) The Otsu method finds a single global threshold for an image.
	/// This function allows a locally adapted threshold to be
	/// found for each tile into which the image is broken up.<para/>
	///
	/// (2) The array of threshold values, one for each tile, constitutes
	/// a highly downscaled image.  This array is optionally
	/// smoothed using a convolution.  The full width and height of the
	/// convolution kernel are (2  %smoothx + 1) and (2  %smoothy + 1).<para/>
	///
	/// (3) The minimum tile dimension allowed is 16.  If such small
	/// tiles are used, it is recommended to use smoothing, because
	/// without smoothing, each small tile determines the splitting
	/// threshold independently.  A tile that is entirely in the
	/// image bg will then hallucinate fg, resulting in a very noisy
	/// binarization.  The smoothing should be large enough that no
	/// tile is only influenced by one type (fg or bg) of pixels,
	/// because it will force a split of its pixels.<para/>
	///
	/// (4) To get a single global threshold for the entire image, use
	/// input values of %sx and %sy that are larger than the image.
	/// For this situation, the smoothing parameters are ignored.<para/>
	///
	/// (5) The threshold values partition the image pixels into two classes:
	/// one whose values are less than the threshold and another
	/// whose values are greater than or equal to the threshold.
	/// This is the same use of 'threshold' as in pixThresholdToBinary().<para/>
	///
	/// (6) The scorefract is the fraction of the maximum Otsu score, which
	/// is used to determine the range over which the histogram minimum
	/// is searched.  See numaSplitDistribution() for details on the
	/// underlying method of choosing a threshold.<para/>
	///
	/// (7) This uses enables a modified version of the Otsu criterion for
	/// splitting the distribution of pixels in each tile into a
	/// fg and bg part.  The modification consists of searching for
	/// a minimum in the histogram over a range of pixel values where
	/// the Otsu score is within a defined fraction, %scorefract,
	/// of the max score.  To get the original Otsu algorithm, set
	/// %scorefract == 0.<para/>
	///
	/// (8) N.B. This method is NOT recommended for images with weak text
	/// and significant background noise, such as bleedthrough, because
	/// of the problem noted in (3) above for tiling.  Use Sauvola.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOtsuAdaptiveThreshold/*"/>
	///  <param name="sx">[in] - desired tile dimensions actual size may vary</param>
	///  <param name="sy">[in] - desired tile dimensions actual size may vary</param>
	///  <param name="smoothx">[in] - half-width of convolution kernel applied to threshold array: use 0 for no smoothing</param>
	///  <param name="smoothy">[in] - half-width of convolution kernel applied to threshold array: use 0 for no smoothing</param>
	///  <param name="scorefract">[in] - fraction of the max Otsu score typ. 0.1 use 0.0 for standard Otsu</param>
	///  <param name="ppixth">[out][optional] - array of threshold values found for each tile</param>
	///  <param name="ppixd">[out][optional] - thresholded input pixs, based on the threshold array</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int OtsuAdaptiveThreshold (int sx,
									  int sy,
									  int smoothx,
									  int smoothy,
									  Single scorefract,
									  out Pix ppixth,
									  out Pix ppixd)
	{
		int RetObj = _All.pixOtsuAdaptiveThreshold(this, sx, sy, smoothx, smoothy, scorefract, out ppixth, out ppixd);
		return RetObj;
	}

	// binarize.c (256, 1)
	// pixOtsuThreshOnBackgroundNorm(pixs, pixim, sx, sy, thresh, mincount, bgval, smoothx, smoothy, scorefract, pthresh) as Pix
	// pixOtsuThreshOnBackgroundNorm(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_float32, l_int32 *) as PIX *
	///  <summary>
	/// (1) This does background normalization followed by Otsu
	/// thresholding.  Otsu binarization attempts to split the
	/// image into two roughly equal sets of pixels, and it does
	/// a very poor job when there are large amounts of dark
	/// background.  By doing a background normalization first,
	/// to get the background near 255, we remove this problem.
	/// Then we use a modified Otsu to estimate the best global
	/// threshold on the normalized image.<para/>
	///
	/// (2) See pixBackgroundNorm() for meaning and typical values
	/// of input parameters.  For a start, you can try:
	/// sx, sy = 10, 15
	/// thresh = 100
	/// mincount = 50
	/// bgval = 255
	/// smoothx, smoothy = 2
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOtsuThreshOnBackgroundNorm/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null</param>
	///  <param name="sx">[in] - tile size in pixels</param>
	///  <param name="sy">[in] - tile size in pixels</param>
	///  <param name="thresh">[in] - threshold for determining foreground</param>
	///  <param name="mincount">[in] - min threshold on counts in a tile</param>
	///  <param name="bgval">[in] - target bg val typ.  is greater  128</param>
	///  <param name="smoothx">[in] - half-width of block convolution kernel width</param>
	///  <param name="smoothy">[in] - half-width of block convolution kernel height</param>
	///  <param name="scorefract">[in] - fraction of the max Otsu score typ. 0.1</param>
	///  <param name="pthresh">[out][optional] - threshold value that was used on the normalized image</param>
	///   <returns>pixd 1 bpp thresholded image, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OtsuThreshOnBackgroundNorm (int sx,
										   int sy,
										   int thresh,
										   int mincount,
										   int bgval,
										   int smoothx,
										   int smoothy,
										   Single scorefract,
										   Pix pixim,
										   out int pthresh)
	{
		Pix RetObj = _All.pixOtsuThreshOnBackgroundNorm(this, pixim, sx, sy, thresh, mincount, bgval, smoothx, smoothy, scorefract, out pthresh);
		return RetObj;
	}

	// binarize.c (354, 1)
	// pixMaskedThreshOnBackgroundNorm(pixs, pixim, sx, sy, thresh, mincount, smoothx, smoothy, scorefract, pthresh) as Pix
	// pixMaskedThreshOnBackgroundNorm(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_float32, l_int32 *) as PIX *
	///  <summary>
	/// (1) This begins with a standard background normalization.
	/// Additionally, there is a flexible background norm, that
	/// will adapt to a rapidly varying background, and this
	/// puts white pixels in the background near regions with
	/// significant foreground.  The white pixels are turned into
	/// a 1 bpp selection mask by binarization followed by dilation.
	/// Otsu thresholding is performed on the input image to get an
	/// estimate of the threshold in the non-mask regions.
	/// The background normalized image is thresholded with two
	/// different values, and the result is combined using
	/// the selection mask.<para/>
	///
	/// (2) Note that the numbers 255 (for bgval target) and 190 (for
	/// thresholding on pixn) are tied together, and explicitly
	/// defined in this function.<para/>
	///
	/// (3) See pixBackgroundNorm() for meaning and typical values
	/// of input parameters.  For a start, you can try:
	/// sx, sy = 10, 15
	/// thresh = 100
	/// mincount = 50
	/// smoothx, smoothy = 2
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMaskedThreshOnBackgroundNorm/*"/>
	///  <param name="pixim">[in][optional] - 1 bpp 'image' mask can be null</param>
	///  <param name="sx">[in] - tile size in pixels</param>
	///  <param name="sy">[in] - tile size in pixels</param>
	///  <param name="thresh">[in] - threshold for determining foreground</param>
	///  <param name="mincount">[in] - min threshold on counts in a tile</param>
	///  <param name="smoothx">[in] - half-width of block convolution kernel width</param>
	///  <param name="smoothy">[in] - half-width of block convolution kernel height</param>
	///  <param name="scorefract">[in] - fraction of the max Otsu score typ. ~ 0.1</param>
	///  <param name="pthresh">[out][optional] - threshold value that was used on the normalized image</param>
	///   <returns>pixd 1 bpp thresholded image, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MaskedThreshOnBackgroundNorm (int sx,
											 int sy,
											 int thresh,
											 int mincount,
											 int smoothx,
											 int smoothy,
											 Single scorefract,
											 Pix pixim,
											 out int pthresh)
	{
		Pix RetObj = _All.pixMaskedThreshOnBackgroundNorm(this, pixim, sx, sy, thresh, mincount, smoothx, smoothy, scorefract, out pthresh);
		return RetObj;
	}

	// binarize.c (468, 1)
	// pixSauvolaBinarizeTiled(pixs, whsize, factor, nx, ny, ppixth, ppixd) as int
	// pixSauvolaBinarizeTiled(PIX *, l_int32, l_float32, l_int32, l_int32, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) The window width and height are 2  %whsize + 1.  The minimum
	/// value for %whsize is 2 typically it is greater or equal 7..<para/>
	///
	/// (2) For nx == ny == 1, this defaults to pixSauvolaBinarize().<para/>
	///
	/// (3) Why a tiled version?
	/// (a) Because the mean value accumulator is a uint32, overflow
	/// can occur for an image with more than 16M pixels.
	/// (b) The mean value accumulator array for 16M pixels is 64 MB.
	/// The mean square accumulator array for 16M pixels is 128 MB.
	/// Using tiles reduces the size of these arrays.
	/// (c) Each tile can be processed independently, in parallel,
	/// on a multicore processor.<para/>
	///
	/// (4) The Sauvola threshold is determined from the formula:
	/// t = m  (1 - k  (1 - s / 128))
	/// See pixSauvolaBinarize() for details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSauvolaBinarizeTiled/*"/>
	///  <param name="whsize">[in] - window half-width for measuring local statistics</param>
	///  <param name="factor">[in] - factor for reducing threshold due to variance greater or equal 0</param>
	///  <param name="nx">[in] - subdivision into tiles greater or equal 1</param>
	///  <param name="ny">[in] - subdivision into tiles greater or equal 1</param>
	///  <param name="ppixth">[out][optional] - Sauvola threshold values</param>
	///  <param name="ppixd">[out][optional] - thresholded image</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SauvolaBinarizeTiled (int whsize,
									 Single factor,
									 int nx,
									 int ny,
									 out Pix ppixth,
									 out Pix ppixd)
	{
		int RetObj = _All.pixSauvolaBinarizeTiled(this, whsize, factor, nx, ny, out ppixth, out ppixd);
		return RetObj;
	}

	// binarize.c (595, 1)
	// pixSauvolaBinarize(pixs, whsize, factor, addborder, ppixm, ppixsd, ppixth, ppixd) as int
	// pixSauvolaBinarize(PIX *, l_int32, l_float32, l_int32, PIX **, PIX **, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) The window width and height are 2  %whsize + 1.  The minimum
	/// value for %whsize is 2 typically it is greater or equal 7..<para/>
	///
	/// (2) The local statistics, measured over the window, are the
	/// average and standard deviation.<para/>
	///
	/// (3) The measurements of the mean and standard deviation are
	/// performed inside a border of (%whsize + 1) pixels.  If pixs does
	/// not have these added border pixels, use %addborder = 1 to add
	/// it here otherwise use %addborder = 0.<para/>
	///
	/// (4) The Sauvola threshold is determined from the formula:
	/// t = m  (1 - k  (1 - s / 128))
	/// where:
	/// t = local threshold
	/// m = local mean
	/// k = %factor (greater or equal 0) [ typ. 0.35 ]
	/// s = local standard deviation, which is maximized at
	/// 127.5 when half the samples are 0 and half are 255.<para/>
	///
	/// (5) The basic idea of Niblack and Sauvola binarization is that
	/// the local threshold should be less than the median value,
	/// and the larger the variance, the closer to the median
	/// it should be chosen.  Typical values for k are between
	/// 0.2 and 0.5.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSauvolaBinarize/*"/>
	///  <param name="whsize">[in] - window half-width for measuring local statistics</param>
	///  <param name="factor">[in] - factor for reducing threshold due to variance greater or equal 0</param>
	///  <param name="addborder">[in] - 1 to add border of width (%whsize + 1) on all sides</param>
	///  <param name="ppixm">[out][optional] - local mean values</param>
	///  <param name="ppixsd">[out][optional] - local standard deviation values</param>
	///  <param name="ppixth">[out][optional] - threshold values</param>
	///  <param name="ppixd">[out][optional] - thresholded image</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SauvolaBinarize (int whsize,
								Single factor,
								int addborder,
								out Pix ppixm,
								out Pix ppixsd,
								out Pix ppixth,
								out Pix ppixd)
	{
		int RetObj = _All.pixSauvolaBinarize(this, whsize, factor, addborder, out ppixm, out ppixsd, out ppixth, out ppixd);
		return RetObj;
	}

	// binarize.c (705, 1)
	// pixSauvolaGetThreshold(pixm, pixms, factor, ppixsd) as Pix
	// pixSauvolaGetThreshold(PIX *, PIX *, l_float32, PIX **) as PIX *
	///  <summary>
	/// (1) The Sauvola threshold is determined from the formula:
	/// t = m  (1 - k  (1 - s / 128))
	/// where:
	/// t = local threshold
	/// m = local mean
	/// k = %factor (greater or equal 0) [ typ. 0.35 ]
	/// s = local standard deviation, which is maximized at
	/// 127.5 when half the samples are 0 and half are 255.<para/>
	///
	/// (2) See pixSauvolaBinarize() for other details.<para/>
	///
	/// (3) Important definitions and relations for computing averages:
	/// v == pixel value
	/// E(p) == expected value of p == average of p over some pixel set
	/// S(v) == square of v == v  v
	/// mv == E(v) == expected pixel value == mean value
	/// ms == E(S(v)) == expected square of pixel values
	/// == mean square value
	/// var == variance == expected square of deviation from mean
	/// == E(S(v - mv)) = E(S(v) - 2  S(v  mv) + S(mv))
	/// = E(S(v)) - S(mv)
	/// = ms - mv  mv
	/// s == standard deviation = sqrt(var)
	/// So for evaluating the standard deviation in the Sauvola
	/// threshold, we take
	/// s = sqrt(ms - mv  mv)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSauvolaGetThreshold/*"/>
	///  <param name="pixm">[in] - 8 bpp grayscale not colormapped</param>
	///  <param name="pixms">[in] - 32 bpp</param>
	///  <param name="factor">[in] - factor for reducing threshold due to variance greater or equal 0</param>
	///  <param name="ppixsd">[out][optional] - local standard deviation</param>
	///   <returns>pixd 8 bpp, sauvola threshold values, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SauvolaGetThreshold (Pix pixm,
									Pix pixms,
									Single factor,
									out Pix ppixsd)
	{
		Pix RetObj = _All.pixSauvolaGetThreshold(pixm, pixms, factor, out ppixsd);
		return RetObj;
	}

	// binarize.c (788, 1)
	// pixApplyLocalThreshold(pixs, pixth, redfactor) as Pix
	// pixApplyLocalThreshold(PIX *, PIX *, l_int32) as PIX *
	///  <summary>
	/// pixApplyLocalThreshold()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixApplyLocalThreshold/*"/>
	///  <param name="pixth">[in] - 8 bpp array of local thresholds</param>
	///  <param name="redfactor">[in] - ...</param>
	///   <returns>pixd 1 bpp, thresholded image, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ApplyLocalThreshold (Pix pixth,
									int redfactor)
	{
		Pix RetObj = _All.pixApplyLocalThreshold(this, pixth, redfactor);
		return RetObj;
	}

	// binarize.c (887, 1)
	// pixThresholdByConnComp(pixs, pixm, start, end, incr, thresh48, threshdiff, pglobthresh, ppixd, debugflag) as int
	// pixThresholdByConnComp(PIX *, PIX *, l_int32, l_int32, l_int32, l_float32, l_float32, l_int32 *, PIX **, l_int32) as l_ok
	///  <summary>
	/// (1) This finds a global threshold based on connected components.
	/// Although slow, it is reasonable to use it in a situation where
	/// (a) the background in the image is relatively uniform, and
	/// (b) the result will be fed to an OCR program that accepts 1 bpp
	/// images and works best with easily segmented characters.
	/// The reason for (b) is that this selects a threshold with a
	/// minimum number of both broken characters and merged characters.<para/>
	///
	/// (2) If the pix has color, it is converted to gray using the
	/// max component.<para/>
	///
	/// (3) Input 0 to use default values for any of these inputs:
	/// %start, %end, %incr, %thresh48, %threshdiff.<para/>
	///
	/// (4) This approach can be understood as follows.  When the
	/// binarization threshold is varied, the numbers of c.c. identify
	/// four regimes:
	/// (a) For low thresholds, text is broken into small pieces, and
	/// the number of c.c. is large, with the 4 c.c. significantly
	/// exceeding the 8 c.c.
	/// (b) As the threshold rises toward the optimum value, the text
	/// characters coalesce and there is very little difference
	/// between the numbers of 4 and 8 c.c, which both go
	/// through a minimum.
	/// (c) Above this, the image background gets noisy because some
	/// pixels are(thresholded to foreground, and the numbers
	/// of c.c. quickly increase, with the 4 c.c. significantly
	/// larger than the 8 c.c.
	/// (d) At even higher thresholds, the image background noise
	/// coalesces as it becomes mostly foreground, and the
	/// number of c.c. drops quickly.<para/>
	///
	/// (5) If there is no global threshold that distinguishes foreground
	/// text from background (e.g., weak text over a background that
	/// has significant variation and/or bleedthrough), this returns 1,
	/// which the caller should check.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixThresholdByConnComp/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask giving region to ignore by setting pixels to white use NULL if no mask</param>
	///  <param name="start">[in] - binarization threshold levels to test</param>
	///  <param name="incr">[in] - binarization threshold levels to test</param>
	///  <param name="thresh48">[in] - threshold on normalized difference between the numbers of 4 and 8 connected components</param>
	///  <param name="threshdiff">[in] - threshold on normalized difference between the number of 4 cc at successive iterations</param>
	///  <param name="pglobthresh">[out][optional] - best global threshold 0 if no threshold is found</param>
	///  <param name="ppixd">[out][optional] - image thresholded to binary, or null if no threshold is found</param>
	///  <param name="debugflag">[in] - 1 for plotted results</param>
	///   <returns>0 if OK, 1 on error or if no threshold is found</returns>
	// CreateAdditiveFunction: Function/Else
	public int ThresholdByConnComp (int start,
									int _end_,
									int incr,
									Single thresh48,
									Single threshdiff,
									int debugflag,
									Pix pixm,
									out int pglobthresh,
									out Pix ppixd)
	{
		int RetObj = _All.pixThresholdByConnComp(this, pixm, start, _end_, incr, thresh48, threshdiff, out pglobthresh, out ppixd, debugflag);
		return RetObj;
	}

	// binexpand.c (67, 1)
	// pixExpandBinaryReplicate(pixs, xfact, yfact) as Pix
	// pixExpandBinaryReplicate(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixExpandBinaryReplicate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExpandBinaryReplicate/*"/>
	///  <param name="xfact">[in] - integer scale factor for horiz. replicative expansion</param>
	///  <param name="yfact">[in] - integer scale factor for vertical replicative expansion</param>
	///   <returns>pixd scaled up, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ExpandBinaryReplicate (int xfact,
									  int yfact)
	{
		Pix RetObj = _All.pixExpandBinaryReplicate(this, xfact, yfact);
		return RetObj;
	}

	// binexpand.c (132, 1)
	// pixExpandBinaryPower2(pixs, factor) as Pix
	// pixExpandBinaryPower2(PIX *, l_int32) as PIX *
	///  <summary>
	/// pixExpandBinaryPower2()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExpandBinaryPower2/*"/>
	///  <param name="factor">[in] - expansion factor: 1, 2, 4, 8, 16</param>
	///   <returns>pixd expanded 1 bpp by replication, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ExpandBinaryPower2 (int factor)
	{
		Pix RetObj = _All.pixExpandBinaryPower2(this, factor);
		return RetObj;
	}

	// binreduce.c (71, 1)
	// pixReduceBinary2(pixs, intab) as Pix
	// pixReduceBinary2(PIX *, l_uint8 *) as PIX *
	///  <summary>
	/// (1) After folding, the data is in bytes 0 and 2 of the word,
	/// and the bits in each byte are in the following order
	/// (with 0 being the leftmost originating pair and 7 being
	/// the rightmost originating pair):
	/// 0 4 1 5 2 6 3 7
	/// These need to be permuted to
	/// 0 1 2 3 4 5 6 7
	/// which is done with an 8-bit table generated by makeSubsampleTab2x().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReduceBinary2/*"/>
	///  <param name="intab">[in][optional] - if null, a table is made here and destroyed before exit</param>
	///   <returns>pixd 2x subsampled, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReduceBinary2 (Byte[] intab)
	{
		Pix RetObj = _All.pixReduceBinary2(this, intab);
		return RetObj;
	}

	// binreduce.c (148, 1)
	// pixReduceRankBinaryCascade(pixs, level1, level2, level3, level4) as Pix
	// pixReduceRankBinaryCascade(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This performs up to four cascaded 2x rank reductions.<para/>
	///
	/// (2) Use level = 0 to truncate the cascade.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReduceRankBinaryCascade/*"/>
	///  <param name="level1">[in] - threshold, in the set {0, 1, 2, 3, 4}</param>
	///  <param name="level2">[in] - threshold, in the set {0, 1, 2, 3, 4}</param>
	///  <param name="level3">[in] - threshold, in the set {0, 1, 2, 3, 4}</param>
	///  <param name="level4">[in] - threshold, in the set {0, 1, 2, 3, 4}</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReduceRankBinaryCascade (int level1,
										int level2,
										int level3,
										int level4)
	{
		Pix RetObj = _All.pixReduceRankBinaryCascade(this, level1, level2, level3, level4);
		return RetObj;
	}

	// binreduce.c (223, 1)
	// pixReduceRankBinary2(pixs, level, intab) as Pix
	// pixReduceRankBinary2(PIX *, l_int32, l_uint8 *) as PIX *
	///  <summary>
	/// (1) pixd is downscaled by 2x from pixs.<para/>
	///
	/// (2) The rank threshold specifies the minimum number of ON
	/// pixels in each 2x2 region of pixs that are required to
	/// set the corresponding pixel ON in pixd.<para/>
	///
	/// (3) Rank filtering is done to the UL corner of each 2x2 pixel block,
	/// using only logical operations.  Then these pixels are chosen
	/// in the 2x subsampling process, subsampled, as described
	/// above in pixReduceBinary2().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReduceRankBinary2/*"/>
	///  <param name="level">[in] - rank threshold: 1, 2, 3, 4</param>
	///  <param name="intab">[in][optional] - if null, a table is made here and destroyed before exit</param>
	///   <returns>pixd 1 bpp, 2x rank threshold reduced, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReduceRankBinary2 (int level,
								  Byte[] intab)
	{
		Pix RetObj = _All.pixReduceRankBinary2(this, level, intab);
		return RetObj;
	}

	// blend.c (174, 1)
	// pixBlend(pixs1, pixs2, x, y, fract) as Pix
	// pixBlend(PIX *, PIX *, l_int32, l_int32, l_float32) as PIX *
	///  <summary>
	/// (1) This is a simple top-level interface.  For more flexibility,
	/// call directly into pixBlendMask(), etc.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlend/*"/>
	///  <param name="pixs1">[in] - blendee</param>
	///  <param name="pixs2">[in] - blender typ. smaller</param>
	///  <param name="x">[in] - ,y  origin [UL corner] of pixs2 relative to the origin of pixs1 can be  is smaller 0</param>
	///  <param name="fract">[in] - blending fraction</param>
	///   <returns>pixd blended image, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Blend (Pix pixs1,
					  Pix pixs2,
					  int x,
					  int y,
					  Single fract)
	{
		Pix RetObj = _All.pixBlend(pixs1, pixs2, x, y, fract);
		return RetObj;
	}

	// blend.c (262, 1)
	// pixBlendMask(pixd, pixs1, pixs2, x, y, fract, type) as Pix
	// pixBlendMask(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) Clipping of pixs2 to pixs1 is done in the inner pixel loop.<para/>
	///
	/// (2) If pixs1 has a colormap, it is removed.<para/>
	///
	/// (3) For inplace operation (pixs1 not cmapped), call it this way:
	/// pixBlendMask(pixs1, pixs1, pixs2, ...)<para/>
	///
	/// (4) For generating a new pixd:
	/// pixd = pixBlendMask(NULL, pixs1, pixs2, ...)<para/>
	///
	/// (5) Only call in-place if pixs1 does not have a colormap.<para/>
	///
	/// (6) Invalid %fract defaults to 0.5 with a warning.
	/// Invalid %type defaults to L_BLEND_WITH_INVERSE with a warning.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlendMask/*"/>
	///  <param name="pixd">[in][optional] - either NULL or equal to pixs1 for in-place</param>
	///  <param name="pixs1">[in] - blendee, depth  is greater  1</param>
	///  <param name="pixs2">[in] - blender, 1 bpp typ. smaller in size than pixs1</param>
	///  <param name="x">[in] - ,y  origin [UL corner] of pixs2 relative to the origin of pixs1 can be  is smaller 0</param>
	///  <param name="fract">[in] - blending fraction</param>
	///  <param name="type">[in] - L_BLEND_WITH_INVERSE, L_BLEND_TO_WHITE, L_BLEND_TO_BLACK</param>
	///   <returns>pixd if OK NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlendMask (Pix pixs1,
						  Pix pixs2,
						  int x,
						  int y,
						  Single fract,
						  int type,
						  Pix pixd)
	{
		Pix RetObj = _All.pixBlendMask(pixd, pixs1, pixs2, x, y, fract, type);
		return RetObj;
	}

	// blend.c (489, 1)
	// pixBlendGray(pixd, pixs1, pixs2, x, y, fract, type, transparent, transpix) as Pix
	// pixBlendGray(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32, l_int32, l_int32, l_uint32) as PIX *
	///  <summary>
	/// (1) For inplace operation (pixs1 not cmapped), call it this way:
	/// pixBlendGray(pixs1, pixs1, pixs2, ...)<para/>
	///
	/// (2) For generating a new pixd:
	/// pixd = pixBlendGray(NULL, pixs1, pixs2, ...)<para/>
	///
	/// (3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.<para/>
	///
	/// (4) If pixs1 has a colormap, it is removed otherwise, if pixs1
	/// has depth  is smaller 8, it is unpacked to generate a 8 bpp pix.<para/>
	///
	/// (5) If transparent = 0, the blending fraction (fract) is
	/// applied equally to all pixels.<para/>
	///
	/// (6) If transparent = 1, all pixels of value transpix (typically
	/// either 0 or 0xff) in pixs2 are transparent in the blend.<para/>
	///
	/// (7) After processing pixs1, it is either 8 bpp or 32 bpp:
	/// ~ if 8 bpp, the fraction of pixs2 is mixed with pixs1.
	/// ~ if 32 bpp, each component of pixs1 is mixed with
	/// the same fraction of pixs2.<para/>
	///
	/// (8) For L_BLEND_GRAY_WITH_INVERSE, the white values of the blendee
	/// (cval == 255 in the code below) result in a delta of 0.
	/// Thus, these pixels are intrinsically transparent!
	/// The "pivot" value of the src, at which no blending occurs, is
	/// 128.  Compare with the adaptive pivot in pixBlendGrayAdapt().<para/>
	///
	/// (9) Invalid %fract defaults to 0.5 with a warning.
	/// Invalid %type defaults to L_BLEND_GRAY with a warning.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlendGray/*"/>
	///  <param name="pixd">[in][optional] - either NULL or equal to pixs1 for in-place</param>
	///  <param name="pixs1">[in] - blendee, depth  is greater  1</param>
	///  <param name="pixs2">[in] - blender, any depth typ. smaller in size than pixs1</param>
	///  <param name="x">[in] - ,y  origin [UL corner] of pixs2 relative to the origin of pixs1 can be  is smaller 0</param>
	///  <param name="fract">[in] - blending fraction</param>
	///  <param name="type">[in] - L_BLEND_GRAY, L_BLEND_GRAY_WITH_INVERSE</param>
	///  <param name="transparent">[in] - 1 to use transparency 0 otherwise</param>
	///  <param name="transpix">[in] - pixel grayval in pixs2 that is to be transparent</param>
	///   <returns>pixd if OK pixs1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlendGray (Pix pixs1,
						  Pix pixs2,
						  int x,
						  int y,
						  Single fract,
						  int type,
						  int transparent,
						  uint transpix,
						  Pix pixd)
	{
		Pix RetObj = _All.pixBlendGray(pixd, pixs1, pixs2, x, y, fract, type, transparent, transpix);
		return RetObj;
	}

	// blend.c (688, 1)
	// pixBlendGrayInverse(pixd, pixs1, pixs2, x, y, fract) as Pix
	// pixBlendGrayInverse(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32) as PIX *
	///  <summary>
	/// (1) For inplace operation (pixs1 not cmapped), call it this way:
	/// pixBlendGrayInverse(pixs1, pixs1, pixs2, ...)<para/>
	///
	/// (2) For generating a new pixd:
	/// pixd = pixBlendGrayInverse(NULL, pixs1, pixs2, ...)<para/>
	///
	/// (3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.<para/>
	///
	/// (4) If pixs1 has a colormap, it is removed otherwise if pixs1
	/// has depth  is smaller 8, it is unpacked to generate a 8 bpp pix.<para/>
	///
	/// (5) This is a no-nonsense blender.  It changes the src1 pixel except
	/// when the src1 pixel is midlevel gray.  Use fract == 1 for the most
	/// aggressive blending, where, if the gray pixel in pixs2 is 0,
	/// we get a complete inversion of the color of the src pixel in pixs1.<para/>
	///
	/// (6) The basic logic is that each component transforms by:
	///    d  to  c * d + (1 - c ) * (f * (1 - d) + d * (1 - f))
	/// where c is the blender pixel from pixs2,
	/// f is %fract,
	/// c and d are normalized to [0...1]
	/// This has the property that for f == 0 (no blend) or c == 1 (white):
	/// d  to  d
	/// For c == 0 (black) we get maximum inversion:
	/// d  to  f  (1 - d) + d  (1 - f) [inversion by fraction f]
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlendGrayInverse/*"/>
	///  <param name="pixd">[in][optional] - either NULL or equal to pixs1 for in-place</param>
	///  <param name="pixs1">[in] - blendee, depth  is greater  1</param>
	///  <param name="pixs2">[in] - blender, any depth typ. smaller in size than pixs1</param>
	///  <param name="x">[in] - ,y  origin [UL corner] of pixs2 relative to the origin of pixs1 can be  is smaller 0</param>
	///  <param name="fract">[in] - blending fraction</param>
	///   <returns>pixd if OK pixs1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlendGrayInverse (Pix pixs1,
								 Pix pixs2,
								 int x,
								 int y,
								 Single fract,
								 Pix pixd)
	{
		Pix RetObj = _All.pixBlendGrayInverse(pixd, pixs1, pixs2, x, y, fract);
		return RetObj;
	}

	// blend.c (820, 1)
	// pixBlendColor(pixd, pixs1, pixs2, x, y, fract, transparent, transpix) as Pix
	// pixBlendColor(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32, l_int32, l_uint32) as PIX *
	///  <summary>
	/// (1) For inplace operation (pixs1 must be 32 bpp), call it this way:
	/// pixBlendColor(pixs1, pixs1, pixs2, ...)<para/>
	///
	/// (2) For generating a new pixd:
	/// pixd = pixBlendColor(NULL, pixs1, pixs2, ...)<para/>
	///
	/// (3) If pixs2 is not 32 bpp rgb, it is converted.<para/>
	///
	/// (4) Clipping of pixs2 to pixs1 is done in the inner pixel loop.<para/>
	///
	/// (5) If pixs1 has a colormap, it is removed to generate a 32 bpp pix.<para/>
	///
	/// (6) If pixs1 has depth  is smaller 32, it is unpacked to generate a 32 bpp pix.<para/>
	///
	/// (7) If transparent = 0, the blending fraction (fract) is
	/// applied equally to all pixels.<para/>
	///
	/// (8) If transparent = 1, all pixels of value transpix (typically
	/// either 0 or 0xffffff00) in pixs2 are transparent in the blend.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlendColor/*"/>
	///  <param name="pixd">[in][optional] - either NULL or equal to pixs1 for in-place</param>
	///  <param name="pixs1">[in] - blendee depth  is greater  1</param>
	///  <param name="pixs2">[in] - blender, any depth typ. smaller in size than pixs1</param>
	///  <param name="x">[in] - ,y  origin [UL corner] of pixs2 relative to the origin of pixs1</param>
	///  <param name="fract">[in] - blending fraction</param>
	///  <param name="transparent">[in] - 1 to use transparency 0 otherwise</param>
	///  <param name="transpix">[in] - pixel color in pixs2 that is to be transparent</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlendColor (Pix pixs1,
						   Pix pixs2,
						   int x,
						   int y,
						   Single fract,
						   int transparent,
						   uint transpix,
						   Pix pixd)
	{
		Pix RetObj = _All.pixBlendColor(pixd, pixs1, pixs2, x, y, fract, transparent, transpix);
		return RetObj;
	}

	// blend.c (932, 1)
	// pixBlendColorByChannel(pixd, pixs1, pixs2, x, y, rfract, gfract, bfract, transparent, transpix) as Pix
	// pixBlendColorByChannel(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32, l_float32, l_float32, l_int32, l_uint32) as PIX *
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlendColorByChannel/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlendColorByChannel (Pix pixd,
									Pix pixs1,
									Pix pixs2,
									int x,
									int y,
									Single rfract,
									Single gfract,
									Single bfract,
									int transparent,
									uint transpix)
	{
		Pix RetObj = _All.pixBlendColorByChannel(pixd, pixs1, pixs2, x, y, rfract, gfract, bfract, transparent, transpix);
		return RetObj;
	}

	// blend.c (1061, 1)
	// pixBlendGrayAdapt(pixd, pixs1, pixs2, x, y, fract, shift) as Pix
	// pixBlendGrayAdapt(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) For inplace operation (pixs1 not cmapped), call it this way:
	/// pixBlendGrayAdapt(pixs1, pixs1, pixs2, ...)
	/// For generating a new pixd:
	/// pixd = pixBlendGrayAdapt(NULL, pixs1, pixs2, ...)<para/>
	///
	/// (2) Clipping of pixs2 to pixs1 is done in the inner pixel loop.<para/>
	///
	/// (3) If pixs1 has a colormap, it is removed.<para/>
	///
	/// (4) If pixs1 has depth  is smaller 8, it is unpacked to generate a 8 bpp pix.<para/>
	///
	/// (5) This does a blend with inverse.  Whereas in pixGlendGray(), the
	/// zero blend point is where the blendee pixel is 128, here
	/// the zero blend point is found adaptively, with respect to the
	/// median of the blendee region.  If the median is  is smaller 128,
	/// the zero blend point is found from
	/// median + shift.
	/// Otherwise, if the median greater or equal 128, the zero blend point is
	/// median - shift.
	/// The purpose of shifting the zero blend point away from the
	/// median is to prevent a situation in pixBlendGray() where
	/// the median is 128 and the blender is not visible.
	/// The default value of shift is 64.<para/>
	///
	/// (6) After processing pixs1, it is either 8 bpp or 32 bpp:
	/// ~ if 8 bpp, the fraction of pixs2 is mixed with pixs1.
	/// ~ if 32 bpp, each component of pixs1 is mixed with
	/// the same fraction of pixs2.<para/>
	///
	/// (7) The darker the blender, the more it mixes with the blendee.
	/// A blender value of 0 has maximum mixing a value of 255
	/// has no mixing and hence is transparent.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlendGrayAdapt/*"/>
	///  <param name="pixd">[in][optional] - either NULL or equal to pixs1 for in-place</param>
	///  <param name="pixs1">[in] - blendee, depth  is greater  1</param>
	///  <param name="pixs2">[in] - blender, any depth typ. smaller in size than pixs1</param>
	///  <param name="x">[in] - ,y  origin [UL corner] of pixs2 relative to the origin of pixs1 can be  is smaller 0</param>
	///  <param name="fract">[in] - blending fraction</param>
	///  <param name="shift">[in] - greater or equal 0 but smaller or equal 128: shift of zero blend value from median source use -1 for default value</param>
	///   <returns>pixd if OK pixs1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlendGrayAdapt (Pix pixs1,
							   Pix pixs2,
							   int x,
							   int y,
							   Single fract,
							   int shift,
							   Pix pixd)
	{
		Pix RetObj = _All.pixBlendGrayAdapt(pixd, pixs1, pixs2, x, y, fract, shift);
		return RetObj;
	}

	// blend.c (1235, 1)
	// pixFadeWithGray(pixs, pixb, factor, type) as Pix
	// pixFadeWithGray(PIX *, PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) This function combines two pix aligned to the UL corner they
	/// need not be the same size.<para/>
	///
	/// (2) Each pixel in pixb is multiplied by 'factor' divided by 255, and
	/// clipped to the range [0 ... 1].  This gives the fade fraction
	/// to be applied to pixs.  Fade either to white (L_BLEND_TO_WHITE)
	/// or to black (L_BLEND_TO_BLACK).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFadeWithGray/*"/>
	///  <param name="pixb">[in] - 8 bpp blender</param>
	///  <param name="factor">[in] - multiplicative factor to apply to blender value</param>
	///  <param name="type">[in] - L_BLEND_TO_WHITE, L_BLEND_TO_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FadeWithGray (Pix pixb,
							 Single factor,
							 int type)
	{
		Pix RetObj = _All.pixFadeWithGray(this, pixb, factor, type);
		return RetObj;
	}

	// blend.c (1349, 1)
	// pixBlendHardLight(pixd, pixs1, pixs2, x, y, fract) as Pix
	// pixBlendHardLight(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32) as PIX *
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlendHardLight/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlendHardLight (Pix pixd,
							   Pix pixs1,
							   Pix pixs2,
							   int x,
							   int y,
							   Single fract)
	{
		Pix RetObj = _All.pixBlendHardLight(pixd, pixs1, pixs2, x, y, fract);
		return RetObj;
	}

	// blend.c (1555, 1)
	// pixBlendCmap(pixs, pixb, x, y, sindex) as int
	// pixBlendCmap(PIX *, PIX *, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This function combines two colormaps, and replaces the pixels
	/// in pixs that have a specified color value with those in pixb.<para/>
	///
	/// (2) sindex must be in the existing colormap otherwise an
	/// error is returned.  In use, sindex will typically be the index
	/// for white (255, 255, 255).<para/>
	///
	/// (3) Blender colors that already exist in the colormap are used
	/// others are added.  If any blender colors cannot be
	/// stored in the colormap, an error is returned.<para/>
	///
	/// (4) In the implementation, a mapping is generated from each
	/// original blender colormap index to the corresponding index
	/// in the expanded colormap for pixs.  Then for each pixel in
	/// pixs with value sindex, and which is covered by a blender pixel,
	/// the new index corresponding to the blender pixel is substituted
	/// for sindex.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlendCmap/*"/>
	///  <param name="pixb">[in] - colormapped blender</param>
	///  <param name="x">[in] - UL corner of blender relative to pixs</param>
	///  <param name="y">[in] - UL corner of blender relative to pixs</param>
	///  <param name="sindex">[in] - colormap index of pixels in pixs to be changed</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int BlendCmap (Pix pixb,
						  int x,
						  int y,
						  int sindex)
	{
		int RetObj = _All.pixBlendCmap(this, pixb, x, y, sindex);
		return RetObj;
	}

	// blend.c (1692, 1)
	// pixBlendWithGrayMask(pixs1, pixs2, pixg, x, y) as Pix
	// pixBlendWithGrayMask(PIX *, PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The result is 8 bpp grayscale if both pixs1 and pixs2 are
	/// 8 bpp gray.  Otherwise, the result is 32 bpp rgb.<para/>
	///
	/// (2) pixg is an 8 bpp transparency image, where 0 is transparent
	/// and 255 is opaque.  It determines the transparency of pixs2
	/// when applied over pixs1.  It can be null if pixs2 is rgba,
	/// in which case we use the alpha component of pixs2.<para/>
	///
	/// (3) If pixg exists, it need not be the same size as pixs2.
	/// However, we assume their UL corners are aligned with each other,
	/// and placed at the location (x, y) in pixs1.<para/>
	///
	/// (4) The pixels in pixd are a combination of those in pixs1
	/// and pixs2, where the amount from pixs2 is proportional to
	/// the value of the pixel (p) in pixg, and the amount from pixs1
	/// is proportional to (255 - p).  Thus pixg is a transparency
	/// image (usually called an alpha blender) where each pixel
	/// can be associated with a pixel in pixs2, and determines
	/// the amount of the pixs2 pixel in the final result.
	/// For example, if pixg is all 0, pixs2 is transparent and
	/// the result in pixd is simply pixs1.<para/>
	///
	/// (5) A typical use is for the pixs2/pixg combination to be
	/// a small watermark that is applied to pixs1.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlendWithGrayMask/*"/>
	///  <param name="pixs1">[in] - 8 bpp gray, rgb, rgba or colormapped</param>
	///  <param name="pixs2">[in] - 8 bpp gray, rgb, rgba or colormapped</param>
	///  <param name="pixg">[in][optional] - 8 bpp gray, for transparency of pixs2 can be null</param>
	///  <param name="x">[in] - UL corner of pixs2 and pixg with respect to pixs1</param>
	///  <param name="y">[in] - UL corner of pixs2 and pixg with respect to pixs1</param>
	///   <returns>pixd blended image, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlendWithGrayMask (Pix pixs1,
								  Pix pixs2,
								  int x,
								  int y,
								  Pix pixg)
	{
		Pix RetObj = _All.pixBlendWithGrayMask(pixs1, pixs2, pixg, x, y);
		return RetObj;
	}

	// blend.c (1846, 1)
	// pixBlendBackgroundToColor(pixd, pixs, box, color, gamma, minval, maxval) as Pix
	// pixBlendBackgroundToColor(PIX *, PIX *, BOX *, l_uint32, l_float32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This in effect replaces light background pixels in pixs
	/// by the input color.  It does it by alpha blending so that
	/// there are no visible artifacts from hard cutoffs.<para/>
	///
	/// (2) If pixd == pixs, this is done in-place.<para/>
	///
	/// (3) If box == NULL, this is performed on all of pixs.<para/>
	///
	/// (4) The alpha component for blending is derived from pixs,
	/// by converting to grayscale and enhancing with a TRC.<para/>
	///
	/// (5) The last three arguments specify the TRC operation.
	/// Suggested values are: %gamma = 0.3, %minval = 50, %maxval = 200.
	/// To skip the TRC, use %gamma == 1, %minval = 0, %maxval = 255.
	/// See pixGammaTRC() for details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlendBackgroundToColor/*"/>
	///  <param name="pixd">[in]can be NULL - or pixs</param>
	///  <param name="box">[in] - region for blending can be NULL)</param>
	///  <param name="color">[in] - 32 bit color in 0xrrggbb00 format</param>
	///  <param name="gamma">[in] - args for grayscale TRC mapping</param>
	///  <param name="minval">[in] - args for grayscale TRC mapping</param>
	///  <param name="maxval">[in] - args for grayscale TRC mapping</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlendBackgroundToColor (Box box,
									   uint color,
									   Single gamma,
									   int minval,
									   int maxval,
									   Pix pixd)
	{
		Pix RetObj = _All.pixBlendBackgroundToColor(pixd, this, box, color, gamma, minval, maxval);
		return RetObj;
	}

	// blend.c (1926, 1)
	// pixMultiplyByColor(pixd, pixs, box, color) as Pix
	// pixMultiplyByColor(PIX *, PIX *, BOX *, l_uint32) as PIX *
	///  <summary>
	/// (1) This filters all pixels in the specified region by
	/// multiplying each component by the input color.
	/// This leaves black invariant and transforms white to the
	/// input color.<para/>
	///
	/// (2) If pixd == pixs, this is done in-place.<para/>
	///
	/// (3) If box == NULL, this is performed on all of pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMultiplyByColor/*"/>
	///  <param name="pixd">[in]can be NULL - or pixs</param>
	///  <param name="box">[in] - region for filtering can be NULL)</param>
	///  <param name="color">[in] - 32 bit color in 0xrrggbb00 format</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MultiplyByColor (Box box,
								uint color,
								Pix pixd)
	{
		Pix RetObj = _All.pixMultiplyByColor(pixd, this, box, color);
		return RetObj;
	}

	// blend.c (2004, 1)
	// pixAlphaBlendUniform(pixs, color) as Pix
	// pixAlphaBlendUniform(PIX *, l_uint32) as PIX *
	///  <summary>
	/// (1) This is a convenience function that renders 32 bpp RGBA images
	/// (with an alpha channel) over a uniform background of
	/// value %color.  To render over a white background,
	/// use %color = 0xffffff00.  The result is an RGB image.<para/>
	///
	/// (2) If pixs does not have an alpha channel, it returns a clone
	/// of pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAlphaBlendUniform/*"/>
	///  <param name="color">[in] - 32 bit color in 0xrrggbb00 format</param>
	///   <returns>pixd 32 bpp rgb: pixs blended over uniform color %color, a clone of pixs if no alpha, and NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AlphaBlendUniform (uint color)
	{
		Pix RetObj = _All.pixAlphaBlendUniform(this, color);
		return RetObj;
	}

	// blend.c (2057, 1)
	// pixAddAlphaToBlend(pixs, fract, invert) as Pix
	// pixAddAlphaToBlend(PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) This is a simple alpha layer generator, where typically white has
	/// maximum transparency and black has minimum.<para/>
	///
	/// (2) If %invert == 1, generate the same alpha layer but invert
	/// the input image photometrically.  This is useful for blending
	/// over dark images, where you want dark regions in pixs, such
	/// as text, to be lighter in the blended image.<para/>
	///
	/// (3) The fade %fract gives the minimum transparency (i.e.,
	/// maximum opacity).  A small fraction is useful for adding
	/// a watermark to an image.<para/>
	///
	/// (4) If pixs has a colormap, it is removed to rgb.<para/>
	///
	/// (5) If pixs already has an alpha layer, it is overwritten.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddAlphaToBlend/*"/>
	///  <param name="fract">[in] - fade fraction in the alpha component</param>
	///  <param name="invert">[in] - 1 to photometrically invert pixs</param>
	///   <returns>pixd 32 bpp with alpha, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddAlphaToBlend (Single fract,
								int invert)
	{
		Pix RetObj = _All.pixAddAlphaToBlend(this, fract, invert);
		return RetObj;
	}

	// blend.c (2116, 1)
	// pixSetAlphaOverWhite(pixs) as Pix
	// pixSetAlphaOverWhite(PIX *) as PIX *
	///  <summary>
	/// (1) The generated alpha component is transparent over white
	/// (background) pixels in pixs, and quickly grades to opaque
	/// away from the transparent parts.  This is a cheap and
	/// dirty alpha generator.  The 2 pixel gradation is useful
	/// to blur the boundary between the transparent region
	/// (that will render entirely from a backing image) and
	/// the remainder which renders from pixs.<para/>
	///
	/// (2) All alpha component bits in pixs are overwritten.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetAlphaOverWhite/*"/>
	///   <returns>pixd new pix with meaningful alpha component, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SetAlphaOverWhite ()
	{
		Pix RetObj = _All.pixSetAlphaOverWhite(this);
		return RetObj;
	}

	// blend.c (2178, 1)
	// pixLinearEdgeFade(pixs, dir, fadeto, distfract, maxfade) as int
	// pixLinearEdgeFade(PIX *, l_int32, l_int32, l_float32, l_float32) as l_ok
	///  <summary>
	/// (1) In-place operation.<para/>
	///
	/// (2) Maximum fading fraction %maxfade occurs at the edge of the image,
	/// and the fraction goes to 0 at the fractional distance %distfract
	/// from the edge.  %maxfade must be in [0, 1].<para/>
	///
	/// (3) %distrfact must be in [0, 1], and typically it would be smaller or equal 0.5.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixLinearEdgeFade/*"/>
	///  <param name="dir">[in] - L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
	///  <param name="fadeto">[in] - L_BLEND_TO_WHITE, L_BLEND_TO_BLACK</param>
	///  <param name="distfract">[in] - fraction of width or height over which fading occurs</param>
	///  <param name="maxfade">[in] - fraction of fading at the edge, smaller or equal 1.0</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int LinearEdgeFade (int dir,
							   int fadeto,
							   Single distfract,
							   Single maxfade)
	{
		int RetObj = _All.pixLinearEdgeFade(this, dir, fadeto, distfract, maxfade);
		return RetObj;
	}

	// bmpio.c (89, 1)
	// pixReadStreamBmp(fp) as Pix
	// pixReadStreamBmp(FILE *) as PIX *
	///  <summary>
	/// (1) Here are references on the bmp file format:
	/// http://en.wikipedia.org/wiki/BMP_file_format
	/// http://www.fortunecity.com/skyscraper/windows/364/bmpffrmt.html
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadStreamBmp/*"/>
	///  <param name="fp">[in] - file stream opened for read</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadStreamBmp (FILE fp)
	{
		Pix RetObj = _All.pixReadStreamBmp(fp);
		return RetObj;
	}

	// bmpio.c (119, 1)
	// pixReadMemBmp(cdata, size) as Pix
	// pixReadMemBmp(const l_uint8 *, size_t) as PIX *
	///  <summary>
	/// pixReadMemBmp()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadMemBmp/*"/>
	///  <param name="cdata">[in] - bmp data</param>
	///  <param name="size">[in] - number of bytes of bmp-formatted data</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadMemBmp (Byte[] cdata,
						   uint size)
	{
		Pix RetObj = _All.pixReadMemBmp(cdata, size);
		return RetObj;
	}

	// bmpio.c (351, 1)
	// pixWriteStreamBmp(fp, pix) as int
	// pixWriteStreamBmp(FILE *, PIX *) as l_ok
	///  <summary>
	/// pixWriteStreamBmp()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamBmp/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="pix">[in] - all depths</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamBmp (FILE fp,
							   Pix pix)
	{
		int RetObj = _All.pixWriteStreamBmp(fp, pix);
		return RetObj;
	}

	// bmpio.c (396, 1)
	// pixWriteMemBmp(pfdata, pfsize, pixs) as int
	// pixWriteMemBmp(l_uint8 **, size_t *, PIX *) as l_ok
	///  <summary>
	/// (1) 2 bpp bmp files are not valid in the spec, and are
	/// written as 8 bpp.<para/>
	///
	/// (2) pix with depth smaller or equal 8 bpp are written with a colormap.
	/// 16 bpp gray and 32 bpp rgb pix are written without a colormap.<para/>
	///
	/// (3) The transparency component in an rgb pix is ignored.
	/// All 32 bpp pix have the bmp alpha component set to 255 (opaque).<para/>
	///
	/// (4) The bmp colormap entries, RGBA_QUAD, are the same as
	/// the ones used for colormaps in leptonica.  This allows
	/// a simple memcpy for bmp output.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMemBmp/*"/>
	///  <param name="pfdata">[out] - data of bmp formatted image</param>
	///  <param name="pfsize">[out] - size of returned data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemBmp (out Byte[] pfdata,
							out uint pfsize)
	{
		int RetObj = _All.pixWriteMemBmp(out pfdata, out pfsize, this);
		return RetObj;
	}

	// boxfunc3.c (94, 1)
	// pixMaskConnComp(pixs, connectivity, pboxa) as Pix
	// pixMaskConnComp(PIX *, l_int32, BOXA **) as PIX *
	///  <summary>
	/// (1) This generates a mask image with ON pixels over the
	/// b.b. of the c.c. in pixs.  If there are no ON pixels in pixs,
	/// pixd will also have no ON pixels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMaskConnComp/*"/>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="pboxa">[out][optional] - bounding boxes of c.c.</param>
	///   <returns>pixd 1 bpp mask over the c.c., or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MaskConnComp (int connectivity,
							 out Boxa pboxa)
	{
		Pix RetObj = _All.pixMaskConnComp(this, connectivity, out pboxa);
		return RetObj;
	}

	// boxfunc3.c (148, 1)
	// pixMaskBoxa(pixd, pixs, boxa, op) as Pix
	// pixMaskBoxa(PIX *, PIX *, BOXA *, l_int32) as PIX *
	///  <summary>
	/// (1) This can be used with:
	/// pixd = NULL  (makes a new pixd)
	/// pixd = pixs  (in-place)<para/>
	///
	/// (2) If pixd == NULL, this first makes a copy of pixs, and then
	/// bit-twiddles over the boxes.  Otherwise, it operates directly
	/// on pixs.<para/>
	///
	/// (3) This simple function is typically used with 1 bpp images.
	/// It uses the 1-image rasterop function, rasteropUniLow(),
	/// to set, clear or flip the pixels in pixd.<para/>
	///
	/// (4) If you want to generate a 1 bpp mask of ON pixels from the boxes
	/// in a Boxa, in a pix of size (w,h):
	/// pix = pixCreate(w, h, 1)
	/// pixMaskBoxa(pix, pix, boxa, L_SET_PIXELS)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMaskBoxa/*"/>
	///  <param name="pixd">[in][optional] - may be NULL</param>
	///  <param name="boxa">[in] - of boxes, to paint</param>
	///  <param name="op">[in] - L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	///   <returns>pixd with masking op over the boxes, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MaskBoxa (Boxa boxa,
						 int op,
						 Pix pixd)
	{
		Pix RetObj = _All.pixMaskBoxa(pixd, this, boxa, op);
		return RetObj;
	}

	// boxfunc3.c (217, 1)
	// pixPaintBoxa(pixs, boxa, val) as Pix
	// pixPaintBoxa(PIX *, BOXA *, l_uint32) as PIX *
	///  <summary>
	/// (1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp
	/// and the boxa is painted using a colormap otherwise,
	/// it is converted to 32 bpp rgb.<para/>
	///
	/// (2) There are several ways to display a box on an image:
	/// Paint it as a solid color
	/// Draw the outline
	/// Blend the outline or region with the existing image
	/// We provide painting and drawing here blending is in blend.c.
	/// When painting or drawing, the result can be either a
	/// cmapped image or an rgb image.  The dest will be cmapped
	/// if the src is either 1 bpp or has a cmap that is not full.
	/// To force RGB output, use pixConvertTo8(pixs, FALSE)
	/// before calling any of these paint and draw functions.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixPaintBoxa/*"/>
	///  <param name="boxa">[in] - of boxes, to paint</param>
	///  <param name="val">[in] - rgba color to paint</param>
	///   <returns>pixd with painted boxes, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix PaintBoxa (Boxa boxa,
						  uint val)
	{
		Pix RetObj = _All.pixPaintBoxa(this, boxa, val);
		return RetObj;
	}

	// boxfunc3.c (283, 1)
	// pixSetBlackOrWhiteBoxa(pixs, boxa, op) as Pix
	// pixSetBlackOrWhiteBoxa(PIX *, BOXA *, l_int32) as PIX *
	///  <summary>
	/// pixSetBlackOrWhiteBoxa()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetBlackOrWhiteBoxa/*"/>
	///  <param name="boxa">[in][optional] - of boxes, to clear or set</param>
	///  <param name="op">[in] - L_SET_BLACK, L_SET_WHITE</param>
	///   <returns>pixd with boxes filled with white or black, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SetBlackOrWhiteBoxa (int op,
									Boxa boxa)
	{
		Pix RetObj = _All.pixSetBlackOrWhiteBoxa(this, boxa, op);
		return RetObj;
	}

	// boxfunc3.c (364, 1)
	// pixPaintBoxaRandom(pixs, boxa) as Pix
	// pixPaintBoxaRandom(PIX *, BOXA *) as PIX *
	///  <summary>
	/// (1) If pixs is 1 bpp, we paint the boxa using a colormap
	/// otherwise, we convert to 32 bpp.<para/>
	///
	/// (2) We use up to 254 different colors for painting the regions.<para/>
	///
	/// (3) If boxes overlap, the later ones paint over earlier ones.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixPaintBoxaRandom/*"/>
	///  <param name="boxa">[in] - of boxes, to paint</param>
	///   <returns>pixd with painted boxes, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix PaintBoxaRandom (Boxa boxa)
	{
		Pix RetObj = _All.pixPaintBoxaRandom(this, boxa);
		return RetObj;
	}

	// boxfunc3.c (435, 1)
	// pixBlendBoxaRandom(pixs, boxa, fract) as Pix
	// pixBlendBoxaRandom(PIX *, BOXA *, l_float32) as PIX *
	///  <summary>
	/// (1) pixs is converted to 32 bpp.<para/>
	///
	/// (2) This differs from pixPaintBoxaRandom(), in that the
	/// colors here are blended with the color of pixs.<para/>
	///
	/// (3) We use up to 254 different colors for painting the regions.<para/>
	///
	/// (4) If boxes overlap, the final color depends only on the last
	/// rect that is used.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlendBoxaRandom/*"/>
	///  <param name="boxa">[in] - of boxes, to blend/paint</param>
	///  <param name="fract">[in] - of box color to use</param>
	///   <returns>pixd 32 bpp, with blend/painted boxes, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlendBoxaRandom (Boxa boxa,
								Single fract)
	{
		Pix RetObj = _All.pixBlendBoxaRandom(this, boxa, fract);
		return RetObj;
	}

	// boxfunc3.c (496, 1)
	// pixDrawBoxa(pixs, boxa, width, val) as Pix
	// pixDrawBoxa(PIX *, BOXA *, l_int32, l_uint32) as PIX *
	///  <summary>
	/// (1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp
	/// and the boxa is drawn using a colormap otherwise,
	/// it is converted to 32 bpp rgb.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDrawBoxa/*"/>
	///  <param name="boxa">[in] - of boxes, to draw</param>
	///  <param name="width">[in] - of lines</param>
	///  <param name="val">[in] - rgba color to draw</param>
	///   <returns>pixd with outlines of boxes added, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DrawBoxa (Boxa boxa,
						 int width,
						 uint val)
	{
		Pix RetObj = _All.pixDrawBoxa(this, boxa, width, val);
		return RetObj;
	}

	// boxfunc3.c (560, 1)
	// pixDrawBoxaRandom(pixs, boxa, width) as Pix
	// pixDrawBoxaRandom(PIX *, BOXA *, l_int32) as PIX *
	///  <summary>
	/// (1) If pixs is 1 bpp, we draw the boxa using a colormap
	/// otherwise, we convert to 32 bpp.<para/>
	///
	/// (2) We use up to 254 different colors for drawing the boxes.<para/>
	///
	/// (3) If boxes overlap, the later ones draw over earlier ones.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDrawBoxaRandom/*"/>
	///  <param name="boxa">[in] - of boxes, to draw</param>
	///  <param name="width">[in] - thickness of line</param>
	///   <returns>pixd with box outlines drawn, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DrawBoxaRandom (Boxa boxa,
							   int width)
	{
		Pix RetObj = _All.pixDrawBoxaRandom(this, boxa, width);
		return RetObj;
	}

	// boxfunc3.c (835, 1)
	// pixSplitIntoBoxa(pixs, minsum, skipdist, delta, maxbg, maxcomps, remainder) as Boxa
	// pixSplitIntoBoxa(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) This generates a boxa of rectangles that covers
	/// the fg of a mask.  For each 8-connected component in pixs,
	/// it does a greedy partitioning, choosing the largest
	/// rectangle found from each of the four directions at each iter.
	/// See pixSplitComponentIntoBoxa() for details.<para/>
	///
	/// (2) The input parameters give some flexibility for boundary
	/// noise.  The resulting set of rectangles may cover some
	/// bg pixels.<para/>
	///
	/// (3) This should be used when there are a small number of
	/// mask components, each of which has sides that are close
	/// to horizontal and vertical.  The input parameters %delta
	/// and %maxbg determine whether or not holes in the mask are covered.<para/>
	///
	/// (4) The parameter %maxcomps gives the maximum number of allowed
	/// rectangles extracted from any single connected component.
	/// Use 0 if no limit is to be applied.<para/>
	///
	/// (5) The flag %remainder specifies whether we take a final bounding
	/// box for anything left after the maximum number of allowed
	/// rectangle is extracted.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSplitIntoBoxa/*"/>
	///  <param name="minsum">[in] - minimum pixels to trigger propagation</param>
	///  <param name="skipdist">[in] - distance before computing sum for propagation</param>
	///  <param name="delta">[in] - difference required to stop propagation</param>
	///  <param name="maxbg">[in] - maximum number of allowed bg pixels in ref scan</param>
	///  <param name="maxcomps">[in] - use 0 for unlimited number of subdivided components</param>
	///  <param name="remainder">[in] - set to 1 to get b.b. of remaining stuff</param>
	///   <returns>boxa of rectangles covering the fg of pixs, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa SplitIntoBoxa (int minsum,
							   int skipdist,
							   int delta,
							   int maxbg,
							   int maxcomps,
							   int remainder)
	{
		Boxa RetObj = _All.pixSplitIntoBoxa(this, minsum, skipdist, delta, maxbg, maxcomps, remainder);
		return RetObj;
	}

	// boxfunc3.c (944, 1)
	// pixSplitComponentIntoBoxa(pix, box, minsum, skipdist, delta, maxbg, maxcomps, remainder) as Boxa
	// pixSplitComponentIntoBoxa(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) This generates a boxa of rectangles that covers
	/// the fg of a mask.  It does so by a greedy partitioning of
	/// the mask, choosing the largest rectangle found from
	/// each of the four directions at each step.<para/>
	///
	/// (2) The input parameters give some flexibility for boundary
	/// noise.  The resulting set of rectangles must cover all
	/// the fg pixels and, in addition, may cover some bg pixels.
	/// Using small input parameters on a noiseless mask (i.e., one
	/// that has only large vertical and horizontal edges) will
	/// result in a proper covering of only the fg pixels of the mask.<para/>
	///
	/// (3) The input is assumed to be a single connected component, that
	/// may have holes.  From each side, sweep inward, counting
	/// the pixels.  If the count becomes greater than %minsum,
	/// and we have moved forward a further amount %skipdist,
	/// record that count ('countref'), but don't accept if the scan
	/// contains more than %maxbg bg pixels.  Continue the scan
	/// until we reach a count that differs from countref by at
	/// least %delta, at which point the propagation stops.  The box
	/// swept out gets a score, which is the sum of fg pixels
	/// minus a penalty.  The penalty is the number of bg pixels
	/// in the box.  This is done from all four sides, and the
	/// side with the largest score is saved as a rectangle.
	/// The process repeats until there is either no rectangle
	/// left, or there is one that can't be captured from any
	/// direction.  For the latter case, we simply accept the
	/// last rectangle.<para/>
	///
	/// (4) The input box is only used to specify the location of
	/// the UL corner of pix, with respect to an origin that
	/// typically represents the UL corner of an underlying image,
	/// of which pix is one component.  If %box is null,
	/// the UL corner is taken to be (0, 0).<para/>
	///
	/// (5) The parameter %maxcomps gives the maximum number of allowed
	/// rectangles extracted from any single connected component.
	/// Use 0 if no limit is to be applied.<para/>
	///
	/// (6) The flag %remainder specifies whether we take a final bounding
	/// box for anything left after the maximum number of allowed
	/// rectangle is extracted.<para/>
	///
	/// (7) So if %maxcomps  is greater  0, it specifies that we want no more than
	/// the first %maxcomps rectangles that satisfy the input
	/// criteria.  After this, we can get a final rectangle that
	/// bounds everything left over by setting %remainder == 1.
	/// If %remainder == 0, we only get rectangles that satisfy
	/// the input criteria.<para/>
	///
	/// (8) It should be noted that the removal of rectangles can
	/// break the original c.c. into several c.c.<para/>
	///
	/// (9) Summing up:
	/// If %maxcomp == 0, the splitting proceeds as far as possible.
	/// If %maxcomp  is greater  0, the splitting stops when %maxcomps are
	/// found, or earlier if no more components can be selected.
	/// If %remainder == 1 and components remain that cannot be
	/// selected, they are returned as a single final rectangle
	/// otherwise, they are ignored.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSplitComponentIntoBoxa/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///  <param name="box">[in][optional] - location of pix w/rt an origin</param>
	///  <param name="minsum">[in] - minimum pixels to trigger propagation</param>
	///  <param name="skipdist">[in] - distance before computing sum for propagation</param>
	///  <param name="delta">[in] - difference required to stop propagation</param>
	///  <param name="maxbg">[in] - maximum number of allowed bg pixels in ref scan</param>
	///  <param name="maxcomps">[in] - use 0 for unlimited number of subdivided components</param>
	///  <param name="remainder">[in] - set to 1 to get b.b. of remaining stuff</param>
	///   <returns>boxa of rectangles covering the fg of pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa SplitComponentIntoBoxa (Pix pix,
										int minsum,
										int skipdist,
										int delta,
										int maxbg,
										int maxcomps,
										int remainder,
										Box box)
	{
		Boxa RetObj = _All.pixSplitComponentIntoBoxa(pix, box, minsum, skipdist, delta, maxbg, maxcomps, remainder);
		return RetObj;
	}

	// boxfunc3.c (1532, 1)
	// pixSelectLargeULComp(pixs, areaslop, yslop, connectivity) as Box
	// pixSelectLargeULComp(PIX *, l_float32, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) This selects a box near the top (first) and left (second)
	/// of the image, from the set of all boxes that have
	/// area greater or equal %areaslop  (area of biggest box),
	/// where %areaslop is some fraction say ~ 0.9.<para/>
	///
	/// (2) For all boxes satisfying the above condition, select
	/// the left-most box that is within %yslop (say, 20) pixels
	/// of the box nearest the top.<para/>
	///
	/// (3) This can be used to reliably select a specific one of
	/// the largest regions in an image, for applications where
	/// there are expected to be small variations in region size
	/// and location.<para/>
	///
	/// (4) See boxSelectLargeULBox() for implementation details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSelectLargeULComp/*"/>
	///  <param name="areaslop">[in] - fraction near but less than 1.0</param>
	///  <param name="yslop">[in] - number of pixels in y direction</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>box, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box SelectLargeULComp (Single areaslop,
								  int yslop,
								  int connectivity)
	{
		Box RetObj = _All.pixSelectLargeULComp(this, areaslop, yslop, connectivity);
		return RetObj;
	}

	// ccbord.c (564, 1)
	// pixGetAllCCBorders(pixs) as CCBorda
	// pixGetAllCCBorders(PIX *) as CCBORDA *
	///  <summary>
	/// pixGetAllCCBorders()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetAllCCBorders/*"/>
	///   <returns>ccborda, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public CCBorda GetAllCCBorders ()
	{
		CCBorda RetObj = _All.pixGetAllCCBorders(this);
		return RetObj;
	}

	// ccbord.c (650, 1)
	// pixGetCCBorders(pixs, box) as CCBord
	// pixGetCCBorders(PIX *, BOX *) as CCBORD *
	///  <summary>
	/// (1) We are finding the exterior and interior borders
	/// of an 8-connected component. This should be used
	/// on a pix that has exactly one 8-connected component.<para/>
	///
	/// (2) Typically, pixs is a c.c. in some larger pix.  The
	/// input box gives its location in global coordinates.
	/// This box is saved, as well as the boxes for the
	/// borders of any holes within the c.c., but the latter
	/// are given in relative coords within the c.c.<para/>
	///
	/// (3) The calculations for the exterior border are done
	/// on a pix with a 1-pixel
	/// added border, but the saved pixel coordinates
	/// are the correct (relative) ones for the input pix
	/// (without a 1-pixel border)<para/>
	///
	/// (4) For the definition of the three tables -- xpostab[], ypostab[]
	/// and qpostab[] -- see above where they are defined.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetCCBorders/*"/>
	///  <param name="box">[in] - xul, yul, width, height in global coords</param>
	///   <returns>ccbord, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public CCBord GetCCBorders (Box box)
	{
		CCBord RetObj = _All.pixGetCCBorders(this, box);
		return RetObj;
	}

	// ccbord.c (761, 1)
	// pixGetOuterBordersPtaa(pixs) as Ptaa
	// pixGetOuterBordersPtaa(PIX *) as PTAA *
	///  <summary>
	/// pixGetOuterBordersPtaa()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetOuterBordersPtaa/*"/>
	///   <returns>ptaa of outer borders, in global coords, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Ptaa GetOuterBordersPtaa ()
	{
		Ptaa RetObj = _All.pixGetOuterBordersPtaa(this);
		return RetObj;
	}

	// ccbord.c (821, 1)
	// pixGetOuterBorderPta(pixs, box) as Pta
	// pixGetOuterBorderPta(PIX *, BOX *) as PTA *
	///  <summary>
	/// (1) We are finding the exterior border of a single 8-connected
	/// component.<para/>
	///
	/// (2) If box is NULL, the outline returned is in the local coords
	/// of the input pix.  Otherwise, box is assumed to give the
	/// location of the pix in global coordinates, and the returned
	/// pta will be in those global coordinates.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetOuterBorderPta/*"/>
	///  <param name="box">[in][optional] - of pixs, in global coordinates</param>
	///   <returns>pta of outer border, in global coords, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta GetOuterBorderPta (Box box)
	{
		Pta RetObj = _All.pixGetOuterBorderPta(this, box);
		return RetObj;
	}

	// ccbord.c (894, 1)
	// pixGetOuterBorder(ccb, pixs, box) as int
	// pixGetOuterBorder(CCBORD *, PIX *, BOX *) as l_ok
	///  <summary>
	/// (1) the border is saved in relative coordinates within
	/// the c.c. (pixs).  Because the calculation is done
	/// in pixb with added 1 pixel border, we must subtract
	/// 1 from each pixel value before storing it.<para/>
	///
	/// (2) the stopping condition is that after the first pixel is
	/// returned to, the next pixel is the second pixel.  Having
	/// these 2 pixels recur in sequence proves the path is closed,
	/// and we do not store the second pixel again.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetOuterBorder/*"/>
	///  <param name="ccb">[in] - unfilled</param>
	///  <param name="box">[in] - for the component, in global coords</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetOuterBorder (CCBord ccb,
							   Box box)
	{
		int RetObj = _All.pixGetOuterBorder(ccb, this, box);
		return RetObj;
	}

	// ccbord.c (982, 1)
	// pixGetHoleBorder(ccb, pixs, box, xs, ys) as int
	// pixGetHoleBorder(CCBORD *, PIX *, BOX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) we trace out hole border on pixs without addition
	/// of single pixel added border to pixs<para/>
	///
	/// (2) therefore all coordinates are relative within the c.c. (pixs)<para/>
	///
	/// (3) same position tables and stopping condition as for
	/// exterior borders
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetHoleBorder/*"/>
	///  <param name="ccb">[in] - the exterior border is already made</param>
	///  <param name="box">[in] - for the specific hole border, in relative coordinates to the c.c.</param>
	///  <param name="xs">[in] - first pixel on hole border, relative to c.c.</param>
	///  <param name="ys">[in] - first pixel on hole border, relative to c.c.</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetHoleBorder (CCBord ccb,
							  Box box,
							  int xs,
							  int ys)
	{
		int RetObj = _All.pixGetHoleBorder(ccb, this, box, xs, ys);
		return RetObj;
	}

	// ccthin.c (158, 1)
	// pixThinConnected(pixs, type, connectivity, maxiters) as Pix
	// pixThinConnected(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See "Connectivity-preserving morphological image transformations,"
	/// Dan S. Bloomberg, in SPIE Visual Communications and Image
	/// Processing, Conference 1606, pp. 320-334, November 1991,
	/// Boston, MA. A web version is available at
	/// http://www.leptonica.com/papers/conn.pdf<para/>
	///
	/// (2) This is a simple interface for two of the best iterative
	/// morphological thinning algorithms, for 4-c.c and 8-c.c.
	/// Each iteration uses a mixture of parallel operations
	/// (using several different 3x3 Sels) and serial operations.
	/// Specifically, each thinning iteration consists of
	/// four sequential thinnings from each of four directions.
	/// Each of these thinnings is a parallel composite
	/// operation, where the union of a set of HMTs are set
	/// subtracted from the input.  For 4-cc thinning, we
	/// use 3 HMTs in parallel, and for 8-cc thinning we use 4 HMTs.<para/>
	///
	/// (3) A "good" thinning algorithm is one that generates a skeleton
	/// that is near the medial axis and has neither pruned
	/// real branches nor left extra dendritic branches.<para/>
	///
	/// (4) Duality between operations on fg and bg require switching
	/// the connectivity.  To thin the foreground, which is the usual
	/// situation, use type == L_THIN_FG.  Thickening the foreground
	/// is equivalent to thinning the background (type == L_THIN_BG),
	/// where the alternate connectivity gets preserved.
	/// For example, to thicken the fg with 2 rounds of iterations
	/// using 4-c.c., thin the bg using Sels that preserve 8-connectivity:
	/// Pix pix = pixThinConnected(pixs, L_THIN_BG, 8, 2)<para/>
	///
	/// (5) This makes and destroys the sela set each time. It's not a large
	/// overhead, but if you are calling this thousands of times on
	/// very small images, you can avoid the overhead e.g.
	/// Sela sela = selaMakeThinSets(1, 0)  // for 4-c.c.
	/// Pix pix = pixThinConnectedBySet(pixs, L_THIN_FG, sela, 0)
	/// using set 1 for 4-c.c. and set 5 for 8-c.c operations.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixThinConnected/*"/>
	///  <param name="type">[in] - L_THIN_FG, L_THIN_BG</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="maxiters">[in] - max number of iters allowed use 0 to iterate until completion</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ThinConnected (int type,
							  int connectivity,
							  int maxiters)
	{
		Pix RetObj = _All.pixThinConnected(this, type, connectivity, maxiters);
		return RetObj;
	}

	// ccthin.c (220, 1)
	// pixThinConnectedBySet(pixs, type, sela, maxiters) as Pix
	// pixThinConnectedBySet(PIX *, l_int32, SELA *, l_int32) as PIX *
	///  <summary>
	/// (1) See notes in pixThinConnected().<para/>
	///
	/// (2) This takes a sela representing one of 11 sets of HMT Sels.
	/// The HMTs from this set are run in parallel and the result
	/// is OR'd before being subtracted from the source.  For each
	/// iteration, this "parallel" thin is performed four times
	/// sequentially, for sels rotated by 90 degrees in all four
	/// directions.<para/>
	///
	/// (3) The "parallel" and "sequential" nomenclature is standard
	/// in digital filtering.  Here, "parallel" operations work on the
	/// same source (pixd), and accumulate the results in a temp
	/// image before actually applying them to the source (in this
	/// case, using an in-place subtraction).  "Sequential" operations
	/// operate directly on the source (pixd) to produce the result
	/// (in this case, with four sequential thinning operations, one
	/// from each of four directions).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixThinConnectedBySet/*"/>
	///  <param name="type">[in] - L_THIN_FG, L_THIN_BG</param>
	///  <param name="sela">[in] - of Sels for parallel composite HMTs</param>
	///  <param name="maxiters">[in] - max number of iters allowed use 0 to iterate until completion</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ThinConnectedBySet (int type,
								   Sela sela,
								   int maxiters)
	{
		Pix RetObj = _All.pixThinConnectedBySet(this, type, sela, maxiters);
		return RetObj;
	}

	// classapp.c (378, 1)
	// pixGetWordsInTextlines(pixs, minwidth, minheight, maxwidth, maxheight, pboxad, ppixad, pnai) as int
	// pixGetWordsInTextlines(PIX *, l_int32, l_int32, l_int32, l_int32, BOXA **, PIXA **, NUMA **) as l_ok
	///  <summary>
	/// (1) The input should be at a resolution of between 75 and 150 ppi.<para/>
	///
	/// (2) The four size constraints on saved components are all
	/// scaled by %reduction.<para/>
	///
	/// (3) The result are word images (and their b.b.), extracted in
	/// textline order, at either full res or 2x reduction,
	/// and with a numa giving the textline index for each word.<para/>
	///
	/// (4) The pixa and boxa interfaces should make this type of
	/// application simple to put together.  The steps are:
	/// ~ generate first estimate of word masks
	/// ~ get b.b. of these, and remove the small and big ones
	/// ~ extract pixa of the word images, using the b.b.
	/// ~ sort actual word images in textline order (2d)
	/// ~ flatten them to a pixa (1d), saving the textline index
	/// for each pix<para/>
	///
	/// (5) In an actual application, it may be desirable to pre-filter
	/// the input image to remove large components, to extract
	/// single columns of text, and to deskew them.  For example,
	/// to remove both large components and small noisy components
	/// that can interfere with the statistics used to estimate
	/// parameters for segmenting by words, but still retain text lines,
	/// the following image preprocessing can be done:
	/// Pix pixt = pixMorphSequence(pixs, "c40.1", 0)
	/// Pix pixf = pixSelectBySize(pixt, 0, 60, 8,
	/// L_SELECT_HEIGHT, L_SELECT_IF_LT, NULL)
	/// pixAnd(pixf, pixf, pixs)  // the filtered image
	/// The closing turns text lines into long blobs, but does not
	/// significantly increase their height.  But if there are many
	/// small connected components in a dense texture, this is likely
	/// to generate tall components that will be eliminated in pixf.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetWordsInTextlines/*"/>
	///  <param name="minwidth">[in] - of saved components smaller are discarded</param>
	///  <param name="minheight">[in] - of saved components smaller are discarded</param>
	///  <param name="maxwidth">[in] - of saved components larger are discarded</param>
	///  <param name="maxheight">[in] - of saved components larger are discarded</param>
	///  <param name="pboxad">[out] - word boxes sorted in textline line order</param>
	///  <param name="ppixad">[out] - word images sorted in textline line order</param>
	///  <param name="pnai">[out] - index of textline for each word</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetWordsInTextlines (int minwidth,
									int minheight,
									int maxwidth,
									int maxheight,
									out Boxa pboxad,
									out Pixa ppixad,
									out Numa pnai)
	{
		int RetObj = _All.pixGetWordsInTextlines(this, minwidth, minheight, maxwidth, maxheight, out pboxad, out ppixad, out pnai);
		return RetObj;
	}

	// classapp.c (453, 1)
	// pixGetWordBoxesInTextlines(pixs, minwidth, minheight, maxwidth, maxheight, pboxad, pnai) as int
	// pixGetWordBoxesInTextlines(PIX *, l_int32, l_int32, l_int32, l_int32, BOXA **, NUMA **) as l_ok
	///  <summary>
	/// (1) The input should be at a resolution of between 75 and 150 ppi.<para/>
	///
	/// (2) This is a special version of pixGetWordsInTextlines(), that
	/// just finds the word boxes in line order, with a numa
	/// giving the textline index for each word.
	/// See pixGetWordsInTextlines() for more details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetWordBoxesInTextlines/*"/>
	///  <param name="minwidth">[in] - of saved components smaller are discarded</param>
	///  <param name="minheight">[in] - of saved components smaller are discarded</param>
	///  <param name="maxwidth">[in] - of saved components larger are discarded</param>
	///  <param name="maxheight">[in] - of saved components larger are discarded</param>
	///  <param name="pboxad">[out] - word boxes sorted in textline line order</param>
	///  <param name="pnai">[out][optional] - index of textline for each word</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetWordBoxesInTextlines (int minwidth,
										int minheight,
										int maxwidth,
										int maxheight,
										out Boxa pboxad,
										out Numa pnai)
	{
		int RetObj = _All.pixGetWordBoxesInTextlines(this, minwidth, minheight, maxwidth, maxheight, out pboxad, out pnai);
		return RetObj;
	}

	// colorcontent.c (179, 1)
	// pixColorContent(pixs, rwhite, gwhite, bwhite, mingray, ppixr, ppixg, ppixb) as int
	// pixColorContent(PIX *, l_int32, l_int32, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) This returns the color content in each component, which is
	/// a measure of the deviation from gray, and is defined
	/// as the difference between the component and the average of
	/// the other two components.  See the discussion at the
	/// top of this file.<para/>
	///
	/// (2) The three numbers (rwhite, gwhite and bwhite) can be thought
	/// of as the values in the image corresponding to white.
	/// They are used to compensate for an unbalanced color white point.
	/// They must either be all 0 or all non-zero.  To turn this
	/// off, set them all to 0.<para/>
	///
	/// (3) If the maximum component after white point correction,
	/// max(r,g,b), is less than mingray, all color components
	/// for that pixel are set to zero.
	/// Use mingray = 0 to turn off this filtering of dark pixels.<para/>
	///
	/// (4) Therefore, use 0 for all four input parameters if the color
	/// magnitude is to be calculated without either white balance
	/// correction or dark filtering.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorContent/*"/>
	///  <param name="rwhite">[in] - color value associated with white point</param>
	///  <param name="gwhite">[in] - color value associated with white point</param>
	///  <param name="bwhite">[in] - color value associated with white point</param>
	///  <param name="mingray">[in] - min gray value for which color is measured</param>
	///  <param name="ppixr">[out][optional] - 8 bpp red 'content'</param>
	///  <param name="ppixg">[out][optional] - 8 bpp green 'content'</param>
	///  <param name="ppixb">[out][optional] - 8 bpp blue 'content'</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ColorContent (int rwhite,
							 int gwhite,
							 int bwhite,
							 int mingray,
							 out Pix ppixr,
							 out Pix ppixg,
							 out Pix ppixb)
	{
		int RetObj = _All.pixColorContent(this, rwhite, gwhite, bwhite, mingray, out ppixr, out ppixg, out ppixb);
		return RetObj;
	}

	// colorcontent.c (363, 1)
	// pixColorMagnitude(pixs, rwhite, gwhite, bwhite, type) as Pix
	// pixColorMagnitude(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) For an RGB image, a gray pixel is one where all three components
	/// are equal.  We define the amount of color in an RGB pixel as
	/// a function depending on the absolute value of the differences
	/// between the three color components.  Consider the two largest
	/// of these differences.  The pixel component in common to these
	/// two differences is the color farthest from the other two.
	/// The color magnitude in an RGB pixel can be taken as one
	/// of these three definitions:
	/// (a) The average of these two differences.  This is the
	/// average distance from the two components that are
	/// nearest to each other to the third component.
	/// (b) The minimum value of these two differences.  This is
	/// the intermediate value of the three distances between
	/// component values.  Stated otherwise, it is the
	/// maximum over all components of the minimum distance
	/// from that component to the other two components.
	/// (c) The maximum difference between component values.<para/>
	///
	/// (2) As an example, suppose that R and G are the closest in
	/// magnitude.  Then the color is determined as either:
	/// (a) The average distance of B from these two:
	/// (|B - R| + |B - G|) / 2
	/// (b) The minimum distance of B from these two:
	/// min(|B - R|, |B - G|).
	/// (c) The maximum distance of B from these two:
	/// max(|B - R|, |B - G|)<para/>
	///
	/// (3) The three methods for choosing the color magnitude from
	/// the components are selected with these flags:
	/// (a) L_MAX_DIFF_FROM_AVERAGE_2
	/// (b) L_MAX_MIN_DIFF_FROM_2
	/// (c) L_MAX_DIFF<para/>
	///
	/// (4) The three numbers (rwhite, gwhite and bwhite) can be thought
	/// of as the values in the image corresponding to white.
	/// They are used to compensate for an unbalanced color white point.
	/// They must either be all 0 or all non-zero.  To turn this
	/// off, set them all to 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorMagnitude/*"/>
	///  <param name="rwhite">[in] - color value associated with white point</param>
	///  <param name="gwhite">[in] - color value associated with white point</param>
	///  <param name="bwhite">[in] - color value associated with white point</param>
	///  <param name="type">[in] - chooses the method for calculating the color magnitude: L_MAX_DIFF_FROM_AVERAGE_2, L_MAX_MIN_DIFF_FROM_2, L_MAX_DIFF</param>
	///   <returns>pixd 8 bpp, amount of color in each source pixel, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ColorMagnitude (int rwhite,
							   int gwhite,
							   int bwhite,
							   int type)
	{
		Pix RetObj = _All.pixColorMagnitude(this, rwhite, gwhite, bwhite, type);
		return RetObj;
	}

	// colorcontent.c (502, 1)
	// pixMaskOverColorPixels(pixs, threshdiff, mindist) as Pix
	// pixMaskOverColorPixels(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The generated mask identifies each pixel as either color or
	/// non-color.  For a pixel to be color, it must satisfy two
	/// constraints:
	/// (a) The max difference between the r,g and b components must
	/// equal or exceed a threshold %threshdiff.
	/// (b) It must be at least %mindist (in an 8-connected way)
	/// from the nearest non-color pixel.<para/>
	///
	/// (2) The distance constraint (b) is only applied if %mindist  is greater  1.
	/// For example, if %mindist == 2, the color pixels identified
	/// by (a) are eroded by a 3x3 Sel.  In general, the Sel size
	/// for erosion is 2  (%mindist - 1) + 1.
	/// Why have this constraint?  In scanned images that are
	/// essentially gray, color artifacts are typically introduced
	/// in transition regions near sharp edges that go from dark
	/// to light, so this allows these transition regions to be removed.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMaskOverColorPixels/*"/>
	///  <param name="threshdiff">[in] - threshold for minimum of the max difference between components</param>
	///  <param name="mindist">[in] - minimum allowed distance from nearest non-color pixel</param>
	///   <returns>pixd 1 bpp, mask over color pixels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MaskOverColorPixels (int threshdiff,
									int mindist)
	{
		Pix RetObj = _All.pixMaskOverColorPixels(this, threshdiff, mindist);
		return RetObj;
	}

	// colorcontent.c (569, 1)
	// pixMaskOverColorRange(pixs, rmin, rmax, gmin, gmax, bmin, bmax) as Pix
	// pixMaskOverColorRange(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixMaskOverColorRange()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMaskOverColorRange/*"/>
	///  <param name="rmin">[in] - min and max allowed values for red component</param>
	///  <param name="rmax">[in] - min and max allowed values for red component</param>
	///  <param name="gmin">[in] - </param>
	///  <param name="gmax">[in] - </param>
	///  <param name="bmin">[in] - </param>
	///  <param name="bmax">[in] - </param>
	///   <returns>pixd 1 bpp, mask over color pixels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MaskOverColorRange (int rmin,
								   int rmax,
								   int gmin,
								   int gmax,
								   int bmin,
								   int bmax)
	{
		Pix RetObj = _All.pixMaskOverColorRange(this, rmin, rmax, gmin, gmax, bmin, bmax);
		return RetObj;
	}

	// colorcontent.c (678, 1)
	// pixColorFraction(pixs, darkthresh, lightthresh, diffthresh, factor, ppixfract, pcolorfract) as int
	// pixColorFraction(PIX *, l_int32, l_int32, l_int32, l_int32, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) This function is asking the question: to what extent does the
	/// image appear to have color? The amount of color a pixel
	/// appears to have depends on both the deviation of the
	/// individual components from their average and on the average
	/// intensity itself.  For example, the color will be much more
	/// obvious with a small deviation from white than the same
	/// deviation from black.<para/>
	///
	/// (2) Any pixel that meets these three tests is considered a
	/// colorful pixel:
	/// (a) the lightest component must equal or exceed %darkthresh
	/// (b) the darkest component must not exceed %lightthresh
	/// (c) the max difference between components must equal or
	/// exceed %diffthresh.<para/>
	///
	/// (3) The dark pixels are removed from consideration because
	/// they don't appear to have color.<para/>
	///
	/// (4) The very lightest pixels are removed because if an image
	/// has a lot of "white", the color fraction will be artificially
	/// low, even if all the other pixels are colorful.<para/>
	///
	/// (5) If pixfract is very small, there are few pixels that are neither
	/// black nor white.  If colorfract is very small, the pixels
	/// that are neither black nor white have very little color
	/// content.  The product 'pixfract  colorfract' gives the
	/// fraction of pixels with significant color content.<para/>
	///
	/// (6) One use of this function is as a preprocessing step for median
	/// cut quantization (colorquant2.c), which does a very poor job
	/// splitting the color space into rectangular volume elements when
	/// all the pixels are near the diagonal of the color cube.  For
	/// octree quantization of an image with only gray values, the
	/// 2^(level) octcubes on the diagonal are the only ones
	/// that can be occupied.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorFraction/*"/>
	///  <param name="darkthresh">[in] - threshold near black if the lightest component is below this, the pixel is not considered in the statistics typ. 20</param>
	///  <param name="lightthresh">[in] - threshold near white if the darkest component is above this, the pixel is not considered in the statistics typ. 244</param>
	///  <param name="diffthresh">[in] - thresh for the maximum difference between component value below this the pixel is not considered to have sufficient color</param>
	///  <param name="factor">[in] - subsampling factor</param>
	///  <param name="ppixfract">[out] - fraction of pixels in intermediate brightness range that were considered for color content</param>
	///  <param name="pcolorfract">[out] - fraction of pixels that meet the criterion for sufficient color 0.0 on error</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ColorFraction (int darkthresh,
							  int lightthresh,
							  int diffthresh,
							  int factor,
							  out Single ppixfract,
							  out Single pcolorfract)
	{
		int RetObj = _All.pixColorFraction(this, darkthresh, lightthresh, diffthresh, factor, out ppixfract, out pcolorfract);
		return RetObj;
	}

	// colorcontent.c (805, 1)
	// pixFindColorRegions(pixs, pixm, factor, lightthresh, darkthresh, mindiff, colordiff, edgefract, pcolorfract, pcolormask1, pcolormask2, pixadb) as int
	// pixFindColorRegions(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_float32, l_float32 *, PIX **, PIX **, PIXA *) as l_ok
	///  <summary>
	/// (1) This function tries to determine if there is a significant
	/// color or darker region on a scanned page image, where part
	/// of the image is background that is either white or reddish.
	/// This also allows extraction of regions of colored pixels that
	/// have a smaller red component than blue or green components.<para/>
	///
	/// (2) If %pixm exists, pixels under its fg are combined with
	/// dark pixels to make a mask of pixels not to be considered
	/// as color candidates.<para/>
	///
	/// (3) There are four thresholds.
	/// %lightthresh: compute the average value of each rgb pixel,
	/// and make 10 buckets by value.  If the lightest bucket gray
	/// value is below %lightthresh, the image is not considered
	/// to have a light bg, and this returns 0.0 for %colorfract.
	/// %darkthresh: ignore pixels darker than this (typ. fg text).
	/// We make a 1 bpp mask of these pixels, and then dilate it to
	/// remove all vestiges of fg from their vicinity.
	/// %mindiff: consider pixels with either (b - r) or (g - r)
	/// being at least this value, as having color.
	/// %colordiff: consider pixels where the (max - min) difference
	/// of the pixel components exceeds this value, as having color.<para/>
	///
	/// (4) All components of color pixels that are touching the image
	/// border are removed.  Additionally, all pixels within some
	/// normalized distance %edgefract from the image border can
	/// be removed.  This insures that dark pixels near the edge
	/// of the image are not included.<para/>
	///
	/// (5) This returns in %pcolorfract the fraction of pixels that have
	/// color and are not in the set consisting of an OR between
	/// %pixm and the dilated dark pixel mask.<para/>
	///
	/// (6) No masks are returned unless light color pixels are found.
	/// If colorfract  is greater  0.0 and %pcolormask1 is defined, this returns
	/// a 1 bpp mask with fg pixels over the color background.
	/// This mask may have some holes in it.<para/>
	///
	/// (7) If colorfract  is greater  0.0 and %pcolormask2 is defined, this returns
	/// a version of colormask1 where small holes have been filled.<para/>
	///
	/// (8) To generate a boxa of rectangular regions from the overlap
	/// of components in the filtered mask:
	/// boxa1 = pixConnCompBB(colormask2, 8)
	/// boxa2 = boxaCombineOverlaps(boxa1, NULL)
	/// This is done here in debug mode.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindColorRegions/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask image</param>
	///  <param name="factor">[in] - subsample factor integer greater or equal 1</param>
	///  <param name="lightthresh">[in] - threshold for component average in lightest of 10 buckets typ. 210 -1 for default</param>
	///  <param name="darkthresh">[in] - threshold to eliminate dark pixels (e.g., text) from consideration typ. 70 -1 for default.</param>
	///  <param name="mindiff">[in] - minimum difference (b - r) and (g - r), used to find blue or green pixels typ. 10 -1 for default</param>
	///  <param name="colordiff">[in] - minimum difference in (max - min) component to qualify as a color pixel typ. 90 -1 for default</param>
	///  <param name="edgefract">[in] - fraction of image half-width and half-height for which color pixels are ignored typ. 0.05.</param>
	///  <param name="pcolorfract">[out] - fraction of 'color' pixels found</param>
	///  <param name="pcolormask1">[out][optional] - mask over background color, if any</param>
	///  <param name="pcolormask2">[out][optional] - filtered mask over background color</param>
	///  <param name="pixadb">[out][optional] - debug intermediate results</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindColorRegions (int factor,
								 int lightthresh,
								 int darkthresh,
								 int mindiff,
								 int colordiff,
								 Single edgefract,
								 out Single pcolorfract,
								 Pix pixm,
								 out Pix pcolormask1,
								 out Pix pcolormask2,
								 out Pixa pixadb)
	{
		int RetObj = _All.pixFindColorRegions(this, pixm, factor, lightthresh, darkthresh, mindiff, colordiff, edgefract, out pcolorfract, out pcolormask1, out pcolormask2, out pixadb);
		return RetObj;
	}

	// colorcontent.c (1022, 1)
	// pixNumSignificantGrayColors(pixs, darkthresh, lightthresh, minfract, factor, pncolors) as int
	// pixNumSignificantGrayColors(PIX *, l_int32, l_int32, l_float32, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) This function is asking the question: how many perceptually
	/// significant gray color levels is in this pix?
	/// A color level must meet 3 criteria to be significant:
	/// ~ it can't be too close to black
	/// ~ it can't be too close to white
	/// ~ it must have at least some minimum fractional population<para/>
	///
	/// (2) Use -1 for default values for darkthresh, lightthresh and minfract.<para/>
	///
	/// (3) Choose default of darkthresh = 20, because variations in very
	/// dark pixels are not visually significant.<para/>
	///
	/// (4) Choose default of lightthresh = 236, because document images
	/// that have been jpeg'd typically have near-white pixels in the
	/// 8x8 jpeg blocks, and these should not be counted.  It is desirable
	/// to obtain a clean image by quantizing this noise away.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixNumSignificantGrayColors/*"/>
	///  <param name="darkthresh">[in] - dark threshold for minimum intensity to be considered typ. 20</param>
	///  <param name="lightthresh">[in] - threshold near white, for maximum intensity to be considered typ. 236</param>
	///  <param name="minfract">[in] - minimum fraction of all pixels to include a level as significant typ. 0.0001 should be  is smaller 0.001</param>
	///  <param name="factor">[in] - subsample factor integer greater or equal 1</param>
	///  <param name="pncolors">[out] - number of significant colors 0 on error</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int NumSignificantGrayColors (int darkthresh,
										 int lightthresh,
										 Single minfract,
										 int factor,
										 out int pncolors)
	{
		int RetObj = _All.pixNumSignificantGrayColors(this, darkthresh, lightthresh, minfract, factor, out pncolors);
		return RetObj;
	}

	// colorcontent.c (1145, 1)
	// pixColorsForQuantization(pixs, thresh, pncolors, piscolor, debug) as int
	// pixColorsForQuantization(PIX *, l_int32, l_int32 *, l_int32 *, l_int32) as l_ok
	///  <summary>
	/// (1) This function finds a measure of the number of colors that are
	/// found in low-gradient regions of an image.  By its
	/// magnitude relative to some threshold (not specified in
	/// this function), it gives a good indication of whether
	/// quantization will generate posterization. This number
	/// is larger for images with regions of slowly varying
	/// intensity (if 8 bpp) or color (if rgb). Such images, if
	/// quantized, may require dithering to avoid posterization,
	/// and lossless compression is then expected to be poor.<para/>
	///
	/// (2) If pixs has a colormap, the number of colors returned is
	/// the number in the colormap.<para/>
	///
	/// (3) It is recommended that document images be reduced to a width
	/// of 800 pixels before applying this function.  Then it can
	/// be expected that color detection will be fairly accurate
	/// and the number of colors will reflect both the content and
	/// the type of compression to be used.  For less than 15 colors,
	/// there is unlikely to be a halftone image, and lossless
	/// quantization should give both a good visual result and
	/// better compression.<para/>
	///
	/// (4) When using the default threshold on the gradient (15),
	/// images (both gray and rgb) where ncolors is greater than
	/// about 15 will compress poorly with either lossless
	/// compression or dithered quantization, and they may be
	/// posterized with non-dithered quantization.<para/>
	///
	/// (5) For grayscale images, or images without significant color,
	/// this returns the number of significant gray levels in
	/// the low-gradient regions.  The actual number of gray levels
	/// can be large due to jpeg compression noise in the background.<para/>
	///
	/// (6) Similarly, for color images, the actual number of different
	/// (r,g,b) colors in the low-gradient regions (rather than the
	/// number of occupied level 4 octcubes) can be quite large, e.g.,
	/// due to jpeg compression noise, even for regions that appear
	/// to be of a single color.  By quantizing to level 4 octcubes,
	/// most of these superfluous colors are removed from the counting.<para/>
	///
	/// (7) The image is tested for color.  If there is very little color,
	/// it is thresholded to gray and the number of gray levels in
	/// the low gradient regions is found.  If the image has color,
	/// the number of occupied level 4 octcubes is found.<para/>
	///
	/// (8) The number of colors in the low-gradient regions increases
	/// monotonically with the threshold %thresh on the edge gradient.<para/>
	///
	/// (9) Background: grayscale and color quantization is often useful
	/// to achieve highly compressed images with little visible
	/// distortion.  However, gray or color washes (regions of
	/// low gradient) can defeat this approach to high compression.
	/// How can one determine if an image is expected to compress
	/// well using gray or color quantization?  We use the fact that
	/// gray washes, when quantized with less than 50 intensities,
	/// have posterization (visible boundaries between regions
	/// of uniform 'color') and poor lossless compression
	/// color washes, when quantized with level 4 octcubes,
	/// typically result in both posterization and the occupancy
	/// of many level 4 octcubes.
	/// Images can have colors either intrinsically or as jpeg
	/// compression artifacts.  This function reduces but does not
	/// completely eliminate measurement of jpeg quantization noise
	/// in the white background of grayscale or color images.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorsForQuantization/*"/>
	///  <param name="thresh">[in] - binary threshold on edge gradient 0 for default</param>
	///  <param name="pncolors">[out] - the number of colors found</param>
	///  <param name="piscolor">[out][optional] - 1 if significant color is found 0 otherwise.  If pixs is 8 bpp, and does not have a colormap with color entries, this is 0</param>
	///  <param name="debug">[in] - 1 to output masked image that is tested for colors 0 otherwise</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int ColorsForQuantization (int thresh,
									  out int pncolors,
									  out int piscolor,
									  DebugOnOff debug)
	{
		int RetObj = _All.pixColorsForQuantization(this, thresh, out pncolors, out piscolor, debug);
		return RetObj;
	}

	// colorcontent.c (1287, 1)
	// pixNumColors(pixs, factor, pncolors) as int
	// pixNumColors(PIX *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) This returns the actual number of colors found in the image,
	/// even if there is a colormap.  If %factor == 1 and the
	/// number of colors differs from the number of entries
	/// in the colormap, a warning is issued.<para/>
	///
	/// (2) Use %factor == 1 to find the actual number of colors.
	/// Use %factor  is greater  1 to quickly find the approximate number of colors.<para/>
	///
	/// (3) For d = 2, 4 or 8 bpp grayscale, this returns the number
	/// of colors found in the image in 'ncolors'.<para/>
	///
	/// (4) For d = 32 bpp (rgb), if the number of colors is
	/// greater than 256, this returns 0 in 'ncolors'.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixNumColors/*"/>
	///  <param name="factor">[in] - subsampling factor integer</param>
	///  <param name="pncolors">[out] - the number of colors found, or 0 if there are more than 256</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int NumColors (int factor,
						  out int pncolors)
	{
		int RetObj = _All.pixNumColors(this, factor, out pncolors);
		return RetObj;
	}

	// colorcontent.c (1395, 1)
	// pixGetMostPopulatedColors(pixs, sigbits, factor, ncolors, parray, pcmap) as int
	// pixGetMostPopulatedColors(PIX *, l_int32, l_int32, l_int32, l_uint32 **, PIXCMAP **) as l_ok
	///  <summary>
	/// (1) This finds the %ncolors most populated cubes in rgb colorspace,
	/// where the cube size depends on %sigbits as
	/// cube side = (256  is greater  is greater  sigbits)<para/>
	///
	/// (2) The rgb color components are found at the center of the cube.<para/>
	///
	/// (3) The output array of colors can be displayed using
	/// pixDisplayColorArray(array, ncolors, ...)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetMostPopulatedColors/*"/>
	///  <param name="sigbits">[in] - 2-6, significant bits retained in the quantizer for each component of the input image</param>
	///  <param name="factor">[in] - subsampling factor use 1 for no subsampling</param>
	///  <param name="ncolors">[in] - the number of most populated colors to select</param>
	///  <param name="parray">[out][optional] - array of colors, each as 0xrrggbb00</param>
	///  <param name="pcmap">[out][optional] - colormap of the colors</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMostPopulatedColors (int sigbits,
									   int factor,
									   int ncolors,
									   out Byte[] parray,
									   out PixColormap pcmap)
	{
		int RetObj = _All.pixGetMostPopulatedColors(this, sigbits, factor, ncolors, out parray, out pcmap);
		return RetObj;
	}

	// colorcontent.c (1470, 1)
	// pixSimpleColorQuantize(pixs, sigbits, factor, ncolors) as Pix
	// pixSimpleColorQuantize(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) If you want to do color quantization for real, use octcube
	/// or modified median cut.  This function shows that it is
	/// easy to make a simple quantizer based solely on the population
	/// in cells of a given size in rgb color space.<para/>
	///
	/// (2) The %ncolors most populated cells at the %sigbits level form
	/// the colormap for quantizing, and this uses octcube indexing
	/// under the covers to assign each pixel to the nearest color.<para/>
	///
	/// (3) %sigbits is restricted to 2, 3 and 4.  At the low end, the
	/// color discrimination is very crude at the upper end, a set of
	/// similar colors can dominate the result.  Interesting results
	/// are generally found for %sigbits = 3 and ncolors ~ 20.<para/>
	///
	/// (4) See also pixColorSegment() for a method of quantizing the
	/// colors to generate regions of similar color.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSimpleColorQuantize/*"/>
	///  <param name="sigbits">[in] - 2-4, significant bits retained in the quantizer for each component of the input image</param>
	///  <param name="factor">[in] - subsampling factor use 1 for no subsampling</param>
	///  <param name="ncolors">[in] - the number of most populated colors to select</param>
	///   <returns>pixd 8 bpp cmapped or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SimpleColorQuantize (int sigbits,
									int factor,
									int ncolors)
	{
		Pix RetObj = _All.pixSimpleColorQuantize(this, sigbits, factor, ncolors);
		return RetObj;
	}

	// colorcontent.c (1516, 1)
	// pixGetRGBHistogram(pixs, sigbits, factor) as Numa
	// pixGetRGBHistogram(PIX *, l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) This uses a simple, fast method of indexing into an rgb image.<para/>
	///
	/// (2) The output is a 1D histogram of count vs. rgb-index, which
	/// uses red sigbits as the most significant and blue as the least.<para/>
	///
	/// (3) This function produces the same result as pixMedianCutHisto().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRGBHistogram/*"/>
	///  <param name="sigbits">[in] - 2-6, significant bits retained in the quantizer for each component of the input image</param>
	///  <param name="factor">[in] - subsampling factor use 1 for no subsampling</param>
	///   <returns>numa histogram of colors, indexed by RGB components, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetRGBHistogram (int sigbits,
								 int factor)
	{
		Numa RetObj = _All.pixGetRGBHistogram(this, sigbits, factor);
		return RetObj;
	}

	// colorcontent.c (1757, 1)
	// pixHasHighlightRed(pixs, factor, fract, fthresh, phasred, pratio, ppixdb) as int
	// pixHasHighlightRed(PIX *, l_int32, l_float32, l_float32, l_int32 *, l_float32 *, PIX **) as l_ok
	///  <summary>
	/// (1) Pixels are identified as red if they satisfy two conditions:
	/// (a) The components satisfy (R-B)/B  is greater  %fthresh (red or dark fg)
	/// (b) The red component satisfied R  is greater  128  (red or light bg)
	/// Masks are generated for (a) and (b), and the intersection
	/// gives the pixels that are red but not either light bg or
	/// dark fg.<para/>
	///
	/// (2) A typical value for fract = 0.0001, which gives sensitivity
	/// to an image where a small fraction of the pixels are printed
	/// in red.<para/>
	///
	/// (3) A typical value for fthresh = 2.5.  Higher values give less
	/// sensitivity to red, and fewer false positives.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixHasHighlightRed/*"/>
	///  <param name="factor">[in] - subsampling an integer greater or equal 1 use 1 for all pixels</param>
	///  <param name="fract">[in] - threshold fraction of all image pixels</param>
	///  <param name="fthresh">[in] - threshold on a function of the components typ. ~2.5</param>
	///  <param name="phasred">[out] - 1 if red pixels are above threshold</param>
	///  <param name="pratio">[out][optional] - normalized fraction of threshold red pixels that is actually observed</param>
	///  <param name="ppixdb">[out][optional] - seed pixel mask</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int HasHighlightRed (int factor,
								Single fract,
								Single fthresh,
								out int phasred,
								out Single pratio,
								out Pix ppixdb)
	{
		int RetObj = _All.pixHasHighlightRed(this, factor, fract, fthresh, out phasred, out pratio, out ppixdb);
		return RetObj;
	}

	// coloring.c (126, 1)
	// pixColorGrayRegions(pixs, boxa, type, thresh, rval, gval, bval) as Pix
	// pixColorGrayRegions(PIX *, BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This generates a new image, where some of the pixels in each
	/// box in the boxa are colorized.  See pixColorGray() for usage
	/// with %type and %thresh.  Note that %thresh is only used for
	/// rgb it is ignored for colormapped images.<para/>
	///
	/// (2) If the input image is colormapped, the new image will be 8 bpp
	/// colormapped if possible otherwise, it will be converted
	/// to 32 bpp rgb.  Only pixels that are strictly gray will be
	/// colorized.<para/>
	///
	/// (3) If the input image is not colormapped, it is converted to rgb.
	/// A "gray" value for a pixel is determined by averaging the
	/// components, and the output rgb value is determined from this.<para/>
	///
	/// (4) This can be used in conjunction with pixHasHighlightRed() to
	/// add highlight color to a grayscale image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorGrayRegions/*"/>
	///  <param name="boxa">[in] - of regions in which to apply color</param>
	///  <param name="type">[in] - L_PAINT_LIGHT, L_PAINT_DARK</param>
	///  <param name="thresh">[in] - average value below/above which pixel is unchanged</param>
	///  <param name="rval">[in] - new color to paint</param>
	///  <param name="gval">[in] - new color to paint</param>
	///  <param name="bval">[in] - new color to paint</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ColorGrayRegions (Boxa boxa,
								 int type,
								 int thresh,
								 int rval,
								 int gval,
								 int bval)
	{
		Pix RetObj = _All.pixColorGrayRegions(this, boxa, type, thresh, rval, gval, bval);
		return RetObj;
	}

	// coloring.c (227, 1)
	// pixColorGray(pixs, box, type, thresh, rval, gval, bval) as int
	// pixColorGray(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place operation pixs is modified.
	/// If pixs is colormapped, the operation will add colors to the
	/// colormap.  Otherwise, pixs will be converted to 32 bpp rgb if
	/// it is initially 8 bpp gray.<para/>
	///
	/// (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
	/// preserving antialiasing.
	/// If type == L_PAINT_DARK, it colorizes non-white pixels,
	/// preserving antialiasing.<para/>
	///
	/// (3) If box is NULL, applies function to the entire image otherwise,
	/// clips the operation to the intersection of the box and pix.<para/>
	///
	/// (4) If colormapped, calls pixColorGrayCmap(), which applies the
	/// coloring algorithm only to pixels that are strictly gray.<para/>
	///
	/// (5) For RGB, determines a "gray" value by averaging then uses this
	/// value, plus the input rgb target, to generate the output
	/// pixel values.<para/>
	///
	/// (6) thresh is only used for rgb it is ignored for colormapped pix.
	/// If type == L_PAINT_LIGHT, use thresh = 0 if all pixels are to
	/// be colored (black pixels will be unaltered).
	/// In situations where there are a lot of black pixels,
	/// setting thresh  is greater  0 will make the function considerably
	/// more efficient without affecting the final result.
	/// If type == L_PAINT_DARK, use thresh = 255 if all pixels
	/// are to be colored (white pixels will be unaltered).
	/// In situations where there are a lot of white pixels,
	/// setting thresh  is smaller 255 will make the function considerably
	/// more efficient without affecting the final result.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorGray/*"/>
	///  <param name="box">[in][optional] - region in which to apply color can be NULL</param>
	///  <param name="type">[in] - L_PAINT_LIGHT, L_PAINT_DARK</param>
	///  <param name="thresh">[in] - average value below/above which pixel is unchanged</param>
	///  <param name="rval">[in] - new color to paint</param>
	///  <param name="gval">[in] - new color to paint</param>
	///  <param name="bval">[in] - new color to paint</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ColorGray (int type,
						  int thresh,
						  int rval,
						  int gval,
						  int bval,
						  Box box)
	{
		int RetObj = _All.pixColorGray(this, box, type, thresh, rval, gval, bval);
		return RetObj;
	}

	// coloring.c (353, 1)
	// pixColorGrayMasked(pixs, pixm, type, thresh, rval, gval, bval) as Pix
	// pixColorGrayMasked(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This generates a new image, where some of the pixels under
	/// FG in the mask are colorized.<para/>
	///
	/// (2) See pixColorGray() for usage with %type and %thresh.  Note
	/// that %thresh is only used for rgb it is ignored for
	/// colormapped images.  In most cases, the mask will be over
	/// the darker parts and %type == L_PAINT_DARK.<para/>
	///
	/// (3) If pixs is colormapped this calls pixColorMaskedCmap(),
	/// which adds colors to the colormap for pixd it only adds
	/// colors corresponding to strictly gray colors in the colormap.
	/// Otherwise, if pixs is 8 bpp gray, pixd will be 32 bpp rgb.<para/>
	///
	/// (4) If pixs is 32 bpp rgb, for each pixel a "gray" value is
	/// found by averaging.  This average is then used with the
	/// input rgb target to generate the output pixel values.<para/>
	///
	/// (5) This can be used in conjunction with pixHasHighlightRed() to
	/// add highlight color to a grayscale image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorGrayMasked/*"/>
	///  <param name="pixm">[in] - 1 bpp mask, through which to apply color</param>
	///  <param name="type">[in] - L_PAINT_LIGHT, L_PAINT_DARK</param>
	///  <param name="thresh">[in] - average value below/above which pixel is unchanged</param>
	///  <param name="rval">[in] - new color to paint</param>
	///  <param name="gval">[in] - new color to paint</param>
	///  <param name="bval">[in] - new color to paint</param>
	///   <returns>pixd colorized, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ColorGrayMasked (Pix pixm,
								int type,
								int thresh,
								int rval,
								int gval,
								int bval)
	{
		Pix RetObj = _All.pixColorGrayMasked(this, pixm, type, thresh, rval, gval, bval);
		return RetObj;
	}

	// coloring.c (478, 1)
	// pixSnapColor(pixd, pixs, srcval, dstval, diff) as Pix
	// pixSnapColor(PIX *, PIX *, l_uint32, l_uint32, l_int32) as PIX *
	///  <summary>
	/// (1) For inplace operation, call it this way:
	/// pixSnapColor(pixs, pixs, ... )<para/>
	///
	/// (2) For generating a new pixd:
	/// pixd = pixSnapColor(NULL, pixs, ...)<para/>
	///
	/// (3) If pixs has a colormap, it is handled by pixSnapColorCmap().<para/>
	///
	/// (4) All pixels within 'diff' of 'srcval', componentwise,
	/// will be changed to 'dstval'.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSnapColor/*"/>
	///  <param name="pixd">[in][optional] - either NULL or equal to pixs for in-place</param>
	///  <param name="srcval">[in] - color center to be selected for change: 0xrrggbb00</param>
	///  <param name="dstval">[in] - target color for pixels: 0xrrggbb00</param>
	///  <param name="diff">[in] - max absolute difference, applied to all components</param>
	///   <returns>pixd with all pixels within diff of pixval set to pixval, or pixd on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SnapColor (uint srcval,
						  uint dstval,
						  int diff,
						  Pix pixd)
	{
		Pix RetObj = _All.pixSnapColor(pixd, this, srcval, dstval, diff);
		return RetObj;
	}

	// coloring.c (565, 1)
	// pixSnapColorCmap(pixd, pixs, srcval, dstval, diff) as Pix
	// pixSnapColorCmap(PIX *, PIX *, l_uint32, l_uint32, l_int32) as PIX *
	///  <summary>
	/// (1) For inplace operation, call it this way:
	/// pixSnapCcmap(pixs, pixs, ... )<para/>
	///
	/// (2) For generating a new pixd:
	/// pixd = pixSnapCmap(NULL, pixs, ...)<para/>
	///
	/// (3) pixs must have a colormap.<para/>
	///
	/// (4) All colors within 'diff' of 'srcval', componentwise,
	/// will be changed to 'dstval'.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSnapColorCmap/*"/>
	///  <param name="pixd">[in][optional] - either NULL or equal to pixs for in-place</param>
	///  <param name="srcval">[in] - color center to be selected for change: 0xrrggbb00</param>
	///  <param name="dstval">[in] - target color for pixels: 0xrrggbb00</param>
	///  <param name="diff">[in] - max absolute difference, applied to all components</param>
	///   <returns>pixd with all pixels within diff of srcval set to dstval, or pixd on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SnapColorCmap (uint srcval,
							  uint dstval,
							  int diff,
							  Pix pixd)
	{
		Pix RetObj = _All.pixSnapColorCmap(pixd, this, srcval, dstval, diff);
		return RetObj;
	}

	// coloring.c (681, 1)
	// pixLinearMapToTargetColor(pixd, pixs, srcval, dstval) as Pix
	// pixLinearMapToTargetColor(PIX *, PIX *, l_uint32, l_uint32) as PIX *
	///  <summary>
	/// (1) For each component (r, b, g) separately, this does a piecewise
	/// linear mapping of the colors in pixs to colors in pixd.
	/// If rs and rd are the red src and dest components in %srcval and
	/// %dstval, then the range [0 ... rs] in pixs is mapped to
	/// [0 ... rd] in pixd.  Likewise, the range [rs ... 255] in pixs
	/// is mapped to [rd ... 255] in pixd.  And similarly for green
	/// and blue.<para/>
	///
	/// (2) The mapping will in general change the hue of the pixels.
	/// However, if the src and dst targets are related by
	/// a transformation given by pixelFractionalShift(), the hue
	/// is invariant.<para/>
	///
	/// (3) For inplace operation, call it this way:
	/// pixLinearMapToTargetColor(pixs, pixs, ... )<para/>
	///
	/// (4) For generating a new pixd:
	/// pixd = pixLinearMapToTargetColor(NULL, pixs, ...)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixLinearMapToTargetColor/*"/>
	///  <param name="pixd">[in][optional] - either NULL or equal to pixs for in-place</param>
	///  <param name="srcval">[in] - source color: 0xrrggbb00</param>
	///  <param name="dstval">[in] - target color: 0xrrggbb00</param>
	///   <returns>pixd with all pixels mapped based on the srcval/destval mapping, or pixd on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix LinearMapToTargetColor (uint srcval,
									   uint dstval,
									   Pix pixd)
	{
		Pix RetObj = _All.pixLinearMapToTargetColor(pixd, this, srcval, dstval);
		return RetObj;
	}

	// coloring.c (863, 1)
	// pixShiftByComponent(pixd, pixs, srcval, dstval) as Pix
	// pixShiftByComponent(PIX *, PIX *, l_uint32, l_uint32) as PIX *
	///  <summary>
	/// (1) For each component (r, b, g) separately, this does a linear
	/// mapping of the colors in pixs to colors in pixd.
	/// Let rs and rd be the red src and dest components in %srcval and
	/// %dstval, and rval is the red component of the src pixel.
	/// Then for all pixels in pixs, the mapping for the red
	/// component from pixs to pixd is:
	/// if (rd smaller or equal rs) (shift toward black)
	/// rval to (rd/rs)  rval
	/// if (rd  is greater  rs)  (shift toward white)
	/// (255 - rval) to ((255 - rs)/(255 - rd))  (255 - rval)
	/// Thus if rd smaller or equal rs, the red component of all pixels is
	/// mapped by the same fraction toward white, and if rd  is greater  rs,
	/// they are mapped by the same fraction toward black.
	/// This is essentially a different linear TRC (gamma = 1)
	/// for each component.  The source and target color inputs are
	/// just used to generate the three fractions.<para/>
	///
	/// (2) Note that this mapping differs from that in
	/// pixLinearMapToTargetColor(), which maps rs to rd and does
	/// a piecewise stretching in between.<para/>
	///
	/// (3) For inplace operation, call it this way:
	/// pixFractionalShiftByComponent(pixs, pixs, ... )<para/>
	///
	/// (4) For generating a new pixd:
	/// pixd = pixLinearMapToTargetColor(NULL, pixs, ...)<para/>
	///
	/// (5) A simple application is to color a grayscale image.
	/// A light background can be colored using srcval = 0xffffff00
	/// and picking a target background color for dstval.
	/// A dark foreground can be colored by using srcval = 0x0
	/// and choosing a target foreground color for dstval.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixShiftByComponent/*"/>
	///  <param name="pixd">[in][optional] - either NULL or equal to pixs for in-place</param>
	///  <param name="srcval">[in] - source color: 0xrrggbb00</param>
	///  <param name="dstval">[in] - target color: 0xrrggbb00</param>
	///   <returns>pixd with all pixels mapped based on the srcval/destval mapping, or pixd on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ShiftByComponent (uint srcval,
								 uint dstval,
								 Pix pixd)
	{
		Pix RetObj = _All.pixShiftByComponent(pixd, this, srcval, dstval);
		return RetObj;
	}

	// colormorph.c (66, 1)
	// pixColorMorph(pixs, type, hsize, vsize) as Pix
	// pixColorMorph(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This does the morph operation on each component separately,
	/// and recombines the result.<para/>
	///
	/// (2) Sel is a brick with all elements being hits.<para/>
	///
	/// (3) If hsize = vsize = 1, just returns a copy.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorMorph/*"/>
	///  <param name="type">[in] - L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, or L_MORPH_CLOSE</param>
	///  <param name="hsize">[in] - of Sel must be odd origin implicitly in center</param>
	///  <param name="vsize">[in] - ditto</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ColorMorph (int type,
						   int hsize,
						   int vsize)
	{
		Pix RetObj = _All.pixColorMorph(this, type, hsize, vsize);
		return RetObj;
	}

	// colorquant1.c (535, 1)
	// pixOctreeColorQuant(pixs, colors, ditherflag) as Pix
	// pixOctreeColorQuant(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// I found one description in the literature of octree color
	/// quantization, using progressive truncation of the octree,
	/// by M. Gervautz and W. Purgathofer in Graphics Gems, pp.
	/// 287-293, ed. A. Glassner, Academic Press, 1990.
	/// Rather than setting up a fixed partitioning of the color
	/// space ab initio, as we do here, they allow the octree to be
	/// progressively truncated as new pixels are added.  They
	/// need to set up some data structures that are traversed
	/// with the addition of each 24 bit pixel, in order to decide
	/// either 1) in which cluster (sub-branch of the octree to put
	/// the pixel, or 2 whether to truncate the octree further
	/// to place the pixel in an existing cluster, or 3 which
	/// two existing clusters should be merged so that the pixel
	/// can be left to start a truncated leaf of the octree.  Such dynamic
	/// truncation is considerably more complicated, and Gervautz et
	/// al. did not explain how they did it in anywhere near the
	/// detail required to check their implementation.
	/// The simple method in pixFixedOctcubeQuant256 is very
	/// fast, and with dithering the results are good, but you
	/// can do better if the color clusters are selected adaptively
	/// from the image.  We want a method that makes much better
	/// use of color samples in regions of color space with high
	/// pixel density, while also fairly representing small numbers
	/// of color pixels in low density regions.  Such adaptation
	/// requires two passes through the image: the first for generating
	/// the pruned tree of color cubes and the second for computing the index
	/// into the color table for each pixel.
	/// A relatively simple adaptive method is pixOctreeQuantByPopulation.
	/// That function first determines if the image has very few colors,
	/// and, if so, quantizes to those colors.  If there are more than
	/// 256 colors, it generates a histogram of octcube leaf occupancy
	/// at level 4, chooses the 192 most populated such leaves as
	/// the first 192 colors, and sets the remaining 64 colors to the
	/// residual average pixel values in each of the 64 level 2 octcubes.
	/// This is a bit faster than pixOctreeColorQuant, and does very
	/// well without dithering, but for most images with dithering it
	/// is clearly inferior.
	/// We now describe pixOctreeColorQuant.  The first pass is done
	/// on a subsampled image, because we do not need to use all the
	/// pixels in the image to generate the tree.  Subsampling
	/// down to 0.25 1/16 of the pixels makes the program run
	/// about 1.3 times faster.
	/// Instead of dividing the color space into 256 equal-sized
	/// regions, we initially divide it into 2^12 or 2^15 or 2^18
	/// equal-sized octcubes.  Suppose we choose to use 2^18 octcubes.
	/// This gives us 6 octree levels.  We then prune back,
	/// starting from level 6.  For every cube at level 6, there
	/// are 8 cubes at level 5.  Call the operation of putting a
	/// cube aside as a color table entry CTE a "saving."
	/// We use a in general level-dependent threshold, and save
	/// those level 6 cubes that are above threshold.
	/// The rest are combined into the containing level 5 cube.
	/// If between 1 and 7 level 6 cubes within a level 5
	/// cube have been saved by thresholding, then the remaining
	/// level 6 cubes in that level 5 cube are automatically
	/// saved as well, without applying a threshold.  This greatly
	/// simplifies both the description of the CTEs and the later
	/// classification of each pixel as belonging to a CTE.
	/// This procedure is iterated through every cube, starting at
	/// level 5, and then 4, 3, and 2, successively.  The result is that
	/// each CTE contains the entirety of a set of from 1 to 7 cubes
	/// from a given level that all belong to a single cube at the
	/// level above. We classify the CTEs in terms of the
	/// condition in which they are made as either being "threshold"
	/// or "residual."  They are "threshold" CTEs if no subcubes
	/// are CTEs that is, they contain every pixel within the cube
	/// and the number of pixels exceeds the threshold for making
	/// a CTE.  They are "residual" CTEs if at least one but not more
	/// than 7 of the subcubes have already been determined to be CTEs
	/// this happens automatically -- no threshold is applied.
	/// If all 8 subcubes are determined to be CTEs, the cube is
	/// marked as having all pixels accounted for 'bleaf' = 1 but
	/// is not saved as a CTE.
	/// We stop the pruning at level 2, at which there are 64
	/// sub-cubes.  Any pixels not already claimed in a CTE are
	/// put in these cubes.
	/// As the cubes are saved as color samples in the color table,
	/// the number of remaining pixels P and the number of
	/// remaining colors in the color table N are recomputed,
	/// along with the average number of pixels P/N ppc to go in
	/// each of the remaining colors.  This running average number is
	/// used to set the threshold at the current level.
	/// Because we are going to very small cubes at levels 6 or 5,
	/// and will dither the colors for errors, it is not necessary
	/// to compute the color center of each cluster we can simply
	/// use the center of the cube.  This gives us a minimax error
	/// condition: the maximum error is half the width of the
	/// level 2 cubes -- 32 color values out of 256 -- for each color
	/// sample.  In practice, most of the pixels will be very much
	/// closer to the center of their cells.  And with dithering,
	/// the average pixel color in a small region will be closer still.
	/// Thus with the octree quantizer, we are able to capture
	/// regions of high color pdf probability density function in small
	/// but accurate CTEs, and to have only a small number of pixels
	/// that end up a significant distance with a guaranteed maximum
	/// from their true color.
	/// How should the threshold factor vary?  Threshold factors
	/// are required for levels 2, 3, 4 and 5 in the pruning stage.
	/// The threshold for level 5 is actually applied to cubes at
	/// level 6, etc.  From various experiments, it appears that
	/// the results do not vary appreciably for threshold values near 1.0.
	/// If you want more colors in smaller cubes, the threshold
	/// factors can be set lower than 1.0 for cubes at levels 4 and 5.
	/// However, if the factor is set much lower than 1.0 for
	/// levels 2 and 3, we can easily run out of colors.
	/// We put aside 64 colors in the calculation of the threshold
	/// values, because we must have 64 color centers at level 2,
	/// that will have very few pixels in most of them.
	/// If we reduce the factor for level 5 to 0.4, this will
	/// generate many level 6 CTEs, and consequently
	/// many residual cells will be formed up from those leaves,
	/// resulting in the possibility of running out of colors.
	/// Remember, the residual CTEs are mandatory, and are formed
	/// without using the threshold, regardless of the number of
	/// pixels that are absorbed.
	/// The implementation logically has four parts:
	/// 1 accumulation into small, fixed cells
	/// 2 pruning back into selected CTE cubes
	/// 3 organizing the CTEs for fast search to find
	/// the CTE to which any image pixel belongs
	/// 4 doing a second scan to code the image pixels by CTE
	/// Step 1 is straightforward we use 2^15 cells.
	/// We've already discussed how the pruning step 2 will be performed.
	/// Steps 3) and (4 are related, in that the organization
	/// used by step 3 determines how the search actually
	/// takes place for each pixel in step 4.
	/// There are many ways to do step 3.  Let's explore a few.
	/// a The simplest is to order the cubes from highest occupancy
	/// to lowest, and traverse the list looking for the deepest
	/// match.  To make this more efficient, so that we know when
	/// to stop looking, any cube that has separate CTE subcubes
	/// would be marked as such, so that we know when we hit a
	/// true leaf.
	/// b Alternatively, we can order the cubes by highest
	/// occupancy separately each level, and work upward,
	/// starting at level 5, so that when we find a match we
	/// know that it will be correct.
	/// c Another approach would be to order the cubes by
	/// "address" and use a hash table to find the cube
	/// corresponding to a pixel color.  I don't know how to
	/// do this with a variable length address, as each CTE
	/// will have 3n bits, where n is the level.
	/// d Another approach entirely is to put the CTE cubes into
	/// a tree, in such a way that starting from the root, and
	/// using 3 bits of address at a time, the correct branch of
	/// each octree can be taken until a leaf is found.  Because
	/// a given cube can be both a leaf and also have branches
	/// going to sub-cubes, the search stops only when no
	/// marked subcubes have addresses that match the given pixel.
	/// In the tree method, we can start with a dense infrastructure,
	/// and place the leaves corresponding to the N colors
	/// in the tree, or we can grow from the root only those
	/// branches that end directly on leaves.
	/// What we do here is to take approach d, and implement the tree
	/// "virtually", as a set of arrays, one array for each level
	/// of the tree. Initially we start at level 5, an array with
	/// 2^15 cubes, each with 8 subcubes.  We then build nodes at
	/// levels closer to the root at level 4 there are 2^12 nodes
	/// each with 8 subcubes etc.  Using these arrays has
	/// several advantages:
	/// ~  We don't need to keep track of links between cubes
	/// and subcubes, because we can use the canonical
	/// addressing on the cell arrays directly to determine
	/// which nodes are parent cubes and which are sub-cubes.
	/// ~  We can prune directly on this tree
	/// ~  We can navigate the pruned tree quickly to classify
	/// each pixel in the image.
	/// Canonical addressing guarantees that the i-th node at level k
	/// has 8 subnodes given by the 8i ... 8i+7 nodes at level k+1.
	/// The pruning step works as follows.  We go from the lowest
	/// level up.  At each level, the threshold is found from the
	/// product of a factor near 1.0 and the ratio of unmarked pixels
	/// to remaining colors minus the 64.  We march through
	/// the space, sequentially considering a cube and its 8 subcubes.
	/// We first check those subcubes that are not already
	/// marked as CTE to see if any are above threshold, and if so,
	/// generate a CTE and mark them as such.
	/// We then determine if any of the subcubes have been marked.
	/// If so, and there are subcubes that are not marked,
	/// we generate a CTE for the cube from the remaining unmarked
	/// subcubes this is mandatory and does not depend on how many
	/// pixels are in the set of subcubes.  If none of the subcubes
	/// are marked, we aggregate their pixels into the cube
	/// containing them, but do not mark it as a CTE that
	/// will be determined when iterating through the next level up.
	/// When all the pixels in a cube are accounted for in one or more
	/// colors, we set the boolean 'bleaf' to true.  This is the
	/// flag used to mark the cubes in the pruning step.  If a cube
	/// is marked, and all 8 subcubes are marked, then it is not
	/// itself given a CTE because all pixels have already been
	/// accounted for.
	/// Note that the pruning of the tree and labelling of the CTEs
	/// step 2 accomplishes step 3 implicitly, because the marked
	/// and pruned tree is ready for use in labelling each pixel
	/// in step 4.  We now, for every pixel in the image, traverse
	/// the tree from the root, looking for the lowest cube that is a leaf.
	/// At each level we have a cube and subcube.  If we reach a subcube
	/// leaf that is marked 0, we know that the color is stored in the
	/// cube above, and we've found the CTE.  Otherwise, the subcube
	/// leaf is marked 1.  If we're at the last level, we've reached
	/// the final leaf and must use it.  Otherwise, continue the
	/// process at the next level down.
	/// For robustness, efficiency and high quality output, we do the following:<para/>
	///
	/// (1) Measure the color content of the image.  If there is very little
	/// color, quantize in grayscale.<para/>
	///
	/// (2) For efficiency, build the octree with a subsampled image if the
	/// image is larger than some threshold size.<para/>
	///
	/// (3) Reserve an extra set of colors to prevent running out of colors
	/// when pruning the octree specifically, during the assignment
	/// of those level 2 cells out of the 64 that have unassigned
	/// pixels.  The problem of running out is more likely to happen
	/// with small images, because the estimation we use for the
	/// number of pixels available is not accurate.<para/>
	///
	/// (4) In the unlikely event that we run out of colors, the dithered
	/// image can be very poor.  As this would only happen with very
	/// small images, and dithering is not particularly noticeable with
	/// such images, turn it off.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOctreeColorQuant/*"/>
	///  <param name="colors">[in] - in colormap some number in range [128 ... 256] the actual number of colors used will be smaller</param>
	///  <param name="ditherflag">[in] - 1 to dither, 0 otherwise</param>
	///   <returns>pixd 8 bpp with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OctreeColorQuant (int colors,
								 int ditherflag)
	{
		Pix RetObj = _All.pixOctreeColorQuant(this, colors, ditherflag);
		return RetObj;
	}

	// colorquant1.c (601, 1)
	// pixOctreeColorQuantGeneral(pixs, colors, ditherflag, validthresh, colorthresh) as Pix
	// pixOctreeColorQuantGeneral(PIX *, l_int32, l_int32, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) The parameters %validthresh and %colorthresh are used to
	/// determine if color quantization should be used on an image,
	/// or whether, instead, it should be quantized in grayscale.
	/// If the image has very few non-white and non-black pixels, or
	/// if those pixels that are non-white and non-black are all
	/// very close to either white or black, it is usually better
	/// to treat the color as accidental and to quantize the image
	/// to gray only.  These parameters are useful if you know
	/// something a priori about the image.  Perhaps you know that
	/// there is only a very small fraction of color pixels, but they're
	/// important to preserve then you want to use a smaller value for
	/// these parameters.  To disable conversion to gray and force
	/// color quantization, use %validthresh = 0.0 and %colorthresh = 0.0.<para/>
	///
	/// (2) See pixOctreeColorQuant() for algorithmic and implementation
	/// details.  This function has a more general interface.<para/>
	///
	/// (3) See pixColorFraction() for computing the fraction of pixels
	/// that are neither white nor black, and the fraction of those
	/// pixels that have little color.  From the documentation there:
	/// If pixfract is very small, there are few pixels that are
	/// neither black nor white.  If colorfract is very small,
	/// the pixels that are neither black nor white have very
	/// little color content.  The product 'pixfract  colorfract'
	/// gives the fraction of pixels with significant color content.
	/// We test against the product %validthresh  %colorthresh
	/// to find color in images that have either very few
	/// intermediate gray pixels or that have many such gray pixels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOctreeColorQuantGeneral/*"/>
	///  <param name="colors">[in] - in colormap some number in range [128 ... 240] the actual number of colors used will be smaller</param>
	///  <param name="ditherflag">[in] - 1 to dither, 0 otherwise</param>
	///  <param name="validthresh">[in] - minimum fraction of pixels neither near white nor black, required for color quantization typically ~0.01, but smaller for images that have color but are nearly all white</param>
	///  <param name="colorthresh">[in] - minimum fraction of pixels with color that are not near white or black, that are required for color quantization typ. ~0.01, but smaller for images that have color along with a significant fraction of gray</param>
	///   <returns>pixd 8 bit with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OctreeColorQuantGeneral (int colors,
										int ditherflag,
										Single validthresh,
										Single colorthresh)
	{
		Pix RetObj = _All.pixOctreeColorQuantGeneral(this, colors, ditherflag, validthresh, colorthresh);
		return RetObj;
	}

	// colorquant1.c (1701, 1)
	// pixOctreeQuantByPopulation(pixs, level, ditherflag) as Pix
	// pixOctreeQuantByPopulation(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This color quantization method works very well without
	/// dithering, using octcubes at two different levels:
	/// (a) the input %level, which is either 3 or 4
	/// (b) level 2 (64 octcubes to cover the entire color space)<para/>
	///
	/// (2) For best results, using %level = 4 is recommended.
	/// Why do we provide an option for using level 3?  Because
	/// there are 512 octcubes at level 3, and for many images
	/// not more than 256 are filled.  As a result, on some images
	/// a very accurate quantized representation is possible using
	/// %level = 3.<para/>
	///
	/// (3) This first breaks up the color space into octcubes at the
	/// input %level, and computes, for each octcube, the average
	/// value of the pixels that are in it.<para/>
	///
	/// (4) Then there are two possible situations:
	/// (a) If there are not more than 256 populated octcubes,
	/// it returns a cmapped pix with those values assigned.
	/// (b) Otherwise, it selects 192 octcubes containing the largest
	/// number of pixels and quantizes pixels within those octcubes
	/// to their average.  Then, to handle the residual pixels
	/// that are not in those 192 octcubes, it generates a
	/// level 2 octree consisting of 64 octcubes, and within
	/// each octcube it quantizes the residual pixels to their
	/// average within each of those level 2 octcubes.<para/>
	///
	/// (5) Unpopulated level 2 octcubes are represented in the colormap
	/// by their centers.  This, of course, has no effect unless
	/// dithering is used for the output image.<para/>
	///
	/// (6) The depth of pixd is the minimum required to support the
	/// number of colors found at %level namely, 2, 4 or 8.<para/>
	///
	/// (7) This function works particularly well on images such as maps,
	/// where there are a relatively small number of well-populated
	/// colors, but due to antialiasing and compression artifacts
	/// there may be a large number of different colors.  This will
	/// pull out and represent accurately the highly populated colors,
	/// while still making a reasonable approximation for the others.<para/>
	///
	/// (8) The highest level of octcubes allowed is 4.  Use of higher
	/// levels typically results in having a small fraction of
	/// pixels in the most populated 192 octcubes.  As a result,
	/// most of the pixels are represented at level 2, which is
	/// not sufficiently accurate.<para/>
	///
	/// (9) Dithering shows artifacts on some images.  If you plan to
	/// dither, pixOctreeColorQuant() and pixFixedOctcubeQuant256()
	/// usually give better results.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOctreeQuantByPopulation/*"/>
	///  <param name="level">[in] - significant bits for each of RGB valid for {3,4}, Use 0 for default (level 4 recommended</param>
	///  <param name="ditherflag">[in] - 1 to dither, 0 otherwise</param>
	///   <returns>pixd quantized to octcubes or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OctreeQuantByPopulation (int level,
										int ditherflag)
	{
		Pix RetObj = _All.pixOctreeQuantByPopulation(this, level, ditherflag);
		return RetObj;
	}

	// colorquant1.c (2263, 1)
	// pixOctreeQuantNumColors(pixs, maxcolors, subsample) as Pix
	// pixOctreeQuantNumColors(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixOctreeColorQuant is very flexible in terms of the relative
	/// depth of different cubes of the octree. By contrast, this function,
	/// pixOctreeQuantNumColors is also adaptive, but it supports octcube
	/// leaves at only two depths: a smaller depth that guarantees
	/// full coverage of the color space and octcubes at one level
	/// deeper for more accurate colors.  Its main virutes are simplicity
	/// and speed, which are both derived from the natural indexing of
	/// the octcubes from the RGB values.
	/// Before describing pixOctreeQuantNumColors, consider an even simpler
	/// approach for 4 bpp with either 8 or 16 colors.  With 8 colors,
	/// you simply go to level 1 octcubes and use the average color
	/// found in each cube.  For 16 colors, you find which of the three
	/// colors has the largest variance at the second level, and use two
	/// indices for that color.  The result is quite poor, because 1 some
	/// of the cubes are nearly empty and 2 you don't get much color
	/// differentiation for the extra 8 colors.  Trust me, this method may
	/// be simple, but it isn't worth anything.
	/// In pixOctreeQuantNumColors, we generate colormapped images at
	/// either 4 bpp or 8 bpp.  For 4 bpp, we have a minimum of 8 colors
	/// for the level 1 octcubes, plus up to 8 additional colors that
	/// are determined from the level 2 popularity.  If the number of colors
	/// is between 8 and 16, the output is a 4 bpp image.  If the number of
	/// colors is greater than 16, the output is a 8 bpp image.
	/// We use a priority queue, implemented with a heap, to select the
	/// requisite number of most populated octcubes at the deepest level
	/// level 2 for 64 or fewer colors level 3 for more than 64 colors.
	/// These are combined with one color for each octcube one level above,
	/// which is used to span the color space of octcubes that were not
	/// included at the deeper level.
	/// If the deepest level is 2, we combine the popular level 2 octcubes
	/// out of a total of 64 with the 8 level 1 octcubes.  If the deepest
	/// level is 3, we combine the popular level 3 octcubes out of a
	/// total 512 with the 64 level 2 octcubes that span the color space.
	/// In the latter case, we require a minimum of 64 colors for the level 2
	/// octcubes, plus up to 192 additional colors determined from level 3
	/// popularity.
	/// The parameter 'maxlevel' is the deepest octcube level that is used.
	/// The implementation also uses two LUTs, which are employed in
	/// two successive traversals of the dest image.  The first maps
	/// from the src octindex at 'maxlevel' to the color table index,
	/// which is the value that is stored in the 4 or 8 bpp dest pixel.
	/// The second LUT maps from that colormap value in the dest to a
	/// new colormap value for a minimum sized colormap, stored back in
	/// the dest.  It is used to remove any color map entries that
	/// correspond to color space regions that have no pixels in the
	/// source image.  These regions can be either from the higher level
	/// e.g., level 1 for 4 bpp, or from octcubes at 'maxlevel' that
	/// are unoccupied.  This remapping results in the minimum number
	/// of colors used according to the constraints induced by the
	/// input 'maxcolors'.  We also compute the average R, G and B color
	/// values in each region of the color space represented by a
	/// colormap entry, and store them in the colormap.
	/// The maximum number of colors is input, which determines the
	/// following properties of the dest image and octcube regions used:
	/// Number of colors  dest image depth  maxlevel
	/// ----------------  ----------------  --------
	/// 8 to 16  4 bpp   2
	/// 17 to 64   8 bpp   2
	/// 65 to 256  8 bpp   3
	/// It may turn out that the number of extra colors, beyond the
	/// minimum 8 and 64 for maxlevel 2 and 3, respectively, is larger
	/// than the actual number of occupied cubes at these levels
	/// In that case, all the pixels are contained in this
	/// subset of cubes at maxlevel, and no colormap colors are needed
	/// to represent the remainder pixels one level above.  Thus, for
	/// example, in use one often finds that the pixels in an image
	/// occupy less than 192 octcubes at level 3, so they can be represented
	/// by a colormap for octcubes at level 3 only.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOctreeQuantNumColors/*"/>
	///  <param name="maxcolors">[in] - 8 to 256 the actual number of colors used may be less than this</param>
	///  <param name="subsample">[in] - factor for computing color distribution use 0 for default</param>
	///   <returns>pixd 4 or 8 bpp, colormapped, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OctreeQuantNumColors (int maxcolors,
									 int subsample)
	{
		Pix RetObj = _All.pixOctreeQuantNumColors(this, maxcolors, subsample);
		return RetObj;
	}

	// colorquant1.c (2587, 1)
	// pixOctcubeQuantMixedWithGray(pixs, depth, graylevels, delta) as Pix
	// pixOctcubeQuantMixedWithGray(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Generates a colormapped image, where the colormap table values
	/// have two components: octcube values representing pixels with
	/// color content, and grayscale values for the rest.<para/>
	///
	/// (2) The threshold (delta) is the maximum allowable difference of
	/// the max abs value of | r - g |, | r - b | and | g - b |.<para/>
	///
	/// (3) The octcube values are the averages of all pixels that are
	/// found in the octcube, and that are far enough from gray to
	/// be considered color.  This can roughly be visualized as all
	/// the points in the rgb color cube that are not within a "cylinder"
	/// of diameter approximately 'delta' along the main diagonal.<para/>
	///
	/// (4) We want to guarantee full coverage of the rgb color space thus,
	/// if the output depth is 4, the octlevel is 1 (2 x 2 x 2 = 8 cubes)
	/// and if the output depth is 8, the octlevel is 2 (4 x 4 x 4
	/// = 64 cubes).<para/>
	///
	/// (5) Consequently, we have the following constraint on the number
	/// of allowed gray levels: for 4 bpp, 8 for 8 bpp, 192.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOctcubeQuantMixedWithGray/*"/>
	///  <param name="depth">[in] - of output pix</param>
	///  <param name="graylevels">[in] - graylevels (must be  is greater  1)</param>
	///  <param name="delta">[in] - threshold for deciding if a pix is color or gray</param>
	///   <returns>pixd     quantized to octcube and gray levels or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OctcubeQuantMixedWithGray (int depth,
										  int graylevels,
										  int delta)
	{
		Pix RetObj = _All.pixOctcubeQuantMixedWithGray(this, depth, graylevels, delta);
		return RetObj;
	}

	// colorquant1.c (2806, 1)
	// pixFixedOctcubeQuant256(pixs, ditherflag) as Pix
	// pixFixedOctcubeQuant256(PIX *, l_int32) as PIX *
	///  <summary>
	/// This simple 1-pass color quantization works by breaking the
	/// color space into 256 pieces, with 3 bits quantized for each of
	/// red and green, and 2 bits quantized for blue.  We shortchange
	/// blue because the eye is least sensitive to blue.  This
	/// division of the color space is into two levels of octrees,
	/// followed by a further division by 4 not 8, where both
	/// blue octrees have been combined in the third level.
	/// The color map is generated from the 256 color centers by
	/// taking the representative color to be the center of the
	/// cell volume.  This gives a maximum error in the red and
	/// green values of 16 levels, and a maximum error in the
	/// blue sample of 32 levels.
	/// Each pixel in the 24-bit color image is placed in its containing
	/// cell, given by the relevant MSbits of the red, green and blue
	/// samples.  An error-diffusion dithering is performed on each
	/// color sample to give the appearance of good average local color.
	/// Dithering is required without it, the contouring and visible
	/// color errors are very bad.
	/// I originally implemented this algorithm in two passes,
	/// where the first pass was used to compute the weighted average
	/// of each sample in each pre-allocated region of color space.
	/// The idea was to use these centroids in the dithering algorithm
	/// of the second pass, to reduce the average error that was
	/// being dithered.  However, with dithering, there is
	/// virtually no difference, so there is no reason to make the
	/// first pass.  Consequently, this 1-pass version just assigns
	/// the pixels to the centers of the pre-allocated cells.
	/// We use dithering to spread the difference between the sample
	/// value and the location of the center of the cell.  For speed
	/// and simplicity, we use integer dithering and propagate only
	/// to the right, down, and diagonally down-right, with ratios
	/// 3/8, 3/8 and 1/4, respectively.  The results should be nearly
	/// as good, and a bit faster, with propagation only to the right
	/// and down.
	/// The algorithm is very fast, because there is no search,
	/// only fast generation of the cell index for each pixel.
	/// We use a simple mapping from the three 8 bit rgb samples
	/// to the 8 bit cell index namely, r7 r6 r5 g7 g6 g5 b7 b6.
	/// This is not in an octcube format, but it doesn't matter.
	/// There are no storage requirements.  We could keep a
	/// running average of the center of each sample in each
	/// cluster, rather than using the center of the cell, but
	/// this is just extra work, esp. with dithering.
	/// This method gives surprisingly good results with dithering.
	/// However, without dithering, the loss of color accuracy is
	/// evident in regions that are very light or that have subtle
	/// blending of colors.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFixedOctcubeQuant256/*"/>
	///  <param name="ditherflag">[in] - 1 for dithering 0 for no dithering</param>
	///   <returns>pixd 8 bit with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FixedOctcubeQuant256 (int ditherflag)
	{
		Pix RetObj = _All.pixFixedOctcubeQuant256(this, ditherflag);
		return RetObj;
	}

	// colorquant1.c (2940, 1)
	// pixFewColorsOctcubeQuant1(pixs, level) as Pix
	// pixFewColorsOctcubeQuant1(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Generates a colormapped image, where the colormap table values
	/// are the averages of all pixels that are found in the octcube.<para/>
	///
	/// (2) This fails if there are more than 256 colors (i.e., more
	/// than 256 occupied octcubes).<para/>
	///
	/// (3) Often level 3 (512 octcubes) will succeed because not more
	/// than half of them are occupied with 1 or more pixels.<para/>
	///
	/// (4) The depth of the result, which is either 2, 4 or 8 bpp,
	/// is the minimum required to hold the number of colors that
	/// are found.<para/>
	///
	/// (5) This can be useful for quantizing orthographically generated
	/// images such as color maps, where there may be more than 256 colors
	/// because of aliasing or jpeg artifacts on text or lines, but
	/// there are a relatively small number of solid colors.  Then,
	/// use with level = 3 can often generate a compact and accurate
	/// representation of the original RGB image.  For this purpose,
	/// it is better than pixFewColorsOctcubeQuant2(), because it
	/// uses the average value of pixels in the octcube rather
	/// than the first found pixel.  It is also simpler to use,
	/// because it generates the histogram internally.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFewColorsOctcubeQuant1/*"/>
	///  <param name="level">[in] - significant bits for each of RGB valid in [1...6]</param>
	///   <returns>pixd quantized to octcube or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FewColorsOctcubeQuant1 (int level)
	{
		Pix RetObj = _All.pixFewColorsOctcubeQuant1(this, level);
		return RetObj;
	}

	// colorquant1.c (3110, 1)
	// pixFewColorsOctcubeQuant2(pixs, level, na, ncolors, pnerrors) as Pix
	// pixFewColorsOctcubeQuant2(PIX *, l_int32, NUMA *, l_int32, l_int32 *) as PIX *
	///  <summary>
	/// (1) Generates a colormapped image, where the colormap table values
	/// are the averages of all pixels that are found in the octcube.<para/>
	///
	/// (2) This fails if there are more than 256 colors (i.e., more
	/// than 256 occupied octcubes).<para/>
	///
	/// (3) Often level 3 (512 octcubes) will succeed because not more
	/// than half of them are occupied with 1 or more pixels.<para/>
	///
	/// (4) For an image with not more than 256 colors, it is unlikely
	/// that two pixels of different color will fall in the same
	/// octcube at level = 4. However it is possible, and this
	/// function optionally returns %nerrors, the number of pixels
	/// where, because more than one color is in the same octcube,
	/// the pixel color is not exactly reproduced in the colormap.
	/// The colormap for an occupied leaf of the octree contains
	/// the color of the first pixel encountered in that octcube.<para/>
	///
	/// (5) This differs from pixFewColorsOctcubeQuant1(), which also
	/// requires not more than 256 occupied leaves, but represents
	/// the color of each leaf by an average over the pixels in
	/// that leaf.  This also requires precomputing the histogram
	/// of occupied octree leaves, which is generated using
	/// pixOctcubeHistogram().<para/>
	///
	/// (6) This is used in pixConvertRGBToColormap() for images that
	/// are determined, by their histogram, to have relatively few
	/// colors.  This typically happens with orthographically
	/// produced images (as oppopsed to natural images), where
	/// it is expected that most of the pixels within a leaf
	/// octcube have exactly the same color, and quantization to
	/// that color is lossless.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFewColorsOctcubeQuant2/*"/>
	///  <param name="level">[in] - of octcube indexing, for histogram: 3, 4, 5, 6</param>
	///  <param name="na">[in] - histogram of pixel occupation in octree leaves at given level</param>
	///  <param name="ncolors">[in] - number of occupied octree leaves at given level</param>
	///  <param name="pnerrors">[out][optional] - num of pixels not exactly represented in the colormap</param>
	///   <returns>pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FewColorsOctcubeQuant2 (int level,
									   Numa na,
									   int ncolors,
									   out int pnerrors)
	{
		Pix RetObj = _All.pixFewColorsOctcubeQuant2(this, level, na, ncolors, out pnerrors);
		return RetObj;
	}

	// colorquant1.c (3299, 1)
	// pixFewColorsOctcubeQuantMixed(pixs, level, darkthresh, lightthresh, diffthresh, minfract, maxspan) as Pix
	// pixFewColorsOctcubeQuantMixed(PIX *, l_int32, l_int32, l_int32, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) First runs pixFewColorsOctcubeQuant1().  If this succeeds,
	/// it separates the color from gray(ish) entries in the cmap,
	/// and re-quantizes the gray pixels.  The result has some pixels
	/// in color and others in gray.<para/>
	///
	/// (2) This fails if there are more than 256 colors (i.e., more
	/// than 256 occupied octcubes in the color quantization).<para/>
	///
	/// (3) Level 3 (512 octcubes) will usually succeed because not more
	/// than half of them are occupied with 1 or more pixels.<para/>
	///
	/// (4) This uses the criterion from pixColorFraction() for deciding
	/// if a colormap entry is color namely, if the color components
	/// are not too close to either black or white, and the maximum
	/// difference between component values equals or exceeds a threshold.<para/>
	///
	/// (5) For quantizing the gray pixels, it uses a histogram-based
	/// method where input parameters determining the buckets are
	/// the minimum population fraction and the maximum allowed size.<para/>
	///
	/// (6) Recommended input parameters are:
	/// %level:  3 or 4  (3 is default)
	/// %darkthresh:  20
	/// %lightthresh: 244
	/// %diffthresh: 20
	/// %minfract: 0.05
	/// %maxspan: 15
	/// These numbers are intended to be conservative (somewhat over-
	/// sensitive) in color detection,  It's usually better to pay
	/// extra with octcube quantization of a grayscale image than
	/// to use grayscale quantization on an image that has some
	/// actual color.  Input 0 on any of these to get the default.<para/>
	///
	/// (7) This can be useful for quantizing orthographically generated
	/// images such as color maps, where there may be more than 256 colors
	/// because of aliasing or jpeg artifacts on text or lines, but
	/// there are a relatively small number of solid colors.  It usually
	/// gives results that are better than pixOctcubeQuantMixedWithGray(),
	/// both in size and appearance.  But it is a bit slower.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFewColorsOctcubeQuantMixed/*"/>
	///  <param name="level">[in] - significant octcube bits for each of RGB valid in [1...6] use 0 for default</param>
	///  <param name="darkthresh">[in] - threshold near black if the lightest component is below this, the pixel is not considered to be gray or color uses 0 for default</param>
	///  <param name="lightthresh">[in] - threshold near white if the darkest component is above this, the pixel is not considered to be gray or color use 0 for default</param>
	///  <param name="diffthresh">[in] - thresh for the max difference between component values for differences below this, the pixel is considered to be gray use 0 for default</param>
	///  <param name="minfract">[in] - min fraction of pixels for gray histo bin use 0.0 for default</param>
	///  <param name="maxspan">[in] - max size of gray histo bin use 0 for default</param>
	///   <returns>pixd 8 bpp, quantized to octcube for pixels that are not gray gray pixels are quantized separately over the full gray range, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FewColorsOctcubeQuantMixed (int level,
										   int darkthresh,
										   int lightthresh,
										   int diffthresh,
										   int maxspan,
										   Single minfract)
	{
		Pix RetObj = _All.pixFewColorsOctcubeQuantMixed(this, level, darkthresh, lightthresh, diffthresh, minfract, maxspan);
		return RetObj;
	}

	// colorquant1.c (3417, 1)
	// pixFixedOctcubeQuantGenRGB(pixs, level) as Pix
	// pixFixedOctcubeQuantGenRGB(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Unlike the other color quantization functions, this one
	/// generates an rgb image.<para/>
	///
	/// (2) The pixel values are quantized to the center of each octcube
	/// (at the specified level) containing the pixel.  They are
	/// not quantized to the average of the pixels in that octcube.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFixedOctcubeQuantGenRGB/*"/>
	///  <param name="level">[in] - significant bits for each of r,g,b</param>
	///   <returns>pixd rgb quantized to octcube centers, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FixedOctcubeQuantGenRGB (int level)
	{
		Pix RetObj = _All.pixFixedOctcubeQuantGenRGB(this, level);
		return RetObj;
	}

	// colorquant1.c (3490, 1)
	// pixQuantFromCmap(pixs, cmap, mindepth, level, metric) as Pix
	// pixQuantFromCmap(PIX *, PIXCMAP *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This is a top-level wrapper for quantizing either grayscale
	/// or rgb images to a specified colormap.<para/>
	///
	/// (2) The actual output depth is constrained by %mindepth and
	/// by the number of colors in %cmap.<para/>
	///
	/// (3) For grayscale, %level and %metric are ignored.<para/>
	///
	/// (4) If the cmap has color and pixs is grayscale, the color is
	/// removed from the cmap before quantizing pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixQuantFromCmap/*"/>
	///  <param name="cmap">[in] - to quantize to insert copy into dest pix</param>
	///  <param name="mindepth">[in] - minimum depth of pixd: can be 2, 4 or 8 bpp</param>
	///  <param name="level">[in] - of octcube used for finding nearest color in cmap</param>
	///  <param name="metric">[in] - L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
	///   <returns>pixd  2, 4 or 8 bpp, colormapped, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix QuantFromCmap (PixColormap cmap,
							  int mindepth,
							  int level,
							  int metric)
	{
		Pix RetObj = _All.pixQuantFromCmap(this, cmap, mindepth, level, metric);
		return RetObj;
	}

	// colorquant1.c (3579, 1)
	// pixOctcubeQuantFromCmap(pixs, cmap, mindepth, level, metric) as Pix
	// pixOctcubeQuantFromCmap(PIX *, PIXCMAP *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) In typical use, we are doing an operation, such as
	/// interpolative scaling, on a colormapped pix, where it is
	/// necessary to remove the colormap before the operation.
	/// We then want to re-quantize the RGB result using the same
	/// colormap.<para/>
	///
	/// (2) The level is used to divide the color space into octcubes.
	/// Each input pixel is, in effect, placed at the center of an
	/// octcube at the given level, and it is mapped into the
	/// exact color (given in the colormap) that is the closest
	/// to that location.  We need to know that distance, for each color
	/// in the colormap.  The higher the level of the octtree, the smaller
	/// the octcubes in the color space, and hence the more accurately
	/// we can determine the closest color in the colormap however,
	/// the size of the LUT, which is the total number of octcubes,
	/// increases by a factor of 8 for each increase of 1 level.
	/// The time required to acquire a level 4 mapping table, which has
	/// about 4K entries, is less than 1 msec, so that is the
	/// recommended minimum size to be used.  At that size, the
	/// octcubes have their centers 16 units apart in each (r,g,b)
	/// direction.  If two colors are in the same octcube, the one
	/// closest to the center will always be chosen.  The maximum
	/// error for any component occurs when the correct color is
	/// at a cube corner and there is an incorrect color just inside
	/// the cube next to the opposite corner, giving an error of
	/// 14 units (out of 256) for each component. Using a level 5
	/// mapping table reduces the maximum error to 6 units.<para/>
	///
	/// (3) Typically you should use the Euclidean metric, because the
	/// resulting voronoi cells (which are generated using the actual
	/// colormap values as seeds) are convex for Euclidean distance
	/// but not for Manhattan distance.  In terms of the octcubes,
	/// convexity of the voronoi cells means that if the 8 corners
	/// of any cube (of which the octcubes are special cases)
	/// are all within a cell, then every point in the cube will
	/// lie within the cell.<para/>
	///
	/// (4) The depth of the output pixd is equal to the maximum of
	/// (a) %mindepth and (b) the minimum (2, 4 or 8 bpp) necessary
	/// to hold the indices in the colormap.<para/>
	///
	/// (5) We build a mapping table from octcube to colormap index so
	/// that this function can run in a time (otherwise) independent
	/// of the number of colors in the colormap.  This avoids a
	/// brute-force search for the closest colormap color to each
	/// pixel in the image.<para/>
	///
	/// (6) This is similar to the function pixAssignToNearestColor()
	/// used for color segmentation.<para/>
	///
	/// (7) Except for very small images or when using level  is greater  4,
	/// it takes very little time to generate the tables,
	/// compared to the generation of the colormapped dest pix,
	/// so one would not typically use the low-level version.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOctcubeQuantFromCmap/*"/>
	///  <param name="cmap">[in] - to quantize to insert copy into dest pix</param>
	///  <param name="mindepth">[in] - minimum depth of pixd: can be 2, 4 or 8 bpp</param>
	///  <param name="level">[in] - of octcube used for finding nearest color in cmap</param>
	///  <param name="metric">[in] - L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
	///   <returns>pixd  2, 4 or 8 bpp, colormapped, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OctcubeQuantFromCmap (PixColormap cmap,
									 int mindepth,
									 int level,
									 int metric)
	{
		Pix RetObj = _All.pixOctcubeQuantFromCmap(this, cmap, mindepth, level, metric);
		return RetObj;
	}

	// colorquant1.c (3729, 1)
	// pixOctcubeHistogram(pixs, level, pncolors) as Numa
	// pixOctcubeHistogram(PIX *, l_int32, l_int32 *) as NUMA *
	///  <summary>
	/// (1) Input NULL for [and]ncolors to prevent computation and return value.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOctcubeHistogram/*"/>
	///  <param name="level">[in] - significant bits for each of RGB valid in [1...6]</param>
	///  <param name="pncolors">[out][optional] - number of occupied cubes</param>
	///   <returns>numa histogram of color pixels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa OctcubeHistogram (int level,
								  out int pncolors)
	{
		Numa RetObj = _All.pixOctcubeHistogram(this, level, out pncolors);
		return RetObj;
	}

	// colorquant1.c (3938, 1)
	// pixRemoveUnusedColors(pixs) as int
	// pixRemoveUnusedColors(PIX *) as l_ok
	///  <summary>
	/// (1) This is an in-place operation.<para/>
	///
	/// (2) If the image doesn't have a colormap, returns without error.<para/>
	///
	/// (3) Unusued colors are removed from the colormap, and the
	/// image pixels are re-numbered.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRemoveUnusedColors/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RemoveUnusedColors ()
	{
		int RetObj = _All.pixRemoveUnusedColors(this);
		return RetObj;
	}

	// colorquant1.c (4084, 1)
	// pixNumberOccupiedOctcubes(pix, level, mincount, minfract, pncolors) as int
	// pixNumberOccupiedOctcubes(PIX *, l_int32, l_int32, l_float32, l_int32 *) as l_ok
	///  <summary>
	/// (1) Exactly one of (%mincount, %minfract) must be -1, so, e.g.,
	/// if %mincount == -1, then we use %minfract.<para/>
	///
	/// (2) If all occupied octcubes are to count, set %mincount == 1.
	/// Setting %minfract == 0.0 is taken to mean the same thing.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixNumberOccupiedOctcubes/*"/>
	///  <param name="pix">[in] - 32 bpp</param>
	///  <param name="level">[in] - of octcube</param>
	///  <param name="mincount">[in] - minimum num pixels in an octcube to be counted -1 to not use</param>
	///  <param name="minfract">[in] - minimum fract of pixels in an octcube to be counted -1 to not use</param>
	///  <param name="pncolors">[out] - number of occupied octcubes</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int NumberOccupiedOctcubes (Pix pix,
									   int level,
									   int mincount,
									   Single minfract,
									   out int pncolors)
	{
		int RetObj = _All.pixNumberOccupiedOctcubes(pix, level, mincount, minfract, out pncolors);
		return RetObj;
	}

	// colorquant2.c (257, 1)
	// pixMedianCutQuant(pixs, ditherflag) as Pix
	// pixMedianCutQuant(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Simple interface.  See pixMedianCutQuantGeneral() for
	/// use of defaulted parameters.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMedianCutQuant/*"/>
	///  <param name="ditherflag">[in] - 1 for dither 0 for no dither</param>
	///   <returns>pixd 8 bit with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MedianCutQuant (int ditherflag)
	{
		Pix RetObj = _All.pixMedianCutQuant(this, ditherflag);
		return RetObj;
	}

	// colorquant2.c (308, 1)
	// pixMedianCutQuantGeneral(pixs, ditherflag, outdepth, maxcolors, sigbits, maxsub, checkbw) as Pix
	// pixMedianCutQuantGeneral(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) %maxcolors must be in the range [2 ... 256].<para/>
	///
	/// (2) Use %outdepth = 0 to have the output depth computed as the
	/// minimum required to hold the actual colors found, given
	/// the %maxcolors constraint.<para/>
	///
	/// (3) Use %outdepth = 1, 2, 4 or 8 to specify the output depth.
	/// In that case, %maxcolors must not exceed 2^(outdepth).<para/>
	///
	/// (4) If there are fewer quantized colors in the image than %maxcolors,
	/// the colormap is simply generated from those colors.<para/>
	///
	/// (5) %maxsub is the maximum allowed subsampling to be used in the
	/// computation of the color histogram and region of occupied
	/// color space.  The subsampling is chosen internally for
	/// efficiency, based on the image size, but this parameter
	/// limits it.  Use %maxsub = 0 for the internal default, which is the
	/// maximum allowed subsampling.  Use %maxsub = 1 to prevent
	/// subsampling.  In general use %maxsub greater or equal 1 to specify the
	/// maximum subsampling to be allowed, where the actual subsampling
	/// will be the minimum of this value and the internally
	/// determined default value.<para/>
	///
	/// (6) If the image appears gray because either most of the pixels
	/// are gray or most of the pixels are essentially black or white,
	/// the image is trivially quantized with a grayscale colormap.  The
	/// reason is that median cut divides the color space into rectangular
	/// regions, and it does a very poor job if all the pixels are
	/// near the diagonal of the color space cube.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMedianCutQuantGeneral/*"/>
	///  <param name="ditherflag">[in] - 1 for dither 0 for no dither</param>
	///  <param name="outdepth">[in] - output depth valid: 0, 1, 2, 4, 8</param>
	///  <param name="maxcolors">[in] - between 2 and 256</param>
	///  <param name="sigbits">[in] - valid: 5 or 6 use 0 for default</param>
	///  <param name="maxsub">[in] - max subsampling, integer use 0 for default 1 for no subsampling</param>
	///  <param name="checkbw">[in] - 1 to check if color content is very small, 0 to assume there is sufficient color</param>
	///   <returns>pixd 8 bit with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MedianCutQuantGeneral (int ditherflag,
									  int outdepth,
									  int maxcolors,
									  int sigbits,
									  int maxsub,
									  int checkbw)
	{
		Pix RetObj = _All.pixMedianCutQuantGeneral(this, ditherflag, outdepth, maxcolors, sigbits, maxsub, checkbw);
		return RetObj;
	}

	// colorquant2.c (579, 1)
	// pixMedianCutQuantMixed(pixs, ncolor, ngray, darkthresh, lightthresh, diffthresh) as Pix
	// pixMedianCutQuantMixed(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) ncolor + ngray must not exceed 255.<para/>
	///
	/// (2) The method makes use of pixMedianCutQuantGeneral() with
	/// minimal addition.
	/// (a) Preprocess the image, setting all pixels with little color
	/// to black, and populating an auxiliary 8 bpp image with the
	/// expected colormap values corresponding to the set of
	/// quantized gray values.
	/// (b) Color quantize the altered input image to n + 1 colors.
	/// (c) Augment the colormap with the gray indices, and
	/// substitute the gray quantized values from the auxiliary
	/// image for those in the color quantized output that had
	/// been quantized as black.<para/>
	///
	/// (3) Median cut color quantization is relatively poor for grayscale
	/// images with many colors, when compared to octcube quantization.
	/// Thus, for images with both gray and color, it is important
	/// to quantize the gray pixels by another method.  Here, we
	/// are conservative in detecting color, preferring to use
	/// a few extra bits to encode colorful pixels that push them
	/// to gray.  This is particularly reasonable with this function,
	/// because it handles the gray and color pixels separately,
	/// using median cut color quantization for the color pixels
	/// and equal-bin grayscale quantization for the non-color pixels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMedianCutQuantMixed/*"/>
	///  <param name="ncolor">[in] - maximum number of colors assigned to pixels with significant color</param>
	///  <param name="ngray">[in] - number of gray colors to be used must be greater or equal 2</param>
	///  <param name="darkthresh">[in] - threshold near black if the lightest component is below this, the pixel is not considered to be gray or color uses 0 for default</param>
	///  <param name="lightthresh">[in] - threshold near white if the darkest component is above this, the pixel is not considered to be gray or color use 0 for default</param>
	///  <param name="diffthresh">[in] - thresh for the max difference between component values for differences below this, the pixel is considered to be gray use 0 for default</param>
	///   <returns>pixd 8 bpp cmapped, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MedianCutQuantMixed (int ncolor,
									int ngray,
									int darkthresh,
									int lightthresh,
									int diffthresh)
	{
		Pix RetObj = _All.pixMedianCutQuantMixed(this, ncolor, ngray, darkthresh, lightthresh, diffthresh);
		return RetObj;
	}

	// colorquant2.c (754, 1)
	// pixFewColorsMedianCutQuantMixed(pixs, ncolor, ngray, maxncolors, darkthresh, lightthresh, diffthresh) as Pix
	// pixFewColorsMedianCutQuantMixed(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This is the "few colors" version of pixMedianCutQuantMixed().
	/// It fails (returns NULL) if it finds more than maxncolors, but
	/// otherwise it gives the same result.<para/>
	///
	/// (2) Recommended input parameters are:
	/// %maxncolors:  20
	/// %darkthresh:  20
	/// %lightthresh: 244
	/// %diffthresh:  15  (any higher can miss colors differing
	/// slightly from gray)<para/>
	///
	/// (3) Both ncolor and ngray should be at least equal to maxncolors.
	/// If they're not, they are automatically increased, and a
	/// warning is given.<para/>
	///
	/// (4) If very little color content is found, the input is
	/// converted to gray and quantized in equal intervals.<para/>
	///
	/// (5) This can be useful for quantizing orthographically generated
	/// images such as color maps, where there may be more than 256 colors
	/// because of aliasing or jpeg artifacts on text or lines, but
	/// there are a relatively small number of solid colors.<para/>
	///
	/// (6) Example of usage:
	/// // Try to quantize, using default values for mixed med cut
	/// Pix pixq = pixFewColorsMedianCutQuantMixed(pixs, 100, 20,
	/// 0, 0, 0, 0)
	/// if (!pixq)  // too many colors don't quantize
	/// pixq = pixClone(pixs)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFewColorsMedianCutQuantMixed/*"/>
	///  <param name="ncolor">[in] - number of colors to be assigned to pixels with significant color</param>
	///  <param name="ngray">[in] - number of gray colors to be used must be greater or equal 2</param>
	///  <param name="maxncolors">[in] - maximum number of colors to be returned from pixColorsForQuantization() use 0 for default</param>
	///  <param name="darkthresh">[in] - threshold near black if the lightest component is below this, the pixel is not considered to be gray or color use 0 for default</param>
	///  <param name="lightthresh">[in] - threshold near white if the darkest component is above this, the pixel is not considered to be gray or color use 0 for default</param>
	///  <param name="diffthresh">[in] - thresh for the max difference between component values for differences below this, the pixel is considered to be gray use 0 for default</param>
	///   <returns>pixd 8 bpp, median cut quantized for pixels that are not gray gray pixels are quantized separately over the full gray range null if too many colors or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FewColorsMedianCutQuantMixed (int ncolor,
											 int ngray,
											 int maxncolors,
											 int darkthresh,
											 int lightthresh,
											 int diffthresh)
	{
		Pix RetObj = _All.pixFewColorsMedianCutQuantMixed(this, ncolor, ngray, maxncolors, darkthresh, lightthresh, diffthresh);
		return RetObj;
	}

	// colorquant2.c (826, 1)
	// pixMedianCutHisto(pixs, sigbits, subsample) as int[]
	// pixMedianCutHisto(PIX *, l_int32, l_int32) as l_int32 *
	///  <summary>
	/// (1) Array is indexed by (3  sigbits) bits.  The array size
	/// is 2^(3  sigbits).<para/>
	///
	/// (2) Indexing into the array from rgb uses red sigbits as
	/// most significant and blue as least.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMedianCutHisto/*"/>
	///  <param name="sigbits">[in] - valid: 5 or 6</param>
	///  <param name="subsample">[in] - integer  is greater  0</param>
	///   <returns>histo 1-d array, giving the number of pixels in each quantized region of color space, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int[] MedianCutHisto (int sigbits,
								 int subsample)
	{
		int[] RetObj = _All.pixMedianCutHisto(this, sigbits, subsample);
		return RetObj;
	}

	// colorseg.c (129, 1)
	// pixColorSegment(pixs, maxdist, maxcolors, selsize, finalcolors, debugflag) as Pix
	// pixColorSegment(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// Color segmentation proceeds in four phases:
	/// Phase 1:  pixColorSegmentCluster()
	/// The image is traversed in raster order.  Each pixel either
	/// becomes the representative for a new cluster or is assigned to an
	/// existing cluster.  Assignment is greedy.  The data is stored in
	/// a colormapped image.  Three auxiliary arrays are used to hold
	/// the colors of the representative pixels, for fast lookup.
	/// The average color in each cluster is computed.
	/// Phase 2.  pixAssignToNearestColor()
	/// A second non-greedy clustering pass is performed, where each pixel
	/// is assigned to the nearest cluster average.  We also keep track
	/// of how many pixels are assigned to each cluster.
	/// Phase 3.  pixColorSegmentClean()
	/// For each cluster, starting with the largest, do a morphological
	/// closing to eliminate small components within larger ones.
	/// Phase 4.  pixColorSegmentRemoveColors()
	/// Eliminate all colors except the most populated 'finalcolors'.
	/// Then remove unused colors from the colormap, and reassign those
	/// pixels to the nearest remaining cluster, using the original pixel values.
	/// Notes:<para/>
	///
	/// (1) The goal is to generate a small number of colors.
	/// Typically this would be specified by 'finalcolors',
	/// a number that would be somewhere between 3 and 6.
	/// The parameter 'maxcolors' specifies the maximum number of
	/// colors generated in the first phase.  This should be
	/// larger than finalcolors, perhaps twice as large.
	/// If more than 'maxcolors' are generated in the first phase
	/// using the input 'maxdist', the distance is repeatedly
	/// increased by a multiplicative factor until the condition
	/// is satisfied.  The implicit relation between 'maxdist'
	/// and 'maxcolors' is thus adjusted programmatically.<para/>
	///
	/// (2) As a very rough guideline, given a target value of 'finalcolors',
	/// here are approximate values of 'maxdist' and 'maxcolors'
	/// to start with:
	/// finalcolors  maxcolors  maxdist
	/// -----------  ---------  -------
	/// 3   6  100
	/// 4   8   90
	/// 5  10   75
	/// 6  12   60
	/// For a given number of finalcolors, if you use too many
	/// maxcolors, the result will be noisy.  If you use too few,
	/// the result will be a relatively poor assignment of colors.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorSegment/*"/>
	///  <param name="maxdist">[in] - max euclidean dist to existing cluster</param>
	///  <param name="maxcolors">[in] - max number of colors allowed in first pass</param>
	///  <param name="selsize">[in] - linear size of sel for closing to remove noise</param>
	///  <param name="finalcolors">[in] - max number of final colors allowed after 4th pass</param>
	///  <param name="debugflag">[in] - 1 for debug output 0 otherwise</param>
	///   <returns>pixd 8 bit with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ColorSegment (int maxdist,
							 int maxcolors,
							 int selsize,
							 int finalcolors,
							 int debugflag)
	{
		Pix RetObj = _All.pixColorSegment(this, maxdist, maxcolors, selsize, finalcolors, debugflag);
		return RetObj;
	}

	// colorseg.c (200, 1)
	// pixColorSegmentCluster(pixs, maxdist, maxcolors, debugflag) as Pix
	// pixColorSegmentCluster(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This is phase 1.  See description in pixColorSegment().<para/>
	///
	/// (2) Greedy unsupervised classification.  If the limit 'maxcolors'
	/// is exceeded, the computation is repeated with a larger
	/// allowed cluster size.<para/>
	///
	/// (3) On each successive iteration, 'maxdist' is increased by a
	/// constant factor.  See comments in pixColorSegment() for
	/// a guideline on parameter selection.
	/// Note that the diagonal of the 8-bit rgb color cube is about
	/// 440, so for 'maxdist' = 440, you are guaranteed to get 1 color!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorSegmentCluster/*"/>
	///  <param name="maxdist">[in] - max euclidean dist to existing cluster</param>
	///  <param name="maxcolors">[in] - max number of colors allowed in first pass</param>
	///  <param name="debugflag">[in] - 1 for debug output 0 otherwise</param>
	///   <returns>pixd 8 bit with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ColorSegmentCluster (int maxdist,
									int maxcolors,
									int debugflag)
	{
		Pix RetObj = _All.pixColorSegmentCluster(this, maxdist, maxcolors, debugflag);
		return RetObj;
	}

	// colorseg.c (412, 1)
	// pixAssignToNearestColor(pixd, pixs, pixm, level, countarray) as int
	// pixAssignToNearestColor(PIX *, PIX *, PIX *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) This is used in phase 2 of color segmentation, where pixs
	/// is the original input image to pixColorSegment(), and
	/// pixd is the colormapped image returned from
	/// pixColorSegmentCluster().  It is also used, with a mask,
	/// in phase 4.<para/>
	///
	/// (2) This is an in-place operation.<para/>
	///
	/// (3) The colormap in pixd is unchanged.<para/>
	///
	/// (4) pixs and pixd must be the same size (w, h).<para/>
	///
	/// (5) The selection mask pixm can be null.  If it exists, it must
	/// be the same size as pixs and pixd, and only pixels
	/// corresponding to fg in pixm are assigned.  Set to
	/// NULL if all pixels in pixd are to be assigned.<para/>
	///
	/// (6) The countarray can be null.  If it exists, it is pre-allocated
	/// and of a size at least equal to the size of the colormap in pixd.<para/>
	///
	/// (7) This does a best-fit (non-greedy) assignment of pixels to
	/// existing clusters.  Specifically, it assigns each pixel
	/// in pixd to the color index in the pixd colormap that has a
	/// color closest to the corresponding rgb pixel in pixs.<para/>
	///
	/// (8) 'level' is the octcube level used to quickly find the nearest
	/// color in the colormap for each pixel.  For color segmentation,
	/// this parameter is set to LEVEL_IN_OCTCUBE.<para/>
	///
	/// (9) We build a mapping table from octcube to colormap index so
	/// that this function can run in a time (otherwise) independent
	/// of the number of colors in the colormap.  This avoids a
	/// brute-force search for the closest colormap color to each
	/// pixel in the image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAssignToNearestColor/*"/>
	///  <param name="pixd">[in] - 8 bpp, colormapped</param>
	///  <param name="pixm">[in][optional] - 1 bpp</param>
	///  <param name="level">[in] - of octcube used for finding nearest color in cmap</param>
	///  <param name="countarray">[in][optional] - ptr to array, in which we can store the number of pixels found in each color in the colormap in pixd</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AssignToNearestColor (Pix pixd,
									 int level,
									 Pix pixm,
									 int[] countarray)
	{
		int RetObj = _All.pixAssignToNearestColor(pixd, this, pixm, level, countarray);
		return RetObj;
	}

	// colorseg.c (512, 1)
	// pixColorSegmentClean(pixs, selsize, countarray) as int
	// pixColorSegmentClean(PIX *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) This operation is in-place.<para/>
	///
	/// (2) This is phase 3 of color segmentation.  It is the first
	/// part of a two-step noise removal process.  Colors with a
	/// large population are closed first this operation absorbs
	/// small sets of intercolated pixels of a different color.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorSegmentClean/*"/>
	///  <param name="selsize">[in] - for closing</param>
	///  <param name="countarray">[in] - ptr to array containing the number of pixels found in each color in the colormap</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ColorSegmentClean (int selsize,
								  int[] countarray)
	{
		int RetObj = _All.pixColorSegmentClean(this, selsize, countarray);
		return RetObj;
	}

	// colorseg.c (584, 1)
	// pixColorSegmentRemoveColors(pixd, pixs, finalcolors) as int
	// pixColorSegmentRemoveColors(PIX *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) This operation is in-place.<para/>
	///
	/// (2) This is phase 4 of color segmentation, and the second part
	/// of the 2-step noise removal.  Only 'finalcolors' different
	/// colors are retained, with colors with smaller populations
	/// being replaced by the nearest color of the remaining colors.
	/// For highest accuracy, for pixels that are being replaced,
	/// we find the nearest colormap color  to the original rgb color.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorSegmentRemoveColors/*"/>
	///  <param name="pixd">[in] - 8 bpp, colormapped</param>
	///  <param name="finalcolors">[in] - max number of colors to retain</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ColorSegmentRemoveColors (Pix pixd,
										 int finalcolors)
	{
		int RetObj = _All.pixColorSegmentRemoveColors(pixd, this, finalcolors);
		return RetObj;
	}

	// colorspace.c (134, 1)
	// pixConvertRGBToHSV(pixd, pixs) as Pix
	// pixConvertRGBToHSV(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) For pixs = pixd, this is in-place otherwise pixd must be NULL.<para/>
	///
	/// (2) The definition of our HSV space is given in convertRGBToHSV().<para/>
	///
	/// (3) The h, s and v values are stored in the same places as
	/// the r, g and b values, respectively.  Here, they are explicitly
	/// placed in the 3 MS bytes in the pixel.<para/>
	///
	/// (4) Normalizing to 1 and considering the r,g,b components,
	/// a simple way to understand the HSV space is:
	/// ~ v = max(r,g,b)
	/// ~ s = (max - min) / max
	/// ~ h ~ (mid - min) / (max - min)  [apart from signs and constants]<para/>
	///
	/// (5) Normalizing to 1, some properties of the HSV space are:
	/// ~ For gray values (r = g = b) along the continuum between
	/// black and white:
	/// s = 0  (becoming undefined as you approach black)
	/// h is undefined everywhere
	/// ~ Where one component is saturated and the others are zero:
	/// v = 1
	/// s = 1
	/// h = 0 (r = max), 1/3 (g = max), 2/3 (b = max)
	/// ~ Where two components are saturated and the other is zero:
	/// v = 1
	/// s = 1
	/// h = 1/2 (if r = 0), 5/6 (if g = 0), 1/6 (if b = 0)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToHSV/*"/>
	///  <param name="pixd">[in]can be NULL - if not NULL, must == pixs</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertRGBToHSV (Pix pixd)
	{
		Pix RetObj = _All.pixConvertRGBToHSV(pixd, this);
		return RetObj;
	}

	// colorspace.c (198, 1)
	// pixConvertHSVToRGB(pixd, pixs) as Pix
	// pixConvertHSVToRGB(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) For pixs = pixd, this is in-place otherwise pixd must be NULL.<para/>
	///
	/// (2) The user takes responsibility for making sure that pixs is
	/// in our HSV space.  The definition of our HSV space is given
	/// in convertRGBToHSV().<para/>
	///
	/// (3) The h, s and v values are stored in the same places as
	/// the r, g and b values, respectively.  Here, they are explicitly
	/// placed in the 3 MS bytes in the pixel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertHSVToRGB/*"/>
	///  <param name="pixd">[in]can be NULL - if not NULL, must == pixs</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertHSVToRGB (Pix pixd)
	{
		Pix RetObj = _All.pixConvertHSVToRGB(pixd, this);
		return RetObj;
	}

	// colorspace.c (492, 1)
	// pixConvertRGBToHue(pixs) as Pix
	// pixConvertRGBToHue(PIX *) as PIX *
	///  <summary>
	/// (1) The conversion to HSV hue is in-lined here.<para/>
	///
	/// (2) If there is a colormap, it is removed.<para/>
	///
	/// (3) If you just want the hue component, this does it
	/// at about 10 Mpixels/sec/GHz, which is about
	/// 2x faster than using pixConvertRGBToHSV()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToHue/*"/>
	///   <returns>pixd 8 bpp hue of HSV, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertRGBToHue ()
	{
		Pix RetObj = _All.pixConvertRGBToHue(this);
		return RetObj;
	}

	// colorspace.c (568, 1)
	// pixConvertRGBToSaturation(pixs) as Pix
	// pixConvertRGBToSaturation(PIX *) as PIX *
	///  <summary>
	/// (1) The conversion to HSV sat is in-lined here.<para/>
	///
	/// (2) If there is a colormap, it is removed.<para/>
	///
	/// (3) If you just want the saturation component, this does it
	/// at about 12 Mpixels/sec/GHz.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToSaturation/*"/>
	///   <returns>pixd 8 bpp sat of HSV, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertRGBToSaturation ()
	{
		Pix RetObj = _All.pixConvertRGBToSaturation(this);
		return RetObj;
	}

	// colorspace.c (633, 1)
	// pixConvertRGBToValue(pixs) as Pix
	// pixConvertRGBToValue(PIX *) as PIX *
	///  <summary>
	/// (1) The conversion to HSV sat is in-lined here.<para/>
	///
	/// (2) If there is a colormap, it is removed.<para/>
	///
	/// (3) If you just want the value component, this does it
	/// at about 35 Mpixels/sec/GHz.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToValue/*"/>
	///   <returns>pixd 8 bpp max component intensity of HSV, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertRGBToValue ()
	{
		Pix RetObj = _All.pixConvertRGBToValue(this);
		return RetObj;
	}

	// colorspace.c (702, 1)
	// pixMakeRangeMaskHS(pixs, huecenter, huehw, satcenter, sathw, regionflag) as Pix
	// pixMakeRangeMaskHS(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The pixels are selected based on the specified ranges of
	/// hue and saturation.  For selection or exclusion, the pixel
	/// HS component values must be within both ranges.  Care must
	/// be taken in finding the hue range because of wrap-around.<para/>
	///
	/// (2) Use %regionflag == L_INCLUDE_REGION to take only those
	/// pixels within the rectangular region specified in HS space.
	/// Use %regionflag == L_EXCLUDE_REGION to take all pixels except
	/// those within the rectangular region specified in HS space.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMakeRangeMaskHS/*"/>
	///  <param name="huecenter">[in] - center value of hue range</param>
	///  <param name="huehw">[in] - half-width of hue range</param>
	///  <param name="satcenter">[in] - center value of saturation range</param>
	///  <param name="sathw">[in] - half-width of saturation range</param>
	///  <param name="regionflag">[in] - L_INCLUDE_REGION, L_EXCLUDE_REGION</param>
	///   <returns>pixd 1 bpp mask over selected pixels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MakeRangeMaskHS (int huecenter,
								int huehw,
								int satcenter,
								int sathw,
								int regionflag)
	{
		Pix RetObj = _All.pixMakeRangeMaskHS(this, huecenter, huehw, satcenter, sathw, regionflag);
		return RetObj;
	}

	// colorspace.c (801, 1)
	// pixMakeRangeMaskHV(pixs, huecenter, huehw, valcenter, valhw, regionflag) as Pix
	// pixMakeRangeMaskHV(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The pixels are selected based on the specified ranges of
	/// hue and max intensity values.  For selection or exclusion,
	/// the pixel HV component values must be within both ranges.
	/// Care must be taken in finding the hue range because of wrap-around.<para/>
	///
	/// (2) Use %regionflag == L_INCLUDE_REGION to take only those
	/// pixels within the rectangular region specified in HV space.
	/// Use %regionflag == L_EXCLUDE_REGION to take all pixels except
	/// those within the rectangular region specified in HV space.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMakeRangeMaskHV/*"/>
	///  <param name="huecenter">[in] - center value of hue range</param>
	///  <param name="huehw">[in] - half-width of hue range</param>
	///  <param name="valcenter">[in] - center value of max intensity range</param>
	///  <param name="valhw">[in] - half-width of max intensity range</param>
	///  <param name="regionflag">[in] - L_INCLUDE_REGION, L_EXCLUDE_REGION</param>
	///   <returns>pixd 1 bpp mask over selected pixels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MakeRangeMaskHV (int huecenter,
								int huehw,
								int valcenter,
								int valhw,
								int regionflag)
	{
		Pix RetObj = _All.pixMakeRangeMaskHV(this, huecenter, huehw, valcenter, valhw, regionflag);
		return RetObj;
	}

	// colorspace.c (899, 1)
	// pixMakeRangeMaskSV(pixs, satcenter, sathw, valcenter, valhw, regionflag) as Pix
	// pixMakeRangeMaskSV(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The pixels are selected based on the specified ranges of
	/// saturation and max intensity (val).  For selection or
	/// exclusion, the pixel SV component values must be within both ranges.<para/>
	///
	/// (2) Use %regionflag == L_INCLUDE_REGION to take only those
	/// pixels within the rectangular region specified in SV space.
	/// Use %regionflag == L_EXCLUDE_REGION to take all pixels except
	/// those within the rectangular region specified in SV space.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMakeRangeMaskSV/*"/>
	///  <param name="satcenter">[in] - center value of saturation range</param>
	///  <param name="sathw">[in] - half-width of saturation range</param>
	///  <param name="valcenter">[in] - center value of max intensity range</param>
	///  <param name="valhw">[in] - half-width of max intensity range</param>
	///  <param name="regionflag">[in] - L_INCLUDE_REGION, L_EXCLUDE_REGION</param>
	///   <returns>pixd 1 bpp mask over selected pixels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MakeRangeMaskSV (int satcenter,
								int sathw,
								int valcenter,
								int valhw,
								int regionflag)
	{
		Pix RetObj = _All.pixMakeRangeMaskSV(this, satcenter, sathw, valcenter, valhw, regionflag);
		return RetObj;
	}

	// colorspace.c (988, 1)
	// pixMakeHistoHS(pixs, factor, pnahue, pnasat) as Pix
	// pixMakeHistoHS(PIX *, l_int32, NUMA **, NUMA **) as PIX *
	///  <summary>
	/// (1) pixs is a 32 bpp image in HSV colorspace hue is in the "red"
	/// byte, saturation is in the "green" byte.<para/>
	///
	/// (2) In pixd, hue is displayed vertically saturation horizontally.
	/// The dimensions of pixd are w = 256, h = 240, and the depth
	/// is 32 bpp.  The value at each point is simply the number
	/// of pixels found at that value of hue and saturation.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMakeHistoHS/*"/>
	///  <param name="factor">[in] - subsampling factor integer</param>
	///  <param name="pnahue">[out][optional] - hue histogram</param>
	///  <param name="pnasat">[out][optional] - saturation histogram</param>
	///   <returns>pixd 32 bpp histogram in hue and saturation, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MakeHistoHS (int factor,
							out Numa pnahue,
							out Numa pnasat)
	{
		Pix RetObj = _All.pixMakeHistoHS(this, factor, out pnahue, out pnasat);
		return RetObj;
	}

	// colorspace.c (1079, 1)
	// pixMakeHistoHV(pixs, factor, pnahue, pnaval) as Pix
	// pixMakeHistoHV(PIX *, l_int32, NUMA **, NUMA **) as PIX *
	///  <summary>
	/// (1) pixs is a 32 bpp image in HSV colorspace hue is in the "red"
	/// byte, max intensity ("value") is in the "blue" byte.<para/>
	///
	/// (2) In pixd, hue is displayed vertically intensity horizontally.
	/// The dimensions of pixd are w = 256, h = 240, and the depth
	/// is 32 bpp.  The value at each point is simply the number
	/// of pixels found at that value of hue and intensity.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMakeHistoHV/*"/>
	///  <param name="factor">[in] - subsampling factor integer</param>
	///  <param name="pnahue">[out][optional] - hue histogram</param>
	///  <param name="pnaval">[out][optional] - max intensity (value) histogram</param>
	///   <returns>pixd 32 bpp histogram in hue and value, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MakeHistoHV (int factor,
							out Numa pnahue,
							out Numa pnaval)
	{
		Pix RetObj = _All.pixMakeHistoHV(this, factor, out pnahue, out pnaval);
		return RetObj;
	}

	// colorspace.c (1162, 1)
	// pixMakeHistoSV(pixs, factor, pnasat, pnaval) as Pix
	// pixMakeHistoSV(PIX *, l_int32, NUMA **, NUMA **) as PIX *
	///  <summary>
	/// (1) pixs is a 32 bpp image in HSV colorspace sat is in the "green"
	/// byte, max intensity ("value") is in the "blue" byte.<para/>
	///
	/// (2) In pixd, sat is displayed vertically intensity horizontally.
	/// The dimensions of pixd are w = 256, h = 256, and the depth
	/// is 32 bpp.  The value at each point is simply the number
	/// of pixels found at that value of saturation and intensity.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMakeHistoSV/*"/>
	///  <param name="factor">[in] - subsampling factor integer</param>
	///  <param name="pnasat">[out][optional] - sat histogram</param>
	///  <param name="pnaval">[out][optional] - max intensity (value) histogram</param>
	///   <returns>pixd 32 bpp histogram in sat and value, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MakeHistoSV (int factor,
							out Numa pnasat,
							out Numa pnaval)
	{
		Pix RetObj = _All.pixMakeHistoSV(this, factor, out pnasat, out pnaval);
		return RetObj;
	}

	// colorspace.c (1253, 1)
	// pixFindHistoPeaksHSV(pixs, type, width, height, npeaks, erasefactor, ppta, pnatot, ppixa) as int
	// pixFindHistoPeaksHSV(PIX *, l_int32, l_int32, l_int32, l_int32, l_float32, PTA **, NUMA **, PIXA **) as l_ok
	///  <summary>
	/// (1) pixs is a 32 bpp histogram in a pair of HSV colorspace.  It
	/// should be thought of as a single sample with 32 bps (bits/sample).<para/>
	///
	/// (2) After each peak is found, the peak is erased with a window
	/// that is centered on the peak and scaled from the sliding
	/// window by %erasefactor.  Typically, %erasefactor is chosen
	/// to be  is greater  1.0.<para/>
	///
	/// (3) Data for a maximum of %npeaks is returned in %pta and %natot.<para/>
	///
	/// (4) For debugging, after the pixa is returned, display with:
	/// pixd = pixaDisplayTiledInRows(pixa, 32, 1000, 1.0, 0, 30, 2)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindHistoPeaksHSV/*"/>
	///  <param name="type">[in] - L_HS_HISTO, L_HV_HISTO or L_SV_HISTO</param>
	///  <param name="width">[in] - half width of sliding window</param>
	///  <param name="height">[in] - half height of sliding window</param>
	///  <param name="npeaks">[in] - number of peaks to look for</param>
	///  <param name="erasefactor">[in] - ratio of erase window size to sliding window size</param>
	///  <param name="ppta">[out] - locations of max for each integrated peak area</param>
	///  <param name="pnatot">[out] - integrated peak areas</param>
	///  <param name="ppixa">[out][optional] - pixa for debugging NULL to skip</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindHistoPeaksHSV (int type,
								  int width,
								  int height,
								  int npeaks,
								  Single erasefactor,
								  out Pta ppta,
								  out Numa pnatot,
								  out Pixa ppixa)
	{
		int RetObj = _All.pixFindHistoPeaksHSV(this, type, width, height, npeaks, erasefactor, out ppta, out pnatot, out ppixa);
		return RetObj;
	}

	// colorspace.c (1454, 1)
	// pixConvertRGBToYUV(pixd, pixs) as Pix
	// pixConvertRGBToYUV(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) For pixs = pixd, this is in-place otherwise pixd must be NULL.<para/>
	///
	/// (2) The Y, U and V values are stored in the same places as
	/// the r, g and b values, respectively.  Here, they are explicitly
	/// placed in the 3 MS bytes in the pixel.<para/>
	///
	/// (3) Normalizing to 1 and considering the r,g,b components,
	/// a simple way to understand the YUV space is:
	/// ~ Y = weighted sum of (r,g,b)
	/// ~ U = weighted difference between Y and B
	/// ~ V = weighted difference between Y and R<para/>
	///
	/// (4) Following video conventions, Y, U and V are in the range:
	/// Y: [16, 235]
	/// U: [16, 240]
	/// V: [16, 240]<para/>
	///
	/// (5) For the coefficients in the transform matrices, see eq. 4 in
	/// "Frequently Asked Questions about Color" by Charles Poynton,
	/// //http://user.engineering.uiowa.edu/~aip/Misc/ColorFAQ.html
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToYUV/*"/>
	///  <param name="pixd">[in]can be NULL - if not NULL, must == pixs</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertRGBToYUV (Pix pixd)
	{
		Pix RetObj = _All.pixConvertRGBToYUV(pixd, this);
		return RetObj;
	}

	// colorspace.c (1517, 1)
	// pixConvertYUVToRGB(pixd, pixs) as Pix
	// pixConvertYUVToRGB(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) For pixs = pixd, this is in-place otherwise pixd must be NULL.<para/>
	///
	/// (2) The user takes responsibility for making sure that pixs is
	/// in YUV space.<para/>
	///
	/// (3) The Y, U and V values are stored in the same places as
	/// the r, g and b values, respectively.  Here, they are explicitly
	/// placed in the 3 MS bytes in the pixel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertYUVToRGB/*"/>
	///  <param name="pixd">[in]can be NULL - if not NULL, must == pixs</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertYUVToRGB (Pix pixd)
	{
		Pix RetObj = _All.pixConvertYUVToRGB(pixd, this);
		return RetObj;
	}

	// colorspace.c (1762, 1)
	// pixConvertRGBToXYZ(pixs) as FPixa
	// pixConvertRGBToXYZ(PIX *) as FPIXA *
	///  <summary>
	/// (1) The [x,y,z] values are stored as float values in three fpix
	/// that are returned in a fpixa.<para/>
	///
	/// (2) The XYZ color space was defined in 1931 as a reference model that
	/// simulates human color perception.  When Y is taken as luminance,
	/// the values of X and Z constitute a color plane representing
	/// all the hues that can be perceived.  This gamut of colors
	/// is larger than the gamuts that can be displayed or printed.
	/// For example, although all rgb values map to XYZ, the converse
	/// is not true.<para/>
	///
	/// (3) The value of the coefficients depends on the illuminant.  We use
	/// coefficients for converting sRGB under D65 (the spectrum from
	/// a 6500 degree K black body an approximation to daylight color).
	/// See, e.g.,
	/// http://www.cs.rit.edu/~ncs/color/t_convert.html
	/// For more general information on color transforms, see:
	/// http://www.brucelindbloom.com/
	/// http://user.engineering.uiowa.edu/~aip/Misc/ColorFAQ.html
	/// http://en.wikipedia.org/wiki/CIE_1931_color_space
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToXYZ/*"/>
	///   <returns>fpixa xyz</returns>
	// CreateAdditiveFunction: Function/Else
	public FPixa ConvertRGBToXYZ ()
	{
		FPixa RetObj = _All.pixConvertRGBToXYZ(this);
		return RetObj;
	}

	// colorspace.c (2243, 1)
	// pixConvertRGBToLAB(pixs) as FPixa
	// pixConvertRGBToLAB(PIX *) as FPIXA *
	///  <summary>
	/// (1) The [l,a,b] values are stored as float values in three fpix
	/// that are returned in a fpixa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToLAB/*"/>
	///   <returns>fpixa lab</returns>
	// CreateAdditiveFunction: Function/Else
	public FPixa ConvertRGBToLAB ()
	{
		FPixa RetObj = _All.pixConvertRGBToLAB(this);
		return RetObj;
	}

	// compare.c (150, 1)
	// pixEqual(pix1, pix2, psame) as int
	// pixEqual(PIX *, PIX *, l_int32 *) as l_ok
	///  <summary>
	/// (1) Equality is defined as having the same pixel values for
	/// each respective image pixel.<para/>
	///
	/// (2) This works on two pix of any depth.  If one or both pix
	/// have a colormap, the depths can be different and the
	/// two pix can still be equal.<para/>
	///
	/// (3) This ignores the alpha component for 32 bpp images.<para/>
	///
	/// (4) If both pix have colormaps and the depths are equal,
	/// use the pixEqualWithCmap() function, which does a fast
	/// comparison if the colormaps are identical and a relatively
	/// slow comparison otherwise.<para/>
	///
	/// (5) In all other cases, any existing colormaps must first be
	/// removed before doing pixel comparison.  After the colormaps
	/// are removed, the resulting two images must have the same depth.
	/// The "lowest common denominator" is RGB, but this is only
	/// chosen when necessary, or when both have colormaps but
	/// different depths.<para/>
	///
	/// (6) For images without colormaps that are not 32 bpp, all bits
	/// in the image part of the data array must be identical.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixEqual/*"/>
	///  <param name="pix1">[in] - </param>
	///  <param name="pix2">[in] - </param>
	///  <param name="psame">[out] - 1 if same 0 if different</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Equal (Pix pix1,
					  Pix pix2,
					  out int psame)
	{
		int RetObj = _All.pixEqual(pix1, pix2, out psame);
		return RetObj;
	}

	// compare.c (176, 1)
	// pixEqualWithAlpha(pix1, pix2, use_alpha, psame) as int
	// pixEqualWithAlpha(PIX *, PIX *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) See notes in pixEqual().<para/>
	///
	/// (2) This is more general than pixEqual(), in that for 32 bpp
	/// RGBA images, where spp = 4, you can optionally include
	/// the alpha component in the comparison.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixEqualWithAlpha/*"/>
	///  <param name="pix1">[in] - </param>
	///  <param name="pix2">[in] - </param>
	///  <param name="use_alpha">[in] - 1 to compare alpha in RGBA 0 to ignore</param>
	///  <param name="psame">[out] - 1 if same 0 if different</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int EqualWithAlpha (Pix pix1,
							   Pix pix2,
							   int use_alpha,
							   out int psame)
	{
		int RetObj = _All.pixEqualWithAlpha(pix1, pix2, use_alpha, out psame);
		return RetObj;
	}

	// compare.c (378, 1)
	// pixEqualWithCmap(pix1, pix2, psame) as int
	// pixEqualWithCmap(PIX *, PIX *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This returns same = TRUE if the images have identical content.<para/>
	///
	/// (2) Both pix must have a colormap, and be of equal size and depth.
	/// If these conditions are not satisfied, it is not an error
	/// the returned result is same = FALSE.<para/>
	///
	/// (3) We then check whether the colormaps are the same if so,
	/// the comparison proceeds 32 bits at a time.<para/>
	///
	/// (4) If the colormaps are different, the comparison is done by
	/// slow brute force.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixEqualWithCmap/*"/>
	///  <param name="pix1">[in] - </param>
	///  <param name="pix2">[in] - </param>
	///  <param name="psame">[out] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int EqualWithCmap (Pix pix1,
							  Pix pix2,
							  out int psame)
	{
		int RetObj = _All.pixEqualWithCmap(pix1, pix2, out psame);
		return RetObj;
	}

	// compare.c (532, 1)
	// pixUsesCmapColor(pixs, pcolor) as int
	// pixUsesCmapColor(PIX *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This returns color = TRUE if three things are obtained:
	/// (a) the pix has a colormap
	/// (b) the colormap has at least one color entry
	/// (c) a color entry is actually used<para/>
	///
	/// (2) It is used in pixEqual() for comparing two images, in a
	/// situation where it is required to know if the colormap
	/// has color entries that are actually used in the image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixUsesCmapColor/*"/>
	///  <param name="pcolor">[out] - TRUE if color found</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int UsesCmapColor (out int pcolor)
	{
		int RetObj = _All.pixUsesCmapColor(this, out pcolor);
		return RetObj;
	}

	// compare.c (598, 1)
	// pixCorrelationBinary(pix1, pix2, pval) as int
	// pixCorrelationBinary(PIX *, PIX *, l_float32 *) as l_ok
	///  <summary>
	/// (1) The correlation is a number between 0.0 and 1.0,
	/// based on foreground similarity:
	/// (|1 AND 2|)2
	/// correlation =  --------------
	/// |1|  |2|
	/// where |x| is the count of foreground pixels in image x.
	/// If the images are identical, this is 1.0.
	/// If they have no fg pixels in common, this is 0.0.
	/// If one or both images have no fg pixels, the correlation is 0.0.<para/>
	///
	/// (2) Typically the two images are of equal size, but this
	/// is not enforced.  Instead, the UL corners are aligned.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCorrelationBinary/*"/>
	///  <param name="pix1">[in] - 1 bpp</param>
	///  <param name="pix2">[in] - 1 bpp</param>
	///  <param name="pval">[out] - correlation</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CorrelationBinary (Pix pix1,
								  Pix pix2,
								  out Single pval)
	{
		int RetObj = _All.pixCorrelationBinary(pix1, pix2, out pval);
		return RetObj;
	}

	// compare.c (656, 1)
	// pixDisplayDiffBinary(pix1, pix2) as Pix
	// pixDisplayDiffBinary(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) This gives a color representation of the difference between
	/// pix1 and pix2.  The color difference depends on the order.
	/// The pixels in pixd have 4 colors:
	/// unchanged:  black (on), white (off)
	/// on in pix1, off in pix2: red
	/// on in pix2, off in pix1: green<para/>
	///
	/// (2) This aligns the UL corners of pix1 and pix2, and crops
	/// to the overlapping pixels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDisplayDiffBinary/*"/>
	///  <param name="pix1">[in] - 1 bpp</param>
	///  <param name="pix2">[in] - 1 bpp</param>
	///   <returns>pixd 4 bpp cmapped, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayDiffBinary (Pix pix1,
								  Pix pix2)
	{
		Pix RetObj = _All.pixDisplayDiffBinary(pix1, pix2);
		return RetObj;
	}

	// compare.c (712, 1)
	// pixCompareBinary(pix1, pix2, comptype, pfract, ppixdiff) as int
	// pixCompareBinary(PIX *, PIX *, l_int32, l_float32 *, PIX **) as l_ok
	///  <summary>
	/// (1) The two images are aligned at the UL corner, and do not
	/// need to be the same size.<para/>
	///
	/// (2) If using L_COMPARE_SUBTRACT, pix2 is subtracted from pix1.<para/>
	///
	/// (3) The total number of pixels is determined by pix1.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCompareBinary/*"/>
	///  <param name="pix1">[in] - 1 bpp</param>
	///  <param name="pix2">[in] - 1 bpp</param>
	///  <param name="comptype">[in] - L_COMPARE_XOR, L_COMPARE_SUBTRACT</param>
	///  <param name="pfract">[out] - fraction of pixels that are different</param>
	///  <param name="ppixdiff">[out][optional] - pix of difference</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CompareBinary (Pix pix1,
							  Pix pix2,
							  int comptype,
							  out Single pfract,
							  out Pix ppixdiff)
	{
		int RetObj = _All.pixCompareBinary(pix1, pix2, comptype, out pfract, out ppixdiff);
		return RetObj;
	}

	// compare.c (788, 1)
	// pixCompareGrayOrRGB(pix1, pix2, comptype, plottype, psame, pdiff, prmsdiff, ppixdiff) as int
	// pixCompareGrayOrRGB(PIX *, PIX *, l_int32, l_int32, l_int32 *, l_float32 *, l_float32 *, PIX **) as l_ok
	///  <summary>
	/// (1) The two images are aligned at the UL corner, and do not
	/// need to be the same size.  If they are not the same size,
	/// the comparison will be made over overlapping pixels.<para/>
	///
	/// (2) If there is a colormap, it is removed and the result
	/// is either gray or RGB depending on the colormap.<para/>
	///
	/// (3) If RGB, each component is compared separately.<para/>
	///
	/// (4) If type is L_COMPARE_ABS_DIFF, pix2 is subtracted from pix1
	/// and the absolute value is taken.<para/>
	///
	/// (5) If type is L_COMPARE_SUBTRACT, pix2 is subtracted from pix1
	/// and the result is clipped to 0.<para/>
	///
	/// (6) The plot output types are specified in gplot.h.
	/// Use 0 if no difference plot is to be made.<para/>
	///
	/// (7) If the images are pixelwise identical, no difference
	/// plot is made, even if requested.  The result (TRUE or FALSE)
	/// is optionally returned in the parameter 'same'.<para/>
	///
	/// (8) The average difference (either subtracting or absolute value)
	/// is optionally returned in the parameter 'diff'.<para/>
	///
	/// (9) The RMS difference is optionally returned in the
	/// parameter 'rmsdiff'.  For RGB, we return the average of
	/// the RMS differences for each of the components.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCompareGrayOrRGB/*"/>
	///  <param name="pix1">[in] - 8 or 16 bpp gray, 32 bpp rgb, or colormapped</param>
	///  <param name="pix2">[in] - 8 or 16 bpp gray, 32 bpp rgb, or colormapped</param>
	///  <param name="comptype">[in] - L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF</param>
	///  <param name="plottype">[in] - gplot plot output type, or 0 for no plot</param>
	///  <param name="psame">[out][optional] - 1 if pixel values are identical</param>
	///  <param name="pdiff">[out][optional] - average difference</param>
	///  <param name="prmsdiff">[out][optional] - rms of difference</param>
	///  <param name="ppixdiff">[out][optional] - pix of difference</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CompareGrayOrRGB (Pix pix1,
								 Pix pix2,
								 int comptype,
								 int plottype,
								 out int psame,
								 out Single pdiff,
								 out Single prmsdiff,
								 out Pix ppixdiff)
	{
		int RetObj = _All.pixCompareGrayOrRGB(pix1, pix2, comptype, plottype, out psame, out pdiff, out prmsdiff, out ppixdiff);
		return RetObj;
	}

	// compare.c (859, 1)
	// pixCompareGray(pix1, pix2, comptype, plottype, psame, pdiff, prmsdiff, ppixdiff) as int
	// pixCompareGray(PIX *, PIX *, l_int32, l_int32, l_int32 *, l_float32 *, l_float32 *, PIX **) as l_ok
	///  <summary>
	/// (1) See pixCompareGrayOrRGB() for details.<para/>
	///
	/// (2) Use pixCompareGrayOrRGB() if the input pix are colormapped.<para/>
	///
	/// (3) Note: setting %plottype  is greater  0 can result in writing named
	/// output files.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCompareGray/*"/>
	///  <param name="pix1">[in] - 8 or 16 bpp, not cmapped</param>
	///  <param name="pix2">[in] - 8 or 16 bpp, not cmapped</param>
	///  <param name="comptype">[in] - L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF</param>
	///  <param name="plottype">[in] - gplot plot output type, or 0 for no plot</param>
	///  <param name="psame">[out][optional] - 1 if pixel values are identical</param>
	///  <param name="pdiff">[out][optional] - average difference</param>
	///  <param name="prmsdiff">[out][optional] - rms of difference</param>
	///  <param name="ppixdiff">[out][optional] - pix of difference</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CompareGray (Pix pix1,
							Pix pix2,
							int comptype,
							int plottype,
							out int psame,
							out Single pdiff,
							out Single prmsdiff,
							out Pix ppixdiff)
	{
		int RetObj = _All.pixCompareGray(pix1, pix2, comptype, plottype, out psame, out pdiff, out prmsdiff, out ppixdiff);
		return RetObj;
	}

	// compare.c (968, 1)
	// pixCompareRGB(pix1, pix2, comptype, plottype, psame, pdiff, prmsdiff, ppixdiff) as int
	// pixCompareRGB(PIX *, PIX *, l_int32, l_int32, l_int32 *, l_float32 *, l_float32 *, PIX **) as l_ok
	///  <summary>
	/// (1) See pixCompareGrayOrRGB() for details.<para/>
	///
	/// (2) Note: setting %plottype  is greater  0 can result in writing named
	/// output files.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCompareRGB/*"/>
	///  <param name="pix1">[in] - 32 bpp rgb</param>
	///  <param name="pix2">[in] - 32 bpp rgb</param>
	///  <param name="comptype">[in] - L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF</param>
	///  <param name="plottype">[in] - gplot plot output type, or 0 for no plot</param>
	///  <param name="psame">[out][optional] - 1 if pixel values are identical</param>
	///  <param name="pdiff">[out][optional] - average difference</param>
	///  <param name="prmsdiff">[out][optional] - rms of difference</param>
	///  <param name="ppixdiff">[out][optional] - pix of difference</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CompareRGB (Pix pix1,
						   Pix pix2,
						   int comptype,
						   int plottype,
						   out int psame,
						   out Single pdiff,
						   out Single prmsdiff,
						   out Pix ppixdiff)
	{
		int RetObj = _All.pixCompareRGB(pix1, pix2, comptype, plottype, out psame, out pdiff, out prmsdiff, out ppixdiff);
		return RetObj;
	}

	// compare.c (1124, 1)
	// pixCompareTiled(pix1, pix2, sx, sy, type, ppixdiff) as int
	// pixCompareTiled(PIX *, PIX *, l_int32, l_int32, l_int32, PIX **) as l_ok
	///  <summary>
	/// (1) With L_MEAN_ABSVAL, we compute for each tile the
	/// average abs value of the pixel component difference between
	/// the two (aligned) images.  With L_ROOT_MEAN_SQUARE, we
	/// compute instead the rms difference over all components.<para/>
	///
	/// (2) The two input pix must be the same depth.  Comparison is made
	/// using UL corner alignment.<para/>
	///
	/// (3) For 32 bpp, the distance between corresponding tiles
	/// is found by averaging the measured difference over all three
	/// components of each pixel in the tile.<para/>
	///
	/// (4) The result, pixdiff, contains one pixel for each source tile.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCompareTiled/*"/>
	///  <param name="pix1">[in] - 8 bpp or 32 bpp rgb</param>
	///  <param name="pix2">[in] - 8 bpp 32 bpp rgb</param>
	///  <param name="sx">[in] - tile size must be  is greater  1 in each dimension</param>
	///  <param name="sy">[in] - tile size must be  is greater  1 in each dimension</param>
	///  <param name="type">[in] - L_MEAN_ABSVAL or L_ROOT_MEAN_SQUARE</param>
	///  <param name="ppixdiff">[out] - pix of difference</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CompareTiled (Pix pix1,
							 Pix pix2,
							 int sx,
							 int sy,
							 int type,
							 out Pix ppixdiff)
	{
		int RetObj = _All.pixCompareTiled(pix1, pix2, sx, sy, type, out ppixdiff);
		return RetObj;
	}

	// compare.c (1218, 1)
	// pixCompareRankDifference(pix1, pix2, factor) as Numa
	// pixCompareRankDifference(PIX *, PIX *, l_int32) as NUMA *
	///  <summary>
	/// (1) This answers the question: if the pixel values in each
	/// component are compared by absolute difference, for
	/// any value of difference, what is the fraction of
	/// pixel pairs that have a difference of this magnitude
	/// or greater.  For a difference of 0, the fraction is 1.0.
	/// In this sense, it is a mapping from pixel difference to
	/// rank order of difference.<para/>
	///
	/// (2) The two images are aligned at the UL corner, and do not
	/// need to be the same size.  If they are not the same size,
	/// the comparison will be made over overlapping pixels.<para/>
	///
	/// (3) If there is a colormap, it is removed and the result
	/// is either gray or RGB depending on the colormap.<para/>
	///
	/// (4) If RGB, pixel differences for each component are aggregated
	/// into a single histogram.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCompareRankDifference/*"/>
	///  <param name="pix1">[in] - 8 bpp gray or 32 bpp rgb, or colormapped</param>
	///  <param name="pix2">[in] - 8 bpp gray or 32 bpp rgb, or colormapped</param>
	///  <param name="factor">[in] - subsampling factor use 0 or 1 for no subsampling</param>
	///   <returns>narank      numa of rank difference, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa CompareRankDifference (Pix pix1,
									   Pix pix2,
									   int factor)
	{
		Numa RetObj = _All.pixCompareRankDifference(pix1, pix2, factor);
		return RetObj;
	}

	// compare.c (1303, 1)
	// pixTestForSimilarity(pix1, pix2, factor, mindiff, maxfract, maxave, psimilar, details) as int
	// pixTestForSimilarity(PIX *, PIX *, l_int32, l_int32, l_float32, l_float32, l_int32 *, l_int32) as l_ok
	///  <summary>
	/// (1) This takes 2 pix that are the same size and determines using
	/// 3 input parameters if they are "similar".  The first parameter
	/// %mindiff establishes a criterion of pixel-to-pixel similarity:
	/// two pixels are not similar if their difference in value is
	/// at least mindiff.  Then %maxfract and %maxave are thresholds
	/// on the number and distribution of dissimilar pixels
	/// allowed for the two pix to be similar. If the pix are
	/// to be similar, neither threshold can be exceeded.<para/>
	///
	/// (2) In setting the %maxfract and %maxave thresholds, you have
	/// these options:
	/// (a) Base the comparison only on %maxfract.  Then set
	/// %maxave = 0.0 or 256.0.  (If 0, we always ignore it.)
	/// (b) Base the comparison only on %maxave.  Then set
	/// %maxfract = 1.0.
	/// (c) Base the comparison on both thresholds.<para/>
	///
	/// (3) Example of values that can be expected at mindiff = 15 when
	/// comparing lossless png encoding with jpeg encoding, q=75:
	/// (smoothish bg) fractdiff = 0.01, avediff = 2.5
	/// (natural scene)  fractdiff = 0.13, avediff = 3.5
	/// To identify these images as 'similar', select maxfract
	/// and maxave to be upper bounds of what you expect.<para/>
	///
	/// (4) See pixGetDifferenceStats() for a discussion of why we subtract
	/// mindiff from the computed average diff of the nonsimilar pixels
	/// to get the 'avediff' returned by that function.<para/>
	///
	/// (5) If there is a colormap, it is removed and the result
	/// is either gray or RGB depending on the colormap.<para/>
	///
	/// (6) If RGB, the maximum difference between pixel components is
	/// saved in the histogram.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTestForSimilarity/*"/>
	///  <param name="pix1">[in] - 8 bpp gray or 32 bpp rgb, or colormapped</param>
	///  <param name="pix2">[in] - 8 bpp gray or 32 bpp rgb, or colormapped</param>
	///  <param name="factor">[in] - subsampling factor use 0 or 1 for no subsampling</param>
	///  <param name="mindiff">[in] - minimum pixel difference to be counted  is greater  0</param>
	///  <param name="maxfract">[in] - maximum fraction of pixels allowed to have diff greater than or equal to mindiff</param>
	///  <param name="maxave">[in] - maximum average difference of pixels allowed for pixels with diff greater than or equal to mindiff, after subtracting mindiff</param>
	///  <param name="psimilar">[out] - 1 if similar, 0 otherwise</param>
	///  <param name="details">[in] - use 1 to give normalized histogram and other data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int TestForSimilarity (Pix pix1,
								  Pix pix2,
								  int factor,
								  int mindiff,
								  Single maxfract,
								  Single maxave,
								  out int psimilar,
								  int details)
	{
		int RetObj = _All.pixTestForSimilarity(pix1, pix2, factor, mindiff, maxfract, maxave, out psimilar, details);
		return RetObj;
	}

	// compare.c (1382, 1)
	// pixGetDifferenceStats(pix1, pix2, factor, mindiff, pfractdiff, pavediff, details) as int
	// pixGetDifferenceStats(PIX *, PIX *, l_int32, l_int32, l_float32 *, l_float32 *, l_int32) as l_ok
	///  <summary>
	/// (1) This takes a threshold %mindiff and describes the difference
	/// between two images in terms of two numbers:
	/// (a) the fraction of pixels, %fractdiff, whose difference
	/// equals or exceeds the threshold %mindiff, and
	/// (b) the average value %avediff of the difference in pixel value
	/// for the pixels in the set given by (a), after you subtract
	/// %mindiff.  The reason for subtracting %mindiff is that
	/// you then get a useful measure for the rate of falloff
	/// of the distribution for larger differences.  For example,
	/// if %mindiff = 10 and you find that %avediff = 2.5, it
	/// says that of the pixels with diff  is greater  10, the average of
	/// their diffs is just mindiff + 2.5 = 12.5.  This is a
	/// fast falloff in the histogram with increasing difference.<para/>
	///
	/// (2) The two images are aligned at the UL corner, and do not
	/// need to be the same size.  If they are not the same size,
	/// the comparison will be made over overlapping pixels.<para/>
	///
	/// (3) If there is a colormap, it is removed and the result
	/// is either gray or RGB depending on the colormap.<para/>
	///
	/// (4) If RGB, the maximum difference between pixel components is
	/// saved in the histogram.<para/>
	///
	/// (5) Set %details == 1 to see the difference histogram and get
	/// an output that shows for each value of %mindiff, what are the
	/// minimum values required for fractdiff and avediff in order
	/// that the two pix will be considered similar.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetDifferenceStats/*"/>
	///  <param name="pix1">[in] - 8 bpp gray or 32 bpp rgb, or colormapped</param>
	///  <param name="pix2">[in] - 8 bpp gray or 32 bpp rgb, or colormapped</param>
	///  <param name="factor">[in] - subsampling factor use 0 or 1 for no subsampling</param>
	///  <param name="mindiff">[in] - minimum pixel difference to be counted  is greater  0</param>
	///  <param name="pfractdiff">[out] - fraction of pixels with diff greater than or equal to mindiff</param>
	///  <param name="pavediff">[out] - average difference of pixels with diff greater than or equal to mindiff, less mindiff</param>
	///  <param name="details">[in] - use 1 to give normalized histogram and other data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetDifferenceStats (Pix pix1,
								   Pix pix2,
								   int factor,
								   int mindiff,
								   out Single pfractdiff,
								   out Single pavediff,
								   int details)
	{
		int RetObj = _All.pixGetDifferenceStats(pix1, pix2, factor, mindiff, out pfractdiff, out pavediff, details);
		return RetObj;
	}

	// compare.c (1484, 1)
	// pixGetDifferenceHistogram(pix1, pix2, factor) as Numa
	// pixGetDifferenceHistogram(PIX *, PIX *, l_int32) as NUMA *
	///  <summary>
	/// (1) The two images are aligned at the UL corner, and do not
	/// need to be the same size.  If they are not the same size,
	/// the comparison will be made over overlapping pixels.<para/>
	///
	/// (2) If there is a colormap, it is removed and the result
	/// is either gray or RGB depending on the colormap.<para/>
	///
	/// (3) If RGB, the maximum difference between pixel components is
	/// saved in the histogram.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetDifferenceHistogram/*"/>
	///  <param name="pix1">[in] - 8 bpp gray or 32 bpp rgb, or colormapped</param>
	///  <param name="pix2">[in] - 8 bpp gray or 32 bpp rgb, or colormapped</param>
	///  <param name="factor">[in] - subsampling factor use 0 or 1 for no subsampling</param>
	///   <returns>na     Numa of histogram of differences, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetDifferenceHistogram (Pix pix1,
										Pix pix2,
										int factor)
	{
		Numa RetObj = _All.pixGetDifferenceHistogram(pix1, pix2, factor);
		return RetObj;
	}

	// compare.c (1615, 1)
	// pixGetPerceptualDiff(pixs1, pixs2, sampling, dilation, mindiff, pfract, ppixdiff1, ppixdiff2) as int
	// pixGetPerceptualDiff(PIX *, PIX *, l_int32, l_int32, l_int32, l_float32 *, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) This takes 2 pix and determines, using 2 input parameters:
	/// %dilation specifies the amount of grayscale or color
	/// dilation to apply to the images, to compensate for
	/// a small amount of misregistration.  A typical number might
	/// be 5, which uses a 5x5 Sel.  Grayscale dilation expands
	/// lighter pixels into darker pixel regions.
	/// %mindiff determines the threshold on the difference in
	/// pixel values to be counted -- two pixels are not similar
	/// if their difference in value is at least %mindiff.  For
	/// color pixels, we use the maximum component difference.<para/>
	///
	/// (2) The pixelwise comparison is always done with the UL corners
	/// aligned.  The sizes of pix1 and pix2 need not be the same,
	/// although in practice it can be useful to scale to the same size.<para/>
	///
	/// (3) If there is a colormap, it is removed and the result
	/// is either gray or RGB depending on the colormap.<para/>
	///
	/// (4) Two optional diff images can be retrieved (typ. for debugging):
	/// pixdiff1: the gray or color difference
	/// pixdiff2: thresholded to 1 bpp for pixels exceeding %mindiff<para/>
	///
	/// (5) The returned value of fract can be compared to some threshold,
	/// which is application dependent.<para/>
	///
	/// (6) This method is in analogy to the two-sided hausdorff transform,
	/// except here it is for d  is greater  1.  For d == 1 (see pixRankHaustest()),
	/// we verify that when one pix1 is dilated, it covers at least a
	/// given fraction of the pixels in pix2, and v.v. in that
	/// case, the two pix are sufficiently similar.  Here, we
	/// do an analogous thing: subtract the dilated pix1 from pix2 to
	/// get a 1-sided hausdorff-like transform.  Then do it the
	/// other way.  Take the component-wise max of the two results,
	/// and threshold to get the fraction of pixels with a difference
	/// below the threshold.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetPerceptualDiff/*"/>
	///  <param name="pixs1">[in] - 8 bpp gray or 32 bpp rgb, or colormapped</param>
	///  <param name="pixs2">[in] - 8 bpp gray or 32 bpp rgb, or colormapped</param>
	///  <param name="sampling">[in] - subsampling factor use 0 or 1 for no subsampling</param>
	///  <param name="dilation">[in] - size of grayscale or color Sel odd</param>
	///  <param name="mindiff">[in] - minimum pixel difference to be counted  is greater  0</param>
	///  <param name="pfract">[out] - fraction of pixels with diff greater than mindiff</param>
	///  <param name="ppixdiff1">[out][optional] - showing difference (gray or color)</param>
	///  <param name="ppixdiff2">[out][optional] - showing pixels of sufficient diff</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetPerceptualDiff (Pix pixs1,
								  Pix pixs2,
								  int sampling,
								  int dilation,
								  int mindiff,
								  out Single pfract,
								  out Pix ppixdiff1,
								  out Pix ppixdiff2)
	{
		int RetObj = _All.pixGetPerceptualDiff(pixs1, pixs2, sampling, dilation, mindiff, out pfract, out ppixdiff1, out ppixdiff2);
		return RetObj;
	}

	// compare.c (1778, 1)
	// pixGetPSNR(pix1, pix2, factor, ppsnr) as int
	// pixGetPSNR(PIX *, PIX *, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// (1) This computes the power S/N ratio, in dB, for the difference
	/// between two images.  By convention, the power S/N
	/// for a grayscale image is ('log' == log base 10,
	/// and 'ln == log base e):
	/// PSNR = 10  log((255/MSE)^2)
	/// = 4.3429  ln((255/MSE)^2)
	/// = -4.3429  ln((MSE/255)^2)
	/// where MSE is the mean squared error.
	/// Here are some examples:
	/// MSE   PSNR
	/// ---   ----
	/// 10  28.1
	/// 3   38.6
	/// 1   48.1
	/// 0.1   68.1<para/>
	///
	/// (2) If pix1 and pix2 have the same pixel values, the MSE = 0.0
	/// and the PSNR is infinity.  For that case, this returns
	/// PSNR = 1000, which corresponds to the very small MSE of
	/// about 10^(-48).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetPSNR/*"/>
	///  <param name="pix1">[in] - 8 or 32 bpp no colormap</param>
	///  <param name="pix2">[in] - 8 or 32 bpp no colormap</param>
	///  <param name="factor">[in] - sampling factor greater or equal 1</param>
	///  <param name="ppsnr">[out] - power signal/noise ratio difference</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetPSNR (Pix pix1,
						Pix pix2,
						int factor,
						out Single ppsnr)
	{
		int RetObj = _All.pixGetPSNR(pix1, pix2, factor, out ppsnr);
		return RetObj;
	}

	// compare.c (2104, 1)
	// pixComparePhotoRegionsByHisto(pix1, pix2, box1, box2, minratio, factor, nx, ny, pscore, debugflag) as int
	// pixComparePhotoRegionsByHisto(PIX *, PIX *, BOX *, BOX *, l_float32, l_int32, l_int32, l_int32, l_float32 *, l_int32) as l_ok
	///  <summary>
	/// (1) This function compares two grayscale photo regions.  If a
	/// box is given, the region is clipped otherwise assume
	/// the entire images are photo regions.  This is done with a
	/// set of (nx  ny) spatially aligned histograms, which are
	/// aligned using the centroid of the inverse image.<para/>
	///
	/// (2) An initial filter gives %score = 0 if the ratio of widths
	/// and heights (smallest / largest) does not exceed a
	/// threshold %minratio.  This must be between 0.5 and 1.0.
	/// If set at 1.0, both images must be exactly the same size.
	/// A typical value for %minratio is 0.9.<para/>
	///
	/// (3) Because this function should not be used on text or
	/// line graphics, which can give false positive results
	/// (i.e., high scores for different images), filter the images
	/// using pixGenPhotoHistos(), which returns tiled histograms
	/// only if an image is not text and comparison is expected
	/// to work with histograms.  If either image fails the test,
	/// the comparison returns a score of 0.0.<para/>
	///
	/// (4) The white value counts in the histograms are removed they
	/// are typically pixels that were padded to achieve alignment.<para/>
	///
	/// (5) For an efficient representation of the histogram, normalize
	/// using a multiplicative factor so that the number in the
	/// maximum bucket is 255.  It then takes 256 bytes to store.<para/>
	///
	/// (6) When comparing the histograms of two regions, use the
	/// Earth Mover distance (EMD), with the histograms normalized
	/// so that the sum over bins is the same.  Further normalize
	/// by dividing by 255, so that the result is in [0.0 ... 1.0].<para/>
	///
	/// (7) Get a similarity score S = 1.0 - k  D, where
	/// k is a constant, say in the range 5-10
	/// D = normalized EMD
	/// and for multiple tiles, take the Min(S) to be the final score.
	/// Using aligned tiles gives protection against accidental
	/// similarity of the overall grayscale histograms.
	/// A small number of aligned tiles works well.<para/>
	///
	/// (8) With debug on, you get a pdf that shows, for each tile,
	/// the images, histograms and score.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixComparePhotoRegionsByHisto/*"/>
	///  <param name="pix1">[in] - any depth colormap OK</param>
	///  <param name="pix2">[in] - any depth colormap OK</param>
	///  <param name="box1">[in][optional] - photo regions from each can be null</param>
	///  <param name="box2">[in][optional] - photo regions from each can be null</param>
	///  <param name="minratio">[in] - requiring sizes be compatible  is smaller 1.0</param>
	///  <param name="factor">[in] - subsampling factor greater or equal 1</param>
	///  <param name="nx">[in] - num subregions to use for histograms e.g. 3x3</param>
	///  <param name="ny">[in] - num subregions to use for histograms e.g. 3x3</param>
	///  <param name="pscore">[out] - similarity score of histograms</param>
	///  <param name="debugflag">[in] - 1 for debug output 0 for no debugging</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ComparePhotoRegionsByHisto (Pix pix1,
										   Pix pix2,
										   Single minratio,
										   int factor,
										   int nx,
										   int ny,
										   out Single pscore,
										   int debugflag,
										   Box box1,
										   Box box2)
	{
		int RetObj = _All.pixComparePhotoRegionsByHisto(pix1, pix2, box1, box2, minratio, factor, nx, ny, out pscore, debugflag);
		return RetObj;
	}

	// compare.c (2214, 1)
	// pixGenPhotoHistos(pixs, box, factor, thresh, nx, ny, pnaa, pw, ph, debugindex) as int
	// pixGenPhotoHistos(PIX *, BOX *, l_int32, l_float32, l_int32, l_int32, NUMAA **, l_int32 *, l_int32 *, l_int32) as l_ok
	///  <summary>
	/// (1) This crops and converts to 8 bpp if necessary.  It adds a
	/// minimal white boundary such that the centroid of the
	/// photo-inverted image is in the center. This allows
	/// automatic alignment with histograms of other image regions.<para/>
	///
	/// (2) The white value in the histogram is removed, because of
	/// the padding.<para/>
	///
	/// (3) Use 0 for conservative default (1.3) for thresh.<para/>
	///
	/// (4) For an efficient representation of the histogram, normalize
	/// using a multiplicative factor so that the number in the
	/// maximum bucket is 255.  It then takes 256 bytes to store.<para/>
	///
	/// (5) With %debugindex  is greater  0, this makes a pdf that shows, for each tile,
	/// the images and histograms.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenPhotoHistos/*"/>
	///  <param name="box">[in][optional] - region to be selected can be null</param>
	///  <param name="factor">[in] - subsampling greater or equal 1</param>
	///  <param name="thresh">[in] - threshold for photo/text use 0 for default</param>
	///  <param name="nx">[in] - number of subregions to use for histograms e.g. 3x3</param>
	///  <param name="ny">[in] - number of subregions to use for histograms e.g. 3x3</param>
	///  <param name="pnaa">[out] - nx  ny 256-entry gray histograms</param>
	///  <param name="pw">[out] - width of image used to make histograms</param>
	///  <param name="ph">[out] - height of image used to make histograms</param>
	///  <param name="debugindex">[in] - 0 for no debugging positive integer otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GenPhotoHistos (int factor,
							   Single thresh,
							   int nx,
							   int ny,
							   out Numaa pnaa,
							   out int pw,
							   out int ph,
							   int debugindex,
							   Box box)
	{
		int RetObj = _All.pixGenPhotoHistos(this, box, factor, thresh, nx, ny, out pnaa, out pw, out ph, debugindex);
		return RetObj;
	}

	// compare.c (2326, 1)
	// pixPadToCenterCentroid(pixs, factor) as Pix
	// pixPadToCenterCentroid(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This add minimum white padding to an 8 bpp pix, such that
	/// the centroid of the photometric inverse is in the center of
	/// the resulting image.  Thus in computing the centroid,
	/// black pixels have weight 255, and white pixels have weight 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixPadToCenterCentroid/*"/>
	///  <param name="factor">[in] - subsampling for centroid greater or equal 1</param>
	///   <returns>pixd padded with white pixels, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix PadToCenterCentroid (int factor)
	{
		Pix RetObj = _All.pixPadToCenterCentroid(this, factor);
		return RetObj;
	}

	// compare.c (2380, 1)
	// pixCentroid8(pixs, factor, pcx, pcy) as int
	// pixCentroid8(PIX *, l_int32, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) This first does a photometric inversion (black = 255, white = 0).
	/// It then finds the centroid of the result.  The inversion is
	/// done because white is usually background, so the centroid
	/// is computed based on the "foreground" gray pixels, and the
	/// darker the pixel, the more weight it is given.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCentroid8/*"/>
	///  <param name="factor">[in] - subsampling factor greater or equal 1</param>
	///  <param name="pcx">[out] - x value of centroid</param>
	///  <param name="pcy">[out] - y value of centroid</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Centroid8 (int factor,
						  out Single pcx,
						  out Single pcy)
	{
		int RetObj = _All.pixCentroid8(this, factor, out pcx, out pcy);
		return RetObj;
	}

	// compare.c (2458, 1)
	// pixDecideIfPhotoImage(pix, factor, nx, ny, thresh, pnaa, pixadebug) as int
	// pixDecideIfPhotoImage(PIX *, l_int32, l_int32, l_int32, l_float32, NUMAA **, PIXA *) as l_ok
	///  <summary>
	/// (1) The input image must be 8 bpp (no colormap), and padded with
	/// white pixels so the centroid of photo-inverted pixels is at
	/// the center of the image.<para/>
	///
	/// (2) If the pix is not almost certainly a photoimage, the returned
	/// histograms (%naa) are null.<para/>
	///
	/// (3) If histograms are generated, the white (255) count is set
	/// to 0.  This removes all pixels values above 230, including
	/// white padding from the centroid matching operation, from
	/// consideration.  The resulting histograms are then normalized
	/// so the maximum count is 255.<para/>
	///
	/// (4) Default for %thresh is 1.3 this seems sufficiently conservative.<para/>
	///
	/// (5) Use %pixadebug == NULL unless debug output is requested.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDecideIfPhotoImage/*"/>
	///  <param name="pix">[in] - 8 bpp, centroid in center</param>
	///  <param name="factor">[in] - subsampling for histograms greater or equal 1</param>
	///  <param name="nx">[in] - number of subregions to use for histograms</param>
	///  <param name="ny">[in] - number of subregions to use for histograms</param>
	///  <param name="thresh">[in] - threshold for photo/text use 0 for default</param>
	///  <param name="pnaa">[out] - array of normalized histograms</param>
	///  <param name="pixadebug">[in][optional] - use only for debug output</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int DecideIfPhotoImage (Pix pix,
								   int factor,
								   int nx,
								   int ny,
								   Single thresh,
								   out Numaa pnaa,
								   Pixa pixadebug)
	{
		int RetObj = _All.pixDecideIfPhotoImage(pix, factor, nx, ny, thresh, out pnaa, pixadebug);
		return RetObj;
	}

	// compare.c (2758, 1)
	// pixCompareGrayByHisto(pix1, pix2, box1, box2, minratio, maxgray, factor, nx, ny, pscore, debugflag) as int
	// pixCompareGrayByHisto(PIX *, PIX *, BOX *, BOX *, l_float32, l_int32, l_int32, l_int32, l_int32, l_float32 *, l_int32) as l_ok
	///  <summary>
	/// (1) This function compares two grayscale photo regions.  It can
	/// do it with a single histogram from each region, or with a
	/// set of (nx  ny) spatially aligned histograms.  For both
	/// cases, align the regions using the centroid of the inverse
	/// image, and crop to the smallest of the two.<para/>
	///
	/// (2) An initial filter gives %score = 0 if the ratio of widths
	/// and heights (smallest / largest) does not exceed a
	/// threshold %minratio.  This must be between 0.5 and 1.0.
	/// If set at 1.0, both images must be exactly the same size.
	/// A typical value for %minratio is 0.9.<para/>
	///
	/// (3) The lightest values in the histogram can be disregarded.
	/// Set %maxgray to the lightest value to be kept.  For example,
	/// to eliminate white (255), set %maxgray = 254.  %maxgray must
	/// be greater or equal 200.<para/>
	///
	/// (4) For an efficient representation of the histogram, normalize
	/// using a multiplicative factor so that the number in the
	/// maximum bucket is 255.  It then takes 256 bytes to store.<para/>
	///
	/// (5) When comparing the histograms of two regions:
	/// ~ Use %maxgray = 254 to ignore the white pixels, the number
	/// of which may be sensitive to the crop region if the pixels
	/// outside that region are white.
	/// ~ Use the Earth Mover distance (EMD), with the histograms
	/// normalized so that the sum over bins is the same.
	/// Further normalize by dividing by 255, so that the result
	/// is in [0.0 ... 1.0].<para/>
	///
	/// (6) Get a similarity score S = 1.0 - k  D, where
	/// k is a constant, say in the range 5-10
	/// D = normalized EMD
	/// and for multiple tiles, take the Min(S) to be the final score.
	/// Using aligned tiles gives protection against accidental
	/// similarity of the overall grayscale histograms.
	/// A small number of aligned tiles works well.<para/>
	///
	/// (7) With debug on, you get a pdf that shows, for each tile,
	/// the images, histograms and score.<para/>
	///
	/// (8) When to use:
	/// (a) Because this function should not be used on text or
	/// line graphics, which can give false positive results
	/// (i.e., high scores for different images), the input
	/// images should be filtered.
	/// (b) To filter, first use pixDecideIfText().  If that function
	/// says the image is text, do not use it.  If the function
	/// says it is not text, it still may be line graphics, and
	/// in that case, use:
	/// pixGetGrayHistogramTiled()
	/// grayInterHistogramStats()
	/// to determine whether it is photo or line graphics.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCompareGrayByHisto/*"/>
	///  <param name="pix1">[in] - any depth colormap OK</param>
	///  <param name="pix2">[in] - any depth colormap OK</param>
	///  <param name="box1">[in][optional] - region selected from each can be null</param>
	///  <param name="box2">[in][optional] - region selected from each can be null</param>
	///  <param name="minratio">[in] - requiring sizes be compatible  is smaller 1.0</param>
	///  <param name="maxgray">[in] - max value to keep in histo greater or equal 200, 255 to keep all</param>
	///  <param name="factor">[in] - subsampling factor greater or equal 1</param>
	///  <param name="nx">[in] - num subregions to use for histograms e.g. 3x3</param>
	///  <param name="ny">[in] - num subregions to use for histograms e.g. 3x3</param>
	///  <param name="pscore">[out] - similarity score of histograms</param>
	///  <param name="debugflag">[in] - 1 for debug output 0 for no debugging</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CompareGrayByHisto (Pix pix1,
								   Pix pix2,
								   Single minratio,
								   int maxgray,
								   int factor,
								   int nx,
								   int ny,
								   out Single pscore,
								   int debugflag,
								   Box box1,
								   Box box2)
	{
		int RetObj = _All.pixCompareGrayByHisto(pix1, pix2, box1, box2, minratio, maxgray, factor, nx, ny, out pscore, debugflag);
		return RetObj;
	}

	// compare.c (3011, 1)
	// pixCropAlignedToCentroid(pix1, pix2, factor, pbox1, pbox2) as int
	// pixCropAlignedToCentroid(PIX *, PIX *, l_int32, BOX **, BOX **) as l_ok
	///  <summary>
	/// (1) This finds the maximum crop boxes for two 8 bpp images when
	/// their centroids of their photometric inverses are aligned.
	/// Black pixels have weight 255 white pixels have weight 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCropAlignedToCentroid/*"/>
	///  <param name="pix1">[in] - any depth colormap OK</param>
	///  <param name="pix2">[in] - any depth colormap OK</param>
	///  <param name="factor">[in] - subsampling greater or equal 1</param>
	///  <param name="pbox1">[out] - crop box for pix1</param>
	///  <param name="pbox2">[out] - crop box for pix2</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CropAlignedToCentroid (Pix pix1,
									  Pix pix2,
									  int factor,
									  out Box pbox1,
									  out Box pbox2)
	{
		int RetObj = _All.pixCropAlignedToCentroid(pix1, pix2, factor, out pbox1, out pbox2);
		return RetObj;
	}

	// compare.c (3223, 1)
	// pixCompareWithTranslation(pix1, pix2, thresh, pdelx, pdely, pscore, debugflag) as int
	// pixCompareWithTranslation(PIX *, PIX *, l_int32, l_int32 *, l_int32 *, l_float32 *, l_int32) as l_ok
	///  <summary>
	/// (1) This does a coarse-to-fine search for best translational
	/// alignment of two images, measured by a scoring function
	/// that is the correlation between the fg pixels.<para/>
	///
	/// (2) The threshold is used if the images aren't 1 bpp.<para/>
	///
	/// (3) With debug on, you get a pdf that shows, as a grayscale
	/// image, the score as a function of shift from the initial
	/// estimate, for each of the four levels.  The shift is 0 at
	/// the center of the image.<para/>
	///
	/// (4) With debug on, you also get a pdf that shows the
	/// difference at the best alignment between the two images,
	/// at each of the four levels.  The red and green pixels
	/// show locations where one image has a fg pixel and the
	/// other doesn't.  The black pixels are where both images
	/// have fg pixels, and white pixels are where neither image
	/// has fg pixels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCompareWithTranslation/*"/>
	///  <param name="pix1">[in] - any depth colormap OK</param>
	///  <param name="pix2">[in] - any depth colormap OK</param>
	///  <param name="thresh">[in] - threshold for converting to 1 bpp</param>
	///  <param name="pdelx">[out] - x translation on pix2 to align with pix1</param>
	///  <param name="pdely">[out] - y translation on pix2 to align with pix1</param>
	///  <param name="pscore">[out] - correlation score at best alignment</param>
	///  <param name="debugflag">[in] - 1 for debug output 0 for no debugging</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CompareWithTranslation (Pix pix1,
									   Pix pix2,
									   int thresh,
									   out int pdelx,
									   out int pdely,
									   out Single pscore,
									   int debugflag)
	{
		int RetObj = _All.pixCompareWithTranslation(pix1, pix2, thresh, out pdelx, out pdely, out pscore, debugflag);
		return RetObj;
	}

	// compare.c (3377, 1)
	// pixBestCorrelation(pix1, pix2, area1, area2, etransx, etransy, maxshift, tab8, pdelx, pdely, pscore, debugflag) as int
	// pixBestCorrelation(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *, l_float32 *, l_int32) as l_ok
	///  <summary>
	/// (1) This maximizes the correlation score between two 1 bpp images,
	/// by starting with an estimate of the alignment
	/// (%etransx, %etransy) and computing the correlation around this.
	/// It optionally returns the shift (%delx, %dely) that maximizes
	/// the correlation score when pix2 is shifted by this amount
	/// relative to pix1.<para/>
	///
	/// (2) Get the centroids of pix1 and pix2, using pixCentroid(),
	/// to compute (%etransx, %etransy).  Get the areas using
	/// pixCountPixels().<para/>
	///
	/// (3) The centroid of pix2 is shifted with respect to the centroid
	/// of pix1 by all values between -maxshiftx and maxshiftx,
	/// and likewise for the y shifts.  Therefore, the number of
	/// correlations computed is:
	/// (2  maxshiftx + 1)  (2  maxshifty + 1)
	/// Consequently, if pix1 and pix2 are large, you should do this
	/// in a coarse-to-fine sequence.  See the use of this function
	/// in pixCompareWithTranslation().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBestCorrelation/*"/>
	///  <param name="pix1">[in] - 1 bpp</param>
	///  <param name="pix2">[in] - 1 bpp</param>
	///  <param name="area1">[in] - number of on pixels in pix1</param>
	///  <param name="area2">[in] - number of on pixels in pix2</param>
	///  <param name="etransx">[in] - estimated x translation of pix2 to align with pix1</param>
	///  <param name="etransy">[in] - estimated y translation of pix2 to align with pix1</param>
	///  <param name="maxshift">[in] - max x and y shift of pix2, around the estimated alignment location, relative to pix1</param>
	///  <param name="tab8">[in][optional] - sum tab for ON pixels in byte can be NULL</param>
	///  <param name="pdelx">[out][optional] - best x shift of pix2 relative to pix1</param>
	///  <param name="pdely">[out][optional] - best y shift of pix2 relative to pix1</param>
	///  <param name="pscore">[out][optional] - maximum score found can be NULL</param>
	///  <param name="debugflag">[in] - smaller or equal 0 to skip positive to generate output. The integer is used to label the debug image.</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int BestCorrelation (Pix pix1,
								Pix pix2,
								int area1,
								int area2,
								int etransx,
								int etransy,
								int maxshift,
								int debugflag,
								int[] tab8,
								out int pdelx,
								out int pdely,
								out Single pscore)
	{
		int RetObj = _All.pixBestCorrelation(pix1, pix2, area1, area2, etransx, etransy, maxshift, tab8, out pdelx, out pdely, out pscore, debugflag);
		return RetObj;
	}

	// conncomp.c (144, 1)
	// pixConnComp(pixs, ppixa, connectivity) as Boxa
	// pixConnComp(PIX *, PIXA **, l_int32) as BOXA *
	///  <summary>
	/// (1) This is the top-level call for getting bounding boxes or
	/// a pixa of the components, and it can be used instead
	/// of either pixConnCompBB() or pixConnCompPixa(), rsp.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConnComp/*"/>
	///  <param name="ppixa">[out][optional] - pixa of each c.c.</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa ConnComp (int connectivity,
						  out Pixa ppixa)
	{
		Boxa RetObj = _All.pixConnComp(this, out ppixa, connectivity);
		return RetObj;
	}

	// conncomp.c (190, 1)
	// pixConnCompPixa(pixs, ppixa, connectivity) as Boxa
	// pixConnCompPixa(PIX *, PIXA **, l_int32) as BOXA *
	///  <summary>
	/// (1) This finds bounding boxes of 4- or 8-connected components
	/// in a binary image, and saves images of each c.c
	/// in a pixa array.<para/>
	///
	/// (2) It sets up 2 temporary pix, and for each c.c. that is
	/// located in raster order, it erases the c.c. from one pix,
	/// then uses the b.b. to extract the c.c. from the two pix using
	/// an XOR, and finally erases the c.c. from the second pix.<para/>
	///
	/// (3) A clone of the returned boxa (where all boxes in the array
	/// are clones) is inserted into the pixa.<para/>
	///
	/// (4) If the input is valid, this always returns a boxa and a pixa.
	/// If pixs is empty, the boxa and pixa will be empty.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConnCompPixa/*"/>
	///  <param name="ppixa">[out] - pixa of each c.c.</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa ConnCompPixa (out Pixa ppixa,
							  int connectivity)
	{
		Boxa RetObj = _All.pixConnCompPixa(this, out ppixa, connectivity);
		return RetObj;
	}

	// conncomp.c (304, 1)
	// pixConnCompBB(pixs, connectivity) as Boxa
	// pixConnCompBB(PIX *, l_int32) as BOXA *
	///  <summary>
	/// (1) Finds bounding boxes of 4- or 8-connected components
	/// in a binary image.<para/>
	///
	/// (2) This works on a copy of the input pix.  The c.c. are located
	/// in raster order and erased one at a time.  In the process,
	/// the b.b. is computed and saved.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConnCompBB/*"/>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa ConnCompBB (int connectivity)
	{
		Boxa RetObj = _All.pixConnCompBB(this, connectivity);
		return RetObj;
	}

	// conncomp.c (387, 1)
	// pixCountConnComp(pixs, connectivity, pcount) as int
	// pixCountConnComp(PIX *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// pixCountConnComp()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCountConnComp/*"/>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="pcount">[out] - </param>
	///   <returns>0 if OK, 1 on error Notes: (1 This is the top-level call for getting the number of 4- or 8-connected components in a 1 bpp image. 2 It works on a copy of the input pix.  The c.c. are located in raster order and erased one at a time.</returns>
	// CreateAdditiveFunction: Function/Else
	public int CountConnComp (int connectivity,
							  out int pcount)
	{
		int RetObj = _All.pixCountConnComp(this, connectivity, out pcount);
		return RetObj;
	}

	// conncomp.c (560, 1)
	// pixSeedfillBB(pixs, stack, x, y, connectivity) as Box
	// pixSeedfillBB(PIX *, L_STACK *, l_int32, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) This is the high-level interface to Paul Heckbert's
	/// stack-based seedfill algorithm.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfillBB/*"/>
	///  <param name="stack">[in] - for holding fillsegs</param>
	///  <param name="x">[in] - ,y   location of seed pixel</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>box or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box SeedfillBB (L_Stack stack,
						   int x,
						   int y,
						   int connectivity)
	{
		Box RetObj = _All.pixSeedfillBB(this, stack, x, y, connectivity);
		return RetObj;
	}

	// conncomp.c (623, 1)
	// pixSeedfill4BB(pixs, stack, x, y) as Box
	// pixSeedfill4BB(PIX *, L_STACK *, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.<para/>
	///
	/// (2) This operates on the input 1 bpp pix to remove the fg seed
	/// pixel, at (x,y), and all pixels that are 4-connected to it.
	/// The seed pixel at (x,y) must initially be ON.<para/>
	///
	/// (3) Returns the bounding box of the erased 4-cc component.<para/>
	///
	/// (4) Reference: see Paul Heckbert's stack-based seed fill algorithm
	/// in "Graphic Gems", ed. Andrew Glassner, Academic
	/// Press, 1990.  The algorithm description is given
	/// on pp. 275-277 working C code is on pp. 721-722.)
	/// The code here follows Heckbert's exactly, except
	/// we use function calls instead of macros for
	/// pushing data on and popping data off the stack.
	/// This makes sense to do because Heckbert's fixed-size
	/// stack with macros is dangerous: images exist that
	/// will overrun the stack and crash. The stack utility
	/// here grows dynamically as needed, and the fillseg
	/// structures that are not in use are stored in another
	/// stack for reuse.  It should be noted that the
	/// overhead in the function calls (vs. macros) is negligible.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfill4BB/*"/>
	///  <param name="stack">[in] - for holding fillsegs</param>
	///  <param name="x">[in] - ,y   location of seed pixel</param>
	///   <returns>box or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Box Seedfill4BB (L_Stack stack,
							int x,
							int y)
	{
		Box RetObj = _All.pixSeedfill4BB(this, stack, x, y);
		return RetObj;
	}

	// conncomp.c (738, 1)
	// pixSeedfill8BB(pixs, stack, x, y) as Box
	// pixSeedfill8BB(PIX *, L_STACK *, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.<para/>
	///
	/// (2) This operates on the input 1 bpp pix to remove the fg seed
	/// pixel, at (x,y), and all pixels that are 8-connected to it.
	/// The seed pixel at (x,y) must initially be ON.<para/>
	///
	/// (3) Returns the bounding box of the erased 8-cc component.<para/>
	///
	/// (4) Reference: see Paul Heckbert's stack-based seed fill algorithm
	/// in "Graphic Gems", ed. Andrew Glassner, Academic
	/// Press, 1990.  The algorithm description is given
	/// on pp. 275-277 working C code is on pp. 721-722.)
	/// The code here follows Heckbert's closely, except
	/// the leak checks are changed for 8 connectivity.
	/// See comments on pixSeedfill4BB() for more details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfill8BB/*"/>
	///  <param name="stack">[in] - for holding fillsegs</param>
	///  <param name="x">[in] - ,y   location of seed pixel</param>
	///   <returns>box or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Box Seedfill8BB (L_Stack stack,
							int x,
							int y)
	{
		Box RetObj = _All.pixSeedfill8BB(this, stack, x, y);
		return RetObj;
	}

	// conncomp.c (844, 1)
	// pixSeedfill(pixs, stack, x, y, connectivity) as int
	// pixSeedfill(PIX *, L_STACK *, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This removes the component from pixs with a fg pixel at (x,y).<para/>
	///
	/// (2) See pixSeedfill4() and pixSeedfill8() for details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfill/*"/>
	///  <param name="stack">[in] - for holding fillsegs</param>
	///  <param name="x">[in] - ,y   location of seed pixel</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Seedfill (L_Stack stack,
						 int x,
						 int y,
						 int connectivity)
	{
		int RetObj = _All.pixSeedfill(this, stack, x, y, connectivity);
		return RetObj;
	}

	// conncomp.c (888, 1)
	// pixSeedfill4(pixs, stack, x, y) as int
	// pixSeedfill4(PIX *, L_STACK *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.<para/>
	///
	/// (2) This operates on the input 1 bpp pix to remove the fg seed
	/// pixel, at (x,y), and all pixels that are 4-connected to it.
	/// The seed pixel at (x,y) must initially be ON.<para/>
	///
	/// (3) Reference: see pixSeedFill4BB()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfill4/*"/>
	///  <param name="stack">[in] - for holding fillsegs</param>
	///  <param name="x">[in] - ,y   location of seed pixel</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Seedfill4 (L_Stack stack,
						  int x,
						  int y)
	{
		int RetObj = _All.pixSeedfill4(this, stack, x, y);
		return RetObj;
	}

	// conncomp.c (982, 1)
	// pixSeedfill8(pixs, stack, x, y) as int
	// pixSeedfill8(PIX *, L_STACK *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.<para/>
	///
	/// (2) This operates on the input 1 bpp pix to remove the fg seed
	/// pixel, at (x,y), and all pixels that are 8-connected to it.
	/// The seed pixel at (x,y) must initially be ON.<para/>
	///
	/// (3) Reference: see pixSeedFill8BB()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfill8/*"/>
	///  <param name="stack">[in] - for holding fillsegs</param>
	///  <param name="x">[in] - ,y   location of seed pixel</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Seedfill8 (L_Stack stack,
						  int x,
						  int y)
	{
		int RetObj = _All.pixSeedfill8(this, stack, x, y);
		return RetObj;
	}

	// convolve.c (127, 1)
	// pixBlockconv(pix, wc, hc) as Pix
	// pixBlockconv(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The full width and height of the convolution kernel
	/// are (2  wc + 1) and (2  hc + 1)<para/>
	///
	/// (2) Returns a copy if both wc and hc are 0<para/>
	///
	/// (3) Require that w greater or equal 2  wc + 1 and h greater or equal 2  hc + 1,
	/// where (w,h) are the dimensions of pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlockconv/*"/>
	///  <param name="pix">[in] - 8 or 32 bpp or 2, 4 or 8 bpp with colormap</param>
	///  <param name="wc">[in] - half width/height of convolution kernel</param>
	///  <param name="hc">[in] - half width/height of convolution kernel</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Blockconv (int wc,
						  int hc,
						  Pix pix)
	{
		Pix RetObj = _All.pixBlockconv(pix, wc, hc);
		return RetObj;
	}

	// convolve.c (210, 1)
	// pixBlockconvGray(pixs, pixacc, wc, hc) as Pix
	// pixBlockconvGray(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) If accum pix is null, make one and destroy it before
	/// returning otherwise, just use the input accum pix.<para/>
	///
	/// (2) The full width and height of the convolution kernel
	/// are (2  wc + 1) and (2  hc + 1).<para/>
	///
	/// (3) Returns a copy if both wc and hc are 0.<para/>
	///
	/// (4) Require that w greater or equal 2  wc + 1 and h greater or equal 2  hc + 1,
	/// where (w,h) are the dimensions of pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlockconvGray/*"/>
	///  <param name="pixacc">[in] - pix 32 bpp can be null</param>
	///  <param name="wc">[in] - half width/height of convolution kernel</param>
	///  <param name="hc">[in] - half width/height of convolution kernel</param>
	///   <returns>pix 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlockconvGray (Pix pixacc,
							  int wc,
							  int hc)
	{
		Pix RetObj = _All.pixBlockconvGray(this, pixacc, wc, hc);
		return RetObj;
	}

	// convolve.c (455, 1)
	// pixBlockconvAccum(pixs) as Pix
	// pixBlockconvAccum(PIX *) as PIX *
	///  <summary>
	/// (1) The general recursion relation is
	/// a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)
	/// For the first line, this reduces to the special case
	/// a(i,j) = v(i,j) + a(i, j-1)
	/// For the first column, the special case is
	/// a(i,j) = v(i,j) + a(i-1, j)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlockconvAccum/*"/>
	///   <returns>accum pix 32 bpp, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlockconvAccum ()
	{
		Pix RetObj = _All.pixBlockconvAccum(this);
		return RetObj;
	}

	// convolve.c (636, 1)
	// pixBlockconvGrayUnnormalized(pixs, wc, hc) as Pix
	// pixBlockconvGrayUnnormalized(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The full width and height of the convolution kernel
	/// are (2  wc + 1) and (2  hc + 1).<para/>
	///
	/// (2) Require that w greater or equal 2  wc + 1 and h greater or equal 2  hc + 1,
	/// where (w,h) are the dimensions of pixs.<para/>
	///
	/// (3) Returns a copy if both wc and hc are 0.<para/>
	///
	/// (3) Adds mirrored border to avoid treating the boundary pixels
	/// specially.  Note that we add wc + 1 pixels to the left
	/// and wc to the right.  The added width is 2  wc + 1 pixels,
	/// and the particular choice simplifies the indexing in the loop.
	/// Likewise, add hc + 1 pixels to the top and hc to the bottom.<para/>
	///
	/// (4) To get the normalized result, divide by the area of the
	/// convolution kernel: (2  wc + 1)  (2  hc + 1)
	/// Specifically, do this:
	/// pixc = pixBlockconvGrayUnnormalized(pixs, wc, hc)
	/// fract = 1. / ((2  wc + 1)  (2  hc + 1))
	/// pixMultConstantGray(pixc, fract)
	/// pixd = pixGetRGBComponent(pixc, L_ALPHA_CHANNEL)<para/>
	///
	/// (5) Unlike pixBlockconvGray(), this always computes the accumulation
	/// pix because its size is tied to wc and hc.<para/>
	///
	/// (6) Compare this implementation with pixBlockconvGray(), where
	/// most of the code in blockconvLow() is special casing for
	/// efficiently handling the boundary.  Here, the use of
	/// mirrored borders and destination indexing makes the
	/// implementation very simple.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlockconvGrayUnnormalized/*"/>
	///  <param name="wc">[in] - half width/height of convolution kernel</param>
	///  <param name="hc">[in] - half width/height of convolution kernel</param>
	///   <returns>pix 32 bpp containing the convolution without normalizing for the window size, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlockconvGrayUnnormalized (int wc,
										  int hc)
	{
		Pix RetObj = _All.pixBlockconvGrayUnnormalized(this, wc, hc);
		return RetObj;
	}

	// convolve.c (727, 1)
	// pixBlockconvTiled(pix, wc, hc, nx, ny) as Pix
	// pixBlockconvTiled(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The full width and height of the convolution kernel
	/// are (2  wc + 1) and (2  hc + 1)<para/>
	///
	/// (2) Returns a copy if both wc and hc are 0<para/>
	///
	/// (3) Require that w greater or equal 2  wc + 1 and h greater or equal 2  hc + 1,
	/// where (w,h) are the dimensions of pixs.<para/>
	///
	/// (4) For nx == ny == 1, this defaults to pixBlockconv(), which
	/// is typically about twice as fast, and gives nearly
	/// identical results as pixBlockconvGrayTile().<para/>
	///
	/// (5) If the tiles are too small, nx and/or ny are reduced
	/// a minimum amount so that the tiles are expanded to the
	/// smallest workable size in the problematic direction(s).<para/>
	///
	/// (6) Why a tiled version?  Three reasons:
	/// (a) Because the accumulator is a uint32, overflow can occur
	/// for an image with more than 16M pixels.
	/// (b) The accumulator array for 16M pixels is 64 MB using
	/// tiles reduces the size of this array.
	/// (c) Each tile can be processed independently, in parallel,
	/// on a multicore processor.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlockconvTiled/*"/>
	///  <param name="pix">[in] - 8 or 32 bpp or 2, 4 or 8 bpp with colormap</param>
	///  <param name="wc">[in] - half width/height of convolution kernel</param>
	///  <param name="hc">[in] - half width/height of convolution kernel</param>
	///  <param name="nx">[in] - subdivision into tiles</param>
	///  <param name="ny">[in] - subdivision into tiles</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlockconvTiled (int wc,
							   int hc,
							   int nx,
							   int ny,
							   Pix pix)
	{
		Pix RetObj = _All.pixBlockconvTiled(pix, wc, hc, nx, ny);
		return RetObj;
	}

	// convolve.c (853, 1)
	// pixBlockconvGrayTile(pixs, pixacc, wc, hc) as Pix
	// pixBlockconvGrayTile(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The full width and height of the convolution kernel
	/// are (2  wc + 1) and (2  hc + 1)<para/>
	///
	/// (2) Assumes that the input pixs is padded with (wc + 1) pixels on
	/// left and right, and with (hc + 1) pixels on top and bottom.
	/// The returned pix has these stripped off they are only used
	/// for computation.<para/>
	///
	/// (3) Returns a copy if both wc and hc are 0<para/>
	///
	/// (4) Require that w  is greater  2  wc + 1 and h  is greater  2  hc + 1,
	/// where (w,h) are the dimensions of pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlockconvGrayTile/*"/>
	///  <param name="pixacc">[in] - 32 bpp accum pix</param>
	///  <param name="wc">[in] - half width/height of convolution kernel</param>
	///  <param name="hc">[in] - half width/height of convolution kernel</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix BlockconvGrayTile (Pix pixacc,
								  int wc,
								  int hc)
	{
		Pix RetObj = _All.pixBlockconvGrayTile(this, pixacc, wc, hc);
		return RetObj;
	}

	// convolve.c (980, 1)
	// pixWindowedStats(pixs, wc, hc, hasborder, ppixm, ppixms, pfpixv, pfpixrv) as int
	// pixWindowedStats(PIX *, l_int32, l_int32, l_int32, PIX **, PIX **, FPIX **, FPIX **) as l_ok
	///  <summary>
	/// (1) This is a high-level convenience function for calculating
	/// any or all of these derived images.<para/>
	///
	/// (2) If %hasborder = 0, a border is added and the result is
	/// computed over all pixels in pixs.  Otherwise, no border is
	/// added and the border pixels are removed from the output images.<para/>
	///
	/// (3) These statistical measures over the pixels in the
	/// rectangular window are:
	/// ~ average value:  is smallerp is greater (pixm)
	/// ~ average squared value:  is smallerpp is greater  (pixms)
	/// ~ variance:  is smaller(p -  is smallerp is greater )(p -  is smallerp is greater ) is greater  =  is smallerpp is greater  -  is smallerp is greater  is smallerp is greater (pixv)
	/// ~ square-root of variance: (pixrv)
	/// where the brackets  is smaller ..  is greater  indicate that the average value is
	/// to be taken over the window.<para/>
	///
	/// (4) Note that the variance is just the mean square difference from
	/// the mean value and the square root of the variance is the
	/// root mean square difference from the mean, sometimes also
	/// called the 'standard deviation'.<para/>
	///
	/// (5) The added border, along with the use of an accumulator array,
	/// allows computation without special treatment of pixels near
	/// the image boundary, and runs in a time that is independent
	/// of the size of the convolution kernel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWindowedStats/*"/>
	///  <param name="wc">[in] - half width/height of convolution kernel</param>
	///  <param name="hc">[in] - half width/height of convolution kernel</param>
	///  <param name="hasborder">[in] - use 1 if it already has (wc + 1 border pixels on left and right, and hc + 1 on top and bottom use 0 to add kernel-dependent border)</param>
	///  <param name="ppixm">[out][optional] - 8 bpp mean value in window</param>
	///  <param name="ppixms">[out][optional] - 32 bpp mean square value in window</param>
	///  <param name="pfpixv">[out][optional] - float variance in window</param>
	///  <param name="pfpixrv">[out][optional] - float rms deviation from the mean</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WindowedStats (int wc,
							  int hc,
							  int hasborder,
							  out Pix ppixm,
							  out Pix ppixms,
							  out FPix pfpixv,
							  out FPix pfpixrv)
	{
		int RetObj = _All.pixWindowedStats(this, wc, hc, hasborder, out ppixm, out ppixms, out pfpixv, out pfpixrv);
		return RetObj;
	}

	// convolve.c (1065, 1)
	// pixWindowedMean(pixs, wc, hc, hasborder, normflag) as Pix
	// pixWindowedMean(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The input and output depths are the same.<para/>
	///
	/// (2) A set of border pixels of width (wc + 1) on left and right,
	/// and of height (hc + 1) on top and bottom, must be on the
	/// pix before the accumulator is found.  The output pixd
	/// (after convolution) has this border removed.
	/// If %hasborder = 0, the required border is added.<para/>
	///
	/// (3) Typically, %normflag == 1.  However, if you want the sum
	/// within the window, rather than a normalized convolution,
	/// use %normflag == 0.<para/>
	///
	/// (4) This builds a block accumulator pix, uses it here, and
	/// destroys it.<para/>
	///
	/// (5) The added border, along with the use of an accumulator array,
	/// allows computation without special treatment of pixels near
	/// the image boundary, and runs in a time that is independent
	/// of the size of the convolution kernel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWindowedMean/*"/>
	///  <param name="wc">[in] - half width/height of convolution kernel</param>
	///  <param name="hc">[in] - half width/height of convolution kernel</param>
	///  <param name="hasborder">[in] - use 1 if it already has (wc + 1 border pixels on left and right, and hc + 1 on top and bottom use 0 to add kernel-dependent border)</param>
	///  <param name="normflag">[in] - 1 for normalization to get average in window 0 for the sum in the window (un-normalized)</param>
	///   <returns>pixd 8 or 32 bpp, average over kernel window</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix WindowedMean (int wc,
							 int hc,
							 int hasborder,
							 int normflag)
	{
		Pix RetObj = _All.pixWindowedMean(this, wc, hc, hasborder, normflag);
		return RetObj;
	}

	// convolve.c (1182, 1)
	// pixWindowedMeanSquare(pixs, wc, hc, hasborder) as Pix
	// pixWindowedMeanSquare(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) A set of border pixels of width (wc + 1) on left and right,
	/// and of height (hc + 1) on top and bottom, must be on the
	/// pix before the accumulator is found.  The output pixd
	/// (after convolution) has this border removed.
	/// If %hasborder = 0, the required border is added.<para/>
	///
	/// (2) The advantage is that we are unaffected by the boundary, and
	/// it is not necessary to treat pixels within %wc and %hc of the
	/// border differently.  This is because processing for pixd
	/// only takes place for pixels in pixs for which the
	/// kernel is entirely contained in pixs.<para/>
	///
	/// (3) Why do we have an added border of width (%wc + 1) and
	/// height (%hc + 1), when we only need %wc and %hc pixels
	/// to satisfy this condition?  Answer: the accumulators
	/// are asymmetric, requiring an extra row and column of
	/// pixels at top and left to work accurately.<para/>
	///
	/// (4) The added border, along with the use of an accumulator array,
	/// allows computation without special treatment of pixels near
	/// the image boundary, and runs in a time that is independent
	/// of the size of the convolution kernel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWindowedMeanSquare/*"/>
	///  <param name="wc">[in] - half width/height of convolution kernel</param>
	///  <param name="hc">[in] - half width/height of convolution kernel</param>
	///  <param name="hasborder">[in] - use 1 if it already has (wc + 1 border pixels on left and right, and hc + 1 on top and bottom use 0 to add kernel-dependent border)</param>
	///   <returns>pixd 32 bpp, average over rectangular window of width = 2  wc + 1 and height = 2  hc + 1</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix WindowedMeanSquare (int wc,
								   int hc,
								   int hasborder)
	{
		Pix RetObj = _All.pixWindowedMeanSquare(this, wc, hc, hasborder);
		return RetObj;
	}

	// convolve.c (1280, 1)
	// pixWindowedVariance(pixm, pixms, pfpixv, pfpixrv) as int
	// pixWindowedVariance(PIX *, PIX *, FPIX **, FPIX **) as l_ok
	///  <summary>
	/// (1) The mean and mean square values are precomputed, using
	/// pixWindowedMean() and pixWindowedMeanSquare().<para/>
	///
	/// (2) Either or both of the variance and square-root of variance
	/// are returned as an fpix, where the variance is the
	/// average over the window of the mean square difference of
	/// the pixel value from the mean:
	///  is smaller(p -  is smallerp is greater )(p -  is smallerp is greater ) is greater  =  is smallerpp is greater  -  is smallerp is greater  is smallerp is greater <para/>
	///
	/// (3) To visualize the results:
	/// ~ for both, use fpixDisplayMaxDynamicRange().
	/// ~ for rms deviation, simply convert the output fpix to pix,
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWindowedVariance/*"/>
	///  <param name="pixm">[in] - mean over window 8 or 32 bpp grayscale</param>
	///  <param name="pixms">[in] - mean square over window 32 bpp</param>
	///  <param name="pfpixv">[out][optional] - float variance -- the ms deviation from the mean</param>
	///  <param name="pfpixrv">[out][optional] - float rms deviation from the mean</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WindowedVariance (Pix pixm,
								 Pix pixms,
								 out FPix pfpixv,
								 out FPix pfpixrv)
	{
		int RetObj = _All.pixWindowedVariance(pixm, pixms, out pfpixv, out pfpixrv);
		return RetObj;
	}

	// convolve.c (1369, 1)
	// pixMeanSquareAccum(pixs) as DPix
	// pixMeanSquareAccum(PIX *) as DPIX *
	///  <summary>
	/// (1) Similar to pixBlockconvAccum(), this computes the
	/// sum of the squares of the pixel values in such a way
	/// that the value at (i,j) is the sum of all squares in
	/// the rectangle from the origin to (i,j).<para/>
	///
	/// (2) The general recursion relation (v are squared pixel values) is
	/// a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)
	/// For the first line, this reduces to the special case
	/// a(i,j) = v(i,j) + a(i, j-1)
	/// For the first column, the special case is
	/// a(i,j) = v(i,j) + a(i-1, j)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMeanSquareAccum/*"/>
	///   <returns>dpix 64 bit array, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public DPix MeanSquareAccum ()
	{
		DPix RetObj = _All.pixMeanSquareAccum(this);
		return RetObj;
	}

	// convolve.c (1450, 1)
	// pixBlockrank(pixs, pixacc, wc, hc, rank) as Pix
	// pixBlockrank(PIX *, PIX *, l_int32, l_int32, l_float32) as PIX *
	///  <summary>
	/// (1) The full width and height of the convolution kernel
	/// are (2  wc + 1) and (2  hc + 1)<para/>
	///
	/// (2) This returns a pixd where each pixel is a 1 if the
	/// neighborhood (2  wc + 1) x (2  hc + 1)) pixels
	/// contains the rank fraction of 1 pixels.  Otherwise,
	/// the returned pixel is 0.  Note that the special case
	/// of rank = 0.0 is always satisfied, so the returned
	/// pixd has all pixels with value 1.<para/>
	///
	/// (3) If accum pix is null, make one, use it, and destroy it
	/// before returning otherwise, just use the input accum pix<para/>
	///
	/// (4) If both wc and hc are 0, returns a copy unless rank == 0.0,
	/// in which case this returns an all-ones image.<para/>
	///
	/// (5) Require that w greater or equal 2  wc + 1 and h greater or equal 2  hc + 1,
	/// where (w,h) are the dimensions of pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlockrank/*"/>
	///  <param name="pixacc">[in] - pix [optional] 32 bpp</param>
	///  <param name="wc">[in] - half width/height of block sum/rank kernel</param>
	///  <param name="hc">[in] - half width/height of block sum/rank kernel</param>
	///  <param name="rank">[in] - between 0.0 and 1.0 0.5 is median filter</param>
	///   <returns>pixd 1 bpp</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Blockrank (int wc,
						  int hc,
						  Single rank,
						  Pix pixacc)
	{
		Pix RetObj = _All.pixBlockrank(this, pixacc, wc, hc, rank);
		return RetObj;
	}

	// convolve.c (1532, 1)
	// pixBlocksum(pixs, pixacc, wc, hc) as Pix
	// pixBlocksum(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) If accum pix is null, make one and destroy it before
	/// returning otherwise, just use the input accum pix<para/>
	///
	/// (2) The full width and height of the convolution kernel
	/// are (2  wc + 1) and (2  hc + 1)<para/>
	///
	/// (3) Use of wc = hc = 1, followed by pixInvert() on the
	/// 8 bpp result, gives a nice anti-aliased, and somewhat
	/// darkened, result on text.<para/>
	///
	/// (4) Require that w greater or equal 2  wc + 1 and h greater or equal 2  hc + 1,
	/// where (w,h) are the dimensions of pixs.<para/>
	///
	/// (5) Returns in each dest pixel the sum of all src pixels
	/// that are within a block of size of the kernel, centered
	/// on the dest pixel.  This sum is the number of src ON
	/// pixels in the block at each location, normalized to 255
	/// for a block containing all ON pixels.  For pixels near
	/// the boundary, where the block is not entirely contained
	/// within the image, we then multiply by a second normalization
	/// factor that is greater than one, so that all results
	/// are normalized by the number of participating pixels
	/// within the block.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlocksum/*"/>
	///  <param name="pixacc">[in] - pix [optional] 32 bpp</param>
	///  <param name="wc">[in] - half width/height of block sum/rank kernel</param>
	///  <param name="hc">[in] - half width/height of block sum/rank kernel</param>
	///   <returns>pixd 8 bpp</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Blocksum (int wc,
						 int hc,
						 Pix pixacc)
	{
		Pix RetObj = _All.pixBlocksum(this, pixacc, wc, hc);
		return RetObj;
	}

	// convolve.c (1772, 1)
	// pixCensusTransform(pixs, halfsize, pixacc) as Pix
	// pixCensusTransform(PIX *, l_int32, PIX *) as PIX *
	///  <summary>
	/// (1) The Census transform was invented by Ramin Zabih and John Woodfill
	/// ("Non-parametric local transforms for computing visual
	/// correspondence", Third European Conference on Computer Vision,
	/// Stockholm, Sweden, May 1994) see publications at
	/// http://www.cs.cornell.edu/~rdz/index.htm
	/// This compares each pixel against the average of its neighbors,
	/// in a square of odd dimension centered on the pixel.
	/// If the pixel is greater than the average of its neighbors,
	/// the output pixel value is 1 otherwise it is 0.<para/>
	///
	/// (2) This can be used as an encoding for an image that is
	/// fairly robust against slow illumination changes, with
	/// applications in image comparison and mosaicing.<para/>
	///
	/// (3) The size of the convolution kernel is (2  halfsize + 1)
	/// on a side.  The halfsize parameter must be greater or equal 1.<para/>
	///
	/// (4) If accum pix is null, make one, use it, and destroy it
	/// before returning otherwise, just use the input accum pix
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCensusTransform/*"/>
	///  <param name="halfsize">[in] - of square over which neighbors are averaged</param>
	///  <param name="pixacc">[in] - pix [optional] 32 bpp</param>
	///   <returns>pixd 1 bpp</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CensusTransform (int halfsize,
								Pix pixacc)
	{
		Pix RetObj = _All.pixCensusTransform(this, halfsize, pixacc);
		return RetObj;
	}

	// convolve.c (1872, 1)
	// pixConvolve(pixs, kel, outdepth, normflag) as Pix
	// pixConvolve(PIX *, L_KERNEL *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This gives a convolution with an arbitrary kernel.<para/>
	///
	/// (2) The input pixs must have only one sample/pixel.
	/// To do a convolution on an RGB image, use pixConvolveRGB().<para/>
	///
	/// (3) The parameter %outdepth determines the depth of the result.
	/// If the kernel is normalized to unit sum, the output values
	/// can never exceed 255, so an output depth of 8 bpp is sufficient.
	/// If the kernel is not normalized, it may be necessary to use
	/// 16 or 32 bpp output to avoid overflow.<para/>
	///
	/// (4) If normflag == 1, the result is normalized by scaling all
	/// kernel values for a unit sum.  If the sum of kernel values
	/// is very close to zero, the kernel can not be normalized and
	/// the convolution will not be performed.  A warning is issued.<para/>
	///
	/// (5) The kernel values can be positive or negative, but the
	/// result for the convolution can only be stored as a positive
	/// number.  Consequently, if it goes negative, the choices are
	/// to clip to 0 or take the absolute value.  We're choosing
	/// to take the absolute value.  (Another possibility would be
	/// to output a second unsigned image for the negative values.)
	/// If you want to get a clipped result, or to keep the negative
	/// values in the result, use fpixConvolve(), with the
	/// converters in fpix2.c between pix and fpix.<para/>
	///
	/// (6) This uses a mirrored border to avoid special casing on
	/// the boundaries.<para/>
	///
	/// (7) To get a subsampled output, call l_setConvolveSampling().
	/// The time to make a subsampled output is reduced by the
	/// product of the sampling factors.<para/>
	///
	/// (8) The function is slow, running at about 12 machine cycles for
	/// each pixel-op in the convolution.  For example, with a 3 GHz
	/// cpu, a 1 Mpixel grayscale image, and a kernel with
	/// (sx  sy) = 25 elements, the convolution takes about 100 msec.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvolve/*"/>
	///  <param name="kel">[in] - kernel</param>
	///  <param name="outdepth">[in] - of pixd: 8, 16 or 32</param>
	///  <param name="normflag">[in] - 1 to normalize kernel to unit sum 0 otherwise</param>
	///   <returns>pixd 8, 16 or 32 bpp</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convolve (L_Kernel kel,
						 int outdepth,
						 int normflag)
	{
		Pix RetObj = _All.pixConvolve(this, kel, outdepth, normflag);
		return RetObj;
	}

	// convolve.c (2002, 1)
	// pixConvolveSep(pixs, kelx, kely, outdepth, normflag) as Pix
	// pixConvolveSep(PIX *, L_KERNEL *, L_KERNEL *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This does a convolution with a separable kernel that is
	/// is a sequence of convolutions in x and y.  The two
	/// one-dimensional kernel components must be input separately
	/// the full kernel is the product of these components.
	/// The support for the full kernel is thus a rectangular region.<para/>
	///
	/// (2) The input pixs must have only one sample/pixel.
	/// To do a convolution on an RGB image, use pixConvolveSepRGB().<para/>
	///
	/// (3) The parameter %outdepth determines the depth of the result.
	/// If the kernel is normalized to unit sum, the output values
	/// can never exceed 255, so an output depth of 8 bpp is sufficient.
	/// If the kernel is not normalized, it may be necessary to use
	/// 16 or 32 bpp output to avoid overflow.<para/>
	///
	/// (2) The %normflag parameter is used as in pixConvolve().<para/>
	///
	/// (4) The kernel values can be positive or negative, but the
	/// result for the convolution can only be stored as a positive
	/// number.  Consequently, if it goes negative, the choices are
	/// to clip to 0 or take the absolute value.  We're choosing
	/// the former for now.  Another possibility would be to output
	/// a second unsigned image for the negative values.<para/>
	///
	/// (5) Warning: if you use l_setConvolveSampling() to get a
	/// subsampled output, and the sampling factor is larger than
	/// the kernel half-width, it is faster to use the non-separable
	/// version pixConvolve().  This is because the first convolution
	/// here must be done on every raster line, regardless of the
	/// vertical sampling factor.  If the sampling factor is smaller
	/// than kernel half-width, it's faster to use the separable
	/// convolution.<para/>
	///
	/// (6) This uses mirrored borders to avoid special casing on
	/// the boundaries.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvolveSep/*"/>
	///  <param name="kelx">[in] - x-dependent kernel</param>
	///  <param name="kely">[in] - y-dependent kernel</param>
	///  <param name="outdepth">[in] - of pixd: 8, 16 or 32</param>
	///  <param name="normflag">[in] - 1 to normalize kernel to unit sum 0 otherwise</param>
	///   <returns>pixd 8, 16 or 32 bpp</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvolveSep (L_Kernel kelx,
							L_Kernel kely,
							int outdepth,
							int normflag)
	{
		Pix RetObj = _All.pixConvolveSep(this, kelx, kely, outdepth, normflag);
		return RetObj;
	}

	// convolve.c (2074, 1)
	// pixConvolveRGB(pixs, kel) as Pix
	// pixConvolveRGB(PIX *, L_KERNEL *) as PIX *
	///  <summary>
	/// (1) This gives a convolution on an RGB image using an
	/// arbitrary kernel (which we normalize to keep each
	/// component within the range [0 ... 255].<para/>
	///
	/// (2) The input pixs must be RGB.<para/>
	///
	/// (3) The kernel values can be positive or negative, but the
	/// result for the convolution can only be stored as a positive
	/// number.  Consequently, if it goes negative, we clip the
	/// result to 0.<para/>
	///
	/// (4) To get a subsampled output, call l_setConvolveSampling().
	/// The time to make a subsampled output is reduced by the
	/// product of the sampling factors.<para/>
	///
	/// (5) This uses a mirrored border to avoid special casing on
	/// the boundaries.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvolveRGB/*"/>
	///  <param name="kel">[in] - kernel</param>
	///   <returns>pixd 32 bpp rgb</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvolveRGB (L_Kernel kel)
	{
		Pix RetObj = _All.pixConvolveRGB(this, kel);
		return RetObj;
	}

	// convolve.c (2133, 1)
	// pixConvolveRGBSep(pixs, kelx, kely) as Pix
	// pixConvolveRGBSep(PIX *, L_KERNEL *, L_KERNEL *) as PIX *
	///  <summary>
	/// (1) This does a convolution on an RGB image using a separable
	/// kernel that is a sequence of convolutions in x and y.  The two
	/// one-dimensional kernel components must be input separately
	/// the full kernel is the product of these components.
	/// The support for the full kernel is thus a rectangular region.<para/>
	///
	/// (2) The kernel values can be positive or negative, but the
	/// result for the convolution can only be stored as a positive
	/// number.  Consequently, if it goes negative, we clip the
	/// result to 0.<para/>
	///
	/// (3) To get a subsampled output, call l_setConvolveSampling().
	/// The time to make a subsampled output is reduced by the
	/// product of the sampling factors.<para/>
	///
	/// (4) This uses a mirrored border to avoid special casing on
	/// the boundaries.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvolveRGBSep/*"/>
	///  <param name="kelx">[in] - x-dependent kernel</param>
	///  <param name="kely">[in] - y-dependent kernel</param>
	///   <returns>pixd 32 bpp rgb</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvolveRGBSep (L_Kernel kelx,
							   L_Kernel kely)
	{
		Pix RetObj = _All.pixConvolveRGBSep(this, kelx, kely);
		return RetObj;
	}

	// convolve.c (2367, 1)
	// pixConvolveWithBias(pixs, kel1, kel2, force8, pbias) as Pix
	// pixConvolveWithBias(PIX *, L_KERNEL *, L_KERNEL *, l_int32, l_int32 *) as PIX *
	///  <summary>
	/// (1) This does a convolution with either a single kernel or
	/// a pair of separable kernels, and automatically applies whatever
	/// bias (shift) is required so that the resulting pixel values
	/// are non-negative.<para/>
	///
	/// (2) The kernel is always normalized.  If there are no negative
	/// values in the kernel, a standard normalized convolution is
	/// performed, with 8 bpp output.  If the sum of kernel values is
	/// very close to zero, the kernel can not be normalized and
	/// the convolution will not be performed.  An error message results.<para/>
	///
	/// (3) If there are negative values in the kernel, the pix is
	/// converted to an fpix, the convolution is done on the fpix, and
	/// a bias (shift) may need to be applied.<para/>
	///
	/// (4) If force8 == TRUE and the range of values after the convolution
	/// is  is greater  255, the output values will be scaled to fit in [0 ... 255].
	/// If force8 == FALSE, the output will be either 8 or 16 bpp,
	/// to accommodate the dynamic range of output values without scaling.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvolveWithBias/*"/>
	///  <param name="kel1">[in] - </param>
	///  <param name="kel2">[in]can be null - use if separable</param>
	///  <param name="force8">[in] - if 1, force output to 8 bpp otherwise, determine output depth by the dynamic range of pixel values</param>
	///  <param name="pbias">[out] - applied bias</param>
	///   <returns>pixd 8 or 16 bpp</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvolveWithBias (L_Kernel kel1,
								 int force8,
								 out int pbias,
								 L_Kernel kel2)
	{
		Pix RetObj = _All.pixConvolveWithBias(this, kel1, kel2, force8, out pbias);
		return RetObj;
	}

	// convolve.c (2484, 1)
	// pixAddGaussianNoise(pixs, stdev) as Pix
	// pixAddGaussianNoise(PIX *, l_float32) as PIX *
	///  <summary>
	/// (1) This adds noise to each pixel, taken from a normal
	/// distribution with zero mean and specified standard deviation.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddGaussianNoise/*"/>
	///  <param name="stdev">[in] - of noise</param>
	///   <returns>pixd 8 or 32 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddGaussianNoise (Single stdev)
	{
		Pix RetObj = _All.pixAddGaussianNoise(this, stdev);
		return RetObj;
	}

	// correlscore.c (125, 1)
	// pixCorrelationScore(pix1, pix2, area1, area2, delx, dely, maxdiffw, maxdiffh, tab, pscore) as int
	// pixCorrelationScore(PIX *, PIX *, l_int32, l_int32, l_float32, l_float32, l_int32, l_int32, l_int32 *, l_float32 *) as l_ok
	///  <summary>
	/// We check first that the two pix are roughly the same size.
	/// For jbclass (jbig2) applications at roughly 300 ppi, maxdiffw and
	/// maxdiffh should be at least 2.
	/// Only if they meet that criterion do we compare the bitmaps.
	/// The centroid difference is used to align the two images to the
	/// nearest integer for the correlation.
	/// The correlation score is the ratio of the square of the number of
	/// pixels in the AND of the two bitmaps to the product of the number
	/// of ON pixels in each.  Denote the number of ON pixels in pix1
	/// by |1|, the number in pix2 by |2|, and the number in the AND
	/// of pix1 and pix2 by |1 [and] 2|.  The correlation score is then
	/// (|1 [and] 2|)2 / (|1||2|).
	/// This score is compared with an input threshold, which can
	/// be modified depending on the weight of the template.
	/// The modified threshold is
	/// thresh + (1.0 - thresh)  weight  R
	/// where
	/// weight is a fixed input factor between 0.0 and 1.0
	/// R = |2| / area(2)
	/// and area(2) is the total number of pixels in 2 (i.e., width x height).
	/// To understand why a weight factor is useful, consider what happens
	/// with thick, sans-serif characters that look similar and have a value
	/// of R near 1.  Different characters can have a high correlation value,
	/// and the classifier will make incorrect substitutions.  The weight
	/// factor raises the threshold for these characters.
	/// Yet another approach to reduce such substitutions is to run the classifier
	/// in a non-greedy way, matching to the template with the highest
	/// score, not the first template with a score satisfying the matching
	/// constraint.  However, this is not particularly effective.
	/// The implementation here gives the same result as in
	/// pixCorrelationScoreSimple(), where a temporary Pix is made to hold
	/// the AND and implementation uses rasterop:
	/// pixt = pixCreateTemplate(pix1)
	/// pixRasterop(pixt, idelx, idely, wt, ht, PIX_SRC, pix2, 0, 0)
	/// pixRasterop(pixt, 0, 0, wi, hi, PIX_SRC [and] PIX_DST, pix1, 0, 0)
	/// pixCountPixels(pixt, [and]count, tab)
	/// pixDestroy([and]pixt)
	/// However, here it is done in a streaming fashion, counting as it goes,
	/// and touching memory exactly once, giving a 3-4x speedup over the
	/// simple implementation.  This very fast correlation matcher was
	/// contributed by William Rucklidge.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCorrelationScore/*"/>
	///  <param name="pix1">[in] - test pix, 1 bpp</param>
	///  <param name="pix2">[in] - exemplar pix, 1 bpp</param>
	///  <param name="area1">[in] - number of on pixels in pix1</param>
	///  <param name="area2">[in] - number of on pixels in pix2</param>
	///  <param name="delx">[in] - x comp of centroid difference</param>
	///  <param name="dely">[in] - y comp of centroid difference</param>
	///  <param name="maxdiffw">[in] - max width difference of pix1 and pix2</param>
	///  <param name="maxdiffh">[in] - max height difference of pix1 and pix2</param>
	///  <param name="tab">[in] - sum tab for byte</param>
	///  <param name="pscore">[out] - correlation score</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CorrelationScore (Pix pix1,
								 Pix pix2,
								 int area1,
								 int area2,
								 Single delx,
								 Single dely,
								 int maxdiffw,
								 int maxdiffh,
								 int[] tab,
								 out Single pscore)
	{
		int RetObj = _All.pixCorrelationScore(pix1, pix2, area1, area2, delx, dely, maxdiffw, maxdiffh, tab, out pscore);
		return RetObj;
	}

	// correlscore.c (423, 1)
	// pixCorrelationScoreThresholded(pix1, pix2, area1, area2, delx, dely, maxdiffw, maxdiffh, tab, downcount, score_threshold) as int
	// pixCorrelationScoreThresholded(PIX *, PIX *, l_int32, l_int32, l_float32, l_float32, l_int32, l_int32, l_int32 *, l_int32 *, l_float32) as l_int32
	///  <summary>
	/// We check first that the two pix are roughly the same size.
	/// Only if they meet that criterion do we compare the bitmaps.
	/// The centroid difference is used to align the two images to the
	/// nearest integer for the correlation.
	/// The correlation score is the ratio of the square of the number of
	/// pixels in the AND of the two bitmaps to the product of the number
	/// of ON pixels in each.  Denote the number of ON pixels in pix1
	/// by |1|, the number in pix2 by |2|, and the number in the AND
	/// of pix1 and pix2 by |1 [and] 2|.  The correlation score is then
	/// (|1 [and] 2|)2 / (|1||2|).
	/// This score is compared with an input threshold, which can
	/// be modified depending on the weight of the template.
	/// The modified threshold is
	/// thresh + (1.0 - thresh)  weight  R
	/// where
	/// weight is a fixed input factor between 0.0 and 1.0
	/// R = |2| / area(2)
	/// and area(2) is the total number of pixels in 2 (i.e., width x height).
	/// To understand why a weight factor is useful, consider what happens
	/// with thick, sans-serif characters that look similar and have a value
	/// of R near 1.  Different characters can have a high correlation value,
	/// and the classifier will make incorrect substitutions.  The weight
	/// factor raises the threshold for these characters.
	/// Yet another approach to reduce such substitutions is to run the classifier
	/// in a non-greedy way, matching to the template with the highest
	/// score, not the first template with a score satisfying the matching
	/// constraint.  However, this is not particularly effective.
	/// This very fast correlation matcher was contributed by William Rucklidge.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCorrelationScoreThresholded/*"/>
	///  <param name="pix1">[in] - test pix, 1 bpp</param>
	///  <param name="pix2">[in] - exemplar pix, 1 bpp</param>
	///  <param name="area1">[in] - number of on pixels in pix1</param>
	///  <param name="area2">[in] - number of on pixels in pix2</param>
	///  <param name="delx">[in] - x comp of centroid difference</param>
	///  <param name="dely">[in] - y comp of centroid difference</param>
	///  <param name="maxdiffw">[in] - max width difference of pix1 and pix2</param>
	///  <param name="maxdiffh">[in] - max height difference of pix1 and pix2</param>
	///  <param name="tab">[in] - sum tab for byte</param>
	///  <param name="downcount">[in] - count of 1 pixels below each row of pix1</param>
	///  <param name="score_threshold">[in] - </param>
	///   <returns>whether the correlation score is greater or equal score_threshold</returns>
	// CreateAdditiveFunction: Function/Else
	public int CorrelationScoreThresholded (Pix pix1,
											Pix pix2,
											int area1,
											int area2,
											Single delx,
											Single dely,
											int maxdiffw,
											int maxdiffh,
											int[] tab,
											int[] downcount,
											Single score_threshold)
	{
		int RetObj = _All.pixCorrelationScoreThresholded(pix1, pix2, area1, area2, delx, dely, maxdiffw, maxdiffh, tab, downcount, score_threshold);
		return RetObj;
	}

	// correlscore.c (732, 1)
	// pixCorrelationScoreSimple(pix1, pix2, area1, area2, delx, dely, maxdiffw, maxdiffh, tab, pscore) as int
	// pixCorrelationScoreSimple(PIX *, PIX *, l_int32, l_int32, l_float32, l_float32, l_int32, l_int32, l_int32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) This calculates exactly the same value as pixCorrelationScore().
	/// It is 2-3x slower, but much simpler to understand.<para/>
	///
	/// (2) The returned correlation score is 0.0 if the width or height
	/// exceed %maxdiffw or %maxdiffh.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCorrelationScoreSimple/*"/>
	///  <param name="pix1">[in] - test pix, 1 bpp</param>
	///  <param name="pix2">[in] - exemplar pix, 1 bpp</param>
	///  <param name="area1">[in] - number of on pixels in pix1</param>
	///  <param name="area2">[in] - number of on pixels in pix2</param>
	///  <param name="delx">[in] - x comp of centroid difference</param>
	///  <param name="dely">[in] - y comp of centroid difference</param>
	///  <param name="maxdiffw">[in] - max width difference of pix1 and pix2</param>
	///  <param name="maxdiffh">[in] - max height difference of pix1 and pix2</param>
	///  <param name="tab">[in] - sum tab for byte</param>
	///  <param name="pscore">[out] - correlation score, in range [0.0 ... 1.0]</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CorrelationScoreSimple (Pix pix1,
									   Pix pix2,
									   int area1,
									   int area2,
									   Single delx,
									   Single dely,
									   int maxdiffw,
									   int maxdiffh,
									   int[] tab,
									   out Single pscore)
	{
		int RetObj = _All.pixCorrelationScoreSimple(pix1, pix2, area1, area2, delx, dely, maxdiffw, maxdiffh, tab, out pscore);
		return RetObj;
	}

	// correlscore.c (835, 1)
	// pixCorrelationScoreShifted(pix1, pix2, area1, area2, delx, dely, tab, pscore) as int
	// pixCorrelationScoreShifted(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) This finds the correlation between two 1 bpp images,
	/// when pix2 is shifted by (delx, dely) with respect
	/// to each other.<para/>
	///
	/// (2) This is implemented by starting with a copy of pix1 and
	/// ANDing its pixels with those of a shifted pix2.<para/>
	///
	/// (3) Get the pixel counts for area1 and area2 using piCountPixels().<para/>
	///
	/// (4) A good estimate for a shift that would maximize the correlation
	/// is to align the centroids (cx1, cy1 cx2, cy2), giving the
	/// relative translations etransx and etransy:
	/// etransx = cx1 - cx2
	/// etransy = cy1 - cy2
	/// Typically delx is chosen to be near etransx ditto for dely.
	/// This function is used in pixBestCorrelation(), where the
	/// translations delx and dely are varied to find the best alignment.<para/>
	///
	/// (5) We do not check the sizes of pix1 and pix2, because they should
	/// be comparable.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCorrelationScoreShifted/*"/>
	///  <param name="pix1">[in] - 1 bpp</param>
	///  <param name="pix2">[in] - 1 bpp</param>
	///  <param name="area1">[in] - number of on pixels in pix1</param>
	///  <param name="area2">[in] - number of on pixels in pix2</param>
	///  <param name="delx">[in] - x translation of pix2 relative to pix1</param>
	///  <param name="dely">[in] - y translation of pix2 relative to pix1</param>
	///  <param name="tab">[in] - sum tab for byte</param>
	///  <param name="pscore">[out] - correlation score</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CorrelationScoreShifted (Pix pix1,
										Pix pix2,
										int area1,
										int area2,
										int delx,
										int dely,
										int[] tab,
										out Single pscore)
	{
		int RetObj = _All.pixCorrelationScoreShifted(pix1, pix2, area1, area2, delx, dely, tab, out pscore);
		return RetObj;
	}

	// dwacomb.2.c (37, 6)
	// pixMorphDwa_2(pixd, pixs, operation, selname) as Pix
	// pixMorphDwa_2(PIX *, PIX *, l_int32, char *) as PIX *
	///  <summary>
	/// (1) This simply adds a border, calls the appropriate
	/// pixFMorphopGen_(), and removes the border.
	/// See the notes for that function.<para/>
	///
	/// (2) The size of the border depends on the operation
	/// and the boundary conditions.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMorphDwa_2/*"/>
	///  <param name="pixd">[in] - usual 3 choices: null, == pixs, != pixs</param>
	///  <param name="operation">[in] - L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, L_MORPH_CLOSE</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MorphDwa_2 (Pix pixd,
						   int operation,
						   String selname)
	{
		Pix RetObj = _All.pixMorphDwa_2(pixd, this, operation, selname);
		return RetObj;
	}

	// dwacomb.2.c (38, 6)
	// pixFMorphopGen_2(pixd, pixs, operation, selname) as Pix
	// pixFMorphopGen_2(PIX *, PIX *, l_int32, char *) as PIX *
	///  <summary>
	/// (1) This is a dwa operation, and the Sels must be limited in
	/// size to not more than 31 pixels about the origin.<para/>
	///
	/// (2) A border of appropriate size (32 pixels, or 64 pixels
	/// for safe closing with asymmetric b.c.) must be added before
	/// this function is called.<para/>
	///
	/// (3) This handles all required setting of the border pixels
	/// before erosion and dilation.<para/>
	///
	/// (4) The closing operation is safe no pixels can be removed
	/// near the boundary.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFMorphopGen_2/*"/>
	///  <param name="pixd">[in] - usual 3 choices: null, == pixs, != pixs</param>
	///  <param name="operation">[in] - L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, L_MORPH_CLOSE</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FMorphopGen_2 (Pix pixd,
							  int operation,
							  String selname)
	{
		Pix RetObj = _All.pixFMorphopGen_2(pixd, this, operation, selname);
		return RetObj;
	}

	// edge.c (91, 1)
	// pixSobelEdgeFilter(pixs, orientflag) as Pix
	// pixSobelEdgeFilter(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Invert pixd to see larger gradients as darker (grayscale).<para/>
	///
	/// (2) To generate a binary image of the edges, threshold
	/// the result using pixThresholdToBinary().  If the high
	/// edge values are to be fg (1), invert after running
	/// pixThresholdToBinary().<para/>
	///
	/// (3) Label the pixels as follows:
	/// 1  4  7
	/// 2  5  8
	/// 3  6  9
	/// Read the data incrementally across the image and unroll
	/// the loop.<para/>
	///
	/// (4) This runs at about 45 Mpix/sec on a 3 GHz processor.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSobelEdgeFilter/*"/>
	///  <param name="orientflag">[in] - L_HORIZONTAL_EDGES, L_VERTICAL_EDGES, L_ALL_EDGES</param>
	///   <returns>pixd 8 bpp, edges are brighter, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SobelEdgeFilter (int orientflag)
	{
		Pix RetObj = _All.pixSobelEdgeFilter(this, orientflag);
		return RetObj;
	}

	// edge.c (199, 1)
	// pixTwoSidedEdgeFilter(pixs, orientflag) as Pix
	// pixTwoSidedEdgeFilter(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) For detecting vertical edges, this considers the
	/// difference of the central pixel from those on the left
	/// and right.  For situations where the gradient is the same
	/// sign on both sides, this computes and stores the minimum
	/// (absolute value of the) difference.  The reason for
	/// checking the sign is that we are looking for pixels within
	/// a transition.  By contrast, for single pixel noise, the pixel
	/// value is either larger than or smaller than its neighbors,
	/// so the gradient would change direction on each side.  Horizontal
	/// edges are handled similarly, looking for vertical gradients.<para/>
	///
	/// (2) To generate a binary image of the edges, threshold
	/// the result using pixThresholdToBinary().  If the high
	/// edge values are to be fg (1), invert after running
	/// pixThresholdToBinary().<para/>
	///
	/// (3) This runs at about 60 Mpix/sec on a 3 GHz processor.
	/// It is about 30% faster than Sobel, and the results are
	/// similar.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTwoSidedEdgeFilter/*"/>
	///  <param name="orientflag">[in] - L_HORIZONTAL_EDGES, L_VERTICAL_EDGES</param>
	///   <returns>pixd 8 bpp, edges are brighter, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix TwoSidedEdgeFilter (int orientflag)
	{
		Pix RetObj = _All.pixTwoSidedEdgeFilter(this, orientflag);
		return RetObj;
	}

	// edge.c (309, 1)
	// pixMeasureEdgeSmoothness(pixs, side, minjump, minreversal, pjpl, pjspl, prpl, debugfile) as int
	// pixMeasureEdgeSmoothness(PIX *, l_int32, l_int32, l_int32, l_float32 *, l_float32 *, l_float32 *, const char *) as l_ok
	///  <summary>
	/// (1) This computes three measures of smoothness of the edge of a
	/// connected component:
	/// jumps/length: (jpl) the number of jumps of size greater or equal %minjump,
	/// normalized to the length of the side
	/// jump sum/length: (jspl) the sum of all jump lengths of
	/// size greater or equal %minjump, normalized to the length of the side
	/// reversals/length: (rpl) the number of peak  is smallerto valley
	/// reversals, using %minreverse as a minimum deviation of
	/// the peak or valley from its preceding extremum,
	/// normalized to the length of the side<para/>
	///
	/// (2) The input pix should be a single connected component, but
	/// this is not required.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMeasureEdgeSmoothness/*"/>
	///  <param name="side">[in] - L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
	///  <param name="minjump">[in] - minimum jump to be counted greater or equal 1</param>
	///  <param name="minreversal">[in] - minimum reversal size for new peak or valley</param>
	///  <param name="pjpl">[out][optional] - jumps/length: number of jumps, normalized to length of component side</param>
	///  <param name="pjspl">[out][optional] - jumpsum/length: sum of all sufficiently large jumps, normalized to length of component side</param>
	///  <param name="prpl">[out][optional] - reversals/length: number of peak-to-valley or valley-to-peak reversals, normalized to length of component side</param>
	///  <param name="debugfile">[in][optional] - displays constructed edge use NULL for no output</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int MeasureEdgeSmoothness (int side,
									  int minjump,
									  int minreversal,
									  out Single pjpl,
									  out Single pjspl,
									  out Single prpl,
									  String debugfile)
	{
		int RetObj = _All.pixMeasureEdgeSmoothness(this, side, minjump, minreversal, out pjpl, out pjspl, out prpl, debugfile);
		return RetObj;
	}

	// edge.c (386, 1)
	// pixGetEdgeProfile(pixs, side, debugfile) as Numa
	// pixGetEdgeProfile(PIX *, l_int32, const char *) as NUMA *
	///  <summary>
	/// pixGetEdgeProfile()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetEdgeProfile/*"/>
	///  <param name="side">[in] - L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
	///  <param name="debugfile">[in][optional] - displays constructed edge use NULL for no output</param>
	///   <returns>na of fg edge pixel locations, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetEdgeProfile (int side,
								String debugfile)
	{
		Numa RetObj = _All.pixGetEdgeProfile(this, side, debugfile);
		return RetObj;
	}

	// edge.c (515, 1)
	// pixGetLastOffPixelInRun(pixs, x, y, direction, ploc) as int
	// pixGetLastOffPixelInRun(PIX *, l_int32, l_int32, l_int32, l_int32 *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetLastOffPixelInRun/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetLastOffPixelInRun (int x,
									 int y,
									 int direction,
									 object ploc)
	{
		int RetObj = _All.pixGetLastOffPixelInRun(this, x, y, direction, ploc);
		return RetObj;
	}

	// edge.c (587, 1)
	// pixGetLastOnPixelInRun(pixs, x, y, direction, ploc) as int
	// pixGetLastOnPixelInRun(PIX *, l_int32, l_int32, l_int32, l_int32 *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetLastOnPixelInRun/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetLastOnPixelInRun (int x,
									int y,
									int direction,
									object ploc)
	{
		int RetObj = _All.pixGetLastOnPixelInRun(this, x, y, direction, ploc);
		return RetObj;
	}

	// enhance.c (174, 1)
	// pixGammaTRC(pixd, pixs, gamma, minval, maxval) as Pix
	// pixGammaTRC(PIX *, PIX *, l_float32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) pixd must either be null or equal to pixs.
	/// For in-place operation, set pixd == pixs:
	/// pixGammaTRC(pixs, pixs, ...)
	/// To get a new image, set pixd == null:
	/// pixd = pixGammaTRC(NULL, pixs, ...)<para/>
	///
	/// (2) If pixs is colormapped, the colormap is transformed,
	/// either in-place or in a copy of pixs.<para/>
	///
	/// (3) We use a gamma mapping between minval and maxval.<para/>
	///
	/// (4) If gamma  is smaller 1.0, the image will appear darker
	/// if gamma  is greater  1.0, the image will appear lighter<para/>
	///
	/// (5) If gamma = 1.0 and minval = 0 and maxval = 255, no
	/// enhancement is performed return a copy unless in-place,
	/// in which case this is a no-op.<para/>
	///
	/// (6) For color images that are not colormapped, the mapping
	/// is applied to each component.<para/>
	///
	/// (7) minval and maxval are not restricted to the interval [0, 255].
	/// If minval  is smaller 0, an input value of 0 is mapped to a
	/// nonzero output.  This will turn black to gray.
	/// If maxval  is greater  255, an input value of 255 is mapped to
	/// an output value less than 255.  This will turn
	/// white (e.g., in the background) to gray.<para/>
	///
	/// (8) Increasing minval darkens the image.<para/>
	///
	/// (9) Decreasing maxval bleaches the image.<para/>
	///
	/// (10) Simultaneously increasing minval and decreasing maxval
	/// will darken the image and make the colors more intense
	/// e.g., minval = 50, maxval = 200.<para/>
	///
	/// (11) See numaGammaTRC() for further examples of use.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGammaTRC/*"/>
	///  <param name="pixd">[in][optional] - null or equal to pixs</param>
	///  <param name="gamma">[in] - gamma correction must be  is greater  0.0</param>
	///  <param name="minval">[in] - input value that gives 0 for output can be  is smaller 0</param>
	///  <param name="maxval">[in] - input value that gives 255 for output can be  is greater  255</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GammaTRC (Single gamma,
						 int minval,
						 int maxval,
						 Pix pixd)
	{
		Pix RetObj = _All.pixGammaTRC(pixd, this, gamma, minval, maxval);
		return RetObj;
	}

	// enhance.c (242, 1)
	// pixGammaTRCMasked(pixd, pixs, pixm, gamma, minval, maxval) as Pix
	// pixGammaTRCMasked(PIX *, PIX *, PIX *, l_float32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Same as pixGammaTRC() except mapping is optionally over
	/// a subset of pixels described by pixm.<para/>
	///
	/// (2) Masking does not work for colormapped images.<para/>
	///
	/// (3) See pixGammaTRC() for details on how to use the parameters.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGammaTRCMasked/*"/>
	///  <param name="pixd">[in][optional] - null or equal to pixs</param>
	///  <param name="pixm">[in][optional] - null or 1 bpp</param>
	///  <param name="gamma">[in] - gamma correction must be  is greater  0.0</param>
	///  <param name="minval">[in] - input value that gives 0 for output can be  is smaller 0</param>
	///  <param name="maxval">[in] - input value that gives 255 for output can be  is greater  255</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GammaTRCMasked (Single gamma,
							   int minval,
							   int maxval,
							   Pix pixd,
							   Pix pixm)
	{
		Pix RetObj = _All.pixGammaTRCMasked(pixd, this, pixm, gamma, minval, maxval);
		return RetObj;
	}

	// enhance.c (306, 1)
	// pixGammaTRCWithAlpha(pixd, pixs, gamma, minval, maxval) as Pix
	// pixGammaTRCWithAlpha(PIX *, PIX *, l_float32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See usage notes in pixGammaTRC().<para/>
	///
	/// (2) This version saves the alpha channel.  It is only valid
	/// for 32 bpp (no colormap), and is a bit slower.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGammaTRCWithAlpha/*"/>
	///  <param name="pixd">[in][optional] - null or equal to pixs</param>
	///  <param name="gamma">[in] - gamma correction must be  is greater  0.0</param>
	///  <param name="minval">[in] - input value that gives 0 for output can be  is smaller 0</param>
	///  <param name="maxval">[in] - input value that gives 255 for output can be  is greater  255</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GammaTRCWithAlpha (Single gamma,
								  int minval,
								  int maxval,
								  Pix pixd)
	{
		Pix RetObj = _All.pixGammaTRCWithAlpha(pixd, this, gamma, minval, maxval);
		return RetObj;
	}

	// enhance.c (436, 1)
	// pixContrastTRC(pixd, pixs, factor) as Pix
	// pixContrastTRC(PIX *, PIX *, l_float32) as PIX *
	///  <summary>
	/// (1) pixd must either be null or equal to pixs.
	/// For in-place operation, set pixd == pixs:
	/// pixContrastTRC(pixs, pixs, ...)
	/// To get a new image, set pixd == null:
	/// pixd = pixContrastTRC(NULL, pixs, ...)<para/>
	///
	/// (2) If pixs is colormapped, the colormap is transformed,
	/// either in-place or in a copy of pixs.<para/>
	///
	/// (3) Contrast is enhanced by mapping each color component
	/// using an atan function with maximum slope at 127.
	/// Pixels below 127 are lowered in intensity and pixels
	/// above 127 are increased.<para/>
	///
	/// (4) The useful range for the contrast factor is scaled to
	/// be in (0.0 to 1.0), but larger values can also be used.<para/>
	///
	/// (5) If factor == 0.0, no enhancement is performed return a copy
	/// unless in-place, in which case this is a no-op.<para/>
	///
	/// (6) For color images that are not colormapped, the mapping
	/// is applied to each component.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixContrastTRC/*"/>
	///  <param name="pixd">[in][optional] - null or equal to pixs</param>
	///  <param name="factor">[in] - 0.0 is no enhancement</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ContrastTRC (Single factor,
							Pix pixd)
	{
		Pix RetObj = _All.pixContrastTRC(pixd, this, factor);
		return RetObj;
	}

	// enhance.c (498, 1)
	// pixContrastTRCMasked(pixd, pixs, pixm, factor) as Pix
	// pixContrastTRCMasked(PIX *, PIX *, PIX *, l_float32) as PIX *
	///  <summary>
	/// (1) Same as pixContrastTRC() except mapping is optionally over
	/// a subset of pixels described by pixm.<para/>
	///
	/// (2) Masking does not work for colormapped images.<para/>
	///
	/// (3) See pixContrastTRC() for details on how to use the parameters.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixContrastTRCMasked/*"/>
	///  <param name="pixd">[in][optional] - null or equal to pixs</param>
	///  <param name="pixm">[in][optional] - null or 1 bpp</param>
	///  <param name="factor">[in] - 0.0 is no enhancement</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ContrastTRCMasked (Single factor,
								  Pix pixd,
								  Pix pixm)
	{
		Pix RetObj = _All.pixContrastTRCMasked(pixd, this, pixm, factor);
		return RetObj;
	}

	// enhance.c (627, 1)
	// pixEqualizeTRC(pixd, pixs, fract, factor) as Pix
	// pixEqualizeTRC(PIX *, PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) pixd must either be null or equal to pixs.
	/// For in-place operation, set pixd == pixs:
	/// pixEqualizeTRC(pixs, pixs, ...)
	/// To get a new image, set pixd == null:
	/// pixd = pixEqualizeTRC(NULL, pixs, ...)<para/>
	///
	/// (2) In histogram equalization, a tone reproduction curve
	/// mapping is used to make the number of pixels at each
	/// intensity equal.<para/>
	///
	/// (3) If fract == 0.0, no equalization is performed return a copy
	/// unless in-place, in which case this is a no-op.
	/// If fract == 1.0, equalization is complete.<para/>
	///
	/// (4) Set the subsampling factor  is greater  1 to reduce the amount of computation.<para/>
	///
	/// (5) If pixs is colormapped, the colormap is removed and
	/// converted to rgb or grayscale.<para/>
	///
	/// (6) If pixs has color, equalization is done in each channel
	/// separately.<para/>
	///
	/// (7) Note that even if there is a colormap, we can get an
	/// in-place operation because the intermediate image pixt
	/// is copied back to pixs (which for in-place is the same
	/// as pixd).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixEqualizeTRC/*"/>
	///  <param name="pixd">[in][optional] - null or equal to pixs</param>
	///  <param name="fract">[in] - fraction of equalization movement of pixel values</param>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix EqualizeTRC (Single fract,
							int factor,
							Pix pixd)
	{
		Pix RetObj = _All.pixEqualizeTRC(pixd, this, fract, factor);
		return RetObj;
	}

	// enhance.c (781, 1)
	// pixTRCMap(pixs, pixm, na) as int
	// pixTRCMap(PIX *, PIX *, NUMA *) as l_int32
	///  <summary>
	/// (1) This operation is in-place on pixs.<para/>
	///
	/// (2) For 32 bpp, this applies the same map to each of the r,g,b
	/// components.<para/>
	///
	/// (3) The mapping array is of size 256, and it maps the input
	/// index into values in the range [0, 255].<para/>
	///
	/// (4) If defined, the optional 1 bpp mask pixm has its origin
	/// aligned with pixs, and the map function is applied only
	/// to pixels in pixs under the fg of pixm.<para/>
	///
	/// (5) For 32 bpp, this does not save the alpha channel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTRCMap/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask</param>
	///  <param name="na">[in] - mapping array</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int TRCMap (Numa na,
					   Pix pixm)
	{
		int RetObj = _All.pixTRCMap(this, pixm, na);
		return RetObj;
	}

	// enhance.c (904, 1)
	// pixUnsharpMasking(pixs, halfwidth, fract) as Pix
	// pixUnsharpMasking(PIX *, l_int32, l_float32) as PIX *
	///  <summary>
	/// (1) We use symmetric smoothing filters of odd dimension,
	/// typically use sizes of 3, 5, 7, etc.  The %halfwidth parameter
	/// for these is (size - 1)/2 i.e., 1, 2, 3, etc.<para/>
	///
	/// (2) The fract parameter is typically taken in the
	/// range:  0.2  is smaller fract  is smaller 0.7<para/>
	///
	/// (3) Returns a clone if no sharpening is requested.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixUnsharpMasking/*"/>
	///  <param name="halfwidth">[in] - "half-width" of smoothing filter</param>
	///  <param name="fract">[in] - fraction of edge added back into image</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix UnsharpMasking (int halfwidth,
							   Single fract)
	{
		Pix RetObj = _All.pixUnsharpMasking(this, halfwidth, fract);
		return RetObj;
	}

	// enhance.c (973, 1)
	// pixUnsharpMaskingGray(pixs, halfwidth, fract) as Pix
	// pixUnsharpMaskingGray(PIX *, l_int32, l_float32) as PIX *
	///  <summary>
	/// (1) We use symmetric smoothing filters of odd dimension,
	/// typically use sizes of 3, 5, 7, etc.  The %halfwidth parameter
	/// for these is (size - 1)/2 i.e., 1, 2, 3, etc.<para/>
	///
	/// (2) The fract parameter is typically taken in the range:
	/// 0.2  is smaller fract  is smaller 0.7<para/>
	///
	/// (3) Returns a clone if no sharpening is requested.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixUnsharpMaskingGray/*"/>
	///  <param name="halfwidth">[in] - "half-width" of smoothing filter</param>
	///  <param name="fract">[in] - fraction of edge added back into image</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix UnsharpMaskingGray (int halfwidth,
								   Single fract)
	{
		Pix RetObj = _All.pixUnsharpMaskingGray(this, halfwidth, fract);
		return RetObj;
	}

	// enhance.c (1070, 1)
	// pixUnsharpMaskingFast(pixs, halfwidth, fract, direction) as Pix
	// pixUnsharpMaskingFast(PIX *, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) The fast version uses separable 1-D filters directly on
	/// the input image.  The halfwidth is either 1 (full width = 3)
	/// or 2 (full width = 5).<para/>
	///
	/// (2) The fract parameter is typically taken in the
	/// range:  0.2  is smaller fract  is smaller 0.7<para/>
	///
	/// (3) To skip horizontal sharpening, use %fracth = 0.0 ditto for %fractv<para/>
	///
	/// (4) For one dimensional filtering (as an example):
	/// For %halfwidth = 1, the low-pass filter is
	/// L:  1/3  1/3 1/3
	/// and the high-pass filter is
	/// H = I - L: -1/3 2/3 -1/3
	/// For %halfwidth = 2, the low-pass filter is
	/// L:  1/5  1/5 1/5  1/5  1/5
	/// and the high-pass filter is
	/// H = I - L: -1/5  -1/5 4/5  -1/5 -1/5
	/// The new sharpened pixel value is found by adding some fraction
	/// of the high-pass filter value (which sums to 0) to the
	/// initial pixel value:
	/// N = I + fract  H<para/>
	///
	/// (5) For 2D, the sharpening filter is not separable, because the
	/// vertical filter depends on the horizontal location relative
	/// to the filter origin, and v.v. So we either do the full
	/// 2D filter (for %halfwidth == 1) or do the low-pass
	/// convolution separably and then compose with the original pix.<para/>
	///
	/// (6) Returns a clone if no sharpening is requested.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixUnsharpMaskingFast/*"/>
	///  <param name="halfwidth">[in] - "half-width" of smoothing filter 1 and 2 only</param>
	///  <param name="fract">[in] - fraction of high frequency added to image</param>
	///  <param name="direction">[in] - L_HORIZ, L_VERT, L_BOTH_DIRECTIONS</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix UnsharpMaskingFast (int halfwidth,
								   Single fract,
								   int direction)
	{
		Pix RetObj = _All.pixUnsharpMaskingFast(this, halfwidth, fract, direction);
		return RetObj;
	}

	// enhance.c (1141, 1)
	// pixUnsharpMaskingGrayFast(pixs, halfwidth, fract, direction) as Pix
	// pixUnsharpMaskingGrayFast(PIX *, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) For usage and explanation of the algorithm, see notes
	/// in pixUnsharpMaskingFast().<para/>
	///
	/// (2) Returns a clone if no sharpening is requested.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixUnsharpMaskingGrayFast/*"/>
	///  <param name="halfwidth">[in] - "half-width" of smoothing filter: 1 or 2</param>
	///  <param name="fract">[in] - fraction of high frequency added to image</param>
	///  <param name="direction">[in] - L_HORIZ, L_VERT, L_BOTH_DIRECTIONS</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix UnsharpMaskingGrayFast (int halfwidth,
									   Single fract,
									   int direction)
	{
		Pix RetObj = _All.pixUnsharpMaskingGrayFast(this, halfwidth, fract, direction);
		return RetObj;
	}

	// enhance.c (1190, 1)
	// pixUnsharpMaskingGray1D(pixs, halfwidth, fract, direction) as Pix
	// pixUnsharpMaskingGray1D(PIX *, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) For usage and explanation of the algorithm, see notes
	/// in pixUnsharpMaskingFast().<para/>
	///
	/// (2) Returns a clone if no sharpening is requested.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixUnsharpMaskingGray1D/*"/>
	///  <param name="halfwidth">[in] - "half-width" of smoothing filter: 1 or 2</param>
	///  <param name="fract">[in] - fraction of high frequency added to image</param>
	///  <param name="direction">[in] - filtering direction use L_HORIZ or L_VERT</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix UnsharpMaskingGray1D (int halfwidth,
									 Single fract,
									 int direction)
	{
		Pix RetObj = _All.pixUnsharpMaskingGray1D(this, halfwidth, fract, direction);
		return RetObj;
	}

	// enhance.c (1324, 1)
	// pixUnsharpMaskingGray2D(pixs, halfwidth, fract) as Pix
	// pixUnsharpMaskingGray2D(PIX *, l_int32, l_float32) as PIX *
	///  <summary>
	/// (1) This is for %halfwidth == 1, 2.<para/>
	///
	/// (2) The lowpass filter is implemented separably.<para/>
	///
	/// (3) Returns a clone if no sharpening is requested.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixUnsharpMaskingGray2D/*"/>
	///  <param name="halfwidth">[in] - "half-width" of smoothing filter: 1 or 2</param>
	///  <param name="fract">[in] - fraction of high frequency added to image</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix UnsharpMaskingGray2D (int halfwidth,
									 Single fract)
	{
		Pix RetObj = _All.pixUnsharpMaskingGray2D(this, halfwidth, fract);
		return RetObj;
	}

	// enhance.c (1469, 1)
	// pixModifyHue(pixd, pixs, fract) as Pix
	// pixModifyHue(PIX *, PIX *, l_float32) as PIX *
	///  <summary>
	/// (1) pixd must either be null or equal to pixs.
	/// For in-place operation, set pixd == pixs:
	/// pixEqualizeTRC(pixs, pixs, ...)
	/// To get a new image, set pixd == null:
	/// pixd = pixEqualizeTRC(NULL, pixs, ...)<para/>
	///
	/// (1) Use fract  is greater  0.0 to increase hue value  is smaller 0.0 to decrease it.
	/// 1.0 (or -1.0) represents a 360 degree rotation i.e., no change.<para/>
	///
	/// (2) If no modification is requested (fract = -1.0 or 0 or 1.0),
	/// return a copy unless in-place, in which case this is a no-op.<para/>
	///
	/// (3) See discussion of color-modification methods, in coloring.c.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixModifyHue/*"/>
	///  <param name="pixd">[in][optional] - can be null or equal to pixs</param>
	///  <param name="fract">[in] - between -1.0 and 1.0</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ModifyHue (Single fract,
						  Pix pixd)
	{
		Pix RetObj = _All.pixModifyHue(pixd, this, fract);
		return RetObj;
	}

	// enhance.c (1542, 1)
	// pixModifySaturation(pixd, pixs, fract) as Pix
	// pixModifySaturation(PIX *, PIX *, l_float32) as PIX *
	///  <summary>
	/// (1) If fract  is greater  0.0, it gives the fraction that the pixel
	/// saturation is moved from its initial value toward 255.
	/// If fract  is smaller 0.0, it gives the fraction that the pixel
	/// saturation is moved from its initial value toward 0.
	/// The limiting values for fract = -1.0 (1.0) thus set the
	/// saturation to 0 (255).<para/>
	///
	/// (2) If fract = 0, no modification is requested return a copy
	/// unless in-place, in which case this is a no-op.<para/>
	///
	/// (3) See discussion of color-modification methods, in coloring.c.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixModifySaturation/*"/>
	///  <param name="pixd">[in][optional] - can be null, existing or equal to pixs</param>
	///  <param name="fract">[in] - between -1.0 and 1.0</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ModifySaturation (Single fract,
								 Pix pixd)
	{
		Pix RetObj = _All.pixModifySaturation(pixd, this, fract);
		return RetObj;
	}

	// enhance.c (1597, 1)
	// pixMeasureSaturation(pixs, factor, psat) as int
	// pixMeasureSaturation(PIX *, l_int32, l_float32 *) as l_int32
	///  <summary>
	/// pixMeasureSaturation()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMeasureSaturation/*"/>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///  <param name="psat">[out] - average saturation</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int MeasureSaturation (int factor,
								  out Single psat)
	{
		int RetObj = _All.pixMeasureSaturation(this, factor, out psat);
		return RetObj;
	}

	// enhance.c (1658, 1)
	// pixModifyBrightness(pixd, pixs, fract) as Pix
	// pixModifyBrightness(PIX *, PIX *, l_float32) as PIX *
	///  <summary>
	/// (1) If fract  is greater  0.0, it gives the fraction that the v-parameter,
	/// which is max(r,g,b), is moved from its initial value toward 255.
	/// If fract  is smaller 0.0, it gives the fraction that the v-parameter
	/// is moved from its initial value toward 0.
	/// The limiting values for fract = -1.0 (1.0) thus set the
	/// v-parameter to 0 (255).<para/>
	///
	/// (2) If fract = 0, no modification is requested return a copy
	/// unless in-place, in which case this is a no-op.<para/>
	///
	/// (3) See discussion of color-modification methods, in coloring.c.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixModifyBrightness/*"/>
	///  <param name="pixd">[in][optional] - can be null, existing or equal to pixs</param>
	///  <param name="fract">[in] - between -1.0 and 1.0</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ModifyBrightness (Single fract,
								 Pix pixd)
	{
		Pix RetObj = _All.pixModifyBrightness(pixd, this, fract);
		return RetObj;
	}

	// enhance.c (1737, 1)
	// pixMosaicColorShiftRGB(pixs, roff, goff, boff, delta, nincr) as Pix
	// pixMosaicColorShiftRGB(PIX *, l_float32, l_float32, l_float32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) This generates a mosaic view of the effect of shifting the RGB
	/// components.  See pixColorShiftRGB() for details on the shifting.<para/>
	///
	/// (2) The offsets (%roff, %goff, %boff) set the color center point,
	/// and the deviations from this are shown separately for deltas
	/// in r, g and b.  For each component, we show 2  %nincr + 1
	/// images.<para/>
	///
	/// (3) Usage: color prints differ from the original due to three factors:
	/// illumination, calibration of the camera in acquisition,
	/// and calibration of the printer.  This function can be used
	/// to iteratively match a color print to the original.  On each
	/// iteration, the center offsets are set to the best match so
	/// far, and the %delta increments are typically reduced.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMosaicColorShiftRGB/*"/>
	///  <param name="roff">[in] - center offset of red component</param>
	///  <param name="goff">[in] - center offset of green component</param>
	///  <param name="boff">[in] - center offset of blue component</param>
	///  <param name="delta">[in] - increments from center offsets [0.0 - 0.1] use 0.0 to get the default (0.04)</param>
	///  <param name="nincr">[in] - number of increments in each (positive and negative) direction use 0 to get the default (2).</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MosaicColorShiftRGB (Single roff,
									Single goff,
									Single boff,
									Single delta,
									int nincr)
	{
		Pix RetObj = _All.pixMosaicColorShiftRGB(this, roff, goff, boff, delta, nincr);
		return RetObj;
	}

	// enhance.c (1833, 1)
	// pixColorShiftRGB(pixs, rfract, gfract, bfract) as Pix
	// pixColorShiftRGB(PIX *, l_float32, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) This allows independent fractional shifts of the r,g and b
	/// components.  A positive shift pushes to saturation (255)
	/// a negative shift pushes toward 0 (black).<para/>
	///
	/// (2) The effect can be imagined using a color wheel that consists
	/// (for our purposes) of these 6 colors, separated by 60 degrees:
	/// red, magenta, blue, cyan, green, yellow<para/>
	///
	/// (3) So, for example, a negative shift of the blue component
	/// (bfract  is smaller 0) could be accompanied by positive shifts
	/// of red and green to make an image more yellow.<para/>
	///
	/// (4) Examples of limiting cases:
	/// rfract = 1 == is greater  r = 255
	/// rfract = -1 == is greater  r = 0
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorShiftRGB/*"/>
	///  <param name="rfract">[in] - fractional shift in red component</param>
	///  <param name="gfract">[in] - fractional shift in green component</param>
	///  <param name="bfract">[in] - fractional shift in blue component</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ColorShiftRGB (Single rfract,
							  Single gfract,
							  Single bfract)
	{
		Pix RetObj = _All.pixColorShiftRGB(this, rfract, gfract, bfract);
		return RetObj;
	}

	// enhance.c (1930, 1)
	// pixDarkenGray(pixd, pixs, thresh, satlimit) as Pix
	// pixDarkenGray(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This darkens gray pixels, by a fraction (sat/%satlimit), where
	/// the sat, the saturation, is the component difference (max - min).
	/// The pixel value is unchanged if sat greater or equal %satlimit.  A typical
	/// value of %satlimit might be 50 the larger the value, the
	/// more that pixels with a smaller saturation will be darkened.<para/>
	///
	/// (2) Pixels with max component greater or equal %thresh are unchanged. This can be
	/// used to prevent bright pixels with low saturation from being
	/// darkened.  Setting thresh == 0 is a no-op setting %thresh == 255
	/// causes the darkening to be applied to all pixels.<para/>
	///
	/// (3) This function is useful to enhance pixels relative to a
	/// gray background.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDarkenGray/*"/>
	///  <param name="pixd">[in][optional] - can be null or equal to pixs</param>
	///  <param name="thresh">[in] - pixels with max component greater or equal %thresh are unchanged</param>
	///  <param name="satlimit">[in] - pixels with saturation greater or equal %satlimit are unchanged</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DarkenGray (int thresh,
						   int satlimit,
						   Pix pixd)
	{
		Pix RetObj = _All.pixDarkenGray(pixd, this, thresh, satlimit);
		return RetObj;
	}

	// enhance.c (2002, 1)
	// pixMultConstantColor(pixs, rfact, gfact, bfact) as Pix
	// pixMultConstantColor(PIX *, l_float32, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) rfact, gfact and bfact can only have non-negative values.
	/// They can be greater than 1.0.  All transformed component
	/// values are clipped to the interval [0, 255].<para/>
	///
	/// (2) For multiplication with a general 3x3 matrix of constants,
	/// use pixMultMatrixColor().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMultConstantColor/*"/>
	///  <param name="rfact">[in] - red multiplicative factor</param>
	///  <param name="gfact">[in] - green multiplicative factor</param>
	///  <param name="bfact">[in] - blue multiplicative factor</param>
	///   <returns>pixd colormapped or rgb, with colors scaled, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MultConstantColor (Single rfact,
								  Single gfact,
								  Single bfact)
	{
		Pix RetObj = _All.pixMultConstantColor(this, rfact, gfact, bfact);
		return RetObj;
	}

	// enhance.c (2104, 1)
	// pixMultMatrixColor(pixs, kel) as Pix
	// pixMultMatrixColor(PIX *, L_KERNEL *) as PIX *
	///  <summary>
	/// (1) The kernel is a data structure used mostly for floating point
	/// convolution.  Here it is a 3x3 matrix of floats that are used
	/// to transform the pixel values by matrix multiplication:
	/// nrval = a[0,0]  rval + a[0,1]  gval + a[0,2]  bval
	/// ngval = a[1,0]  rval + a[1,1]  gval + a[1,2]  bval
	/// nbval = a[2,0]  rval + a[2,1]  gval + a[2,2]  bval<para/>
	///
	/// (2) The matrix can be generated in several ways.
	/// See kernel.c for details.  Here are two of them:
	/// (a) kel = kernelCreate(3, 3)
	/// kernelSetElement(kel, 0, 0, val00)
	/// kernelSetElement(kel, 0, 1, val01)
	/// ...
	/// (b) from a static string e.g.,:
	/// const char kdata = " 0.6  0.3 -0.2 "
	/// " 0.1  1.2  0.4 "
	/// " -0.4 0.2  0.9 "
	/// kel = kernelCreateFromString(3, 3, 0, 0, kdata)<para/>
	///
	/// (3) For the special case where the matrix is diagonal, it is easier
	/// to use pixMultConstantColor().<para/>
	///
	/// (4) Matrix entries can have positive and negative values, and can
	/// be larger than 1.0.  All transformed component values
	/// are clipped to [0, 255].
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMultMatrixColor/*"/>
	///  <param name="kel">[in] - kernel 3x3 matrix of floats</param>
	///   <returns>pixd colormapped or rgb, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MultMatrixColor (L_Kernel kel)
	{
		Pix RetObj = _All.pixMultMatrixColor(this, kel);
		return RetObj;
	}

	// enhance.c (2213, 1)
	// pixHalfEdgeByBandpass(pixs, sm1h, sm1v, sm2h, sm2v) as Pix
	// pixHalfEdgeByBandpass(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) We use symmetric smoothing filters of odd dimension,
	/// typically use 3, 5, 7, etc.  The smoothing parameters
	/// for these are 1, 2, 3, etc.  The filter size is related
	/// to the smoothing parameter by
	/// size = 2  smoothing + 1<para/>
	///
	/// (2) Because we take the difference of two lowpass filters,
	/// this is actually a bandpass filter.<para/>
	///
	/// (3) We allow both filters to be anisotropic.<para/>
	///
	/// (4) Consider either the h or v component of the 2 filters.
	/// Depending on whether sm1  is greater  sm2 or sm2  is greater  sm1, we get
	/// different halves of the smoothed gradients (or "edges").
	/// This difference of smoothed signals looks more like
	/// a second derivative of a transition, which we rectify
	/// by not allowing the signal to go below zero.  If sm1  is smaller sm2,
	/// the sm2 transition is broader, so the difference between
	/// sm1 and sm2 signals is positive on the upper half of
	/// the transition.  Likewise, if sm1  is greater  sm2, the sm1 - sm2
	/// signal difference is positive on the lower half of
	/// the transition.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixHalfEdgeByBandpass/*"/>
	///  <param name="sm1h">[in] - "half-widths" of smoothing filter sm1</param>
	///  <param name="sm1v">[in] - "half-widths" of smoothing filter sm1</param>
	///  <param name="sm2h">[in] - "half-widths" of smoothing filter sm2 require sm2 != sm1</param>
	///  <param name="sm2v">[in] - "half-widths" of smoothing filter sm2 require sm2 != sm1</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix HalfEdgeByBandpass (int sm1h,
								   int sm1v,
								   int sm2h,
								   int sm2v)
	{
		Pix RetObj = _All.pixHalfEdgeByBandpass(this, sm1h, sm1v, sm2h, sm2v);
		return RetObj;
	}

	// fhmtgen.1.c (37, 6)
	// pixHMTDwa_1(pixd, pixs, selname) as Pix
	// pixHMTDwa_1(PIX *, PIX *, const char *) as PIX *
	///  <summary>
	/// (1) This simply adds a 32 pixel border, calls the appropriate
	/// pixFHMTGen_(), and removes the border.
	/// See notes below for that function.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixHMTDwa_1/*"/>
	///  <param name="pixd">[in] - usual 3 choices: null, == pixs, != pixs</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix HMTDwa_1 (Pix pixd,
						 String selname)
	{
		Pix RetObj = _All.pixHMTDwa_1(pixd, this, selname);
		return RetObj;
	}

	// fhmtgen.1.c (38, 6)
	// pixFHMTGen_1(pixd, pixs, selname) as Pix
	// pixFHMTGen_1(PIX *, PIX *, const char *) as PIX *
	///  <summary>
	/// (1) This is a dwa implementation of the hit-miss transform
	/// on pixs by the sel.<para/>
	///
	/// (2) The sel must be limited in size to not more than 31 pixels
	/// about the origin.  It must have at least one hit, and it
	/// can have any number of misses.<para/>
	///
	/// (3) This handles all required setting of the border pixels
	/// before erosion and dilation.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFHMTGen_1/*"/>
	///  <param name="pixd">[in] - usual 3 choices: null, == pixs, != pixs</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FHMTGen_1 (Pix pixd,
						  String selname)
	{
		Pix RetObj = _All.pixFHMTGen_1(pixd, this, selname);
		return RetObj;
	}

	// finditalic.c (110, 1)
	// pixItalicWords(pixs, boxaw, pixw, pboxa, debugflag) as int
	// pixItalicWords(PIX *, BOXA *, PIX *, BOXA **, l_int32) as l_ok
	///  <summary>
	/// (1) You can input the bounding boxes for the words in one of
	/// two forms: as bounding boxes (%boxaw) or as a word mask with
	/// the word bounding boxes filled (%pixw).  For example,
	/// to compute %pixw, you can use pixWordMaskByDilation().<para/>
	///
	/// (2) Alternatively, you can set both of these inputs to NULL,
	/// in which case the word mask is generated here.  This is
	/// done by dilating and closing the input image to connect
	/// letters within a word, while leaving the words separated.
	/// The parameters are chosen under the assumption that the
	/// input is 10 to 12 pt text, scanned at about 300 ppi.<para/>
	///
	/// (3) sel_ital1 and sel_ital2 detect the right edges that are
	/// nearly vertical, at approximately the angle of italic
	/// strokes.  We use the right edge to avoid getting seeds
	/// from lower-case 'y'.  The typical italic slant has a smaller
	/// angle with the vertical than the 'W', so in most cases we
	/// will not trigger on the slanted lines in the 'W'.<para/>
	///
	/// (4) Note that sel_ital2 is shorter than sel_ital1.  It is
	/// more appropriate for a typical font scanned at 200 ppi.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixItalicWords/*"/>
	///  <param name="boxaw">[in][optional] - word bounding boxes can be NULL</param>
	///  <param name="pixw">[in][optional] - word box mask can be NULL</param>
	///  <param name="pboxa">[out] - boxa of italic words</param>
	///  <param name="debugflag">[in] - 1 for debug output 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ItalicWords (out Boxa pboxa,
							int debugflag,
							Boxa boxaw,
							Pix pixw)
	{
		int RetObj = _All.pixItalicWords(this, boxaw, pixw, out pboxa, debugflag);
		return RetObj;
	}

	// flipdetect.c (242, 1)
	// pixOrientCorrect(pixs, minupconf, minratio, pupconf, pleftconf, protation, debug) as Pix
	// pixOrientCorrect(PIX *, l_float32, l_float32, l_float32 *, l_float32 *, l_int32 *, l_int32) as PIX *
	///  <summary>
	/// (1) Simple top-level function to detect if Roman text is in
	/// reading orientation, and to rotate the image accordingly if not.<para/>
	///
	/// (2) Returns a copy if no rotation is needed.<para/>
	///
	/// (3) See notes for pixOrientDetect() and pixOrientDecision().
	/// Use 0.0 for default values for %minupconf and %minratio<para/>
	///
	/// (4) Optional output of intermediate confidence results and
	/// the rotation performed on pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOrientCorrect/*"/>
	///  <param name="minupconf">[in] - minimum value for which a decision can be made</param>
	///  <param name="minratio">[in] - minimum conf ratio required for a decision</param>
	///  <param name="pupconf">[out][optional] - use NULL to skip</param>
	///  <param name="pleftconf">[out][optional] - use NULL to skip</param>
	///  <param name="protation">[out][optional] - use NULL to skip</param>
	///  <param name="debug">[in] - 1 for debug output 0 otherwise</param>
	///   <returns>pixd  may be rotated by 90, 180 or 270 null on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OrientCorrect (Single minupconf,
							  Single minratio,
							  out Single pupconf,
							  out Single pleftconf,
							  out int protation,
							  DebugOnOff debug)
	{
		Pix RetObj = _All.pixOrientCorrect(this, minupconf, minratio, out pupconf, out pleftconf, out protation, debug);
		return RetObj;
	}

	// flipdetect.c (370, 1)
	// pixOrientDetect(pixs, pupconf, pleftconf, mincount, debug) as int
	// pixOrientDetect(PIX *, l_float32 *, l_float32 *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) See "Measuring document image skew and orientation"
	/// Dan S. Bloomberg, Gary E. Kopec and Lakshmi Dasari
	/// IS[and]T/SPIE EI'95, Conference 2422: Document Recognition II
	/// pp 302-316, Feb 6-7, 1995, San Jose, CA<para/>
	///
	/// (2) upconf is the normalized difference between up ascenders
	/// and down ascenders.  The image is analyzed without rotation
	/// for being rightside-up or upside-down.  Set [and]upconf to null
	/// to skip this operation.<para/>
	///
	/// (3) leftconf is the normalized difference between up ascenders
	/// and down ascenders in the image after it has been
	/// rotated 90 degrees clockwise.  With that rotation, ascenders
	/// projecting to the left in the source image will project up
	/// in the rotated image.  We compute this by rotating 90 degrees
	/// clockwise and testing for up and down ascenders.  Set
	/// [and]leftconf to null to skip this operation.<para/>
	///
	/// (4) Note that upconf and leftconf are not linear measures of
	/// confidence, e.g., in a range between 0 and 100.  They
	/// measure how far you are out on the tail of a (presumably)
	/// normal distribution.  For example, a confidence of 10 means
	/// that it is nearly certain that the difference did not
	/// happen at random.  However, these values must be interpreted
	/// cautiously, taking into consideration the estimated prior
	/// for a particular orientation or mirror flip. The up-down
	/// signal is very strong if applied to text with ascenders
	/// up and down, and relatively weak for text at 90 degrees,
	/// but even at 90 degrees, the difference can look significant.
	/// For example, suppose the ascenders are oriented horizontally,
	/// but the test is done vertically.  Then upconf can
	/// be  is smaller -MIN_CONF_FOR_UP_DOWN, suggesting the text may be
	/// upside-down.  However, if instead the test were done
	/// horizontally, leftconf will be very much larger
	/// (in absolute value), giving the correct orientation.<para/>
	///
	/// (5) If you compute both upconf and leftconf, and there is
	/// sufficient signal, the following table determines the
	/// cw angle necessary to rotate pixs so that the text is
	/// rightside-up:
	/// 0 deg :   upconf  is greater  is greater  1,  abs(upconf)  is greater  is greater  abs(leftconf)
	/// 90 deg :  leftconf  is greater  is greater  1,  abs(leftconf)  is greater  is greater  abs(upconf)
	/// 180 deg : upconf  is smaller is smaller -1, abs(upconf)  is greater  is greater  abs(leftconf)
	/// 270 deg : leftconf  is smaller is smaller -1, abs(leftconf)  is greater  is greater  abs(upconf)<para/>
	///
	/// (6) One should probably not interpret the direction unless
	/// there are a sufficient number of counts for both orientations,
	/// in which case neither upconf nor leftconf will be 0.0.<para/>
	///
	/// (7) Uses rasterop implementation of HMT.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOrientDetect/*"/>
	///  <param name="pupconf">[out][optional] - may be NULL</param>
	///  <param name="pleftconf">[out][optional] - may be NULL</param>
	///  <param name="mincount">[in] - min number of up + down use 0 for default</param>
	///  <param name="debug">[in] - 1 for debug output 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int OrientDetect (int mincount,
							 out Single pupconf,
							 out Single pleftconf,
							 DebugOnOff debug)
	{
		int RetObj = _All.pixOrientDetect(this, out pupconf, out pleftconf, mincount, debug);
		return RetObj;
	}

	// flipdetect.c (510, 1)
	// pixUpDownDetect(pixs, pconf, mincount, debug) as int
	// pixUpDownDetect(PIX *, l_float32 *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) Special (typical, slightly faster) case, where the pixels
	/// identified through the HMT (hit-miss transform) are not
	/// clipped by a truncated word mask pixm.  See pixOrientDetect()
	/// and pixUpDownDetectGeneral() for details.<para/>
	///
	/// (2) The returned confidence is the normalized difference
	/// between the number of detected up and down ascenders,
	/// assuming that the text is either rightside-up or upside-down
	/// and not rotated at a 90 degree angle.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixUpDownDetect/*"/>
	///  <param name="pconf">[out] - confidence that text is rightside-up</param>
	///  <param name="mincount">[in] - min number of up + down use 0 for default</param>
	///  <param name="debug">[in] - 1 for debug output 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int UpDownDetect (out Single pconf,
							 int mincount,
							 DebugOnOff debug)
	{
		int RetObj = _All.pixUpDownDetect(this, out pconf, mincount, debug);
		return RetObj;
	}

	// flipdetect.c (558, 1)
	// pixUpDownDetectGeneral(pixs, pconf, mincount, npixels, debug) as int
	// pixUpDownDetectGeneral(PIX *, l_float32 *, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) See pixOrientDetect() for other details.<para/>
	///
	/// (2) %conf is the normalized difference between the number of
	/// detected up and down ascenders, assuming that the text
	/// is either rightside-up or upside-down and not rotated
	/// at a 90 degree angle.<para/>
	///
	/// (3) The typical mode of operation is %npixels == 0.
	/// If %npixels  is greater  0, this removes HMT matches at the
	/// beginning and ending of "words."  This is useful for
	/// pages that may have mostly digits, because if npixels == 0,
	/// leading "1" and "3" digits can register as having
	/// ascenders or descenders, and "7" digits can match descenders.
	/// Consequently, a page image of only digits may register
	/// as being upside-down.<para/>
	///
	/// (4) We want to count the number of instances found using the HMT.
	/// An expensive way to do this would be to count the
	/// number of connected components.  A cheap way is to do a rank
	/// reduction cascade that reduces each component to a single
	/// pixel, and results (after two or three 2x reductions)
	/// in one pixel for each of the original components.
	/// After the reduction, you have a much smaller pix over
	/// which to count pixels.  We do only 2 reductions, because
	/// this function is designed to work for input pix between
	/// 150 and 300 ppi, and an 8x reduction on a 150 ppi image
	/// is going too far -- components will get merged.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixUpDownDetectGeneral/*"/>
	///  <param name="pconf">[out] - confidence that text is rightside-up</param>
	///  <param name="mincount">[in] - min number of up + down use 0 for default</param>
	///  <param name="npixels">[in] - number of pixels removed from each side of word box</param>
	///  <param name="debug">[in] - 1 for debug output 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int UpDownDetectGeneral (out Single pconf,
									int mincount,
									int npixels,
									DebugOnOff debug)
	{
		int RetObj = _All.pixUpDownDetectGeneral(this, out pconf, mincount, npixels, debug);
		return RetObj;
	}

	// flipdetect.c (699, 1)
	// pixOrientDetectDwa(pixs, pupconf, pleftconf, mincount, debug) as int
	// pixOrientDetectDwa(PIX *, l_float32 *, l_float32 *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) Same interface as for pixOrientDetect().  See notes
	/// there for usage.<para/>
	///
	/// (2) Uses auto-gen'd code for the Sels defined at the
	/// top of this file, with some renaming of functions.
	/// The auto-gen'd code is in fliphmtgen.c, and can
	/// be generated by a simple executable see prog/flipselgen.c.<para/>
	///
	/// (3) This runs about 2.5 times faster than the pixOrientDetect().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOrientDetectDwa/*"/>
	///  <param name="pupconf">[out][optional] - may be NULL</param>
	///  <param name="pleftconf">[out][optional] - may be NULL</param>
	///  <param name="mincount">[in] - min number of up + down use 0 for default</param>
	///  <param name="debug">[in] - 1 for debug output 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int OrientDetectDwa (int mincount,
								out Single pupconf,
								out Single pleftconf,
								DebugOnOff debug)
	{
		int RetObj = _All.pixOrientDetectDwa(this, out pupconf, out pleftconf, mincount, debug);
		return RetObj;
	}

	// flipdetect.c (752, 1)
	// pixUpDownDetectDwa(pixs, pconf, mincount, debug) as int
	// pixUpDownDetectDwa(PIX *, l_float32 *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) Faster (DWA) version of pixUpDownDetect().<para/>
	///
	/// (2) This is a special case (but typical and slightly faster) of
	/// pixUpDownDetectGeneralDwa(), where the pixels identified
	/// through the HMT (hit-miss transform) are not clipped by
	/// a truncated word mask pixm.  See pixUpDownDetectGeneral()
	/// for usage and other details.<para/>
	///
	/// (3) The returned confidence is the normalized difference
	/// between the number of detected up and down ascenders,
	/// assuming that the text is either rightside-up or upside-down
	/// and not rotated at a 90 degree angle.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixUpDownDetectDwa/*"/>
	///  <param name="pconf">[out] - confidence that text is rightside-up</param>
	///  <param name="mincount">[in] - min number of up + down use 0 for default</param>
	///  <param name="debug">[in] - 1 for debug output 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int UpDownDetectDwa (out Single pconf,
								int mincount,
								DebugOnOff debug)
	{
		int RetObj = _All.pixUpDownDetectDwa(this, out pconf, mincount, debug);
		return RetObj;
	}

	// flipdetect.c (777, 1)
	// pixUpDownDetectGeneralDwa(pixs, pconf, mincount, npixels, debug) as int
	// pixUpDownDetectGeneralDwa(PIX *, l_float32 *, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) See the notes in pixUpDownDetectGeneral() for usage.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixUpDownDetectGeneralDwa/*"/>
	///  <param name="pconf">[out] - confidence that text is rightside-up</param>
	///  <param name="mincount">[in] - min number of up + down use 0 for default</param>
	///  <param name="npixels">[in] - number of pixels removed from each side of word box</param>
	///  <param name="debug">[in] - 1 for debug output 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int UpDownDetectGeneralDwa (out Single pconf,
									   int mincount,
									   int npixels,
									   DebugOnOff debug)
	{
		int RetObj = _All.pixUpDownDetectGeneralDwa(this, out pconf, mincount, npixels, debug);
		return RetObj;
	}

	// flipdetect.c (934, 1)
	// pixMirrorDetect(pixs, pconf, mincount, debug) as int
	// pixMirrorDetect(PIX *, l_float32 *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) For this test, it is necessary that the text is horizontally
	/// oriented, with ascenders going up.<para/>
	///
	/// (2) conf is the normalized difference between the number of
	/// right and left facing characters with ascenders.
	/// Left-facing are {d} right-facing are {b, h, k}.
	/// At least that was the expectation.  In practice, we can
	/// really just say that it is the normalized difference in
	/// hits using two specific hit-miss filters, textsel1 and textsel2,
	/// after the image has been suitably pre-filtered so that
	/// these filters are effective.  See (4) for what's really happening.<para/>
	///
	/// (3) A large positive conf value indicates normal text, whereas
	/// a large negative conf value means the page is mirror reversed.<para/>
	///
	/// (4) The implementation is a bit tricky.  The general idea is
	/// to fill the x-height part of characters, but not the space
	/// between them, before doing the HMT.  This is done by
	/// finding pixels added using two different operations -- a
	/// horizontal close and a vertical dilation -- and adding
	/// the intersection of these sets to the original.  It turns
	/// out that the original intuition about the signal was largely
	/// in error: much of the signal for right-facing characters
	/// comes from the lower part of common x-height characters, like
	/// the e and c, that remain open after these operations.
	/// So it's important that the operations to close the x-height
	/// parts of the characters are purposely weakened sufficiently
	/// to allow these characters to remain open.  The wonders
	/// of morphology!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMirrorDetect/*"/>
	///  <param name="pconf">[out] - confidence that text is not LR mirror reversed</param>
	///  <param name="mincount">[in] - min number of left + right use 0 for default</param>
	///  <param name="debug">[in] - 1 for debug output 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int MirrorDetect (out Single pconf,
							 int mincount,
							 DebugOnOff debug)
	{
		int RetObj = _All.pixMirrorDetect(this, out pconf, mincount, debug);
		return RetObj;
	}

	// flipdetect.c (1025, 1)
	// pixMirrorDetectDwa(pixs, pconf, mincount, debug) as int
	// pixMirrorDetectDwa(PIX *, l_float32 *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) We assume the text is horizontally oriented, with
	/// ascenders going up.<para/>
	///
	/// (2) See notes in pixMirrorDetect().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMirrorDetectDwa/*"/>
	///  <param name="pconf">[out] - confidence that text is not LR mirror reversed</param>
	///  <param name="mincount">[in] - min number of left + right use 0 for default</param>
	///  <param name="debug">[in] - 1 for debug output 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int MirrorDetectDwa (out Single pconf,
								int mincount,
								DebugOnOff debug)
	{
		int RetObj = _All.pixMirrorDetectDwa(this, out pconf, mincount, debug);
		return RetObj;
	}

	// fliphmtgen.c (77, 1)
	// pixFlipFHMTGen(pixd, pixs, selname) as Pix
	// pixFlipFHMTGen(PIX *, PIX *, const char *) as PIX *
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFlipFHMTGen/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FlipFHMTGen (Pix pixd,
							String selname)
	{
		Pix RetObj = _All.pixFlipFHMTGen(pixd, this, selname);
		return RetObj;
	}

	// fmorphgen.1.c (37, 6)
	// pixMorphDwa_1(pixd, pixs, operation, selname) as Pix
	// pixMorphDwa_1(PIX *, PIX *, l_int32, char *) as PIX *
	///  <summary>
	/// (1) This simply adds a border, calls the appropriate
	/// pixFMorphopGen_(), and removes the border.
	/// See the notes for that function.<para/>
	///
	/// (2) The size of the border depends on the operation
	/// and the boundary conditions.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMorphDwa_1/*"/>
	///  <param name="pixd">[in] - usual 3 choices: null, == pixs, != pixs</param>
	///  <param name="operation">[in] - L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, L_MORPH_CLOSE</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MorphDwa_1 (Pix pixd,
						   int operation,
						   String selname)
	{
		Pix RetObj = _All.pixMorphDwa_1(pixd, this, operation, selname);
		return RetObj;
	}

	// fmorphgen.1.c (38, 6)
	// pixFMorphopGen_1(pixd, pixs, operation, selname) as Pix
	// pixFMorphopGen_1(PIX *, PIX *, l_int32, char *) as PIX *
	///  <summary>
	/// (1) This is a dwa operation, and the Sels must be limited in
	/// size to not more than 31 pixels about the origin.<para/>
	///
	/// (2) A border of appropriate size (32 pixels, or 64 pixels
	/// for safe closing with asymmetric b.c.) must be added before
	/// this function is called.<para/>
	///
	/// (3) This handles all required setting of the border pixels
	/// before erosion and dilation.<para/>
	///
	/// (4) The closing operation is safe no pixels can be removed
	/// near the boundary.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFMorphopGen_1/*"/>
	///  <param name="pixd">[in] - usual 3 choices: null, == pixs, != pixs</param>
	///  <param name="operation">[in] - L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, L_MORPH_CLOSE</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FMorphopGen_1 (Pix pixd,
							  int operation,
							  String selname)
	{
		Pix RetObj = _All.pixFMorphopGen_1(pixd, this, operation, selname);
		return RetObj;
	}

	// fpix2.c (124, 1)
	// pixConvertToFPix(pixs, ncomps) as FPix
	// pixConvertToFPix(PIX *, l_int32) as FPIX *
	///  <summary>
	/// (1) If colormapped, remove to grayscale.<para/>
	///
	/// (2) If 32 bpp and %ncomps == 3, this is RGB convert to luminance.
	/// In all other cases the src image is treated as having a single
	/// component of pixel values.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertToFPix/*"/>
	///  <param name="ncomps">[in] - number of components: 3 for RGB, 1 otherwise</param>
	///   <returns>fpix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix ConvertToFPix (int ncomps)
	{
		FPix RetObj = _All.pixConvertToFPix(this, ncomps);
		return RetObj;
	}

	// fpix2.c (217, 1)
	// pixConvertToDPix(pixs, ncomps) as DPix
	// pixConvertToDPix(PIX *, l_int32) as DPIX *
	///  <summary>
	/// (1) If colormapped, remove to grayscale.<para/>
	///
	/// (2) If 32 bpp and %ncomps == 3, this is RGB convert to luminance.
	/// In all other cases the src image is treated as having a single
	/// component of pixel values.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertToDPix/*"/>
	///  <param name="ncomps">[in] - number of components: 3 for RGB, 1 otherwise</param>
	///   <returns>dpix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public DPix ConvertToDPix (int ncomps)
	{
		DPix RetObj = _All.pixConvertToDPix(this, ncomps);
		return RetObj;
	}

	// fpix2.c (2391, 1)
	// pixComponentFunction(pix, rnum, gnum, bnum, rdenom, gdenom, bdenom) as FPix
	// pixComponentFunction(PIX *, l_float32, l_float32, l_float32, l_float32, l_float32, l_float32) as FPIX *
	///  <summary>
	/// (1) This stores a function of the component values of each
	/// input pixel in %fpixd.<para/>
	///
	/// (2) The function is a ratio of linear combinations of component values.
	/// There are two special cases for denominator coefficients:
	/// (a) The denominator is 1.0: input 0 for all denominator coefficients
	/// (b) Only one component is used in the denominator: input 1.0
	/// for that denominator component and 0.0 for the other two.<para/>
	///
	/// (3) If the denominator is 0, multiply by an arbitrary number that
	/// is much larger than 1.  Choose 256 "arbitrarily".
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixComponentFunction/*"/>
	///  <param name="pix">[in] - 32 bpp rgb</param>
	///  <param name="rnum">[in] - coefficients for numerator</param>
	///  <param name="gnum">[in] - coefficients for numerator</param>
	///  <param name="bnum">[in] - coefficients for numerator</param>
	///  <param name="rdenom">[in] - coefficients for denominator</param>
	///  <param name="gdenom">[in] - coefficients for denominator</param>
	///  <param name="bdenom">[in] - coefficients for denominator</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix ComponentFunction (Pix pix,
								   Single rnum,
								   Single gnum,
								   Single bnum,
								   Single rdenom,
								   Single gdenom,
								   Single bdenom)
	{
		FPix RetObj = _All.pixComponentFunction(pix, rnum, gnum, bnum, rdenom, gdenom, bdenom);
		return RetObj;
	}

	// gifiostub.c (45, 7)
	// pixReadStreamGif(fp) as Pix
	// pixReadStreamGif(FILE *) as PIX *
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadStreamGif/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadStreamGif (FILE fp)
	{
		Pix RetObj = _All.pixReadStreamGif(fp);
		return RetObj;
	}

	// gifiostub.c (52, 7)
	// pixReadMemGif(cdata, size) as Pix
	// pixReadMemGif(const l_uint8 *, size_t) as PIX *
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadMemGif/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadMemGif (Byte[] cdata,
						   uint size)
	{
		Pix RetObj = _All.pixReadMemGif(cdata, size);
		return RetObj;
	}

	// gifiostub.c (59, 6)
	// pixWriteStreamGif(fp, pix) as int
	// pixWriteStreamGif(FILE *, PIX *) as l_ok
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamGif/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamGif (FILE fp,
							   Pix pix)
	{
		int RetObj = _All.pixWriteStreamGif(fp, pix);
		return RetObj;
	}

	// gifiostub.c (66, 6)
	// pixWriteMemGif(pdata, psize, pix) as int
	// pixWriteMemGif(l_uint8 **, size_t *, PIX *) as l_ok
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMemGif/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemGif (object pdata,
							object psize,
							Pix pix)
	{
		int RetObj = _All.pixWriteMemGif(pdata, psize, pix);
		return RetObj;
	}

	// graphics.c (963, 1)
	// pixRenderPlotFromNuma(ppix, na, plotloc, linewidth, max, color) as int
	// pixRenderPlotFromNuma(PIX **, NUMA *, l_int32, l_int32, l_int32, l_uint32) as l_ok
	///  <summary>
	/// (1) Simplified interface for plotting row or column aligned data
	/// on a pix.<para/>
	///
	/// (2) This replaces %pix with a 32 bpp rgb version if it is not
	/// already 32 bpp.  It then draws the plot on the pix.<para/>
	///
	/// (3) See makePlotPtaFromNumaGen() for more details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderPlotFromNuma/*"/>
	///  <param name="ppix">[in,out] - any type replaced if not 32 bpp rgb</param>
	///  <param name="na">[in] - to be plotted</param>
	///  <param name="plotloc">[in] - location of plot: L_PLOT_AT_TOP, etc</param>
	///  <param name="linewidth">[in] - width of "line" that is drawn between 1 and 7</param>
	///  <param name="max">[in] - maximum excursion in pixels from baseline</param>
	///  <param name="color">[in] - plot color: 0xrrggbb00</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderPlotFromNuma (ref Pix ppix,
								   Numa na,
								   int plotloc,
								   int linewidth,
								   int max,
								   uint color)
	{
		int RetObj = _All.pixRenderPlotFromNuma(ref ppix, na, plotloc, linewidth, max, color);
		return RetObj;
	}

	// graphics.c (1077, 1)
	// pixRenderPlotFromNumaGen(ppix, na, orient, linewidth, refpos, max, drawref, color) as int
	// pixRenderPlotFromNumaGen(PIX **, NUMA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_uint32) as l_ok
	///  <summary>
	/// (1) General interface for plotting row or column aligned data
	/// on a pix.<para/>
	///
	/// (2) This replaces %pix with a 32 bpp rgb version if it is not
	/// already 32 bpp.  It then draws the plot on the pix.<para/>
	///
	/// (3) See makePlotPtaFromNumaGen() for other input parameters.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderPlotFromNumaGen/*"/>
	///  <param name="ppix">[in,out] - any type replaced if not 32 bpp rgb</param>
	///  <param name="na">[in] - to be plotted</param>
	///  <param name="orient">[in] - L_HORIZONTAL_LINE, L_VERTICAL_LINE</param>
	///  <param name="linewidth">[in] - width of "line" that is drawn between 1 and 7</param>
	///  <param name="refpos">[in] - reference position: y for horizontal and x for vertical</param>
	///  <param name="max">[in] - maximum excursion in pixels from baseline</param>
	///  <param name="drawref">[in] - 1 to draw the reference line and the normal to it</param>
	///  <param name="color">[in] - plot color: 0xrrggbb00</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderPlotFromNumaGen (ref Pix ppix,
									  Numa na,
									  int orient,
									  int linewidth,
									  int refpos,
									  int max,
									  int drawref,
									  uint color)
	{
		int RetObj = _All.pixRenderPlotFromNumaGen(ref ppix, na, orient, linewidth, refpos, max, drawref, color);
		return RetObj;
	}

	// graphics.c (1254, 1)
	// pixRenderPta(pix, pta, op) as int
	// pixRenderPta(PIX *, PTA *, l_int32) as l_ok
	///  <summary>
	/// (1) L_SET_PIXELS puts all image bits in each pixel to 1
	/// (black for 1 bpp white for depth  is greater  1)<para/>
	///
	/// (2) L_CLEAR_PIXELS puts all image bits in each pixel to 0
	/// (white for 1 bpp black for depth  is greater  1)<para/>
	///
	/// (3) L_FLIP_PIXELS reverses all image bits in each pixel<para/>
	///
	/// (4) This function clips the rendering to the pix.  It performs
	/// clipping for functions such as pixRenderLine(),
	/// pixRenderBox() and pixRenderBoxa(), that call pixRenderPta().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderPta/*"/>
	///  <param name="pix">[in] - any depth, not cmapped</param>
	///  <param name="pta">[in] - arbitrary set of points</param>
	///  <param name="op">[in] - one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderPta (Pix pix,
						  Pta pta,
						  int op)
	{
		int RetObj = _All.pixRenderPta(pix, pta, op);
		return RetObj;
	}

	// graphics.c (1343, 1)
	// pixRenderPtaArb(pix, pta, rval, gval, bval) as int
	// pixRenderPtaArb(PIX *, PTA *, l_uint8, l_uint8, l_uint8) as l_ok
	///  <summary>
	/// (1) If pix is colormapped, render this color (or the nearest
	/// color if the cmap is full) on each pixel.<para/>
	///
	/// (2) The rgb components have the standard dynamic range [0 ... 255]<para/>
	///
	/// (3) If pix is not colormapped, do the best job you can using
	/// the input colors:
	/// ~ d = 1: set the pixels
	/// ~ d = 2, 4, 8: average the input rgb value
	/// ~ d = 32: use the input rgb value<para/>
	///
	/// (4) This function clips the rendering to the pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderPtaArb/*"/>
	///  <param name="pix">[in] - any depth, cmapped ok</param>
	///  <param name="pta">[in] - arbitrary set of points</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderPtaArb (Pix pix,
							 Pta pta,
							 byte rval,
							 byte gval,
							 byte bval)
	{
		int RetObj = _All.pixRenderPtaArb(pix, pta, rval, gval, bval);
		return RetObj;
	}

	// graphics.c (1418, 1)
	// pixRenderPtaBlend(pix, pta, rval, gval, bval, fract) as int
	// pixRenderPtaBlend(PIX *, PTA *, l_uint8, l_uint8, l_uint8, l_float32) as l_ok
	///  <summary>
	/// (1) This function clips the rendering to the pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderPtaBlend/*"/>
	///  <param name="pix">[in] - 32 bpp rgb</param>
	///  <param name="pta">[in] - arbitrary set of points</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///  <param name="fract">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderPtaBlend (Pix pix,
							   Pta pta,
							   byte rval,
							   byte gval,
							   byte bval,
							   Single fract)
	{
		int RetObj = _All.pixRenderPtaBlend(pix, pta, rval, gval, bval, fract);
		return RetObj;
	}

	// graphics.c (1483, 1)
	// pixRenderLine(pix, x1, y1, x2, y2, width, op) as int
	// pixRenderLine(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixRenderLine()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderLine/*"/>
	///  <param name="pix">[in] - any depth, not cmapped</param>
	///  <param name="x1">[in] - </param>
	///  <param name="y1">[in] - </param>
	///  <param name="x2">[in] - </param>
	///  <param name="y2">[in] - </param>
	///  <param name="width">[in] - thickness of line</param>
	///  <param name="op">[in] - one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderLine (Pix pix,
						   int x1,
						   int y1,
						   int x2,
						   int y2,
						   int width,
						   int op)
	{
		int RetObj = _All.pixRenderLine(pix, x1, y1, x2, y2, width, op);
		return RetObj;
	}

	// graphics.c (1523, 1)
	// pixRenderLineArb(pix, x1, y1, x2, y2, width, rval, gval, bval) as int
	// pixRenderLineArb(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_uint8, l_uint8, l_uint8) as l_ok
	///  <summary>
	/// pixRenderLineArb()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderLineArb/*"/>
	///  <param name="pix">[in] - any depth, cmapped ok</param>
	///  <param name="x1">[in] - </param>
	///  <param name="y1">[in] - </param>
	///  <param name="x2">[in] - </param>
	///  <param name="y2">[in] - </param>
	///  <param name="width">[in] - thickness of line</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderLineArb (Pix pix,
							  int x1,
							  int y1,
							  int x2,
							  int y2,
							  int width,
							  byte rval,
							  byte gval,
							  byte bval)
	{
		int RetObj = _All.pixRenderLineArb(pix, x1, y1, x2, y2, width, rval, gval, bval);
		return RetObj;
	}

	// graphics.c (1564, 1)
	// pixRenderLineBlend(pix, x1, y1, x2, y2, width, rval, gval, bval, fract) as int
	// pixRenderLineBlend(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_uint8, l_uint8, l_uint8, l_float32) as l_ok
	///  <summary>
	/// pixRenderLineBlend()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderLineBlend/*"/>
	///  <param name="pix">[in] - 32 bpp rgb</param>
	///  <param name="x1">[in] - </param>
	///  <param name="y1">[in] - </param>
	///  <param name="x2">[in] - </param>
	///  <param name="y2">[in] - </param>
	///  <param name="width">[in] - thickness of line</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///  <param name="fract">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderLineBlend (Pix pix,
								int x1,
								int y1,
								int x2,
								int y2,
								int width,
								byte rval,
								byte gval,
								byte bval,
								Single fract)
	{
		int RetObj = _All.pixRenderLineBlend(pix, x1, y1, x2, y2, width, rval, gval, bval, fract);
		return RetObj;
	}

	// graphics.c (1604, 1)
	// pixRenderBox(pix, box, width, op) as int
	// pixRenderBox(PIX *, BOX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixRenderBox()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderBox/*"/>
	///  <param name="pix">[in] - any depth, not cmapped</param>
	///  <param name="box">[in] - </param>
	///  <param name="width">[in] - thickness of box lines</param>
	///  <param name="op">[in] - one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderBox (Pix pix,
						  Box box,
						  int width,
						  int op)
	{
		int RetObj = _All.pixRenderBox(pix, box, width, op);
		return RetObj;
	}

	// graphics.c (1642, 1)
	// pixRenderBoxArb(pix, box, width, rval, gval, bval) as int
	// pixRenderBoxArb(PIX *, BOX *, l_int32, l_uint8, l_uint8, l_uint8) as l_ok
	///  <summary>
	/// pixRenderBoxArb()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderBoxArb/*"/>
	///  <param name="pix">[in] - any depth, cmapped ok</param>
	///  <param name="box">[in] - </param>
	///  <param name="width">[in] - thickness of box lines</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderBoxArb (Pix pix,
							 Box box,
							 int width,
							 byte rval,
							 byte gval,
							 byte bval)
	{
		int RetObj = _All.pixRenderBoxArb(pix, box, width, rval, gval, bval);
		return RetObj;
	}

	// graphics.c (1682, 1)
	// pixRenderBoxBlend(pix, box, width, rval, gval, bval, fract) as int
	// pixRenderBoxBlend(PIX *, BOX *, l_int32, l_uint8, l_uint8, l_uint8, l_float32) as l_ok
	///  <summary>
	/// pixRenderBoxBlend()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderBoxBlend/*"/>
	///  <param name="pix">[in] - 32 bpp rgb</param>
	///  <param name="box">[in] - </param>
	///  <param name="width">[in] - thickness of box lines</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///  <param name="fract">[in] - in [0.0 - 1.0] complete transparency (no effect if 0.0 no transparency if 1.0)</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderBoxBlend (Pix pix,
							   Box box,
							   int width,
							   byte rval,
							   byte gval,
							   byte bval,
							   Single fract)
	{
		int RetObj = _All.pixRenderBoxBlend(pix, box, width, rval, gval, bval, fract);
		return RetObj;
	}

	// graphics.c (1721, 1)
	// pixRenderBoxa(pix, boxa, width, op) as int
	// pixRenderBoxa(PIX *, BOXA *, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixRenderBoxa()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderBoxa/*"/>
	///  <param name="pix">[in] - any depth, not cmapped</param>
	///  <param name="boxa">[in] - </param>
	///  <param name="width">[in] - thickness of line</param>
	///  <param name="op">[in] - one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderBoxa (Pix pix,
						   Boxa boxa,
						   int width,
						   int op)
	{
		int RetObj = _All.pixRenderBoxa(pix, boxa, width, op);
		return RetObj;
	}

	// graphics.c (1759, 1)
	// pixRenderBoxaArb(pix, boxa, width, rval, gval, bval) as int
	// pixRenderBoxaArb(PIX *, BOXA *, l_int32, l_uint8, l_uint8, l_uint8) as l_ok
	///  <summary>
	/// pixRenderBoxaArb()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderBoxaArb/*"/>
	///  <param name="pix">[in] - any depth colormapped is ok</param>
	///  <param name="boxa">[in] - </param>
	///  <param name="width">[in] - thickness of line</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderBoxaArb (Pix pix,
							  Boxa boxa,
							  int width,
							  byte rval,
							  byte gval,
							  byte bval)
	{
		int RetObj = _All.pixRenderBoxaArb(pix, boxa, width, rval, gval, bval);
		return RetObj;
	}

	// graphics.c (1800, 1)
	// pixRenderBoxaBlend(pix, boxa, width, rval, gval, bval, fract, removedups) as int
	// pixRenderBoxaBlend(PIX *, BOXA *, l_int32, l_uint8, l_uint8, l_uint8, l_float32, l_int32) as l_ok
	///  <summary>
	/// pixRenderBoxaBlend()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderBoxaBlend/*"/>
	///  <param name="pix">[in] - 32 bpp rgb</param>
	///  <param name="boxa">[in] - </param>
	///  <param name="width">[in] - thickness of line</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///  <param name="fract">[in] - in [0.0 - 1.0] complete transparency (no effect if 0.0 no transparency if 1.0)</param>
	///  <param name="removedups">[in] - 1 to remove 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderBoxaBlend (Pix pix,
								Boxa boxa,
								int width,
								byte rval,
								byte gval,
								byte bval,
								Single fract,
								int removedups)
	{
		int RetObj = _All.pixRenderBoxaBlend(pix, boxa, width, rval, gval, bval, fract, removedups);
		return RetObj;
	}

	// graphics.c (1843, 1)
	// pixRenderHashBox(pix, box, spacing, width, orient, outline, op) as int
	// pixRenderHashBox(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixRenderHashBox()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderHashBox/*"/>
	///  <param name="pix">[in] - any depth, not cmapped</param>
	///  <param name="box">[in] - </param>
	///  <param name="spacing">[in] - spacing between lines must be  is greater  1</param>
	///  <param name="width">[in] - thickness of box and hash lines</param>
	///  <param name="orient">[in] - orientation of lines: L_HORIZONTAL_LINE, ...</param>
	///  <param name="outline">[in] - 0 to skip drawing box outline</param>
	///  <param name="op">[in] - one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderHashBox (Pix pix,
							  Box box,
							  int spacing,
							  int width,
							  int orient,
							  int outline,
							  int op)
	{
		int RetObj = _All.pixRenderHashBox(pix, box, spacing, width, orient, outline, op);
		return RetObj;
	}

	// graphics.c (1893, 1)
	// pixRenderHashBoxArb(pix, box, spacing, width, orient, outline, rval, gval, bval) as int
	// pixRenderHashBoxArb(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixRenderHashBoxArb()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderHashBoxArb/*"/>
	///  <param name="pix">[in] - any depth cmapped ok</param>
	///  <param name="box">[in] - </param>
	///  <param name="spacing">[in] - spacing between lines must be  is greater  1</param>
	///  <param name="width">[in] - thickness of box and hash lines</param>
	///  <param name="orient">[in] - orientation of lines: L_HORIZONTAL_LINE, ...</param>
	///  <param name="outline">[in] - 0 to skip drawing box outline</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderHashBoxArb (Pix pix,
								 Box box,
								 int spacing,
								 int width,
								 int orient,
								 int outline,
								 int rval,
								 int gval,
								 int bval)
	{
		int RetObj = _All.pixRenderHashBoxArb(pix, box, spacing, width, orient, outline, rval, gval, bval);
		return RetObj;
	}

	// graphics.c (1945, 1)
	// pixRenderHashBoxBlend(pix, box, spacing, width, orient, outline, rval, gval, bval, fract) as int
	// pixRenderHashBoxBlend(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_float32) as l_ok
	///  <summary>
	/// pixRenderHashBoxBlend()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderHashBoxBlend/*"/>
	///  <param name="pix">[in] - 32 bpp</param>
	///  <param name="box">[in] - </param>
	///  <param name="spacing">[in] - spacing between lines must be  is greater  1</param>
	///  <param name="width">[in] - thickness of box and hash lines</param>
	///  <param name="orient">[in] - orientation of lines: L_HORIZONTAL_LINE, ...</param>
	///  <param name="outline">[in] - 0 to skip drawing box outline</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///  <param name="fract">[in] - in [0.0 - 1.0] complete transparency (no effect if 0.0 no transparency if 1.0)</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderHashBoxBlend (Pix pix,
								   Box box,
								   int spacing,
								   int width,
								   int orient,
								   int outline,
								   int rval,
								   int gval,
								   int bval,
								   Single fract)
	{
		int RetObj = _All.pixRenderHashBoxBlend(pix, box, spacing, width, orient, outline, rval, gval, bval, fract);
		return RetObj;
	}

	// graphics.c (2003, 1)
	// pixRenderHashMaskArb(pix, pixm, x, y, spacing, width, orient, outline, rval, gval, bval) as int
	// pixRenderHashMaskArb(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place operation that renders hash lines
	/// through a mask %pixm onto %pix.  The mask origin is
	/// translated by (%x,%y) relative to the origin of %pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderHashMaskArb/*"/>
	///  <param name="pix">[in] - any depth cmapped ok</param>
	///  <param name="pixm">[in] - 1 bpp clipping mask for hash marks</param>
	///  <param name="x">[in] - ,y   UL corner of %pixm with respect to %pix</param>
	///  <param name="spacing">[in] - spacing between lines must be  is greater  1</param>
	///  <param name="width">[in] - thickness of box and hash lines</param>
	///  <param name="orient">[in] - orientation of lines: L_HORIZONTAL_LINE, ...</param>
	///  <param name="outline">[in] - 0 to skip drawing box outline</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderHashMaskArb (Pix pix,
								  Pix pixm,
								  int x,
								  int y,
								  int spacing,
								  int width,
								  int orient,
								  int outline,
								  int rval,
								  int gval,
								  int bval)
	{
		int RetObj = _All.pixRenderHashMaskArb(pix, pixm, x, y, spacing, width, orient, outline, rval, gval, bval);
		return RetObj;
	}

	// graphics.c (2071, 1)
	// pixRenderHashBoxa(pix, boxa, spacing, width, orient, outline, op) as int
	// pixRenderHashBoxa(PIX *, BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixRenderHashBoxa()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderHashBoxa/*"/>
	///  <param name="pix">[in] - any depth, not cmapped</param>
	///  <param name="boxa">[in] - </param>
	///  <param name="spacing">[in] - spacing between lines must be  is greater  1</param>
	///  <param name="width">[in] - thickness of box and hash lines</param>
	///  <param name="orient">[in] - orientation of lines: L_HORIZONTAL_LINE, ...</param>
	///  <param name="outline">[in] - 0 to skip drawing box outline</param>
	///  <param name="op">[in] - one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderHashBoxa (Pix pix,
							   Boxa boxa,
							   int spacing,
							   int width,
							   int orient,
							   int outline,
							   int op)
	{
		int RetObj = _All.pixRenderHashBoxa(pix, boxa, spacing, width, orient, outline, op);
		return RetObj;
	}

	// graphics.c (2121, 1)
	// pixRenderHashBoxaArb(pix, boxa, spacing, width, orient, outline, rval, gval, bval) as int
	// pixRenderHashBoxaArb(PIX *, BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixRenderHashBoxaArb()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderHashBoxaArb/*"/>
	///  <param name="pix">[in] - any depth cmapped ok</param>
	///  <param name="boxa">[in] - </param>
	///  <param name="spacing">[in] - spacing between lines must be  is greater  1</param>
	///  <param name="width">[in] - thickness of box and hash lines</param>
	///  <param name="orient">[in] - orientation of lines: L_HORIZONTAL_LINE, ...</param>
	///  <param name="outline">[in] - 0 to skip drawing box outline</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderHashBoxaArb (Pix pix,
								  Boxa boxa,
								  int spacing,
								  int width,
								  int orient,
								  int outline,
								  int rval,
								  int gval,
								  int bval)
	{
		int RetObj = _All.pixRenderHashBoxaArb(pix, boxa, spacing, width, orient, outline, rval, gval, bval);
		return RetObj;
	}

	// graphics.c (2173, 1)
	// pixRenderHashBoxaBlend(pix, boxa, spacing, width, orient, outline, rval, gval, bval, fract) as int
	// pixRenderHashBoxaBlend(PIX *, BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_float32) as l_ok
	///  <summary>
	/// pixRenderHashBoxaBlend()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderHashBoxaBlend/*"/>
	///  <param name="pix">[in] - 32 bpp rgb</param>
	///  <param name="boxa">[in] - </param>
	///  <param name="spacing">[in] - spacing between lines must be  is greater  1</param>
	///  <param name="width">[in] - thickness of box and hash lines</param>
	///  <param name="orient">[in] - orientation of lines: L_HORIZONTAL_LINE, ...</param>
	///  <param name="outline">[in] - 0 to skip drawing box outline</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///  <param name="fract">[in] - in [0.0 - 1.0] complete transparency (no effect if 0.0 no transparency if 1.0)</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderHashBoxaBlend (Pix pix,
									Boxa boxa,
									int spacing,
									int width,
									int orient,
									int outline,
									int rval,
									int gval,
									int bval,
									Single fract)
	{
		int RetObj = _All.pixRenderHashBoxaBlend(pix, boxa, spacing, width, orient, outline, rval, gval, bval, fract);
		return RetObj;
	}

	// graphics.c (2227, 1)
	// pixRenderPolyline(pix, ptas, width, op, closeflag) as int
	// pixRenderPolyline(PIX *, PTA *, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// This renders a closed contour.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderPolyline/*"/>
	///  <param name="pix">[in] - any depth, not cmapped</param>
	///  <param name="ptas">[in] - </param>
	///  <param name="width">[in] - thickness of line</param>
	///  <param name="op">[in] - one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	///  <param name="closeflag">[in] - 1 to close the contour 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderPolyline (Pix pix,
							   Pta ptas,
							   int width,
							   int op,
							   int closeflag)
	{
		int RetObj = _All.pixRenderPolyline(pix, ptas, width, op, closeflag);
		return RetObj;
	}

	// graphics.c (2272, 1)
	// pixRenderPolylineArb(pix, ptas, width, rval, gval, bval, closeflag) as int
	// pixRenderPolylineArb(PIX *, PTA *, l_int32, l_uint8, l_uint8, l_uint8, l_int32) as l_ok
	///  <summary>
	/// This renders a closed contour.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderPolylineArb/*"/>
	///  <param name="pix">[in] - any depth cmapped ok</param>
	///  <param name="ptas">[in] - </param>
	///  <param name="width">[in] - thickness of line</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///  <param name="closeflag">[in] - 1 to close the contour 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderPolylineArb (Pix pix,
								  Pta ptas,
								  int width,
								  byte rval,
								  byte gval,
								  byte bval,
								  int closeflag)
	{
		int RetObj = _All.pixRenderPolylineArb(pix, ptas, width, rval, gval, bval, closeflag);
		return RetObj;
	}

	// graphics.c (2315, 1)
	// pixRenderPolylineBlend(pix, ptas, width, rval, gval, bval, fract, closeflag, removedups) as int
	// pixRenderPolylineBlend(PIX *, PTA *, l_int32, l_uint8, l_uint8, l_uint8, l_float32, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixRenderPolylineBlend()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderPolylineBlend/*"/>
	///  <param name="pix">[in] - 32 bpp rgb</param>
	///  <param name="ptas">[in] - </param>
	///  <param name="width">[in] - thickness of line</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///  <param name="fract">[in] - in [0.0 - 1.0] complete transparency (no effect if 0.0 no transparency if 1.0)</param>
	///  <param name="closeflag">[in] - 1 to close the contour 0 otherwise</param>
	///  <param name="removedups">[in] - 1 to remove 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderPolylineBlend (Pix pix,
									Pta ptas,
									int width,
									byte rval,
									byte gval,
									byte bval,
									Single fract,
									int closeflag,
									int removedups)
	{
		int RetObj = _All.pixRenderPolylineBlend(pix, ptas, width, rval, gval, bval, fract, closeflag, removedups);
		return RetObj;
	}

	// graphics.c (2356, 1)
	// pixRenderGridArb(pix, nx, ny, width, rval, gval, bval) as int
	// pixRenderGridArb(PIX *, l_int32, l_int32, l_int32, l_uint8, l_uint8, l_uint8) as l_ok
	///  <summary>
	/// pixRenderGridArb()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderGridArb/*"/>
	///  <param name="pix">[in] - any depth, cmapped ok</param>
	///  <param name="nx">[in] - number of rectangles in each direction</param>
	///  <param name="ny">[in] - number of rectangles in each direction</param>
	///  <param name="width">[in] - thickness of grid lines</param>
	///  <param name="rval">[in] - </param>
	///  <param name="gval">[in] - </param>
	///  <param name="bval">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RenderGridArb (Pix pix,
							  int nx,
							  int ny,
							  int width,
							  byte rval,
							  byte gval,
							  byte bval)
	{
		int RetObj = _All.pixRenderGridArb(pix, nx, ny, width, rval, gval, bval);
		return RetObj;
	}

	// graphics.c (2416, 1)
	// pixRenderRandomCmapPtaa(pix, ptaa, polyflag, width, closeflag) as Pix
	// pixRenderRandomCmapPtaa(PIX *, PTAA *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This is a debugging routine, that displays a set of
	/// pixels, selected by the set of Ptas in a Ptaa,
	/// in a random color in a pix.<para/>
	///
	/// (2) If %polyflag == 1, each Pta is considered to be a polyline,
	/// and is rendered using %width and %closeflag.  Each polyline
	/// is rendered in a random color.<para/>
	///
	/// (3) If %polyflag == 0, all points in each Pta are rendered in a
	/// random color.  The %width and %closeflag parameters are ignored.<para/>
	///
	/// (4) The output pix is 8 bpp and colormapped.  Up to 254
	/// different, randomly selected colors, can be used.<para/>
	///
	/// (5) The rendered pixels replace the input pixels.  They will
	/// be clipped silently to the input pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderRandomCmapPtaa/*"/>
	///  <param name="pix">[in] - 1, 2, 4, 8, 16, 32 bpp</param>
	///  <param name="ptaa">[in] - </param>
	///  <param name="polyflag">[in] - 1 to interpret each Pta as a polyline 0 to simply render the Pta as a set of pixels</param>
	///  <param name="width">[in] - thickness of line use only for polyline</param>
	///  <param name="closeflag">[in] - 1 to close the contour 0 otherwise use only for polyline mode</param>
	///   <returns>pixd cmapped, 8 bpp or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RenderRandomCmapPtaa (Ptaa ptaa,
									 int polyflag,
									 int width,
									 int closeflag,
									 Pix pix)
	{
		Pix RetObj = _All.pixRenderRandomCmapPtaa(pix, ptaa, polyflag, width, closeflag);
		return RetObj;
	}

	// graphics.c (2485, 1)
	// pixRenderPolygon(ptas, width, pxmin, pymin) as Pix
	// pixRenderPolygon(PTA *, l_int32, l_int32 *, l_int32 *) as PIX *
	///  <summary>
	/// (1) The pix is the minimum size required to contain the origin
	/// and the polygon.  For example, the max x value of the input
	/// points is w - 1, where w is the pix width.<para/>
	///
	/// (2) The rendered line is 4-connected, so that an interior or
	/// exterior 8-c.c. flood fill operation works properly.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderPolygon/*"/>
	///  <param name="ptas">[in] - of vertices, none repeated</param>
	///  <param name="width">[in] - of polygon outline</param>
	///  <param name="pxmin">[out][optional] - min x value of input pts</param>
	///  <param name="pymin">[out][optional] - min y value of input pts</param>
	///   <returns>pix 1 bpp, with outline generated, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RenderPolygon (Pta ptas,
							  int width,
							  out int pxmin,
							  out int pymin)
	{
		Pix RetObj = _All.pixRenderPolygon(ptas, width, out pxmin, out pymin);
		return RetObj;
	}

	// graphics.c (2540, 1)
	// pixFillPolygon(pixs, pta, xmin, ymin) as Pix
	// pixFillPolygon(PIX *, PTA *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This fills the interior of the polygon, returning a
	/// new pix.  It works for both convex and non-convex polygons.<para/>
	///
	/// (2) To generate a filled polygon from a pta:
	/// PIX pixt = pixRenderPolygon(pta, 1, [and]xmin, [and]ymin)
	/// PIX pixd = pixFillPolygon(pixt, pta, xmin, ymin)
	/// pixDestroy([and]pixt)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFillPolygon/*"/>
	///  <param name="pta">[in] - vertices of the polygon</param>
	///  <param name="xmin">[in] - min values of vertices of polygon</param>
	///  <param name="ymin">[in] - min values of vertices of polygon</param>
	///   <returns>pixd with outline filled, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FillPolygon (Pta pta,
							int xmin,
							int ymin)
	{
		Pix RetObj = _All.pixFillPolygon(this, pta, xmin, ymin);
		return RetObj;
	}

	// graphics.c (2619, 1)
	// pixRenderContours(pixs, startval, incr, outdepth) as Pix
	// pixRenderContours(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The output can be either 1 bpp, showing just the contour
	/// lines, or a copy of the input pixs with the contour lines
	/// superposed.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRenderContours/*"/>
	///  <param name="startval">[in] - value of lowest contour must be in [0 ... maxval]</param>
	///  <param name="incr">[in] - increment to next contour must be  is greater  0</param>
	///  <param name="outdepth">[in] - either 1 or depth of pixs</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RenderContours (int startval,
							   int incr,
							   int outdepth)
	{
		Pix RetObj = _All.pixRenderContours(this, startval, incr, outdepth);
		return RetObj;
	}

	// graphics.c (2862, 1)
	// pixGeneratePtaBoundary(pixs, width) as Pta
	// pixGeneratePtaBoundary(PIX *, l_int32) as PTA *
	///  <summary>
	/// (1) Similar to ptaGetBoundaryPixels(), except here:
	/// we only get pixels in the foreground
	/// we can have a "line" width greater than 1 pixel.<para/>
	///
	/// (2) Once generated, this can be applied to a random 1 bpp image
	/// to add a color boundary as follows:
	/// Pta pta = pixGeneratePtaBoundary(pixs, width)
	/// Pix pix1 = pixConvert1To8Cmap(pixs)
	/// pixRenderPtaArb(pix1, pta, rval, gval, bval)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGeneratePtaBoundary/*"/>
	///  <param name="width">[in] - of boundary line</param>
	///   <returns>pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta GeneratePtaBoundary (int width)
	{
		Pta RetObj = _All.pixGeneratePtaBoundary(this, width);
		return RetObj;
	}

	// graymorph.c (158, 1)
	// pixErodeGray(pixs, hsize, vsize) as Pix
	// pixErodeGray(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) If hsize = vsize = 1, just returns a copy.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixErodeGray/*"/>
	///  <param name="hsize">[in] - of Sel must be odd origin implicitly in center</param>
	///  <param name="vsize">[in] - ditto</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ErodeGray (int hsize,
						  int vsize)
	{
		Pix RetObj = _All.pixErodeGray(this, hsize, vsize);
		return RetObj;
	}

	// graymorph.c (274, 1)
	// pixDilateGray(pixs, hsize, vsize) as Pix
	// pixDilateGray(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) If hsize = vsize = 1, just returns a copy.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDilateGray/*"/>
	///  <param name="hsize">[in] - of Sel must be odd origin implicitly in center</param>
	///  <param name="vsize">[in] - ditto</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DilateGray (int hsize,
						   int vsize)
	{
		Pix RetObj = _All.pixDilateGray(this, hsize, vsize);
		return RetObj;
	}

	// graymorph.c (390, 1)
	// pixOpenGray(pixs, hsize, vsize) as Pix
	// pixOpenGray(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) If hsize = vsize = 1, just returns a copy.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOpenGray/*"/>
	///  <param name="hsize">[in] - of Sel must be odd origin implicitly in center</param>
	///  <param name="vsize">[in] - ditto</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OpenGray (int hsize,
						 int vsize)
	{
		Pix RetObj = _All.pixOpenGray(this, hsize, vsize);
		return RetObj;
	}

	// graymorph.c (522, 1)
	// pixCloseGray(pixs, hsize, vsize) as Pix
	// pixCloseGray(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) If hsize = vsize = 1, just returns a copy.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCloseGray/*"/>
	///  <param name="hsize">[in] - of Sel must be odd origin implicitly in center</param>
	///  <param name="vsize">[in] - ditto</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CloseGray (int hsize,
						  int vsize)
	{
		Pix RetObj = _All.pixCloseGray(this, hsize, vsize);
		return RetObj;
	}

	// graymorph.c (661, 1)
	// pixErodeGray3(pixs, hsize, vsize) as Pix
	// pixErodeGray3(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)<para/>
	///
	/// (2) If hsize = vsize = 1, just returns a copy.<para/>
	///
	/// (3) It would be nice not to add a border, but it is required
	/// if we want the same results as from the general case.
	/// We add 4 bytes on the left to speed up the copying, and
	/// 8 bytes at the right and bottom to allow unrolling of
	/// the computation of 8 pixels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixErodeGray3/*"/>
	///  <param name="hsize">[in] - 1 or 3</param>
	///  <param name="vsize">[in] - 1 or 3</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ErodeGray3 (int hsize,
						   int vsize)
	{
		Pix RetObj = _All.pixErodeGray3(this, hsize, vsize);
		return RetObj;
	}

	// graymorph.c (847, 1)
	// pixDilateGray3(pixs, hsize, vsize) as Pix
	// pixDilateGray3(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)<para/>
	///
	/// (2) If hsize = vsize = 1, just returns a copy.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDilateGray3/*"/>
	///  <param name="hsize">[in] - 1 or 3</param>
	///  <param name="vsize">[in] - 1 or 3</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DilateGray3 (int hsize,
							int vsize)
	{
		Pix RetObj = _All.pixDilateGray3(this, hsize, vsize);
		return RetObj;
	}

	// graymorph.c (1032, 1)
	// pixOpenGray3(pixs, hsize, vsize) as Pix
	// pixOpenGray3(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)<para/>
	///
	/// (2) If hsize = vsize = 1, just returns a copy.<para/>
	///
	/// (3) It would be nice not to add a border, but it is required
	/// to get the same results as for the general case.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOpenGray3/*"/>
	///  <param name="hsize">[in] - 1 or 3</param>
	///  <param name="vsize">[in] - 1 or 3</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OpenGray3 (int hsize,
						  int vsize)
	{
		Pix RetObj = _All.pixOpenGray3(this, hsize, vsize);
		return RetObj;
	}

	// graymorph.c (1098, 1)
	// pixCloseGray3(pixs, hsize, vsize) as Pix
	// pixCloseGray3(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)<para/>
	///
	/// (2) If hsize = vsize = 1, just returns a copy.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCloseGray3/*"/>
	///  <param name="hsize">[in] - 1 or 3</param>
	///  <param name="vsize">[in] - 1 or 3</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CloseGray3 (int hsize,
						   int vsize)
	{
		Pix RetObj = _All.pixCloseGray3(this, hsize, vsize);
		return RetObj;
	}

	// grayquant.c (171, 1)
	// pixDitherToBinary(pixs) as Pix
	// pixDitherToBinary(PIX *) as PIX *
	///  <summary>
	/// pixDitherToBinary()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDitherToBinary/*"/>
	///   <returns>pixd dithered binary, or NULL on error The Floyd-Steinberg error diffusion dithering algorithm binarizes an 8 bpp grayscale image to a threshold of 128. If a pixel has a value above 127, it is binarized to white and the excess below 255 is subtracted from three neighboring pixels in the fractions 3/8 to i, j+1, 3/8 to i+1, j) and 1/4 to (i+1,j+1, truncating to 0 if necessary.  Likewise, if it the pixel has a value below 128, it is binarized to black and the excess above 0 is added to the neighboring pixels, truncating to 255 if necessary. This function differs from straight dithering in that it allows clipping of grayscale to 0 or 255 if the values are sufficiently close, without distribution of the excess. This uses default values to specify the range of lower and upper values near 0 and 255, rsp that are clipped to black and white without propagating the excess. Not propagating the excess has the effect of reducing the snake patterns in parts of the image that are nearly black or white however, it also prevents the attempt to reproduce gray for those values. The implementation is straightforward.  It uses a pair of line buffers to avoid changing pixs.  It is about the same speed as pixDitherToBinaryLUT(), which uses three LUTs.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DitherToBinary ()
	{
		Pix RetObj = _All.pixDitherToBinary(this);
		return RetObj;
	}

	// grayquant.c (203, 1)
	// pixDitherToBinarySpec(pixs, lowerclip, upperclip) as Pix
	// pixDitherToBinarySpec(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See comments above in pixDitherToBinary() for details.<para/>
	///
	/// (2) The input parameters lowerclip and upperclip specify the range
	/// of lower and upper values (near 0 and 255, rsp) that are
	/// clipped to black and white without propagating the excess.
	/// For that reason, lowerclip and upperclip should be small numbers.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDitherToBinarySpec/*"/>
	///  <param name="lowerclip">[in] - lower clip distance to black use 0 for default</param>
	///  <param name="upperclip">[in] - upper clip distance to white use 0 for default</param>
	///   <returns>pixd dithered binary, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DitherToBinarySpec (int lowerclip,
								   int upperclip)
	{
		Pix RetObj = _All.pixDitherToBinarySpec(this, lowerclip, upperclip);
		return RetObj;
	}

	// grayquant.c (443, 1)
	// pixThresholdToBinary(pixs, thresh) as Pix
	// pixThresholdToBinary(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) If the source pixel is less than the threshold value,
	/// the dest will be 1 otherwise, it will be 0.<para/>
	///
	/// (2) For example, for 8 bpp src pix, if %thresh == 256, the dest
	/// 1 bpp pix is all ones (fg), and if %thresh == 0, the dest
	/// pix is all zeros (bg).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixThresholdToBinary/*"/>
	///  <param name="thresh">[in] - threshold value</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ThresholdToBinary (int thresh)
	{
		Pix RetObj = _All.pixThresholdToBinary(this, thresh);
		return RetObj;
	}

	// grayquant.c (650, 1)
	// pixVarThresholdToBinary(pixs, pixg) as Pix
	// pixVarThresholdToBinary(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) If the pixel in pixs is less than the corresponding pixel
	/// in pixg, the dest will be 1 otherwise it will be 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixVarThresholdToBinary/*"/>
	///  <param name="pixg">[in] - 8 bpp contains threshold values for each pixel</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix VarThresholdToBinary (Pix pixg)
	{
		Pix RetObj = _All.pixVarThresholdToBinary(this, pixg);
		return RetObj;
	}

	// grayquant.c (725, 1)
	// pixAdaptThresholdToBinary(pixs, pixm, gamma) as Pix
	// pixAdaptThresholdToBinary(PIX *, PIX *, l_float32) as PIX *
	///  <summary>
	/// (1) This is a simple convenience function for doing adaptive
	/// thresholding on a grayscale image with variable background.
	/// It uses default parameters appropriate for typical text images.<para/>
	///
	/// (2) %pixm is a 1 bpp mask over "image" regions, which are not
	/// expected to have a white background.  The mask inhibits
	/// background finding under the fg pixels of the mask.  For
	/// images with both text and image, the image regions would
	/// be binarized (or quantized) by a different set of operations.<para/>
	///
	/// (3) As %gamma is increased, the foreground pixels are reduced.<para/>
	///
	/// (4) Under the covers:  The default background value for normalization
	/// is 200, so we choose 170 for 'maxval' in pixGammaTRC.  Likewise,
	/// the default foreground threshold for normalization is 60,
	/// so we choose 50 for 'minval' in pixGammaTRC.  Because
	/// 170 was mapped to 255, choosing 200 for the threshold is
	/// quite safe for avoiding speckle noise from the background.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAdaptThresholdToBinary/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp image mask can be null</param>
	///  <param name="gamma">[in] - gamma correction must be  is greater  0.0 typically ~1.0</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AdaptThresholdToBinary (Single gamma,
									   Pix pixm)
	{
		Pix RetObj = _All.pixAdaptThresholdToBinary(this, pixm, gamma);
		return RetObj;
	}

	// grayquant.c (765, 1)
	// pixAdaptThresholdToBinaryGen(pixs, pixm, gamma, blackval, whiteval, thresh) as Pix
	// pixAdaptThresholdToBinaryGen(PIX *, PIX *, l_float32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This is a convenience function for doing adaptive thresholding
	/// on a grayscale image with variable background.  Also see notes
	/// in pixAdaptThresholdToBinary().<para/>
	///
	/// (2) Reducing %gamma increases the foreground (text) pixels.
	/// Use a low value (e.g., 0.5) for images with light text.<para/>
	///
	/// (3) For normal images, see default args in pixAdaptThresholdToBinary().
	/// For images with very light text, these values are appropriate:
	/// gamma ~0.5
	/// blackval  ~70
	/// whiteval  ~190
	/// thresh  ~200
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAdaptThresholdToBinaryGen/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp image mask can be null</param>
	///  <param name="gamma">[in] - gamma correction must be  is greater  0.0 typically ~1.0</param>
	///  <param name="blackval">[in] - dark value to set to black (0)</param>
	///  <param name="whiteval">[in] - light value to set to white (255)</param>
	///  <param name="thresh">[in] - final threshold for binarization</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AdaptThresholdToBinaryGen (Single gamma,
										  int blackval,
										  int whiteval,
										  int thresh,
										  Pix pixm)
	{
		Pix RetObj = _All.pixAdaptThresholdToBinaryGen(this, pixm, gamma, blackval, whiteval, thresh);
		return RetObj;
	}

	// grayquant.c (810, 1)
	// pixGenerateMaskByValue(pixs, val, usecmap) as Pix
	// pixGenerateMaskByValue(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) %val is the pixel value that we are selecting.  It can be
	/// either a gray value or a colormap index.<para/>
	///
	/// (2) If pixs is colormapped, %usecmap determines if the colormap
	/// index values are used, or if the colormap is removed to gray and
	/// the gray values are used.  For the latter, it generates
	/// an approximate grayscale value for each pixel, and then looks
	/// for gray pixels with the value %val.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenerateMaskByValue/*"/>
	///  <param name="val">[in] - of pixels for which we set 1 in dest</param>
	///  <param name="usecmap">[in] - 1 to retain cmap values 0 to convert to gray</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GenerateMaskByValue (int val,
									int usecmap)
	{
		Pix RetObj = _All.pixGenerateMaskByValue(this, val, usecmap);
		return RetObj;
	}

	// grayquant.c (900, 1)
	// pixGenerateMaskByBand(pixs, lower, upper, inband, usecmap) as Pix
	// pixGenerateMaskByBand(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Generates a 1 bpp mask pixd, the same size as pixs, where
	/// the fg pixels in the mask are those either within the specified
	/// band (for inband == 1) or outside the specified band
	/// (for inband == 0).<para/>
	///
	/// (2) If pixs is colormapped, %usecmap determines if the colormap
	/// values are used, or if the colormap is removed to gray and
	/// the gray values are used.  For the latter, it generates
	/// an approximate grayscale value for each pixel, and then looks
	/// for gray pixels with the value %val.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenerateMaskByBand/*"/>
	///  <param name="lower">[in] - two pixel values from which a range, either between (inband) or outside of (!inband), determines which pixels in pixs cause us to set a 1 in the dest mask</param>
	///  <param name="upper">[in] - two pixel values from which a range, either between (inband) or outside of (!inband), determines which pixels in pixs cause us to set a 1 in the dest mask</param>
	///  <param name="inband">[in] - 1 for finding pixels in [lower, upper] 0 for finding pixels in [0, lower) union (upper, 255]</param>
	///  <param name="usecmap">[in] - 1 to retain cmap values 0 to convert to gray</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GenerateMaskByBand (int lower,
								   int upper,
								   int inband,
								   int usecmap)
	{
		Pix RetObj = _All.pixGenerateMaskByBand(this, lower, upper, inband, usecmap);
		return RetObj;
	}

	// grayquant.c (1013, 1)
	// pixDitherTo2bpp(pixs, cmapflag) as Pix
	// pixDitherTo2bpp(PIX *, l_int32) as PIX *
	///  <summary>
	/// pixDitherTo2bpp()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDitherTo2bpp/*"/>
	///  <param name="cmapflag">[in] - 1 to generate a colormap</param>
	///   <returns>pixd dithered 2 bpp, or NULL on error An analog of the Floyd-Steinberg error diffusion dithering algorithm is used to "dibitize" an 8 bpp grayscale image to 2 bpp, using equally spaced gray values of 0, 85, 170, and 255, which are served by thresholds of 43, 128 and 213. If cmapflag == 1, the colormap values are set to 0, 85, 170 and 255. If a pixel has a value between 0 and 42, it is dibitized to 0, and the excess above 0 is added to the three neighboring pixels, in the fractions 3/8 to i, j+1, 3/8 to i+1, j) and 1/4 to (i+1, j+1, truncating to 255 if necessary.  If a pixel has a value between 43 and 127, it is dibitized to 1, and the excess above 85 is added to the three neighboring pixels as before.  If the value is below 85, the excess is subtracted.  With a value between 128 and 212, it is dibitized to 2, with the excess on either side of 170 distributed as before.  Finally, with a value between 213 and 255, it is dibitized to 3, with the excess below 255 subtracted from the neighbors.  We always truncate to 0 or 255. The details can be seen in the lookup table generation. This function differs from straight dithering in that it allows clipping of grayscale to 0 or 255 if the values are sufficiently close, without distribution of the excess. This uses default values from pix.h to specify the range of lower and upper values near 0 and 255, rsp that are clipped to black and white without propagating the excess. Not propagating the excess has the effect of reducing the snake patterns in parts of the image that are nearly black or white however, it also prevents any attempt to reproduce gray for those values. The implementation uses 3 lookup tables for simplicity, and a pair of line buffers to avoid modifying pixs.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DitherTo2bpp (int cmapflag)
	{
		Pix RetObj = _All.pixDitherTo2bpp(this, cmapflag);
		return RetObj;
	}

	// grayquant.c (1047, 1)
	// pixDitherTo2bppSpec(pixs, lowerclip, upperclip, cmapflag) as Pix
	// pixDitherTo2bppSpec(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See comments above in pixDitherTo2bpp() for details.<para/>
	///
	/// (2) The input parameters lowerclip and upperclip specify the range
	/// of lower and upper values (near 0 and 255, rsp) that are
	/// clipped to black and white without propagating the excess.
	/// For that reason, lowerclip and upperclip should be small numbers.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDitherTo2bppSpec/*"/>
	///  <param name="lowerclip">[in] - lower clip distance to black use 0 for default</param>
	///  <param name="upperclip">[in] - upper clip distance to white use 0 for default</param>
	///  <param name="cmapflag">[in] - 1 to generate a colormap</param>
	///   <returns>pixd dithered 2 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DitherTo2bppSpec (int lowerclip,
								 int upperclip,
								 int cmapflag)
	{
		Pix RetObj = _All.pixDitherTo2bppSpec(this, lowerclip, upperclip, cmapflag);
		return RetObj;
	}

	// grayquant.c (1373, 1)
	// pixThresholdTo2bpp(pixs, nlevels, cmapflag) as Pix
	// pixThresholdTo2bpp(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Valid values for nlevels is the set {2, 3, 4}.<para/>
	///
	/// (2) Any colormap on the input pixs is removed to 8 bpp grayscale.<para/>
	///
	/// (3) This function is typically invoked with cmapflag == 1.
	/// In the situation where no colormap is desired, nlevels is
	/// ignored and pixs is thresholded to 4 levels.<para/>
	///
	/// (4) The target output colors are equally spaced, with the
	/// darkest at 0 and the lightest at 255.  The thresholds are
	/// chosen halfway between adjacent output values.  A table
	/// is built that specifies the mapping from src to dest.<para/>
	///
	/// (5) If cmapflag == 1, a colormap of size 'nlevels' is made,
	/// and the pixel values in pixs are replaced by their
	/// appropriate color indices.  The number of holdouts,
	/// 4 - nlevels, will be between 0 and 2.<para/>
	///
	/// (6) If you don't want the thresholding to be equally spaced,
	/// either first transform the 8 bpp src using pixGammaTRC().
	/// or, if cmapflag == 1, after calling this function you can use
	/// pixcmapResetColor() to change any individual colors.<para/>
	///
	/// (7) If a colormap is generated, it will specify (to display
	/// programs) exactly how each level is to be represented in RGB
	/// space.  When representing text, 3 levels is far better than
	/// 2 because of the antialiasing of the single gray level,
	/// and 4 levels (black, white and 2 gray levels) is getting
	/// close to the perceptual quality of a (nearly continuous)
	/// grayscale image.  With 2 bpp, you can set up a colormap
	/// and allocate from 2 to 4 levels to represent antialiased text.
	/// Any left over colormap entries can be used for coloring regions.
	/// For the same number of levels, the file size of a 2 bpp image
	/// is about 10% smaller than that of a 4 bpp result for the same
	/// number of levels.  For both 2 bpp and 4 bpp, using 4 levels you
	/// get compression far better than that of jpeg, because the
	/// quantization to 4 levels will remove the jpeg ringing in the
	/// background near character edges.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixThresholdTo2bpp/*"/>
	///  <param name="nlevels">[in] - equally spaced must be between 2 and 4</param>
	///  <param name="cmapflag">[in] - 1 to build colormap 0 otherwise</param>
	///   <returns>pixd 2 bpp, optionally with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ThresholdTo2bpp (int nlevels,
								int cmapflag)
	{
		Pix RetObj = _All.pixThresholdTo2bpp(this, nlevels, cmapflag);
		return RetObj;
	}

	// grayquant.c (1515, 1)
	// pixThresholdTo4bpp(pixs, nlevels, cmapflag) as Pix
	// pixThresholdTo4bpp(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Valid values for nlevels is the set {2, ... 16}.<para/>
	///
	/// (2) Any colormap on the input pixs is removed to 8 bpp grayscale.<para/>
	///
	/// (3) This function is typically invoked with cmapflag == 1.
	/// In the situation where no colormap is desired, nlevels is
	/// ignored and pixs is thresholded to 16 levels.<para/>
	///
	/// (4) The target output colors are equally spaced, with the
	/// darkest at 0 and the lightest at 255.  The thresholds are
	/// chosen halfway between adjacent output values.  A table
	/// is built that specifies the mapping from src to dest.<para/>
	///
	/// (5) If cmapflag == 1, a colormap of size 'nlevels' is made,
	/// and the pixel values in pixs are replaced by their
	/// appropriate color indices.  The number of holdouts,
	/// 16 - nlevels, will be between 0 and 14.<para/>
	///
	/// (6) If you don't want the thresholding to be equally spaced,
	/// either first transform the 8 bpp src using pixGammaTRC().
	/// or, if cmapflag == 1, after calling this function you can use
	/// pixcmapResetColor() to change any individual colors.<para/>
	///
	/// (7) If a colormap is generated, it will specify, to display
	/// programs, exactly how each level is to be represented in RGB
	/// space.  When representing text, 3 levels is far better than
	/// 2 because of the antialiasing of the single gray level,
	/// and 4 levels (black, white and 2 gray levels) is getting
	/// close to the perceptual quality of a (nearly continuous)
	/// grayscale image.  Therefore, with 4 bpp, you can set up a
	/// colormap, allocate a relatively small fraction of the 16
	/// possible values to represent antialiased text, and use the
	/// other colormap entries for other things, such as coloring
	/// text or background.  Two other reasons for using a small number
	/// of gray values for antialiased text are (1) PNG compression
	/// gets worse as the number of levels that are used is increased,
	/// and (2) using a small number of levels will filter out most of
	/// the jpeg ringing that is typically introduced near sharp edges
	/// of text.  This filtering is partly responsible for the improved
	/// compression.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixThresholdTo4bpp/*"/>
	///  <param name="nlevels">[in] - equally spaced must be between 2 and 16</param>
	///  <param name="cmapflag">[in] - 1 to build colormap 0 otherwise</param>
	///   <returns>pixd 4 bpp, optionally with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ThresholdTo4bpp (int nlevels,
								int cmapflag)
	{
		Pix RetObj = _All.pixThresholdTo4bpp(this, nlevels, cmapflag);
		return RetObj;
	}

	// grayquant.c (1632, 1)
	// pixThresholdOn8bpp(pixs, nlevels, cmapflag) as Pix
	// pixThresholdOn8bpp(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Valid values for nlevels is the set {2,...,256}.<para/>
	///
	/// (2) Any colormap on the input pixs is removed to 8 bpp grayscale.<para/>
	///
	/// (3) If cmapflag == 1, a colormap of size 'nlevels' is made,
	/// and the pixel values in pixs are replaced by their
	/// appropriate color indices.  Otherwise, the pixel values
	/// are the actual thresholded (i.e., quantized) grayscale values.<para/>
	///
	/// (4) If you don't want the thresholding to be equally spaced,
	/// first transform the input 8 bpp src using pixGammaTRC().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixThresholdOn8bpp/*"/>
	///  <param name="nlevels">[in] - equally spaced must be between 2 and 256</param>
	///  <param name="cmapflag">[in] - 1 to build colormap 0 otherwise</param>
	///   <returns>pixd 8 bpp, optionally with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ThresholdOn8bpp (int nlevels,
								int cmapflag)
	{
		Pix RetObj = _All.pixThresholdOn8bpp(this, nlevels, cmapflag);
		return RetObj;
	}

	// grayquant.c (1733, 1)
	// pixThresholdGrayArb(pixs, edgevals, outdepth, use_average, setblack, setwhite) as Pix
	// pixThresholdGrayArb(PIX *, const char *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This function allows exact specification of the quantization bins.
	/// The string %edgevals is a space-separated set of values
	/// specifying the dividing points between output quantization bins.
	/// These threshold values are assigned to the bin with higher
	/// values, so that each of them is the smallest value in their bin.<para/>
	///
	/// (2) The output image (pixd) depth is specified by %outdepth.  The
	/// number of bins is the number of edgevals + 1.  The
	/// relation between outdepth and the number of bins is:
	/// outdepth = 2 nbins smaller or equal 4
	/// outdepth = 4 nbins smaller or equal 16
	/// outdepth = 8 nbins smaller or equal 256
	/// With %outdepth == 0, the minimum required depth for the
	/// given number of bins is used.
	/// The output pixd has a colormap.<para/>
	///
	/// (3) The last 3 args determine the specific values that go into
	/// the colormap.<para/>
	///
	/// (4) For %use_average:
	/// ~ if TRUE, the average value of pixels falling in the bin is
	/// chosen as the representative gray value.  Otherwise,
	/// ~ if FALSE, the central value of each bin is chosen as
	/// the representative value.
	/// The colormap holds the representative value.<para/>
	///
	/// (5) For %setblack, if TRUE the darkest color is set to (0,0,0).<para/>
	///
	/// (6) For %setwhite, if TRUE the lightest color is set to (255,255,255).<para/>
	///
	/// (7) An alternative to using this function to quantize to
	/// unequally-spaced bins is to first transform the 8 bpp pixs
	/// using pixGammaTRC(), and follow this with pixThresholdTo4bpp().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixThresholdGrayArb/*"/>
	///  <param name="edgevals">[in] - string giving edge value of each bin</param>
	///  <param name="outdepth">[in] - 0, 2, 4 or 8 bpp 0 is default for min depth</param>
	///  <param name="use_average">[in] - 1 if use the average pixel value in colormap</param>
	///  <param name="setblack">[in] - 1 if darkest color is set to black</param>
	///  <param name="setwhite">[in] - 1 if lightest color is set to white</param>
	///   <returns>pixd 2, 4 or 8 bpp quantized image with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ThresholdGrayArb (String edgevals,
								 int outdepth,
								 int use_average,
								 int setblack,
								 int setwhite)
	{
		Pix RetObj = _All.pixThresholdGrayArb(this, edgevals, outdepth, use_average, setblack, setwhite);
		return RetObj;
	}

	// grayquant.c (2129, 1)
	// pixGenerateMaskByBand32(pixs, refval, delm, delp, fractm, fractp) as Pix
	// pixGenerateMaskByBand32(PIX *, l_uint32, l_int32, l_int32, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) Generates a 1 bpp mask pixd, the same size as pixs, where
	/// the fg pixels in the mask within a band of rgb values
	/// surrounding %refval.  The band can be chosen in two ways
	/// for each component:
	/// (a) Use (%delm, %delp) to specify how many levels down and up
	/// (b) Use (%fractm, %fractp) to specify the fractional
	/// distance toward 0 and 255, respectively.
	/// Note that %delm and %delp must be in [0 ... 255], whereas
	/// %fractm and %fractp must be in [0.0 - 1.0].<para/>
	///
	/// (2) Either (%delm, %delp) or (%fractm, %fractp) can be used.
	/// Set each value in the other pair to 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenerateMaskByBand32/*"/>
	///  <param name="refval">[in] - reference rgb value</param>
	///  <param name="delm">[in] - max amount below the ref value for any component</param>
	///  <param name="delp">[in] - max amount above the ref value for any component</param>
	///  <param name="fractm">[in] - fractional amount below ref value for all components</param>
	///  <param name="fractp">[in] - fractional amount above ref value for all components</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GenerateMaskByBand32 (uint refval,
									 int delm,
									 int delp,
									 Single fractm,
									 Single fractp)
	{
		Pix RetObj = _All.pixGenerateMaskByBand32(this, refval, delm, delp, fractm, fractp);
		return RetObj;
	}

	// grayquant.c (2227, 1)
	// pixGenerateMaskByDiscr32(pixs, refval1, refval2, distflag) as Pix
	// pixGenerateMaskByDiscr32(PIX *, l_uint32, l_uint32, l_int32) as PIX *
	///  <summary>
	/// (1) Generates a 1 bpp mask pixd, the same size as pixs, where
	/// the fg pixels in the mask are those where the pixel in pixs
	/// is "closer" to refval1 than to refval2.<para/>
	///
	/// (2) "Closer" can be defined in several ways, such as:
	/// ~ manhattan distance (L1)
	/// ~ euclidean distance (L2)
	/// ~ majority vote of the individual components
	/// Here, we have a choice of L1 or L2.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenerateMaskByDiscr32/*"/>
	///  <param name="refval1">[in] - reference rgb value</param>
	///  <param name="refval2">[in] - reference rgb value</param>
	///  <param name="distflag">[in] - L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GenerateMaskByDiscr32 (uint refval1,
									  uint refval2,
									  int distflag)
	{
		Pix RetObj = _All.pixGenerateMaskByDiscr32(this, refval1, refval2, distflag);
		return RetObj;
	}

	// grayquant.c (2341, 1)
	// pixGrayQuantFromHisto(pixd, pixs, pixm, minfract, maxsize) as Pix
	// pixGrayQuantFromHisto(PIX *, PIX *, PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) This is useful for quantizing images with relatively few
	/// colors, but which may have both color and gray pixels.
	/// If there are color pixels, it is assumed that an input
	/// rgb image has been color quantized first so that:
	/// ~ pixd has a colormap describing the color pixels
	/// ~ pixm is a mask over the non-color pixels in pixd
	/// ~ the colormap in pixd, and the color pixels in pixd,
	/// have been repacked to go from 0 to n-1 (n colors)
	/// If there are no color pixels, pixd and pixm are both null,
	/// and all pixels in pixs are quantized to gray.<para/>
	///
	/// (2) A 256-entry histogram is built of the gray values in pixs.
	/// If pixm exists, the pixels contributing to the histogram are
	/// restricted to the fg of pixm.  A colormap and LUT are generated
	/// from this histogram.  We break up the array into a set
	/// of intervals, each one constituting a color in the colormap:
	/// An interval is identified by summing histogram bins until
	/// either the sum equals or exceeds the %minfract of the total
	/// number of pixels, or the span itself equals or exceeds %maxsize.
	/// The color of each bin is always an average of the pixels
	/// that constitute it.<para/>
	///
	/// (3) Note that we do not specify the number of gray colors in
	/// the colormap.  Instead, we specify two parameters that
	/// describe the accuracy of the color assignments this and
	/// the actual image determine the number of resulting colors.<para/>
	///
	/// (4) If a mask exists and it is not the same size as pixs, make
	/// a new mask the same size as pixs, with the original mask
	/// aligned at the UL corners.  Set all additional pixels
	/// in the (larger) new mask set to 1, causing those pixels
	/// in pixd to be set as gray.<para/>
	///
	/// (5) We estimate the total number of colors (color plus gray)
	/// if it exceeds 255, return null.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGrayQuantFromHisto/*"/>
	///  <param name="pixd">[in][optional] - quantized pix with cmap can be null</param>
	///  <param name="pixm">[in][optional] - mask over pixels in pixs to quantize</param>
	///  <param name="minfract">[in] - minimum fraction of pixels in a set of adjacent histo bins that causes the set to be automatically set aside as a color in the colormap must be at least 0.01</param>
	///  <param name="maxsize">[in] - maximum number of adjacent bins allowed to represent a color, regardless of the population of pixels in the bins must be at least 2</param>
	///   <returns>pixd 8 bpp, cmapped, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GrayQuantFromHisto (Single minfract,
								   int maxsize,
								   Pix pixd,
								   Pix pixm)
	{
		Pix RetObj = _All.pixGrayQuantFromHisto(pixd, this, pixm, minfract, maxsize);
		return RetObj;
	}

	// grayquant.c (2564, 1)
	// pixGrayQuantFromCmap(pixs, cmap, mindepth) as Pix
	// pixGrayQuantFromCmap(PIX *, PIXCMAP *, l_int32) as PIX *
	///  <summary>
	/// (1) In use, pixs is an 8 bpp grayscale image without a colormap.
	/// If there is an existing colormap, a warning is issued and
	/// a copy of the input pixs is returned.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGrayQuantFromCmap/*"/>
	///  <param name="cmap">[in] - to quantize to of dest pix</param>
	///  <param name="mindepth">[in] - minimum depth of pixd: can be 2, 4 or 8 bpp</param>
	///   <returns>pixd 2, 4 or 8 bpp, colormapped, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GrayQuantFromCmap (PixColormap cmap,
								  int mindepth)
	{
		Pix RetObj = _All.pixGrayQuantFromCmap(this, cmap, mindepth);
		return RetObj;
	}

	// jbclass.c (845, 1)
	// pixHaustest(pix1, pix2, pix3, pix4, delx, dely, maxdiffw, maxdiffh) as int
	// pixHaustest(PIX *, PIX *, PIX *, PIX *, l_float32, l_float32, l_int32, l_int32) as l_int32
	///  <summary>
	/// We check first that the two pix are roughly
	/// the same size.  Only if they meet that criterion do
	/// we compare the bitmaps.  The Hausdorff is a 2-way
	/// check.  The centroid difference is used to align the two
	/// images to the nearest integer for each of the checks.
	/// These check that the dilated image of one contains
	/// ALL the pixels of the undilated image of the other.
	/// Checks are done in both direction.  A single pixel not
	/// contained in either direction results in failure of the test.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixHaustest/*"/>
	///  <param name="pix1">[in] - new pix, not dilated</param>
	///  <param name="pix2">[in] - new pix, dilated</param>
	///  <param name="pix3">[in] - exemplar pix, not dilated</param>
	///  <param name="pix4">[in] - exemplar pix, dilated</param>
	///  <param name="delx">[in] - x comp of centroid difference</param>
	///  <param name="dely">[in] - y comp of centroid difference</param>
	///  <param name="maxdiffw">[in] - max width difference of pix1 and pix2</param>
	///  <param name="maxdiffh">[in] - max height difference of pix1 and pix2</param>
	///   <returns>0 FALSE) if no match, 1 (TRUE if the new pix is in the same class as the exemplar.</returns>
	// CreateAdditiveFunction: Function/Else
	public int Haustest (Pix pix1,
						 Pix pix2,
						 Pix pix3,
						 Pix pix4,
						 Single delx,
						 Single dely,
						 int maxdiffw,
						 int maxdiffh)
	{
		int RetObj = _All.pixHaustest(pix1, pix2, pix3, pix4, delx, dely, maxdiffw, maxdiffh);
		return RetObj;
	}

	// jbclass.c (943, 1)
	// pixRankHaustest(pix1, pix2, pix3, pix4, delx, dely, maxdiffw, maxdiffh, area1, area3, rank, tab8) as int
	// pixRankHaustest(PIX *, PIX *, PIX *, PIX *, l_float32, l_float32, l_int32, l_int32, l_int32, l_int32, l_float32, l_int32 *) as l_int32
	///  <summary>
	/// We check first that the two pix are roughly
	/// the same size.  Only if they meet that criterion do
	/// we compare the bitmaps.  We convert the rank value to
	/// a number of pixels by multiplying the rank fraction by the number
	/// of pixels in the undilated image.  The Hausdorff is a 2-way
	/// check.  The centroid difference is used to align the two
	/// images to the nearest integer for each of the checks.
	/// The rank hausdorff checks that the dilated image of one
	/// contains the rank fraction of the pixels of the undilated
	/// image of the other. Checks are done in both direction.
	/// Failure of the test in either direction results in failure
	/// of the test.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRankHaustest/*"/>
	///  <param name="pix1">[in] - new pix, not dilated</param>
	///  <param name="pix2">[in] - new pix, dilated</param>
	///  <param name="pix3">[in] - exemplar pix, not dilated</param>
	///  <param name="pix4">[in] - exemplar pix, dilated</param>
	///  <param name="delx">[in] - x comp of centroid difference</param>
	///  <param name="dely">[in] - y comp of centroid difference</param>
	///  <param name="maxdiffw">[in] - max width difference of pix1 and pix2</param>
	///  <param name="maxdiffh">[in] - max height difference of pix1 and pix2</param>
	///  <param name="area1">[in] - fg pixels in pix1</param>
	///  <param name="area3">[in] - fg pixels in pix3</param>
	///  <param name="rank">[in] - rank value of test, each way</param>
	///  <param name="tab8">[in] - table of pixel sums for byte</param>
	///   <returns>0 FALSE) if no match, 1 (TRUE if the new pix is in the same class as the exemplar.</returns>
	// CreateAdditiveFunction: Function/Else
	public int RankHaustest (Pix pix1,
							 Pix pix2,
							 Pix pix3,
							 Pix pix4,
							 Single delx,
							 Single dely,
							 int maxdiffw,
							 int maxdiffh,
							 int area1,
							 int area3,
							 Single rank,
							 int[] tab8)
	{
		int RetObj = _All.pixRankHaustest(pix1, pix2, pix3, pix4, delx, dely, maxdiffw, maxdiffh, area1, area3, rank, tab8);
		return RetObj;
	}

	// jbclass.c (1454, 1)
	// pixWordMaskByDilation(pixs, ppixm, psize, pixadb) as int
	// pixWordMaskByDilation(PIX *, PIX **, l_int32 *, PIXA *) as l_ok
	///  <summary>
	/// (1) This gives an estimate of the word masks.  See
	/// pixWordBoxesByDilation() for further filtering of the word boxes.<para/>
	///
	/// (2) The resolution should be between 75 and 150 ppi, and the optimal
	/// dilation will be between 3 and 10.<para/>
	///
	/// (3) A good size for dilating to get word masks is optionally returned.<para/>
	///
	/// (4) Typically, the number of c.c. reduced with each successive
	/// dilation (stored in nadiff) decreases quickly to a minimum
	/// (where the characters in a word are joined), and then
	/// increases again as the smaller number of words are joined.
	/// For the typical case, you can then look for this minimum
	/// and dilate to get the word mask.  However, there are many
	/// cases where the function is not so simple. For example, if the
	/// pix has been upscaled 2x, the nadiff function oscillates, with
	/// every other value being zero!  And for some images it tails
	/// off without a clear minimum to indicate where to break.
	/// So a more simple and robust method is to find the dilation
	/// where the initial number of c.c. has been reduced by some
	/// fraction (we use a 70% reduction).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWordMaskByDilation/*"/>
	///  <param name="psize">[out][optional] - size of good horizontal dilation</param>
	///  <param name="pixadb">[out][optional] - debug: pixa of intermediate steps</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WordMaskByDilation (Pix ppixm,
								   out int psize,
								   out Pixa pixadb)
	{
		int RetObj = _All.pixWordMaskByDilation(this, ppixm, out psize, out pixadb);
		return RetObj;
	}

	// jbclass.c (1597, 1)
	// pixWordBoxesByDilation(pixs, minwidth, minheight, maxwidth, maxheight, pboxa, psize, pixadb) as int
	// pixWordBoxesByDilation(PIX *, l_int32, l_int32, l_int32, l_int32, BOXA **, l_int32 *, PIXA *) as l_ok
	///  <summary>
	/// (1) Returns a pruned set of word boxes.<para/>
	///
	/// (2) See pixWordMaskByDilation().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWordBoxesByDilation/*"/>
	///  <param name="minwidth">[in] - saved components smaller are discarded</param>
	///  <param name="minheight">[in] - saved components smaller are discarded</param>
	///  <param name="maxwidth">[in] - saved components larger are discarded</param>
	///  <param name="maxheight">[in] - saved components larger are discarded</param>
	///  <param name="pboxa">[out] - of dilated word mask</param>
	///  <param name="psize">[out][optional] - size of good horizontal dilation</param>
	///  <param name="pixadb">[out][optional] - debug: pixa of intermediate steps</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WordBoxesByDilation (int minwidth,
									int minheight,
									int maxwidth,
									int maxheight,
									out Boxa pboxa,
									out int psize,
									out Pixa pixadb)
	{
		int RetObj = _All.pixWordBoxesByDilation(this, minwidth, minheight, maxwidth, maxheight, out pboxa, out psize, out pixadb);
		return RetObj;
	}

	// jp2kiostub.c (47, 7)
	// pixReadJp2k(filename, reduction, box, hint, debug) as Pix
	// pixReadJp2k(const char *, l_uint32, BOX *, l_int32, l_int32) as PIX *
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadJp2k/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadJp2k (String filename,
						 uint reduction,
						 Box box,
						 int hint,
						 DebugOnOff debug)
	{
		Pix RetObj = _All.pixReadJp2k(filename, reduction, box, hint, debug);
		return RetObj;
	}

	// jp2kiostub.c (55, 7)
	// pixReadStreamJp2k(fp, reduction, box, hint, debug) as Pix
	// pixReadStreamJp2k(FILE *, l_uint32, BOX *, l_int32, l_int32) as PIX *
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadStreamJp2k/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadStreamJp2k (FILE fp,
							   uint reduction,
							   Box box,
							   int hint,
							   DebugOnOff debug)
	{
		Pix RetObj = _All.pixReadStreamJp2k(fp, reduction, box, hint, debug);
		return RetObj;
	}

	// jp2kiostub.c (63, 6)
	// pixWriteJp2k(filename, pix, quality, nlevels, hint, debug) as int
	// pixWriteJp2k(const char *, PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteJp2k/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteJp2k (String filename,
						  Pix pix,
						  int nlevels,
						  int quality,
						  int hint,
						  DebugOnOff debug)
	{
		int RetObj = _All.pixWriteJp2k(filename, pix, quality, nlevels, hint, debug);
		return RetObj;
	}

	// jp2kiostub.c (71, 6)
	// pixWriteStreamJp2k(fp, pix, quality, nlevels, hint, debug) as int
	// pixWriteStreamJp2k(FILE *, PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamJp2k/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamJp2k (FILE fp,
								Pix pix,
								int nlevels,
								int quality,
								int hint,
								DebugOnOff debug)
	{
		int RetObj = _All.pixWriteStreamJp2k(fp, pix, quality, nlevels, hint, debug);
		return RetObj;
	}

	// jp2kiostub.c (79, 7)
	// pixReadMemJp2k(data, size, reduction, box, hint, debug) as Pix
	// pixReadMemJp2k(const l_uint8 *, size_t, l_uint32, BOX *, l_int32, l_int32) as PIX *
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadMemJp2k/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadMemJp2k (Byte[] data,
							uint size,
							uint reduction,
							Box box,
							int hint,
							DebugOnOff debug)
	{
		Pix RetObj = _All.pixReadMemJp2k(data, size, reduction, box, hint, debug);
		return RetObj;
	}

	// jp2kiostub.c (87, 6)
	// pixWriteMemJp2k(pdata, psize, pix, quality, nlevels, hint, debug) as int
	// pixWriteMemJp2k(l_uint8 **, size_t *, PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMemJp2k/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemJp2k (object pdata,
							 object psize,
							 Pix pix,
							 int nlevels,
							 int quality,
							 int hint,
							 DebugOnOff debug)
	{
		int RetObj = _All.pixWriteMemJp2k(pdata, psize, pix, quality, nlevels, hint, debug);
		return RetObj;
	}

	// jpegio.c (214, 1)
	// pixReadJpeg(filename, cmapflag, reduction, pnwarn, hint) as Pix
	// pixReadJpeg(const char *, l_int32, l_int32, l_int32 *, l_int32) as PIX *
	///  <summary>
	/// (1) This is a special function for reading jpeg files.<para/>
	///
	/// (2) Use this if you want the jpeg library to create
	/// an 8 bpp colormapped image.<para/>
	///
	/// (3) Images reduced by factors of 2, 4 or 8 can be returned
	/// significantly faster than full resolution images.<para/>
	///
	/// (4) If the jpeg data is bad, the jpeg library will continue
	/// silently, or return warnings, or attempt to exit.  Depending
	/// on the severity of the data corruption, there are two possible
	/// outcomes:
	/// (a) a possibly damaged pix can be generated, along with zero
	/// or more warnings, or
	/// (b) the library will attempt to exit (caught by our error
	/// handler) and no pix will be returned.
	/// If a pix is generated with at least one warning of data
	/// corruption, and if L_JPEG_FAIL_ON_BAD_DATA is included in %hint,
	/// no pix will be returned.<para/>
	///
	/// (5) The possible hint values are given in the enum in imageio.h:
	/// L_JPEG_READ_LUMINANCE
	/// L_JPEG_FAIL_ON_BAD_DATA
	/// Default (0) is to do neither.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadJpeg/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="cmapflag">[in] - 0 for no colormap in returned pix 1 to return an 8 bpp cmapped pix if spp = 3 or 4</param>
	///  <param name="reduction">[in] - scaling factor: 1, 2, 4 or 8</param>
	///  <param name="pnwarn">[out][optional] - number of warnings about corrupted data</param>
	///  <param name="hint">[in] - a bitwise OR of L_JPEG_ values 0 for default</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadJpeg (String filename,
						 int cmapflag,
						 int reduction,
						 out int pnwarn,
						 int hint)
	{
		Pix RetObj = _All.pixReadJpeg(filename, cmapflag, reduction, out pnwarn, hint);
		return RetObj;
	}

	// jpegio.c (270, 1)
	// pixReadStreamJpeg(fp, cmapflag, reduction, pnwarn, hint) as Pix
	// pixReadStreamJpeg(FILE *, l_int32, l_int32, l_int32 *, l_int32) as PIX *
	///  <summary>
	/// (1) The jpeg comment, if it exists, is not stored in the pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadStreamJpeg/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="cmapflag">[in] - 0 for no colormap in returned pix 1 to return an 8 bpp cmapped pix if spp = 3 or 4</param>
	///  <param name="reduction">[in] - scaling factor: 1, 2, 4 or 8</param>
	///  <param name="pnwarn">[out][optional] - number of warnings</param>
	///  <param name="hint">[in] - a bitwise OR of L_JPEG_ values 0 for default</param>
	///   <returns>pix, or NULL on error Usage: see pixReadJpeg</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadStreamJpeg (FILE fp,
							   int cmapflag,
							   int reduction,
							   out int pnwarn,
							   int hint)
	{
		Pix RetObj = _All.pixReadStreamJpeg(fp, cmapflag, reduction, out pnwarn, hint);
		return RetObj;
	}

	// jpegio.c (793, 1)
	// pixWriteStreamJpeg(fp, pixs, quality, progressive) as int
	// pixWriteStreamJpeg(FILE *, PIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) Progressive encoding gives better compression, at the
	/// expense of slower encoding and decoding.<para/>
	///
	/// (2) Standard chroma subsampling is 2x2 on both the U and V
	/// channels.  For highest quality, use no subsampling this
	/// option is set by pixSetChromaSampling(pix, 0).<para/>
	///
	/// (3) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16
	/// and 32 bpp.  However, it is possible, and in some cases desirable,
	/// to write out a jpeg file using an rgb pix that has 24 bpp.
	/// This can be created by appending the raster data for a 24 bpp
	/// image (with proper scanline padding) directly to a 24 bpp
	/// pix that was created without a data array.<para/>
	///
	/// (4) There are two compression paths in this function:
	/// Grayscale image, no colormap: compress as 8 bpp image.
	/// rgb full color image: copy each line into the color
	/// line buffer, and compress as three 8 bpp images.<para/>
	///
	/// (5) Under the covers, the jpeg library transforms rgb to a
	/// luminance-chromaticity triple, each component of which is
	/// also 8 bits, and compresses that.  It uses 2 Huffman tables,
	/// a higher resolution one (with more quantization levels)
	/// for luminosity and a lower resolution one for the chromas.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamJpeg/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="quality">[in] - 1 - 100 75 is default value 0 is also default</param>
	///  <param name="progressive">[in] - 0 for baseline sequential 1 for progressive</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamJpeg (FILE fp,
								int quality,
								int progressive)
	{
		int RetObj = _All.pixWriteStreamJpeg(fp, this, quality, progressive);
		return RetObj;
	}

	// jpegio.c (991, 1)
	// pixReadMemJpeg(data, size, cmflag, reduction, pnwarn, hint) as Pix
	// pixReadMemJpeg(const l_uint8 *, size_t, l_int32, l_int32, l_int32 *, l_int32) as PIX *
	///  <summary>
	/// (1) The %size byte of %data must be a null character.<para/>
	///
	/// (2) The only hint flag so far is L_JPEG_READ_LUMINANCE,
	/// given in the enum in imageio.h.<para/>
	///
	/// (3) See pixReadJpeg() for usage.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadMemJpeg/*"/>
	///  <param name="data">[in] - const jpeg-encoded</param>
	///  <param name="size">[in] - of data</param>
	///  <param name="cmflag">[in] - colormap flag 0 means return RGB image if color 1 means create a colormap and return an 8 bpp colormapped image if color</param>
	///  <param name="reduction">[in] - scaling factor: 1, 2, 4 or 8</param>
	///  <param name="pnwarn">[out][optional] - number of warnings</param>
	///  <param name="hint">[in] - a bitwise OR of L_JPEG_ values 0 for default</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadMemJpeg (Byte[] data,
							uint size,
							int cmflag,
							int reduction,
							out int pnwarn,
							int hint)
	{
		Pix RetObj = _All.pixReadMemJpeg(data, size, cmflag, reduction, out pnwarn, hint);
		return RetObj;
	}

	// jpegio.c (1121, 1)
	// pixWriteMemJpeg(pdata, psize, pix, quality, progressive) as int
	// pixWriteMemJpeg(l_uint8 **, size_t *, PIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) See pixWriteStreamJpeg() for usage.  This version writes to
	/// memory instead of to a file stream.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMemJpeg/*"/>
	///  <param name="pdata">[out] - data of jpeg compressed image</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="pix">[in] - any depth cmap is OK</param>
	///  <param name="quality">[in] - 1 - 100 75 is default value 0 is also default</param>
	///  <param name="progressive">[in] - 0 for baseline sequential 1 for progressive</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemJpeg (out Byte[] pdata,
							 out uint psize,
							 Pix pix,
							 int quality,
							 int progressive)
	{
		int RetObj = _All.pixWriteMemJpeg(out pdata, out psize, pix, quality, progressive);
		return RetObj;
	}

	// jpegio.c (1182, 1)
	// pixSetChromaSampling(pix, sampling) as int
	// pixSetChromaSampling(PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) The default is for 2x2 chroma subsampling because the files are
	/// considerably smaller and the appearance is typically satisfactory.
	/// To get full resolution output in the chroma channels for
	/// jpeg writing, call this with %sampling == 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetChromaSampling/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="sampling">[in] - 1 for subsampling 0 for no subsampling</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetChromaSampling (Pix pix,
								  int sampling)
	{
		int RetObj = _All.pixSetChromaSampling(pix, sampling);
		return RetObj;
	}

	// leptwin.c (303, 1)
	// pixGetWindowsHBITMAP(pix) as IntPtr
	// pixGetWindowsHBITMAP(PIX *) as HBITMAP
	///  <summary>
	/// (1) It's the responsibility of the caller to destroy the
	/// returned hBitmap with a call to DeleteObject (or with
	/// something that eventually calls DeleteObject).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetWindowsHBITMAP/*"/>
	///  <param name="pix">[in] - </param>
	///   <returns>Windows hBitmap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public IntPtr GetWindowsHBITMAP (Pix pix)
	{
		IntPtr RetObj = _All.pixGetWindowsHBITMAP(pix);
		return RetObj;
	}

	// maze.c (339, 1)
	// pixSearchBinaryMaze(pixs, xi, yi, xf, yf, ppixd) as Pta
	// pixSearchBinaryMaze(PIX *, l_int32, l_int32, l_int32, l_int32, PIX **) as PTA *
	///  <summary>
	/// (1) Because of the overhead in calling pixGetPixel() and
	/// pixSetPixel(), we have used raster line pointers and the
	/// GET_DATA and SET_DATA macros for many of the pix accesses.<para/>
	///
	/// (2) Commentary:
	/// The goal is to find the shortest path between beginning and
	/// end points, without going through walls, and there are many
	/// ways to solve this problem.
	/// We use a queue to implement a breadth-first search.  Two auxiliary
	/// "image" data structures can be used: one to mark the visited
	/// pixels and one to give the direction to the parent for each
	/// visited pixel.  The first structure is used to avoid putting
	/// pixels on the queue more than once, and the second is used
	/// for retracing back to the origin, like the breadcrumbs in
	/// Hansel and Gretel.  Each pixel taken off the queue is destroyed
	/// after it is used to locate the allowed neighbors.  In fact,
	/// only one distance image is required, if you initialize it
	/// to some value that signifies "not yet visited."  (We use
	/// a binary image for marking visited pixels because it is clearer.)
	/// This method for a simple search of a binary maze is implemented in
	/// pixSearchBinaryMaze().
	/// An alternative method would store the (manhattan) distance
	/// from the start point with each pixel on the queue.  The children
	/// of each pixel get a distance one larger than the parent.  These
	/// values can be stored in an auxiliary distance map image
	/// that is constructed simultaneously with the search.  Once the
	/// end point is reached, the distance map is used to backtrack
	/// along a minimum path.  There may be several equal length
	/// minimum paths, any one of which can be chosen this way.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSearchBinaryMaze/*"/>
	///  <param name="xi">[in] - beginning point use same initial point that was used to generate the maze</param>
	///  <param name="yi">[in] - beginning point use same initial point that was used to generate the maze</param>
	///  <param name="xf">[in] - end point, or close to it</param>
	///  <param name="yf">[in] - end point, or close to it</param>
	///  <param name="ppixd">[out][optional] - maze with path illustrated, or if no path possible, the part of the maze that was searched</param>
	///   <returns>pta shortest path, or NULL if either no path exists or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta SearchBinaryMaze (int xi,
								 int yi,
								 int xf,
								 int yf,
								 out Pix ppixd)
	{
		Pta RetObj = _All.pixSearchBinaryMaze(this, xi, yi, xf, yf, out ppixd);
		return RetObj;
	}

	// maze.c (723, 1)
	// pixSearchGrayMaze(pixs, xi, yi, xf, yf, ppixd) as Pta
	// pixSearchGrayMaze(PIX *, l_int32, l_int32, l_int32, l_int32, PIX **) as PTA *
	///  <summary>
	/// pixSearchGrayMaze()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSearchGrayMaze/*"/>
	///  <param name="xi">[in] - beginning point use same initial point that was used to generate the maze</param>
	///  <param name="yi">[in] - beginning point use same initial point that was used to generate the maze</param>
	///  <param name="xf">[in] - end point, or close to it</param>
	///  <param name="yf">[in] - end point, or close to it</param>
	///  <param name="ppixd">[out][optional] - maze with path illustrated, or if no path possible, the part of the maze that was searched</param>
	///   <returns>pta shortest path, or NULL if either no path exists or on error Commentary: Consider first a slight generalization of the binary maze search problem.  Suppose that you can go through walls, but the cost is higher say, an increment of 3 to go into a wall pixel rather than 1?  You're still trying to find the shortest path.  One way to do this is with an ordered queue, and a simple way to visualize an ordered queue is as a set of stacks, each stack being marked with the distance of each pixel in the stack from the start.  We place the start pixel in stack 0, pop it, and process its 4 children. Each pixel is given a distance that is incremented from that of its parent 0 in this case, depending on if it is a wall pixel or not.  That value may be recorded on a distance map, according to the algorithm below.  For children of the first pixel, those not on a wall go in stack 1, and wall children go in stack 3.  Stack 0 being emptied, the process then continues with pixels being popped from stack 1. Here is the algorithm for each child pixel.  The pixel's distance value, were it to be placed on a stack, is compared with the value for it that is on the distance map.  There are three possible cases: 1 If the pixel has not yet been registered, it is pushed on its stack and the distance is written to the map. 2 If it has previously been registered with a higher distance, the distance on the map is relaxed to that of the current pixel, which is then placed on its stack. 3 If it has previously been registered with an equal or lower value, the pixel is discarded. The pixels are popped and processed successively from stack 1, and when stack 1 is empty, popping starts on stack 2. This continues until the destination pixel is popped off a stack.   The minimum path is then derived from the distance map, going back from the end point as before.  This is just Dijkstra's algorithm for a directed graph here, the underlying graph consisting of the pixels and four edges connecting each pixel to its 4-neighbor is a special case of a directed graph, where each edge is bi-directional.  The implementation of this generalized maze search is left as an exercise to the reader. Let's generalize a bit further.  Suppose the "maze" is just a grayscale image -- think of it as an elevation map.  The cost of moving on this surface depends on the height, or the gradient, or whatever you want.  All that is required is that the cost is specified and non-negative on each link between adjacent pixels.  Now the problem becomes: find the least cost path moving on this surface between two specified end points. For example, if the cost across an edge between two pixels depends on the "gradient", you can use: cost = 1 + L_ABSdeltaV where deltaV is the difference in value between two adjacent pixels.  If the costs are all integers, we can still use an array of stacks to avoid ordering the queue e.g., by using a heap sort. This is a neat problem, because you don't even have to build a maze -- you can can use it on any grayscale image! Rather than using an array of stacks, a more practical approach is to implement with a priority queue, which is a queue that is sorted so that the elements with the largest or smallest key values always come off first.  The priority queue is efficiently implemented as a heap, and this is how we do it.  Suppose you run the algorithm using a priority queue, doing the bookkeeping with an auxiliary image data structure that saves the distance of each pixel put on the queue as before, according to the method described above.  We implement it as a 2-way choice by initializing the distance array to a large value and putting a pixel on the queue if its distance is less than the value found on the array.  When you finally pop the end pixel from the queue, you're done, and you can trace the path backward, either always going downhill or using an auxiliary image to give you the direction to go at each step.  This is implemented here in searchGrayMaze. Do we really have to use a sorted queue?  Can we solve this generalized maze with an unsorted queue of pixels?  Or even an unsorted stack, doing a depth-first search (DFS)? Consider a different algorithm for this generalized maze, where we travel again breadth first, but this time use a single, unsorted queue.  An auxiliary image is used as before to store the distances and to determine if pixels get pushed on the stack or dropped.  As before, we must allow pixels to be revisited, with relaxation of the distance if a shorter path arrives later.  As a result, we will in general have multiple instances of the same pixel on the stack with different distances.  However, because the queue is not ordered, some of these pixels will be popped when another instance with a lower distance is still on the stack.  Here, we're just popping them in the order they go on, rather than setting up a priority based on minimum distance.  Thus, unlike the priority queue, when a pixel is popped we have to check the distance map to see if a pixel with a lower distance has been put on the queue, and, if so, we discard the pixel we just popped.  So the "while" loop looks like this: ~ pop a pixel from the queue ~ check its distance against the distance stored in the distance map if larger, discard ~ otherwise, for each of its neighbors: ~ compute its distance from the start pixel ~ compare this distance with that on the distance map: ~ if the distance map value higher, relax the distance and push the pixel on the queue ~ if the distance map value is lower, discard the pixel How does this loop terminate?  Before, with an ordered queue, it terminates when you pop the end pixel.  But with an unordered queue or stack, the first time you hit the end pixel, the distance is not guaranteed to be correct, because the pixels along the shortest path may not have yet been visited and relaxed. Because the shortest path can theoretically go anywhere, we must keep going.  How do we know when to stop?   Dijkstra uses an ordered queue to systematically remove nodes from further consideration.  Each time a pixel is popped, we're done with it it's "finalized" in the Dijkstra sense because we know the shortest path to it.  However, with an unordered queue, the brute force answer is: stop when the queue or stack is empty, because then every pixel in the image has been assigned its minimum "distance" from the start pixel. This is similar to the situation when you use a stack for the simpler uniform-step problem: with breadth-first search BFS the pixels on the queue are automatically ordered, so you are done when you locate the end pixel as a neighbor of a popped pixel whereas depth-first search DFS, using a stack, requires, in general, a search of every accessible pixel.  Further, if a pixel is revisited with a smaller distance, that distance is recorded and the pixel is put on the stack again. But surely, you ask, can't we stop sooner?  What if the start and end pixels are very close to each other? OK, suppose they are, and you have very high walls and a long snaking level path that is actually the minimum cost. That long path can wind back and forth across the entire maze many times before ending up at the end point, which could be just over a wall from the start.  With the unordered queue, you very quickly get a high distance for the end pixel, which will be relaxed to the minimum distance only after all the pixels of the path have been visited and placed on the queue, multiple times for many of them.  So that's the price for not ordering the queue!</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta SearchGrayMaze (int xi,
							   int yi,
							   int xf,
							   int yf,
							   out Pix ppixd)
	{
		Pta RetObj = _All.pixSearchGrayMaze(this, xi, yi, xf, yf, out ppixd);
		return RetObj;
	}

	// morph.c (209, 1)
	// pixDilate(pixd, pixs, sel) as Pix
	// pixDilate(PIX *, PIX *, SEL *) as PIX *
	///  <summary>
	/// (1) This dilates src using hits in Sel.<para/>
	///
	/// (2) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (3) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixDilate(NULL, pixs, ...)
	/// (b) pixDilate(pixs, pixs, ...)
	/// (c) pixDilate(pixd, pixs, ...)<para/>
	///
	/// (4) The size of the result is determined by pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDilate/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="sel">[in] - </param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Dilate (Sel sel,
					   Pix pixd)
	{
		Pix RetObj = _All.pixDilate(pixd, this, sel);
		return RetObj;
	}

	// morph.c (263, 1)
	// pixErode(pixd, pixs, sel) as Pix
	// pixErode(PIX *, PIX *, SEL *) as PIX *
	///  <summary>
	/// (1) This erodes src using hits in Sel.<para/>
	///
	/// (2) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (3) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixErode(NULL, pixs, ...)
	/// (b) pixErode(pixs, pixs, ...)
	/// (c) pixErode(pixd, pixs, ...)<para/>
	///
	/// (4) The size of the result is determined by pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixErode/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="sel">[in] - </param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Erode (Sel sel,
					  Pix pixd)
	{
		Pix RetObj = _All.pixErode(pixd, this, sel);
		return RetObj;
	}

	// morph.c (338, 1)
	// pixHMT(pixd, pixs, sel) as Pix
	// pixHMT(PIX *, PIX *, SEL *) as PIX *
	///  <summary>
	/// (1) The hit-miss transform erodes the src, using both hits
	/// and misses in the Sel.  It ANDs the shifted src for hits
	/// and ANDs the inverted shifted src for misses.<para/>
	///
	/// (2) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (3) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixHMT(NULL, pixs, ...)
	/// (b) pixHMT(pixs, pixs, ...)
	/// (c) pixHMT(pixd, pixs, ...)<para/>
	///
	/// (4) The size of the result is determined by pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixHMT/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="sel">[in] - </param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix HMT (Sel sel,
					Pix pixd)
	{
		Pix RetObj = _All.pixHMT(pixd, this, sel);
		return RetObj;
	}

	// morph.c (422, 1)
	// pixOpen(pixd, pixs, sel) as Pix
	// pixOpen(PIX *, PIX *, SEL *) as PIX *
	///  <summary>
	/// (1) Generic morphological opening, using hits in the Sel.<para/>
	///
	/// (2) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (3) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixOpen(NULL, pixs, ...)
	/// (b) pixOpen(pixs, pixs, ...)
	/// (c) pixOpen(pixd, pixs, ...)<para/>
	///
	/// (4) The size of the result is determined by pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOpen/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="sel">[in] - </param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Open (Sel sel,
					 Pix pixd)
	{
		Pix RetObj = _All.pixOpen(pixd, this, sel);
		return RetObj;
	}

	// morph.c (469, 1)
	// pixClose(pixd, pixs, sel) as Pix
	// pixClose(PIX *, PIX *, SEL *) as PIX *
	///  <summary>
	/// (1) Generic morphological closing, using hits in the Sel.<para/>
	///
	/// (2) This implementation is a strict dual of the opening if
	/// symmetric boundary conditions are used (see notes at top
	/// of this file).<para/>
	///
	/// (3) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (4) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixClose(NULL, pixs, ...)
	/// (b) pixClose(pixs, pixs, ...)
	/// (c) pixClose(pixd, pixs, ...)<para/>
	///
	/// (5) The size of the result is determined by pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixClose/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="sel">[in] - </param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Close (Sel sel,
					  Pix pixd)
	{
		Pix RetObj = _All.pixClose(pixd, this, sel);
		return RetObj;
	}

	// morph.c (520, 1)
	// pixCloseSafe(pixd, pixs, sel) as Pix
	// pixCloseSafe(PIX *, PIX *, SEL *) as PIX *
	///  <summary>
	/// (1) Generic morphological closing, using hits in the Sel.<para/>
	///
	/// (2) If non-symmetric boundary conditions are used, this
	/// function adds a border of OFF pixels that is of
	/// sufficient size to avoid losing pixels from the dilation,
	/// and it removes the border after the operation is finished.
	/// It thus enforces a correct extensive result for closing.<para/>
	///
	/// (3) If symmetric b.c. are used, it is not necessary to add
	/// and remove this border.<para/>
	///
	/// (4) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (5) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixCloseSafe(NULL, pixs, ...)
	/// (b) pixCloseSafe(pixs, pixs, ...)
	/// (c) pixCloseSafe(pixd, pixs, ...)<para/>
	///
	/// (6) The size of the result is determined by pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCloseSafe/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="sel">[in] - </param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CloseSafe (Sel sel,
						  Pix pixd)
	{
		Pix RetObj = _All.pixCloseSafe(pixd, this, sel);
		return RetObj;
	}

	// morph.c (587, 1)
	// pixOpenGeneralized(pixd, pixs, sel) as Pix
	// pixOpenGeneralized(PIX *, PIX *, SEL *) as PIX *
	///  <summary>
	/// (1) Generalized morphological opening, using both hits and
	/// misses in the Sel.<para/>
	///
	/// (2) This does a hit-miss transform, followed by a dilation
	/// using the hits.<para/>
	///
	/// (3) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (4) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixOpenGeneralized(NULL, pixs, ...)
	/// (b) pixOpenGeneralized(pixs, pixs, ...)
	/// (c) pixOpenGeneralized(pixd, pixs, ...)<para/>
	///
	/// (5) The size of the result is determined by pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOpenGeneralized/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="sel">[in] - </param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OpenGeneralized (Sel sel,
								Pix pixd)
	{
		Pix RetObj = _All.pixOpenGeneralized(pixd, this, sel);
		return RetObj;
	}

	// morph.c (634, 1)
	// pixCloseGeneralized(pixd, pixs, sel) as Pix
	// pixCloseGeneralized(PIX *, PIX *, SEL *) as PIX *
	///  <summary>
	/// (1) Generalized morphological closing, using both hits and
	/// misses in the Sel.<para/>
	///
	/// (2) This does a dilation using the hits, followed by a
	/// hit-miss transform.<para/>
	///
	/// (3) This operation is a dual of the generalized opening.<para/>
	///
	/// (4) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (5) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixCloseGeneralized(NULL, pixs, ...)
	/// (b) pixCloseGeneralized(pixs, pixs, ...)
	/// (c) pixCloseGeneralized(pixd, pixs, ...)<para/>
	///
	/// (6) The size of the result is determined by pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCloseGeneralized/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="sel">[in] - </param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CloseGeneralized (Sel sel,
								 Pix pixd)
	{
		Pix RetObj = _All.pixCloseGeneralized(pixd, this, sel);
		return RetObj;
	}

	// morph.c (684, 1)
	// pixDilateBrick(pixd, pixs, hsize, vsize) as Pix
	// pixDilateBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) The origin is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (3) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (4) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (5) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixDilateBrick(NULL, pixs, ...)
	/// (b) pixDilateBrick(pixs, pixs, ...)
	/// (c) pixDilateBrick(pixd, pixs, ...)<para/>
	///
	/// (6) The size of the result is determined by pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDilateBrick/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DilateBrick (int hsize,
							int vsize,
							Pix pixd)
	{
		Pix RetObj = _All.pixDilateBrick(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morph.c (748, 1)
	// pixErodeBrick(pixd, pixs, hsize, vsize) as Pix
	// pixErodeBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) The origin is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (3) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (4) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (5) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixErodeBrick(NULL, pixs, ...)
	/// (b) pixErodeBrick(pixs, pixs, ...)
	/// (c) pixErodeBrick(pixd, pixs, ...)<para/>
	///
	/// (6) The size of the result is determined by pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixErodeBrick/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ErodeBrick (int hsize,
						   int vsize,
						   Pix pixd)
	{
		Pix RetObj = _All.pixErodeBrick(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morph.c (812, 1)
	// pixOpenBrick(pixd, pixs, hsize, vsize) as Pix
	// pixOpenBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) The origin is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (3) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (4) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (5) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixOpenBrick(NULL, pixs, ...)
	/// (b) pixOpenBrick(pixs, pixs, ...)
	/// (c) pixOpenBrick(pixd, pixs, ...)<para/>
	///
	/// (6) The size of the result is determined by pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOpenBrick/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OpenBrick (int hsize,
						  int vsize,
						  Pix pixd)
	{
		Pix RetObj = _All.pixOpenBrick(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morph.c (878, 1)
	// pixCloseBrick(pixd, pixs, hsize, vsize) as Pix
	// pixCloseBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) The origin is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (3) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (4) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (5) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixCloseBrick(NULL, pixs, ...)
	/// (b) pixCloseBrick(pixs, pixs, ...)
	/// (c) pixCloseBrick(pixd, pixs, ...)<para/>
	///
	/// (6) The size of the result is determined by pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCloseBrick/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CloseBrick (int hsize,
						   int vsize,
						   Pix pixd)
	{
		Pix RetObj = _All.pixCloseBrick(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morph.c (949, 1)
	// pixCloseSafeBrick(pixd, pixs, hsize, vsize) as Pix
	// pixCloseSafeBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) The origin is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (3) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (4) Safe closing adds a border of 0 pixels, of sufficient size so
	/// that all pixels in input image are processed within
	/// 32-bit words in the expanded image.  As a result, there is
	/// no special processing for pixels near the boundary, and there
	/// are no boundary effects.  The border is removed at the end.<para/>
	///
	/// (5) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (6) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixCloseBrick(NULL, pixs, ...)
	/// (b) pixCloseBrick(pixs, pixs, ...)
	/// (c) pixCloseBrick(pixd, pixs, ...)<para/>
	///
	/// (7) The size of the result is determined by pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCloseSafeBrick/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CloseSafeBrick (int hsize,
							   int vsize,
							   Pix pixd)
	{
		Pix RetObj = _All.pixCloseSafeBrick(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morph.c (1204, 1)
	// pixDilateCompBrick(pixd, pixs, hsize, vsize) as Pix
	// pixDilateCompBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) The origin is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (3) Do compositely for each dimension  is greater  1.<para/>
	///
	/// (4) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (5) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (6) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixDilateCompBrick(NULL, pixs, ...)
	/// (b) pixDilateCompBrick(pixs, pixs, ...)
	/// (c) pixDilateCompBrick(pixd, pixs, ...)<para/>
	///
	/// (7) The dimensions of the resulting image are determined by pixs.<para/>
	///
	/// (8) CAUTION: both hsize and vsize are being decomposed.
	/// The decomposer chooses a product of sizes (call them
	/// 'terms') for each that is close to the input size,
	/// but not necessarily equal to it.  It attempts to optimize:
	/// (a) for consistency with the input values: the product
	/// of terms is close to the input size
	/// (b) for efficiency of the operation: the sum of the
	/// terms is small ideally about twice the square
	/// root of the input size.
	/// So, for example, if the input hsize = 37, which is
	/// a prime number, the decomposer will break this into two
	/// terms, 6 and 6, so that the net result is a dilation
	/// with hsize = 36.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDilateCompBrick/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DilateCompBrick (int hsize,
								int vsize,
								Pix pixd)
	{
		Pix RetObj = _All.pixDilateCompBrick(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morph.c (1304, 1)
	// pixErodeCompBrick(pixd, pixs, hsize, vsize) as Pix
	// pixErodeCompBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) The origin is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (3) Do compositely for each dimension  is greater  1.<para/>
	///
	/// (4) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (5) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (6) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixErodeCompBrick(NULL, pixs, ...)
	/// (b) pixErodeCompBrick(pixs, pixs, ...)
	/// (c) pixErodeCompBrick(pixd, pixs, ...)<para/>
	///
	/// (7) The dimensions of the resulting image are determined by pixs.<para/>
	///
	/// (8) CAUTION: both hsize and vsize are being decomposed.
	/// The decomposer chooses a product of sizes (call them
	/// 'terms') for each that is close to the input size,
	/// but not necessarily equal to it.  It attempts to optimize:
	/// (a) for consistency with the input values: the product
	/// of terms is close to the input size
	/// (b) for efficiency of the operation: the sum of the
	/// terms is small ideally about twice the square
	/// root of the input size.
	/// So, for example, if the input hsize = 37, which is
	/// a prime number, the decomposer will break this into two
	/// terms, 6 and 6, so that the net result is a dilation
	/// with hsize = 36.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixErodeCompBrick/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ErodeCompBrick (int hsize,
							   int vsize,
							   Pix pixd)
	{
		Pix RetObj = _All.pixErodeCompBrick(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morph.c (1395, 1)
	// pixOpenCompBrick(pixd, pixs, hsize, vsize) as Pix
	// pixOpenCompBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) The origin is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (3) Do compositely for each dimension  is greater  1.<para/>
	///
	/// (4) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (5) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (6) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixOpenCompBrick(NULL, pixs, ...)
	/// (b) pixOpenCompBrick(pixs, pixs, ...)
	/// (c) pixOpenCompBrick(pixd, pixs, ...)<para/>
	///
	/// (7) The dimensions of the resulting image are determined by pixs.<para/>
	///
	/// (8) CAUTION: both hsize and vsize are being decomposed.
	/// The decomposer chooses a product of sizes (call them
	/// 'terms') for each that is close to the input size,
	/// but not necessarily equal to it.  It attempts to optimize:
	/// (a) for consistency with the input values: the product
	/// of terms is close to the input size
	/// (b) for efficiency of the operation: the sum of the
	/// terms is small ideally about twice the square
	/// root of the input size.
	/// So, for example, if the input hsize = 37, which is
	/// a prime number, the decomposer will break this into two
	/// terms, 6 and 6, so that the net result is a dilation
	/// with hsize = 36.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOpenCompBrick/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OpenCompBrick (int hsize,
							  int vsize,
							  Pix pixd)
	{
		Pix RetObj = _All.pixOpenCompBrick(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morph.c (1494, 1)
	// pixCloseCompBrick(pixd, pixs, hsize, vsize) as Pix
	// pixCloseCompBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) The origin is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (3) Do compositely for each dimension  is greater  1.<para/>
	///
	/// (4) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (5) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (6) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixCloseCompBrick(NULL, pixs, ...)
	/// (b) pixCloseCompBrick(pixs, pixs, ...)
	/// (c) pixCloseCompBrick(pixd, pixs, ...)<para/>
	///
	/// (7) The dimensions of the resulting image are determined by pixs.<para/>
	///
	/// (8) CAUTION: both hsize and vsize are being decomposed.
	/// The decomposer chooses a product of sizes (call them
	/// 'terms') for each that is close to the input size,
	/// but not necessarily equal to it.  It attempts to optimize:
	/// (a) for consistency with the input values: the product
	/// of terms is close to the input size
	/// (b) for efficiency of the operation: the sum of the
	/// terms is small ideally about twice the square
	/// root of the input size.
	/// So, for example, if the input hsize = 37, which is
	/// a prime number, the decomposer will break this into two
	/// terms, 6 and 6, so that the net result is a dilation
	/// with hsize = 36.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCloseCompBrick/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CloseCompBrick (int hsize,
							   int vsize,
							   Pix pixd)
	{
		Pix RetObj = _All.pixCloseCompBrick(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morph.c (1598, 1)
	// pixCloseSafeCompBrick(pixd, pixs, hsize, vsize) as Pix
	// pixCloseSafeCompBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) The origin is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (3) Do compositely for each dimension  is greater  1.<para/>
	///
	/// (4) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (5) Safe closing adds a border of 0 pixels, of sufficient size so
	/// that all pixels in input image are processed within
	/// 32-bit words in the expanded image.  As a result, there is
	/// no special processing for pixels near the boundary, and there
	/// are no boundary effects.  The border is removed at the end.<para/>
	///
	/// (6) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (7) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixCloseSafeCompBrick(NULL, pixs, ...)
	/// (b) pixCloseSafeCompBrick(pixs, pixs, ...)
	/// (c) pixCloseSafeCompBrick(pixd, pixs, ...)<para/>
	///
	/// (8) The dimensions of the resulting image are determined by pixs.<para/>
	///
	/// (9) CAUTION: both hsize and vsize are being decomposed.
	/// The decomposer chooses a product of sizes (call them
	/// 'terms') for each that is close to the input size,
	/// but not necessarily equal to it.  It attempts to optimize:
	/// (a) for consistency with the input values: the product
	/// of terms is close to the input size
	/// (b) for efficiency of the operation: the sum of the
	/// terms is small ideally about twice the square
	/// root of the input size.
	/// So, for example, if the input hsize = 37, which is
	/// a prime number, the decomposer will break this into two
	/// terms, 6 and 6, so that the net result is a dilation
	/// with hsize = 36.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCloseSafeCompBrick/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CloseSafeCompBrick (int hsize,
								   int vsize,
								   Pix pixd)
	{
		Pix RetObj = _All.pixCloseSafeCompBrick(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morphapp.c (108, 1)
	// pixExtractBoundary(pixs, type) as Pix
	// pixExtractBoundary(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Extracts the fg or bg boundary pixels for each component.
	/// Components are assumed to end at the boundary of pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExtractBoundary/*"/>
	///  <param name="type">[in] - 0 for background pixels 1 for foreground pixels</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ExtractBoundary (int type)
	{
		Pix RetObj = _All.pixExtractBoundary(this, type);
		return RetObj;
	}

	// morphapp.c (148, 1)
	// pixMorphSequenceMasked(pixs, pixm, sequence, dispsep) as Pix
	// pixMorphSequenceMasked(PIX *, PIX *, const char *, l_int32) as PIX *
	///  <summary>
	/// (1) This applies the morph sequence to the image, but only allows
	/// changes in pixs for pixels under the background of pixm.<para/>
	///
	/// (5) If pixm is NULL, this is just pixMorphSequence().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMorphSequenceMasked/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask</param>
	///  <param name="sequence">[in] - string specifying sequence of operations</param>
	///  <param name="dispsep">[in] - horizontal separation in pixels between successive displays use zero to suppress display</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MorphSequenceMasked (String sequence,
									int dispsep,
									Pix pixm)
	{
		Pix RetObj = _All.pixMorphSequenceMasked(this, pixm, sequence, dispsep);
		return RetObj;
	}

	// morphapp.c (195, 1)
	// pixMorphSequenceByComponent(pixs, sequence, connectivity, minw, minh, pboxa) as Pix
	// pixMorphSequenceByComponent(PIX *, const char *, l_int32, l_int32, l_int32, BOXA **) as PIX *
	///  <summary>
	/// (1) See pixMorphSequence() for composing operation sequences.<para/>
	///
	/// (2) This operates separately on each c.c. in the input pix.<para/>
	///
	/// (3) The dilation does NOT increase the c.c. size it is clipped
	/// to the size of the original c.c. This is necessary to
	/// keep the c.c. independent after the operation.<para/>
	///
	/// (4) You can specify that the width and/or height must equal
	/// or exceed a minimum size for the operation to take place.<para/>
	///
	/// (5) Use NULL for boxa to avoid returning the boxa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMorphSequenceByComponent/*"/>
	///  <param name="sequence">[in] - string specifying sequence</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="minw">[in] - minimum width to consider use 0 or 1 for any width</param>
	///  <param name="minh">[in] - minimum height to consider use 0 or 1 for any height</param>
	///  <param name="pboxa">[out][optional] - return boxa of c.c. in pixs</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MorphSequenceByComponent (String sequence,
										 int connectivity,
										 int minw,
										 int minh,
										 out Boxa pboxa)
	{
		Pix RetObj = _All.pixMorphSequenceByComponent(this, sequence, connectivity, minw, minh, out pboxa);
		return RetObj;
	}

	// morphapp.c (348, 1)
	// pixMorphSequenceByRegion(pixs, pixm, sequence, connectivity, minw, minh, pboxa) as Pix
	// pixMorphSequenceByRegion(PIX *, PIX *, const char *, l_int32, l_int32, l_int32, BOXA **) as PIX *
	///  <summary>
	/// (1) See pixMorphCompSequence() for composing operation sequences.<para/>
	///
	/// (2) This operates separately on the region in pixs corresponding
	/// to each c.c. in the mask pixm.  It differs from
	/// pixMorphSequenceByComponent() in that the latter does not have
	/// a pixm (mask), but instead operates independently on each
	/// component in pixs.<para/>
	///
	/// (3) Dilation will NOT increase the region size the result
	/// is clipped to the size of the mask region.  This is necessary
	/// to make regions independent after the operation.<para/>
	///
	/// (4) You can specify that the width and/or height of a region must
	/// equal or exceed a minimum size for the operation to take place.<para/>
	///
	/// (5) Use NULL for %pboxa to avoid returning the boxa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMorphSequenceByRegion/*"/>
	///  <param name="pixm">[in] - mask specifying regions</param>
	///  <param name="sequence">[in] - string specifying sequence</param>
	///  <param name="connectivity">[in] - 4 or 8, used on mask</param>
	///  <param name="minw">[in] - minimum width to consider use 0 or 1 for any width</param>
	///  <param name="minh">[in] - minimum height to consider use 0 or 1 for any height</param>
	///  <param name="pboxa">[out][optional] - return boxa of c.c. in pixm</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MorphSequenceByRegion (Pix pixm,
									  String sequence,
									  int connectivity,
									  int minw,
									  int minh,
									  out Boxa pboxa)
	{
		Pix RetObj = _All.pixMorphSequenceByRegion(this, pixm, sequence, connectivity, minw, minh, out pboxa);
		return RetObj;
	}

	// morphapp.c (502, 1)
	// pixUnionOfMorphOps(pixs, sela, type) as Pix
	// pixUnionOfMorphOps(PIX *, SELA *, l_int32) as PIX *
	///  <summary>
	/// pixUnionOfMorphOps()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixUnionOfMorphOps/*"/>
	///  <param name="sela">[in] - </param>
	///  <param name="type">[in] - L_MORPH_DILATE, etc.</param>
	///   <returns>pixd union of the specified morphological operation on pixs for each Sel in the Sela, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix UnionOfMorphOps (Sela sela,
								int type)
	{
		Pix RetObj = _All.pixUnionOfMorphOps(this, sela, type);
		return RetObj;
	}

	// morphapp.c (555, 1)
	// pixIntersectionOfMorphOps(pixs, sela, type) as Pix
	// pixIntersectionOfMorphOps(PIX *, SELA *, l_int32) as PIX *
	///  <summary>
	/// pixIntersectionOfMorphOps()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixIntersectionOfMorphOps/*"/>
	///  <param name="sela">[in] - </param>
	///  <param name="type">[in] - L_MORPH_DILATE, etc.</param>
	///   <returns>pixd intersection of the specified morphological operation on pixs for each Sel in the Sela, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix IntersectionOfMorphOps (Sela sela,
									   int type)
	{
		Pix RetObj = _All.pixIntersectionOfMorphOps(this, sela, type);
		return RetObj;
	}

	// morphapp.c (613, 1)
	// pixSelectiveConnCompFill(pixs, connectivity, minw, minh) as Pix
	// pixSelectiveConnCompFill(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixSelectiveConnCompFill()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSelectiveConnCompFill/*"/>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="minw">[in] - minimum width to consider use 0 or 1 for any width</param>
	///  <param name="minh">[in] - minimum height to consider use 0 or 1 for any height</param>
	///   <returns>pix with holes filled in selected c.c., or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SelectiveConnCompFill (int connectivity,
									  int minw,
									  int minh)
	{
		Pix RetObj = _All.pixSelectiveConnCompFill(this, connectivity, minw, minh);
		return RetObj;
	}

	// morphapp.c (684, 1)
	// pixRemoveMatchedPattern(pixs, pixp, pixe, x0, y0, dsize) as int
	// pixRemoveMatchedPattern(PIX *, PIX *, PIX *, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is in-place.<para/>
	///
	/// (2) You can use various functions in selgen to create a Sel
	/// that is used to generate pixe from pixs.<para/>
	///
	/// (3) This function is applied after pixe has been computed.
	/// It finds the centroid of each c.c., and subtracts
	/// (the appropriately dilated version of) pixp, with the center
	/// of the Sel used to align pixp with pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRemoveMatchedPattern/*"/>
	///  <param name="pixp">[in] - pattern to be removed from image, 1 bpp</param>
	///  <param name="pixe">[in] - image after erosion by Sel that approximates pixp, 1 bpp</param>
	///  <param name="x0">[in] - center of Sel</param>
	///  <param name="y0">[in] - center of Sel</param>
	///  <param name="dsize">[in] - number of pixels on each side by which pixp is dilated before being subtracted from pixs valid values are {0, 1, 2, 3, 4}</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RemoveMatchedPattern (Pix pixp,
									 Pix pixe,
									 int x0,
									 int y0,
									 int dsize)
	{
		int RetObj = _All.pixRemoveMatchedPattern(this, pixp, pixe, x0, y0, dsize);
		return RetObj;
	}

	// morphapp.c (789, 1)
	// pixDisplayMatchedPattern(pixs, pixp, pixe, x0, y0, color, scale, nlevels) as Pix
	// pixDisplayMatchedPattern(PIX *, PIX *, PIX *, l_int32, l_int32, l_uint32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) A 4 bpp colormapped image is generated.<para/>
	///
	/// (2) If scale smaller or equal 1.0, do scale to gray for the output, and threshold
	/// to nlevels of gray.<para/>
	///
	/// (3) You can use various functions in selgen to create a Sel
	/// that will generate pixe from pixs.<para/>
	///
	/// (4) This function is applied after pixe has been computed.
	/// It finds the centroid of each c.c., and colors the output
	/// pixels using pixp (appropriately aligned) as a stencil.
	/// Alignment is done using the origin of the Sel and the
	/// centroid of the eroded image to place the stencil pixp.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDisplayMatchedPattern/*"/>
	///  <param name="pixp">[in] - pattern to be removed from image, 1 bpp</param>
	///  <param name="pixe">[in] - image after erosion by Sel that approximates pixp, 1 bpp</param>
	///  <param name="x0">[in] - center of Sel</param>
	///  <param name="y0">[in] - center of Sel</param>
	///  <param name="color">[in] - to paint the matched patterns 0xrrggbb00</param>
	///  <param name="scale">[in] - reduction factor for output pixd</param>
	///  <param name="nlevels">[in] - if scale  is smaller 1.0, threshold to this number of levels</param>
	///   <returns>pixd 8 bpp, colormapped, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayMatchedPattern (Pix pixp,
									  Pix pixe,
									  int x0,
									  int y0,
									  uint color,
									  Single scale,
									  int nlevels)
	{
		Pix RetObj = _All.pixDisplayMatchedPattern(this, pixp, pixe, x0, y0, color, scale, nlevels);
		return RetObj;
	}

	// morphapp.c (1041, 1)
	// pixSeedfillMorph(pixs, pixm, maxiters, connectivity) as Pix
	// pixSeedfillMorph(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This is in general a very inefficient method for filling
	/// from a seed into a mask.  Use it for a small number of iterations,
	/// but if you expect more than a few iterations, use
	/// pixSeedfillBinary().<para/>
	///
	/// (2) We use a 3x3 brick SEL for 8-cc filling and a 3x3 plus SEL for 4-cc.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfillMorph/*"/>
	///  <param name="pixm">[in] - mask</param>
	///  <param name="maxiters">[in] - use 0 to go to completion</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>pixd after filling into the mask or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SeedfillMorph (Pix pixm,
							  int maxiters,
							  int connectivity)
	{
		Pix RetObj = _All.pixSeedfillMorph(this, pixm, maxiters, connectivity);
		return RetObj;
	}

	// morphapp.c (1103, 1)
	// pixRunHistogramMorph(pixs, runtype, direction, maxsize) as Numa
	// pixRunHistogramMorph(PIX *, l_int32, l_int32, l_int32) as NUMA *
	///  <summary>
	/// pixRunHistogramMorph()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRunHistogramMorph/*"/>
	///  <param name="runtype">[in] - L_RUN_OFF, L_RUN_ON</param>
	///  <param name="direction">[in] - L_HORIZ, L_VERT</param>
	///  <param name="maxsize">[in] - size of largest runlength counted</param>
	///   <returns>numa of run-lengths</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa RunHistogramMorph (int runtype,
								   int direction,
								   int maxsize)
	{
		Numa RetObj = _All.pixRunHistogramMorph(this, runtype, direction, maxsize);
		return RetObj;
	}

	// morphapp.c (1203, 1)
	// pixTophat(pixs, hsize, vsize, type) as Pix
	// pixTophat(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Sel is a brick with all elements being hits<para/>
	///
	/// (2) If hsize = vsize = 1, returns an image with all 0 data.<para/>
	///
	/// (3) The L_TOPHAT_WHITE flag emphasizes small bright regions,
	/// whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.
	/// The L_TOPHAT_WHITE tophat can be accomplished by doing a
	/// L_TOPHAT_BLACK tophat on the inverse, or v.v.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTophat/*"/>
	///  <param name="hsize">[in] - of Sel must be odd origin implicitly in center</param>
	///  <param name="vsize">[in] - ditto</param>
	///  <param name="type">[in] - L_TOPHAT_WHITE: image - opening L_TOPHAT_BLACK: closing - image</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Tophat (int hsize,
					   int vsize,
					   int type)
	{
		Pix RetObj = _All.pixTophat(this, hsize, vsize, type);
		return RetObj;
	}

	// morphapp.c (1303, 1)
	// pixHDome(pixs, height, connectivity) as Pix
	// pixHDome(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) It is more efficient to use a connectivity of 4 for the fill.<para/>
	///
	/// (2) This fills bumps to some level, and extracts the unfilled
	/// part of the bump.  To extract the troughs of basins, first
	/// invert pixs and then apply pixHDome().<para/>
	///
	/// (3) It is useful to compare the HDome operation with the TopHat.
	/// The latter extracts peaks or valleys that have a width
	/// not exceeding the size of the structuring element used
	/// in the opening or closing, rsp.  The height of the peak is
	/// irrelevant.  By contrast, for the HDome, the gray seedfill
	/// is used to extract all peaks that have a height not exceeding
	/// a given value, regardless of their width!<para/>
	///
	/// (4) Slightly more precisely, suppose you set 'height' = 40.
	/// Then all bumps in pixs with a height greater than or equal
	/// to 40 become, in pixd, bumps with a max value of exactly 40.
	/// All shorter bumps have a max value in pixd equal to the height
	/// of the bump.<para/>
	///
	/// (5) The method: the filling mask, pixs, is the image whose peaks
	/// are to be extracted.  The height of a peak is the distance
	/// between the top of the peak and the highest "leak" to the
	/// outside -- think of a sombrero, where the leak occurs
	/// at the highest point on the rim.
	/// (a) Generate a seed, pixd, by subtracting some value, p, from
	/// each pixel in the filling mask, pixs.  The value p is
	/// the 'height' input to this function.
	/// (b) Fill in pixd starting with this seed, clipping by pixs,
	/// in the way described in seedfillGrayLow().  The filling
	/// stops before the peaks in pixs are filled.
	/// For peaks that have a height  is greater  p, pixd is filled to
	/// the level equal to the (top-of-the-peak - p).
	/// For peaks of height  is smaller p, the peak is left unfilled
	/// from its highest saddle point (the leak to the outside).
	/// (c) Subtract the filled seed (pixd) from the filling mask (pixs).
	/// Note that in this procedure, everything is done starting
	/// with the filling mask, pixs.<para/>
	///
	/// (6) For segmentation, the resulting image, pixd, can be thresholded
	/// and used as a seed for another filling operation.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixHDome/*"/>
	///  <param name="height">[in] - of seed below the filling maskhdome must be greater or equal 0</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix HDome (int height,
					  int connectivity)
	{
		Pix RetObj = _All.pixHDome(this, height, connectivity);
		return RetObj;
	}

	// morphapp.c (1359, 1)
	// pixFastTophat(pixs, xsize, ysize, type) as Pix
	// pixFastTophat(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Don't be fooled. This is NOT a tophat.  It is a tophat-like
	/// operation, where the result is similar to what you'd get
	/// if you used an erosion instead of an opening, or a dilation
	/// instead of a closing.<para/>
	///
	/// (2) Instead of opening or closing at full resolution, it does
	/// a fast downscale/minmax operation, then a quick small smoothing
	/// at low res, a replicative expansion of the "background"
	/// to full res, and finally a removal of the background level
	/// from the input image.  The smoothing step may not be important.<para/>
	///
	/// (3) It does not remove noise as well as a tophat, but it is
	/// 5 to 10 times faster.
	/// If you need the preciseness of the tophat, don't use this.<para/>
	///
	/// (4) The L_TOPHAT_WHITE flag emphasizes small bright regions,
	/// whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFastTophat/*"/>
	///  <param name="xsize">[in] - width of max/min op, smoothing any integer greater or equal 1</param>
	///  <param name="ysize">[in] - height of max/min op, smoothing any integer greater or equal 1</param>
	///  <param name="type">[in] - L_TOPHAT_WHITE: image - min L_TOPHAT_BLACK: max - image</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FastTophat (int xsize,
						   int ysize,
						   int type)
	{
		Pix RetObj = _All.pixFastTophat(this, xsize, ysize, type);
		return RetObj;
	}

	// morphapp.c (1421, 1)
	// pixMorphGradient(pixs, hsize, vsize, smoothing) as Pix
	// pixMorphGradient(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixMorphGradient()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMorphGradient/*"/>
	///  <param name="hsize">[in] - of Sel must be odd origin implicitly in center</param>
	///  <param name="vsize">[in] - ditto</param>
	///  <param name="smoothing">[in] - half-width of convolution smoothing filter. The width is (2  smoothing + 1, so 0 is no-op.</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MorphGradient (int hsize,
							  int vsize,
							  int smoothing)
	{
		Pix RetObj = _All.pixMorphGradient(this, hsize, vsize, smoothing);
		return RetObj;
	}

	// morphapp.c (1527, 1)
	// pixCentroid(pix, centtab, sumtab, pxave, pyave) as int
	// pixCentroid(PIX *, l_int32 *, l_int32 *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) Any table not passed in will be made internally and destroyed
	/// after use.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCentroid/*"/>
	///  <param name="pix">[in] - 1 or 8 bpp</param>
	///  <param name="centtab">[in][optional] - table for finding centroids can be null</param>
	///  <param name="sumtab">[in][optional] - table for finding pixel sums can be null</param>
	///  <param name="pxave">[out] - coordinates of centroid, relative to the UL corner of the pix</param>
	///  <param name="pyave">[out] - coordinates of centroid, relative to the UL corner of the pix</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Centroid (Pix pix,
						 out Single pxave,
						 out Single pyave,
						 int[] centtab,
						 int[] sumtab)
	{
		int RetObj = _All.pixCentroid(pix, centtab, sumtab, out pxave, out pyave);
		return RetObj;
	}

	// morphdwa.c (175, 1)
	// pixDilateBrickDwa(pixd, pixs, hsize, vsize) as Pix
	// pixDilateBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) These implement 2D brick Sels, using linear Sels generated
	/// with selaAddBasic().<para/>
	///
	/// (2) A brick Sel has hits for all elements.<para/>
	///
	/// (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (4) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (5) It is necessary that both horizontal and vertical Sels
	/// of the input size are defined in the basic sela.<para/>
	///
	/// (6) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (7) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixDilateBrickDwa(NULL, pixs, ...)
	/// (b) pixDilateBrickDwa(pixs, pixs, ...)
	/// (c) pixDilateBrickDwa(pixd, pixs, ...)<para/>
	///
	/// (8) The size of pixd is determined by pixs.<para/>
	///
	/// (9) If either linear Sel is not found, this calls
	/// the appropriate decomposible function.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDilateBrickDwa/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DilateBrickDwa (int hsize,
							   int vsize,
							   Pix pixd)
	{
		Pix RetObj = _All.pixDilateBrickDwa(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morphdwa.c (277, 1)
	// pixErodeBrickDwa(pixd, pixs, hsize, vsize) as Pix
	// pixErodeBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) These implement 2D brick Sels, using linear Sels generated
	/// with selaAddBasic().<para/>
	///
	/// (2) A brick Sel has hits for all elements.<para/>
	///
	/// (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (4) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (5) It is necessary that both horizontal and vertical Sels
	/// of the input size are defined in the basic sela.<para/>
	///
	/// (6) Note that we must always set or clear the border pixels
	/// before each operation, depending on the the b.c.
	/// (symmetric or asymmetric).<para/>
	///
	/// (7) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (8) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixErodeBrickDwa(NULL, pixs, ...)
	/// (b) pixErodeBrickDwa(pixs, pixs, ...)
	/// (c) pixErodeBrickDwa(pixd, pixs, ...)<para/>
	///
	/// (9) The size of the result is determined by pixs.<para/>
	///
	/// (10) If either linear Sel is not found, this calls
	/// the appropriate decomposible function.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixErodeBrickDwa/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ErodeBrickDwa (int hsize,
							  int vsize,
							  Pix pixd)
	{
		Pix RetObj = _All.pixErodeBrickDwa(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morphdwa.c (379, 1)
	// pixOpenBrickDwa(pixd, pixs, hsize, vsize) as Pix
	// pixOpenBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) These implement 2D brick Sels, using linear Sels generated
	/// with selaAddBasic().<para/>
	///
	/// (2) A brick Sel has hits for all elements.<para/>
	///
	/// (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (4) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (5) It is necessary that both horizontal and vertical Sels
	/// of the input size are defined in the basic sela.<para/>
	///
	/// (6) Note that we must always set or clear the border pixels
	/// before each operation, depending on the the b.c.
	/// (symmetric or asymmetric).<para/>
	///
	/// (7) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (8) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixOpenBrickDwa(NULL, pixs, ...)
	/// (b) pixOpenBrickDwa(pixs, pixs, ...)
	/// (c) pixOpenBrickDwa(pixd, pixs, ...)<para/>
	///
	/// (9) The size of the result is determined by pixs.<para/>
	///
	/// (10) If either linear Sel is not found, this calls
	/// the appropriate decomposible function.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOpenBrickDwa/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OpenBrickDwa (int hsize,
							 int vsize,
							 Pix pixd)
	{
		Pix RetObj = _All.pixOpenBrickDwa(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morphdwa.c (486, 1)
	// pixCloseBrickDwa(pixd, pixs, hsize, vsize) as Pix
	// pixCloseBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This is a 'safe' closing we add an extra border of 32 OFF
	/// pixels for the standard asymmetric b.c.<para/>
	///
	/// (2) These implement 2D brick Sels, using linear Sels generated
	/// with selaAddBasic().<para/>
	///
	/// (3) A brick Sel has hits for all elements.<para/>
	///
	/// (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (5) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (6) It is necessary that both horizontal and vertical Sels
	/// of the input size are defined in the basic sela.<para/>
	///
	/// (7) Note that we must always set or clear the border pixels
	/// before each operation, depending on the the b.c.
	/// (symmetric or asymmetric).<para/>
	///
	/// (8) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (9) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixCloseBrickDwa(NULL, pixs, ...)
	/// (b) pixCloseBrickDwa(pixs, pixs, ...)
	/// (c) pixCloseBrickDwa(pixd, pixs, ...)<para/>
	///
	/// (10) The size of the result is determined by pixs.<para/>
	///
	/// (11) If either linear Sel is not found, this calls
	/// the appropriate decomposible function.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCloseBrickDwa/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CloseBrickDwa (int hsize,
							  int vsize,
							  Pix pixd)
	{
		Pix RetObj = _All.pixCloseBrickDwa(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morphdwa.c (613, 1)
	// pixDilateCompBrickDwa(pixd, pixs, hsize, vsize) as Pix
	// pixDilateCompBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) These implement a separable composite dilation with 2D brick Sels.<para/>
	///
	/// (2) For efficiency, it may decompose each linear morphological
	/// operation into two (brick + comb).<para/>
	///
	/// (3) A brick Sel has hits for all elements.<para/>
	///
	/// (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (5) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (6) It is necessary that both horizontal and vertical Sels
	/// of the input size are defined in the basic sela.<para/>
	///
	/// (7) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (8) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixDilateCompBrickDwa(NULL, pixs, ...)
	/// (b) pixDilateCompBrickDwa(pixs, pixs, ...)
	/// (c) pixDilateCompBrickDwa(pixd, pixs, ...)<para/>
	///
	/// (9) The size of pixd is determined by pixs.<para/>
	///
	/// (10) CAUTION: both hsize and vsize are being decomposed.
	/// The decomposer chooses a product of sizes (call them
	/// 'terms') for each that is close to the input size,
	/// but not necessarily equal to it.  It attempts to optimize:
	/// (a) for consistency with the input values: the product
	/// of terms is close to the input size
	/// (b) for efficiency of the operation: the sum of the
	/// terms is small ideally about twice the square
	/// root of the input size.
	/// So, for example, if the input hsize = 37, which is
	/// a prime number, the decomposer will break this into two
	/// terms, 6 and 6, so that the net result is a dilation
	/// with hsize = 36.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDilateCompBrickDwa/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DilateCompBrickDwa (int hsize,
								   int vsize,
								   Pix pixd)
	{
		Pix RetObj = _All.pixDilateCompBrickDwa(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morphdwa.c (746, 1)
	// pixErodeCompBrickDwa(pixd, pixs, hsize, vsize) as Pix
	// pixErodeCompBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) These implement a separable composite erosion with 2D brick Sels.<para/>
	///
	/// (2) For efficiency, it may decompose each linear morphological
	/// operation into two (brick + comb).<para/>
	///
	/// (3) A brick Sel has hits for all elements.<para/>
	///
	/// (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (5) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (6) It is necessary that both horizontal and vertical Sels
	/// of the input size are defined in the basic sela.<para/>
	///
	/// (7) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (8) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixErodeCompBrickDwa(NULL, pixs, ...)
	/// (b) pixErodeCompBrickDwa(pixs, pixs, ...)
	/// (c) pixErodeCompBrickDwa(pixd, pixs, ...)<para/>
	///
	/// (9) The size of pixd is determined by pixs.<para/>
	///
	/// (10) CAUTION: both hsize and vsize are being decomposed.
	/// The decomposer chooses a product of sizes (call them
	/// 'terms') for each that is close to the input size,
	/// but not necessarily equal to it.  It attempts to optimize:
	/// (a) for consistency with the input values: the product
	/// of terms is close to the input size
	/// (b) for efficiency of the operation: the sum of the
	/// terms is small ideally about twice the square
	/// root of the input size.
	/// So, for example, if the input hsize = 37, which is
	/// a prime number, the decomposer will break this into two
	/// terms, 6 and 6, so that the net result is a dilation
	/// with hsize = 36.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixErodeCompBrickDwa/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ErodeCompBrickDwa (int hsize,
								  int vsize,
								  Pix pixd)
	{
		Pix RetObj = _All.pixErodeCompBrickDwa(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morphdwa.c (875, 1)
	// pixOpenCompBrickDwa(pixd, pixs, hsize, vsize) as Pix
	// pixOpenCompBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) These implement a separable composite opening with 2D brick Sels.<para/>
	///
	/// (2) For efficiency, it may decompose each linear morphological
	/// operation into two (brick + comb).<para/>
	///
	/// (3) A brick Sel has hits for all elements.<para/>
	///
	/// (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (5) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (6) It is necessary that both horizontal and vertical Sels
	/// of the input size are defined in the basic sela.<para/>
	///
	/// (7) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (8) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixOpenCompBrickDwa(NULL, pixs, ...)
	/// (b) pixOpenCompBrickDwa(pixs, pixs, ...)
	/// (c) pixOpenCompBrickDwa(pixd, pixs, ...)<para/>
	///
	/// (9) The size of pixd is determined by pixs.<para/>
	///
	/// (10) CAUTION: both hsize and vsize are being decomposed.
	/// The decomposer chooses a product of sizes (call them
	/// 'terms') for each that is close to the input size,
	/// but not necessarily equal to it.  It attempts to optimize:
	/// (a) for consistency with the input values: the product
	/// of terms is close to the input size
	/// (b) for efficiency of the operation: the sum of the
	/// terms is small ideally about twice the square
	/// root of the input size.
	/// So, for example, if the input hsize = 37, which is
	/// a prime number, the decomposer will break this into two
	/// terms, 6 and 6, so that the net result is a dilation
	/// with hsize = 36.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOpenCompBrickDwa/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OpenCompBrickDwa (int hsize,
								 int vsize,
								 Pix pixd)
	{
		Pix RetObj = _All.pixOpenCompBrickDwa(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morphdwa.c (1042, 1)
	// pixCloseCompBrickDwa(pixd, pixs, hsize, vsize) as Pix
	// pixCloseCompBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This implements a separable composite safe closing with 2D
	/// brick Sels.<para/>
	///
	/// (2) For efficiency, it may decompose each linear morphological
	/// operation into two (brick + comb).<para/>
	///
	/// (3) A brick Sel has hits for all elements.<para/>
	///
	/// (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)<para/>
	///
	/// (5) Do separably if both hsize and vsize are  is greater  1.<para/>
	///
	/// (6) It is necessary that both horizontal and vertical Sels
	/// of the input size are defined in the basic sela.<para/>
	///
	/// (7) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (8) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixCloseCompBrickDwa(NULL, pixs, ...)
	/// (b) pixCloseCompBrickDwa(pixs, pixs, ...)
	/// (c) pixCloseCompBrickDwa(pixd, pixs, ...)<para/>
	///
	/// (9) The size of pixd is determined by pixs.<para/>
	///
	/// (10) CAUTION: both hsize and vsize are being decomposed.
	/// The decomposer chooses a product of sizes (call them
	/// 'terms') for each that is close to the input size,
	/// but not necessarily equal to it.  It attempts to optimize:
	/// (a) for consistency with the input values: the product
	/// of terms is close to the input size
	/// (b) for efficiency of the operation: the sum of the
	/// terms is small ideally about twice the square
	/// root of the input size.
	/// So, for example, if the input hsize = 37, which is
	/// a prime number, the decomposer will break this into two
	/// terms, 6 and 6, so that the net result is a dilation
	/// with hsize = 36.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCloseCompBrickDwa/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CloseCompBrickDwa (int hsize,
								  int vsize,
								  Pix pixd)
	{
		Pix RetObj = _All.pixCloseCompBrickDwa(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morphdwa.c (1192, 1)
	// pixDilateCompBrickExtendDwa(pixd, pixs, hsize, vsize) as Pix
	// pixDilateCompBrickExtendDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Ankur Jain suggested and implemented extending the composite
	/// DWA operations beyond the 63 pixel limit.  This is a
	/// simplified and approximate implementation of the extension.
	/// This allows arbitrary Dwa morph operations using brick Sels,
	/// by decomposing the horizontal and vertical dilations into
	/// a sequence of 63-element dilations plus a dilation of size
	/// between 3 and 62.<para/>
	///
	/// (2) The 63-element dilations are exact, whereas the extra dilation
	/// is approximate, because the underlying decomposition is
	/// in pixDilateCompBrickDwa().  See there for further details.<para/>
	///
	/// (3) There are three cases:
	/// (a) pixd == null (result into new pixd)
	/// (b) pixd == pixs (in-place writes result back to pixs)
	/// (c) pixd != pixs (puts result into existing pixd)<para/>
	///
	/// (4) There is no need to call this directly:  pixDilateCompBrickDwa()
	/// calls this function if either brick dimension exceeds 63.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDilateCompBrickExtendDwa/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DilateCompBrickExtendDwa (int hsize,
										 int vsize,
										 Pix pixd)
	{
		Pix RetObj = _All.pixDilateCompBrickExtendDwa(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morphdwa.c (1312, 1)
	// pixErodeCompBrickExtendDwa(pixd, pixs, hsize, vsize) as Pix
	// pixErodeCompBrickExtendDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See pixDilateCompBrickExtendDwa() for usage.<para/>
	///
	/// (2) There is no need to call this directly:  pixErodeCompBrickDwa()
	/// calls this function if either brick dimension exceeds 63.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixErodeCompBrickExtendDwa/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ErodeCompBrickExtendDwa (int hsize,
										int vsize,
										Pix pixd)
	{
		Pix RetObj = _All.pixErodeCompBrickExtendDwa(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morphdwa.c (1432, 1)
	// pixOpenCompBrickExtendDwa(pixd, pixs, hsize, vsize) as Pix
	// pixOpenCompBrickExtendDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixOpenCompBrickExtendDwa()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOpenCompBrickExtendDwa/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd 1 There are three cases: a) pixd == null   (result into new pixd b) pixd == pixs   (in-place writes result back to pixs c) pixd != pixs   (puts result into existing pixd 2) There is no need to call this directly:  pixOpenCompBrickDwa( calls this function if either brick dimension exceeds 63.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix OpenCompBrickExtendDwa (int hsize,
									   int vsize,
									   Pix pixd)
	{
		Pix RetObj = _All.pixOpenCompBrickExtendDwa(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morphdwa.c (1473, 1)
	// pixCloseCompBrickExtendDwa(pixd, pixs, hsize, vsize) as Pix
	// pixCloseCompBrickExtendDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixCloseCompBrickExtendDwa()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCloseCompBrickExtendDwa/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hsize">[in] - width of brick Sel</param>
	///  <param name="vsize">[in] - height of brick Sel</param>
	///   <returns>pixd 1 There are three cases: a) pixd == null   (result into new pixd b) pixd == pixs   (in-place writes result back to pixs c) pixd != pixs   (puts result into existing pixd 2) There is no need to call this directly:  pixCloseCompBrickDwa( calls this function if either brick dimension exceeds 63.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CloseCompBrickExtendDwa (int hsize,
										int vsize,
										Pix pixd)
	{
		Pix RetObj = _All.pixCloseCompBrickExtendDwa(pixd, this, hsize, vsize);
		return RetObj;
	}

	// morphseq.c (133, 1)
	// pixMorphSequence(pixs, sequence, dispsep) as Pix
	// pixMorphSequence(PIX *, const char *, l_int32) as PIX *
	///  <summary>
	/// (1) This does rasterop morphology on binary images.<para/>
	///
	/// (2) This runs a pipeline of operations no branching is allowed.<para/>
	///
	/// (3) This only uses brick Sels, which are created on the fly.
	/// In the future this will be generalized to extract Sels from
	/// a Sela by name.<para/>
	///
	/// (4) A new image is always produced the input image is not changed.<para/>
	///
	/// (5) This contains an interpreter, allowing sequences to be
	/// generated and run.<para/>
	///
	/// (6) The format of the sequence string is defined below.<para/>
	///
	/// (7) In addition to morphological operations, rank order reduction
	/// and replicated expansion allow operations to take place
	/// downscaled by a power of 2.<para/>
	///
	/// (8) Intermediate results can optionally be displayed.<para/>
	///
	/// (9) Thanks to Dar-Shyang Lee, who had the idea for this and
	/// built the first implementation.<para/>
	///
	/// (10) The sequence string is formatted as follows:
	/// ~ An arbitrary number of operations,  each separated
	/// by a '+' character.  White space is ignored.
	/// ~ Each operation begins with a case-independent character
	/// specifying the operation:
	/// d or D  (dilation)
	/// e or E  (erosion)
	/// o or O  (opening)
	/// c or C  (closing)
	/// r or R  (rank binary reduction)
	/// x or X  (replicative binary expansion)
	/// b or B  (add a border of 0 pixels of this size)
	/// ~ The args to the morphological operations are bricks of hits,
	/// and are formatted as a.b, where a and b are horizontal and
	/// vertical dimensions, rsp.
	/// ~ The args to the reduction are a sequence of up to 4 integers,
	/// each from 1 to 4.
	/// ~ The arg to the expansion is a power of two, in the set
	/// {2, 4, 8, 16}.<para/>
	///
	/// (11) An example valid sequence is:
	/// "b32 + o1.3 + C3.1 + r23 + e2.2 + D3.2 + X4"
	/// In this example, the following operation sequence is carried out:
	/// b32: Add a 32 pixel border around the input image
	/// o1.3: Opening with vert sel of length 3 (e.g., 1 x 3)
	/// C3.1: Closing with horiz sel of length 3  (e.g., 3 x 1)
	/// r23: Two successive 2x2 reductions with rank 2 in the first
	/// and rank 3 in the second.  The result is a 4x reduced pix.
	/// e2.2: Erosion with a 2x2 sel (origin will be at x,y: 0,0)
	/// d3.2: Dilation with a 3x2 sel (origin will be at x,y: 1,0)
	/// X4: 4x replicative expansion, back to original resolution<para/>
	///
	/// (12) The safe closing is used.  However, if you implement a
	/// closing as separable dilations followed by separable erosions,
	/// it will not be safe.  For that situation, you need to add
	/// a sufficiently large border as the first operation in
	/// the sequence.  This will be removed automatically at the
	/// end.  There are two cautions:
	/// ~ When computing what is sufficient, remember that if
	/// reductions are carried out, the border is also reduced.
	/// ~ The border is removed at the end, so if a border is
	/// added at the beginning, the result must be at the
	/// same resolution as the input!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMorphSequence/*"/>
	///  <param name="sequence">[in] - string specifying sequence</param>
	///  <param name="dispsep">[in] - controls debug display of each result in the sequence: 0: no output  is greater  0: gives horizontal separation in pixels between successive displays  is smaller 0: pdf output abs(dispsep) is used for naming</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MorphSequence (String sequence,
							  int dispsep)
	{
		Pix RetObj = _All.pixMorphSequence(this, sequence, dispsep);
		return RetObj;
	}

	// morphseq.c (300, 1)
	// pixMorphCompSequence(pixs, sequence, dispsep) as Pix
	// pixMorphCompSequence(PIX *, const char *, l_int32) as PIX *
	///  <summary>
	/// (1) This does rasterop morphology on binary images, using composite
	/// operations for extra speed on large Sels.<para/>
	///
	/// (2) Safe closing is used atomically.  However, if you implement a
	/// closing as a sequence with a dilation followed by an
	/// erosion, it will not be safe, and to ensure that you have
	/// no boundary effects you must add a border in advance and
	/// remove it at the end.<para/>
	///
	/// (3) For other usage details, see the notes for pixMorphSequence().<para/>
	///
	/// (4) The sequence string is formatted as follows:
	/// ~ An arbitrary number of operations,  each separated
	/// by a '+' character.  White space is ignored.
	/// ~ Each operation begins with a case-independent character
	/// specifying the operation:
	/// d or D  (dilation)
	/// e or E  (erosion)
	/// o or O  (opening)
	/// c or C  (closing)
	/// r or R  (rank binary reduction)
	/// x or X  (replicative binary expansion)
	/// b or B  (add a border of 0 pixels of this size)
	/// ~ The args to the morphological operations are bricks of hits,
	/// and are formatted as a.b, where a and b are horizontal and
	/// vertical dimensions, rsp.
	/// ~ The args to the reduction are a sequence of up to 4 integers,
	/// each from 1 to 4.
	/// ~ The arg to the expansion is a power of two, in the set
	/// {2, 4, 8, 16}.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMorphCompSequence/*"/>
	///  <param name="sequence">[in] - string specifying sequence</param>
	///  <param name="dispsep">[in] - controls debug display of each result in the sequence: 0: no output  is greater  0: gives horizontal separation in pixels between successive displays  is smaller 0: pdf output abs(dispsep) is used for naming</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MorphCompSequence (String sequence,
								  int dispsep)
	{
		Pix RetObj = _All.pixMorphCompSequence(this, sequence, dispsep);
		return RetObj;
	}

	// morphseq.c (449, 1)
	// pixMorphSequenceDwa(pixs, sequence, dispsep) as Pix
	// pixMorphSequenceDwa(PIX *, const char *, l_int32) as PIX *
	///  <summary>
	/// (1) This does dwa morphology on binary images.<para/>
	///
	/// (2) This runs a pipeline of operations no branching is allowed.<para/>
	///
	/// (3) This only uses brick Sels that have been pre-compiled with
	/// dwa code.<para/>
	///
	/// (4) A new image is always produced the input image is not changed.<para/>
	///
	/// (5) This contains an interpreter, allowing sequences to be
	/// generated and run.<para/>
	///
	/// (6) See pixMorphSequence() for further information about usage.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMorphSequenceDwa/*"/>
	///  <param name="sequence">[in] - string specifying sequence</param>
	///  <param name="dispsep">[in] - controls debug display of each result in the sequence: 0: no output  is greater  0: gives horizontal separation in pixels between successive displays  is smaller 0: pdf output abs(dispsep) is used for naming</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MorphSequenceDwa (String sequence,
								 int dispsep)
	{
		Pix RetObj = _All.pixMorphSequenceDwa(this, sequence, dispsep);
		return RetObj;
	}

	// morphseq.c (598, 1)
	// pixMorphCompSequenceDwa(pixs, sequence, dispsep) as Pix
	// pixMorphCompSequenceDwa(PIX *, const char *, l_int32) as PIX *
	///  <summary>
	/// (1) This does dwa morphology on binary images, using brick Sels.<para/>
	///
	/// (2) This runs a pipeline of operations no branching is allowed.<para/>
	///
	/// (3) It implements all brick Sels that have dimensions up to 63
	/// on each side, using a composite (linear + comb) when useful.<para/>
	///
	/// (4) A new image is always produced the input image is not changed.<para/>
	///
	/// (5) This contains an interpreter, allowing sequences to be
	/// generated and run.<para/>
	///
	/// (6) See pixMorphSequence() for further information about usage.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMorphCompSequenceDwa/*"/>
	///  <param name="sequence">[in] - string specifying sequence</param>
	///  <param name="dispsep">[in] - controls debug display of each result in the sequence: 0: no output  is greater  0: gives horizontal separation in pixels between successive displays  is smaller 0: pdf output abs(dispsep) is used for naming</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MorphCompSequenceDwa (String sequence,
									 int dispsep)
	{
		Pix RetObj = _All.pixMorphCompSequenceDwa(this, sequence, dispsep);
		return RetObj;
	}

	// morphseq.c (912, 1)
	// pixGrayMorphSequence(pixs, sequence, dispsep, dispy) as Pix
	// pixGrayMorphSequence(PIX *, const char *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This works on 8 bpp grayscale images.<para/>
	///
	/// (2) This runs a pipeline of operations no branching is allowed.<para/>
	///
	/// (3) This only uses brick SELs.<para/>
	///
	/// (4) A new image is always produced the input image is not changed.<para/>
	///
	/// (5) This contains an interpreter, allowing sequences to be
	/// generated and run.<para/>
	///
	/// (6) The format of the sequence string is defined below.<para/>
	///
	/// (7) In addition to morphological operations, the composite
	/// morph/subtract tophat can be performed.<para/>
	///
	/// (8) Sel sizes (width, height) must each be odd numbers.<para/>
	///
	/// (9) Intermediate results can optionally be displayed<para/>
	///
	/// (10) The sequence string is formatted as follows:
	/// ~ An arbitrary number of operations,  each separated
	/// by a '+' character.  White space is ignored.
	/// ~ Each operation begins with a case-independent character
	/// specifying the operation:
	/// d or D  (dilation)
	/// e or E  (erosion)
	/// o or O  (opening)
	/// c or C  (closing)
	/// t or T  (tophat)
	/// ~ The args to the morphological operations are bricks of hits,
	/// and are formatted as a.b, where a and b are horizontal and
	/// vertical dimensions, rsp. (each must be an odd number)
	/// ~ The args to the tophat are w or W (for white tophat)
	/// or b or B (for black tophat), followed by a.b as for
	/// the dilation, erosion, opening and closing.
	/// Example valid sequences are:
	/// "c5.3 + o7.5"
	/// "c9.9 + tw9.9"
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGrayMorphSequence/*"/>
	///  <param name="sequence">[in] - string specifying sequence</param>
	///  <param name="dispsep">[in] - controls debug display of each result in the sequence: 0: no output  is greater  0: gives horizontal separation in pixels between successive displays  is smaller 0: pdf output abs(dispsep) is used for naming</param>
	///  <param name="dispy">[in] - if dispsep  is greater  0, this gives the y-value of the UL corner for display otherwise it is ignored</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GrayMorphSequence (String sequence,
								  int dispsep,
								  int dispy)
	{
		Pix RetObj = _All.pixGrayMorphSequence(this, sequence, dispsep, dispy);
		return RetObj;
	}

	// morphseq.c (1117, 1)
	// pixColorMorphSequence(pixs, sequence, dispsep, dispy) as Pix
	// pixColorMorphSequence(PIX *, const char *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This works on 32 bpp rgb images.<para/>
	///
	/// (2) Each component is processed separately.<para/>
	///
	/// (3) This runs a pipeline of operations no branching is allowed.<para/>
	///
	/// (4) This only uses brick SELs.<para/>
	///
	/// (5) A new image is always produced the input image is not changed.<para/>
	///
	/// (6) This contains an interpreter, allowing sequences to be
	/// generated and run.<para/>
	///
	/// (7) Sel sizes (width, height) must each be odd numbers.<para/>
	///
	/// (8) The format of the sequence string is defined below.<para/>
	///
	/// (9) Intermediate results can optionally be displayed.<para/>
	///
	/// (10) The sequence string is formatted as follows:
	/// ~ An arbitrary number of operations,  each separated
	/// by a '+' character.  White space is ignored.
	/// ~ Each operation begins with a case-independent character
	/// specifying the operation:
	/// d or D  (dilation)
	/// e or E  (erosion)
	/// o or O  (opening)
	/// c or C  (closing)
	/// ~ The args to the morphological operations are bricks of hits,
	/// and are formatted as a.b, where a and b are horizontal and
	/// vertical dimensions, rsp. (each must be an odd number)
	/// Example valid sequences are:
	/// "c5.3 + o7.5"
	/// "D9.1"
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorMorphSequence/*"/>
	///  <param name="sequence">[in] - string specifying sequence</param>
	///  <param name="dispsep">[in] - controls debug display of each result in the sequence: 0: no output  is greater  0: gives horizontal separation in pixels between successive displays  is smaller 0: pdf output abs(dispsep) is used for naming</param>
	///  <param name="dispy">[in] - if dispsep  is greater  0, this gives the y-value of the UL corner for display otherwise it is ignored</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ColorMorphSequence (String sequence,
								   int dispsep,
								   int dispy)
	{
		Pix RetObj = _All.pixColorMorphSequence(this, sequence, dispsep, dispy);
		return RetObj;
	}

	// pageseg.c (102, 1)
	// pixGetRegionsBinary(pixs, ppixhm, ppixtm, ppixtb, pixadb) as int
	// pixGetRegionsBinary(PIX *, PIX **, PIX **, PIX **, PIXA *) as l_ok
	///  <summary>
	/// (1) It is best to deskew the image before segmenting.<para/>
	///
	/// (2) Passing in %pixadb enables debug output.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRegionsBinary/*"/>
	///  <param name="ppixhm">[out][optional] - halftone mask</param>
	///  <param name="ppixtm">[out][optional] - textline mask</param>
	///  <param name="ppixtb">[out][optional] - textblock mask</param>
	///  <param name="pixadb">[in] - input for collecting debug pix use NULL to skip</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRegionsBinary (Pixa pixadb,
								 out Pix ppixhm,
								 out Pix ppixtm,
								 out Pix ppixtb)
	{
		int RetObj = _All.pixGetRegionsBinary(this, out ppixhm, out ppixtm, out ppixtb, pixadb);
		return RetObj;
	}

	// pageseg.c (264, 1)
	// pixGenHalftoneMask(pixs, ppixtext, phtfound, debug) as Pix
	// pixGenHalftoneMask(PIX *, PIX **, l_int32 *, l_int32) as PIX *
	///  <summary>
	/// Deprecated:
	/// This wrapper avoids an ABI change with tesseract 3.0.4.
	/// It should be removed when we no longer need to support 3.0.4.
	/// The debug parameter is ignored (assumed 0).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenHalftoneMask/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GenHalftoneMask (Pix ppixtext,
								object phtfound,
								DebugOnOff debug)
	{
		Pix RetObj = _All.pixGenHalftoneMask(this, ppixtext, phtfound, debug);
		return RetObj;
	}

	// pageseg.c (289, 1)
	// pixGenerateHalftoneMask(pixs, ppixtext, phtfound, pixadb) as Pix
	// pixGenerateHalftoneMask(PIX *, PIX **, l_int32 *, PIXA *) as PIX *
	///  <summary>
	/// (1) This is not intended to work on small thumbnails.  The
	/// dimensions of pixs must be at least MinWidth x MinHeight.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenerateHalftoneMask/*"/>
	///  <param name="ppixtext">[out][optional] - text part of pixs</param>
	///  <param name="phtfound">[out][optional] - 1 if the mask is not empty</param>
	///  <param name="pixadb">[in] - input for collecting debug pix use NULL to skip</param>
	///   <returns>pixd halftone mask, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GenerateHalftoneMask (Pixa pixadb,
									 out Pix ppixtext,
									 out int phtfound)
	{
		Pix RetObj = _All.pixGenerateHalftoneMask(this, out ppixtext, out phtfound, pixadb);
		return RetObj;
	}

	// pageseg.c (372, 1)
	// pixGenTextlineMask(pixs, ppixvws, ptlfound, pixadb) as Pix
	// pixGenTextlineMask(PIX *, PIX **, l_int32 *, PIXA *) as PIX *
	///  <summary>
	/// (1) The input pixs should be deskewed.<para/>
	///
	/// (2) pixs should have no halftone pixels.<para/>
	///
	/// (3) This is not intended to work on small thumbnails.  The
	/// dimensions of pixs must be at least MinWidth x MinHeight.<para/>
	///
	/// (4) Both the input image and the returned textline mask
	/// are at the same resolution.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenTextlineMask/*"/>
	///  <param name="ppixvws">[out] - vertical whitespace mask</param>
	///  <param name="ptlfound">[out][optional] - 1 if the mask is not empty</param>
	///  <param name="pixadb">[in] - input for collecting debug pix use NULL to skip</param>
	///   <returns>pixd textline mask, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GenTextlineMask (out Pix ppixvws,
								Pixa pixadb,
								out int ptlfound)
	{
		Pix RetObj = _All.pixGenTextlineMask(this, out ppixvws, out ptlfound, pixadb);
		return RetObj;
	}

	// pageseg.c (464, 1)
	// pixGenTextblockMask(pixs, pixvws, pixadb) as Pix
	// pixGenTextblockMask(PIX *, PIX *, PIXA *) as PIX *
	///  <summary>
	/// (1) Both the input masks (textline and vertical white space) and
	/// the returned textblock mask are at the same resolution.<para/>
	///
	/// (2) This is not intended to work on small thumbnails.  The
	/// dimensions of pixs must be at least MinWidth x MinHeight.<para/>
	///
	/// (3) The result is somewhat noisy, in that small "blocks" of
	/// text may be included.  These can be removed by post-processing,
	/// using, e.g.,
	/// pixSelectBySize(pix, 60, 60, 4, L_SELECT_IF_EITHER,
	/// L_SELECT_IF_GTE, NULL)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenTextblockMask/*"/>
	///  <param name="pixvws">[in] - vertical white space mask</param>
	///  <param name="pixadb">[in] - input for collecting debug pix use NULL to skip</param>
	///   <returns>pixd textblock mask, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GenTextblockMask (Pix pixvws,
								 Pixa pixadb)
	{
		Pix RetObj = _All.pixGenTextblockMask(this, pixvws, pixadb);
		return RetObj;
	}

	// pageseg.c (548, 1)
	// pixFindPageForeground(pixs, threshold, mindist, erasedist, showmorph, pixac) as Box
	// pixFindPageForeground(PIX *, l_int32, l_int32, l_int32, l_int32, PIXAC *) as BOX *
	///  <summary>
	/// (1) This doesn't simply crop to the fg.  It attempts to remove
	/// pixel noise and junk at the edge of the image before cropping.
	/// The input %threshold is used if pixs is not 1 bpp.<para/>
	///
	/// (2) This is not intended to work on small thumbnails.  The
	/// dimensions of pixs must be at least MinWidth x MinHeight.<para/>
	///
	/// (3) Debug: set showmorph to display the intermediate image in
	/// the morphological operations on this page.<para/>
	///
	/// (4) Debug: to get pdf output of results when called repeatedly,
	/// call with an existing pixac, which will add an image of this page,
	/// with the fg outlined.  If no foreground is found, there is
	/// no output for this page image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindPageForeground/*"/>
	///  <param name="threshold">[in] - for binarization typically about 128</param>
	///  <param name="mindist">[in] - min distance of text from border to allow cleaning near border at 2x reduction, this should be larger than 50 typically about 70</param>
	///  <param name="erasedist">[in] - when conditions are satisfied, erase anything within this distance of the edge typically 20-30 at 2x reduction</param>
	///  <param name="showmorph">[in] - debug: set to a negative integer to show steps in generating masks this is typically used for debugging region extraction</param>
	///  <param name="pixac">[in] - debug: allocate outside and pass this in to accumulate results of each call to this function, which can be displayed in a mosaic or a pdf.</param>
	///   <returns>box region including foreground, with some pixel noise removed, or NULL if not found</returns>
	// CreateAdditiveFunction: Function/Else
	public Box FindPageForeground (int threshold,
								   int mindist,
								   int erasedist,
								   int showmorph,
								   PixaComp pixac)
	{
		Box RetObj = _All.pixFindPageForeground(this, threshold, mindist, erasedist, showmorph, pixac);
		return RetObj;
	}

	// pageseg.c (679, 1)
	// pixSplitIntoCharacters(pixs, minw, minh, pboxa, ppixa, ppixdebug) as int
	// pixSplitIntoCharacters(PIX *, l_int32, l_int32, BOXA **, PIXA **, PIX **) as l_ok
	///  <summary>
	/// (1) This is a simple function that attempts to find split points
	/// based on vertical pixel profiles.<para/>
	///
	/// (2) It should be given an image that has an arbitrary number
	/// of text characters.<para/>
	///
	/// (3) The returned pixa includes the boxes from which the
	/// (possibly split) components are extracted.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSplitIntoCharacters/*"/>
	///  <param name="minw">[in] - min component width for initial filtering typ. 4</param>
	///  <param name="minh">[in] - min component height for initial filtering typ. 4</param>
	///  <param name="pboxa">[out][optional] - character bounding boxes</param>
	///  <param name="ppixa">[out][optional] - character images</param>
	///  <param name="ppixdebug">[out][optional] - showing splittings</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SplitIntoCharacters (int minw,
									int minh,
									out Boxa pboxa,
									out Pixa ppixa,
									out Pix ppixdebug)
	{
		int RetObj = _All.pixSplitIntoCharacters(this, minw, minh, out pboxa, out ppixa, out ppixdebug);
		return RetObj;
	}

	// pageseg.c (780, 1)
	// pixSplitComponentWithProfile(pixs, delta, mindel, ppixdebug) as Boxa
	// pixSplitComponentWithProfile(PIX *, l_int32, l_int32, PIX **) as BOXA *
	///  <summary>
	/// (1) This will split the most obvious cases of touching characters.
	/// The split points it is searching for are narrow and deep
	/// minimima in the vertical pixel projection profile, after a
	/// large vertical closing has been applied to the component.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSplitComponentWithProfile/*"/>
	///  <param name="delta">[in] - distance used in extrema finding in a numa typ. 10</param>
	///  <param name="mindel">[in] - minimum required difference between profile minimum and profile values +2 and -2 away typ. 7</param>
	///  <param name="ppixdebug">[out][optional] - debug image of splitting</param>
	///   <returns>boxa of c.c. after splitting, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa SplitComponentWithProfile (int delta,
										   int mindel,
										   out Pix ppixdebug)
	{
		Boxa RetObj = _All.pixSplitComponentWithProfile(this, delta, mindel, out ppixdebug);
		return RetObj;
	}

	// pageseg.c (936, 1)
	// pixExtractTextlines(pixs, maxw, maxh, minw, minh, adjw, adjh, pixadb) as Pixa
	// pixExtractTextlines(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, PIXA *) as PIXA *
	///  <summary>
	/// (1) This function assumes that textline fragments have sufficient
	/// vertical separation and small enough skew so that a
	/// horizontal dilation sufficient to join words will not join
	/// textlines.  It does not guarantee that horizontally adjacent
	/// textline fragments on the same line will be joined.<para/>
	///
	/// (2) For images with multiple columns, it attempts to avoid joining
	/// textlines across the space between columns.  If that is not
	/// a concern, you can also use pixExtractRawTextlines(),
	/// which will join them with alacrity.<para/>
	///
	/// (3) This first removes components from pixs that are either
	/// wide ( is greater  %maxw) or tall ( is greater  %maxh).<para/>
	///
	/// (4) A final filtering operation removes small components, such
	/// that width  is smaller %minw or height  is smaller %minh.<para/>
	///
	/// (5) For reasonable accuracy, the resolution of pixs should be
	/// at least 100 ppi.  For reasonable efficiency, the resolution
	/// should not exceed 600 ppi.<para/>
	///
	/// (6) This can be used to determine if some region of a scanned
	/// image is horizontal text.<para/>
	///
	/// (7) As an example, for a pix with resolution 300 ppi, a reasonable
	/// set of parameters is:
	/// pixExtractTextlines(pix, 150, 150, 36, 20, 5, 5, NULL)
	/// The defaults minw and minh for 300 ppi are about 36 and 20,
	/// so the same result is obtained with:
	/// pixExtractTextlines(pix, 150, 150, 0, 0, 5, 5, NULL)<para/>
	///
	/// (8) The output pixa is composed of subimages, one for each textline,
	/// and the boxa in the pixa tells where in %pixs each textline goes.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExtractTextlines/*"/>
	///  <param name="maxw">[in] - initial filtering: remove any components in pixs with components larger than maxw or maxh</param>
	///  <param name="maxh">[in] - initial filtering: remove any components in pixs with components larger than maxw or maxh</param>
	///  <param name="minw">[in] - final filtering: remove extracted 'lines' with sizes smaller than minw or minh use 0 for default.</param>
	///  <param name="minh">[in] - final filtering: remove extracted 'lines' with sizes smaller than minw or minh use 0 for default.</param>
	///  <param name="adjw">[in] - final adjustment of boxes representing each text line.  If  is greater  0, these increase the box size at each edge by this amount.</param>
	///  <param name="adjh">[in] - final adjustment of boxes representing each text line.  If  is greater  0, these increase the box size at each edge by this amount.</param>
	///  <param name="pixadb">[in] - pixa for saving intermediate steps NULL to omit</param>
	///   <returns>pixa of textline images, including bounding boxes, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ExtractTextlines (int maxw,
								  int maxh,
								  int minw,
								  int minh,
								  int adjw,
								  int adjh,
								  Pixa pixadb)
	{
		Pixa RetObj = _All.pixExtractTextlines(this, maxw, maxh, minw, minh, adjw, adjh, pixadb);
		return RetObj;
	}

	// pageseg.c (1076, 1)
	// pixExtractRawTextlines(pixs, maxw, maxh, adjw, adjh, pixadb) as Pixa
	// pixExtractRawTextlines(PIX *, l_int32, l_int32, l_int32, l_int32, PIXA *) as PIXA *
	///  <summary>
	/// (1) This function assumes that textlines have sufficient
	/// vertical separation and small enough skew so that a
	/// horizontal dilation sufficient to join words will not join
	/// textlines.  It aggressively joins textlines across multiple
	/// columns, so if that is not desired, you must either (a) make
	/// sure that %pixs is a single column of text or (b) use instead
	/// pixExtractTextlines(), which is more conservative
	/// about joining text fragments that have vertical overlap.<para/>
	///
	/// (2) This first removes components from pixs that are either
	/// very wide ( is greater  %maxw) or very tall ( is greater  %maxh).<para/>
	///
	/// (3) For reasonable accuracy, the resolution of pixs should be
	/// at least 100 ppi.  For reasonable efficiency, the resolution
	/// should not exceed 600 ppi.<para/>
	///
	/// (4) This can be used to determine if some region of a scanned
	/// image is horizontal text.<para/>
	///
	/// (5) As an example, for a pix with resolution 300 ppi, a reasonable
	/// set of parameters is:
	/// pixExtractRawTextlines(pix, 150, 150, 0, 0, NULL)<para/>
	///
	/// (6) The output pixa is composed of subimages, one for each textline,
	/// and the boxa in the pixa tells where in %pixs each textline goes.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExtractRawTextlines/*"/>
	///  <param name="maxw">[in] - initial filtering: remove any components in pixs with components larger than maxw or maxh use 0 for default values.</param>
	///  <param name="maxh">[in] - initial filtering: remove any components in pixs with components larger than maxw or maxh use 0 for default values.</param>
	///  <param name="adjw">[in] - final adjustment of boxes representing each text line.  If  is greater  0, these increase the box size at each edge by this amount.</param>
	///  <param name="adjh">[in] - final adjustment of boxes representing each text line.  If  is greater  0, these increase the box size at each edge by this amount.</param>
	///  <param name="pixadb">[in] - pixa for saving intermediate steps NULL to omit</param>
	///   <returns>pixa of textline images, including bounding boxes, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ExtractRawTextlines (int maxw,
									 int maxh,
									 int adjw,
									 int adjh,
									 Pixa pixadb)
	{
		Pixa RetObj = _All.pixExtractRawTextlines(this, maxw, maxh, adjw, adjh, pixadb);
		return RetObj;
	}

	// pageseg.c (1204, 1)
	// pixCountTextColumns(pixs, deltafract, peakfract, clipfract, pncols, pixadb) as int
	// pixCountTextColumns(PIX *, l_float32, l_float32, l_float32, l_int32 *, PIXA *) as l_ok
	///  <summary>
	/// (1) It is assumed that pixs has the correct resolution set.
	/// If the resolution is 0, we set to 300 and issue a warning.<para/>
	///
	/// (2) If necessary, the image is scaled to between 37 and 75 ppi
	/// most of the processing is done at this resolution.<para/>
	///
	/// (3) If no text is found (essentially a blank page),
	/// this returns ncols = 0.<para/>
	///
	/// (4) For debug output, input a pre-allocated pixa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCountTextColumns/*"/>
	///  <param name="deltafract">[in] - fraction of (max - min) to be used in the delta for extrema finding typ 0.3</param>
	///  <param name="peakfract">[in] - fraction of (max - min) to be used to threshold the peak value typ. 0.5</param>
	///  <param name="clipfract">[in] - fraction of image dimension removed on each side typ. 0.1, which leaves w and h reduced by 0.8</param>
	///  <param name="pncols">[out] - number of columns -1 if not determined</param>
	///  <param name="pixadb">[in][optional] - pre-allocated, for showing intermediate computation use null to skip</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CountTextColumns (Single deltafract,
								 Single peakfract,
								 Single clipfract,
								 out int pncols,
								 Pixa pixadb)
	{
		int RetObj = _All.pixCountTextColumns(this, deltafract, peakfract, clipfract, out pncols, pixadb);
		return RetObj;
	}

	// pageseg.c (1352, 1)
	// pixDecideIfText(pixs, box, pistext, pixadb) as int
	// pixDecideIfText(PIX *, BOX *, l_int32 *, PIXA *) as l_ok
	///  <summary>
	/// (1) It is assumed that pixs has the correct resolution set.
	/// If the resolution is 0, we set to 300 and issue a warning.<para/>
	///
	/// (2) If necessary, the image is scaled to 300 ppi most of the
	/// processing is done at this resolution.<para/>
	///
	/// (3) Text is assumed to be in horizontal lines.<para/>
	///
	/// (4) Because thin vertical lines are removed before filtering for
	/// text lines, this should identify tables as text.<para/>
	///
	/// (5) If %box is null and pixs contains both text lines and line art,
	/// this function might return %istext == true.<para/>
	///
	/// (6) If the input pixs is empty, or for some other reason the
	/// result can not be determined, return -1.<para/>
	///
	/// (7) For debug output, input a pre-allocated pixa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDecideIfText/*"/>
	///  <param name="box">[in][optional] - if null, use entire pixs</param>
	///  <param name="pistext">[out] - 1 if text 0 if photo -1 if not determined or empty</param>
	///  <param name="pixadb">[in][optional] - pre-allocated, for showing intermediate computation use NULL to skip</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int DecideIfText (out int pistext,
							 Box box,
							 Pixa pixadb)
	{
		int RetObj = _All.pixDecideIfText(this, box, out pistext, pixadb);
		return RetObj;
	}

	// pageseg.c (1518, 1)
	// pixFindThreshFgExtent(pixs, thresh, ptop, pbot) as int
	// pixFindThreshFgExtent(PIX *, l_int32, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixFindThreshFgExtent()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindThreshFgExtent/*"/>
	///  <param name="thresh">[in] - threshold number of pixels in row</param>
	///  <param name="ptop">[out][optional] - location of top of region</param>
	///  <param name="pbot">[out][optional] - location of bottom of region</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindThreshFgExtent (int thresh,
								   out int ptop,
								   out int pbot)
	{
		int RetObj = _All.pixFindThreshFgExtent(this, thresh, out ptop, out pbot);
		return RetObj;
	}

	// pageseg.c (1608, 1)
	// pixDecideIfTable(pixs, box, orient, pscore, pixadb) as int
	// pixDecideIfTable(PIX *, BOX *, l_int32, l_int32 *, PIXA *) as l_ok
	///  <summary>
	/// (1) It is assumed that pixs has the correct resolution set.
	/// If the resolution is 0, we assume it is 300 ppi and issue a warning.<para/>
	///
	/// (2) If %orient == L_LANDSCAPE_MODE, the image is rotated 90 degrees
	/// clockwise before being analyzed.<para/>
	///
	/// (3) The interpretation of the returned score:
	/// -1 undetermined
	/// 0 no table
	/// 1 unlikely to have a table
	/// 2 likely to have a table
	/// 3 even more likely to have a table
	/// 4 extremely likely to have a table
	/// Setting the condition for finding a table at score greater or equal 2 works
	/// well, except for false positives on kanji and landscape text.
	/// These false positives can be removed by setting the condition
	/// at score greater or equal 3, but recall is lowered because it will not find
	/// tables without either horizontal or vertical lines.<para/>
	///
	/// (4) Most of the processing takes place at 75 ppi.<para/>
	///
	/// (5) Internally, three numbers are determined, for horizontal and
	/// vertical fg lines, and for vertical bg lines.  From these,
	/// four tests are made to decide if there is a table occupying
	/// a significant part of the image.<para/>
	///
	/// (6) Images have arbitrary content and would be likely to trigger
	/// this detector, so they are checked for first, and if found,
	/// return with a 0 (no table) score.<para/>
	///
	/// (7) Musical scores (tablature) are likely to trigger the detector.<para/>
	///
	/// (8) Tables of content with more than 2 columns are likely to
	/// trigger the detector.<para/>
	///
	/// (9) For debug output, input a pre-allocated pixa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDecideIfTable/*"/>
	///  <param name="box">[in][optional] - if null, use entire pixs</param>
	///  <param name="orient">[in] - L_PORTRAIT_MODE, L_LANDSCAPE_MODE</param>
	///  <param name="pscore">[out] - 0 - 4 -1 if not determined</param>
	///  <param name="pixadb">[in][optional] - pre-allocated, for showing intermediate computation use NULL to skip</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int DecideIfTable (int orient,
							  out int pscore,
							  Box box,
							  Pixa pixadb)
	{
		int RetObj = _All.pixDecideIfTable(this, box, orient, out pscore, pixadb);
		return RetObj;
	}

	// pageseg.c (1758, 1)
	// pixPrepare1bpp(pixs, box, cropfract, outres) as Pix
	// pixPrepare1bpp(PIX *, BOX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) This handles some common pre-processing operations,
	/// where the page segmentation algorithm takes a 1 bpp image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixPrepare1bpp/*"/>
	///  <param name="box">[in][optional] - if null, use entire pixs</param>
	///  <param name="cropfract">[in] - fraction to be removed from the boundary use 0.0 to retain the entire image</param>
	///  <param name="outres">[in] - desired resolution of output image if the input image resolution is not set, assume 300 ppi use 0 to skip scaling.</param>
	///   <returns>pixd if OK, NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Prepare1bpp (Single cropfract,
							int outres,
							Box box)
	{
		Pix RetObj = _All.pixPrepare1bpp(this, box, cropfract, outres);
		return RetObj;
	}

	// pageseg.c (1843, 1)
	// pixEstimateBackground(pixs, darkthresh, edgecrop, pbg) as int
	// pixEstimateBackground(PIX *, l_int32, l_float32, l_int32 *) as l_ok
	///  <summary>
	/// (1) Caller should check that return bg value is  is greater  0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixEstimateBackground/*"/>
	///  <param name="darkthresh">[in] - pixels below this value are never considered part of the background typ. 70 use 0 to skip</param>
	///  <param name="edgecrop">[in] - fraction of half-width on each side, and of half-height at top and bottom, that are cropped</param>
	///  <param name="pbg">[out] - estimated background, or 0 on error</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int EstimateBackground (int darkthresh,
								   Single edgecrop,
								   out int pbg)
	{
		int RetObj = _All.pixEstimateBackground(this, darkthresh, edgecrop, out pbg);
		return RetObj;
	}

	// pageseg.c (1927, 1)
	// pixFindLargeRectangles(pixs, polarity, nrect, pboxa, ppixdb) as int
	// pixFindLargeRectangles(PIX *, l_int32, l_int32, BOXA **, PIX **) as l_ok
	///  <summary>
	/// (1) This does a greedy search to find the largest rectangles,
	/// either black or white and without overlaps, in %pix.<para/>
	///
	/// (2) See pixFindLargestRectangle(), which is called multiple
	/// times, for details.  On each call, the largest rectangle
	/// found is painted, so that none of its pixels can be
	/// used later, before calling it again.<para/>
	///
	/// (3) This function is surprisingly fast.  Although
	/// pixFindLargestRectangle() runs at about 50 MPix/sec, when it
	/// is run multiple times by pixFindLargeRectangles(), it processes
	/// at 150 - 250 MPix/sec, and the time is approximately linear
	/// in %nrect.  For example, for a 1 MPix image, searching for
	/// the largest 50 boxes takes about 0.2 seconds.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindLargeRectangles/*"/>
	///  <param name="polarity">[in] - 0 within background, 1 within foreground</param>
	///  <param name="nrect">[in] - number of rectangles to be found</param>
	///  <param name="pboxa">[out] - largest rectangles, sorted by decreasing area</param>
	///  <param name="ppixdb">[in,out] - optional return output with rectangles drawn on it</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindLargeRectangles (int polarity,
									int nrect,
									out Boxa pboxa,
									ref Pix ppixdb)
	{
		int RetObj = _All.pixFindLargeRectangles(this, polarity, nrect, out pboxa, ref ppixdb);
		return RetObj;
	}

	// pageseg.c (2030, 1)
	// pixFindLargestRectangle(pixs, polarity, pbox, ppixdb) as int
	// pixFindLargestRectangle(PIX *, l_int32, BOX **, PIX **) as l_ok
	///  <summary>
	/// (1) This is a simple and elegant solution to a problem in
	/// computational geometry that at first appears to be quite
	/// difficult: what is the largest rectangle that can be
	/// placed in the image, covering only pixels of one polarity
	/// (bg or fg)?  The solution is O(n), where n is the number
	/// of pixels in the image, and it requires nothing more than
	/// using a simple recursion relation in a single sweep of the image.<para/>
	///
	/// (2) In a sweep from UL to LR with left-to-right being the fast
	/// direction, calculate the largest white rectangle at (x, y),
	/// using previously calculated values at pixels #1 and #2:
	/// #1:  (x, y - 1)
	/// #2:  (x - 1, y)
	/// We also need the most recent "black" pixels that were seen
	/// in the current row and column.
	/// Consider the largest area.  There are only two possibilities:
	/// (a)  Min(w(1), horizdist)  (h(1) + 1)
	/// (b)  Min(h(2), vertdist)  (w(2) + 1)
	/// where
	/// horizdist: the distance from the rightmost "black" pixel seen
	/// in the current row across to the current pixel
	/// vertdist: the distance from the lowest "black" pixel seen
	/// in the current column down to the current pixel
	/// and we choose the Max of (a) and (b).<para/>
	///
	/// (3) To convince yourself that these recursion relations are correct,
	/// it helps to draw the maximum rectangles at #1 and #2.
	/// Then for #1, you try to extend the rectangle down one line,
	/// so that the height is h(1) + 1.  Do you get the full
	/// width of #1, w(1)?  It depends on where the black pixels are
	/// in the current row.  You know the final width is bounded by w(1)
	/// and w(2) + 1, but the actual value depends on the distribution
	/// of black pixels in the current row that are at a distance
	/// from the current pixel that is between these limits.
	/// We call that value "horizdist", and the area is then given
	/// by the expression (a) above.  Using similar reasoning for #2,
	/// where you attempt to extend the rectangle to the right
	/// by 1 pixel, you arrive at (b).  The largest rectangle is
	/// then found by taking the Max.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindLargestRectangle/*"/>
	///  <param name="polarity">[in] - 0 within background, 1 within foreground</param>
	///  <param name="pbox">[out] - largest area rectangle</param>
	///  <param name="ppixdb">[in,out] - optional return output with rectangle drawn on it</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindLargestRectangle (int polarity,
									 out Box pbox,
									 ref Pix ppixdb)
	{
		int RetObj = _All.pixFindLargestRectangle(this, polarity, out pbox, ref ppixdb);
		return RetObj;
	}

	// paintcmap.c (98, 1)
	// pixSetSelectCmap(pixs, box, sindex, rval, gval, bval) as int
	// pixSetSelectCmap(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place operation.<para/>
	///
	/// (2) It sets all pixels in region that have the color specified
	/// by the colormap index 'sindex' to the new color.<para/>
	///
	/// (3) sindex must be in the existing colormap otherwise an
	/// error is returned.<para/>
	///
	/// (4) If the new color exists in the colormap, it is used
	/// otherwise, it is added to the colormap.  If it cannot be
	/// added because the colormap is full, an error is returned.<para/>
	///
	/// (5) If box is NULL, applies function to the entire image otherwise,
	/// clips the operation to the intersection of the box and pix.<para/>
	///
	/// (6) An example of use would be to set to a specific color all
	/// the light (background) pixels within a certain region of
	/// a 3-level 2 bpp image, while leaving light pixels outside
	/// this region unchanged.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetSelectCmap/*"/>
	///  <param name="box">[in][optional] - region to set color can be NULL</param>
	///  <param name="sindex">[in] - colormap index of pixels to be changed</param>
	///  <param name="rval">[in] - new color to paint</param>
	///  <param name="gval">[in] - new color to paint</param>
	///  <param name="bval">[in] - new color to paint</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetSelectCmap (int sindex,
							  int rval,
							  int gval,
							  int bval,
							  Box box)
	{
		int RetObj = _All.pixSetSelectCmap(this, box, sindex, rval, gval, bval);
		return RetObj;
	}

	// paintcmap.c (219, 1)
	// pixColorGrayRegionsCmap(pixs, boxa, type, rval, gval, bval) as int
	// pixColorGrayRegionsCmap(PIX *, BOXA *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place operation.<para/>
	///
	/// (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
	/// preserving antialiasing.
	/// If type == L_PAINT_DARK, it colorizes non-white pixels,
	/// preserving antialiasing.  See pixColorGrayCmap() for details.<para/>
	///
	/// (3) This can also be called through pixColorGrayRegions().<para/>
	///
	/// (4) This increases the colormap size by the number of
	/// different gray (non-black or non-white) colors in the
	/// selected regions of pixs.  If there is not enough room in
	/// the colormap for this expansion, it returns 1 (error),
	/// and the caller should check the return value.<para/>
	///
	/// (5) Because two boxes in the boxa can overlap, pixels that
	/// are colorized in the first box must be excluded in the
	/// second because their value exceeds the size of the map.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorGrayRegionsCmap/*"/>
	///  <param name="boxa">[in] - of regions in which to apply color</param>
	///  <param name="type">[in] - L_PAINT_LIGHT, L_PAINT_DARK</param>
	///  <param name="rval">[in] - target color</param>
	///  <param name="gval">[in] - target color</param>
	///  <param name="bval">[in] - target color</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ColorGrayRegionsCmap (Boxa boxa,
									 int type,
									 int rval,
									 int gval,
									 int bval)
	{
		int RetObj = _All.pixColorGrayRegionsCmap(this, boxa, type, rval, gval, bval);
		return RetObj;
	}

	// paintcmap.c (327, 1)
	// pixColorGrayCmap(pixs, box, type, rval, gval, bval) as int
	// pixColorGrayCmap(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place operation.<para/>
	///
	/// (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
	/// preserving antialiasing.
	/// If type == L_PAINT_DARK, it colorizes non-white pixels,
	/// preserving antialiasing.<para/>
	///
	/// (3) box gives the region to apply color if NULL, this
	/// colorizes the entire image.<para/>
	///
	/// (4) If the cmap is only 2 or 4 bpp, pixs is converted in-place
	/// to an 8 bpp cmap.  A 1 bpp cmap is not a valid input pix.<para/>
	///
	/// (5) This can also be called through pixColorGray().<para/>
	///
	/// (6) This operation increases the colormap size by the number of
	/// different gray (non-black or non-white) colors in the
	/// input colormap.  If there is not enough room in the colormap
	/// for this expansion, it returns 1 (error), and the caller
	/// should check the return value.<para/>
	///
	/// (7) Using the darkness of each original pixel in the rect,
	/// it generates a new color (based on the input rgb values).
	/// If type == L_PAINT_LIGHT, the new color is a (generally)
	/// darken-to-black version of the  input rgb color, where the
	/// amount of darkening increases with the darkness of the
	/// original pixel color.
	/// If type == L_PAINT_DARK, the new color is a (generally)
	/// faded-to-white version of the  input rgb color, where the
	/// amount of fading increases with the brightness of the
	/// original pixel color.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorGrayCmap/*"/>
	///  <param name="box">[in][optional] - region to set color can be NULL</param>
	///  <param name="type">[in] - L_PAINT_LIGHT, L_PAINT_DARK</param>
	///  <param name="rval">[in] - target color</param>
	///  <param name="gval">[in] - target color</param>
	///  <param name="bval">[in] - target color</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ColorGrayCmap (int type,
							  int rval,
							  int gval,
							  int bval,
							  Box box)
	{
		int RetObj = _All.pixColorGrayCmap(this, box, type, rval, gval, bval);
		return RetObj;
	}

	// paintcmap.c (395, 1)
	// pixColorGrayMaskedCmap(pixs, pixm, type, rval, gval, bval) as int
	// pixColorGrayMaskedCmap(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place operation.<para/>
	///
	/// (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
	/// preserving antialiasing.
	/// If type == L_PAINT_DARK, it colorizes non-white pixels,
	/// preserving antialiasing.  See pixColorGrayCmap() for details.<para/>
	///
	/// (3) This increases the colormap size by the number of
	/// different gray (non-black or non-white) colors in the
	/// input colormap.  If there is not enough room in the colormap
	/// for this expansion, it returns 1 (error).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorGrayMaskedCmap/*"/>
	///  <param name="pixm">[in] - 1 bpp mask, through which to apply color</param>
	///  <param name="type">[in] - L_PAINT_LIGHT, L_PAINT_DARK</param>
	///  <param name="rval">[in] - target color</param>
	///  <param name="gval">[in] - target color</param>
	///  <param name="bval">[in] - target color</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ColorGrayMaskedCmap (Pix pixm,
									int type,
									int rval,
									int gval,
									int bval)
	{
		int RetObj = _All.pixColorGrayMaskedCmap(this, pixm, type, rval, gval, bval);
		return RetObj;
	}

	// paintcmap.c (583, 1)
	// pixSetSelectMaskedCmap(pixs, pixm, x, y, sindex, rval, gval, bval) as int
	// pixSetSelectMaskedCmap(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place operation.<para/>
	///
	/// (2) This paints through the fg of pixm and replaces all pixels
	/// in pixs that have a particular value (sindex) with the new color.<para/>
	///
	/// (3) If pixm == NULL, a warning is given.<para/>
	///
	/// (4) sindex must be in the existing colormap otherwise an
	/// error is returned.<para/>
	///
	/// (5) If the new color exists in the colormap, it is used
	/// otherwise, it is added to the colormap.  If the colormap
	/// is full, an error is returned.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetSelectMaskedCmap/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask no-op if NULL</param>
	///  <param name="x">[in] - UL corner of mask relative to pixs</param>
	///  <param name="y">[in] - UL corner of mask relative to pixs</param>
	///  <param name="sindex">[in] - colormap index of pixels in pixs to be changed</param>
	///  <param name="rval">[in] - new color to substitute</param>
	///  <param name="gval">[in] - new color to substitute</param>
	///  <param name="bval">[in] - new color to substitute</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetSelectMaskedCmap (int x,
									int y,
									int sindex,
									int rval,
									int gval,
									int bval,
									Pix pixm)
	{
		int RetObj = _All.pixSetSelectMaskedCmap(this, pixm, x, y, sindex, rval, gval, bval);
		return RetObj;
	}

	// paintcmap.c (693, 1)
	// pixSetMaskedCmap(pixs, pixm, x, y, rval, gval, bval) as int
	// pixSetMaskedCmap(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place operation.<para/>
	///
	/// (2) It paints a single color through the mask (as a stencil).<para/>
	///
	/// (3) The mask origin is placed at (x,y) on pixs, and the
	/// operation is clipped to the intersection of the mask and pixs.<para/>
	///
	/// (4) If pixm == NULL, a warning is given.<para/>
	///
	/// (5) Typically, pixm is a small binary mask located somewhere
	/// on the larger pixs.<para/>
	///
	/// (6) If the color is in the colormap, it is used.  Otherwise,
	/// it is added if possible an error is returned if the
	/// colormap is already full.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetMaskedCmap/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask no-op if NULL</param>
	///  <param name="x">[in] - origin of pixm relative to pixs can be negative</param>
	///  <param name="y">[in] - origin of pixm relative to pixs can be negative</param>
	///  <param name="rval">[in] - new color to set at each masked pixel</param>
	///  <param name="gval">[in] - new color to set at each masked pixel</param>
	///  <param name="bval">[in] - new color to set at each masked pixel</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetMaskedCmap (int x,
							  int y,
							  int rval,
							  int gval,
							  int bval,
							  Pix pixm)
	{
		int RetObj = _All.pixSetMaskedCmap(this, pixm, x, y, rval, gval, bval);
		return RetObj;
	}

	// pdfio1.c (1223, 1)
	// pixConvertToPdf(pix, type, quality, fileout, x, y, res, title, plpd, position) as int
	// pixConvertToPdf(PIX *, l_int32, l_int32, const char *, l_int32, l_int32, l_int32, const char *, L_PDF_DATA **, l_int32) as l_ok
	///  <summary>
	/// (1) If %res == 0 and the input resolution field is 0,
	/// this will use DEFAULT_INPUT_RES.<para/>
	///
	/// (2) This only writes data to fileout if it is the last
	/// image to be written on the page.<para/>
	///
	/// (3) See comments in convertToPdf().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertToPdf/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="type">[in] - L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	///  <param name="quality">[in] - used for JPEG only 0 for default (75)</param>
	///  <param name="fileout">[in] - output pdf file only required on last image on page</param>
	///  <param name="x">[in] - location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0 at the lower-left corner of the page)</param>
	///  <param name="y">[in] - location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0 at the lower-left corner of the page)</param>
	///  <param name="res">[in] - override the resolution of the input image, in ppi use 0 to respect the resolution embedded in the input</param>
	///  <param name="title">[in][optional] - pdf title</param>
	///  <param name="plpd">[in,out] - ptr to lpd, which is created on the first invocation and returned until last image is processed</param>
	///  <param name="position">[in] - in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConvertToPdf (Pix pix,
							 int type,
							 String fileout,
							 ref L_Pdf_Data plpd,
							 int position,
							 int quality,
							 int x,
							 int y,
							 int res,
							 String title)
	{
		int RetObj = _All.pixConvertToPdf(pix, type, quality, fileout, x, y, res, title, ref plpd, position);
		return RetObj;
	}

	// pdfio1.c (1286, 1)
	// pixWriteStreamPdf(fp, pix, res, title) as int
	// pixWriteStreamPdf(FILE *, PIX *, l_int32, const char *) as l_ok
	///  <summary>
	/// (1) This is the simplest interface for writing a single image
	/// with pdf encoding to a stream.  It uses G4 encoding for 1 bpp,
	/// JPEG encoding for 8 bpp (no cmap) and 32 bpp, and FLATE
	/// encoding for everything else.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamPdf/*"/>
	///  <param name="fp">[in] - file stream opened for writing</param>
	///  <param name="pix">[in] - all depths, cmap OK</param>
	///  <param name="res">[in] - override the resolution of the input image, in ppi use 0 to respect the resolution embedded in the input</param>
	///  <param name="title">[in][optional] - pdf title taken from the first image placed on a page e.g., an input image filename</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamPdf (FILE fp,
							   Pix pix,
							   int res,
							   String title)
	{
		int RetObj = _All.pixWriteStreamPdf(fp, pix, res, title);
		return RetObj;
	}

	// pdfio1.c (1335, 1)
	// pixWriteMemPdf(pdata, pnbytes, pix, res, title) as int
	// pixWriteMemPdf(l_uint8 **, size_t *, PIX *, l_int32, const char *) as l_ok
	///  <summary>
	/// (1) This is the simplest interface for writing a single image
	/// with pdf encoding to memory.  It uses G4 encoding for 1 bpp,
	/// JPEG encoding for 8 bpp (no cmap) and 32 bpp, and FLATE
	/// encoding for everything else.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMemPdf/*"/>
	///  <param name="pdata">[out] - pdf as byte array</param>
	///  <param name="pnbytes">[out] - number of bytes in pdf array</param>
	///  <param name="pix">[in] - all depths, cmap OK</param>
	///  <param name="res">[in] - override the resolution of the input image, in ppi use 0 to respect the resolution embedded in the input</param>
	///  <param name="title">[in][optional] - pdf title taken from the first image placed on a page e.g., an input image filename</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemPdf (out Byte[] pdata,
							out uint pnbytes,
							Pix pix,
							int res,
							String title)
	{
		int RetObj = _All.pixWriteMemPdf(out pdata, out pnbytes, pix, res, title);
		return RetObj;
	}

	// pdfio1.c (1704, 1)
	// pixConvertToPdfSegmented(pixs, res, type, thresh, boxa, quality, scalefactor, title, fileout) as int
	// pixConvertToPdfSegmented(PIX *, l_int32, l_int32, l_int32, BOXA *, l_int32, l_float32, const char *, const char *) as l_ok
	///  <summary>
	/// (1) See convertToPdfSegmented() for details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertToPdfSegmented/*"/>
	///  <param name="res">[in] - input image resolution typ. 300 ppi use 0 for default</param>
	///  <param name="type">[in] - compression type for non-image regions the image regions are always compressed with L_JPEG_ENCODE</param>
	///  <param name="thresh">[in] - used for converting gray to 1 bpp with L_G4_ENCODE</param>
	///  <param name="boxa">[in][optional] - of image regions can be null</param>
	///  <param name="quality">[in] - used for jpeg image regions 0 for default</param>
	///  <param name="scalefactor">[in] - used for jpeg regions must be smaller or equal 1.0</param>
	///  <param name="title">[in][optional] - pdf title typically taken from the input file for the pix</param>
	///  <param name="fileout">[in] - output pdf file</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConvertToPdfSegmented (int res,
									  int type,
									  int thresh,
									  Single scalefactor,
									  String fileout,
									  Boxa boxa,
									  int quality,
									  String title)
	{
		int RetObj = _All.pixConvertToPdfSegmented(this, res, type, thresh, boxa, quality, scalefactor, title, fileout);
		return RetObj;
	}

	// pdfio1.c (1834, 1)
	// pixConvertToPdfDataSegmented(pixs, res, type, thresh, boxa, quality, scalefactor, title, pdata, pnbytes) as int
	// pixConvertToPdfDataSegmented(PIX *, l_int32, l_int32, l_int32, BOXA *, l_int32, l_float32, const char *, l_uint8 **, size_t *) as l_ok
	///  <summary>
	/// (1) See convertToPdfSegmented() for details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertToPdfDataSegmented/*"/>
	///  <param name="res">[in] - input image resolution typ. 300 ppi use 0 for default</param>
	///  <param name="type">[in] - compression type for non-image regions the image regions are always compressed with L_JPEG_ENCODE</param>
	///  <param name="thresh">[in] - used for converting gray to 1 bpp with L_G4_ENCODE</param>
	///  <param name="boxa">[in][optional] - of image regions can be null</param>
	///  <param name="quality">[in] - used for jpeg image regions 0 for default</param>
	///  <param name="scalefactor">[in] - used for jpeg regions must be smaller or equal 1.0</param>
	///  <param name="title">[in][optional] - pdf title typically taken from the input file for the pix</param>
	///  <param name="pdata">[out] - pdf data in memory</param>
	///  <param name="pnbytes">[out] - number of bytes in pdf data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConvertToPdfDataSegmented (int res,
										  int type,
										  int thresh,
										  Single scalefactor,
										  out Byte[] pdata,
										  out uint pnbytes,
										  Boxa boxa,
										  int quality,
										  String title)
	{
		int RetObj = _All.pixConvertToPdfDataSegmented(this, res, type, thresh, boxa, quality, scalefactor, title, out pdata, out pnbytes);
		return RetObj;
	}

	// pdfio2.c (182, 1)
	// pixConvertToPdfData(pix, type, quality, pdata, pnbytes, x, y, res, title, plpd, position) as int
	// pixConvertToPdfData(PIX *, l_int32, l_int32, l_uint8 **, size_t *, l_int32, l_int32, l_int32, const char *, L_PDF_DATA **, l_int32) as l_ok
	///  <summary>
	/// (1) If %res == 0 and the input resolution field is 0,
	/// this will use DEFAULT_INPUT_RES.<para/>
	///
	/// (2) This only writes %data if it is the last image to be
	/// written on the page.<para/>
	///
	/// (3) See comments in convertToPdf().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertToPdfData/*"/>
	///  <param name="pix">[in] - all depths cmap OK</param>
	///  <param name="type">[in] - L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	///  <param name="quality">[in] - used for JPEG only 0 for default (75)</param>
	///  <param name="pdata">[out] - pdf array</param>
	///  <param name="pnbytes">[out] - number of bytes in pdf array</param>
	///  <param name="x">[in] - location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page)</param>
	///  <param name="y">[in] - location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page)</param>
	///  <param name="res">[in] - override the resolution of the input image, in ppi use 0 to respect the resolution embedded in the input</param>
	///  <param name="title">[in][optional] - pdf title</param>
	///  <param name="plpd">[in,out] - ptr to lpd, which is created on the first invocation and returned until last image is processed</param>
	///  <param name="position">[in] - in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConvertToPdfData (Pix pix,
								 int type,
								 out Byte[] pdata,
								 out uint pnbytes,
								 ref L_Pdf_Data plpd,
								 int position,
								 int quality,
								 int x,
								 int y,
								 int res,
								 String title)
	{
		int RetObj = _All.pixConvertToPdfData(pix, type, quality, out pdata, out pnbytes, x, y, res, title, ref plpd, position);
		return RetObj;
	}

	// pdfio2.c (1039, 1)
	// pixGenerateCIData(pixs, type, quality, ascii85, pcid) as int
	// pixGenerateCIData(PIX *, l_int32, l_int32, l_int32, L_COMP_DATA **) as l_ok
	///  <summary>
	/// (1) Set ascii85:
	/// ~ 0 for binary data (not permitted in PostScript)
	/// ~ 1 for ascii85 (5 for 4) encoded binary data
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenerateCIData/*"/>
	///  <param name="type">[in] - L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	///  <param name="quality">[in] - used for jpeg only 0 for default (75)</param>
	///  <param name="ascii85">[in] - 0 for binary 1 for ascii85-encoded</param>
	///  <param name="pcid">[out] - compressed data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GenerateCIData (int type,
							   int ascii85,
							   out L_Compressed_Data pcid,
							   int quality)
	{
		int RetObj = _All.pixGenerateCIData(this, type, quality, ascii85, out pcid);
		return RetObj;
	}

	// pix1.c (331, 1)
	// pixCreateNoInit(width, height, depth) as Pix
	// pixCreateNoInit(l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Must set pad bits to avoid reading uninitialized data, because
	/// some optimized routines (e.g., pixConnComp()) read from pad bits.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCreateNoInit/*"/>
	///  <param name="width">[in] - </param>
	///  <param name="height">[in] - </param>
	///  <param name="depth">[in] - </param>
	///   <returns>pixd with data allocated but not initialized, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CreateNoInit (int width,
							 int height,
							 int depth)
	{
		Pix RetObj = _All.pixCreateNoInit(width, height, depth);
		return RetObj;
	}

	// pix1.c (397, 1)
	// pixCreateTemplateNoInit(pixs) as Pix
	// pixCreateTemplateNoInit(PIX *) as PIX *
	///  <summary>
	/// (1) Makes a Pix of the same size as the input Pix, with
	/// the data array allocated but not initialized to 0.<para/>
	///
	/// (2) Copies the other fields, including colormap if it exists.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCreateTemplateNoInit/*"/>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CreateTemplateNoInit ()
	{
		Pix RetObj = _All.pixCreateTemplateNoInit(this);
		return RetObj;
	}

	// pix1.c (439, 1)
	// pixCreateHeader(width, height, depth) as Pix
	// pixCreateHeader(l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) It is assumed that all 32 bit pix have 3 spp.  If there is
	/// a valid alpha channel, this will be set to 4 spp later.<para/>
	///
	/// (2) If the number of bytes to be allocated is larger than the
	/// maximum value in an int32, we can get overflow, resulting
	/// in a smaller amount of memory actually being allocated.
	/// Later, an attempt to access memory that wasn't allocated will
	/// cause a crash.  So to avoid crashing a program (or worse)
	/// with bad (or malicious) input, this is where we limit the
	/// requested allocation of image data in a typesafe way.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCreateHeader/*"/>
	///  <param name="width">[in] - </param>
	///  <param name="height">[in] - </param>
	///  <param name="depth">[in] - </param>
	///   <returns>pixd with no data allocated, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CreateHeader (int width,
							 int height,
							 int depth)
	{
		Pix RetObj = _All.pixCreateHeader(width, height, depth);
		return RetObj;
	}

	// pix1.c (517, 1)
	// pixClone(pixs) as Pix
	// pixClone(PIX *) as PIX *
	///  <summary>
	/// (1) A "clone" is simply a handle (ptr) to an existing pix.
	/// It is implemented because (a) images can be large and
	/// hence expensive to copy, and (b) extra handles to a data
	/// structure need to be made with a simple policy to avoid
	/// both double frees and memory leaks.  Pix are reference
	/// counted.  The side effect of pixClone() is an increase
	/// by 1 in the ref count.<para/>
	///
	/// (2) The protocol to be used is:
	/// (a) Whenever you want a new handle to an existing image,
	/// call pixClone(), which just bumps a ref count.
	/// (b) Always call pixDestroy() on all handles.  This
	/// decrements the ref count, nulls the handle, and
	/// only destroys the pix when pixDestroy() has been
	/// called on all handles.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixClone/*"/>
	///   <returns>same pix ptr, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Clone ()
	{
		Pix RetObj = _All.pixClone(this);
		return RetObj;
	}

	// pix1.c (545, 1)
	// pixDestroy(ppix) as Object
	// pixDestroy(PIX **) as void
	///  <summary>
	/// (1) Decrements the ref count and, if 0, destroys the pix.<para/>
	///
	/// (2) Always nulls the input ptr.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDestroy/*"/>
	///  <param name="ppix">[in,out] - will be nulled</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref Pix ppix)
	{
		_All.pixDestroy(ref ppix);
	}

	// pix1.c (630, 1)
	// pixCopy(pixd, pixs) as Pix
	// pixCopy(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) There are three cases:
	/// (a) pixd == null  (makes a new pix refcount = 1)
	/// (b) pixd == pixs  (no-op)
	/// (c) pixd != pixs  (data copy no change in refcount)
	/// If the refcount of pixd  is greater  1, case (c) will side-effect
	/// these handles.<para/>
	///
	/// (2) The general pattern of use is:
	/// pixd = pixCopy(pixd, pixs)
	/// This will work for all three cases.
	/// For clarity when the case is known, you can use:
	/// (a) pixd = pixCopy(NULL, pixs)
	/// (c) pixCopy(pixd, pixs)<para/>
	///
	/// (3) For case (c), we check if pixs and pixd are the same
	/// size (w,h,d).  If so, the data is copied directly.
	/// Otherwise, the data is reallocated to the correct size
	/// and the copy proceeds.  The refcount of pixd is unchanged.<para/>
	///
	/// (4) This operation, like all others that may involve a pre-existing
	/// pixd, will side-effect any existing clones of pixd.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCopy/*"/>
	///  <param name="pixd">[in][optional] - can be null, equal to pixs, different from pixs</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Copy (Pix pixd)
	{
		Pix RetObj = _All.pixCopy(pixd, this);
		return RetObj;
	}

	// pix1.c (698, 1)
	// pixResizeImageData(pixd, pixs) as int
	// pixResizeImageData(PIX *, PIX *) as l_ok
	///  <summary>
	/// (1) If the sizes of data in pixs and pixd are unequal, this
	/// frees the existing image data in pixd and allocates
	/// an uninitialized buffer that will hold the required amount
	/// of image data in pixs.  The image data from pixs is not
	/// copied into the new buffer.<para/>
	///
	/// (2) On failure to allocate, pixd is unchanged.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixResizeImageData/*"/>
	///  <param name="pixd">[in] - gets new uninitialized buffer for image data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ResizeImageData (Pix pixd)
	{
		int RetObj = _All.pixResizeImageData(pixd, this);
		return RetObj;
	}

	// pix1.c (747, 1)
	// pixCopyColormap(pixd, pixs) as int
	// pixCopyColormap(PIX *, PIX *) as l_ok
	///  <summary>
	/// (1) This always destroys any colormap in pixd (except if
	/// the operation is a no-op.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCopyColormap/*"/>
	///  <param name="pixd">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CopyColormap (Pix pixd)
	{
		int RetObj = _All.pixCopyColormap(pixd, this);
		return RetObj;
	}

	// pix1.c (780, 1)
	// pixSizesEqual(pix1, pix2) as int
	// pixSizesEqual(PIX *, PIX *) as l_int32
	///  <summary>
	/// pixSizesEqual()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSizesEqual/*"/>
	///  <param name="pix1">[in] - </param>
	///  <param name="pix2">[in] - </param>
	///   <returns>1 if the two pix have same {h, w, d} 0 otherwise.</returns>
	// CreateAdditiveFunction: Function/Else
	public int SizesEqual (Pix pix1,
						   Pix pix2)
	{
		int RetObj = _All.pixSizesEqual(pix1, pix2);
		return RetObj;
	}

	// pix1.c (854, 1)
	// pixTransferAllData(pixd, ppixs, copytext, copyformat) as int
	// pixTransferAllData(PIX *, PIX **, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This does a complete data transfer from pixs to pixd,
	/// followed by the destruction of pixs (refcount permitting).<para/>
	///
	/// (2) If the refcount of pixs is 1, pixs is destroyed.  Otherwise,
	/// the data in pixs is copied (rather than transferred) to pixd.<para/>
	///
	/// (3) This operation, like all others with a pre-existing pixd,
	/// will side-effect any existing clones of pixd.  The pixd
	/// refcount does not change.<para/>
	///
	/// (4) When might you use this?  Suppose you have an in-place Pix
	/// function (returning void) with the typical signature:
	/// void function-inplace(PIX pix, ...)
	/// where "..." are non-pointer input parameters, and suppose
	/// further that you sometimes want to return an arbitrary Pix
	/// in place of the input Pix.  There are two ways you can do this:
	/// (a) The straightforward way is to change the function
	/// signature to take the address of the Pix ptr:
	/// \code
	/// void function-inplace(PIX ppix, ...) {
	/// PIX pixt = function-makenew(ppix)
	/// pixDestroy(ppix)
	/// ppix = pixt
	/// return
	/// }
	/// \endcode
	/// Here, the input and returned pix are different, as viewed
	/// by the calling function, and the inplace function is
	/// expected to destroy the input pix to avoid a memory leak.
	/// (b) Keep the signature the same and use pixTransferAllData()
	/// to return the new Pix in the input Pix struct:
	/// \code
	/// void function-inplace(PIX pix, ...) {
	/// PIX pixt = function-makenew(pix)
	/// pixTransferAllData(pix, [and]pixt, 0, 0)
	/// // pixDestroy() is called on pixt
	/// return
	/// }
	/// \endcode
	/// Here, the input and returned pix are the same, as viewed
	/// by the calling function, and the inplace function must
	/// never destroy the input pix, because the calling function
	/// maintains an unchanged handle to it.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTransferAllData/*"/>
	///  <param name="pixd">[in] - must be different from pixs</param>
	///  <param name="ppixs">[in,out] - will be nulled if refcount goes to 0</param>
	///  <param name="copytext">[in] - 1 to copy the text field 0 to skip</param>
	///  <param name="copyformat">[in] - 1 to copy the informat field 0 to skip</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int TransferAllData (Pix pixd,
								ref Pix ppixs,
								int copytext,
								int copyformat)
	{
		int RetObj = _All.pixTransferAllData(pixd, ref ppixs, copytext, copyformat);
		return RetObj;
	}

	// pix1.c (944, 1)
	// pixSwapAndDestroy(ppixd, ppixs) as int
	// pixSwapAndDestroy(PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) Simple operation to change the handle name safely.
	/// After this operation, the original image in pixd has
	/// been destroyed, pixd points to what was pixs, and
	/// the input pixs ptr has been nulled.<para/>
	///
	/// (2) This works safely whether or not pixs and pixd are cloned.
	/// If pixs is cloned, the other handles still point to
	/// the original image, with the ref count reduced by 1.<para/>
	///
	/// (3) Usage example:
	/// \code
	/// Pix pix1 = pixRead("...")
	/// Pix pix2 = function(pix1, ...)
	/// pixSwapAndDestroy([and]pix1, [and]pix2)
	/// pixDestroy([and]pix1)  // holds what was in pix2
	/// \endcode
	/// Example with clones ([] shows ref count of image generated
	/// by the function):
	/// \code
	/// Pix pixs = pixRead("...")
	/// Pix pix1 = pixClone(pixs)
	/// Pix pix2 = function(pix1, ...) [1]
	/// Pix pix3 = pixClone(pix2) [1] to [2]
	/// pixSwapAndDestroy([and]pix1, [and]pix2)
	/// pixDestroy([and]pixs)  // still holds read image
	/// pixDestroy([and]pix1)  // holds what was in pix2  [2] to [1]
	/// pixDestroy([and]pix3)  // holds what was in pix2  [1] to [0]
	/// \endcode
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSwapAndDestroy/*"/>
	///  <param name="ppixd">[out][optional] - input pixd can be null, and it must be different from pixs</param>
	///  <param name="ppixs">[in,out] - will be nulled after the swap</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SwapAndDestroy (ref Pix ppixs,
							   out Pix ppixd)
	{
		int RetObj = _All.pixSwapAndDestroy(out ppixd, ref ppixs);
		return RetObj;
	}

	// pix1.c (969, 1)
	// pixGetWidth(pix) as int
	// pixGetWidth(PIX *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetWidth/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetWidth (Pix pix)
	{
		int RetObj = _All.pixGetWidth(pix);
		return RetObj;
	}

	// pix1.c (981, 1)
	// pixSetWidth(pix, width) as int
	// pixSetWidth(PIX *, l_int32) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetWidth/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int SetWidth (Pix pix,
						 int width)
	{
		int RetObj = _All.pixSetWidth(pix, width);
		return RetObj;
	}

	// pix1.c (999, 1)
	// pixGetHeight(pix) as int
	// pixGetHeight(PIX *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetHeight/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetHeight (Pix pix)
	{
		int RetObj = _All.pixGetHeight(pix);
		return RetObj;
	}

	// pix1.c (1011, 1)
	// pixSetHeight(pix, height) as int
	// pixSetHeight(PIX *, l_int32) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetHeight/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int SetHeight (Pix pix,
						  int height)
	{
		int RetObj = _All.pixSetHeight(pix, height);
		return RetObj;
	}

	// pix1.c (1029, 1)
	// pixGetDepth(pix) as int
	// pixGetDepth(PIX *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetDepth/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetDepth (Pix pix)
	{
		int RetObj = _All.pixGetDepth(pix);
		return RetObj;
	}

	// pix1.c (1041, 1)
	// pixSetDepth(pix, depth) as int
	// pixSetDepth(PIX *, l_int32) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetDepth/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int SetDepth (Pix pix,
						 int depth)
	{
		int RetObj = _All.pixSetDepth(pix, depth);
		return RetObj;
	}

	// pix1.c (1064, 1)
	// pixGetDimensions(pix, pw, ph, pd) as int
	// pixGetDimensions(PIX *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixGetDimensions()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetDimensions/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="pw">[out][optional] - each can be null</param>
	///  <param name="ph">[out][optional] - each can be null</param>
	///  <param name="pd">[out][optional] - each can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetDimensions (Pix pix,
							  out int pw,
							  out int ph,
							  out int pd)
	{
		int RetObj = _All.pixGetDimensions(pix, out pw, out ph, out pd);
		return RetObj;
	}

	// pix1.c (1091, 1)
	// pixSetDimensions(pix, w, h, d) as int
	// pixSetDimensions(PIX *, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixSetDimensions()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetDimensions/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="w">[in] - use 0 to skip the setting for any of these</param>
	///  <param name="h">[in] - use 0 to skip the setting for any of these</param>
	///  <param name="d">[in] - use 0 to skip the setting for any of these</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetDimensions (Pix pix,
							  int w,
							  int h,
							  int d)
	{
		int RetObj = _All.pixSetDimensions(pix, w, h, d);
		return RetObj;
	}

	// pix1.c (1115, 1)
	// pixCopyDimensions(pixd, pixs) as int
	// pixCopyDimensions(PIX *, PIX *) as l_ok
	///  <summary>
	/// pixCopyDimensions()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCopyDimensions/*"/>
	///  <param name="pixd">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CopyDimensions (Pix pixd)
	{
		int RetObj = _All.pixCopyDimensions(pixd, this);
		return RetObj;
	}

	// pix1.c (1136, 1)
	// pixGetSpp(pix) as int
	// pixGetSpp(PIX *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetSpp/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetSpp (Pix pix)
	{
		int RetObj = _All.pixGetSpp(pix);
		return RetObj;
	}

	// pix1.c (1164, 1)
	// pixSetSpp(pix, spp) as int
	// pixSetSpp(PIX *, l_int32) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetSpp/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int SetSpp (Pix pix,
					   int spp)
	{
		int RetObj = _All.pixSetSpp(pix, spp);
		return RetObj;
	}

	// pix1.c (1187, 1)
	// pixCopySpp(pixd, pixs) as int
	// pixCopySpp(PIX *, PIX *) as l_ok
	///  <summary>
	/// pixCopySpp()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCopySpp/*"/>
	///  <param name="pixd">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CopySpp (Pix pixd)
	{
		int RetObj = _All.pixCopySpp(pixd, this);
		return RetObj;
	}

	// pix1.c (1205, 1)
	// pixGetWpl(pix) as int
	// pixGetWpl(PIX *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetWpl/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetWpl (Pix pix)
	{
		int RetObj = _All.pixGetWpl(pix);
		return RetObj;
	}

	// pix1.c (1216, 1)
	// pixSetWpl(pix, wpl) as int
	// pixSetWpl(PIX *, l_int32) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetWpl/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int SetWpl (Pix pix,
					   int wpl)
	{
		int RetObj = _All.pixSetWpl(pix, wpl);
		return RetObj;
	}

	// pix1.c (1230, 1)
	// pixGetRefcount(pix) as int
	// pixGetRefcount(PIX *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRefcount/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRefcount (Pix pix)
	{
		int RetObj = _All.pixGetRefcount(pix);
		return RetObj;
	}

	// pix1.c (1241, 1)
	// pixChangeRefcount(pix, delta) as int
	// pixChangeRefcount(PIX *, l_int32) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixChangeRefcount/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int ChangeRefcount (Pix pix,
							   int delta)
	{
		int RetObj = _All.pixChangeRefcount(pix, delta);
		return RetObj;
	}

	// pix1.c (1255, 1)
	// pixGetXRes(pix) as int
	// pixGetXRes(PIX *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetXRes/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetXRes (Pix pix)
	{
		int RetObj = _All.pixGetXRes(pix);
		return RetObj;
	}

	// pix1.c (1266, 1)
	// pixSetXRes(pix, res) as int
	// pixSetXRes(PIX *, l_int32) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetXRes/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int SetXRes (Pix pix,
						int res)
	{
		int RetObj = _All.pixSetXRes(pix, res);
		return RetObj;
	}

	// pix1.c (1280, 1)
	// pixGetYRes(pix) as int
	// pixGetYRes(PIX *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetYRes/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetYRes (Pix pix)
	{
		int RetObj = _All.pixGetYRes(pix);
		return RetObj;
	}

	// pix1.c (1291, 1)
	// pixSetYRes(pix, res) as int
	// pixSetYRes(PIX *, l_int32) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetYRes/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int SetYRes (Pix pix,
						int res)
	{
		int RetObj = _All.pixSetYRes(pix, res);
		return RetObj;
	}

	// pix1.c (1312, 1)
	// pixGetResolution(pix, pxres, pyres) as int
	// pixGetResolution(PIX *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixGetResolution()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetResolution/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="pxres">[out][optional] - each can be null</param>
	///  <param name="pyres">[out][optional] - each can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetResolution (Pix pix,
							  out int pxres,
							  out int pyres)
	{
		int RetObj = _All.pixGetResolution(pix, out pxres, out pyres);
		return RetObj;
	}

	// pix1.c (1338, 1)
	// pixSetResolution(pix, xres, yres) as int
	// pixSetResolution(PIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixSetResolution()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetResolution/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="xres">[in] - use 0 to skip setting a value for either of these</param>
	///  <param name="yres">[in] - use 0 to skip setting a value for either of these</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetResolution (Pix pix,
							  int xres,
							  int yres)
	{
		int RetObj = _All.pixSetResolution(pix, xres, yres);
		return RetObj;
	}

	// pix1.c (1353, 1)
	// pixCopyResolution(pixd, pixs) as int
	// pixCopyResolution(PIX *, PIX *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCopyResolution/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int CopyResolution (Pix pixd)
	{
		int RetObj = _All.pixCopyResolution(pixd, this);
		return RetObj;
	}

	// pix1.c (1372, 1)
	// pixScaleResolution(pix, xscale, yscale) as int
	// pixScaleResolution(PIX *, l_float32, l_float32) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleResolution/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int ScaleResolution (Pix pix,
								Single xscale,
								Single yscale)
	{
		int RetObj = _All.pixScaleResolution(pix, xscale, yscale);
		return RetObj;
	}

	// pix1.c (1390, 1)
	// pixGetInputFormat(pix) as int
	// pixGetInputFormat(PIX *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetInputFormat/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetInputFormat (Pix pix)
	{
		int RetObj = _All.pixGetInputFormat(pix);
		return RetObj;
	}

	// pix1.c (1401, 1)
	// pixSetInputFormat(pix, informat) as int
	// pixSetInputFormat(PIX *, l_int32) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetInputFormat/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int SetInputFormat (Pix pix,
							   IFF informat)
	{
		int RetObj = _All.pixSetInputFormat(pix, informat);
		return RetObj;
	}

	// pix1.c (1414, 1)
	// pixCopyInputFormat(pixd, pixs) as int
	// pixCopyInputFormat(PIX *, PIX *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCopyInputFormat/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int CopyInputFormat (Pix pixd)
	{
		int RetObj = _All.pixCopyInputFormat(pixd, this);
		return RetObj;
	}

	// pix1.c (1432, 1)
	// pixSetSpecial(pix, special) as int
	// pixSetSpecial(PIX *, l_int32) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetSpecial/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int SetSpecial (Pix pix,
						   int special)
	{
		int RetObj = _All.pixSetSpecial(pix, special);
		return RetObj;
	}

	// pix1.c (1457, 1)
	// pixGetText(pix) as String
	// pixGetText(PIX *) as char *
	///  <summary>
	/// (1) The text string belongs to the pix.  The caller must
	/// NOT free it!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetText/*"/>
	///  <param name="pix">[in] - </param>
	///   <returns>ptr to existing text string</returns>
	// CreateAdditiveFunction: Function/Else
	public String GetText (Pix pix)
	{
		String RetObj = _All.pixGetText(pix);
		return RetObj;
	}

	// pix1.c (1481, 1)
	// pixSetText(pix, textstring) as int
	// pixSetText(PIX *, const char *) as l_ok
	///  <summary>
	/// (1) This removes any existing textstring and puts a copy of
	/// the input textstring there.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetText/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="textstring">[in]can be null - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetText (Pix pix,
						String textstring)
	{
		int RetObj = _All.pixSetText(pix, textstring);
		return RetObj;
	}

	// pix1.c (1509, 1)
	// pixAddText(pix, textstring) as int
	// pixAddText(PIX *, const char *) as l_ok
	///  <summary>
	/// (1) This adds the new textstring to any existing text.<para/>
	///
	/// (2) Either or both the existing text and the new text
	/// string can be null.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddText/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="textstring">[in]can be null - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddText (Pix pix,
						String textstring)
	{
		int RetObj = _All.pixAddText(pix, textstring);
		return RetObj;
	}

	// pix1.c (1527, 1)
	// pixCopyText(pixd, pixs) as int
	// pixCopyText(PIX *, PIX *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCopyText/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int CopyText (Pix pixd)
	{
		int RetObj = _All.pixCopyText(pixd, this);
		return RetObj;
	}

	// pix1.c (1592, 1)
	// pixDestroyColormap(pix) as int
	// pixDestroyColormap(PIX *) as l_ok
	///  <summary>
	/// pixDestroyColormap()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDestroyColormap/*"/>
	///  <param name="pix">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int DestroyColormap (Pix pix)
	{
		int RetObj = _All.pixDestroyColormap(pix);
		return RetObj;
	}

	// pix1.c (1622, 1)
	// pixGetData(pix) as Byte[]
	// pixGetData(PIX *) as l_uint32 *
	///  <summary>
	/// (1) This gives a new handle for the data.  The data is still
	/// owned by the pix, so do not call LEPT_FREE() on it.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetData/*"/>
	///  <param name="pix">[in] - </param>
	///   <returns>ptr to image data</returns>
	// CreateAdditiveFunction: Function/Else
	public Byte[] GetData (Pix pix)
	{
		Byte[] RetObj = _All.pixGetData(pix);
		return RetObj;
	}

	// pix1.c (1646, 1)
	// pixSetData(pix, data) as int
	// pixSetData(PIX *, l_uint32 *) as l_int32
	///  <summary>
	/// (1) This does not free any existing data.  To free existing
	/// data, use pixFreeData() before pixSetData().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetData/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="data">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetData (Pix pix,
						Byte[] data)
	{
		int RetObj = _All.pixSetData(pix, data);
		return RetObj;
	}

	// pix1.c (1676, 1)
	// pixExtractData(pixs) as Byte[]
	// pixExtractData(PIX *) as l_uint32 *
	///  <summary>
	/// (1) This extracts the pix image data for use in another context.
	/// The caller still needs to use pixDestroy() on the input pix.<para/>
	///
	/// (2) If refcount == 1, the data is extracted and the
	/// pixtodata ptr is set to NULL.<para/>
	///
	/// (3) If refcount  is greater  1, this simply returns a copy of the data,
	/// using the pix allocator, and leaving the input pix unchanged.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExtractData/*"/>
	///   <returns>ptr to data, or null on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Byte[] ExtractData ()
	{
		Byte[] RetObj = _All.pixExtractData(this);
		return RetObj;
	}

	// pix1.c (1717, 1)
	// pixFreeData(pix) as int
	// pixFreeData(PIX *) as l_int32
	///  <summary>
	/// (1) This frees the data and sets the pix data ptr to null.
	/// It should be used before pixSetData() in the situation where
	/// you want to free any existing data before doing
	/// a subsequent assignment with pixSetData().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFreeData/*"/>
	///  <param name="pix">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FreeData (Pix pix)
	{
		int RetObj = _All.pixFreeData(pix);
		return RetObj;
	}

	// pix1.c (1808, 1)
	// pixGetLinePtrs(pix, psize) as IntPtr[]
	// pixGetLinePtrs(PIX *, l_int32 *) as void **
	///  <summary>
	/// (1) This is intended to be used for fast random pixel access.
	/// For example, for an 8 bpp image,
	/// val = GET_DATA_BYTE(lines8[i], j)
	/// is equivalent to, but much faster than,
	/// pixGetPixel(pix, j, i, [and]val)<para/>
	///
	/// (2) How much faster?  For 1 bpp, it's from 6 to 10x faster.
	/// For 8 bpp, it's an amazing 30x faster.  So if you are
	/// doing random access over a substantial part of the image,
	/// use this line ptr array.<para/>
	///
	/// (3) When random access is used in conjunction with a stack,
	/// queue or heap, the overall computation time depends on
	/// the operations performed on each struct that is popped
	/// or pushed, and whether we are using a priority queue (O(logn))
	/// or a queue or stack (O(1)).  For example, for maze search,
	/// the overall ratio of time for line ptrs vs. pixGet/Set is
	/// Maze type Type   Time ratio
	/// binary  queue   0.4
	/// gray  heap (priority queue) 0.6<para/>
	///
	/// (4) Because this returns a void and the accessors take void,
	/// the compiler cannot check the pointer types.  It is
	/// strongly recommended that you adopt a naming scheme for
	/// the returned ptr arrays that indicates the pixel depth.
	/// (This follows the original intent of Simonyi's "Hungarian"
	/// application notation, where naming is used proactively
	/// to make errors visibly obvious.)  By doing this, you can
	/// tell by inspection if the correct accessor is used.
	/// For example, for an 8 bpp pixg:
	/// void lineg8 = pixGetLinePtrs(pixg, NULL)
	/// val = GET_DATA_BYTE(lineg8[i], j)  // fast access BYTE, 8
	/// ...
	/// LEPT_FREE(lineg8)  // don't forget this<para/>
	///
	/// (5) These are convenient for accessing bytes sequentially in an
	/// 8 bpp grayscale image.  People who write image processing code
	/// on 8 bpp images are accustomed to grabbing pixels directly out
	/// of the raster array.  Note that for little endians, you first
	/// need to reverse the byte order in each 32-bit word.
	/// Here's a typical usage pattern:
	/// pixEndianByteSwap(pix) // always safe no-op on big-endians
	/// l_uint8 lineptrs = (l_uint8 )pixGetLinePtrs(pix, NULL)
	/// pixGetDimensions(pix, [and]w, [and]h, NULL)
	/// for (i = 0 i  is smaller h i++) {
	/// l_uint8 line = lineptrs[i]
	/// for (j = 0 j  is smaller w j++) {
	/// val = line[j]
	/// ...
	/// }
	/// }
	/// pixEndianByteSwap(pix)  // restore big-endian order
	/// LEPT_FREE(lineptrs)
	/// This can be done even more simply as follows:
	/// l_uint8 lineptrs = pixSetupByteProcessing(pix, [and]w, [and]h)
	/// for (i = 0 i  is smaller h i++) {
	/// l_uint8 line = lineptrs[i]
	/// for (j = 0 j  is smaller w j++) {
	/// val = line[j]
	/// ...
	/// }
	/// }
	/// pixCleanupByteProcessing(pix, lineptrs)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetLinePtrs/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="psize">[out][optional] - array size, which is the pix height</param>
	///   <returns>array of line ptrs, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public IntPtr[] GetLinePtrs (Pix pix,
								 out int psize)
	{
		IntPtr[] RetObj = _All.pixGetLinePtrs(pix, out psize);
		return RetObj;
	}

	// pix1.c (1848, 1)
	// pixPrintStreamInfo(fp, pix, text) as int
	// pixPrintStreamInfo(FILE *, PIX *, const char *) as l_ok
	///  <summary>
	/// pixPrintStreamInfo()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixPrintStreamInfo/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="pix">[in] - </param>
	///  <param name="text">[in][optional] - identifying string can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int PrintStreamInfo (FILE fp,
								Pix pix,
								String text)
	{
		int RetObj = _All.pixPrintStreamInfo(fp, pix, text);
		return RetObj;
	}

	// pix2.c (180, 1)
	// pixGetPixel(pix, x, y, pval) as int
	// pixGetPixel(PIX *, l_int32, l_int32, l_uint32 *) as l_ok
	///  <summary>
	/// (1) This returns the value in the data array.  If the pix is
	/// colormapped, it returns the colormap index, not the rgb value.<para/>
	///
	/// (2) Because of the function overhead and the parameter checking,
	/// this is much slower than using the GET_DATA_() macros directly.
	/// Speed on a 1 Mpixel RGB image, using a 3 GHz machine:
	/// pixGet/pixSet: ~25 Mpix/sec
	/// GET_DATA/SET_DATA: ~350 MPix/sec
	/// If speed is important and you're doing random access into
	/// the pix, use pixGetLinePtrs() and the array access macros.<para/>
	///
	/// (3) If the point is outside the image, this returns an error (1),
	/// with 0 in %pval.  To avoid spamming output, it fails silently.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetPixel/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="x">[in] - ,y    pixel coords</param>
	///  <param name="pval">[out] - pixel value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetPixel (Pix pix,
						 int x,
						 int y,
						 out uint pval)
	{
		int RetObj = _All.pixGetPixel(pix, x, y, out pval);
		return RetObj;
	}

	// pix2.c (251, 1)
	// pixSetPixel(pix, x, y, val) as int
	// pixSetPixel(PIX *, l_int32, l_int32, l_uint32) as l_ok
	///  <summary>
	/// (1) Warning: the input value is not checked for overflow with respect
	/// the the depth of %pix, and the sign bit (if any) is ignored.
	/// For d == 1, %val  is greater  0 sets the bit on.
	/// For d == 2, 4, 8 and 16, %val is masked to the maximum allowable
	/// pixel value, and any (invalid) higher order bits are discarded.<para/>
	///
	/// (2) See pixGetPixel() for information on performance.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetPixel/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="x">[in] - ,y   pixel coords</param>
	///  <param name="val">[in] - value to be inserted</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetPixel (Pix pix,
						 int x,
						 int y,
						 uint val)
	{
		int RetObj = _All.pixSetPixel(pix, x, y, val);
		return RetObj;
	}

	// pix2.c (314, 1)
	// pixGetRGBPixel(pix, x, y, prval, pgval, pbval) as int
	// pixGetRGBPixel(PIX *, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixGetRGBPixel()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRGBPixel/*"/>
	///  <param name="pix">[in] - 32 bpp rgb, not colormapped</param>
	///  <param name="x">[in] - ,y    pixel coords</param>
	///  <param name="prval">[out][optional] - red component</param>
	///  <param name="pgval">[out][optional] - green component</param>
	///  <param name="pbval">[out][optional] - blue component</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRGBPixel (Pix pix,
							int x,
							int y,
							out int prval,
							out int pgval,
							out int pbval)
	{
		int RetObj = _All.pixGetRGBPixel(pix, x, y, out prval, out pgval, out pbval);
		return RetObj;
	}

	// pix2.c (362, 1)
	// pixSetRGBPixel(pix, x, y, rval, gval, bval) as int
	// pixSetRGBPixel(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixSetRGBPixel()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetRGBPixel/*"/>
	///  <param name="pix">[in] - 32 bpp rgb</param>
	///  <param name="x">[in] - ,y    pixel coords</param>
	///  <param name="rval">[in] - red component</param>
	///  <param name="gval">[in] - green component</param>
	///  <param name="bval">[in] - blue component</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetRGBPixel (Pix pix,
							int x,
							int y,
							int rval,
							int gval,
							int bval)
	{
		int RetObj = _All.pixSetRGBPixel(pix, x, y, rval, gval, bval);
		return RetObj;
	}

	// pix2.c (409, 1)
	// pixGetRandomPixel(pix, pval, px, py) as int
	// pixGetRandomPixel(PIX *, l_uint32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) If the pix is colormapped, it returns the rgb value.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRandomPixel/*"/>
	///  <param name="pix">[in] - any depth can be colormapped</param>
	///  <param name="pval">[out][optional] - pixel value</param>
	///  <param name="px">[out][optional] - x coordinate chosen can be null</param>
	///  <param name="py">[out][optional] - y coordinate chosen can be null</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRandomPixel (Pix pix,
							   out uint pval,
							   out int px,
							   out int py)
	{
		int RetObj = _All.pixGetRandomPixel(pix, out pval, out px, out py);
		return RetObj;
	}

	// pix2.c (455, 1)
	// pixClearPixel(pix, x, y) as int
	// pixClearPixel(PIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixClearPixel()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixClearPixel/*"/>
	///  <param name="pix">[in] - any depth warning if colormapped</param>
	///  <param name="x">[in] - ,y   pixel coords</param>
	///   <returns>0 if OK 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int ClearPixel (Pix pix,
						   int x,
						   int y)
	{
		int RetObj = _All.pixClearPixel(pix, x, y);
		return RetObj;
	}

	// pix2.c (513, 1)
	// pixFlipPixel(pix, x, y) as int
	// pixFlipPixel(PIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixFlipPixel()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFlipPixel/*"/>
	///  <param name="pix">[in] - any depth, warning if colormapped</param>
	///  <param name="x">[in] - ,y   pixel coords</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FlipPixel (Pix pix,
						  int x,
						  int y)
	{
		int RetObj = _All.pixFlipPixel(pix, x, y);
		return RetObj;
	}

	// pix2.c (648, 1)
	// pixGetBlackOrWhiteVal(pixs, op, pval) as int
	// pixGetBlackOrWhiteVal(PIX *, l_int32, l_uint32 *) as l_ok
	///  <summary>
	/// (1) Side effect.  For a colormapped image, if the requested
	/// color is not present and there is room to add it in the cmap,
	/// it is added and the new index is returned.  If there is no room,
	/// the index of the closest color in intensity is returned.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetBlackOrWhiteVal/*"/>
	///  <param name="op">[in] - L_GET_BLACK_VAL, L_GET_WHITE_VAL</param>
	///  <param name="pval">[out] - pixel value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetBlackOrWhiteVal (int op,
								   out uint pval)
	{
		int RetObj = _All.pixGetBlackOrWhiteVal(this, op, out pval);
		return RetObj;
	}

	// pix2.c (704, 1)
	// pixClearAll(pix) as int
	// pixClearAll(PIX *) as l_ok
	///  <summary>
	/// (1) Clears all data to 0.  For 1 bpp, this is white for grayscale
	/// or color, this is black.<para/>
	///
	/// (2) Caution: for colormapped pix, this sets the color to the first
	/// one in the colormap.  Be sure that this is the intended color!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixClearAll/*"/>
	///  <param name="pix">[in] - all depths use cmapped with caution</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ClearAll (Pix pix)
	{
		int RetObj = _All.pixClearAll(pix);
		return RetObj;
	}

	// pix2.c (733, 1)
	// pixSetAll(pix) as int
	// pixSetAll(PIX *) as l_ok
	///  <summary>
	/// (1) Sets all data to 1.  For 1 bpp, this is black for grayscale
	/// or color, this is white.<para/>
	///
	/// (2) Caution: for colormapped pix, this sets the pixel value to the
	/// maximum value supported by the colormap: 2^d - 1.  However, this
	/// color may not be defined, because the colormap may not be full.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetAll/*"/>
	///  <param name="pix">[in] - all depths use cmapped with caution</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetAll (Pix pix)
	{
		int RetObj = _All.pixSetAll(pix);
		return RetObj;
	}

	// pix2.c (776, 1)
	// pixSetAllGray(pix, grayval) as int
	// pixSetAllGray(PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) N.B.  For all images, %grayval == 0 represents black and
	/// %grayval == 255 represents white.<para/>
	///
	/// (2) For depth  is smaller 8, we do our best to approximate the gray level.
	/// For 1 bpp images, any %grayval  is smaller 128 is black greater or equal 128 is white.
	/// For 32 bpp images, each r,g,b component is set to %grayval,
	/// and the alpha component is preserved.<para/>
	///
	/// (3) If pix is colormapped, it adds the gray value, replicated in
	/// all components, to the colormap if it's not there and there
	/// is room.  If the colormap is full, it finds the closest color in
	/// L2 distance of components.  This index is written to all pixels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetAllGray/*"/>
	///  <param name="pix">[in] - all depths, cmap ok</param>
	///  <param name="grayval">[in] - in range 0 ... 255</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetAllGray (Pix pix,
						   int grayval)
	{
		int RetObj = _All.pixSetAllGray(pix, grayval);
		return RetObj;
	}

	// pix2.c (868, 1)
	// pixSetAllArbitrary(pix, val) as int
	// pixSetAllArbitrary(PIX *, l_uint32) as l_ok
	///  <summary>
	/// (1) Caution 1!  For colormapped pix, %val is used as an index
	/// into a colormap.  Be sure that index refers to the intended color.
	/// If the color is not in the colormap, you should first add it
	/// and then call this function.<para/>
	///
	/// (2) Caution 2!  For 32 bpp pix, the interpretation of the LSB
	/// of %val depends on whether spp == 3 (RGB) or spp == 4 (RGBA).
	/// For RGB, the LSB is ignored in image transformations.
	/// For RGBA, the LSB is interpreted as the alpha (transparency)
	/// component full transparency has alpha == 0x0, whereas
	/// full opacity has alpha = 0xff.  An RGBA image with full
	/// opacity behaves like an RGB image.<para/>
	///
	/// (3) As an example of (2), suppose you want to initialize a 32 bpp
	/// pix with partial opacity, say 0xee337788.  If the pix is 3 spp,
	/// the 0x88 alpha component will be ignored and may be changed
	/// in subsequent processing.  However, if the pix is 4 spp, the
	/// alpha component will be retained and used. The function
	/// pixCreate(w, h, 32) makes an RGB image by default, and
	/// pixSetSpp(pix, 4) can be used to promote an RGB image to RGBA.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetAllArbitrary/*"/>
	///  <param name="pix">[in] - all depths use cmapped with caution</param>
	///  <param name="val">[in] - value to set all pixels</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetAllArbitrary (Pix pix,
								uint val)
	{
		int RetObj = _All.pixSetAllArbitrary(pix, val);
		return RetObj;
	}

	// pix2.c (938, 1)
	// pixSetBlackOrWhite(pixs, op) as int
	// pixSetBlackOrWhite(PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) Function for setting all pixels in an image to either black
	/// or white.<para/>
	///
	/// (2) If pixs is colormapped, it adds black or white to the
	/// colormap if it's not there and there is room.  If the colormap
	/// is full, it finds the closest color in intensity.
	/// This index is written to all pixels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetBlackOrWhite/*"/>
	///  <param name="op">[in] - L_SET_BLACK, L_SET_WHITE</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetBlackOrWhite (int op)
	{
		int RetObj = _All.pixSetBlackOrWhite(this, op);
		return RetObj;
	}

	// pix2.c (985, 1)
	// pixSetComponentArbitrary(pix, comp, val) as int
	// pixSetComponentArbitrary(PIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) For example, this can be used to set the alpha component to opaque:
	/// pixSetComponentArbitrary(pix, L_ALPHA_CHANNEL, 255)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetComponentArbitrary/*"/>
	///  <param name="pix">[in] - 32 bpp</param>
	///  <param name="comp">[in] - COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL</param>
	///  <param name="val">[in] - value to set this component</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetComponentArbitrary (Pix pix,
									  int comp,
									  int val)
	{
		int RetObj = _All.pixSetComponentArbitrary(pix, comp, val);
		return RetObj;
	}

	// pix2.c (1035, 1)
	// pixClearInRect(pix, box) as int
	// pixClearInRect(PIX *, BOX *) as l_ok
	///  <summary>
	/// (1) Clears all data in rect to 0.  For 1 bpp, this is white
	/// for grayscale or color, this is black.<para/>
	///
	/// (2) Caution: for colormapped pix, this sets the color to the first
	/// one in the colormap.  Be sure that this is the intended color!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixClearInRect/*"/>
	///  <param name="pix">[in] - all depths can be cmapped</param>
	///  <param name="box">[in] - in which all pixels will be cleared</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ClearInRect (Pix pix,
							Box box)
	{
		int RetObj = _All.pixClearInRect(pix, box);
		return RetObj;
	}

	// pix2.c (1070, 1)
	// pixSetInRect(pix, box) as int
	// pixSetInRect(PIX *, BOX *) as l_ok
	///  <summary>
	/// (1) Sets all data in rect to 1.  For 1 bpp, this is black
	/// for grayscale or color, this is white.<para/>
	///
	/// (2) Caution: for colormapped pix, this sets the pixel value to the
	/// maximum value supported by the colormap: 2^d - 1.  However, this
	/// color may not be defined, because the colormap may not be full.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetInRect/*"/>
	///  <param name="pix">[in] - all depths, can be cmapped</param>
	///  <param name="box">[in] - in which all pixels will be set</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetInRect (Pix pix,
						  Box box)
	{
		int RetObj = _All.pixSetInRect(pix, box);
		return RetObj;
	}

	// pix2.c (1112, 1)
	// pixSetInRectArbitrary(pix, box, val) as int
	// pixSetInRectArbitrary(PIX *, BOX *, l_uint32) as l_ok
	///  <summary>
	/// (1) For colormapped pix, be sure the value is the intended
	/// one in the colormap.<para/>
	///
	/// (2) Caution: for colormapped pix, this sets each pixel in the
	/// rect to the color at the index equal to val.  Be sure that
	/// this index exists in the colormap and that it is the intended one!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetInRectArbitrary/*"/>
	///  <param name="pix">[in] - all depths can be cmapped</param>
	///  <param name="box">[in] - in which all pixels will be set to val</param>
	///  <param name="val">[in] - value to set all pixels</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetInRectArbitrary (Pix pix,
								   Box box,
								   uint val)
	{
		int RetObj = _All.pixSetInRectArbitrary(pix, box, val);
		return RetObj;
	}

	// pix2.c (1213, 1)
	// pixBlendInRect(pixs, box, val, fract) as int
	// pixBlendInRect(PIX *, BOX *, l_uint32, l_float32) as l_ok
	///  <summary>
	/// (1) This is an in-place function.  It blends the input color %val
	/// with the pixels in pixs in the specified rectangle.
	/// If no rectangle is specified, it blends over the entire image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixBlendInRect/*"/>
	///  <param name="box">[in][optional] - in which all pixels will be blended</param>
	///  <param name="val">[in] - blend value 0xrrggbb00</param>
	///  <param name="fract">[in] - fraction of color to be blended with each pixel in pixs</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int BlendInRect (uint val,
							Single fract,
							Box box)
	{
		int RetObj = _All.pixBlendInRect(this, box, val, fract);
		return RetObj;
	}

	// pix2.c (1299, 1)
	// pixSetPadBits(pix, val) as int
	// pixSetPadBits(PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) The pad bits are the bits that expand each scanline to a
	/// multiple of 32 bits.  They are usually not used in
	/// image processing operations.  When boundary conditions
	/// are important, as in seedfill, they must be set properly.<para/>
	///
	/// (2) This sets the value of the pad bits (if any) in the last
	/// 32-bit word in each scanline.<para/>
	///
	/// (3) For 32 bpp pix, there are no pad bits, so this is a no-op.<para/>
	///
	/// (4) When writing formatted output, such as tiff, png or jpeg,
	/// the pad bits have no effect on the raster image that is
	/// generated by reading back from the file.  However, in some
	/// cases, the compressed file itself will depend on the pad
	/// bits.  This is seen, for example, in Windows with 2 and 4 bpp
	/// tiff-compressed images that have pad bits on each scanline.
	/// It is sometimes convenient to use a golden file with a
	/// byte-by-byte check to verify invariance.  Consequently,
	/// and because setting the pad bits is cheap, the pad bits are
	/// set to 0 before writing these compressed files.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetPadBits/*"/>
	///  <param name="pix">[in] - 1, 2, 4, 8, 16, 32 bpp</param>
	///  <param name="val">[in] - 0 or 1</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetPadBits (Pix pix,
						   int val)
	{
		int RetObj = _All.pixSetPadBits(pix, val);
		return RetObj;
	}

	// pix2.c (1359, 1)
	// pixSetPadBitsBand(pix, by, bh, val) as int
	// pixSetPadBitsBand(PIX *, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) The pad bits are the bits that expand each scanline to a
	/// multiple of 32 bits.  They are usually not used in
	/// image processing operations.  When boundary conditions
	/// are important, as in seedfill, they must be set properly.<para/>
	///
	/// (2) This sets the value of the pad bits (if any) in the last
	/// 32-bit word in each scanline, within the specified
	/// band of raster lines.<para/>
	///
	/// (3) For 32 bpp pix, there are no pad bits, so this is a no-op.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetPadBitsBand/*"/>
	///  <param name="pix">[in] - 1, 2, 4, 8, 16, 32 bpp</param>
	///  <param name="by">[in] - starting y value of band</param>
	///  <param name="bh">[in] - height of band</param>
	///  <param name="val">[in] - 0 or 1</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetPadBitsBand (Pix pix,
							   int by,
							   int bh,
							   int val)
	{
		int RetObj = _All.pixSetPadBitsBand(pix, by, bh, val);
		return RetObj;
	}

	// pix2.c (1431, 1)
	// pixSetOrClearBorder(pixs, left, right, top, bot, op) as int
	// pixSetOrClearBorder(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) The border region is defined to be the region in the
	/// image within a specific distance of each edge.  Here, we
	/// allow the pixels within a specified distance of each
	/// edge to be set independently.  This either sets or
	/// clears all pixels in the border region.<para/>
	///
	/// (2) For binary images, use PIX_SET for black and PIX_CLR for white.<para/>
	///
	/// (3) For grayscale or color images, use PIX_SET for white
	/// and PIX_CLR for black.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetOrClearBorder/*"/>
	///  <param name="left">[in] - right, top, bot amount to set or clear</param>
	///  <param name="op">[in] - operation PIX_SET or PIX_CLR</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetOrClearBorder (int left,
								 int right,
								 int top,
								 int bot,
								 int op)
	{
		int RetObj = _All.pixSetOrClearBorder(this, left, right, top, bot, op);
		return RetObj;
	}

	// pix2.c (1480, 1)
	// pixSetBorderVal(pixs, left, right, top, bot, val) as int
	// pixSetBorderVal(PIX *, l_int32, l_int32, l_int32, l_int32, l_uint32) as l_ok
	///  <summary>
	/// (1) The border region is defined to be the region in the
	/// image within a specific distance of each edge.  Here, we
	/// allow the pixels within a specified distance of each
	/// edge to be set independently.  This sets the pixels
	/// in the border region to the given input value.<para/>
	///
	/// (2) For efficiency, use pixSetOrClearBorder() if
	/// you're setting the border to either black or white.<para/>
	///
	/// (3) If d != 32, the input value should be masked off
	/// to the appropriate number of least significant bits.<para/>
	///
	/// (4) The code is easily generalized for 2 or 4 bpp.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetBorderVal/*"/>
	///  <param name="left">[in] - amount to set</param>
	///  <param name="right">[in] - amount to set</param>
	///  <param name="top">[in] - amount to set</param>
	///  <param name="bot">[in] - amount to set</param>
	///  <param name="val">[in] - value to set at each border pixel</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetBorderVal (int left,
							 int right,
							 int top,
							 int bot,
							 uint val)
	{
		int RetObj = _All.pixSetBorderVal(this, left, right, top, bot, val);
		return RetObj;
	}

	// pix2.c (1584, 1)
	// pixSetBorderRingVal(pixs, dist, val) as int
	// pixSetBorderRingVal(PIX *, l_int32, l_uint32) as l_ok
	///  <summary>
	/// (1) The rings are single-pixel-wide rectangular sets of
	/// pixels at a given distance from the edge of the pix.
	/// This sets all pixels in a given ring to a value.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetBorderRingVal/*"/>
	///  <param name="dist">[in] - distance from outside must be  is greater  0 first ring is 1</param>
	///  <param name="val">[in] - value to set at each border pixel</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetBorderRingVal (int dist,
								 uint val)
	{
		int RetObj = _All.pixSetBorderRingVal(this, dist, val);
		return RetObj;
	}

	// pix2.c (1635, 1)
	// pixSetMirroredBorder(pixs, left, right, top, bot) as int
	// pixSetMirroredBorder(PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This applies what is effectively mirror boundary conditions
	/// to a border region in the image.  It is in-place.<para/>
	///
	/// (2) This is useful for setting pixels near the border to a
	/// value representative of the near pixels to the interior.<para/>
	///
	/// (3) The general pixRasterop() is used for an in-place operation here
	/// because there is no overlap between the src and dest rectangles.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetMirroredBorder/*"/>
	///  <param name="left">[in] - number of pixels to set</param>
	///  <param name="right">[in] - number of pixels to set</param>
	///  <param name="top">[in] - number of pixels to set</param>
	///  <param name="bot">[in] - number of pixels to set</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetMirroredBorder (int left,
								  int right,
								  int top,
								  int bot)
	{
		int RetObj = _All.pixSetMirroredBorder(this, left, right, top, bot);
		return RetObj;
	}

	// pix2.c (1686, 1)
	// pixCopyBorder(pixd, pixs, left, right, top, bot) as Pix
	// pixCopyBorder(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) pixd can be null, but otherwise it must be the same size
	/// and depth as pixs.  Always returns pixd.<para/>
	///
	/// (2) This is useful in situations where by setting a few border
	/// pixels we can avoid having to copy all pixels in pixs into
	/// pixd as an initialization step for some operation.
	/// Nevertheless, for safety, if making a new pixd, all the
	/// non-border pixels are initialized to 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCopyBorder/*"/>
	///  <param name="pixd">[in] - all depths colormap ok can be NULL</param>
	///  <param name="left">[in] - number of pixels to copy</param>
	///  <param name="right">[in] - number of pixels to copy</param>
	///  <param name="top">[in] - number of pixels to copy</param>
	///  <param name="bot">[in] - number of pixels to copy</param>
	///   <returns>pixd, or NULL on error if pixd is not defined</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CopyBorder (Pix pixd,
						   int left,
						   int right,
						   int top,
						   int bot)
	{
		Pix RetObj = _All.pixCopyBorder(pixd, this, left, right, top, bot);
		return RetObj;
	}

	// pix2.c (1740, 1)
	// pixAddBorder(pixs, npix, val) as Pix
	// pixAddBorder(PIX *, l_int32, l_uint32) as PIX *
	///  <summary>
	/// (1) See pixGetBlackOrWhiteVal() for values of black and white pixels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddBorder/*"/>
	///  <param name="npix">[in] - number of pixels to be added to each side</param>
	///  <param name="val">[in] - value of added border pixels</param>
	///   <returns>pixd with the added exterior pixels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddBorder (int npix,
						  uint val)
	{
		Pix RetObj = _All.pixAddBorder(this, npix, val);
		return RetObj;
	}

	// pix2.c (1780, 1)
	// pixAddBlackOrWhiteBorder(pixs, left, right, top, bot, op) as Pix
	// pixAddBlackOrWhiteBorder(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See pixGetBlackOrWhiteVal() for possible side effect (adding
	/// a color to a colormap).<para/>
	///
	/// (2) The only complication is that pixs may have a colormap.
	/// There are two ways to add the black or white border:
	/// (a) As done here (simplest, most efficient)
	/// (b) l_int32 ws, hs, d
	/// pixGetDimensions(pixs, [and]ws, [and]hs, [and]d)
	/// Pix pixd = pixCreate(ws + left + right, hs + top + bot, d)
	/// PixColormap cmap = pixGetColormap(pixs)
	/// if (cmap != NULL)
	/// pixSetColormap(pixd, pixcmapCopy(cmap))
	/// pixSetBlackOrWhite(pixd, L_SET_WHITE)  // uses cmap
	/// pixRasterop(pixd, left, top, ws, hs, PIX_SET, pixs, 0, 0)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddBlackOrWhiteBorder/*"/>
	///  <param name="left">[in] - number of pixels added</param>
	///  <param name="right">[in] - number of pixels added</param>
	///  <param name="top">[in] - number of pixels added</param>
	///  <param name="bot">[in] - number of pixels added</param>
	///  <param name="op">[in] - L_GET_BLACK_VAL, L_GET_WHITE_VAL</param>
	///   <returns>pixd with the added exterior pixels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddBlackOrWhiteBorder (int left,
									  int right,
									  int top,
									  int bot,
									  int op)
	{
		Pix RetObj = _All.pixAddBlackOrWhiteBorder(this, left, right, top, bot, op);
		return RetObj;
	}

	// pix2.c (1834, 1)
	// pixAddBorderGeneral(pixs, left, right, top, bot, val) as Pix
	// pixAddBorderGeneral(PIX *, l_int32, l_int32, l_int32, l_int32, l_uint32) as PIX *
	///  <summary>
	/// (1) For binary images:
	/// white:  val = 0
	/// black:  val = 1
	/// For grayscale images:
	/// white:  val = 2  d - 1
	/// black:  val = 0
	/// For rgb color images:
	/// white:  val = 0xffffff00
	/// black:  val = 0
	/// For colormapped images, set val to the appropriate colormap index.<para/>
	///
	/// (2) If the added border is either black or white, you can use
	/// pixAddBlackOrWhiteBorder()
	/// The black and white values for all images can be found with
	/// pixGetBlackOrWhiteVal()
	/// which, if pixs is cmapped, may add an entry to the colormap.
	/// Alternatively, if pixs has a colormap, you can find the index
	/// of the pixel whose intensity is closest to white or black:
	/// white: pixcmapGetRankIntensity(cmap, 1.0, [and]index)
	/// black: pixcmapGetRankIntensity(cmap, 0.0, [and]index)
	/// and use that for val.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddBorderGeneral/*"/>
	///  <param name="left">[in] - number of pixels added</param>
	///  <param name="right">[in] - number of pixels added</param>
	///  <param name="top">[in] - number of pixels added</param>
	///  <param name="bot">[in] - number of pixels added</param>
	///  <param name="val">[in] - value of added border pixels</param>
	///   <returns>pixd with the added exterior pixels, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddBorderGeneral (int left,
								 int right,
								 int top,
								 int bot,
								 uint val)
	{
		Pix RetObj = _All.pixAddBorderGeneral(this, left, right, top, bot, val);
		return RetObj;
	}

	// pix2.c (1889, 1)
	// pixRemoveBorder(pixs, npix) as Pix
	// pixRemoveBorder(PIX *, l_int32) as PIX *
	///  <summary>
	/// pixRemoveBorder()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRemoveBorder/*"/>
	///  <param name="npix">[in] - number to be removed from each of the 4 sides</param>
	///   <returns>pixd with pixels removed around border, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RemoveBorder (int npix)
	{
		Pix RetObj = _All.pixRemoveBorder(this, npix);
		return RetObj;
	}

	// pix2.c (1910, 1)
	// pixRemoveBorderGeneral(pixs, left, right, top, bot) as Pix
	// pixRemoveBorderGeneral(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixRemoveBorderGeneral()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRemoveBorderGeneral/*"/>
	///  <param name="left">[in] - number of pixels removed</param>
	///  <param name="right">[in] - number of pixels removed</param>
	///  <param name="top">[in] - number of pixels removed</param>
	///  <param name="bot">[in] - number of pixels removed</param>
	///   <returns>pixd with pixels removed around border, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RemoveBorderGeneral (int left,
									int right,
									int top,
									int bot)
	{
		Pix RetObj = _All.pixRemoveBorderGeneral(this, left, right, top, bot);
		return RetObj;
	}

	// pix2.c (1963, 1)
	// pixRemoveBorderToSize(pixs, wd, hd) as Pix
	// pixRemoveBorderToSize(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Removes pixels as evenly as possible from the sides of the
	/// image, leaving the central part.<para/>
	///
	/// (2) Returns clone if no pixels requested removed, or the target
	/// sizes are larger than the image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRemoveBorderToSize/*"/>
	///  <param name="wd">[in] - target width use 0 if only removing from height</param>
	///  <param name="hd">[in] - target height use 0 if only removing from width</param>
	///   <returns>pixd with pixels removed around border, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RemoveBorderToSize (int wd,
								   int hd)
	{
		Pix RetObj = _All.pixRemoveBorderToSize(this, wd, hd);
		return RetObj;
	}

	// pix2.c (2018, 1)
	// pixAddMirroredBorder(pixs, left, right, top, bot) as Pix
	// pixAddMirroredBorder(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This applies what is effectively mirror boundary conditions.
	/// For the added border pixels in pixd, the pixels in pixs
	/// near the border are mirror-copied into the border region.<para/>
	///
	/// (2) This is useful for avoiding special operations near
	/// boundaries when doing image processing operations
	/// such as rank filters and convolution.  In use, one first
	/// adds mirrored pixels to each side of the image.  The number
	/// of pixels added on each side is half the filter dimension.
	/// Then the image processing operations proceed over a
	/// region equal to the size of the original image, and
	/// write directly into a dest pix of the same size as pixs.<para/>
	///
	/// (3) The general pixRasterop() is used for an in-place operation here
	/// because there is no overlap between the src and dest rectangles.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddMirroredBorder/*"/>
	///  <param name="left">[in] - number of pixels added</param>
	///  <param name="right">[in] - number of pixels added</param>
	///  <param name="top">[in] - number of pixels added</param>
	///  <param name="bot">[in] - number of pixels added</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddMirroredBorder (int left,
								  int right,
								  int top,
								  int bot)
	{
		Pix RetObj = _All.pixAddMirroredBorder(this, left, right, top, bot);
		return RetObj;
	}

	// pix2.c (2071, 1)
	// pixAddRepeatedBorder(pixs, left, right, top, bot) as Pix
	// pixAddRepeatedBorder(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This applies a repeated border, as if the central part of
	/// the image is tiled over the plane.  So, for example, the
	/// pixels in the left border come from the right side of the image.<para/>
	///
	/// (2) The general pixRasterop() is used for an in-place operation here
	/// because there is no overlap between the src and dest rectangles.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddRepeatedBorder/*"/>
	///  <param name="left">[in] - number of pixels added</param>
	///  <param name="right">[in] - number of pixels added</param>
	///  <param name="top">[in] - number of pixels added</param>
	///  <param name="bot">[in] - number of pixels added</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddRepeatedBorder (int left,
								  int right,
								  int top,
								  int bot)
	{
		Pix RetObj = _All.pixAddRepeatedBorder(this, left, right, top, bot);
		return RetObj;
	}

	// pix2.c (2127, 1)
	// pixAddMixedBorder(pixs, left, right, top, bot) as Pix
	// pixAddMixedBorder(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This applies mirrored boundary conditions horizontally
	/// and repeated b.c. vertically.<para/>
	///
	/// (2) It is specifically used for avoiding special operations
	/// near boundaries when convolving a hue-saturation histogram
	/// with a given window size.  The repeated b.c. are used
	/// vertically for hue, and the mirrored b.c. are used
	/// horizontally for saturation.  The number of pixels added
	/// on each side is approximately (but not quite) half the
	/// filter dimension.  The image processing operations can
	/// then proceed over a region equal to the size of the original
	/// image, and write directly into a dest pix of the same
	/// size as pixs.<para/>
	///
	/// (3) The general pixRasterop() can be used for an in-place
	/// operation here because there is no overlap between the
	/// src and dest rectangles.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddMixedBorder/*"/>
	///  <param name="left">[in] - number of pixels added</param>
	///  <param name="right">[in] - number of pixels added</param>
	///  <param name="top">[in] - number of pixels added</param>
	///  <param name="bot">[in] - number of pixels added</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddMixedBorder (int left,
							   int right,
							   int top,
							   int bot)
	{
		Pix RetObj = _All.pixAddMixedBorder(this, left, right, top, bot);
		return RetObj;
	}

	// pix2.c (2174, 1)
	// pixAddContinuedBorder(pixs, left, right, top, bot) as Pix
	// pixAddContinuedBorder(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This adds pixels on each side whose values are equal to
	/// the value on the closest boundary pixel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddContinuedBorder/*"/>
	///  <param name="left">[in] - pixels on each side to be added</param>
	///  <param name="right">[in] - pixels on each side to be added</param>
	///  <param name="top">[in] - pixels on each side to be added</param>
	///  <param name="bot">[in] - pixels on each side to be added</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddContinuedBorder (int left,
								   int right,
								   int top,
								   int bot)
	{
		Pix RetObj = _All.pixAddContinuedBorder(this, left, right, top, bot);
		return RetObj;
	}

	// pix2.c (2217, 1)
	// pixShiftAndTransferAlpha(pixd, pixs, shiftx, shifty) as int
	// pixShiftAndTransferAlpha(PIX *, PIX *, l_float32, l_float32) as l_ok
	///  <summary>
	/// pixShiftAndTransferAlpha()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixShiftAndTransferAlpha/*"/>
	///  <param name="pixd">[in] - 32 bpp</param>
	///  <param name="shiftx">[in] - </param>
	///  <param name="shifty">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ShiftAndTransferAlpha (Pix pixd,
									  Single shiftx,
									  Single shifty)
	{
		int RetObj = _All.pixShiftAndTransferAlpha(pixd, this, shiftx, shifty);
		return RetObj;
	}

	// pix2.c (2268, 1)
	// pixDisplayLayersRGBA(pixs, val, maxw) as Pix
	// pixDisplayLayersRGBA(PIX *, l_uint32, l_int32) as PIX *
	///  <summary>
	/// (1) Use %val == 0xffffff00 for white background.<para/>
	///
	/// (2) Three views are given:
	/// ~ the image with a fully opaque alpha
	/// ~ the alpha layer
	/// ~ the image as it would appear with a white background.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDisplayLayersRGBA/*"/>
	///  <param name="val">[in] - 32 bit unsigned color to use as background</param>
	///  <param name="maxw">[in] - max output image width 0 for no scaling</param>
	///   <returns>pixd showing various image views, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayLayersRGBA (uint val,
								  int maxw)
	{
		Pix RetObj = _All.pixDisplayLayersRGBA(this, val, maxw);
		return RetObj;
	}

	// pix2.c (2340, 1)
	// pixCreateRGBImage(pixr, pixg, pixb) as Pix
	// pixCreateRGBImage(PIX *, PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) the 4th byte, sometimes called the "alpha channel",
	/// and which is often used for blending between different
	/// images, is left with 0 value.<para/>
	///
	/// (2) see Note (4) in pix.h for details on storage of
	/// 8-bit samples within each 32-bit word.<para/>
	///
	/// (3) This implementation, setting the r, g and b components
	/// sequentially, is much faster than setting them in parallel
	/// by constructing an RGB dest pixel and writing it to dest.
	/// The reason is there are many more cache misses when reading
	/// from 3 input images simultaneously.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCreateRGBImage/*"/>
	///  <param name="pixr">[in] - 8 bpp red pix</param>
	///  <param name="pixg">[in] - 8 bpp green pix</param>
	///  <param name="pixb">[in] - 8 bpp blue pix</param>
	///   <returns>32 bpp pix, interleaved with 4 samples/pixel, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CreateRGBImage (Pix pixr,
							   Pix pixg,
							   Pix pixb)
	{
		Pix RetObj = _All.pixCreateRGBImage(pixr, pixg, pixb);
		return RetObj;
	}

	// pix2.c (2396, 1)
	// pixGetRGBComponent(pixs, comp) as Pix
	// pixGetRGBComponent(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Three calls to this function generate the r, g and b 8 bpp
	/// component images.  This is much faster than generating the
	/// three images in parallel, by extracting a src pixel and setting
	/// the pixels of each component image from it.  The reason is
	/// there are many more cache misses when writing to three
	/// output images simultaneously.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRGBComponent/*"/>
	///  <param name="comp">[in] - one of {COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL}</param>
	///   <returns>pixd the selected 8 bpp component image of the input 32 bpp image or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GetRGBComponent (int comp)
	{
		Pix RetObj = _All.pixGetRGBComponent(this, comp);
		return RetObj;
	}

	// pix2.c (2455, 1)
	// pixSetRGBComponent(pixd, pixs, comp) as int
	// pixSetRGBComponent(PIX *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) This places the 8 bpp pixel in pixs into the
	/// specified component (properly interleaved) in pixd,<para/>
	///
	/// (2) The two images are registered to the UL corner the sizes
	/// need not be the same, but a warning is issued if they differ.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetRGBComponent/*"/>
	///  <param name="pixd">[in] - 32 bpp</param>
	///  <param name="comp">[in] - one of the set: {COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL}</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetRGBComponent (Pix pixd,
								int comp)
	{
		int RetObj = _All.pixSetRGBComponent(pixd, this, comp);
		return RetObj;
	}

	// pix2.c (2517, 1)
	// pixGetRGBComponentCmap(pixs, comp) as Pix
	// pixGetRGBComponentCmap(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) In leptonica, we do not support alpha in colormaps.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRGBComponentCmap/*"/>
	///  <param name="comp">[in] - one of the set: {COLOR_RED, COLOR_GREEN, COLOR_BLUE}</param>
	///   <returns>pixd  the selected 8 bpp component image of the input cmapped image, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GetRGBComponentCmap (int comp)
	{
		Pix RetObj = _All.pixGetRGBComponentCmap(this, comp);
		return RetObj;
	}

	// pix2.c (2602, 1)
	// pixCopyRGBComponent(pixd, pixs, comp) as int
	// pixCopyRGBComponent(PIX *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) The two images are registered to the UL corner.  The sizes
	/// are usually the same, and a warning is issued if they differ.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCopyRGBComponent/*"/>
	///  <param name="pixd">[in] - 32 bpp</param>
	///  <param name="comp">[in] - one of the set: {COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL}</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CopyRGBComponent (Pix pixd,
								 int comp)
	{
		int RetObj = _All.pixCopyRGBComponent(pixd, this, comp);
		return RetObj;
	}

	// pix2.c (2808, 1)
	// pixGetRGBLine(pixs, row, bufr, bufg, bufb) as int
	// pixGetRGBLine(PIX *, l_int32, l_uint8 *, l_uint8 *, l_uint8 *) as l_ok
	///  <summary>
	/// (1) This puts rgb components from the input line in pixs
	/// into the given buffers.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRGBLine/*"/>
	///  <param name="row">[in] - </param>
	///  <param name="bufr">[in] - array of red samples size w bytes</param>
	///  <param name="bufg">[in] - array of green samples size w bytes</param>
	///  <param name="bufb">[in] - array of blue samples size w bytes</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRGBLine (int row,
						   Byte[] bufr,
						   Byte[] bufg,
						   Byte[] bufb)
	{
		int RetObj = _All.pixGetRGBLine(this, row, bufr, bufg, bufb);
		return RetObj;
	}

	// pix2.c (2871, 1)
	// pixEndianByteSwapNew(pixs) as Pix
	// pixEndianByteSwapNew(PIX *) as PIX *
	///  <summary>
	/// (1) This is used to convert the data in a pix to a
	/// serialized byte buffer in raster order, and, for RGB,
	/// in order RGBA.  This requires flipping bytes within
	/// each 32-bit word for little-endian platforms, because the
	/// words have a MSB-to-the-left rule, whereas byte raster-order
	/// requires the left-most byte in each word to be byte 0.
	/// For big-endians, no swap is necessary, so this returns a clone.<para/>
	///
	/// (2) Unlike pixEndianByteSwap(), which swaps the bytes in-place,
	/// this returns a new pix (or a clone).  We provide this
	/// because often when serialization is done, the source
	/// pix needs to be restored to canonical little-endian order,
	/// and this requires a second byte swap.  In such a situation,
	/// it is twice as fast to make a new pix in big-endian order,
	/// use it, and destroy it.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixEndianByteSwapNew/*"/>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix EndianByteSwapNew ()
	{
		Pix RetObj = _All.pixEndianByteSwapNew(this);
		return RetObj;
	}

	// pix2.c (2934, 1)
	// pixEndianByteSwap(pixs) as int
	// pixEndianByteSwap(PIX *) as l_ok
	///  <summary>
	/// (1) This is used on little-endian platforms to swap
	/// the bytes within a word bytes 0 and 3 are swapped,
	/// and bytes 1 and 2 are swapped.<para/>
	///
	/// (2) This is required for little-endians in situations
	/// where we convert from a serialized byte order that is
	/// in raster order, as one typically has in file formats,
	/// to one with MSB-to-the-left in each 32-bit word, or v.v.
	/// See pix.h for a description of the canonical format
	/// (MSB-to-the left) that is used for both little-endian
	/// and big-endian platforms. For big-endians, the
	/// MSB-to-the-left word order has the bytes in raster
	/// order when serialized, so no byte flipping is required.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixEndianByteSwap/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int EndianByteSwap ()
	{
		int RetObj = _All.pixEndianByteSwap(this);
		return RetObj;
	}

	// pix2.c (3045, 1)
	// pixEndianTwoByteSwapNew(pixs) as Pix
	// pixEndianTwoByteSwapNew(PIX *) as PIX *
	///  <summary>
	/// (1) This is used on little-endian platforms to swap the
	/// 2-byte entities within a 32-bit word.<para/>
	///
	/// (2) This is equivalent to a full byte swap, as performed
	/// by pixEndianByteSwap(), followed by byte swaps in
	/// each of the 16-bit entities separately.<para/>
	///
	/// (3) Unlike pixEndianTwoByteSwap(), which swaps the shorts in-place,
	/// this returns a new pix (or a clone).  We provide this
	/// to avoid having to swap twice in situations where the input
	/// pix must be restored to canonical little-endian order.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixEndianTwoByteSwapNew/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix EndianTwoByteSwapNew ()
	{
		Pix RetObj = _All.pixEndianTwoByteSwapNew(this);
		return RetObj;
	}

	// pix2.c (3098, 1)
	// pixEndianTwoByteSwap(pixs) as int
	// pixEndianTwoByteSwap(PIX *) as l_ok
	///  <summary>
	/// (1) This is used on little-endian platforms to swap the
	/// 2-byte entities within a 32-bit word.<para/>
	///
	/// (2) This is equivalent to a full byte swap, as performed
	/// by pixEndianByteSwap(), followed by byte swaps in
	/// each of the 16-bit entities separately.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixEndianTwoByteSwap/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int EndianTwoByteSwap ()
	{
		int RetObj = _All.pixEndianTwoByteSwap(this);
		return RetObj;
	}

	// pix2.c (3152, 1)
	// pixGetRasterData(pixs, pdata, pnbytes) as int
	// pixGetRasterData(PIX *, l_uint8 **, size_t *) as l_ok
	///  <summary>
	/// (1) This returns the raster data as a byte string, padded to the
	/// byte.  For 1 bpp, the first pixel is the MSbit in the first byte.
	/// For rgb, the bytes are in (rgb) order.  This is the format
	/// required for flate encoding of pixels in a PostScript file.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRasterData/*"/>
	///  <param name="pdata">[out] - raster data in memory</param>
	///  <param name="pnbytes">[out] - number of bytes in data string</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRasterData (out Byte[] pdata,
							  out uint pnbytes)
	{
		int RetObj = _All.pixGetRasterData(this, out pdata, out pnbytes);
		return RetObj;
	}

	// pix2.c (3226, 1)
	// pixAlphaIsOpaque(pix, popaque) as int
	// pixAlphaIsOpaque(PIX *, l_int32 *) as l_ok
	///  <summary>
	/// pixAlphaIsOpaque()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAlphaIsOpaque/*"/>
	///  <param name="pix">[in] - 32 bpp, spp == 4</param>
	///  <param name="popaque">[out] - 1 if spp == 4 and all alpha component values are 255 (opaque) 0 otherwise</param>
	///   <returns>0 if OK, 1 on error Notes: 1) On error, opaque is returned as 0 (FALSE).</returns>
	// CreateAdditiveFunction: Function/Else
	public int AlphaIsOpaque (Pix pix,
							  out int popaque)
	{
		int RetObj = _All.pixAlphaIsOpaque(pix, out popaque);
		return RetObj;
	}

	// pix2.c (3291, 1)
	// pixSetupByteProcessing(pix, pw, ph) as List<byte[]>
	// pixSetupByteProcessing(PIX *, l_int32 *, l_int32 *) as l_uint8 **
	///  <summary>
	/// (1) This is a simple helper for processing 8 bpp images with
	/// direct byte access.  It can swap byte order within each word.<para/>
	///
	/// (2) After processing, you must call pixCleanupByteProcessing(),
	/// which frees the lineptr array and restores byte order.<para/>
	///
	/// (3) Usage:
	/// l_uint8 lineptrs = pixSetupByteProcessing(pix, [and]w, [and]h)
	/// for (i = 0 i  is smaller h i++) {
	/// l_uint8 line = lineptrs[i]
	/// for (j = 0 j  is smaller w j++) {
	/// val = line[j]
	/// ...
	/// }
	/// }
	/// pixCleanupByteProcessing(pix, lineptrs)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetupByteProcessing/*"/>
	///  <param name="pix">[in] - 8 bpp, no colormap</param>
	///  <param name="pw">[out][optional] - width</param>
	///  <param name="ph">[out][optional] - height</param>
	///   <returns>line ptr array, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public List<byte[]> SetupByteProcessing (Pix pix,
											 out int pw,
											 out int ph)
	{
		List<byte[]> RetObj = _All.pixSetupByteProcessing(pix, out pw, out ph);
		return RetObj;
	}

	// pix2.c (3329, 1)
	// pixCleanupByteProcessing(pix, lineptrs) as int
	// pixCleanupByteProcessing(PIX *, l_uint8 **) as l_ok
	///  <summary>
	/// (1) This must be called after processing that was initiated
	/// by pixSetupByteProcessing() has finished.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCleanupByteProcessing/*"/>
	///  <param name="pix">[in] - 8 bpp, no colormap</param>
	///  <param name="lineptrs">[in] - ptrs to the beginning of each raster line of data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CleanupByteProcessing (Pix pix,
									  List<byte[]> lineptrs)
	{
		int RetObj = _All.pixCleanupByteProcessing(pix, lineptrs);
		return RetObj;
	}

	// pix3.c (155, 1)
	// pixSetMasked(pixd, pixm, val) as int
	// pixSetMasked(PIX *, PIX *, l_uint32) as l_ok
	///  <summary>
	/// (1) In-place operation.<para/>
	///
	/// (2) NOTE: For cmapped images, this calls pixSetMaskedCmap().
	/// %val must be the 32-bit color representation of the RGB pixel.
	/// It is not the index into the colormap!<para/>
	///
	/// (2) If pixm == NULL, a warning is given.<para/>
	///
	/// (3) This is an implicitly aligned operation, where the UL
	/// corners of pixd and pixm coincide.  A warning is
	/// issued if the two image sizes differ significantly,
	/// but the operation proceeds.<para/>
	///
	/// (4) Each pixel in pixd that co-locates with an ON pixel
	/// in pixm is set to the specified input value.
	/// Other pixels in pixd are not changed.<para/>
	///
	/// (5) You can visualize this as painting the color through
	/// the mask, as a stencil.<para/>
	///
	/// (6) If you do not want to have the UL corners aligned,
	/// use the function pixSetMaskedGeneral(), which requires
	/// you to input the UL corner of pixm relative to pixd.<para/>
	///
	/// (7) Implementation details: see comments in pixPaintThroughMask()
	/// for when we use rasterop to do the painting.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetMasked/*"/>
	///  <param name="pixd">[in] - 1, 2, 4, 8, 16 or 32 bpp or colormapped</param>
	///  <param name="pixm">[in][optional] - 1 bpp mask no operation if NULL</param>
	///  <param name="val">[in] - value to set at each masked pixel</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetMasked (Pix pixd,
						  uint val,
						  Pix pixm)
	{
		int RetObj = _All.pixSetMasked(pixd, pixm, val);
		return RetObj;
	}

	// pix3.c (294, 1)
	// pixSetMaskedGeneral(pixd, pixm, val, x, y) as int
	// pixSetMaskedGeneral(PIX *, PIX *, l_uint32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place operation.<para/>
	///
	/// (2) Alignment is explicit.  If you want the UL corners of
	/// the two images to be aligned, use pixSetMasked().<para/>
	///
	/// (3) A typical use would be painting through the foreground
	/// of a small binary mask pixm, located somewhere on a
	/// larger pixd.  Other pixels in pixd are not changed.<para/>
	///
	/// (4) You can visualize this as painting the color through
	/// the mask, as a stencil.<para/>
	///
	/// (5) This uses rasterop to handle clipping and different depths of pixd.<para/>
	///
	/// (6) If pixd has a colormap, you should call pixPaintThroughMask().<para/>
	///
	/// (7) Why is this function here, if pixPaintThroughMask() does the
	/// same thing, and does it more generally?  I've retained it here
	/// to show how one can paint through a mask using only full
	/// image rasterops, rather than pixel peeking in pixm and poking
	/// in pixd.  It's somewhat baroque, but I found it amusing.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetMaskedGeneral/*"/>
	///  <param name="pixd">[in] - 8, 16 or 32 bpp</param>
	///  <param name="pixm">[in][optional] - 1 bpp mask no operation if null</param>
	///  <param name="val">[in] - value to set at each masked pixel</param>
	///  <param name="x">[in] - location of UL corner of pixm relative to pixd can be negative</param>
	///  <param name="y">[in] - location of UL corner of pixm relative to pixd can be negative</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetMaskedGeneral (Pix pixd,
								 uint val,
								 int x,
								 int y,
								 Pix pixm)
	{
		int RetObj = _All.pixSetMaskedGeneral(pixd, pixm, val, x, y);
		return RetObj;
	}

	// pix3.c (374, 1)
	// pixCombineMasked(pixd, pixs, pixm) as int
	// pixCombineMasked(PIX *, PIX *, PIX *) as l_ok
	///  <summary>
	/// (1) In-place operation pixd is changed.<para/>
	///
	/// (2) This sets each pixel in pixd that co-locates with an ON
	/// pixel in pixm to the corresponding value of pixs.<para/>
	///
	/// (3) pixs and pixd must be the same depth and not colormapped.<para/>
	///
	/// (4) All three input pix are aligned at the UL corner, and the
	/// operation is clipped to the intersection of all three images.<para/>
	///
	/// (5) If pixm == NULL, it's a no-op.<para/>
	///
	/// (6) Implementation: see notes in pixCombineMaskedGeneral().
	/// For 8 bpp selective masking, you might guess that it
	/// would be faster to generate an 8 bpp version of pixm,
	/// using pixConvert1To8(pixm, 0, 255), and then use a
	/// general combine operation
	/// d = (d [and] ~m) | (s [and] m)
	/// on a word-by-word basis.  Not always.  The word-by-word
	/// combine takes a time that is independent of the mask data.
	/// If the mask is relatively sparse, the byte-check method
	/// is actually faster!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCombineMasked/*"/>
	///  <param name="pixd">[in] - 1 bpp, 8 bpp gray or 32 bpp rgb no cmap</param>
	///  <param name="pixm">[in][optional] - 1 bpp mask no operation if NULL</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CombineMasked (Pix pixd,
							  Pix pixm)
	{
		int RetObj = _All.pixCombineMasked(pixd, this, pixm);
		return RetObj;
	}

	// pix3.c (493, 1)
	// pixCombineMaskedGeneral(pixd, pixs, pixm, x, y) as int
	// pixCombineMaskedGeneral(PIX *, PIX *, PIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) In-place operation pixd is changed.<para/>
	///
	/// (2) This is a generalized version of pixCombinedMasked(), where
	/// the source and mask can be placed at the same (arbitrary)
	/// location relative to pixd.<para/>
	///
	/// (3) pixs and pixd must be the same depth and not colormapped.<para/>
	///
	/// (4) The UL corners of both pixs and pixm are aligned with
	/// the point (x, y) of pixd, and the operation is clipped to
	/// the intersection of all three images.<para/>
	///
	/// (5) If pixm == NULL, it's a no-op.<para/>
	///
	/// (6) Implementation.  There are two ways to do these.  In the first,
	/// we use rasterop, ORing the part of pixs under the mask
	/// with pixd (which has been appropriately cleared there first).
	/// In the second, the mask is used one pixel at a time to
	/// selectively replace pixels of pixd with those of pixs.
	/// Here, we use rasterop for 1 bpp and pixel-wise replacement
	/// for 8 and 32 bpp.  To use rasterop for 8 bpp, for example,
	/// we must first generate an 8 bpp version of the mask.
	/// The code is simple:
	/// Pix pixm8 = pixConvert1To8(NULL, pixm, 0, 255)
	/// Pix pixt = pixAnd(NULL, pixs, pixm8)
	/// pixRasterop(pixd, x, y, wmin, hmin, PIX_DST [and] PIX_NOT(PIX_SRC),
	/// pixm8, 0, 0)
	/// pixRasterop(pixd, x, y, wmin, hmin, PIX_SRC | PIX_DST,
	/// pixt, 0, 0)
	/// pixDestroy([and]pixt)
	/// pixDestroy([and]pixm8)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCombineMaskedGeneral/*"/>
	///  <param name="pixd">[in] - 1 bpp, 8 bpp gray or 32 bpp rgb</param>
	///  <param name="pixm">[in][optional] - 1 bpp mask</param>
	///  <param name="x">[in] - origin of pixs and pixm relative to pixd can be negative</param>
	///  <param name="y">[in] - origin of pixs and pixm relative to pixd can be negative</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CombineMaskedGeneral (Pix pixd,
									 int x,
									 int y,
									 Pix pixm)
	{
		int RetObj = _All.pixCombineMaskedGeneral(pixd, this, pixm, x, y);
		return RetObj;
	}

	// pix3.c (618, 1)
	// pixPaintThroughMask(pixd, pixm, x, y, val) as int
	// pixPaintThroughMask(PIX *, PIX *, l_int32, l_int32, l_uint32) as l_ok
	///  <summary>
	/// (1) In-place operation.  Calls pixSetMaskedCmap() for colormapped
	/// images.<para/>
	///
	/// (2) For 1, 2, 4, 8 and 16 bpp gray, we take the appropriate
	/// number of least significant bits of val.<para/>
	///
	/// (3) If pixm == NULL, it's a no-op.<para/>
	///
	/// (4) The mask origin is placed at (x,y) on pixd, and the
	/// operation is clipped to the intersection of rectangles.<para/>
	///
	/// (5) For rgb, the components in val are in the canonical locations,
	/// with red in location COLOR_RED, etc.<para/>
	///
	/// (6) Implementation detail 1:
	/// For painting with val == 0 or val == maxval, you can use rasterop.
	/// If val == 0, invert the mask so that it's 0 over the region
	/// into which you want to write, and use PIX_SRC [and] PIX_DST to
	/// clear those pixels.  To write with val = maxval (all 1's),
	/// use PIX_SRC | PIX_DST to set all bits under the mask.<para/>
	///
	/// (7) Implementation detail 2:
	/// The rasterop trick can be used for depth  is greater  1 as well.
	/// For val == 0, generate the mask for depth d from the binary
	/// mask using
	/// pixmd = pixUnpackBinary(pixm, d, 1)
	/// and use pixRasterop() with PIX_MASK.  For val == maxval,
	/// pixmd = pixUnpackBinary(pixm, d, 0)
	/// and use pixRasterop() with PIX_PAINT.
	/// But note that if d == 32 bpp, it is about 3x faster to use
	/// the general implementation (not pixRasterop()).<para/>
	///
	/// (8) Implementation detail 3:
	/// It might be expected that the switch in the inner loop will
	/// cause large branching delays and should be avoided.
	/// This is not the case, because the entrance is always the
	/// same and the compiler can correctly predict the jump.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixPaintThroughMask/*"/>
	///  <param name="pixd">[in] - 1, 2, 4, 8, 16 or 32 bpp or colormapped</param>
	///  <param name="pixm">[in][optional] - 1 bpp mask</param>
	///  <param name="x">[in] - origin of pixm relative to pixd can be negative</param>
	///  <param name="y">[in] - origin of pixm relative to pixd can be negative</param>
	///  <param name="val">[in] - pixel value to set at each masked pixel</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int PaintThroughMask (Pix pixd,
								 int x,
								 int y,
								 uint val,
								 Pix pixm)
	{
		int RetObj = _All.pixPaintThroughMask(pixd, pixm, x, y, val);
		return RetObj;
	}

	// pix3.c (786, 1)
	// pixPaintSelfThroughMask(pixd, pixm, x, y, searchdir, mindist, tilesize, ntiles, distblend) as int
	// pixPaintSelfThroughMask(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) In-place operation pixd is changed.<para/>
	///
	/// (2) If pixm == NULL, it's a no-op.<para/>
	///
	/// (3) The mask origin is placed at (x,y) on pixd, and the
	/// operation is clipped to the intersection of pixd and the
	/// fg of the mask.<para/>
	///
	/// (4) %tsize is the the requested size for tiling.  The actual
	/// actual size for each c.c. will be bounded by the minimum
	/// dimension of the c.c.<para/>
	///
	/// (5) For %mindist, %searchdir and %ntiles, see pixFindRepCloseTile().
	/// They determine the set of possible tiles that can be used
	/// to build a larger mirrored tile to paint onto pixd through
	/// the c.c. of pixm.<para/>
	///
	/// (6) %distblend is used for alpha blending.  It is only applied
	/// if there is exactly one c.c. in the mask.  Use distblend == 0
	/// to skip blending and just paint through the 1 bpp mask.<para/>
	///
	/// (7) To apply blending to more than 1 component, call this function
	/// repeatedly with %pixm, %x and %y representing one component of
	/// the mask each time.  This would be done as follows, for an
	/// underlying image pixs and mask pixm of components to fill:
	/// Boxa boxa = pixConnComp(pixm, [and]pixa, 8)
	/// n = boxaGetCount(boxa)
	/// for (i = 0 i  is smaller n i++) {
	/// Pix pix = pixaGetPix(pixa, i, L_CLONE)
	/// Box box = pixaGetBox(pixa, i, L_CLONE)
	/// boxGetGeometry(box, [and]bx, [and]by, [and]bw, [and]bh)
	/// pixPaintSelfThroughMask(pixs, pix, bx, by, searchdir,
	/// mindist, tilesize, ntiles, distblend)
	/// pixDestroy([and]pix)
	/// boxDestroy([and]box)
	/// }
	/// pixaDestroy([and]pixa)
	/// boxaDestroy([and]boxa)<para/>
	///
	/// (8) If no tiles can be found, this falls back to estimating the
	/// color near the boundary of the region to be textured.<para/>
	///
	/// (9) This can be used to replace the pixels in some regions of
	/// an image by selected neighboring pixels.  The mask represents
	/// the pixels to be replaced.  For each connected component in
	/// the mask, this function selects up to two tiles of neighboring
	/// pixels to be used for replacement of pixels represented by
	/// the component (i.e., under the FG of that component in the mask).
	/// After selection, mirror replication is used to generate an
	/// image that is large enough to cover the component.  Alpha
	/// blending can also be used outside of the component, but near the
	/// edge, to blur the transition between painted and original pixels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixPaintSelfThroughMask/*"/>
	///  <param name="pixd">[in] - 8 bpp gray or 32 bpp rgb not colormapped</param>
	///  <param name="pixm">[in] - 1 bpp mask</param>
	///  <param name="x">[in] - origin of pixm relative to pixd must not be negative</param>
	///  <param name="y">[in] - origin of pixm relative to pixd must not be negative</param>
	///  <param name="searchdir">[in] - L_HORIZ, L_VERT or L_BOTH_DIRECTIONS</param>
	///  <param name="mindist">[in] - min distance of nearest tile edge to box greater or equal 0</param>
	///  <param name="tilesize">[in] - requested size for tiling may be reduced</param>
	///  <param name="ntiles">[in] - number of tiles tested in each row/column</param>
	///  <param name="distblend">[in] - distance outside the fg used for blending with pixs</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int PaintSelfThroughMask (Pix pixd,
									 Pix pixm,
									 int x,
									 int y,
									 int searchdir,
									 int mindist,
									 int tilesize,
									 int ntiles,
									 int distblend)
	{
		int RetObj = _All.pixPaintSelfThroughMask(pixd, pixm, x, y, searchdir, mindist, tilesize, ntiles, distblend);
		return RetObj;
	}

	// pix3.c (943, 1)
	// pixMakeMaskFromVal(pixs, val) as Pix
	// pixMakeMaskFromVal(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This generates a 1 bpp mask image, where a 1 is written in
	/// the mask for each pixel in pixs that has a value %val.<para/>
	///
	/// (2) If no pixels have the value, an empty mask is generated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMakeMaskFromVal/*"/>
	///  <param name="val">[in] - pixel value</param>
	///   <returns>pixd 1 bpp mask, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MakeMaskFromVal (int val)
	{
		Pix RetObj = _All.pixMakeMaskFromVal(this, val);
		return RetObj;
	}

	// pix3.c (1000, 1)
	// pixMakeMaskFromLUT(pixs, tab) as Pix
	// pixMakeMaskFromLUT(PIX *, l_int32 *) as PIX *
	///  <summary>
	/// (1) This generates a 1 bpp mask image, where a 1 is written in
	/// the mask for each pixel in pixs that has a value corresponding
	/// to a 1 in the LUT.<para/>
	///
	/// (2) The LUT should be of size 256.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMakeMaskFromLUT/*"/>
	///  <param name="tab">[in] - 256-entry LUT 1 means to write to mask</param>
	///   <returns>pixd 1 bpp mask, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MakeMaskFromLUT (int[] tab)
	{
		Pix RetObj = _All.pixMakeMaskFromLUT(this, tab);
		return RetObj;
	}

	// pix3.c (1069, 1)
	// pixMakeArbMaskFromRGB(pixs, rc, gc, bc, thresh) as Pix
	// pixMakeArbMaskFromRGB(PIX *, l_float32, l_float32, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) This generates a 1 bpp mask image, where a 1 is written in
	/// the mask for each pixel in pixs that satisfies
	/// rc  rval + gc  gval + bc  bval  is greater  thresh
	/// where rval is the red component, etc.<para/>
	///
	/// (2) Unlike with pixConvertToGray(), there are no constraints
	/// on the color coefficients, which can be negative.  For
	/// example, a mask that discriminates against red and in favor
	/// of blue will have rc  is smaller 0.0 and bc  is greater  0.0.<para/>
	///
	/// (3) To make the result independent of intensity (the 'V' in HSV),
	/// select coefficients so that %thresh = 0.  Then the result
	/// is not changed when all components are multiplied by the
	/// same constant (as long as nothing saturates).  This can be
	/// useful if, for example, the illumination is not uniform.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMakeArbMaskFromRGB/*"/>
	///  <param name="rc">[in] - arithmetic factors can be negative</param>
	///  <param name="gc">[in] - arithmetic factors can be negative</param>
	///  <param name="bc">[in] - arithmetic factors can be negative</param>
	///  <param name="thresh">[in] - lower threshold on weighted sum of components</param>
	///   <returns>pixd 1 bpp mask, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MakeArbMaskFromRGB (Single rc,
								   Single gc,
								   Single bc,
								   Single thresh)
	{
		Pix RetObj = _All.pixMakeArbMaskFromRGB(this, rc, gc, bc, thresh);
		return RetObj;
	}

	// pix3.c (1146, 1)
	// pixSetUnderTransparency(pixs, val, debug) as Pix
	// pixSetUnderTransparency(PIX *, l_uint32, l_int32) as PIX *
	///  <summary>
	/// (1) This sets the r, g and b components under every fully
	/// transparent alpha component to %val.  The alpha components
	/// are unchanged.<para/>
	///
	/// (2) Full transparency is denoted by alpha == 0.  Setting
	/// all pixels to a constant %val where alpha is transparent
	/// can improve compressibility by reducing the entropy.<para/>
	///
	/// (3) The visual result depends on how the image is displayed.
	/// (a) For display devices that respect the use of the alpha
	/// layer, this will not affect the appearance.
	/// (b) For typical leptonica operations, alpha is ignored,
	/// so there will be a change in appearance because this
	/// resets the rgb values in the fully transparent region.<para/>
	///
	/// (4) pixRead() and pixWrite() will, by default, read and write
	/// 4-component (rgba) pix in png format.  To ignore the alpha
	/// component after reading, or omit it on writing, pixSetSpp(..., 3).<para/>
	///
	/// (5) Here are some examples:
	/// To convert all fully transparent pixels in a 4 component
	/// (rgba) png file to white:
	/// pixs = pixRead( is smallerinfile is greater )
	/// pixd = pixSetUnderTransparency(pixs, 0xffffff00, 0)
	/// To write pixd with the alpha component:
	/// pixWrite( is smalleroutfile is greater , pixd, IFF_PNG)
	/// To write and rgba image without the alpha component, first do:
	/// pixSetSpp(pixd, 3)
	/// If you later want to use the alpha, spp must be reset to 4.
	/// (fancier) To remove the alpha by blending the image over
	/// a white background:
	/// pixRemoveAlpha()
	/// This changes all pixel values where the alpha component is
	/// not opaque (255).<para/>
	///
	/// (6) Caution.  rgb images in leptonica typically have value 0 in
	/// the alpha channel, which is fully transparent.  If spp for
	/// such an image were changed from 3 to 4, the image becomes
	/// fully transparent, and this function will set each pixel to %val.
	/// If you really want to set every pixel to the same value,
	/// use pixSetAllArbitrary().<para/>
	///
	/// (7) This is useful for compressing an RGBA image where the part
	/// of the image that is fully transparent is random junk compression
	/// is typically improved by setting that region to a constant.
	/// For rendering as a 3 component RGB image over a uniform
	/// background of arbitrary color, use pixAlphaBlendUniform().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetUnderTransparency/*"/>
	///  <param name="val">[in] - 32 bit unsigned color to use where alpha == 0</param>
	///  <param name="debug">[in] - displays layers of pixs</param>
	///   <returns>pixd 32 bpp rgba, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SetUnderTransparency (uint val,
									 DebugOnOff debug)
	{
		Pix RetObj = _All.pixSetUnderTransparency(this, val, debug);
		return RetObj;
	}

	// pix3.c (1222, 1)
	// pixMakeAlphaFromMask(pixs, dist, pbox) as Pix
	// pixMakeAlphaFromMask(PIX *, l_int32, BOX **) as PIX *
	///  <summary>
	/// (1) This generates a 8 bpp alpha layer that is opaque (256)
	/// over the FG of pixs, and goes transparent linearly away
	/// from the FG pixels, decaying to 0 (transparent) is an
	/// 8-connected distance given by %dist.  If %dist == 0,
	/// this does a simple conversion from 1 to 8 bpp.<para/>
	///
	/// (2) If [and]box == NULL, this returns an alpha mask that is the
	/// full size of pixs.  Otherwise, the returned mask pixd covers
	/// just the FG pixels of pixs, expanded by %dist in each
	/// direction (if possible), and the returned box gives the
	/// location of the returned mask relative to pixs.<para/>
	///
	/// (3) This is useful for painting through a mask and allowing
	/// blending of the painted image with an underlying image
	/// in the mask background for pixels near foreground mask pixels.
	/// For example, with an underlying rgb image pix1, an overlaying
	/// image rgb pix2, binary mask pixm, and dist  is greater  0, this
	/// blending is achieved with:
	/// pix3 = pixMakeAlphaFromMask(pixm, dist, [and]box)
	/// boxGetGeometry(box, [and]x, [and]y, NULL, NULL)
	/// pix4 = pixBlendWithGrayMask(pix1, pix2, pix3, x, y)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMakeAlphaFromMask/*"/>
	///  <param name="dist">[in] - blending distance typically 10 - 30</param>
	///  <param name="pbox">[out][optional] - use NULL to get the full size</param>
	///   <returns>pixd (8 bpp gray, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MakeAlphaFromMask (int dist,
								  out Box pbox)
	{
		Pix RetObj = _All.pixMakeAlphaFromMask(this, dist, out pbox);
		return RetObj;
	}

	// pix3.c (1291, 1)
	// pixGetColorNearMaskBoundary(pixs, pixm, box, dist, pval, debug) as int
	// pixGetColorNearMaskBoundary(PIX *, PIX *, BOX *, l_int32, l_uint32 *, l_int32) as l_ok
	///  <summary>
	/// (1) This finds the average color in a set of pixels that are
	/// roughly a distance %dist from the c.c. boundary and in the
	/// background of the mask image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetColorNearMaskBoundary/*"/>
	///  <param name="pixm">[in] - 1 bpp mask, full image</param>
	///  <param name="box">[in] - region of mask typically b.b. of a component</param>
	///  <param name="dist">[in] - distance into BG from mask boundary to use</param>
	///  <param name="pval">[out] - average pixel value</param>
	///  <param name="debug">[in] - 1 to output mask images</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetColorNearMaskBoundary (Pix pixm,
										 Box box,
										 int dist,
										 out uint pval,
										 DebugOnOff debug)
	{
		int RetObj = _All.pixGetColorNearMaskBoundary(this, pixm, box, dist, out pval, debug);
		return RetObj;
	}

	// pix3.c (1395, 1)
	// pixInvert(pixd, pixs) as Pix
	// pixInvert(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) This inverts pixs, for all pixel depths.<para/>
	///
	/// (2) There are 3 cases:
	/// (a) pixd == null, ~src to new pixd
	/// (b) pixd == pixs, ~src to src  (in-place)
	/// (c) pixd != pixs, ~src to input pixd<para/>
	///
	/// (3) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixInvert(NULL, pixs)
	/// (b) pixInvert(pixs, pixs)
	/// (c) pixInvert(pixd, pixs)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixInvert/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Invert (Pix pixd)
	{
		Pix RetObj = _All.pixInvert(pixd, this);
		return RetObj;
	}

	// pix3.c (1446, 1)
	// pixOr(pixd, pixs1, pixs2) as Pix
	// pixOr(PIX *, PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) This gives the union of two images with equal depth,
	/// aligning them to the the UL corner.  pixs1 and pixs2
	/// need not have the same width and height.<para/>
	///
	/// (2) There are 3 cases:
	/// (a) pixd == null, (src1 | src2) to new pixd
	/// (b) pixd == pixs1,  (src1 | src2) to src1  (in-place)
	/// (c) pixd != pixs1,  (src1 | src2) to input pixd<para/>
	///
	/// (3) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixOr(NULL, pixs1, pixs2)
	/// (b) pixOr(pixs1, pixs1, pixs2)
	/// (c) pixOr(pixd, pixs1, pixs2)<para/>
	///
	/// (4) The size of the result is determined by pixs1.<para/>
	///
	/// (5) The depths of pixs1 and pixs2 must be equal.<para/>
	///
	/// (6) Note carefully that the order of pixs1 and pixs2 only matters
	/// for the in-place case.  For in-place, you must have
	/// pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
	/// result: the copy puts pixs1 image data in pixs2, and
	/// the rasterop is then between pixs2 and pixs2 (a no-op).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixOr/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs1, different from pixs1</param>
	///  <param name="pixs1">[in] - can be == pixd</param>
	///  <param name="pixs2">[in] - must be != pixd</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Or (Pix pixs1,
				   Pix pixs2,
				   Pix pixd)
	{
		Pix RetObj = _All.pixOr(pixd, pixs1, pixs2);
		return RetObj;
	}

	// pix3.c (1510, 1)
	// pixAnd(pixd, pixs1, pixs2) as Pix
	// pixAnd(PIX *, PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) This gives the intersection of two images with equal depth,
	/// aligning them to the the UL corner.  pixs1 and pixs2
	/// need not have the same width and height.<para/>
	///
	/// (2) There are 3 cases:
	/// (a) pixd == null, (src1 [and] src2) to new pixd
	/// (b) pixd == pixs1,  (src1 [and] src2) to src1  (in-place)
	/// (c) pixd != pixs1,  (src1 [and] src2) to input pixd<para/>
	///
	/// (3) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixAnd(NULL, pixs1, pixs2)
	/// (b) pixAnd(pixs1, pixs1, pixs2)
	/// (c) pixAnd(pixd, pixs1, pixs2)<para/>
	///
	/// (4) The size of the result is determined by pixs1.<para/>
	///
	/// (5) The depths of pixs1 and pixs2 must be equal.<para/>
	///
	/// (6) Note carefully that the order of pixs1 and pixs2 only matters
	/// for the in-place case.  For in-place, you must have
	/// pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
	/// result: the copy puts pixs1 image data in pixs2, and
	/// the rasterop is then between pixs2 and pixs2 (a no-op).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAnd/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs1, different from pixs1</param>
	///  <param name="pixs1">[in] - can be == pixd</param>
	///  <param name="pixs2">[in] - must be != pixd</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix And (Pix pixs1,
					Pix pixs2,
					Pix pixd)
	{
		Pix RetObj = _All.pixAnd(pixd, pixs1, pixs2);
		return RetObj;
	}

	// pix3.c (1574, 1)
	// pixXor(pixd, pixs1, pixs2) as Pix
	// pixXor(PIX *, PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) This gives the XOR of two images with equal depth,
	/// aligning them to the the UL corner.  pixs1 and pixs2
	/// need not have the same width and height.<para/>
	///
	/// (2) There are 3 cases:
	/// (a) pixd == null, (src1 ^ src2) to new pixd
	/// (b) pixd == pixs1,  (src1 ^ src2) to src1  (in-place)
	/// (c) pixd != pixs1,  (src1 ^ src2) to input pixd<para/>
	///
	/// (3) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixXor(NULL, pixs1, pixs2)
	/// (b) pixXor(pixs1, pixs1, pixs2)
	/// (c) pixXor(pixd, pixs1, pixs2)<para/>
	///
	/// (4) The size of the result is determined by pixs1.<para/>
	///
	/// (5) The depths of pixs1 and pixs2 must be equal.<para/>
	///
	/// (6) Note carefully that the order of pixs1 and pixs2 only matters
	/// for the in-place case.  For in-place, you must have
	/// pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
	/// result: the copy puts pixs1 image data in pixs2, and
	/// the rasterop is then between pixs2 and pixs2 (a no-op).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixXor/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs1, different from pixs1</param>
	///  <param name="pixs1">[in] - can be == pixd</param>
	///  <param name="pixs2">[in] - must be != pixd</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Xor (Pix pixs1,
					Pix pixs2,
					Pix pixd)
	{
		Pix RetObj = _All.pixXor(pixd, pixs1, pixs2);
		return RetObj;
	}

	// pix3.c (1639, 1)
	// pixSubtract(pixd, pixs1, pixs2) as Pix
	// pixSubtract(PIX *, PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) This gives the set subtraction of two images with equal depth,
	/// aligning them to the the UL corner.  pixs1 and pixs2
	/// need not have the same width and height.<para/>
	///
	/// (2) Source pixs2 is always subtracted from source pixs1.
	/// The result is
	/// pixs1 \ pixs2 = pixs1 [and] (~pixs2)<para/>
	///
	/// (3) There are 4 cases:
	/// (a) pixd == null, (src1 - src2) to new pixd
	/// (b) pixd == pixs1,  (src1 - src2) to src1  (in-place)
	/// (c) pixd == pixs2,  (src1 - src2) to src2  (in-place)
	/// (d) pixd != pixs1 [and][and] pixd != pixs2),
	/// (src1 - src2) to input pixd<para/>
	///
	/// (4) For clarity, if the case is known, use these patterns:
	/// (a) pixd = pixSubtract(NULL, pixs1, pixs2)
	/// (b) pixSubtract(pixs1, pixs1, pixs2)
	/// (c) pixSubtract(pixs2, pixs1, pixs2)
	/// (d) pixSubtract(pixd, pixs1, pixs2)<para/>
	///
	/// (5) The size of the result is determined by pixs1.<para/>
	///
	/// (6) The depths of pixs1 and pixs2 must be equal.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSubtract/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs1, equal to pixs2, or different from both pixs1 and pixs2</param>
	///  <param name="pixs1">[in] - can be == pixd</param>
	///  <param name="pixs2">[in] - can be == pixd</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Subtract (Pix pixs1,
						 Pix pixs2,
						 Pix pixd)
	{
		Pix RetObj = _All.pixSubtract(pixd, pixs1, pixs2);
		return RetObj;
	}

	// pix3.c (1701, 1)
	// pixZero(pix, pempty) as int
	// pixZero(PIX *, l_int32 *) as l_ok
	///  <summary>
	/// (1) For a binary image, if there are no fg (black) pixels, empty = 1.<para/>
	///
	/// (2) For a grayscale image, if all pixels are black (0), empty = 1.<para/>
	///
	/// (3) For an RGB image, if all 4 components in every pixel is 0,
	/// empty = 1.<para/>
	///
	/// (4) For a colormapped image, pixel values are 0.  The colormap
	/// is ignored.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixZero/*"/>
	///  <param name="pix">[in] - all depths colormap OK</param>
	///  <param name="pempty">[out] - 1 if all bits in image data field are 0 0 otherwise</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Zero (Pix pix,
					 out int pempty)
	{
		int RetObj = _All.pixZero(pix, out pempty);
		return RetObj;
	}

	// pix3.c (1751, 1)
	// pixForegroundFraction(pix, pfract) as int
	// pixForegroundFraction(PIX *, l_float32 *) as l_ok
	///  <summary>
	/// pixForegroundFraction()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixForegroundFraction/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///  <param name="pfract">[out] - fraction of ON pixels</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ForegroundFraction (Pix pix,
								   out Single pfract)
	{
		int RetObj = _All.pixForegroundFraction(pix, out pfract);
		return RetObj;
	}

	// pix3.c (1823, 1)
	// pixCountPixels(pixs, pcount, tab8) as int
	// pixCountPixels(PIX *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixCountPixels()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCountPixels/*"/>
	///  <param name="pcount">[out] - count of ON pixels</param>
	///  <param name="tab8">[in][optional] - 8-bit pixel lookup table</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CountPixels (out int pcount,
							int[] tab8)
	{
		int RetObj = _All.pixCountPixels(this, out pcount, tab8);
		return RetObj;
	}

	// pix3.c (1887, 1)
	// pixCountPixelsInRect(pixs, box, pcount, tab8) as int
	// pixCountPixelsInRect(PIX *, BOX *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixCountPixelsInRect()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCountPixelsInRect/*"/>
	///  <param name="box">[in] - (can be null)</param>
	///  <param name="pcount">[out] - count of ON pixels</param>
	///  <param name="tab8">[in][optional] - 8-bit pixel lookup table</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CountPixelsInRect (Box box,
								  out int pcount,
								  int[] tab8)
	{
		int RetObj = _All.pixCountPixelsInRect(this, box, out pcount, tab8);
		return RetObj;
	}

	// pix3.c (1931, 1)
	// pixCountByRow(pix, box) as Numa
	// pixCountByRow(PIX *, BOX *) as NUMA *
	///  <summary>
	/// (1) To resample for a bin size different from 1, use
	/// numaUniformSampling() on the result of this function.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCountByRow/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///  <param name="box">[in][optional] - clipping box for count can be null</param>
	///   <returns>na of number of ON pixels by row, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa CountByRow (Pix pix,
							Box box)
	{
		Numa RetObj = _All.pixCountByRow(pix, box);
		return RetObj;
	}

	// pix3.c (1983, 1)
	// pixCountByColumn(pix, box) as Numa
	// pixCountByColumn(PIX *, BOX *) as NUMA *
	///  <summary>
	/// (1) To resample for a bin size different from 1, use
	/// numaUniformSampling() on the result of this function.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCountByColumn/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///  <param name="box">[in][optional] - clipping box for count can be null</param>
	///   <returns>na of number of ON pixels by column, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa CountByColumn (Pix pix,
							   Box box)
	{
		Numa RetObj = _All.pixCountByColumn(pix, box);
		return RetObj;
	}

	// pix3.c (2029, 1)
	// pixCountPixelsByRow(pix, tab8) as Numa
	// pixCountPixelsByRow(PIX *, l_int32 *) as NUMA *
	///  <summary>
	/// pixCountPixelsByRow()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCountPixelsByRow/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///  <param name="tab8">[in][optional] - 8-bit pixel lookup table</param>
	///   <returns>na of counts, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa CountPixelsByRow (Pix pix,
								  int[] tab8)
	{
		Numa RetObj = _All.pixCountPixelsByRow(pix, tab8);
		return RetObj;
	}

	// pix3.c (2063, 1)
	// pixCountPixelsByColumn(pix) as Numa
	// pixCountPixelsByColumn(PIX *) as NUMA *
	///  <summary>
	/// pixCountPixelsByColumn()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCountPixelsByColumn/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///   <returns>na of counts in each column, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa CountPixelsByColumn (Pix pix)
	{
		Numa RetObj = _All.pixCountPixelsByColumn(pix);
		return RetObj;
	}

	// pix3.c (2104, 1)
	// pixCountPixelsInRow(pix, row, pcount, tab8) as int
	// pixCountPixelsInRow(PIX *, l_int32, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixCountPixelsInRow()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCountPixelsInRow/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///  <param name="row">[in] - number</param>
	///  <param name="pcount">[out] - sum of ON pixels in raster line</param>
	///  <param name="tab8">[in][optional] - 8-bit pixel lookup table</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CountPixelsInRow (Pix pix,
								 int row,
								 out int pcount,
								 int[] tab8)
	{
		int RetObj = _All.pixCountPixelsInRow(pix, row, out pcount, tab8);
		return RetObj;
	}

	// pix3.c (2167, 1)
	// pixGetMomentByColumn(pix, order) as Numa
	// pixGetMomentByColumn(PIX *, l_int32) as NUMA *
	///  <summary>
	/// pixGetMomentByColumn()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetMomentByColumn/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///  <param name="order">[in] - of moment, either 1 or 2</param>
	///   <returns>na of first moment of fg pixels, by column, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetMomentByColumn (Pix pix,
								   int order)
	{
		Numa RetObj = _All.pixGetMomentByColumn(pix, order);
		return RetObj;
	}

	// pix3.c (2225, 1)
	// pixThresholdPixelSum(pix, thresh, pabove, tab8) as int
	// pixThresholdPixelSum(PIX *, l_int32, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This sums the ON pixels and returns immediately if the count
	/// goes above threshold.  It is therefore more efficient
	/// for matching images (by running this function on the xor of
	/// the 2 images) than using pixCountPixels(), which counts all
	/// pixels before returning.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixThresholdPixelSum/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///  <param name="thresh">[in] - threshold</param>
	///  <param name="pabove">[out] - 1 if above threshold 0 if equal to or less than threshold</param>
	///  <param name="tab8">[in][optional] - 8-bit pixel lookup table</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ThresholdPixelSum (Pix pix,
								  int thresh,
								  out int pabove,
								  int[] tab8)
	{
		int RetObj = _All.pixThresholdPixelSum(pix, thresh, out pabove, tab8);
		return RetObj;
	}

	// pix3.c (2400, 1)
	// pixAverageByRow(pix, box, type) as Numa
	// pixAverageByRow(PIX *, BOX *, l_int32) as NUMA *
	///  <summary>
	/// (1) To resample for a bin size different from 1, use
	/// numaUniformSampling() on the result of this function.<para/>
	///
	/// (2) If type == L_BLACK_IS_MAX, black pixels get the maximum
	/// value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAverageByRow/*"/>
	///  <param name="pix">[in] - 8 or 16 bpp no colormap</param>
	///  <param name="box">[in][optional] - clipping box for sum can be null</param>
	///  <param name="type">[in] - L_WHITE_IS_MAX, L_BLACK_IS_MAX</param>
	///   <returns>na of pixel averages by row, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa AverageByRow (Pix pix,
							  int type,
							  Box box)
	{
		Numa RetObj = _All.pixAverageByRow(pix, box, type);
		return RetObj;
	}

	// pix3.c (2469, 1)
	// pixAverageByColumn(pix, box, type) as Numa
	// pixAverageByColumn(PIX *, BOX *, l_int32) as NUMA *
	///  <summary>
	/// (1) To resample for a bin size different from 1, use
	/// numaUniformSampling() on the result of this function.<para/>
	///
	/// (2) If type == L_BLACK_IS_MAX, black pixels get the maximum
	/// value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAverageByColumn/*"/>
	///  <param name="pix">[in] - 8 or 16 bpp no colormap</param>
	///  <param name="box">[in][optional] - clipping box for sum can be null</param>
	///  <param name="type">[in] - L_WHITE_IS_MAX, L_BLACK_IS_MAX</param>
	///   <returns>na of pixel averages by column, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa AverageByColumn (Pix pix,
								 int type,
								 Box box)
	{
		Numa RetObj = _All.pixAverageByColumn(pix, box, type);
		return RetObj;
	}

	// pix3.c (2534, 1)
	// pixAverageInRect(pix, box, pave) as int
	// pixAverageInRect(PIX *, BOX *, l_float32 *) as l_ok
	///  <summary>
	/// pixAverageInRect()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAverageInRect/*"/>
	///  <param name="pix">[in] - 1, 2, 4, 8 bpp not cmapped</param>
	///  <param name="box">[in][optional] - if null, use entire image</param>
	///  <param name="pave">[out] - average of pixel values in region</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AverageInRect (Pix pix,
							  out Single pave,
							  Box box)
	{
		int RetObj = _All.pixAverageInRect(pix, box, out pave);
		return RetObj;
	}

	// pix3.c (2600, 1)
	// pixVarianceByRow(pix, box) as Numa
	// pixVarianceByRow(PIX *, BOX *) as NUMA *
	///  <summary>
	/// (1) To resample for a bin size different from 1, use
	/// numaUniformSampling() on the result of this function.<para/>
	///
	/// (2) We are actually computing the RMS deviation in each row.
	/// This is the square root of the variance.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixVarianceByRow/*"/>
	///  <param name="pix">[in] - 8 or 16 bpp no colormap</param>
	///  <param name="box">[in][optional] - clipping box for variance can be null</param>
	///   <returns>na of rmsdev by row, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa VarianceByRow (Pix pix,
							   Box box)
	{
		Numa RetObj = _All.pixVarianceByRow(pix, box);
		return RetObj;
	}

	// pix3.c (2665, 1)
	// pixVarianceByColumn(pix, box) as Numa
	// pixVarianceByColumn(PIX *, BOX *) as NUMA *
	///  <summary>
	/// (1) To resample for a bin size different from 1, use
	/// numaUniformSampling() on the result of this function.<para/>
	///
	/// (2) We are actually computing the RMS deviation in each row.
	/// This is the square root of the variance.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixVarianceByColumn/*"/>
	///  <param name="pix">[in] - 8 or 16 bpp no colormap</param>
	///  <param name="box">[in][optional] - clipping box for variance can be null</param>
	///   <returns>na of rmsdev by column, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa VarianceByColumn (Pix pix,
								  Box box)
	{
		Numa RetObj = _All.pixVarianceByColumn(pix, box);
		return RetObj;
	}

	// pix3.c (2723, 1)
	// pixVarianceInRect(pix, box, prootvar) as int
	// pixVarianceInRect(PIX *, BOX *, l_float32 *) as l_ok
	///  <summary>
	/// pixVarianceInRect()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixVarianceInRect/*"/>
	///  <param name="pix">[in] - 1, 2, 4, 8 bpp not cmapped</param>
	///  <param name="box">[in][optional] - if null, use entire image</param>
	///  <param name="prootvar">[out] - sqrt variance of pixel values in region</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int VarianceInRect (Pix pix,
							   out Single prootvar,
							   Box box)
	{
		int RetObj = _All.pixVarianceInRect(pix, box, out prootvar);
		return RetObj;
	}

	// pix3.c (2800, 1)
	// pixAbsDiffByRow(pix, box) as Numa
	// pixAbsDiffByRow(PIX *, BOX *) as NUMA *
	///  <summary>
	/// (1) This is an average over differences of adjacent pixels along
	/// each row.<para/>
	///
	/// (2) To resample for a bin size different from 1, use
	/// numaUniformSampling() on the result of this function.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAbsDiffByRow/*"/>
	///  <param name="pix">[in] - 8 bpp no colormap</param>
	///  <param name="box">[in][optional] - clipping box for region can be null</param>
	///   <returns>na of abs val pixel difference averages by row, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa AbsDiffByRow (Pix pix,
							  Box box)
	{
		Numa RetObj = _All.pixAbsDiffByRow(pix, box);
		return RetObj;
	}

	// pix3.c (2861, 1)
	// pixAbsDiffByColumn(pix, box) as Numa
	// pixAbsDiffByColumn(PIX *, BOX *) as NUMA *
	///  <summary>
	/// (1) This is an average over differences of adjacent pixels along
	/// each column.<para/>
	///
	/// (2) To resample for a bin size different from 1, use
	/// numaUniformSampling() on the result of this function.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAbsDiffByColumn/*"/>
	///  <param name="pix">[in] - 8 bpp no colormap</param>
	///  <param name="box">[in][optional] - clipping box for region can be null</param>
	///   <returns>na of abs val pixel difference averages by column, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa AbsDiffByColumn (Pix pix,
								 Box box)
	{
		Numa RetObj = _All.pixAbsDiffByColumn(pix, box);
		return RetObj;
	}

	// pix3.c (2924, 1)
	// pixAbsDiffInRect(pix, box, dir, pabsdiff) as int
	// pixAbsDiffInRect(PIX *, BOX *, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// (1) This gives the average over the abs val of differences of
	/// adjacent pixels values, along either each
	/// row: dir == L_HORIZONTAL_LINE
	/// column:  dir == L_VERTICAL_LINE
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAbsDiffInRect/*"/>
	///  <param name="pix">[in] - 8 bpp not cmapped</param>
	///  <param name="box">[in][optional] - if null, use entire image</param>
	///  <param name="dir">[in] - differences along L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
	///  <param name="pabsdiff">[out] - average of abs diff pixel values in region</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AbsDiffInRect (Pix pix,
							  int dir,
							  out Single pabsdiff,
							  Box box)
	{
		int RetObj = _All.pixAbsDiffInRect(pix, box, dir, out pabsdiff);
		return RetObj;
	}

	// pix3.c (3001, 1)
	// pixAbsDiffOnLine(pix, x1, y1, x2, y2, pabsdiff) as int
	// pixAbsDiffOnLine(PIX *, l_int32, l_int32, l_int32, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// (1) This gives the average over the abs val of differences of
	/// adjacent pixels values, along a line that is either horizontal
	/// or vertical.<para/>
	///
	/// (2) If horizontal, require x1  is smaller x2 if vertical, require y1  is smaller y2.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAbsDiffOnLine/*"/>
	///  <param name="pix">[in] - 8 bpp not cmapped</param>
	///  <param name="x1">[in] - first point x1 smaller or equal x2, y1 smaller or equal y2</param>
	///  <param name="y1">[in] - first point x1 smaller or equal x2, y1 smaller or equal y2</param>
	///  <param name="x2">[in] - first point</param>
	///  <param name="y2">[in] - first point</param>
	///  <param name="pabsdiff">[out] - average of abs diff pixel values on line</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AbsDiffOnLine (Pix pix,
							  int x1,
							  int y1,
							  int x2,
							  int y2,
							  out Single pabsdiff)
	{
		int RetObj = _All.pixAbsDiffOnLine(pix, x1, y1, x2, y2, out pabsdiff);
		return RetObj;
	}

	// pix3.c (3083, 1)
	// pixCountArbInRect(pixs, box, val, factor, pcount) as int
	// pixCountArbInRect(PIX *, BOX *, l_int32, l_int32, l_int32 *) as l_int32
	///  <summary>
	/// (1) If pixs is cmapped, %val is compared to the colormap index
	/// otherwise, %val is compared to the grayscale value.<para/>
	///
	/// (2) Set the subsampling %factor  is greater  1 to reduce the amount of computation.
	/// If %factor  is greater  1, multiply the count by %factor  %factor.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCountArbInRect/*"/>
	///  <param name="box">[in][optional] - over which count is made use entire image if NULL</param>
	///  <param name="val">[in] - pixel value to count</param>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///  <param name="pcount">[out] - count estimate it if factor  is greater  1</param>
	///   <returns>na histogram, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CountArbInRect (int val,
							   int factor,
							   out int pcount,
							   Box box)
	{
		int RetObj = _All.pixCountArbInRect(this, box, val, factor, out pcount);
		return RetObj;
	}

	// pix3.c (3161, 1)
	// pixMirroredTiling(pixs, w, h) as Pix
	// pixMirroredTiling(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This uses mirrored tiling, where each row alternates
	/// with LR flips and every column alternates with TB
	/// flips, such that the result is a tiling with identical
	/// 2 x 2 tiles, each of which is composed of these transforms:
	/// -----------------
	/// | 1  |  LR  |
	/// -----------------
	/// | TB |  LR/TB |
	/// -----------------
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMirroredTiling/*"/>
	///  <param name="w">[in] - dimensions of output pix</param>
	///  <param name="h">[in] - dimensions of output pix</param>
	///   <returns>pixd usually larger pix, mirror-tiled with pixs, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MirroredTiling (int w,
							   int h)
	{
		Pix RetObj = _All.pixMirroredTiling(this, w, h);
		return RetObj;
	}

	// pix3.c (3236, 1)
	// pixFindRepCloseTile(pixs, box, searchdir, mindist, tsize, ntiles, pboxtile, debug) as int
	// pixFindRepCloseTile(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, BOX **, l_int32) as l_ok
	///  <summary>
	/// (1) This looks for one or two square tiles with conforming median
	/// intensity and low variance, that is outside but near the input box.<para/>
	///
	/// (2) %mindist specifies the gap between the box and the
	/// potential tiles.  The tiles are given an overlap of 50%.
	/// %ntiles specifies the number of tiles that are tested
	/// beyond %mindist for each row or column.<para/>
	///
	/// (3) For example, if %mindist = 20, %tilesize = 50 and %ntiles = 3,
	/// a horizontal search to the right will have 3 tiles in each row,
	/// with left edges at 20, 45 and 70 from the right edge of the
	/// input %box.  The number of rows of tiles is determined by
	/// the height of %box and %tsize, with the 50% overlap..
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindRepCloseTile/*"/>
	///  <param name="box">[in] - region of pixs to search around</param>
	///  <param name="searchdir">[in] - L_HORIZ or L_VERT direction to search</param>
	///  <param name="mindist">[in] - min distance of selected tile edge from box greater or equal 0</param>
	///  <param name="tsize">[in] - tile size  is greater  1 even typically ~50</param>
	///  <param name="ntiles">[in] - number of tiles tested in each row/column</param>
	///  <param name="pboxtile">[out] - region of best tile</param>
	///  <param name="debug">[in] - 1    for debug output</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindRepCloseTile (Box box,
								 int searchdir,
								 int mindist,
								 int tsize,
								 int ntiles,
								 out Box pboxtile,
								 DebugOnOff debug)
	{
		int RetObj = _All.pixFindRepCloseTile(this, box, searchdir, mindist, tsize, ntiles, out pboxtile, debug);
		return RetObj;
	}

	// pix4.c (109, 1)
	// pixGetGrayHistogram(pixs, factor) as Numa
	// pixGetGrayHistogram(PIX *, l_int32) as NUMA *
	///  <summary>
	/// (1) If pixs has a colormap, it is converted to 8 bpp gray.
	/// If you want a histogram of the colormap indices, use
	/// pixGetCmapHistogram().<para/>
	///
	/// (2) If pixs does not have a colormap, the output histogram is
	/// of size 2^d, where d is the depth of pixs.<para/>
	///
	/// (3) Set the subsampling factor  is greater  1 to reduce the amount of computation.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetGrayHistogram/*"/>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///   <returns>na histogram, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetGrayHistogram (int factor)
	{
		Numa RetObj = _All.pixGetGrayHistogram(this, factor);
		return RetObj;
	}

	// pix4.c (205, 1)
	// pixGetGrayHistogramMasked(pixs, pixm, x, y, factor) as Numa
	// pixGetGrayHistogramMasked(PIX *, PIX *, l_int32, l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) If pixs is cmapped, it is converted to 8 bpp gray.
	/// If you want a histogram of the colormap indices, use
	/// pixGetCmapHistogramMasked().<para/>
	///
	/// (2) This always returns a 256-value histogram of pixel values.<para/>
	///
	/// (3) Set the subsampling factor  is greater  1 to reduce the amount of computation.<para/>
	///
	/// (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.<para/>
	///
	/// (5) Input x,y are ignored unless pixm exists.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetGrayHistogramMasked/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask over which histogram is to be computed use all pixels if null</param>
	///  <param name="x">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0 these values are ignored if pixm is null</param>
	///  <param name="y">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0 these values are ignored if pixm is null</param>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///   <returns>na histogram, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetGrayHistogramMasked (int x,
										int y,
										int factor,
										Pix pixm)
	{
		Numa RetObj = _All.pixGetGrayHistogramMasked(this, pixm, x, y, factor);
		return RetObj;
	}

	// pix4.c (285, 1)
	// pixGetGrayHistogramInRect(pixs, box, factor) as Numa
	// pixGetGrayHistogramInRect(PIX *, BOX *, l_int32) as NUMA *
	///  <summary>
	/// (1) If pixs is cmapped, it is converted to 8 bpp gray.
	/// If you want a histogram of the colormap indices, use
	/// pixGetCmapHistogramInRect().<para/>
	///
	/// (2) This always returns a 256-value histogram of pixel values.<para/>
	///
	/// (3) Set the subsampling %factor  is greater  1 to reduce the amount of computation.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetGrayHistogramInRect/*"/>
	///  <param name="box">[in][optional] - over which histogram is to be computed use full image if NULL</param>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///   <returns>na histogram, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetGrayHistogramInRect (int factor,
										Box box)
	{
		Numa RetObj = _All.pixGetGrayHistogramInRect(this, box, factor);
		return RetObj;
	}

	// pix4.c (353, 1)
	// pixGetGrayHistogramTiled(pixs, factor, nx, ny) as Numaa
	// pixGetGrayHistogramTiled(PIX *, l_int32, l_int32, l_int32) as NUMAA *
	///  <summary>
	/// (1) If pixs is cmapped, it is converted to 8 bpp gray.<para/>
	///
	/// (2) This returns a set of 256-value histograms of pixel values.<para/>
	///
	/// (3) Set the subsampling factor  is greater  1 to reduce the amount of computation.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetGrayHistogramTiled/*"/>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///  <param name="nx">[in] - tiling greater or equal 1 typically small</param>
	///  <param name="ny">[in] - tiling greater or equal 1 typically small</param>
	///   <returns>naa set of histograms, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numaa GetGrayHistogramTiled (int factor,
										int nx,
										int ny)
	{
		Numaa RetObj = _All.pixGetGrayHistogramTiled(this, factor, nx, ny);
		return RetObj;
	}

	// pix4.c (410, 1)
	// pixGetColorHistogram(pixs, factor, pnar, pnag, pnab) as int
	// pixGetColorHistogram(PIX *, l_int32, NUMA **, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// (1) This generates a set of three 256 entry histograms,
	/// one for each color component (r,g,b).<para/>
	///
	/// (2) Set the subsampling %factor  is greater  1 to reduce the amount of computation.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetColorHistogram/*"/>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///  <param name="pnar">[out] - red histogram</param>
	///  <param name="pnag">[out] - green histogram</param>
	///  <param name="pnab">[out] - blue histogram</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetColorHistogram (int factor,
								  out Numa pnar,
								  out Numa pnag,
								  out Numa pnab)
	{
		int RetObj = _All.pixGetColorHistogram(this, factor, out pnar, out pnag, out pnab);
		return RetObj;
	}

	// pix4.c (512, 1)
	// pixGetColorHistogramMasked(pixs, pixm, x, y, factor, pnar, pnag, pnab) as int
	// pixGetColorHistogramMasked(PIX *, PIX *, l_int32, l_int32, l_int32, NUMA **, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// (1) This generates a set of three 256 entry histograms,<para/>
	///
	/// (2) Set the subsampling %factor  is greater  1 to reduce the amount of computation.<para/>
	///
	/// (3) Clipping of pixm (if it exists) to pixs is done in the inner loop.<para/>
	///
	/// (4) Input x,y are ignored unless pixm exists.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetColorHistogramMasked/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask over which histogram is to be computed use all pixels if null</param>
	///  <param name="x">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0 these values are ignored if pixm is null</param>
	///  <param name="y">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0 these values are ignored if pixm is null</param>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///  <param name="pnar">[out] - red histogram</param>
	///  <param name="pnag">[out] - green histogram</param>
	///  <param name="pnab">[out] - blue histogram</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetColorHistogramMasked (int x,
										int y,
										int factor,
										out Numa pnar,
										out Numa pnag,
										out Numa pnab,
										Pix pixm)
	{
		int RetObj = _All.pixGetColorHistogramMasked(this, pixm, x, y, factor, out pnar, out pnag, out pnab);
		return RetObj;
	}

	// pix4.c (627, 1)
	// pixGetCmapHistogram(pixs, factor) as Numa
	// pixGetCmapHistogram(PIX *, l_int32) as NUMA *
	///  <summary>
	/// (1) This generates a histogram of colormap pixel indices,
	/// and is of size 2^d.<para/>
	///
	/// (2) Set the subsampling %factor  is greater  1 to reduce the amount of computation.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetCmapHistogram/*"/>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///   <returns>na histogram of cmap indices, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetCmapHistogram (int factor)
	{
		Numa RetObj = _All.pixGetCmapHistogram(this, factor);
		return RetObj;
	}

	// pix4.c (692, 1)
	// pixGetCmapHistogramMasked(pixs, pixm, x, y, factor) as Numa
	// pixGetCmapHistogramMasked(PIX *, PIX *, l_int32, l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) This generates a histogram of colormap pixel indices,
	/// and is of size 2^d.<para/>
	///
	/// (2) Set the subsampling %factor  is greater  1 to reduce the amount of computation.<para/>
	///
	/// (3) Clipping of pixm to pixs is done in the inner loop.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetCmapHistogramMasked/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask over which histogram is to be computed use all pixels if null</param>
	///  <param name="x">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0 these values are ignored if pixm is null</param>
	///  <param name="y">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0 these values are ignored if pixm is null</param>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///   <returns>na histogram, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetCmapHistogramMasked (int x,
										int y,
										int factor,
										Pix pixm)
	{
		Numa RetObj = _All.pixGetCmapHistogramMasked(this, pixm, x, y, factor);
		return RetObj;
	}

	// pix4.c (772, 1)
	// pixGetCmapHistogramInRect(pixs, box, factor) as Numa
	// pixGetCmapHistogramInRect(PIX *, BOX *, l_int32) as NUMA *
	///  <summary>
	/// (1) This generates a histogram of colormap pixel indices,
	/// and is of size 2^d.<para/>
	///
	/// (2) Set the subsampling %factor  is greater  1 to reduce the amount of computation.<para/>
	///
	/// (3) Clipping to the box is done in the inner loop.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetCmapHistogramInRect/*"/>
	///  <param name="box">[in][optional] - over which histogram is to be computed use full image if NULL</param>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///   <returns>na histogram, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetCmapHistogramInRect (int factor,
										Box box)
	{
		Numa RetObj = _All.pixGetCmapHistogramInRect(this, box, factor);
		return RetObj;
	}

	// pix4.c (831, 1)
	// pixCountRGBColors(pixs) as int
	// pixCountRGBColors(PIX *) as l_int32
	///  <summary>
	/// pixCountRGBColors()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCountRGBColors/*"/>
	///   <returns>ncolors, or -1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CountRGBColors ()
	{
		int RetObj = _All.pixCountRGBColors(this);
		return RetObj;
	}

	// pix4.c (861, 1)
	// pixGetColorAmapHistogram(pixs, factor) as L_Rbtree
	// pixGetColorAmapHistogram(PIX *, l_int32) as L_AMAP *
	///  <summary>
	/// (1) This generates an ordered map from pixel value to histogram count.<para/>
	///
	/// (2) Use amapGetCountForColor() to use the map to look up a count.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetColorAmapHistogram/*"/>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///   <returns>amap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public L_Rbtree GetColorAmapHistogram (int factor)
	{
		L_Rbtree RetObj = _All.pixGetColorAmapHistogram(this, factor);
		return RetObj;
	}

	// pix4.c (945, 1)
	// pixGetRankValue(pixs, factor, rank, pvalue) as int
	// pixGetRankValue(PIX *, l_int32, l_float32, l_uint32 *) as l_ok
	///  <summary>
	/// (1) Simple function to get rank values of an image.
	/// For a color image, the median value (rank = 0.5) can be
	/// used to linearly remap the colors based on the median
	/// of a target image, using pixLinearMapToTargetColor().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRankValue/*"/>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///  <param name="rank">[in] - between 0.0 and 1.0 1.0 is brightest, 0.0 is darkest</param>
	///  <param name="pvalue">[out] - pixel value corresponding to input rank</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRankValue (int factor,
							 Single rank,
							 out uint pvalue)
	{
		int RetObj = _All.pixGetRankValue(this, factor, rank, out pvalue);
		return RetObj;
	}

	// pix4.c (1015, 1)
	// pixGetRankValueMaskedRGB(pixs, pixm, x, y, factor, rank, prval, pgval, pbval) as int
	// pixGetRankValueMaskedRGB(PIX *, PIX *, l_int32, l_int32, l_int32, l_float32, l_float32 *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) Computes the rank component values of pixels in pixs that
	/// are under the fg of the optional mask.  If the mask is null, it
	/// computes the average of the pixels in pixs.<para/>
	///
	/// (2) Set the subsampling %factor  is greater  1 to reduce the amount of
	/// computation.<para/>
	///
	/// (4) Input x,y are ignored unless pixm exists.<para/>
	///
	/// (5) The rank must be in [0.0 ... 1.0], where the brightest pixel
	/// has rank 1.0.  For the median pixel value, use 0.5.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRankValueMaskedRGB/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask over which rank val is to be taken use all pixels if null</param>
	///  <param name="x">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0 these values are ignored if pixm is null</param>
	///  <param name="y">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0 these values are ignored if pixm is null</param>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///  <param name="rank">[in] - between 0.0 and 1.0 1.0 is brightest, 0.0 is darkest</param>
	///  <param name="prval">[out][optional] - red component val for input rank</param>
	///  <param name="pgval">[out][optional] - green component val for input rank</param>
	///  <param name="pbval">[out][optional] - blue component val for input rank</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRankValueMaskedRGB (int x,
									  int y,
									  int factor,
									  Single rank,
									  Pix pixm,
									  out Single prval,
									  out Single pgval,
									  out Single pbval)
	{
		int RetObj = _All.pixGetRankValueMaskedRGB(this, pixm, x, y, factor, rank, out prval, out pgval, out pbval);
		return RetObj;
	}

	// pix4.c (1107, 1)
	// pixGetRankValueMasked(pixs, pixm, x, y, factor, rank, pval, pna) as int
	// pixGetRankValueMasked(PIX *, PIX *, l_int32, l_int32, l_int32, l_float32, l_float32 *, NUMA **) as l_ok
	///  <summary>
	/// (1) Computes the rank value of pixels in pixs that are under
	/// the fg of the optional mask.  If the mask is null, it
	/// computes the average of the pixels in pixs.<para/>
	///
	/// (2) Set the subsampling %factor  is greater  1 to reduce the amount of
	/// computation.<para/>
	///
	/// (3) Clipping of pixm (if it exists) to pixs is done in the inner loop.<para/>
	///
	/// (4) Input x,y are ignored unless pixm exists.<para/>
	///
	/// (5) The rank must be in [0.0 ... 1.0], where the brightest pixel
	/// has rank 1.0.  For the median pixel value, use 0.5.<para/>
	///
	/// (6) The histogram can optionally be returned, so that other rank
	/// values can be extracted without recomputing the histogram.
	/// In that case, just use
	/// numaHistogramGetValFromRank(na, rank, [and]val)
	/// on the returned Numa for additional rank values.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRankValueMasked/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask, over which the rank val is to be taken use all pixels if null</param>
	///  <param name="x">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0 these values are ignored if pixm is null</param>
	///  <param name="y">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0 these values are ignored if pixm is null</param>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///  <param name="rank">[in] - between 0.0 and 1.0 1.0 is brightest, 0.0 is darkest</param>
	///  <param name="pval">[out] - pixel value corresponding to input rank</param>
	///  <param name="pna">[out][optional] - of histogram</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRankValueMasked (int x,
								   int y,
								   int factor,
								   Single rank,
								   out Single pval,
								   Pix pixm,
								   out Numa pna)
	{
		int RetObj = _All.pixGetRankValueMasked(this, pixm, x, y, factor, rank, out pval, out pna);
		return RetObj;
	}

	// pix4.c (1176, 1)
	// pixGetPixelAverage(pixs, pixm, x, y, factor, pval) as int
	// pixGetPixelAverage(PIX *, PIX *, l_int32, l_int32, l_int32, l_uint32 *) as l_ok
	///  <summary>
	/// (1) For rgb pix, this is a more direct computation of the
	/// average value of the pixels in %pixs that are under the
	/// mask %pixm. It is faster than pixGetPixelStats(), which
	/// calls pixGetAverageMaskedRGB() and has the overhead of
	/// generating a temporary pix of each of the three components
	/// this can take most of the time if %factor  is greater  1.<para/>
	///
	/// (2) If %pixm is null, this gives the average value of all
	/// pixels in %pixs.  The returned value is an integer.<para/>
	///
	/// (3) For color %pixs, the returned pixel value is in the standard
	/// uint32 RGBA packing.<para/>
	///
	/// (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.<para/>
	///
	/// (5) Input x,y are ignored if %pixm does not exist.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetPixelAverage/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask over which average is to be taken use all pixels if null</param>
	///  <param name="x">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0</param>
	///  <param name="y">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0</param>
	///  <param name="factor">[in] - subsampling factor greater or equal 1</param>
	///  <param name="pval">[out] - average pixel value</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetPixelAverage (int x,
								int y,
								int factor,
								out uint pval,
								Pix pixm)
	{
		int RetObj = _All.pixGetPixelAverage(this, pixm, x, y, factor, out pval);
		return RetObj;
	}

	// pix4.c (1294, 1)
	// pixGetPixelStats(pixs, factor, type, pvalue) as int
	// pixGetPixelStats(PIX *, l_int32, l_int32, l_uint32 *) as l_ok
	///  <summary>
	/// (1) Simple function to get one of four statistical values of an image.<para/>
	///
	/// (2) It does not take a mask: it uses the entire image.<para/>
	///
	/// (3) To get the average pixel value of an RGB image, suggest using
	/// pixGetPixelAverage(), which is considerably faster.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetPixelStats/*"/>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///  <param name="type">[in] - L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION, L_VARIANCE</param>
	///  <param name="pvalue">[out] - pixel value corresponding to input type</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetPixelStats (int factor,
							  int type,
							  out uint pvalue)
	{
		int RetObj = _All.pixGetPixelStats(this, factor, type, out pvalue);
		return RetObj;
	}

	// pix4.c (1361, 1)
	// pixGetAverageMaskedRGB(pixs, pixm, x, y, factor, type, prval, pgval, pbval) as int
	// pixGetAverageMaskedRGB(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_float32 *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) For usage, see pixGetAverageMasked().<para/>
	///
	/// (2) If there is a colormap, it is removed before the 8 bpp
	/// component images are extracted.<para/>
	///
	/// (3) A better name for this would be: pixGetPixelStatsRGB()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetAverageMaskedRGB/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask over which average is to be taken use all pixels if null</param>
	///  <param name="x">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0</param>
	///  <param name="y">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0</param>
	///  <param name="factor">[in] - subsampling factor greater or equal 1</param>
	///  <param name="type">[in] - L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION, L_VARIANCE</param>
	///  <param name="prval">[out][optional] - measured red value of given 'type'</param>
	///  <param name="pgval">[out][optional] - measured green value of given 'type'</param>
	///  <param name="pbval">[out][optional] - measured blue value of given 'type'</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetAverageMaskedRGB (int x,
									int y,
									int factor,
									int type,
									Pix pixm,
									out Single prval,
									out Single pgval,
									out Single pbval)
	{
		int RetObj = _All.pixGetAverageMaskedRGB(this, pixm, x, y, factor, type, out prval, out pgval, out pbval);
		return RetObj;
	}

	// pix4.c (1457, 1)
	// pixGetAverageMasked(pixs, pixm, x, y, factor, type, pval) as int
	// pixGetAverageMasked(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// (1) Use L_MEAN_ABSVAL to get the average value of pixels in pixs
	/// that are under the fg of the optional mask.  If the mask
	/// is null, it finds the average of the pixels in pixs.<para/>
	///
	/// (2) Likewise, use L_ROOT_MEAN_SQUARE to get the rms value of
	/// pixels in pixs, either masked or not L_STANDARD_DEVIATION
	/// to get the standard deviation from the mean of the pixels
	/// L_VARIANCE to get the average squared difference from the
	/// expected value.  The variance is the square of the stdev.
	/// For the standard deviation, we use
	/// sqrt([([x] - x)]^2) = sqrt([x^2] - [x]^2)<para/>
	///
	/// (3) Set the subsampling %factor  is greater  1 to reduce the amount of
	/// computation.<para/>
	///
	/// (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.<para/>
	///
	/// (5) Input x,y are ignored unless pixm exists.<para/>
	///
	/// (6) A better name for this would be: pixGetPixelStatsGray()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetAverageMasked/*"/>
	///  <param name="pixm">[in][optional] - 1 bpp mask over which average is to be taken use all pixels if null</param>
	///  <param name="x">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0</param>
	///  <param name="y">[in] - UL corner of pixm relative to the UL corner of pixs can be  is smaller 0</param>
	///  <param name="factor">[in] - subsampling factor greater or equal 1</param>
	///  <param name="type">[in] - L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION, L_VARIANCE</param>
	///  <param name="pval">[out] - measured value of given 'type'</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetAverageMasked (int x,
								 int y,
								 int factor,
								 int type,
								 out Single pval,
								 Pix pixm)
	{
		int RetObj = _All.pixGetAverageMasked(this, pixm, x, y, factor, type, out pval);
		return RetObj;
	}

	// pix4.c (1576, 1)
	// pixGetAverageTiledRGB(pixs, sx, sy, type, ppixr, ppixg, ppixb) as int
	// pixGetAverageTiledRGB(PIX *, l_int32, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) For usage, see pixGetAverageTiled().<para/>
	///
	/// (2) If there is a colormap, it is removed before the 8 bpp
	/// component images are extracted.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetAverageTiledRGB/*"/>
	///  <param name="sx">[in] - tile size must be at least 2 x 2</param>
	///  <param name="sy">[in] - tile size must be at least 2 x 2</param>
	///  <param name="type">[in] - L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION</param>
	///  <param name="ppixr">[out][optional] - tiled 'average' of red component</param>
	///  <param name="ppixg">[out][optional] - tiled 'average' of green component</param>
	///  <param name="ppixb">[out][optional] - tiled 'average' of blue component</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetAverageTiledRGB (int sx,
								   int sy,
								   int type,
								   out Pix ppixr,
								   out Pix ppixg,
								   out Pix ppixb)
	{
		int RetObj = _All.pixGetAverageTiledRGB(this, sx, sy, type, out ppixr, out ppixg, out ppixb);
		return RetObj;
	}

	// pix4.c (1653, 1)
	// pixGetAverageTiled(pixs, sx, sy, type) as Pix
	// pixGetAverageTiled(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Only computes for tiles that are entirely contained in pixs.<para/>
	///
	/// (2) Use L_MEAN_ABSVAL to get the average abs value within the tile
	/// L_ROOT_MEAN_SQUARE to get the rms value within each tile
	/// L_STANDARD_DEVIATION to get the standard dev. from the average
	/// within each tile.<para/>
	///
	/// (3) If colormapped, converts to 8 bpp gray.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetAverageTiled/*"/>
	///  <param name="sx">[in] - tile size must be at least 2 x 2</param>
	///  <param name="sy">[in] - tile size must be at least 2 x 2</param>
	///  <param name="type">[in] - L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION</param>
	///   <returns>pixd average values in each tile, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GetAverageTiled (int sx,
								int sy,
								int type)
	{
		Pix RetObj = _All.pixGetAverageTiled(this, sx, sy, type);
		return RetObj;
	}

	// pix4.c (1756, 1)
	// pixRowStats(pixs, box, pnamean, pnamedian, pnamode, pnamodecount, pnavar, pnarootvar) as int
	// pixRowStats(PIX *, BOX *, NUMA **, NUMA **, NUMA **, NUMA **, NUMA **, NUMA **) as l_int32
	///  <summary>
	/// (1) This computes numas that represent column vectors of statistics,
	/// with each of its values derived from the corresponding row of a Pix.<para/>
	///
	/// (2) Use NULL on input to prevent computation of any of the 5 numas.<para/>
	///
	/// (3) Other functions that compute pixel row statistics are:
	/// pixCountPixelsByRow()
	/// pixAverageByRow()
	/// pixVarianceByRow()
	/// pixGetRowStats()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRowStats/*"/>
	///  <param name="box">[in][optional] - clipping box can be null</param>
	///  <param name="pnamean">[out][optional] - numa of mean values</param>
	///  <param name="pnamedian">[out][optional] - numa of median values</param>
	///  <param name="pnamode">[out][optional] - numa of mode intensity values</param>
	///  <param name="pnamodecount">[out][optional] - numa of mode counts</param>
	///  <param name="pnavar">[out][optional] - numa of variance</param>
	///  <param name="pnarootvar">[out][optional] - numa of square root of variance</param>
	///   <returns>na numa of requested statistic for each row, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RowStats (Box box,
						 out Numa pnamean,
						 out Numa pnamedian,
						 out Numa pnamode,
						 out Numa pnamodecount,
						 out Numa pnavar,
						 out Numa pnarootvar)
	{
		int RetObj = _All.pixRowStats(this, box, out pnamean, out pnamedian, out pnamode, out pnamodecount, out pnavar, out pnarootvar);
		return RetObj;
	}

	// pix4.c (1916, 1)
	// pixColumnStats(pixs, box, pnamean, pnamedian, pnamode, pnamodecount, pnavar, pnarootvar) as int
	// pixColumnStats(PIX *, BOX *, NUMA **, NUMA **, NUMA **, NUMA **, NUMA **, NUMA **) as l_int32
	///  <summary>
	/// (1) This computes numas that represent row vectors of statistics,
	/// with each of its values derived from the corresponding col of a Pix.<para/>
	///
	/// (2) Use NULL on input to prevent computation of any of the 5 numas.<para/>
	///
	/// (3) Other functions that compute pixel column statistics are:
	/// pixCountPixelsByColumn()
	/// pixAverageByColumn()
	/// pixVarianceByColumn()
	/// pixGetColumnStats()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColumnStats/*"/>
	///  <param name="box">[in][optional] - clipping box can be null</param>
	///  <param name="pnamean">[out][optional] - numa of mean values</param>
	///  <param name="pnamedian">[out][optional] - numa of median values</param>
	///  <param name="pnamode">[out][optional] - numa of mode intensity values</param>
	///  <param name="pnamodecount">[out][optional] - numa of mode counts</param>
	///  <param name="pnavar">[out][optional] - numa of variance</param>
	///  <param name="pnarootvar">[out][optional] - numa of square root of variance</param>
	///   <returns>na numa of requested statistic for each column, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ColumnStats (Box box,
							out Numa pnamean,
							out Numa pnamedian,
							out Numa pnamode,
							out Numa pnamodecount,
							out Numa pnavar,
							out Numa pnarootvar)
	{
		int RetObj = _All.pixColumnStats(this, box, out pnamean, out pnamedian, out pnamode, out pnamodecount, out pnavar, out pnarootvar);
		return RetObj;
	}

	// pix4.c (2063, 1)
	// pixGetRangeValues(pixs, factor, color, pminval, pmaxval) as int
	// pixGetRangeValues(PIX *, l_int32, l_int32, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) If pixs is 8 bpp grayscale, the color selection type is ignored.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRangeValues/*"/>
	///  <param name="factor">[in] - subsampling factor greater or equal 1 ignored if colormapped</param>
	///  <param name="color">[in] - L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE</param>
	///  <param name="pminval">[out][optional] - minimum value of component</param>
	///  <param name="pmaxval">[out][optional] - maximum value of component</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRangeValues (int factor,
							   int color,
							   out int pminval,
							   out int pmaxval)
	{
		int RetObj = _All.pixGetRangeValues(this, factor, color, out pminval, out pmaxval);
		return RetObj;
	}

	// pix4.c (2141, 1)
	// pixGetExtremeValue(pixs, factor, type, prval, pgval, pbval, pgrayval) as int
	// pixGetExtremeValue(PIX *, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) If pixs is grayscale, the result is returned in [and]grayval.
	/// Otherwise, if there is a colormap or d == 32,
	/// each requested color component is returned.  At least
	/// one color component (address) must be input.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetExtremeValue/*"/>
	///  <param name="factor">[in] - subsampling factor greater or equal 1 ignored if colormapped</param>
	///  <param name="type">[in] - L_SELECT_MIN or L_SELECT_MAX</param>
	///  <param name="prval">[out][optional] - red component</param>
	///  <param name="pgval">[out][optional] - green component</param>
	///  <param name="pbval">[out][optional] - blue component</param>
	///  <param name="pgrayval">[out][optional] - min or max gray value</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetExtremeValue (int factor,
								int type,
								out int prval,
								out int pgval,
								out int pbval,
								out int pgrayval)
	{
		int RetObj = _All.pixGetExtremeValue(this, factor, type, out prval, out pgval, out pbval, out pgrayval);
		return RetObj;
	}

	// pix4.c (2278, 1)
	// pixGetMaxValueInRect(pixs, box, pmaxval, pxmax, pymax) as int
	// pixGetMaxValueInRect(PIX *, BOX *, l_uint32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This can be used to find the maximum and its location
	/// in a 2-dimensional histogram, where the x and y directions
	/// represent two color components (e.g., saturation and hue).<para/>
	///
	/// (2) Note that here a 32 bpp pixs has pixel values that are simply
	/// numbers.  They are not 8 bpp components in a colorspace.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetMaxValueInRect/*"/>
	///  <param name="box">[in][optional] - region set box = NULL to use entire pixs</param>
	///  <param name="pmaxval">[out][optional] - max value in region</param>
	///  <param name="pxmax">[out][optional] - x location of max value</param>
	///  <param name="pymax">[out][optional] - y location of max value</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMaxValueInRect (Box box,
								  out uint pmaxval,
								  out int pxmax,
								  out int pymax)
	{
		int RetObj = _All.pixGetMaxValueInRect(this, box, out pmaxval, out pxmax, out pymax);
		return RetObj;
	}

	// pix4.c (2367, 1)
	// pixGetBinnedComponentRange(pixs, nbins, factor, color, pminval, pmaxval, pcarray, fontsize) as int
	// pixGetBinnedComponentRange(PIX *, l_int32, l_int32, l_int32, l_int32 *, l_int32 *, l_uint32 **, l_int32) as l_ok
	///  <summary>
	/// (1) This returns the min and max average values of the
	/// selected color component in the set of rank bins,
	/// where the ranking is done using the specified component.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetBinnedComponentRange/*"/>
	///  <param name="nbins">[in] - number of equal population bins must be  is greater  1</param>
	///  <param name="factor">[in] - subsampling factor greater or equal 1</param>
	///  <param name="color">[in] - L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE</param>
	///  <param name="pminval">[out][optional] - minimum value of component</param>
	///  <param name="pmaxval">[out][optional] - maximum value of component</param>
	///  <param name="pcarray">[out][optional] - color array of bins</param>
	///  <param name="fontsize">[in][optional] - 0 for no debug for debug, valid set is {4,6,8,10,12,14,16,18,20}.</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetBinnedComponentRange (int nbins,
										int factor,
										int color,
										out int pminval,
										out int pmaxval,
										out Byte[] pcarray,
										int fontsize)
	{
		int RetObj = _All.pixGetBinnedComponentRange(this, nbins, factor, color, out pminval, out pmaxval, out pcarray, fontsize);
		return RetObj;
	}

	// pix4.c (2467, 1)
	// pixGetRankColorArray(pixs, nbins, type, factor, pcarray, debugflag, fontsize) as int
	// pixGetRankColorArray(PIX *, l_int32, l_int32, l_int32, l_uint32 **, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) The color selection flag is one of: L_SELECT_RED, L_SELECT_GREEN,
	/// L_SELECT_BLUE, L_SELECT_MIN, L_SELECT_MAX, L_SELECT_AVERAGE,
	/// L_SELECT_HUE, L_SELECT_SATURATION.<para/>
	///
	/// (2) Then it finds the histogram of the selected color type in each
	/// RGB pixel.  For each of the %nbins sets of pixels,
	/// ordered by this color type value, find the average RGB color,
	/// and return this as a "rank color" array.  The output array
	/// has %nbins colors.<para/>
	///
	/// (3) Set the subsampling factor  is greater  1 to reduce the amount of
	/// computation.  Typically you want at least 10,000 pixels
	/// for reasonable statistics.<para/>
	///
	/// (4) The rank color as a function of rank can then be found from
	/// rankint = (l_int32)(rank  (nbins - 1) + 0.5)
	/// extractRGBValues(array[rankint], [and]rval, [and]gval, [and]bval)
	/// where the rank is in [0.0 ... 1.0].
	/// This function is meant to be simple and approximate.<para/>
	///
	/// (5) Compare this with pixGetBinnedColor(), which generates equal
	/// width intensity bins and finds the average color in each bin.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRankColorArray/*"/>
	///  <param name="nbins">[in] - number of equal population bins must be  is greater  1</param>
	///  <param name="type">[in] - color selection flag</param>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///  <param name="pcarray">[out] - array of colors, ranked by intensity</param>
	///  <param name="debugflag">[in] - 1 to display color squares and plots of color components 2 to write them as png to file</param>
	///  <param name="fontsize">[in][optional] - 0 for no debug for debug, valid set is {4,6,8,10,12,14,16,18,20}.  Ignored if debugflag == 0.  fontsize == 6 is typical.</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRankColorArray (int nbins,
								  int type,
								  int factor,
								  out Byte[] pcarray,
								  int debugflag,
								  int fontsize)
	{
		int RetObj = _All.pixGetRankColorArray(this, nbins, type, factor, out pcarray, debugflag, fontsize);
		return RetObj;
	}

	// pix4.c (2629, 1)
	// pixGetBinnedColor(pixs, pixg, factor, nbins, nalut, pcarray, debugflag) as int
	// pixGetBinnedColor(PIX *, PIX *, l_int32, l_int32, NUMA *, l_uint32 **, l_int32) as l_ok
	///  <summary>
	/// (1) This takes a color image, a grayscale (intensity) version,
	/// a LUT from intensity to bin number, and the number of bins.
	/// It computes the average color for pixels whose intensity
	/// is in each bin.  This is returned as an array of l_uint32
	/// colors in our standard RGBA ordering.<para/>
	///
	/// (2) This function generates equal width intensity bins and
	/// finds the average color in each bin.  Compare this with
	/// pixGetRankColorArray(), which rank orders the pixels
	/// by the value of the selected component in each pixel,
	/// sets up bins with equal population (not intensity width!),
	/// and gets the average color in each bin.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetBinnedColor/*"/>
	///  <param name="pixg">[in] - 8 bpp grayscale version of pixs</param>
	///  <param name="factor">[in] - sampling factor along pixel counting direction</param>
	///  <param name="nbins">[in] - number of intensity bins</param>
	///  <param name="nalut">[in] - LUT for mapping from intensity to bin number</param>
	///  <param name="pcarray">[out] - array of average color values in each bin</param>
	///  <param name="debugflag">[in] - 1 to display output debug plots of color components 2 to write them as png to file</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetBinnedColor (Pix pixg,
							   int factor,
							   int nbins,
							   Numa nalut,
							   out Byte[] pcarray,
							   int debugflag)
	{
		int RetObj = _All.pixGetBinnedColor(this, pixg, factor, nbins, nalut, out pcarray, debugflag);
		return RetObj;
	}

	// pix4.c (2759, 1)
	// pixDisplayColorArray(carray, ncolors, side, ncols, fontsize) as Pix
	// pixDisplayColorArray(l_uint32 *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixDisplayColorArray()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDisplayColorArray/*"/>
	///  <param name="carray">[in] - array of colors: 0xrrggbb00</param>
	///  <param name="ncolors">[in] - size of array</param>
	///  <param name="side">[in] - size of each color square suggest 200</param>
	///  <param name="ncols">[in] - number of columns in output color matrix</param>
	///  <param name="fontsize">[in] - to label each square with text.  Valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	///   <returns>pixd color array, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayColorArray (Byte[] carray,
								  int ncolors,
								  int side,
								  int ncols,
								  int fontsize)
	{
		Pix RetObj = _All.pixDisplayColorArray(carray, ncolors, side, ncols, fontsize);
		return RetObj;
	}

	// pix4.c (2831, 1)
	// pixRankBinByStrip(pixs, direction, size, nbins, type) as Pix
	// pixRankBinByStrip(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This generates a pix where each column represents a strip of
	/// the input image.  If %direction == L_SCAN_HORIZONTAL, the
	/// input impage is tiled into vertical strips of width %size,
	/// where %size is a compromise between getting better spatial
	/// columnwise resolution (small %size) and getting better
	/// columnwise statistical information (larger %size).  Likewise
	/// with rows of the image if %direction == L_SCAN_VERTICAL.<para/>
	///
	/// (2) For L_HORIZONTAL_SCAN, the output pix contains rank binned
	/// median colors in each column that correspond to a vertical
	/// strip of width %size in the input image.<para/>
	///
	/// (3) The color selection flag is one of: L_SELECT_RED, L_SELECT_GREEN,
	/// L_SELECT_BLUE, L_SELECT_MIN, L_SELECT_MAX, L_SELECT_AVERAGE.
	/// It determines how the rank ordering is done.<para/>
	///
	/// (4) Typical input values might be %size = 5, %nbins = 10.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRankBinByStrip/*"/>
	///  <param name="direction">[in] - L_SCAN_HORIZONTAL or L_SCAN_VERTICAL</param>
	///  <param name="size">[in] - of strips in scan direction</param>
	///  <param name="nbins">[in] - number of equal population bins must be  is greater  1</param>
	///  <param name="type">[in] - color selection flag</param>
	///   <returns>pixd result, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RankBinByStrip (int direction,
							   int size,
							   int nbins,
							   int type)
	{
		Pix RetObj = _All.pixRankBinByStrip(this, direction, size, nbins, type);
		return RetObj;
	}

	// pix4.c (3050, 1)
	// pixGetRowStats(pixs, type, nbins, thresh, colvect) as int
	// pixGetRowStats(PIX *, l_int32, l_int32, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// (1) This computes a column vector of statistics using each
	/// row of a Pix.  The result is put in %colvect.<para/>
	///
	/// (2) The %thresh parameter works with L_MODE_VAL only, and
	/// sets a minimum occupancy of the mode bin.
	/// If the occupancy of the mode bin is less than %thresh, the
	/// mode value is returned as 0.  To always return the actual
	/// mode value, set %thresh = 0.<para/>
	///
	/// (3) What is the meaning of this %thresh parameter?
	/// For each row, the total count in the histogram is w, the
	/// image width.  So %thresh, relative to w, gives a measure
	/// of the ratio of the bin width to the width of the distribution.
	/// The larger %thresh, the narrower the distribution must be
	/// for the mode value to be returned (instead of returning 0).<para/>
	///
	/// (4) If the Pix consists of a set of corresponding columns,
	/// one for each Pix in a Pixa, the width of the Pix is the
	/// number of Pix in the Pixa and the column vector can
	/// be stored as a column in a Pix of the same size as
	/// each Pix in the Pixa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRowStats/*"/>
	///  <param name="type">[in] - L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT</param>
	///  <param name="nbins">[in] - of histogram for median and mode ignored for mean</param>
	///  <param name="thresh">[in] - on histogram for mode ignored for mean and median</param>
	///  <param name="colvect">[in] - vector of results gathered across the rows of pixs</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRowStats (int type,
							int nbins,
							int thresh,
							Single[] colvect)
	{
		int RetObj = _All.pixGetRowStats(this, type, nbins, thresh, colvect);
		return RetObj;
	}

	// pix4.c (3172, 1)
	// pixGetColumnStats(pixs, type, nbins, thresh, rowvect) as int
	// pixGetColumnStats(PIX *, l_int32, l_int32, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// (1) This computes a row vector of statistics using each
	/// column of a Pix.  The result is put in %rowvect.<para/>
	///
	/// (2) The %thresh parameter works with L_MODE_VAL only, and
	/// sets a minimum occupancy of the mode bin.
	/// If the occupancy of the mode bin is less than %thresh, the
	/// mode value is returned as 0.  To always return the actual
	/// mode value, set %thresh = 0.<para/>
	///
	/// (3) What is the meaning of this %thresh parameter?
	/// For each column, the total count in the histogram is h, the
	/// image height.  So %thresh, relative to h, gives a measure
	/// of the ratio of the bin width to the width of the distribution.
	/// The larger %thresh, the narrower the distribution must be
	/// for the mode value to be returned (instead of returning 0).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetColumnStats/*"/>
	///  <param name="type">[in] - L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT</param>
	///  <param name="nbins">[in] - of histogram for median and mode ignored for mean</param>
	///  <param name="thresh">[in] - on histogram for mode val ignored for all other types</param>
	///  <param name="rowvect">[in] - vector of results gathered down the columns of pixs</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetColumnStats (int type,
							   int nbins,
							   int thresh,
							   Single[] rowvect)
	{
		int RetObj = _All.pixGetColumnStats(this, type, nbins, thresh, rowvect);
		return RetObj;
	}

	// pix4.c (3273, 1)
	// pixSetPixelColumn(pix, col, colvect) as int
	// pixSetPixelColumn(PIX *, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// pixSetPixelColumn()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetPixelColumn/*"/>
	///  <param name="pix">[in] - 8 bpp not cmapped</param>
	///  <param name="col">[in] - column index</param>
	///  <param name="colvect">[in] - vector of floats</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetPixelColumn (Pix pix,
							   int col,
							   Single[] colvect)
	{
		int RetObj = _All.pixSetPixelColumn(pix, col, colvect);
		return RetObj;
	}

	// pix4.c (3313, 1)
	// pixThresholdForFgBg(pixs, factor, thresh, pfgval, pbgval) as int
	// pixThresholdForFgBg(PIX *, l_int32, l_int32, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixThresholdForFgBg()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixThresholdForFgBg/*"/>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///  <param name="thresh">[in] - threshold for generating foreground mask</param>
	///  <param name="pfgval">[out][optional] - average foreground value</param>
	///  <param name="pbgval">[out][optional] - average background value</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ThresholdForFgBg (int factor,
								 int thresh,
								 out int pfgval,
								 out int pbgval)
	{
		int RetObj = _All.pixThresholdForFgBg(this, factor, thresh, out pfgval, out pbgval);
		return RetObj;
	}

	// pix4.c (3372, 1)
	// pixSplitDistributionFgBg(pixs, scorefract, factor, pthresh, pfgval, pbgval, ppixdb) as int
	// pixSplitDistributionFgBg(PIX *, l_float32, l_int32, l_int32 *, l_int32 *, l_int32 *, PIX **) as l_ok
	///  <summary>
	/// (1) See numaSplitDistribution() for details on the underlying
	/// method of choosing a threshold.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSplitDistributionFgBg/*"/>
	///  <param name="scorefract">[in] - fraction of the max score, used to determine the range over which the histogram min is searched</param>
	///  <param name="factor">[in] - subsampling factor integer greater or equal 1</param>
	///  <param name="pthresh">[out][optional] - best threshold for separating</param>
	///  <param name="pfgval">[out][optional] - average foreground value</param>
	///  <param name="pbgval">[out][optional] - average background value</param>
	///  <param name="ppixdb">[out][optional] - plot of distribution and split point</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SplitDistributionFgBg (Single scorefract,
									  int factor,
									  out int pthresh,
									  out int pfgval,
									  out int pbgval,
									  out Pix ppixdb)
	{
		int RetObj = _All.pixSplitDistributionFgBg(this, scorefract, factor, out pthresh, out pfgval, out pbgval, out ppixdb);
		return RetObj;
	}

	// pix5.c (180, 1)
	// pixFindAreaPerimRatio(pixs, tab, pfract) as int
	// pixFindAreaPerimRatio(PIX *, l_int32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) The area is the number of fg pixels that are not on the
	/// boundary (i.e., are not 8-connected to a bg pixel), and the
	/// perimeter is the number of fg boundary pixels.  Returns
	/// 0.0 if there are no fg pixels.<para/>
	///
	/// (2) This function is retained because clients are using it.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindAreaPerimRatio/*"/>
	///  <param name="tab">[in][optional] - pixel sum table, can be NULL</param>
	///  <param name="pfract">[out] - area/perimeter ratio</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindAreaPerimRatio (out Single pfract,
								   int[] tab)
	{
		int RetObj = _All.pixFindAreaPerimRatio(this, tab, out pfract);
		return RetObj;
	}

	// pix5.c (281, 1)
	// pixFindPerimToAreaRatio(pixs, tab, pfract) as int
	// pixFindPerimToAreaRatio(PIX *, l_int32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) The perimeter is the number of fg boundary pixels, and the
	/// area is the number of fg pixels.  This returns 0.0 if
	/// there are no fg pixels.<para/>
	///
	/// (2) Unlike pixFindAreaPerimRatio(), this uses the full set of
	/// fg pixels for the area, and the ratio is taken in the opposite
	/// order.<para/>
	///
	/// (3) This is typically used for a single connected component.
	/// This always has a value smaller or equal 1.0, and if the average distance
	/// of a fg pixel from the nearest bg pixel is d, this has
	/// a value ~1/d.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindPerimToAreaRatio/*"/>
	///  <param name="tab">[in][optional] - pixel sum table, can be NULL</param>
	///  <param name="pfract">[out] - perimeter/area ratio</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindPerimToAreaRatio (out Single pfract,
									 int[] tab)
	{
		int RetObj = _All.pixFindPerimToAreaRatio(this, tab, out pfract);
		return RetObj;
	}

	// pix5.c (385, 1)
	// pixFindPerimSizeRatio(pixs, tab, pratio) as int
	// pixFindPerimSizeRatio(PIX *, l_int32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) We take the 'size' as twice the sum of the width and
	/// height of pixs, and the perimeter is the number of fg
	/// boundary pixels.  We use the fg pixels of the boundary
	/// because the pix may be clipped to the boundary, so an
	/// erosion is required to count all boundary pixels.<para/>
	///
	/// (2) This has a large value for dendritic, fractal-like components
	/// with highly irregular boundaries.<para/>
	///
	/// (3) This is typically used for a single connected component.
	/// It has a value of about 1.0 for rectangular components with
	/// relatively smooth boundaries.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindPerimSizeRatio/*"/>
	///  <param name="tab">[in][optional] - pixel sum table, can be NULL</param>
	///  <param name="pratio">[out] - perimeter/size ratio</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindPerimSizeRatio (out Single pratio,
								   int[] tab)
	{
		int RetObj = _All.pixFindPerimSizeRatio(this, tab, out pratio);
		return RetObj;
	}

	// pix5.c (474, 1)
	// pixFindAreaFraction(pixs, tab, pfract) as int
	// pixFindAreaFraction(PIX *, l_int32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) This finds the ratio of the number of fg pixels to the
	/// size of the pix (w  h).  It is typically used for a
	/// single connected component.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindAreaFraction/*"/>
	///  <param name="tab">[in][optional] - pixel sum table, can be NULL</param>
	///  <param name="pfract">[out] - fg area/size ratio</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindAreaFraction (out Single pfract,
								 int[] tab)
	{
		int RetObj = _All.pixFindAreaFraction(this, tab, out pfract);
		return RetObj;
	}

	// pix5.c (601, 1)
	// pixFindAreaFractionMasked(pixs, box, pixm, tab, pfract) as int
	// pixFindAreaFractionMasked(PIX *, BOX *, PIX *, l_int32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) This finds the ratio of the number of masked fg pixels
	/// in pixs to the total number of fg pixels in pixs.
	/// It is typically used for a single connected component.
	/// If there are no fg pixels, this returns a ratio of 0.0.<para/>
	///
	/// (2) The box gives the location of the pix relative to that
	/// of the UL corner of the mask.  Therefore, the rasterop
	/// is performed with the pix translated to its location
	/// (x, y) in the mask before ANDing.
	/// If box == NULL, the UL corners of pixs and pixm are aligned.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindAreaFractionMasked/*"/>
	///  <param name="box">[in][optional] - for pixs relative to pixm</param>
	///  <param name="pixm">[in] - 1 bpp mask, typically over the entire image from which the component pixs was extracted</param>
	///  <param name="tab">[in][optional] - pixel sum table, can be NULL</param>
	///  <param name="pfract">[out] - fg area/size ratio</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindAreaFractionMasked (Pix pixm,
									   out Single pfract,
									   Box box,
									   int[] tab)
	{
		int RetObj = _All.pixFindAreaFractionMasked(this, box, pixm, tab, out pfract);
		return RetObj;
	}

	// pix5.c (736, 1)
	// pixFindOverlapFraction(pixs1, pixs2, x2, y2, tab, pratio, pnoverlap) as int
	// pixFindOverlapFraction(PIX *, PIX *, l_int32, l_int32, l_int32 *, l_float32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) The UL corner of pixs2 is placed at (x2, y2) in pixs1.<para/>
	///
	/// (2) This measure is similar to the correlation.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindOverlapFraction/*"/>
	///  <param name="pixs1">[in] - 1 bpp</param>
	///  <param name="pixs2">[in] - 1 bpp</param>
	///  <param name="x2">[in] - location in pixs1 of UL corner of pixs2</param>
	///  <param name="y2">[in] - location in pixs1 of UL corner of pixs2</param>
	///  <param name="tab">[in][optional] - pixel sum table, can be null</param>
	///  <param name="pratio">[out] - ratio fg intersection to fg union</param>
	///  <param name="pnoverlap">[out][optional] - number of overlapping pixels</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindOverlapFraction (Pix pixs1,
									Pix pixs2,
									int x2,
									int y2,
									out Single pratio,
									int[] tab,
									out int pnoverlap)
	{
		int RetObj = _All.pixFindOverlapFraction(pixs1, pixs2, x2, y2, tab, out pratio, out pnoverlap);
		return RetObj;
	}

	// pix5.c (803, 1)
	// pixFindRectangleComps(pixs, dist, minw, minh) as Boxa
	// pixFindRectangleComps(PIX *, l_int32, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) This applies the function pixConformsToRectangle() to
	/// each 8-c.c. in pixs, and returns a boxa containing the
	/// regions of all components that are conforming.<para/>
	///
	/// (2) Conforming components must satisfy both the size constraint
	/// given by %minsize and the slop in conforming to a rectangle
	/// determined by %dist.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindRectangleComps/*"/>
	///  <param name="dist">[in] - max distance allowed between bounding box and nearest foreground pixel within it</param>
	///  <param name="minw">[in] - minimum size in each direction as a requirement for a conforming rectangle</param>
	///  <param name="minh">[in] - minimum size in each direction as a requirement for a conforming rectangle</param>
	///   <returns>boxa of components that conform, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa FindRectangleComps (int dist,
									int minw,
									int minh)
	{
		Boxa RetObj = _All.pixFindRectangleComps(this, dist, minw, minh);
		return RetObj;
	}

	// pix5.c (883, 1)
	// pixConformsToRectangle(pixs, box, dist, pconforms) as int
	// pixConformsToRectangle(PIX *, BOX *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) There are several ways to test if a connected component has
	/// an essentially rectangular boundary, such as:
	/// a. Fraction of fill into the bounding box
	/// b. Max-min distance of fg pixel from periphery of bounding box
	/// c. Max depth of bg intrusions into component within bounding box
	/// The weakness of (a) is that it is highly sensitive to holes
	/// within the c.c.  The weakness of (b) is that it can have
	/// arbitrarily large intrusions into the c.c.  Method (c) tests
	/// the integrity of the outer boundary of the c.c., with respect
	/// to the enclosing bounding box, so we use it.<para/>
	///
	/// (2) This tests if the connected component within the box conforms
	/// to the box at all points on the periphery within %dist.
	/// Inside, at a distance from the box boundary that is greater
	/// than %dist, we don't care about the pixels in the c.c.<para/>
	///
	/// (3) We can think of the conforming condition as follows:
	/// No pixel inside a distance %dist from the boundary
	/// can connect to the boundary through a path through the bg.
	/// To implement this, we need to do a flood fill.  We can go
	/// either from inside toward the boundary, or the other direction.
	/// It's easiest to fill from the boundary, and then verify that
	/// there are no filled pixels farther than %dist from the boundary.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConformsToRectangle/*"/>
	///  <param name="box">[in][optional] - if null, use the entire pixs</param>
	///  <param name="dist">[in] - max distance allowed between bounding box and nearest foreground pixel within it</param>
	///  <param name="pconforms">[out] - 0 (false) if not conforming 1 (true) if conforming</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConformsToRectangle (int dist,
									out int pconforms,
									Box box)
	{
		int RetObj = _All.pixConformsToRectangle(this, box, dist, out pconforms);
		return RetObj;
	}

	// pix5.c (950, 1)
	// pixClipRectangles(pixs, boxa) as Pixa
	// pixClipRectangles(PIX *, BOXA *) as PIXA *
	///  <summary>
	/// (1) The returned pixa includes the actual regions clipped out from
	/// the input pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixClipRectangles/*"/>
	///  <param name="boxa">[in] - requested clipping regions</param>
	///   <returns>pixa consisting of requested regions, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ClipRectangles (Boxa boxa)
	{
		Pixa RetObj = _All.pixClipRectangles(this, boxa);
		return RetObj;
	}

	// pix5.c (1016, 1)
	// pixClipRectangle(pixs, box, pboxc) as Pix
	// pixClipRectangle(PIX *, BOX *, BOX **) as PIX *
	///  <summary>
	/// This should be simple, but there are choices to be made.
	/// The box is defined relative to the pix coordinates.  However,
	/// if the box is not contained within the pix, we have two choices:<para/>
	///
	/// (1) clip the box to the pix<para/>
	///
	/// (2) make a new pix equal to the full box dimensions,
	/// but let rasterop do the clipping and positioning
	/// of the src with respect to the dest
	/// Choice (2) immediately brings up the problem of what pixel values
	/// to use that were not taken from the src.  For example, on a grayscale
	/// image, do you want the pixels not taken from the src to be black
	/// or white or something else?  To implement choice 2, one needs to
	/// specify the color of these extra pixels.
	/// So we adopt (1), and clip the box first, if necessary,
	/// before making the dest pix and doing the rasterop.  But there
	/// is another issue to consider.  If you want to paste the
	/// clipped pix back into pixs, it must be properly aligned, and
	/// it is necessary to use the clipped box for alignment.
	/// Accordingly, this function has a third (optional) argument, which is
	/// the input box clipped to the src pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixClipRectangle/*"/>
	///  <param name="box">[in] - requested clipping region const</param>
	///  <param name="pboxc">[out][optional] - actual box of clipped region</param>
	///   <returns>clipped pix, or NULL on error or if rectangle doesn't intersect pixs</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ClipRectangle (Box box,
							  out Box pboxc)
	{
		Pix RetObj = _All.pixClipRectangle(this, box, out pboxc);
		return RetObj;
	}

	// pix5.c (1089, 1)
	// pixClipMasked(pixs, pixm, x, y, outval) as Pix
	// pixClipMasked(PIX *, PIX *, l_int32, l_int32, l_uint32) as PIX *
	///  <summary>
	/// (1) If pixs has a colormap, it is preserved in pixd.<para/>
	///
	/// (2) The depth of pixd is the same as that of pixs.<para/>
	///
	/// (3) If the depth of pixs is 1, use %outval = 0 for white background
	/// and 1 for black otherwise, use the max value for white
	/// and 0 for black.  If pixs has a colormap, the max value for
	/// %outval is 0xffffffff otherwise, it is 2^d - 1.<para/>
	///
	/// (4) When using 1 bpp pixs, this is a simple clip and
	/// blend operation.  For example, if both pix1 and pix2 are
	/// black text on white background, and you want to OR the
	/// fg on the two images, let pixm be the inverse of pix2.
	/// Then the operation takes all of pix1 that's in the bg of
	/// pix2, and for the remainder (which are the pixels
	/// corresponding to the fg of the pix2), paint them black<para/>
	///
	/// (1) in pix1.  The function call looks like
	/// pixClipMasked(pix2, pixInvert(pix1, pix1), x, y, 1)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixClipMasked/*"/>
	///  <param name="pixm">[in] - clipping mask, 1 bpp</param>
	///  <param name="x">[in] - origin of clipping mask relative to pixs</param>
	///  <param name="y">[in] - origin of clipping mask relative to pixs</param>
	///  <param name="outval">[in] - val to use for pixels that are outside the mask</param>
	///   <returns>pixd, clipped pix or NULL on error or if pixm doesn't intersect pixs</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ClipMasked (Pix pixm,
						   int x,
						   int y,
						   uint outval)
	{
		Pix RetObj = _All.pixClipMasked(this, pixm, x, y, outval);
		return RetObj;
	}

	// pix5.c (1151, 1)
	// pixCropToMatch(pixs1, pixs2, ppixd1, ppixd2) as int
	// pixCropToMatch(PIX *, PIX *, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) This resizes pixs1 and/or pixs2 by cropping at the right
	/// and bottom, so that they're the same size.<para/>
	///
	/// (2) If a pix doesn't need to be cropped, a clone is returned.<para/>
	///
	/// (3) Note: the images are implicitly aligned to the UL corner.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCropToMatch/*"/>
	///  <param name="pixs1">[in] - any depth, colormap OK</param>
	///  <param name="pixs2">[in] - any depth, colormap OK</param>
	///  <param name="ppixd1">[out] - may be a clone</param>
	///  <param name="ppixd2">[out] - may be a clone</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CropToMatch (Pix pixs1,
							Pix pixs2,
							out Pix ppixd1,
							out Pix ppixd2)
	{
		int RetObj = _All.pixCropToMatch(pixs1, pixs2, out ppixd1, out ppixd2);
		return RetObj;
	}

	// pix5.c (1194, 1)
	// pixCropToSize(pixs, w, h) as Pix
	// pixCropToSize(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) If either w or h is smaller than the corresponding dimension
	/// of pixs, this returns a cropped image otherwise it returns
	/// a clone of pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCropToSize/*"/>
	///  <param name="w">[in] - max dimensions of cropped image</param>
	///  <param name="h">[in] - max dimensions of cropped image</param>
	///   <returns>pixd cropped if necessary or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CropToSize (int w,
						   int h)
	{
		Pix RetObj = _All.pixCropToSize(this, w, h);
		return RetObj;
	}

	// pix5.c (1248, 1)
	// pixResizeToMatch(pixs, pixt, w, h) as Pix
	// pixResizeToMatch(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This resizes pixs to make pixd, without scaling, by either
	/// cropping or extending separately in both width and height.
	/// Extension is done by replicating the last row or column.
	/// This is useful in a situation where, due to scaling
	/// operations, two images that are expected to be the
	/// same size can differ slightly in each dimension.<para/>
	///
	/// (2) You can use either an existing pixt or specify
	/// both %w and %h.  If pixt is defined, the values
	/// in %w and %h are ignored.<para/>
	///
	/// (3) If pixt is larger than pixs (or if w and/or d is larger
	/// than the dimension of pixs, replicate the outer row and
	/// column of pixels in pixs into pixd.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixResizeToMatch/*"/>
	///  <param name="pixt">[in]can be null - we use only the size</param>
	///  <param name="w">[in] - ignored if pixt is defined</param>
	///  <param name="h">[in] - ignored if pixt is defined</param>
	///   <returns>pixd resized to match or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ResizeToMatch (int w,
							  int h,
							  Pix pixt)
	{
		Pix RetObj = _All.pixResizeToMatch(this, pixt, w, h);
		return RetObj;
	}

	// pix5.c (1329, 1)
	// pixMakeFrameMask(w, h, hf1, hf2, vf1, vf2) as Pix
	// pixMakeFrameMask(l_int32, l_int32, l_float32, l_float32, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) This makes an arbitrary 1-component mask with a centered fg
	/// frame, which can have both an inner and an outer boundary.
	/// All input fractional distances are measured from the image
	/// border to the frame boundary, in units of the image half-width
	/// for hf1 and hf2 and the image half-height for vf1 and vf2.
	/// The distances to the outer frame boundary are given by hf1
	/// and vf1 to the inner frame boundary, by hf2 and vf2.
	/// Input fractions are thus in [0.0 ... 1.0], with hf1 smaller or equal hf2
	/// and vf1 smaller or equal vf2.  Horizontal and vertical frame widths are
	/// thus independently specified.<para/>
	///
	/// (2) Special cases:
	/// full fg mask: hf1 = vf1 = 0.0, hf2 = vf2 = 1.0.
	/// empty fg (zero width) mask: set  hf1 = hf2  and vf1 = vf2.
	/// fg rectangle with no hole: set hf2 = vf2 = 1.0.
	/// frame touching outer boundary: set hf1 = vf1 = 0.0.<para/>
	///
	/// (3) The vertical thickness of the horizontal mask parts
	/// is 0.5  (vf2 - vf1)  h.  The horizontal thickness of the
	/// vertical mask parts is 0.5  (hf2 - hf1)  w.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMakeFrameMask/*"/>
	///  <param name="w">[in] - dimensions of output 1 bpp pix</param>
	///  <param name="h">[in] - dimensions of output 1 bpp pix</param>
	///  <param name="hf1">[in] - horizontal fraction of half-width at outer frame bdry</param>
	///  <param name="hf2">[in] - horizontal fraction of half-width at inner frame bdry</param>
	///  <param name="vf1">[in] - vertical fraction of half-width at outer frame bdry</param>
	///  <param name="vf2">[in] - vertical fraction of half-width at inner frame bdry</param>
	///   <returns>pixd 1 bpp, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MakeFrameMask (int w,
							  int h,
							  Single hf1,
							  Single hf2,
							  Single vf1,
							  Single vf2)
	{
		Pix RetObj = _All.pixMakeFrameMask(w, h, hf1, hf2, vf1, vf2);
		return RetObj;
	}

	// pix5.c (1395, 1)
	// pixMakeCoveringOfRectangles(pixs, maxiters) as Pix
	// pixMakeCoveringOfRectangles(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This iteratively finds the bounding boxes of the connected
	/// components and generates a mask from them.  Two iterations
	/// should suffice for most situations.<para/>
	///
	/// (2) Returns an empty pix if %pixs is empty.<para/>
	///
	/// (3) If there are many small components in proximity, it may
	/// be useful to merge them with a morphological closing before
	/// calling this one.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMakeCoveringOfRectangles/*"/>
	///  <param name="maxiters">[in] - max iterations: use 0 to iterate to completion</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MakeCoveringOfRectangles (int maxiters)
	{
		Pix RetObj = _All.pixMakeCoveringOfRectangles(this, maxiters);
		return RetObj;
	}

	// pix5.c (1468, 1)
	// pixFractionFgInMask(pix1, pix2, pfract) as int
	// pixFractionFgInMask(PIX *, PIX *, l_float32 *) as l_ok
	///  <summary>
	/// (1) This gives the fraction of fg pixels in pix1 that are in
	/// the intersection (i.e., under the fg) of pix2:
	/// |1 [and] 2|/|1|, where |...| means the number of fg pixels.
	/// Note that this is different from the situation where
	/// pix1 and pix2 are reversed.<para/>
	///
	/// (2) Both pix1 and pix2 are registered to the UL corners.  A warning
	/// is issued if pix1 and pix2 have different sizes.<para/>
	///
	/// (3) This can also be used to find the fraction of fg pixels in pix1
	/// that are NOT under the fg of pix2: 1.0 - |1 [and] 2|/|1|<para/>
	///
	/// (4) If pix1 or pix2 are empty, this returns %fract = 0.0.<para/>
	///
	/// (5) For example, pix2 could be a frame around the outside of the
	/// image, made from pixMakeFrameMask().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFractionFgInMask/*"/>
	///  <param name="pix1">[in] - 1 bpp</param>
	///  <param name="pix2">[in] - 1 bpp</param>
	///  <param name="pfract">[out] - fraction of fg pixels in 1 that are aligned with the fg of 2</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int FractionFgInMask (Pix pix1,
								 Pix pix2,
								 out Single pfract)
	{
		int RetObj = _All.pixFractionFgInMask(pix1, pix2, out pfract);
		return RetObj;
	}

	// pix5.c (1524, 1)
	// pixClipToForeground(pixs, ppixd, pbox) as int
	// pixClipToForeground(PIX *, PIX **, BOX **) as l_ok
	///  <summary>
	/// (1) At least one of {[and]pixd, [and]box} must be specified.<para/>
	///
	/// (2) If there are no fg pixels, the returned ptrs are null.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixClipToForeground/*"/>
	///  <param name="ppixd">[out][optional] - clipped pix returned</param>
	///  <param name="pbox">[out][optional] - bounding box</param>
	///   <returns>0 if OK 1 on error or if there are no fg pixels</returns>
	// CreateAdditiveFunction: Function/Else
	public int ClipToForeground (out Pix ppixd,
								 out Box pbox)
	{
		int RetObj = _All.pixClipToForeground(this, out ppixd, out pbox);
		return RetObj;
	}

	// pix5.c (1624, 1)
	// pixTestClipToForeground(pixs, pcanclip) as int
	// pixTestClipToForeground(PIX *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This is a lightweight test to determine if a 1 bpp image
	/// can be further cropped without loss of fg pixels.
	/// If it cannot, canclip is set to 0.<para/>
	///
	/// (2) It does not test for the existence of any fg pixels.
	/// If there are no fg pixels, it will return %canclip = 1.
	/// Check the output of the subsequent call to pixClipToForeground().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTestClipToForeground/*"/>
	///  <param name="pcanclip">[out] - 1 if fg does not extend to all four edges</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int TestClipToForeground (out int pcanclip)
	{
		int RetObj = _All.pixTestClipToForeground(this, out pcanclip);
		return RetObj;
	}

	// pix5.c (1696, 1)
	// pixClipBoxToForeground(pixs, boxs, ppixd, pboxd) as int
	// pixClipBoxToForeground(PIX *, BOX *, PIX **, BOX **) as l_ok
	///  <summary>
	/// (1) At least one of {[and]pixd, [and]boxd} must be specified.<para/>
	///
	/// (2) If there are no fg pixels, the returned ptrs are null.<para/>
	///
	/// (3) Do not use [and]pixs for the 3rd arg or [and]boxs for the 4th arg
	/// this will leak memory.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixClipBoxToForeground/*"/>
	///  <param name="boxs">[in][optional] - use full image if null</param>
	///  <param name="ppixd">[out][optional] - clipped pix returned</param>
	///  <param name="pboxd">[out][optional] - bounding box</param>
	///   <returns>0 if OK 1 on error or if there are no fg pixels</returns>
	// CreateAdditiveFunction: Function/Else
	public int ClipBoxToForeground (Box boxs,
									out Pix ppixd,
									out Box pboxd)
	{
		int RetObj = _All.pixClipBoxToForeground(this, boxs, out ppixd, out pboxd);
		return RetObj;
	}

	// pix5.c (1762, 1)
	// pixScanForForeground(pixs, box, scanflag, ploc) as int
	// pixScanForForeground(PIX *, BOX *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) If there are no fg pixels, the position is set to 0.
	/// Caller must check the return value!<para/>
	///
	/// (2) Use %box == NULL to scan from edge of pixs
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScanForForeground/*"/>
	///  <param name="box">[in][optional] - within which the search is conducted</param>
	///  <param name="scanflag">[in] - direction of scan e.g., L_FROM_LEFT</param>
	///  <param name="ploc">[out] - location in scan direction of first black pixel</param>
	///   <returns>0 if OK 1 on error or if no fg pixels are found</returns>
	// CreateAdditiveFunction: Function/Else
	public int ScanForForeground (int scanflag,
								  out int ploc,
								  Box box)
	{
		int RetObj = _All.pixScanForForeground(this, box, scanflag, out ploc);
		return RetObj;
	}

	// pix5.c (1878, 1)
	// pixClipBoxToEdges(pixs, boxs, lowthresh, highthresh, maxwidth, factor, ppixd, pboxd) as int
	// pixClipBoxToEdges(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, PIX **, BOX **) as l_ok
	///  <summary>
	/// (1) At least one of {[and]pixd, [and]boxd} must be specified.<para/>
	///
	/// (2) If there are no fg pixels, the returned ptrs are null.<para/>
	///
	/// (3) This function attempts to locate rectangular "image" regions
	/// of high-density fg pixels, that have well-defined edges
	/// on the four sides.<para/>
	///
	/// (4) Edges are searched for on each side, iterating in order
	/// from left, right, top and bottom.  As each new edge is
	/// found, the search box is resized to use that location.
	/// Once an edge is found, it is held.  If no more edges
	/// are found in one iteration, the search fails.<para/>
	///
	/// (5) See pixScanForEdge() for usage of the thresholds and %maxwidth.<para/>
	///
	/// (6) The thresholds must be at least 1, and the low threshold
	/// cannot be larger than the high threshold.<para/>
	///
	/// (7) If the low and high thresholds are both 1, this is equivalent
	/// to pixClipBoxToForeground().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixClipBoxToEdges/*"/>
	///  <param name="boxs">[in][optional] - use full image if null</param>
	///  <param name="lowthresh">[in] - threshold to choose clipping location</param>
	///  <param name="highthresh">[in] - threshold required to find an edge</param>
	///  <param name="maxwidth">[in] - max allowed width between low and high thresh locs</param>
	///  <param name="factor">[in] - sampling factor along pixel counting direction</param>
	///  <param name="ppixd">[out][optional] - clipped pix returned</param>
	///  <param name="pboxd">[out][optional] - bounding box</param>
	///   <returns>0 if OK 1 on error or if a fg edge is not found from all four sides.</returns>
	// CreateAdditiveFunction: Function/Else
	public int ClipBoxToEdges (int lowthresh,
							   int highthresh,
							   int maxwidth,
							   int factor,
							   Box boxs,
							   out Pix ppixd,
							   out Box pboxd)
	{
		int RetObj = _All.pixClipBoxToEdges(this, boxs, lowthresh, highthresh, maxwidth, factor, out ppixd, out pboxd);
		return RetObj;
	}

	// pix5.c (2008, 1)
	// pixScanForEdge(pixs, box, lowthresh, highthresh, maxwidth, factor, scanflag, ploc) as int
	// pixScanForEdge(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) If there are no fg pixels, the position is set to 0.
	/// Caller must check the return value!<para/>
	///
	/// (2) Use %box == NULL to scan from edge of pixs<para/>
	///
	/// (3) As the scan progresses, the location where the sum of
	/// pixels equals or excees %lowthresh is noted (loc).  The
	/// scan is stopped when the sum of pixels equals or exceeds
	/// %highthresh.  If the scan distance between loc and that
	/// point does not exceed %maxwidth, an edge is found and
	/// its position is taken to be loc.  %maxwidth implicitly
	/// sets a minimum on the required gradient of the edge.<para/>
	///
	/// (4) The thresholds must be at least 1, and the low threshold
	/// cannot be larger than the high threshold.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScanForEdge/*"/>
	///  <param name="box">[in][optional] - within which the search is conducted</param>
	///  <param name="lowthresh">[in] - threshold to choose clipping location</param>
	///  <param name="highthresh">[in] - threshold required to find an edge</param>
	///  <param name="maxwidth">[in] - max allowed width between low and high thresh locs</param>
	///  <param name="factor">[in] - sampling factor along pixel counting direction</param>
	///  <param name="scanflag">[in] - direction of scan e.g., L_FROM_LEFT</param>
	///  <param name="ploc">[out] - location in scan direction of first black pixel</param>
	///   <returns>0 if OK 1 on error or if the edge is not found</returns>
	// CreateAdditiveFunction: Function/Else
	public int ScanForEdge (int lowthresh,
							int highthresh,
							int maxwidth,
							int factor,
							int scanflag,
							out int ploc,
							Box box)
	{
		int RetObj = _All.pixScanForEdge(this, box, lowthresh, highthresh, maxwidth, factor, scanflag, out ploc);
		return RetObj;
	}

	// pix5.c (2189, 1)
	// pixExtractOnLine(pixs, x1, y1, x2, y2, factor) as Numa
	// pixExtractOnLine(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) Input end points are clipped to the pix.<para/>
	///
	/// (2) If the line is either horizontal, or closer to horizontal
	/// than to vertical, the points will be extracted from left
	/// to right in the pix.  Likewise, if the line is vertical,
	/// or closer to vertical than to horizontal, the points will
	/// be extracted from top to bottom.<para/>
	///
	/// (3) Can be used with numaCountReverals(), for example, to
	/// characterize the intensity smoothness along a line.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExtractOnLine/*"/>
	///  <param name="x1">[in] - one end point for line</param>
	///  <param name="y1">[in] - one end point for line</param>
	///  <param name="x2">[in] - another end pt for line</param>
	///  <param name="y2">[in] - another end pt for line</param>
	///  <param name="factor">[in] - sampling greater or equal 1</param>
	///   <returns>na of pixel values along line, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa ExtractOnLine (int x1,
							   int y1,
							   int x2,
							   int y2,
							   int factor)
	{
		Numa RetObj = _All.pixExtractOnLine(this, x1, y1, x2, y2, factor);
		return RetObj;
	}

	// pix5.c (2309, 1)
	// pixAverageOnLine(pixs, x1, y1, x2, y2, factor) as Single
	// pixAverageOnLine(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_float32
	///  <summary>
	/// (1) The line must be either horizontal or vertical, so either
	/// y1 == y2 (horizontal) or x1 == x2 (vertical).<para/>
	///
	/// (2) If horizontal, x1 must be smaller or equal x2.
	/// If vertical, y1 must be smaller or equal y2.
	/// characterize the intensity smoothness along a line.<para/>
	///
	/// (3) Input end points are clipped to the pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAverageOnLine/*"/>
	///  <param name="x1">[in] - starting pt for line</param>
	///  <param name="y1">[in] - starting pt for line</param>
	///  <param name="x2">[in] - end pt for line</param>
	///  <param name="y2">[in] - end pt for line</param>
	///  <param name="factor">[in] - sampling greater or equal 1</param>
	///   <returns>average of pixel values along line, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Single AverageOnLine (int x1,
								 int y1,
								 int x2,
								 int y2,
								 int factor)
	{
		Single RetObj = _All.pixAverageOnLine(this, x1, y1, x2, y2, factor);
		return RetObj;
	}

	// pix5.c (2408, 1)
	// pixAverageIntensityProfile(pixs, fract, dir, first, last, factor1, factor2) as Numa
	// pixAverageIntensityProfile(PIX *, l_float32, l_int32, l_int32, l_int32, l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) If d != 1 bpp, colormaps are removed and the result
	/// is converted to 8 bpp.<para/>
	///
	/// (2) If %dir == L_HORIZONTAL_LINE, the intensity is averaged
	/// along each horizontal raster line (sampled by %factor1),
	/// and the profile is the array of these averages in the
	/// vertical direction between %first and %last raster lines,
	/// and sampled by %factor2.<para/>
	///
	/// (3) If %dir == L_VERTICAL_LINE, the intensity is averaged
	/// along each vertical line (sampled by %factor1),
	/// and the profile is the array of these averages in the
	/// horizontal direction between %first and %last columns,
	/// and sampled by %factor2.<para/>
	///
	/// (4) The averages are measured over the central %fract of the image.
	/// Use %fract == 1.0 to average across the entire width or height.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAverageIntensityProfile/*"/>
	///  <param name="fract">[in] - fraction of image width or height to be used</param>
	///  <param name="dir">[in] - averaging direction: L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
	///  <param name="first">[in] - last span of rows or columns to measure</param>
	///  <param name="factor1">[in] - sampling along fast scan direction greater or equal 1</param>
	///  <param name="factor2">[in] - sampling along slow scan direction greater or equal 1</param>
	///   <returns>na of reversal profile, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa AverageIntensityProfile (Single fract,
										 int dir,
										 int first,
										 int last,
										 int factor1,
										 int factor2)
	{
		Numa RetObj = _All.pixAverageIntensityProfile(this, fract, dir, first, last, factor1, factor2);
		return RetObj;
	}

	// pix5.c (2523, 1)
	// pixReversalProfile(pixs, fract, dir, first, last, minreversal, factor1, factor2) as Numa
	// pixReversalProfile(PIX *, l_float32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) If d != 1 bpp, colormaps are removed and the result
	/// is converted to 8 bpp.<para/>
	///
	/// (2) If %dir == L_HORIZONTAL_LINE, the the reversals are counted
	/// along each horizontal raster line (sampled by %factor1),
	/// and the profile is the array of these sums in the
	/// vertical direction between %first and %last raster lines,
	/// and sampled by %factor2.<para/>
	///
	/// (3) If %dir == L_VERTICAL_LINE, the the reversals are counted
	/// along each vertical column (sampled by %factor1),
	/// and the profile is the array of these sums in the
	/// horizontal direction between %first and %last columns,
	/// and sampled by %factor2.<para/>
	///
	/// (4) For each row or column, the reversals are summed over the
	/// central %fract of the image.  Use %fract == 1.0 to sum
	/// across the entire width (of row) or height (of column).<para/>
	///
	/// (5) %minreversal is the relative change in intensity that is
	/// required to resolve peaks and valleys.  A typical number for
	/// locating text in 8 bpp might be 50.  For 1 bpp, minreversal
	/// must be 1.<para/>
	///
	/// (6) The reversal profile is simply the number of reversals
	/// in a row or column, vs the row or column index.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReversalProfile/*"/>
	///  <param name="fract">[in] - fraction of image width or height to be used</param>
	///  <param name="dir">[in] - profile direction: L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
	///  <param name="first">[in] - span of rows or columns to measure</param>
	///  <param name="last">[in] - span of rows or columns to measure</param>
	///  <param name="minreversal">[in] - minimum change in intensity to trigger a reversal</param>
	///  <param name="factor1">[in] - sampling along raster line (fast scan) greater or equal 1</param>
	///  <param name="factor2">[in] - sampling of raster lines (slow scan) greater or equal 1</param>
	///   <returns>na of reversal profile, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa ReversalProfile (Single fract,
								 int dir,
								 int first,
								 int last,
								 int minreversal,
								 int factor1,
								 int factor2)
	{
		Numa RetObj = _All.pixReversalProfile(this, fract, dir, first, last, minreversal, factor1, factor2);
		return RetObj;
	}

	// pix5.c (2632, 1)
	// pixWindowedVarianceOnLine(pixs, dir, loc, c1, c2, size, pnad) as int
	// pixWindowedVarianceOnLine(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, NUMA **) as l_ok
	///  <summary>
	/// (1) The returned variance array traverses the line starting
	/// from the smallest coordinate, min(c1,c2).<para/>
	///
	/// (2) Line end points are clipped to pixs.<para/>
	///
	/// (3) The reference point for the variance calculation is the center of
	/// the window.  Therefore, the numa start parameter from
	/// pixExtractOnLine() is incremented by %size/2,
	/// to align the variance values with the pixel coordinate.<para/>
	///
	/// (4) The square root of the variance is the RMS deviation from the mean.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWindowedVarianceOnLine/*"/>
	///  <param name="dir">[in] - L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
	///  <param name="loc">[in] - location of the constant coordinate for the line</param>
	///  <param name="c1">[in] - end point coordinates for the line</param>
	///  <param name="c2">[in] - end point coordinates for the line</param>
	///  <param name="size">[in] - window size must be  is greater  1</param>
	///  <param name="pnad">[out] - windowed square root of variance</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WindowedVarianceOnLine (int dir,
									   int loc,
									   int c1,
									   int c2,
									   int size,
									   out Numa pnad)
	{
		int RetObj = _All.pixWindowedVarianceOnLine(this, dir, loc, c1, c2, size, out pnad);
		return RetObj;
	}

	// pix5.c (2750, 1)
	// pixMinMaxNearLine(pixs, x1, y1, x2, y2, dist, direction, pnamin, pnamax, pminave, pmaxave) as int
	// pixMinMaxNearLine(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, NUMA **, NUMA **, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) If the line is more horizontal than vertical, the values
	/// are computed for [x1, x2], and the pixels are taken
	/// below and/or above the local y-value.  Otherwise, the
	/// values are computed for [y1, y2] and the pixels are taken
	/// to the left and/or right of the local x value.<para/>
	///
	/// (2) %direction specifies which side (or both sides) of the
	/// line are scanned for min and max values.<para/>
	///
	/// (3) There are two ways to tell if the returned values of min
	/// and max averages are valid: the returned values cannot be
	/// negative and the function must return 0.<para/>
	///
	/// (4) All accessed pixels are clipped to the pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMinMaxNearLine/*"/>
	///  <param name="x1">[in] - starting pt for line</param>
	///  <param name="y1">[in] - starting pt for line</param>
	///  <param name="x2">[in] - end pt for line</param>
	///  <param name="y2">[in] - end pt for line</param>
	///  <param name="dist">[in] - distance to search from line in each direction</param>
	///  <param name="direction">[in] - L_SCAN_NEGATIVE, L_SCAN_POSITIVE, L_SCAN_BOTH</param>
	///  <param name="pnamin">[out][optional] - minimum values</param>
	///  <param name="pnamax">[out][optional] - maximum values</param>
	///  <param name="pminave">[out][optional] - average of minimum values</param>
	///  <param name="pmaxave">[out][optional] - average of maximum values</param>
	///   <returns>0 if OK 1 on error or if there are no sampled points within the image.</returns>
	// CreateAdditiveFunction: Function/Else
	public int MinMaxNearLine (int x1,
							   int y1,
							   int x2,
							   int y2,
							   int dist,
							   int direction,
							   out Numa pnamin,
							   out Numa pnamax,
							   out Single pminave,
							   out Single pmaxave)
	{
		int RetObj = _All.pixMinMaxNearLine(this, x1, y1, x2, y2, dist, direction, out pnamin, out pnamax, out pminave, out pmaxave);
		return RetObj;
	}

	// pix5.c (2873, 1)
	// pixRankRowTransform(pixs) as Pix
	// pixRankRowTransform(PIX *) as PIX *
	///  <summary>
	/// (1) The time is O(n) in the number of pixels and runs about
	/// 100 Mpixels/sec on a 3 GHz machine.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRankRowTransform/*"/>
	///   <returns>pixd with pixels sorted in each row, from min to max value</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RankRowTransform ()
	{
		Pix RetObj = _All.pixRankRowTransform(this);
		return RetObj;
	}

	// pix5.c (2926, 1)
	// pixRankColumnTransform(pixs) as Pix
	// pixRankColumnTransform(PIX *) as PIX *
	///  <summary>
	/// (1) The time is O(n) in the number of pixels and runs about
	/// 50 Mpixels/sec on a 3 GHz machine.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRankColumnTransform/*"/>
	///   <returns>pixd with pixels sorted in each column, from min to max value</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RankColumnTransform ()
	{
		Pix RetObj = _All.pixRankColumnTransform(this);
		return RetObj;
	}

	// pixafunc1.c (212, 1)
	// pixSelectBySize(pixs, width, height, connectivity, type, relation, pchanged) as Pix
	// pixSelectBySize(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32 *) as PIX *
	///  <summary>
	/// (1) The args specify constraints on the size of the
	/// components that are kept.<para/>
	///
	/// (2) If unchanged, returns a copy of pixs.  Otherwise,
	/// returns a new pix with the filtered components.<para/>
	///
	/// (3) If the selection type is L_SELECT_WIDTH, the input
	/// height is ignored, and v.v.<para/>
	///
	/// (4) To keep small components, use relation = L_SELECT_IF_LT or
	/// L_SELECT_IF_LTE.
	/// To keep large components, use relation = L_SELECT_IF_GT or
	/// L_SELECT_IF_GTE.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSelectBySize/*"/>
	///  <param name="width">[in] - threshold dimensions</param>
	///  <param name="height">[in] - threshold dimensions</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="type">[in] - L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	///  <param name="relation">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 otherwise</param>
	///   <returns>filtered pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SelectBySize (int width,
							 int height,
							 int connectivity,
							 int type,
							 int relation,
							 out int pchanged)
	{
		Pix RetObj = _All.pixSelectBySize(this, width, height, connectivity, type, relation, out pchanged);
		return RetObj;
	}

	// pixafunc1.c (446, 1)
	// pixSelectByPerimToAreaRatio(pixs, thresh, connectivity, type, pchanged) as Pix
	// pixSelectByPerimToAreaRatio(PIX *, l_float32, l_int32, l_int32, l_int32 *) as PIX *
	///  <summary>
	/// (1) The args specify constraints on the size of the
	/// components that are kept.<para/>
	///
	/// (2) If unchanged, returns a copy of pixs.  Otherwise,
	/// returns a new pix with the filtered components.<para/>
	///
	/// (3) This filters "thick" components, where a thick component
	/// is defined to have a ratio of boundary to interior pixels
	/// that is smaller than a given threshold value.<para/>
	///
	/// (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the thicker
	/// components, and L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSelectByPerimToAreaRatio/*"/>
	///  <param name="thresh">[in] - threshold ratio of fg boundary to fg pixels</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="type">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SelectByPerimToAreaRatio (Single thresh,
										 int connectivity,
										 int type,
										 out int pchanged)
	{
		Pix RetObj = _All.pixSelectByPerimToAreaRatio(this, thresh, connectivity, type, out pchanged);
		return RetObj;
	}

	// pixafunc1.c (577, 1)
	// pixSelectByPerimSizeRatio(pixs, thresh, connectivity, type, pchanged) as Pix
	// pixSelectByPerimSizeRatio(PIX *, l_float32, l_int32, l_int32, l_int32 *) as PIX *
	///  <summary>
	/// (1) The args specify constraints on the size of the
	/// components that are kept.<para/>
	///
	/// (2) If unchanged, returns a copy of pixs.  Otherwise,
	/// returns a new pix with the filtered components.<para/>
	///
	/// (3) This filters components with smooth vs. dendritic shape, using
	/// the ratio of the fg boundary pixels to the circumference of
	/// the bounding box, and comparing it to a threshold value.<para/>
	///
	/// (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the smooth
	/// boundary components, and L_SELECT_IF_GT or L_SELECT_IF_GTE
	/// to remove them.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSelectByPerimSizeRatio/*"/>
	///  <param name="thresh">[in] - threshold ratio of fg boundary to fg pixels</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="type">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SelectByPerimSizeRatio (Single thresh,
									   int connectivity,
									   int type,
									   out int pchanged)
	{
		Pix RetObj = _All.pixSelectByPerimSizeRatio(this, thresh, connectivity, type, out pchanged);
		return RetObj;
	}

	// pixafunc1.c (707, 1)
	// pixSelectByAreaFraction(pixs, thresh, connectivity, type, pchanged) as Pix
	// pixSelectByAreaFraction(PIX *, l_float32, l_int32, l_int32, l_int32 *) as PIX *
	///  <summary>
	/// (1) The args specify constraints on the amount of foreground
	/// coverage of the components that are kept.<para/>
	///
	/// (2) If unchanged, returns a copy of pixs.  Otherwise,
	/// returns a new pix with the filtered components.<para/>
	///
	/// (3) This filters components based on the fraction of fg pixels
	/// of the component in its bounding box.<para/>
	///
	/// (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
	/// with less than the threshold fraction of foreground, and
	/// L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSelectByAreaFraction/*"/>
	///  <param name="thresh">[in] - threshold ratio of fg pixels to (w  h)</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="type">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SelectByAreaFraction (Single thresh,
									 int connectivity,
									 int type,
									 out int pchanged)
	{
		Pix RetObj = _All.pixSelectByAreaFraction(this, thresh, connectivity, type, out pchanged);
		return RetObj;
	}

	// pixafunc1.c (840, 1)
	// pixSelectByWidthHeightRatio(pixs, thresh, connectivity, type, pchanged) as Pix
	// pixSelectByWidthHeightRatio(PIX *, l_float32, l_int32, l_int32, l_int32 *) as PIX *
	///  <summary>
	/// (1) The args specify constraints on the width-to-height ratio
	/// for components that are kept.<para/>
	///
	/// (2) If unchanged, returns a copy of pixs.  Otherwise,
	/// returns a new pix with the filtered components.<para/>
	///
	/// (3) This filters components based on the width-to-height ratios.<para/>
	///
	/// (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
	/// with less than the threshold ratio, and
	/// L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSelectByWidthHeightRatio/*"/>
	///  <param name="thresh">[in] - threshold ratio of width/height</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="type">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SelectByWidthHeightRatio (Single thresh,
										 int connectivity,
										 int type,
										 out int pchanged)
	{
		Pix RetObj = _All.pixSelectByWidthHeightRatio(this, thresh, connectivity, type, out pchanged);
		return RetObj;
	}

	// pixafunc1.c (1087, 1)
	// pixRemoveWithIndicator(pixs, pixa, na) as int
	// pixRemoveWithIndicator(PIX *, PIXA *, NUMA *) as l_ok
	///  <summary>
	/// (1) This complements pixAddWithIndicator(). Here, the selected
	/// components are set subtracted from pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRemoveWithIndicator/*"/>
	///  <param name="pixa">[in] - of connected components in pixs</param>
	///  <param name="na">[in] - numa indicator: remove components corresponding to 1s</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RemoveWithIndicator (Pixa pixa,
									Numa na)
	{
		int RetObj = _All.pixRemoveWithIndicator(this, pixa, na);
		return RetObj;
	}

	// pixafunc1.c (1140, 1)
	// pixAddWithIndicator(pixs, pixa, na) as int
	// pixAddWithIndicator(PIX *, PIXA *, NUMA *) as l_ok
	///  <summary>
	/// (1) This complements pixRemoveWithIndicator(). Here, the selected
	/// components are added to pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddWithIndicator/*"/>
	///  <param name="pixa">[in] - of connected components, some of which will be put into pixs</param>
	///  <param name="na">[in] - numa indicator: add components corresponding to 1s</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddWithIndicator (Pixa pixa,
								 Numa na)
	{
		int RetObj = _All.pixAddWithIndicator(this, pixa, na);
		return RetObj;
	}

	// pixarith.c (115, 1)
	// pixAddConstantGray(pixs, val) as int
	// pixAddConstantGray(PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) In-place operation.<para/>
	///
	/// (2) No clipping for 32 bpp.<para/>
	///
	/// (3) For 8 and 16 bpp, if val  is greater  0 the result is clipped
	/// to 0xff and 0xffff, rsp.<para/>
	///
	/// (4) For 8 and 16 bpp, if val  is smaller 0 the result is clipped to 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddConstantGray/*"/>
	///  <param name="val">[in] - amount to add to each pixel</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddConstantGray (int val)
	{
		int RetObj = _All.pixAddConstantGray(this, val);
		return RetObj;
	}

	// pixarith.c (186, 1)
	// pixMultConstantGray(pixs, val) as int
	// pixMultConstantGray(PIX *, l_float32) as l_ok
	///  <summary>
	/// (1) In-place operation val must be greater or equal 0.<para/>
	///
	/// (2) No clipping for 32 bpp.<para/>
	///
	/// (3) For 8 and 16 bpp, the result is clipped to 0xff and 0xffff, rsp.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMultConstantGray/*"/>
	///  <param name="val">[in] - greater or equal 0.0 amount to multiply by each pixel</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int MultConstantGray (Single val)
	{
		int RetObj = _All.pixMultConstantGray(this, val);
		return RetObj;
	}

	// pixarith.c (261, 1)
	// pixAddGray(pixd, pixs1, pixs2) as Pix
	// pixAddGray(PIX *, PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) Arithmetic addition of two 8, 16 or 32 bpp images.<para/>
	///
	/// (2) For 8 and 16 bpp, we do explicit clipping to 0xff and 0xffff,
	/// respectively.<para/>
	///
	/// (3) Alignment is to UL corner.<para/>
	///
	/// (4) There are 3 cases.  The result can go to a new dest,
	/// in-place to pixs1, or to an existing input dest:
	/// pixd == null: (src1 + src2) to new pixd
	/// pixd == pixs1:  (src1 + src2) to src1  (in-place)
	/// pixd != pixs1:  (src1 + src2) to input pixd<para/>
	///
	/// (5) pixs2 must be different from both pixd and pixs1.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddGray/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs1, or different from pixs1</param>
	///  <param name="pixs1">[in] - can be == to pixd</param>
	///  <param name="pixs2">[in] - </param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddGray (Pix pixs1,
						Pix pixs2,
						Pix pixd)
	{
		Pix RetObj = _All.pixAddGray(pixd, pixs1, pixs2);
		return RetObj;
	}

	// pixarith.c (353, 1)
	// pixSubtractGray(pixd, pixs1, pixs2) as Pix
	// pixSubtractGray(PIX *, PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) Arithmetic subtraction of two 8, 16 or 32 bpp images.<para/>
	///
	/// (2) Source pixs2 is always subtracted from source pixs1.<para/>
	///
	/// (3) Do explicit clipping to 0.<para/>
	///
	/// (4) Alignment is to UL corner.<para/>
	///
	/// (5) There are 3 cases.  The result can go to a new dest,
	/// in-place to pixs1, or to an existing input dest:
	/// (a) pixd == null (src1 - src2) to new pixd
	/// (b) pixd == pixs1  (src1 - src2) to src1  (in-place)
	/// (d) pixd != pixs1  (src1 - src2) to input pixd<para/>
	///
	/// (6) pixs2 must be different from both pixd and pixs1.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSubtractGray/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs1, or different from pixs1</param>
	///  <param name="pixs1">[in] - can be == to pixd</param>
	///  <param name="pixs2">[in] - </param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SubtractGray (Pix pixs1,
							 Pix pixs2,
							 Pix pixd)
	{
		Pix RetObj = _All.pixSubtractGray(pixd, pixs1, pixs2);
		return RetObj;
	}

	// pixarith.c (442, 1)
	// pixThresholdToValue(pixd, pixs, threshval, setval) as Pix
	// pixThresholdToValue(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// ~ operation can be in-place (pixs == pixd) or to a new pixd
	/// ~ if setval  is greater  threshval, sets pixels with a value greater or equal threshval to setval
	/// ~ if setval  is smaller threshval, sets pixels with a value smaller or equal threshval to setval
	/// ~ if setval == threshval, no-op
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixThresholdToValue/*"/>
	///  <param name="pixd">[in][optional] - if not null, must be equal to pixs</param>
	///  <param name="threshval">[in] - </param>
	///  <param name="setval">[in] - </param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ThresholdToValue (int threshval,
								 int setval,
								 Pix pixd)
	{
		Pix RetObj = _All.pixThresholdToValue(pixd, this, threshval, setval);
		return RetObj;
	}

	// pixarith.c (551, 1)
	// pixInitAccumulate(w, h, offset) as Pix
	// pixInitAccumulate(l_int32, l_int32, l_uint32) as PIX *
	///  <summary>
	/// (1) The offset must be greater or equal 0.<para/>
	///
	/// (2) The offset is used so that we can do arithmetic
	/// with negative number results on l_uint32 data it
	/// prevents the l_uint32 data from going negative.<para/>
	///
	/// (3) Because we use l_int32 intermediate data results,
	/// these should never exceed the max of l_int32 (0x7fffffff).
	/// We do not permit the offset to be above 0x40000000,
	/// which is half way between 0 and the max of l_int32.<para/>
	///
	/// (4) The same offset should be used for initialization,
	/// multiplication by a constant, and final extraction!<para/>
	///
	/// (5) If you're only adding positive values, offset can be 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixInitAccumulate/*"/>
	///  <param name="w">[in] - of accumulate array</param>
	///  <param name="h">[in] - of accumulate array</param>
	///  <param name="offset">[in] - initialize the 32 bpp to have this value not more than 0x40000000</param>
	///   <returns>pixd 32 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix InitAccumulate (int w,
							   int h,
							   uint offset)
	{
		Pix RetObj = _All.pixInitAccumulate(w, h, offset);
		return RetObj;
	}

	// pixarith.c (585, 1)
	// pixFinalAccumulate(pixs, offset, depth) as Pix
	// pixFinalAccumulate(PIX *, l_uint32, l_int32) as PIX *
	///  <summary>
	/// (1) The offset must be greater or equal 0 and should not exceed 0x40000000.<para/>
	///
	/// (2) The offset is subtracted from the src 32 bpp image<para/>
	///
	/// (3) For 8 bpp dest, the result is clipped to [0, 0xff]<para/>
	///
	/// (4) For 16 bpp dest, the result is clipped to [0, 0xffff]
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFinalAccumulate/*"/>
	///  <param name="offset">[in] - same as used for initialization</param>
	///  <param name="depth">[in] - 8, 16 or 32 bpp, of destination</param>
	///   <returns>pixd 8, 16 or 32 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FinalAccumulate (uint offset,
								int depth)
	{
		Pix RetObj = _All.pixFinalAccumulate(this, offset, depth);
		return RetObj;
	}

	// pixarith.c (662, 1)
	// pixFinalAccumulateThreshold(pixs, offset, threshold) as Pix
	// pixFinalAccumulateThreshold(PIX *, l_uint32, l_uint32) as PIX *
	///  <summary>
	/// (1) The offset must be greater or equal 0 and should not exceed 0x40000000.<para/>
	///
	/// (2) The offset is subtracted from the src 32 bpp image
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFinalAccumulateThreshold/*"/>
	///  <param name="offset">[in] - same as used for initialization</param>
	///  <param name="threshold">[in] - values less than this are set in the destination</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FinalAccumulateThreshold (uint offset,
										 uint threshold)
	{
		Pix RetObj = _All.pixFinalAccumulateThreshold(this, offset, threshold);
		return RetObj;
	}

	// pixarith.c (719, 1)
	// pixAccumulate(pixd, pixs, op) as int
	// pixAccumulate(PIX *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) This adds or subtracts each pixs value from pixd.<para/>
	///
	/// (2) This clips to the minimum of pixs and pixd, so they
	/// do not need to be the same size.<para/>
	///
	/// (3) The alignment is to the origin [UL corner] of pixs [and] pixd.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAccumulate/*"/>
	///  <param name="pixd">[in] - 32 bpp</param>
	///  <param name="op">[in] - L_ARITH_ADD or L_ARITH_SUBTRACT</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Accumulate (Pix pixd,
						   int op)
	{
		int RetObj = _All.pixAccumulate(pixd, this, op);
		return RetObj;
	}

	// pixarith.c (818, 1)
	// pixMultConstAccumulate(pixs, factor, offset) as int
	// pixMultConstAccumulate(PIX *, l_float32, l_uint32) as l_ok
	///  <summary>
	/// (1) The offset must be greater or equal 0 and should not exceed 0x40000000.<para/>
	///
	/// (2) This multiplies each pixel, relative to offset, by the input factor<para/>
	///
	/// (3) The result is returned with the offset back in place.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMultConstAccumulate/*"/>
	///  <param name="factor">[in] - </param>
	///  <param name="offset">[in] - same as used for initialization</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int MultConstAccumulate (Single factor,
									uint offset)
	{
		int RetObj = _All.pixMultConstAccumulate(this, factor, offset);
		return RetObj;
	}

	// pixarith.c (872, 1)
	// pixAbsDifference(pixs1, pixs2) as Pix
	// pixAbsDifference(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) The depth of pixs1 and pixs2 must be equal.<para/>
	///
	/// (2) Clips computation to the min size, aligning the UL corners<para/>
	///
	/// (3) For 8 and 16 bpp, assumes one gray component.<para/>
	///
	/// (4) For 32 bpp, assumes 3 color components, and ignores the
	/// LSB of each word (the alpha channel)<para/>
	///
	/// (5) Computes the absolute value of the difference between
	/// each component value.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAbsDifference/*"/>
	///  <param name="pixs1">[in] - both either 8 or 16 bpp gray, or 32 bpp RGB</param>
	///  <param name="pixs2">[in] - both either 8 or 16 bpp gray, or 32 bpp RGB</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AbsDifference (Pix pixs1,
							  Pix pixs2)
	{
		Pix RetObj = _All.pixAbsDifference(pixs1, pixs2);
		return RetObj;
	}

	// pixarith.c (969, 1)
	// pixAddRGB(pixs1, pixs2) as Pix
	// pixAddRGB(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) Clips computation to the minimum size, aligning the UL corners.<para/>
	///
	/// (2) Removes any colormap to RGB, and ignores the LSB of each
	/// pixel word (the alpha channel).<para/>
	///
	/// (3) Adds each component value, pixelwise, clipping to 255.<para/>
	///
	/// (4) This is useful to combine two images where most of the
	/// pixels are essentially black, such as in pixPerceptualDiff().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddRGB/*"/>
	///  <param name="pixs1">[in] - 32 bpp RGB, or colormapped</param>
	///  <param name="pixs2">[in] - 32 bpp RGB, or colormapped</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddRGB (Pix pixs1,
					   Pix pixs2)
	{
		Pix RetObj = _All.pixAddRGB(pixs1, pixs2);
		return RetObj;
	}

	// pixarith.c (1054, 1)
	// pixMinOrMax(pixd, pixs1, pixs2, type) as Pix
	// pixMinOrMax(PIX *, PIX *, PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This gives the min or max of two images, component-wise.<para/>
	///
	/// (2) The depth can be 8 or 16 bpp for 1 component, and 32 bpp
	/// for a 3 component image.  For 32 bpp, ignore the LSB
	/// of each word (the alpha channel)<para/>
	///
	/// (3) There are 3 cases:
	/// ~  if pixd == null, Min(src1, src2) to new pixd
	/// ~  if pixd == pixs1,  Min(src1, src2) to src1  (in-place)
	/// ~  if pixd != pixs1,  Min(src1, src2) to input pixd
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMinOrMax/*"/>
	///  <param name="pixd">[in][optional] - destination: this can be null, equal to pixs1, or different from pixs1</param>
	///  <param name="pixs1">[in] - can be == to pixd</param>
	///  <param name="pixs2">[in] - </param>
	///  <param name="type">[in] - L_CHOOSE_MIN, L_CHOOSE_MAX</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MinOrMax (Pix pixs1,
						 Pix pixs2,
						 int type,
						 Pix pixd)
	{
		Pix RetObj = _All.pixMinOrMax(pixd, pixs1, pixs2, type);
		return RetObj;
	}

	// pixarith.c (1155, 1)
	// pixMaxDynamicRange(pixs, type) as Pix
	// pixMaxDynamicRange(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Scales pixel values to fit maximally within the dest 8 bpp pixd<para/>
	///
	/// (2) Assumes the source 'pixels' are a 1-component scalar.  For
	/// a 32 bpp source, each pixel is treated as a single number --
	/// not as a 3-component rgb pixel value.<para/>
	///
	/// (3) Uses a LUT for log scaling.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMaxDynamicRange/*"/>
	///  <param name="type">[in] - L_LINEAR_SCALE or L_LOG_SCALE</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MaxDynamicRange (int type)
	{
		Pix RetObj = _All.pixMaxDynamicRange(this, type);
		return RetObj;
	}

	// pixarith.c (1343, 1)
	// pixMaxDynamicRangeRGB(pixs, type) as Pix
	// pixMaxDynamicRangeRGB(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Scales pixel values to fit maximally within a 32 bpp dest pixd<para/>
	///
	/// (2) All color components are scaled with the same factor, based
	/// on the maximum r,g or b component in the image.  This should
	/// not be used if the 32-bit value is a single number (e.g., a
	/// count in a histogram generated by pixMakeHistoHS()).<para/>
	///
	/// (3) Uses a LUT for log scaling.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMaxDynamicRangeRGB/*"/>
	///  <param name="type">[in] - L_LINEAR_SCALE or L_LOG_SCALE</param>
	///   <returns>pixd 32 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MaxDynamicRangeRGB (int type)
	{
		Pix RetObj = _All.pixMaxDynamicRangeRGB(this, type);
		return RetObj;
	}

	// pixcomp.c (537, 1)
	// pixCreateFromPixcomp(pixc) as Pix
	// pixCreateFromPixcomp(PIXC *) as PIX *
	///  <summary>
	/// pixCreateFromPixcomp()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixCreateFromPixcomp/*"/>
	///  <param name="pixc">[in] - </param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix CreateFromPixcomp (PixComp pixc)
	{
		Pix RetObj = _All.pixCreateFromPixcomp(pixc);
		return RetObj;
	}

	// pixconv.c (204, 1)
	// pixThreshold8(pixs, d, nlevels, cmapflag) as Pix
	// pixThreshold8(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This uses, by default, equally spaced "target" values
	/// that depend on the number of levels, with thresholds
	/// halfway between.  For N levels, with separation (N-1)/255,
	/// there are N-1 fixed thresholds.<para/>
	///
	/// (2) For 1 bpp destination, the number of levels can only be 2
	/// and if a cmap is made, black is (0,0,0) and white
	/// is (255,255,255), which is opposite to the convention
	/// without a colormap.<para/>
	///
	/// (3) For 1, 2 and 4 bpp, the nlevels arg is used if a colormap
	/// is made otherwise, we take the most significant bits
	/// from the src that will fit in the dest.<para/>
	///
	/// (4) For 8 bpp, the input pixs is quantized to nlevels.  The
	/// dest quantized with that mapping, either through a colormap
	/// table or directly with 8 bit values.<para/>
	///
	/// (5) Typically you should not use make a colormap for 1 bpp dest.<para/>
	///
	/// (6) This is not dithering.  Each pixel is treated independently.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixThreshold8/*"/>
	///  <param name="d">[in] - destination depth: 1, 2, 4 or 8</param>
	///  <param name="nlevels">[in] - number of levels to be used for colormap</param>
	///  <param name="cmapflag">[in] - 1 if makes colormap 0 otherwise</param>
	///   <returns>pixd thresholded with standard dest thresholds, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Threshold8 (int d,
						   int nlevels,
						   int cmapflag)
	{
		Pix RetObj = _All.pixThreshold8(this, d, nlevels, cmapflag);
		return RetObj;
	}

	// pixconv.c (272, 1)
	// pixRemoveColormapGeneral(pixs, type, ifnocmap) as Pix
	// pixRemoveColormapGeneral(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Convenience function that allows choice between returning
	/// a clone or a copy if pixs does not have a colormap.<para/>
	///
	/// (2) See pixRemoveColormap().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRemoveColormapGeneral/*"/>
	///  <param name="type">[in] - REMOVE_CMAP_TO_BINARY, REMOVE_CMAP_TO_GRAYSCALE, REMOVE_CMAP_TO_FULL_COLOR, REMOVE_CMAP_WITH_ALPHA, REMOVE_CMAP_BASED_ON_SRC</param>
	///  <param name="ifnocmap">[in] - L_CLONE, L_COPY</param>
	///   <returns>pixd always a new pix without colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RemoveColormapGeneral (int type,
									  int ifnocmap)
	{
		Pix RetObj = _All.pixRemoveColormapGeneral(this, type, ifnocmap);
		return RetObj;
	}

	// pixconv.c (322, 1)
	// pixRemoveColormap(pixs, type) as Pix
	// pixRemoveColormap(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) If pixs does not have a colormap, a clone is returned.<para/>
	///
	/// (2) Otherwise, the input pixs is restricted to 1, 2, 4 or 8 bpp.<para/>
	///
	/// (3) Use REMOVE_CMAP_TO_BINARY only on 1 bpp pix.<para/>
	///
	/// (4) For grayscale conversion from RGB, use a weighted average
	/// of RGB values, and always return an 8 bpp pix, regardless
	/// of whether the input pixs depth is 2, 4 or 8 bpp.<para/>
	///
	/// (5) REMOVE_CMAP_TO_FULL_COLOR ignores the alpha component and
	/// returns a 32 bpp pix with spp == 3 and the alpha bytes are 0.<para/>
	///
	/// (6) For REMOVE_CMAP_BASED_ON_SRC, if there is no color, this
	/// returns either a 1 bpp or 8 bpp grayscale pix.
	/// If there is color, this returns a 32 bpp pix, with either:
	/// 3 spp, if the alpha values are all 255 (opaque), or
	/// 4 spp (preserving the alpha), if any alpha values are not 255.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRemoveColormap/*"/>
	///  <param name="type">[in] - REMOVE_CMAP_TO_BINARY, REMOVE_CMAP_TO_GRAYSCALE, REMOVE_CMAP_TO_FULL_COLOR, REMOVE_CMAP_WITH_ALPHA, REMOVE_CMAP_BASED_ON_SRC</param>
	///   <returns>pixd without colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RemoveColormap (int type)
	{
		Pix RetObj = _All.pixRemoveColormap(this, type);
		return RetObj;
	}

	// pixconv.c (613, 1)
	// pixAddGrayColormap8(pixs) as int
	// pixAddGrayColormap8(PIX *) as l_ok
	///  <summary>
	/// (1) If pixs has a colormap, this is a no-op.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddGrayColormap8/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddGrayColormap8 ()
	{
		int RetObj = _All.pixAddGrayColormap8(this);
		return RetObj;
	}

	// pixconv.c (644, 1)
	// pixAddMinimalGrayColormap8(pixs) as Pix
	// pixAddMinimalGrayColormap8(PIX *) as PIX *
	///  <summary>
	/// (1) This generates a colormapped version of the input image
	/// that has the same number of colormap entries as the
	/// input image has unique gray levels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddMinimalGrayColormap8/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddMinimalGrayColormap8 ()
	{
		Pix RetObj = _All.pixAddMinimalGrayColormap8(this);
		return RetObj;
	}

	// pixconv.c (733, 1)
	// pixConvertRGBToLuminance(pixs) as Pix
	// pixConvertRGBToLuminance(PIX *) as PIX *
	///  <summary>
	/// (1) Use a standard luminance conversion.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToLuminance/*"/>
	///   <returns>8 bpp pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertRGBToLuminance ()
	{
		Pix RetObj = _All.pixConvertRGBToLuminance(this);
		return RetObj;
	}

	// pixconv.c (753, 1)
	// pixConvertRGBToGray(pixs, rwt, gwt, bwt) as Pix
	// pixConvertRGBToGray(PIX *, l_float32, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) Use a weighted average of the RGB values.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToGray/*"/>
	///  <param name="rwt">[in] - non-negative these should add to 1.0, or use 0.0 for default</param>
	///  <param name="gwt">[in] - non-negative these should add to 1.0, or use 0.0 for default</param>
	///  <param name="bwt">[in] - non-negative these should add to 1.0, or use 0.0 for default</param>
	///   <returns>8 bpp pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertRGBToGray (Single rwt,
								 Single gwt,
								 Single bwt)
	{
		Pix RetObj = _All.pixConvertRGBToGray(this, rwt, gwt, bwt);
		return RetObj;
	}

	// pixconv.c (831, 1)
	// pixConvertRGBToGrayFast(pixs) as Pix
	// pixConvertRGBToGrayFast(PIX *) as PIX *
	///  <summary>
	/// (1) This function should be used if speed of conversion
	/// is paramount, and the green channel can be used as
	/// a fair representative of the RGB intensity.  It is
	/// several times faster than pixConvertRGBToGray().<para/>
	///
	/// (2) To combine RGB to gray conversion with subsampling,
	/// use pixScaleRGBToGrayFast() instead.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToGrayFast/*"/>
	///   <returns>8 bpp pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertRGBToGrayFast ()
	{
		Pix RetObj = _All.pixConvertRGBToGrayFast(this);
		return RetObj;
	}

	// pixconv.c (887, 1)
	// pixConvertRGBToGrayMinMax(pixs, type) as Pix
	// pixConvertRGBToGrayMinMax(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This chooses various components or combinations of them,
	/// from the three RGB sample values.  In addition to choosing
	/// the min, max, and maxdiff (difference between max and min),
	/// this also allows boosting the min and max about a reference
	/// value.<para/>
	///
	/// (2) The default reference value for boosting the min and max
	/// is 200.  This can be changed with l_setNeutralBoostVal()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToGrayMinMax/*"/>
	///  <param name="type">[in] - L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF, L_CHOOSE_MIN_BOOST, L_CHOOSE_MAX_BOOST</param>
	///   <returns>8 bpp pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertRGBToGrayMinMax (int type)
	{
		Pix RetObj = _All.pixConvertRGBToGrayMinMax(this, type);
		return RetObj;
	}

	// pixconv.c (974, 1)
	// pixConvertRGBToGraySatBoost(pixs, refval) as Pix
	// pixConvertRGBToGraySatBoost(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This returns the max component value, boosted by
	/// the saturation. The maximum boost occurs where
	/// the maximum component value is equal to some reference value.
	/// This particular weighting is due to Dany Qumsiyeh.<para/>
	///
	/// (2) For gray pixels (zero saturation), this returns
	/// the intensity of any component.<para/>
	///
	/// (3) For fully saturated pixels ('fullsat'), this rises linearly
	/// with the max value and has a slope equal to 255 divided
	/// by the reference value for a max value greater than
	/// the reference value, it is clipped to 255.<para/>
	///
	/// (4) For saturation values in between, the output is a linear
	/// combination of (2) and (3), weighted by saturation.
	/// It falls between these two curves, and does not exceed 255.<para/>
	///
	/// (5) This can be useful for distinguishing an object that has nonzero
	/// saturation from a gray background.  For this, the refval
	/// should be chosen near the expected value of the background,
	/// to achieve maximum saturation boost there.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToGraySatBoost/*"/>
	///  <param name="refval">[in] - between 1 and 255 typ. less than 128</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertRGBToGraySatBoost (int refval)
	{
		Pix RetObj = _All.pixConvertRGBToGraySatBoost(this, refval);
		return RetObj;
	}

	// pixconv.c (1052, 1)
	// pixConvertRGBToGrayArb(pixs, rc, gc, bc) as Pix
	// pixConvertRGBToGrayArb(PIX *, l_float32, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) This converts to gray using an arbitrary linear combination
	/// of the rgb color components.  It differs from pixConvertToGray(),
	/// which uses only positive coefficients that sum to 1.<para/>
	///
	/// (2) The gray output values are clipped to 0 and 255.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToGrayArb/*"/>
	///  <param name="rc">[in] - arithmetic factors can be negative</param>
	///  <param name="gc">[in] - arithmetic factors can be negative</param>
	///  <param name="bc">[in] - arithmetic factors can be negative</param>
	///   <returns>8 bpp pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertRGBToGrayArb (Single rc,
									Single gc,
									Single bc)
	{
		Pix RetObj = _All.pixConvertRGBToGrayArb(this, rc, gc, bc);
		return RetObj;
	}

	// pixconv.c (1114, 1)
	// pixConvertRGBToBinaryArb(pixs, rc, gc, bc, thresh, relation) as Pix
	// pixConvertRGBToBinaryArb(PIX *, l_float32, l_float32, l_float32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This makes a 1 bpp mask from an RGB image, using an arbitrary
	/// linear combination of the rgb color components, along with
	/// a threshold and a selection choice of the gray value relative
	/// to %thresh.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToBinaryArb/*"/>
	///  <param name="rc">[in] - arithmetic factors can be negative</param>
	///  <param name="gc">[in] - arithmetic factors can be negative</param>
	///  <param name="bc">[in] - arithmetic factors can be negative</param>
	///  <param name="thresh">[in] - binarization threshold</param>
	///  <param name="relation">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///   <returns>1 bpp pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertRGBToBinaryArb (Single rc,
									  Single gc,
									  Single bc,
									  int thresh,
									  int relation)
	{
		Pix RetObj = _All.pixConvertRGBToBinaryArb(this, rc, gc, bc, thresh, relation);
		return RetObj;
	}

	// pixconv.c (1171, 1)
	// pixConvertGrayToColormap(pixs) as Pix
	// pixConvertGrayToColormap(PIX *) as PIX *
	///  <summary>
	/// (1) This is a simple interface for adding a colormap to a
	/// 2, 4 or 8 bpp grayscale image without causing any
	/// quantization.  There is some similarity to operations
	/// in grayquant.c, such as pixThresholdOn8bpp(), where
	/// the emphasis is on quantization with an arbitrary number
	/// of levels, and a colormap is an option.<para/>
	///
	/// (2) Returns a copy if pixs already has a colormap.<para/>
	///
	/// (3) For 8 bpp src, this is a lossless transformation.<para/>
	///
	/// (4) For 2 and 4 bpp src, this generates a colormap that
	/// assumes full coverage of the gray space, with equally spaced
	/// levels: 4 levels for d = 2 and 16 levels for d = 4.<para/>
	///
	/// (5) In all cases, the depth of the dest is the same as the src.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertGrayToColormap/*"/>
	///   <returns>pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertGrayToColormap ()
	{
		Pix RetObj = _All.pixConvertGrayToColormap(this);
		return RetObj;
	}

	// pixconv.c (1226, 1)
	// pixConvertGrayToColormap8(pixs, mindepth) as Pix
	// pixConvertGrayToColormap8(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Returns a copy if pixs already has a colormap.<para/>
	///
	/// (2) This is a lossless transformation there is no quantization.
	/// We compute the number of different gray values in pixs,
	/// and construct a colormap that has exactly these values.<para/>
	///
	/// (3) 'mindepth' is the minimum depth of pixd.  If mindepth == 8,
	/// pixd will always be 8 bpp.  Let the number of different
	/// gray values in pixs be ngray.  If mindepth == 4, we attempt
	/// to save pixd as a 4 bpp image, but if ngray  is greater  16,
	/// pixd must be 8 bpp.  Likewise, if mindepth == 2,
	/// the depth of pixd will be 2 if ngray smaller or equal 4 and 4 if ngray  is greater  4
	/// but smaller or equal 16.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertGrayToColormap8/*"/>
	///  <param name="mindepth">[in] - of pixd valid values are 2, 4 and 8</param>
	///   <returns>pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertGrayToColormap8 (int mindepth)
	{
		Pix RetObj = _All.pixConvertGrayToColormap8(this, mindepth);
		return RetObj;
	}

	// pixconv.c (1323, 1)
	// pixColorizeGray(pixs, color, cmapflag) as Pix
	// pixColorizeGray(PIX *, l_uint32, l_int32) as PIX *
	///  <summary>
	/// (1) This applies the specific color to the grayscale image.<para/>
	///
	/// (2) If pixs already has a colormap, it is removed to gray
	/// before colorizing.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixColorizeGray/*"/>
	///  <param name="color">[in] - 32 bit rgba pixel</param>
	///  <param name="cmapflag">[in] - 1 for result to have colormap 0 for RGB</param>
	///   <returns>pixd 8 bpp colormapped or 32 bpp rgb, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ColorizeGray (uint color,
							 int cmapflag)
	{
		Pix RetObj = _All.pixColorizeGray(this, color, cmapflag);
		return RetObj;
	}

	// pixconv.c (1412, 1)
	// pixConvertRGBToColormap(pixs, ditherflag) as Pix
	// pixConvertRGBToColormap(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This function has two relatively simple modes of color
	/// quantization:
	/// (a) If the image is made orthographically and has not more
	/// than 256 'colors' at the level 4 octcube leaves,
	/// it is quantized nearly exactly.  The ditherflag
	/// is ignored.
	/// (b) Most natural images have more than 256 different colors
	/// in that case we use adaptive octree quantization,
	/// with dithering if requested.<para/>
	///
	/// (2) If there are not more than 256 occupied level 4 octcubes,
	/// the color in the colormap that represents all pixels in
	/// one of those octcubes is given by the first pixel that
	/// falls into that octcube.<para/>
	///
	/// (3) If there are more than 256 colors, we use adaptive octree
	/// color quantization.<para/>
	///
	/// (4) Dithering gives better visual results on images where
	/// there is a color wash (a slow variation of color), but it
	/// is about twice as slow and results in significantly larger
	/// files when losslessly compressed (e.g., into png).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertRGBToColormap/*"/>
	///  <param name="ditherflag">[in] - 1 to dither, 0 otherwise</param>
	///   <returns>pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertRGBToColormap (int ditherflag)
	{
		Pix RetObj = _All.pixConvertRGBToColormap(this, ditherflag);
		return RetObj;
	}

	// pixconv.c (1477, 1)
	// pixConvertCmapTo1(pixs) as Pix
	// pixConvertCmapTo1(PIX *) as PIX *
	///  <summary>
	/// (1) This is an extreme color quantizer.  It decides which
	/// colors map to FG (black) and which to BG (white).<para/>
	///
	/// (2) This uses two heuristics to make the decision:
	/// (a) colors similar to each other are likely to be in the same class
	/// (b) there is usually much less FG than BG.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertCmapTo1/*"/>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertCmapTo1 ()
	{
		Pix RetObj = _All.pixConvertCmapTo1(this);
		return RetObj;
	}

	// pixconv.c (1588, 1)
	// pixQuantizeIfFewColors(pixs, maxcolors, mingraycolors, octlevel, ppixd) as int
	// pixQuantizeIfFewColors(PIX *, l_int32, l_int32, l_int32, PIX **) as l_ok
	///  <summary>
	/// (1) This is a wrapper that tests if the pix can be quantized
	/// with good quality using a small number of colors.  If so,
	/// it does the quantization, defining a colormap and using
	/// pixels whose value is an index into the colormap.<para/>
	///
	/// (2) If the image has color, it is quantized with 8 bpp pixels.
	/// If the image is essentially grayscale, the pixels are
	/// either 4 or 8 bpp, depending on the size of the required
	/// colormap.<para/>
	///
	/// (3) %octlevel = 4 generates a larger colormap and larger
	/// compressed image than %octlevel = 3.  If image quality is
	/// important, you should use %octlevel = 4.<para/>
	///
	/// (4) If the image already has a colormap, it returns a clone.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixQuantizeIfFewColors/*"/>
	///  <param name="maxcolors">[in] - max number of colors allowed to be returned from pixColorsForQuantization() use 0 for default</param>
	///  <param name="mingraycolors">[in] - min number of gray levels that a grayscale image is quantized to use 0 for default</param>
	///  <param name="octlevel">[in] - for octcube quantization: 3 or 4</param>
	///  <param name="ppixd">[out] - 2,4 or 8 bpp quantized null if too many colors</param>
	///   <returns>0 if OK, 1 on error or if pixs can't be quantized into a small number of colors.</returns>
	// CreateAdditiveFunction: Function/Else
	public int QuantizeIfFewColors (int maxcolors,
									int mingraycolors,
									int octlevel,
									out Pix ppixd)
	{
		int RetObj = _All.pixQuantizeIfFewColors(this, maxcolors, mingraycolors, octlevel, out ppixd);
		return RetObj;
	}

	// pixconv.c (1689, 1)
	// pixConvert16To8(pixs, type) as Pix
	// pixConvert16To8(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) With L_AUTO_BYTE, if the max pixel value is greater than 255,
	/// use the MSB otherwise, use the LSB.<para/>
	///
	/// (2) With L_CLIP_TO_FF, use min(pixel-value, 0xff) for each
	/// 16-bit src pixel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert16To8/*"/>
	///  <param name="type">[in] - L_LS_BYTE, L_MS_BYTE, L_AUTO_BYTE, L_CLIP_TO_FF</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert16To8 (int type)
	{
		Pix RetObj = _All.pixConvert16To8(this, type);
		return RetObj;
	}

	// pixconv.c (1786, 1)
	// pixConvertGrayToFalseColor(pixs, gamma) as Pix
	// pixConvertGrayToFalseColor(PIX *, l_float32) as PIX *
	///  <summary>
	/// (1) For 8 bpp input, this simply adds a colormap to the input image.<para/>
	///
	/// (2) For 16 bpp input, it first converts to 8 bpp, using the MSB,
	/// and then adds the colormap.<para/>
	///
	/// (3) The colormap is modeled after the Matlab "jet" configuration.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertGrayToFalseColor/*"/>
	///  <param name="gamma">[in] - (factor) 0.0 or 1.0 for default  is greater  1.0 for brighter 2.0 is quite nice</param>
	///   <returns>pixd 8 bpp with colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertGrayToFalseColor (Single gamma)
	{
		Pix RetObj = _All.pixConvertGrayToFalseColor(this, gamma);
		return RetObj;
	}

	// pixconv.c (1878, 1)
	// pixUnpackBinary(pixs, depth, invert) as Pix
	// pixUnpackBinary(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This function calls special cases of pixConvert1To(),
	/// for 2, 4, 8, 16 and 32 bpp destinations.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixUnpackBinary/*"/>
	///  <param name="depth">[in] - of destination: 2, 4, 8, 16 or 32 bpp</param>
	///  <param name="invert">[in] - 0:  binary 0 to grayscale 0 binary 1 to grayscale 0xff... 1:  binary 0 to grayscale 0xff... binary 1 to grayscale 0</param>
	///   <returns>pixd 2, 4, 8, 16 or 32 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix UnpackBinary (int depth,
							 int invert)
	{
		Pix RetObj = _All.pixUnpackBinary(this, depth, invert);
		return RetObj;
	}

	// pixconv.c (1943, 1)
	// pixConvert1To16(pixd, pixs, val0, val1) as Pix
	// pixConvert1To16(PIX *, PIX *, l_uint16, l_uint16) as PIX *
	///  <summary>
	/// (1) If pixd is null, a new pix is made.<para/>
	///
	/// (2) If pixd is not null, it must be of equal width and height
	/// as pixs.  It is always returned.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert1To16/*"/>
	///  <param name="pixd">[in][optional] - 16 bpp, can be null</param>
	///  <param name="val0">[in] - 16 bit value to be used for 0s in pixs</param>
	///  <param name="val1">[in] - 16 bit value to be used for 1s in pixs</param>
	///   <returns>pixd 16 bpp</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert1To16 (ushort val0,
							 ushort val1,
							 Pix pixd)
	{
		Pix RetObj = _All.pixConvert1To16(pixd, this, val0, val1);
		return RetObj;
	}

	// pixconv.c (2017, 1)
	// pixConvert1To32(pixd, pixs, val0, val1) as Pix
	// pixConvert1To32(PIX *, PIX *, l_uint32, l_uint32) as PIX *
	///  <summary>
	/// (1) If pixd is null, a new pix is made.<para/>
	///
	/// (2) If pixd is not null, it must be of equal width and height
	/// as pixs.  It is always returned.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert1To32/*"/>
	///  <param name="pixd">[in][optional] - 32 bpp, can be null</param>
	///  <param name="val0">[in] - 32 bit value to be used for 0s in pixs</param>
	///  <param name="val1">[in] - 32 bit value to be used for 1s in pixs</param>
	///   <returns>pixd 32 bpp</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert1To32 (uint val0,
							 uint val1,
							 Pix pixd)
	{
		Pix RetObj = _All.pixConvert1To32(pixd, this, val0, val1);
		return RetObj;
	}

	// pixconv.c (2080, 1)
	// pixConvert1To2Cmap(pixs) as Pix
	// pixConvert1To2Cmap(PIX *) as PIX *
	///  <summary>
	/// (1) Input 0 is mapped to (255, 255, 255) 1 is mapped to (0, 0, 0)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert1To2Cmap/*"/>
	///   <returns>pixd 2 bpp, cmapped</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert1To2Cmap ()
	{
		Pix RetObj = _All.pixConvert1To2Cmap(this);
		return RetObj;
	}

	// pixconv.c (2123, 1)
	// pixConvert1To2(pixd, pixs, val0, val1) as Pix
	// pixConvert1To2(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) If pixd is null, a new pix is made.<para/>
	///
	/// (2) If pixd is not null, it must be of equal width and height
	/// as pixs.  It is always returned.<para/>
	///
	/// (3) A simple unpacking might use val0 = 0 and val1 = 3.<para/>
	///
	/// (4) If you want a colormapped pixd, use pixConvert1To2Cmap().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert1To2/*"/>
	///  <param name="pixd">[in][optional] - 2 bpp, can be null</param>
	///  <param name="val0">[in] - 2 bit value to be used for 0s in pixs</param>
	///  <param name="val1">[in] - 2 bit value to be used for 1s in pixs</param>
	///   <returns>pixd 2 bpp</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert1To2 (int val0,
							int val1,
							Pix pixd)
	{
		Pix RetObj = _All.pixConvert1To2(pixd, this, val0, val1);
		return RetObj;
	}

	// pixconv.c (2202, 1)
	// pixConvert1To4Cmap(pixs) as Pix
	// pixConvert1To4Cmap(PIX *) as PIX *
	///  <summary>
	/// (1) Input 0 is mapped to (255, 255, 255) 1 is mapped to (0, 0, 0)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert1To4Cmap/*"/>
	///   <returns>pixd 4 bpp, cmapped</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert1To4Cmap ()
	{
		Pix RetObj = _All.pixConvert1To4Cmap(this);
		return RetObj;
	}

	// pixconv.c (2245, 1)
	// pixConvert1To4(pixd, pixs, val0, val1) as Pix
	// pixConvert1To4(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) If pixd is null, a new pix is made.<para/>
	///
	/// (2) If pixd is not null, it must be of equal width and height
	/// as pixs.  It is always returned.<para/>
	///
	/// (3) A simple unpacking might use val0 = 0 and val1 = 15, or v.v.<para/>
	///
	/// (4) If you want a colormapped pixd, use pixConvert1To4Cmap().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert1To4/*"/>
	///  <param name="pixd">[in][optional] - 4 bpp, can be null</param>
	///  <param name="val0">[in] - 4 bit value to be used for 0s in pixs</param>
	///  <param name="val1">[in] - 4 bit value to be used for 1s in pixs</param>
	///   <returns>pixd 4 bpp</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert1To4 (int val0,
							int val1,
							Pix pixd)
	{
		Pix RetObj = _All.pixConvert1To4(pixd, this, val0, val1);
		return RetObj;
	}

	// pixconv.c (2323, 1)
	// pixConvert1To8Cmap(pixs) as Pix
	// pixConvert1To8Cmap(PIX *) as PIX *
	///  <summary>
	/// (1) Input 0 is mapped to (255, 255, 255) 1 is mapped to (0, 0, 0)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert1To8Cmap/*"/>
	///   <returns>pixd 8 bpp, cmapped</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert1To8Cmap ()
	{
		Pix RetObj = _All.pixConvert1To8Cmap(this);
		return RetObj;
	}

	// pixconv.c (2366, 1)
	// pixConvert1To8(pixd, pixs, val0, val1) as Pix
	// pixConvert1To8(PIX *, PIX *, l_uint8, l_uint8) as PIX *
	///  <summary>
	/// (1) If pixd is null, a new pix is made.<para/>
	///
	/// (2) If pixd is not null, it must be of equal width and height
	/// as pixs.  It is always returned.<para/>
	///
	/// (3) A simple unpacking might use val0 = 0 and val1 = 255, or v.v.<para/>
	///
	/// (4) To have a colormap associated with the 8 bpp pixd,
	/// use pixConvert1To8Cmap().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert1To8/*"/>
	///  <param name="pixd">[in][optional] - 8 bpp, can be null</param>
	///  <param name="val0">[in] - 8 bit value to be used for 0s in pixs</param>
	///  <param name="val1">[in] - 8 bit value to be used for 1s in pixs</param>
	///   <returns>pixd 8 bpp</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert1To8 (byte val0,
							byte val1,
							Pix pixd)
	{
		Pix RetObj = _All.pixConvert1To8(pixd, this, val0, val1);
		return RetObj;
	}

	// pixconv.c (2456, 1)
	// pixConvert2To8(pixs, val0, val1, val2, val3, cmapflag) as Pix
	// pixConvert2To8(PIX *, l_uint8, l_uint8, l_uint8, l_uint8, l_int32) as PIX *
	///  <summary>
	/// ~ A simple unpacking might use val0 = 0,
	/// val1 = 85 (0x55), val2 = 170 (0xaa), val3 = 255.
	/// ~ If cmapflag is TRUE:
	/// ~ The 8 bpp image is made with a colormap.
	/// ~ If pixs has a colormap, the input values are ignored and
	/// the 8 bpp image is made using the colormap
	/// ~ If pixs does not have a colormap, the input values are
	/// used to build the colormap.
	/// ~ If cmapflag is FALSE:
	/// ~ The 8 bpp image is made without a colormap.
	/// ~ If pixs has a colormap, the input values are ignored,
	/// the colormap is removed, and the values stored in the 8 bpp
	/// image are from the colormap.
	/// ~ If pixs does not have a colormap, the input values are
	/// used to populate the 8 bpp image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert2To8/*"/>
	///  <param name="val0">[in] - 8 bit value to be used for 00 in pixs</param>
	///  <param name="val1">[in] - 8 bit value to be used for 01 in pixs</param>
	///  <param name="val2">[in] - 8 bit value to be used for 10 in pixs</param>
	///  <param name="val3">[in] - 8 bit value to be used for 11 in pixs</param>
	///  <param name="cmapflag">[in] - TRUE if pixd is to have a colormap FALSE otherwise</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert2To8 (byte val0,
							byte val1,
							byte val2,
							byte val3,
							int cmapflag)
	{
		Pix RetObj = _All.pixConvert2To8(this, val0, val1, val2, val3, cmapflag);
		return RetObj;
	}

	// pixconv.c (2567, 1)
	// pixConvert4To8(pixs, cmapflag) as Pix
	// pixConvert4To8(PIX *, l_int32) as PIX *
	///  <summary>
	/// ~ If cmapflag is TRUE:
	/// ~ pixd is made with a colormap.
	/// ~ If pixs has a colormap, it is copied and the colormap
	/// index values are placed in pixd.
	/// ~ If pixs does not have a colormap, a colormap with linear
	/// trc is built and the pixel values in pixs are placed in
	/// pixd as colormap index values.
	/// ~ If cmapflag is FALSE:
	/// ~ pixd is made without a colormap.
	/// ~ If pixs has a colormap, it is removed and the values stored
	/// in pixd are from the colormap (converted to gray).
	/// ~ If pixs does not have a colormap, the pixel values in pixs
	/// are used, with shift replication, to populate pixd.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert4To8/*"/>
	///  <param name="cmapflag">[in] - TRUE if pixd is to have a colormap FALSE otherwise</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert4To8 (int cmapflag)
	{
		Pix RetObj = _All.pixConvert4To8(this, cmapflag);
		return RetObj;
	}

	// pixconv.c (2652, 1)
	// pixConvert8To16(pixs, leftshift) as Pix
	// pixConvert8To16(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) For left shift of 8, the 8 bit value is replicated in both
	/// the MSB and the LSB of the pixels in pixd.  That way, we get
	/// proportional mapping, with a correct map from 8 bpp white
	/// (0xff) to 16 bpp white (0xffff).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert8To16/*"/>
	///  <param name="leftshift">[in] - number of bits: 0 is no shift 8 replicates in MSB and LSB of dest</param>
	///   <returns>pixd 16 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert8To16 (int leftshift)
	{
		Pix RetObj = _All.pixConvert8To16(this, leftshift);
		return RetObj;
	}

	// pixconv.c (2718, 1)
	// pixConvertTo2(pixs) as Pix
	// pixConvertTo2(PIX *) as PIX *
	///  <summary>
	/// (1) This is a top-level function, with simple default values
	/// used in pixConvertTo8() if unpacking is necessary.<para/>
	///
	/// (2) Any existing colormap is removed the result is always gray.<para/>
	///
	/// (3) If the input image has 2 bpp and no colormap, the operation is
	/// lossless and a copy is returned.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertTo2/*"/>
	///   <returns>pixd   2 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertTo2 ()
	{
		Pix RetObj = _All.pixConvertTo2(this);
		return RetObj;
	}

	// pixconv.c (2770, 1)
	// pixConvert8To2(pix) as Pix
	// pixConvert8To2(PIX *) as PIX *
	///  <summary>
	/// (1) Any existing colormap is removed to gray.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert8To2/*"/>
	///  <param name="pix">[in] - 8 bpp colormap OK</param>
	///   <returns>pixd  2 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert8To2 (Pix pix)
	{
		Pix RetObj = _All.pixConvert8To2(pix);
		return RetObj;
	}

	// pixconv.c (2826, 1)
	// pixConvertTo4(pixs) as Pix
	// pixConvertTo4(PIX *) as PIX *
	///  <summary>
	/// (1) This is a top-level function, with simple default values
	/// used in pixConvertTo8() if unpacking is necessary.<para/>
	///
	/// (2) Any existing colormap is removed the result is always gray.<para/>
	///
	/// (3) If the input image has 4 bpp and no colormap, the operation is
	/// lossless and a copy is returned.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertTo4/*"/>
	///   <returns>pixd   4 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertTo4 ()
	{
		Pix RetObj = _All.pixConvertTo4(this);
		return RetObj;
	}

	// pixconv.c (2878, 1)
	// pixConvert8To4(pix) as Pix
	// pixConvert8To4(PIX *) as PIX *
	///  <summary>
	/// (1) Any existing colormap is removed to gray.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert8To4/*"/>
	///  <param name="pix">[in] - 8 bpp colormap OK</param>
	///   <returns>pixd  4 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert8To4 (Pix pix)
	{
		Pix RetObj = _All.pixConvert8To4(pix);
		return RetObj;
	}

	// pixconv.c (2933, 1)
	// pixConvertTo1(pixs, threshold) as Pix
	// pixConvertTo1(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This is a top-level function, with simple default values
	/// used in pixConvertTo8() if unpacking is necessary.<para/>
	///
	/// (2) Any existing colormap is removed.<para/>
	///
	/// (3) If the input image has 1 bpp and no colormap, the operation is
	/// lossless and a copy is returned.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertTo1/*"/>
	///  <param name="threshold">[in] - for final binarization, relative to 8 bpp</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertTo1 (int threshold)
	{
		Pix RetObj = _All.pixConvertTo1(this, threshold);
		return RetObj;
	}

	// pixconv.c (2989, 1)
	// pixConvertTo1BySampling(pixs, factor, threshold) as Pix
	// pixConvertTo1BySampling(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This is a quick and dirty, top-level converter.<para/>
	///
	/// (2) See pixConvertTo1() for default values.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertTo1BySampling/*"/>
	///  <param name="factor">[in] - submsampling factor integer greater or equal 1</param>
	///  <param name="threshold">[in] - for final binarization, relative to 8 bpp</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertTo1BySampling (int factor,
									 int threshold)
	{
		Pix RetObj = _All.pixConvertTo1BySampling(this, factor, threshold);
		return RetObj;
	}

	// pixconv.c (3041, 1)
	// pixConvertTo8(pixs, cmapflag) as Pix
	// pixConvertTo8(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This is a top-level function, with simple default values
	/// for unpacking.<para/>
	///
	/// (2) The result, pixd, is made with a colormap if specified.
	/// It is always a new image -- never a clone.  For example,
	/// if d == 8, and cmapflag matches the existence of a cmap
	/// in pixs, the operation is lossless and it returns a copy.<para/>
	///
	/// (3) The default values used are:
	/// ~ 1 bpp: val0 = 255, val1 = 0
	/// ~ 2 bpp: 4 bpp:  even increments over dynamic range
	/// ~ 8 bpp: lossless if cmap matches cmapflag
	/// ~ 16 bpp: use most significant byte<para/>
	///
	/// (4) If 32 bpp RGB, this is converted to gray.  If you want
	/// to do color quantization, you must specify the type
	/// explicitly, using the color quantization code.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertTo8/*"/>
	///  <param name="cmapflag">[in] - TRUE if pixd is to have a colormap FALSE otherwise</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertTo8 (int cmapflag)
	{
		Pix RetObj = _All.pixConvertTo8(this, cmapflag);
		return RetObj;
	}

	// pixconv.c (3105, 1)
	// pixConvertTo8BySampling(pixs, factor, cmapflag) as Pix
	// pixConvertTo8BySampling(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This is a fast, quick/dirty, top-level converter.<para/>
	///
	/// (2) See pixConvertTo8() for default values.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertTo8BySampling/*"/>
	///  <param name="factor">[in] - submsampling factor integer greater or equal 1</param>
	///  <param name="cmapflag">[in] - TRUE if pixd is to have a colormap FALSE otherwise</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertTo8BySampling (int factor,
									 int cmapflag)
	{
		Pix RetObj = _All.pixConvertTo8BySampling(this, factor, cmapflag);
		return RetObj;
	}

	// pixconv.c (3149, 1)
	// pixConvertTo8Colormap(pixs, dither) as Pix
	// pixConvertTo8Colormap(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This is a top-level function, with simple default values
	/// for unpacking.<para/>
	///
	/// (2) The result, pixd, is always made with a colormap.<para/>
	///
	/// (3) If d == 8, the operation is lossless and it returns a copy.<para/>
	///
	/// (4) The default values used for increasing depth are:
	/// ~ 1 bpp: val0 = 255, val1 = 0
	/// ~ 2 bpp: 4 bpp:  even increments over dynamic range<para/>
	///
	/// (5) For 16 bpp, use the most significant byte.<para/>
	///
	/// (6) For 32 bpp RGB, use octcube quantization with optional dithering.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertTo8Colormap/*"/>
	///  <param name="dither">[in] - 1 to dither if necessary 0 otherwise</param>
	///   <returns>pixd 8 bpp, cmapped, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertTo8Colormap (int dither)
	{
		Pix RetObj = _All.pixConvertTo8Colormap(this, dither);
		return RetObj;
	}

	// pixconv.c (3184, 1)
	// pixConvertTo16(pixs) as Pix
	// pixConvertTo16(PIX *) as PIX *
	///  <summary>
	/// pixConvertTo16()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertTo16/*"/>
	///   <returns>pixd 16 bpp, or NULL on error Usage: Top-level function, with simple default values for unpacking. 1 bpp:  val0 = 0xffff, val1 = 0 8 bpp:  replicates the 8 bit value in both the MSB and LSB of the 16 bit pixel.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertTo16 ()
	{
		Pix RetObj = _All.pixConvertTo16(this);
		return RetObj;
	}

	// pixconv.c (3233, 1)
	// pixConvertTo32(pixs) as Pix
	// pixConvertTo32(PIX *) as PIX *
	///  <summary>
	/// (1) Never returns a clone of pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertTo32/*"/>
	///   <returns>pixd 32 bpp, or NULL on error Usage: Top-level function, with simple default values for unpacking. 1 bpp:  val0 = 255, val1 = 0 and then replication into R, G and B components 2 bpp:  if colormapped, use the colormap values otherwise, use val0 = 0, val1 = 0x55, val2 = 0xaa, val3 = 255 and replicate gray into R, G and B components 4 bpp:  if colormapped, use the colormap values otherwise, replicate 2 nybs into a byte, and then into R,G,B components 8 bpp:  if colormapped, use the colormap values otherwise, replicate gray values into R, G and B components 16 bpp: replicate MSB into R, G and B components 24 bpp: unpack the pixels, maintaining word alignment on each scanline 32 bpp: makes a copy</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertTo32 ()
	{
		Pix RetObj = _All.pixConvertTo32(this);
		return RetObj;
	}

	// pixconv.c (3288, 1)
	// pixConvertTo32BySampling(pixs, factor) as Pix
	// pixConvertTo32BySampling(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This is a fast, quick/dirty, top-level converter.<para/>
	///
	/// (2) See pixConvertTo32() for default values.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertTo32BySampling/*"/>
	///  <param name="factor">[in] - submsampling factor integer greater or equal 1</param>
	///   <returns>pixd 32 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertTo32BySampling (int factor)
	{
		Pix RetObj = _All.pixConvertTo32BySampling(this, factor);
		return RetObj;
	}

	// pixconv.c (3323, 1)
	// pixConvert8To32(pixs) as Pix
	// pixConvert8To32(PIX *) as PIX *
	///  <summary>
	/// (1) If there is no colormap, replicates the gray value
	/// into the 3 MSB of the dest pixel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert8To32/*"/>
	///   <returns>32 bpp rgb pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert8To32 ()
	{
		Pix RetObj = _All.pixConvert8To32(this);
		return RetObj;
	}

	// pixconv.c (3393, 1)
	// pixConvertTo8Or32(pixs, copyflag, warnflag) as Pix
	// pixConvertTo8Or32(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) If there is a colormap, the colormap is removed to 8 or 32 bpp,
	/// depending on whether the colors in the colormap are all gray.<para/>
	///
	/// (2) If the input is either rgb or 8 bpp without a colormap,
	/// this returns either a clone or a copy, depending on %copyflag.<para/>
	///
	/// (3) Otherwise, the pix is converted to 8 bpp grayscale.
	/// In all cases, pixd does not have a colormap.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertTo8Or32/*"/>
	///  <param name="copyflag">[in] - L_CLONE or L_COPY</param>
	///  <param name="warnflag">[in] - 1 to issue warning if colormap is removed else 0</param>
	///   <returns>pixd 8 bpp grayscale or 32 bpp rgb, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertTo8Or32 (int copyflag,
							   int warnflag)
	{
		Pix RetObj = _All.pixConvertTo8Or32(this, copyflag, warnflag);
		return RetObj;
	}

	// pixconv.c (3456, 1)
	// pixConvert24To32(pixs) as Pix
	// pixConvert24To32(PIX *) as PIX *
	///  <summary>
	/// (1) 24 bpp rgb pix are not supported in leptonica, except for a small
	/// number of formatted write operations.  The data is a byte array,
	/// with pixels in order r,g,b, and padded to 32 bit boundaries
	/// in each line.<para/>
	///
	/// (2) Because 24 bpp rgb pix are conveniently generated by programs
	/// such as xpdf (which has SplashBitmaps that store the raster
	/// data in consecutive 24-bit rgb pixels), it is useful to provide
	/// 24 bpp pix that simply incorporate that data.  The only things
	/// we can do with these are:
	/// (a) write them to file in png, jpeg, tiff and pnm
	/// (b) interconvert between 24 and 32 bpp in memory (for testing).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert24To32/*"/>
	///   <returns>pixd 32 bpp rgb, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert24To32 ()
	{
		Pix RetObj = _All.pixConvert24To32(this);
		return RetObj;
	}

	// pixconv.c (3506, 1)
	// pixConvert32To24(pixs) as Pix
	// pixConvert32To24(PIX *) as PIX *
	///  <summary>
	/// (1) See pixconvert24To32().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert32To24/*"/>
	///   <returns>pixd 24 bpp rgb, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert32To24 ()
	{
		Pix RetObj = _All.pixConvert32To24(this);
		return RetObj;
	}

	// pixconv.c (3559, 1)
	// pixConvert32To16(pixs, type) as Pix
	// pixConvert32To16(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) The data in pixs is typically used for labelling.
	/// It is an array of l_uint32 values, not rgb or rgba.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert32To16/*"/>
	///  <param name="type">[in] - L_LS_TWO_BYTES, L_MS_TWO_BYTES, L_CLIP_TO_FFFF</param>
	///   <returns>pixd 16 bpp , or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert32To16 (int type)
	{
		Pix RetObj = _All.pixConvert32To16(this, type);
		return RetObj;
	}

	// pixconv.c (3623, 1)
	// pixConvert32To8(pixs, type16, type8) as Pix
	// pixConvert32To8(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixConvert32To8()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvert32To8/*"/>
	///  <param name="type16">[in] - L_LS_TWO_BYTES, L_MS_TWO_BYTES, L_CLIP_TO_FFFF</param>
	///  <param name="type8">[in] - L_LS_BYTE, L_MS_BYTE, L_CLIP_TO_FF</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Convert32To8 (int type16,
							 int type8)
	{
		Pix RetObj = _All.pixConvert32To8(this, type16, type8);
		return RetObj;
	}

	// pixconv.c (3662, 1)
	// pixRemoveAlpha(pixs) as Pix
	// pixRemoveAlpha(PIX *) as PIX *
	///  <summary>
	/// (1) This is a wrapper on pixAlphaBlendUniform()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRemoveAlpha/*"/>
	///   <returns>pixd        if 32 bpp rgba, pixs blended over a white background a clone of pixs otherwise, and NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RemoveAlpha ()
	{
		Pix RetObj = _All.pixRemoveAlpha(this);
		return RetObj;
	}

	// pixconv.c (3699, 1)
	// pixAddAlphaTo1bpp(pixd, pixs) as Pix
	// pixAddAlphaTo1bpp(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) We don't use 1 bpp colormapped images with alpha in leptonica,
	/// but we support generating them (here), writing to png, and reading
	/// the png.  On reading, they are converted to 32 bpp RGBA.<para/>
	///
	/// (2) The background (0) pixels in pixs become fully transparent, and the
	/// foreground (1) pixels are fully opaque.  Thus, pixd is a 1 bpp
	/// representation of a stencil, that can be used to paint over pixels
	/// of a backing image that are masked by the foreground in pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddAlphaTo1bpp/*"/>
	///  <param name="pixd">[in][optional] - 1 bpp, can be null or equal to pixs</param>
	///   <returns>pixd 1 bpp with colormap and non-opaque alpha, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddAlphaTo1bpp (Pix pixd)
	{
		Pix RetObj = _All.pixAddAlphaTo1bpp(pixd, this);
		return RetObj;
	}

	// pixconv.c (3741, 1)
	// pixConvertLossless(pixs, d) as Pix
	// pixConvertLossless(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This is a lossless unpacking (depth-increasing)
	/// conversion.  If ds is the depth of pixs, then
	/// ~ if d  is smaller ds, returns NULL
	/// ~ if d == ds, returns a copy
	/// ~ if d  is greater  ds, does the unpacking conversion<para/>
	///
	/// (2) If pixs has a colormap, this is an error.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertLossless/*"/>
	///  <param name="d">[in] - destination depth: 2, 4 or 8</param>
	///   <returns>pixd 2, 4 or 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertLossless (int d)
	{
		Pix RetObj = _All.pixConvertLossless(this, d);
		return RetObj;
	}

	// pixconv.c (3832, 1)
	// pixConvertForPSWrap(pixs) as Pix
	// pixConvertForPSWrap(PIX *) as PIX *
	///  <summary>
	/// (1) For wrapping in PostScript, we convert pixs to
	/// 1 bpp, 8 bpp (gray) and 32 bpp (RGB color).<para/>
	///
	/// (2) Colormaps are removed.  For pixs with colormaps, the
	/// images are converted to either 8 bpp gray or 32 bpp
	/// RGB, depending on whether the colormap has color content.<para/>
	///
	/// (3) Images without colormaps, that are not 1 bpp or 32 bpp,
	/// are converted to 8 bpp gray.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertForPSWrap/*"/>
	///   <returns>pixd    1, 8, or 32 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertForPSWrap ()
	{
		Pix RetObj = _All.pixConvertForPSWrap(this);
		return RetObj;
	}

	// pixconv.c (3911, 1)
	// pixConvertToSubpixelRGB(pixs, scalex, scaley, order) as Pix
	// pixConvertToSubpixelRGB(PIX *, l_float32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) If pixs has a colormap, it is removed based on its contents
	/// to either 8 bpp gray or rgb.<para/>
	///
	/// (2) For horizontal subpixel splitting, the input image
	/// is rescaled by %scaley vertically and by 3.0 times
	/// %scalex horizontally.  Then each horizontal triplet
	/// of pixels is mapped back to a single rgb pixel, with the
	/// r, g and b values being assigned based on the pixel triplet.
	/// For gray triplets, the r, g, and b values are set equal to
	/// the three gray values.  For color triplets, the r, g and b
	/// values are set equal to the components from the appropriate
	/// subpixel.  Vertical subpixel splitting is handled similarly.<para/>
	///
	/// (3) See pixConvertGrayToSubpixelRGB() and
	/// pixConvertColorToSubpixelRGB() for further details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertToSubpixelRGB/*"/>
	///  <param name="scalex">[in] - anisotropic scaling permitted between source and destination</param>
	///  <param name="scaley">[in] - anisotropic scaling permitted between source and destination</param>
	///  <param name="order">[in] - of subpixel rgb color components in composition of pixd: L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR, L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR</param>
	///   <returns>pixd 32 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertToSubpixelRGB (int order,
									 Single scalex,
									 Single scaley)
	{
		Pix RetObj = _All.pixConvertToSubpixelRGB(this, scalex, scaley, order);
		return RetObj;
	}

	// pixconv.c (3981, 1)
	// pixConvertGrayToSubpixelRGB(pixs, scalex, scaley, order) as Pix
	// pixConvertGrayToSubpixelRGB(PIX *, l_float32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) If pixs has a colormap, it is removed to 8 bpp.<para/>
	///
	/// (2) For horizontal subpixel splitting, the input gray image
	/// is rescaled by %scaley vertically and by 3.0 times
	/// %scalex horizontally.  Then each horizontal triplet
	/// of pixels is mapped back to a single rgb pixel, with the
	/// r, g and b values being assigned from the triplet of gray values.
	/// Similar operations are used for vertical subpixel splitting.<para/>
	///
	/// (3) This is a form of subpixel rendering that tends to give the
	/// resulting text a sharper and somewhat chromatic display.
	/// For horizontal subpixel splitting, the observable difference
	/// between %order=L_SUBPIXEL_ORDER_RGB and
	/// %order=L_SUBPIXEL_ORDER_BGR is reduced by optical diffusers
	/// in the display that make the pixel color appear to emerge
	/// from the entire pixel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertGrayToSubpixelRGB/*"/>
	///  <param name="scalex">[in] - </param>
	///  <param name="scaley">[in] - </param>
	///  <param name="order">[in] - of subpixel rgb color components in composition of pixd: L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR, L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR</param>
	///   <returns>pixd 32 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertGrayToSubpixelRGB (int order,
										 Single scalex,
										 Single scaley)
	{
		Pix RetObj = _All.pixConvertGrayToSubpixelRGB(this, scalex, scaley, order);
		return RetObj;
	}

	// pixconv.c (4086, 1)
	// pixConvertColorToSubpixelRGB(pixs, scalex, scaley, order) as Pix
	// pixConvertColorToSubpixelRGB(PIX *, l_float32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) If pixs has a colormap, it is removed to 32 bpp rgb.
	/// If the colormap has no color, pixConvertGrayToSubpixelRGB()
	/// should be called instead, because it will give the same result
	/// more efficiently.  The function pixConvertToSubpixelRGB()
	/// will do the best thing for all cases.<para/>
	///
	/// (2) For horizontal subpixel splitting, the input rgb image
	/// is rescaled by %scaley vertically and by 3.0 times
	/// %scalex horizontally.  Then for each horizontal triplet
	/// of pixels, the r component of the final pixel is selected
	/// from the r component of the appropriate pixel in the triplet,
	/// and likewise for g and b.  Vertical subpixel splitting is
	/// handled similarly.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConvertColorToSubpixelRGB/*"/>
	///  <param name="scalex">[in] - </param>
	///  <param name="scaley">[in] - </param>
	///  <param name="order">[in] - of subpixel rgb color components in composition of pixd: L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR, L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR</param>
	///   <returns>pixd 32 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertColorToSubpixelRGB (int order,
										  Single scalex,
										  Single scaley)
	{
		Pix RetObj = _All.pixConvertColorToSubpixelRGB(this, scalex, scaley, order);
		return RetObj;
	}

	// pixlabel.c (114, 1)
	// pixConnCompTransform(pixs, connect, depth) as Pix
	// pixConnCompTransform(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) pixd is 8, 16 or 32 bpp, and the pixel values label the
	/// fg component, starting with 1.  Pixels in the bg are labelled 0.<para/>
	///
	/// (2) If %depth = 0, the depth of pixd is 8 if the number of c.c.
	/// is less than 254, 16 if the number of c.c is less than 0xfffe,
	/// and 32 otherwise.<para/>
	///
	/// (3) If %depth = 8, the assigned label for the n-th component is
	/// 1 + n % 254.  We use mod 254 because 0 is uniquely assigned
	/// to black: e.g., see pixcmapCreateRandom().  Likewise,
	/// if %depth = 16, the assigned label uses mod(2^16 - 2), and
	/// if %depth = 32, no mod is taken.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConnCompTransform/*"/>
	///  <param name="connect">[in] - connectivity: 4 or 8</param>
	///  <param name="depth">[in] - of pixd: 8 or 16 bpp use 0 for auto determination</param>
	///   <returns>pixd 8, 16 or 32 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConnCompTransform (int connect,
								  int depth)
	{
		Pix RetObj = _All.pixConnCompTransform(this, connect, depth);
		return RetObj;
	}

	// pixlabel.c (194, 1)
	// pixConnCompAreaTransform(pixs, connect) as Pix
	// pixConnCompAreaTransform(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) The pixel values in pixd label the area of the fg component
	/// to which the pixel belongs.  Pixels in the bg are labelled 0.<para/>
	///
	/// (2) For purposes of visualization, the output can be converted
	/// to 8 bpp, using pixConvert32To8() or pixMaxDynamicRange().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConnCompAreaTransform/*"/>
	///  <param name="connect">[in] - connectivity: 4 or 8</param>
	///   <returns>pixd 32 bpp, 1 spp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConnCompAreaTransform (int connect)
	{
		Pix RetObj = _All.pixConnCompAreaTransform(this, connect);
		return RetObj;
	}

	// pixlabel.c (267, 1)
	// pixConnCompIncrInit(pixs, conn, ppixd, pptaa, pncc) as int
	// pixConnCompIncrInit(PIX *, l_int32, PIX **, PTAA **, l_int32 *) as l_ok
	///  <summary>
	/// (1) This labels the connected components in a 1 bpp pix, and
	/// additionally sets up a ptaa that lists the locations of pixels
	/// in each of the components.<para/>
	///
	/// (2) It can be used to initialize the output image and arrays for
	/// an application that maintains information about connected
	/// components incrementally as pixels are added.<para/>
	///
	/// (3) pixs can be empty or have some foreground pixels.<para/>
	///
	/// (4) The connectivity is stored in pixdtospecial.<para/>
	///
	/// (5) Always initialize with the first pta in ptaa being empty
	/// and representing the background value (index 0) in the pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConnCompIncrInit/*"/>
	///  <param name="conn">[in] - connectivity: 4 or 8</param>
	///  <param name="ppixd">[out] - 32 bpp, with c.c. labelled</param>
	///  <param name="pptaa">[out] - with pixel locations indexed by c.c.</param>
	///  <param name="pncc">[out] - initial number of c.c.</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConnCompIncrInit (int conn,
								 out Pix ppixd,
								 out Ptaa pptaa,
								 out int pncc)
	{
		int RetObj = _All.pixConnCompIncrInit(this, conn, out ppixd, out pptaa, out pncc);
		return RetObj;
	}

	// pixlabel.c (351, 1)
	// pixConnCompIncrAdd(pixs, ptaa, pncc, x, y, debug) as int
	// pixConnCompIncrAdd(PIX *, PTAA *, l_int32 *, l_float32, l_float32, l_int32) as l_int32
	///  <summary>
	/// (1) This adds a pixel and updates the labeled connected components.
	/// Before calling this function, initialize the process using
	/// pixConnCompIncrInit().<para/>
	///
	/// (2) As a result of adding a pixel, one of the following can happen,
	/// depending on the number of neighbors with non-zero value:
	/// (a) nothing: the pixel is already a member of a c.c.
	/// (b) no neighbors: a new component is added, increasing the
	/// number of c.c.
	/// (c) one neighbor: the pixel is added to an existing c.c.
	/// (d) more than one neighbor: the added pixel causes joining of
	/// two or more c.c., reducing the number of c.c.  A maximum
	/// of 4 c.c. can be joined.<para/>
	///
	/// (3) When two c.c. are joined, the pixels in the larger index are
	/// relabeled to those of the smaller in pixs, and their locations
	/// are transferred to the pta with the smaller index in the ptaa.
	/// The pta corresponding to the larger index is then deleted.<para/>
	///
	/// (4) This is an efficient implementation of a "union-find" operation,
	/// which supports the generation and merging of disjoint sets
	/// of pixels.  This function can be called about 1.3 million times
	/// per second.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixConnCompIncrAdd/*"/>
	///  <param name="ptaa">[in] - with each pta of pixel locations indexed by c.c.</param>
	///  <param name="pncc">[out] - number of c.c</param>
	///  <param name="x">[in] - ,y location of added pixel</param>
	///  <param name="debug">[in] - 0 for no output otherwise output whenever debug smaller or equal nvals, up to debug == 3</param>
	///   <returns>-1 if nothing happens 0 if a pixel is added 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConnCompIncrAdd (Ptaa ptaa,
								out int pncc,
								Single x,
								Single y,
								DebugOnOff debug)
	{
		int RetObj = _All.pixConnCompIncrAdd(this, ptaa, out pncc, x, y, debug);
		return RetObj;
	}

	// pixlabel.c (481, 1)
	// pixGetSortedNeighborValues(pixs, x, y, conn, pneigh, pnvals) as int
	// pixGetSortedNeighborValues(PIX *, l_int32, l_int32, l_int32, l_int32 **, l_int32 *) as l_ok
	///  <summary>
	/// (1) The returned %neigh array is the unique set of neighboring
	/// pixel values, of size nvals, sorted from smallest to largest.
	/// The value 0, which represents background pixels that do
	/// not belong to any set of connected components, is discarded.<para/>
	///
	/// (2) If there are no neighbors, this returns %neigh = NULL otherwise,
	/// the caller must free the array.<para/>
	///
	/// (3) For either 4 or 8 connectivity, the maximum number of unique
	/// neighbor values is 4.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetSortedNeighborValues/*"/>
	///  <param name="x">[in] - location of pixel</param>
	///  <param name="y">[in] - location of pixel</param>
	///  <param name="conn">[in] - 4 or 8 connected neighbors</param>
	///  <param name="pneigh">[out] - array of integers, to be filled with the values of the neighbors, if any</param>
	///  <param name="pnvals">[out] - the number of unique neighbor values found</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetSortedNeighborValues (int x,
										int y,
										int conn,
										out List<int[]> pneigh,
										out int pnvals)
	{
		int RetObj = _All.pixGetSortedNeighborValues(this, x, y, conn, out pneigh, out pnvals);
		return RetObj;
	}

	// pixlabel.c (567, 1)
	// pixLocToColorTransform(pixs) as Pix
	// pixLocToColorTransform(PIX *) as PIX *
	///  <summary>
	/// (1) This generates an RGB image where each component value
	/// is coded depending on the (x.y) location and the size
	/// of the fg connected component that the pixel in pixs belongs to.
	/// It is independent of the 4-fold orthogonal orientation, and
	/// only weakly depends on translations and small angle rotations.
	/// Background pixels are black.<para/>
	///
	/// (2) Such encodings can be compared between two 1 bpp images
	/// by performing this transform and calculating the
	/// "earth-mover" distance on the resulting R,G,B histograms.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixLocToColorTransform/*"/>
	///   <returns>pixd 32 bpp rgb, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix LocToColorTransform ()
	{
		Pix RetObj = _All.pixLocToColorTransform(this);
		return RetObj;
	}

	// pixtiling.c (121, 1)
	// pixTilingCreate(pixs, nx, ny, w, h, xoverlap, yoverlap) as PixTiling
	// pixTilingCreate(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIXTILING *
	///  <summary>
	/// (1) We put a clone of pixs in the PixTiling.<para/>
	///
	/// (2) The input to pixTilingCreate() for horizontal tiling can be
	/// either the number of tiles across the image or the approximate
	/// width of the tiles.  If the latter, the actual width will be
	/// determined by making all tiles but the last of equal width, and
	/// making the last as close to the others as possible.  The same
	/// consideration is applied independently to the vertical tiling.
	/// To specify tile width, set nx = 0 to specify the number of
	/// tiles horizontally across the image, set w = 0.<para/>
	///
	/// (3) If pixs is to be tiled in one-dimensional strips, use ny = 1 for
	/// vertical strips and nx = 1 for horizontal strips.<para/>
	///
	/// (4) The overlap must not be larger than the width or height of
	/// the leftmost or topmost tile(s).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTilingCreate/*"/>
	///  <param name="nx">[in] - number of tiles across image</param>
	///  <param name="ny">[in] - number of tiles down image</param>
	///  <param name="w">[in] - desired width of each tile</param>
	///  <param name="h">[in] - desired height of each tile</param>
	///  <param name="xoverlap">[in] - overlap into neighboring tiles on each side</param>
	///  <param name="yoverlap">[in] - overlap into neighboring tiles above and below</param>
	///   <returns>pixtiling, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public PixTiling TilingCreate (int nx,
								   int ny,
								   int w,
								   int h,
								   int xoverlap,
								   int yoverlap)
	{
		PixTiling RetObj = _All.pixTilingCreate(this, nx, ny, w, h, xoverlap, yoverlap);
		return RetObj;
	}

	// pixtiling.c (178, 1)
	// pixTilingDestroy(ppt) as Object
	// pixTilingDestroy(PIXTILING **) as void
	///  <summary>
	/// pixTilingDestroy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTilingDestroy/*"/>
	///  <param name="ppt">[in,out] - will be set to null before returning</param>
	// CreateAdditiveFunction: Sub/Default
	public void TilingDestroy (ref PixTiling ppt)
	{
		_All.pixTilingDestroy(ref ppt);
	}

	// pixtiling.c (208, 1)
	// pixTilingGetCount(pt, pnx, pny) as int
	// pixTilingGetCount(PIXTILING *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixTilingGetCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTilingGetCount/*"/>
	///  <param name="pt">[in] - pixtiling</param>
	///  <param name="pnx">[out][optional] - nx can be null</param>
	///  <param name="pny">[out][optional] - ny can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int TilingGetCount (PixTiling pt,
							   out int pnx,
							   out int pny)
	{
		int RetObj = _All.pixTilingGetCount(pt, out pnx, out pny);
		return RetObj;
	}

	// pixtiling.c (231, 1)
	// pixTilingGetSize(pt, pw, ph) as int
	// pixTilingGetSize(PIXTILING *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixTilingGetSize()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTilingGetSize/*"/>
	///  <param name="pt">[in] - pixtiling</param>
	///  <param name="pw">[out][optional] - tile width can be null</param>
	///  <param name="ph">[out][optional] - tile height can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int TilingGetSize (PixTiling pt,
							  out int pw,
							  out int ph)
	{
		int RetObj = _All.pixTilingGetSize(pt, out pw, out ph);
		return RetObj;
	}

	// pixtiling.c (255, 1)
	// pixTilingGetTile(pt, i, j) as Pix
	// pixTilingGetTile(PIXTILING *, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixTilingGetTile()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTilingGetTile/*"/>
	///  <param name="pt">[in] - pixtiling</param>
	///  <param name="i">[in] - tile row index</param>
	///  <param name="j">[in] - tile column index</param>
	///   <returns>pixd tile with appropriate boundary (overlap) pixels added, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix TilingGetTile (PixTiling pt,
							  int i,
							  int j)
	{
		Pix RetObj = _All.pixTilingGetTile(pt, i, j);
		return RetObj;
	}

	// pixtiling.c (368, 1)
	// pixTilingNoStripOnPaint(pt) as int
	// pixTilingNoStripOnPaint(PIXTILING *) as l_ok
	///  <summary>
	/// (1) The default for paint is to strip out the overlap pixels
	/// that are added by pixTilingGetTile().  However, some
	/// operations will generate an image with these pixels
	/// stripped off.  This tells the paint operation not
	/// to strip the added boundary pixels when painting.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTilingNoStripOnPaint/*"/>
	///  <param name="pt">[in] - pixtiling</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int TilingNoStripOnPaint (PixTiling pt)
	{
		int RetObj = _All.pixTilingNoStripOnPaint(pt);
		return RetObj;
	}

	// pixtiling.c (390, 1)
	// pixTilingPaintTile(pixd, i, j, pixs, pt) as int
	// pixTilingPaintTile(PIX *, l_int32, l_int32, PIX *, PIXTILING *) as l_ok
	///  <summary>
	/// pixTilingPaintTile()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTilingPaintTile/*"/>
	///  <param name="pixd">[in] - dest: paint tile onto this, without overlap</param>
	///  <param name="i">[in] - tile row index</param>
	///  <param name="j">[in] - tile column index</param>
	///  <param name="pt">[in] - pixtiling struct</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int TilingPaintTile (Pix pixd,
								int i,
								int j,
								PixTiling pt)
	{
		int RetObj = _All.pixTilingPaintTile(pixd, i, j, this, pt);
		return RetObj;
	}

	// pngio.c (185, 1)
	// pixReadStreamPng(fp) as Pix
	// pixReadStreamPng(FILE *) as PIX *
	///  <summary>
	/// (1) If called from pixReadStream(), the stream is positioned
	/// at the beginning of the file.<para/>
	///
	/// (2) To do sequential reads of png format images from a stream,
	/// use pixReadStreamPng()<para/>
	///
	/// (3) Any image with alpha is converted to RGBA (spp = 4, with
	/// equal red, green and blue channels) on reading.
	/// There are three important cases with alpha:
	/// (a) grayscale-with-alpha (spp = 2), where bpp = 8, and each
	/// pixel has an associated alpha (transparency) value
	/// in the second component of the image data.
	/// (b) spp = 1, d = 1 with colormap and alpha in the trans array.
	/// Transparency is usually associated with the white background.
	/// (c) spp = 1, d = 8 with colormap and alpha in the trans array.
	/// Each color in the colormap has a separate transparency value.<para/>
	///
	/// (4) We use the high level png interface, where the transforms are set
	/// up in advance and the header and image are read with a single
	/// call.  The more complicated interface, where the header is
	/// read first and the buffers for the raster image are user-
	/// allocated before reading the image, works for single images,
	/// but I could not get it to work properly for the successive
	/// png reads that are required by pixaReadStream().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadStreamPng/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadStreamPng (FILE fp)
	{
		Pix RetObj = _All.pixReadStreamPng(fp);
		return RetObj;
	}

	// pngio.c (906, 1)
	// pixWritePng(filename, pix, gamma) as int
	// pixWritePng(const char *, PIX *, l_float32) as l_ok
	///  <summary>
	/// (1) Special version for writing png with a specified gamma.
	/// When using pixWrite(), no field is given for gamma.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWritePng/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="pix">[in] - </param>
	///  <param name="gamma">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WritePng (String filename,
						 Pix pix,
						 Single gamma)
	{
		int RetObj = _All.pixWritePng(filename, pix, gamma);
		return RetObj;
	}

	// pngio.c (1006, 1)
	// pixWriteStreamPng(fp, pix, gamma) as int
	// pixWriteStreamPng(FILE *, PIX *, l_float32) as l_ok
	///  <summary>
	/// (1) If called from pixWriteStream(), the stream is positioned
	/// at the beginning of the file.<para/>
	///
	/// (2) To do sequential writes of png format images to a stream,
	/// use pixWriteStreamPng() directly.<para/>
	///
	/// (3) gamma is an optional png chunk.  If no gamma value is to be
	/// placed into the file, use gamma = 0.0.  Otherwise, if
	/// gamma  is greater  0.0, its value is written into the header.<para/>
	///
	/// (4) The use of gamma in png is highly problematic.  For an illuminating
	/// discussion, see:  http://hsivonen.iki.fi/png-gamma/<para/>
	///
	/// (5) What is the effect/meaning of gamma in the png file?  This
	/// gamma, which we can call the 'source' gamma, is the
	/// inverse of the gamma that was used in enhance.c to brighten
	/// or darken images.  The 'source' gamma is supposed to indicate
	/// the intensity mapping that was done at the time the
	/// image was captured.  Display programs typically apply a
	/// 'display' gamma of 2.2 to the output, which is intended
	/// to linearize the intensity based on the response of
	/// thermionic tubes (CRTs).  Flat panel LCDs have typically
	/// been designed to give a similar response as CRTs (call it
	/// "backward compatibility").  The 'display' gamma is
	/// in some sense the inverse of the 'source' gamma.
	/// jpeg encoders attached to scanners and cameras will lighten
	/// the pixels, applying a gamma corresponding to approximately
	/// a square-root relation of output vs input:
	/// output = input^(gamma)
	/// where gamma is often set near 0.4545  (1/gamma is 2.2).
	/// This is stored in the image file.  Then if the display
	/// program reads the gamma, it will apply a display gamma,
	/// typically about 2.2 the product is 1.0, and the
	/// display program produces a linear output.  This works because
	/// the dark colors were appropriately boosted by the scanner,
	/// as described by the 'source' gamma, so they should not
	/// be further boosted by the display program.<para/>
	///
	/// (6) As an example, with xv and display, if no gamma is stored,
	/// the program acts as if gamma were 0.4545, multiplies this by 2.2,
	/// and does a linear rendering.  Taking this as a baseline
	/// brightness, if the stored gamma is:
	///  is greater  0.4545, the image is rendered lighter than baseline
	///  is smaller 0.4545, the image is rendered darker than baseline
	/// In contrast, gqview seems to ignore the gamma chunk in png.<para/>
	///
	/// (7) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16
	/// and 32.  However, it is possible, and in some cases desirable,
	/// to write out a png file using an rgb pix that has 24 bpp.
	/// For example, the open source xpdf SplashBitmap class generates
	/// 24 bpp rgb images.  Consequently, we enable writing 24 bpp pix.
	/// To generate such a pix, you can make a 24 bpp pix without data
	/// and assign the data array to the pix e.g.,
	/// pix = pixCreateHeader(w, h, 24)
	/// pixSetData(pix, rgbdata)
	/// See pixConvert32To24() for an example, where we get rgbdata
	/// from the 32 bpp pix.  Caution: do not call pixSetPadBits(),
	/// because the alignment is wrong and you may erase part of the
	/// last pixel on each line.<para/>
	///
	/// (8) If the pix has a colormap, it is written to file.  In most
	/// situations, the alpha component is 255 for each colormap entry,
	/// which is opaque and indicates that it should be ignored.
	/// However, if any alpha component is not 255, it is assumed that
	/// the alpha values are valid, and they are written to the png
	/// file in a tRNS segment.  On readback, the tRNS segment is
	/// identified, and the colormapped image with alpha is converted
	/// to a 4 spp rgba image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamPng/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="pix">[in] - </param>
	///  <param name="gamma">[in] - use 0.0 if gamma is not defined</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamPng (FILE fp,
							   Pix pix,
							   Single gamma)
	{
		int RetObj = _All.pixWriteStreamPng(fp, pix, gamma);
		return RetObj;
	}

	// pngio.c (1250, 1)
	// pixSetZlibCompression(pix, compval) as int
	// pixSetZlibCompression(PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) Valid zlib compression values are in the interval [0 ... 9],
	/// where, as defined in zlib.h:
	/// 0 Z_NO_COMPRESSION
	/// 1 Z_BEST_SPEED  (poorest compression)
	/// 9 Z_BEST_COMPRESSION
	/// For the default value, use either of these:
	/// 6 Z_DEFAULT_COMPRESSION
	/// -1 (resolves to Z_DEFAULT_COMPRESSION)<para/>
	///
	/// (2) If you use the defined constants in zlib.h instead of the
	/// compression integers given above, you must include zlib.h.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetZlibCompression/*"/>
	///  <param name="pix">[in] - </param>
	///  <param name="compval">[in] - zlib compression value</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetZlibCompression (Pix pix,
								   int compval)
	{
		int RetObj = _All.pixSetZlibCompression(pix, compval);
		return RetObj;
	}

	// pngio.c (1520, 1)
	// pixReadMemPng(filedata, filesize) as Pix
	// pixReadMemPng(const l_uint8 *, size_t) as PIX *
	///  <summary>
	/// (1) See pixReastreamPng().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadMemPng/*"/>
	///  <param name="filedata">[in] - png compressed data in memory</param>
	///  <param name="filesize">[in] - number of bytes in data</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadMemPng (Byte[] filedata,
						   uint filesize)
	{
		Pix RetObj = _All.pixReadMemPng(filedata, filesize);
		return RetObj;
	}

	// pngio.c (1858, 1)
	// pixWriteMemPng(pfiledata, pfilesize, pix, gamma) as int
	// pixWriteMemPng(l_uint8 **, size_t *, PIX *, l_float32) as l_ok
	///  <summary>
	/// (1) See pixWriteStreamPng()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMemPng/*"/>
	///  <param name="pfiledata">[out] - png encoded data of pix</param>
	///  <param name="pfilesize">[out] - size of png encoded data</param>
	///  <param name="pix">[in] - </param>
	///  <param name="gamma">[in] - use 0.0 if gamma is not defined</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemPng (out Byte[] pfiledata,
							out uint pfilesize,
							Pix pix,
							Single gamma)
	{
		int RetObj = _All.pixWriteMemPng(out pfiledata, out pfilesize, pix, gamma);
		return RetObj;
	}

	// pnmio.c (145, 1)
	// pixReadStreamPnm(fp) as Pix
	// pixReadStreamPnm(FILE *) as PIX *
	///  <summary>
	/// pixReadStreamPnm()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadStreamPnm/*"/>
	///  <param name="fp">[in] - file stream opened for read</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadStreamPnm (FILE fp)
	{
		Pix RetObj = _All.pixReadStreamPnm(fp);
		return RetObj;
	}

	// pnmio.c (667, 1)
	// pixWriteStreamPnm(fp, pix) as int
	// pixWriteStreamPnm(FILE *, PIX *) as l_ok
	///  <summary>
	/// (1) This writes "raw" packed format only:
	/// 1 bpp to pbm (P4)
	/// 2, 4, 8, 16 bpp, no colormap or grayscale colormap to pgm (P5)
	/// 2, 4, 8 bpp with color-valued colormap, or rgb to rgb ppm (P6)<para/>
	///
	/// (2) 24 bpp rgb are not supported in leptonica, but this will
	/// write them out as a packed array of bytes (3 to a pixel).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamPnm/*"/>
	///  <param name="fp">[in] - file stream opened for write</param>
	///  <param name="pix">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamPnm (FILE fp,
							   Pix pix)
	{
		int RetObj = _All.pixWriteStreamPnm(fp, pix);
		return RetObj;
	}

	// pnmio.c (786, 1)
	// pixWriteStreamAsciiPnm(fp, pix) as int
	// pixWriteStreamAsciiPnm(FILE *, PIX *) as l_ok
	///  <summary>
	/// pixWriteStreamAsciiPnm()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamAsciiPnm/*"/>
	///  <param name="fp">[in] - file stream opened for write</param>
	///  <param name="pix">[in] - </param>
	///   <returns>0 if OK 1 on error Writes "ASCII" format only: 1 bpp to pbm P1 2, 4, 8, 16 bpp, no colormap or grayscale colormap to pgm P2 2, 4, 8 bpp with color-valued colormap, or rgb to rgb ppm P3</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamAsciiPnm (FILE fp,
									Pix pix)
	{
		int RetObj = _All.pixWriteStreamAsciiPnm(fp, pix);
		return RetObj;
	}

	// pnmio.c (908, 1)
	// pixWriteStreamPam(fp, pix) as int
	// pixWriteStreamPam(FILE *, PIX *) as l_ok
	///  <summary>
	/// (1) This writes arbitrary PAM (P7) packed format.<para/>
	///
	/// (2) 24 bpp rgb are not supported in leptonica, but this will
	/// write them out as a packed array of bytes (3 to a pixel).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamPam/*"/>
	///  <param name="fp">[in] - file stream opened for write</param>
	///  <param name="pix">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamPam (FILE fp,
							   Pix pix)
	{
		int RetObj = _All.pixWriteStreamPam(fp, pix);
		return RetObj;
	}

	// pnmio.c (1084, 1)
	// pixReadMemPnm(data, size) as Pix
	// pixReadMemPnm(const l_uint8 *, size_t) as PIX *
	///  <summary>
	/// (1) The %size byte of %data must be a null character.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadMemPnm/*"/>
	///  <param name="data">[in] - const pnm-encoded</param>
	///  <param name="size">[in] - of data</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadMemPnm (Byte[] data,
						   uint size)
	{
		Pix RetObj = _All.pixReadMemPnm(data, size);
		return RetObj;
	}

	// pnmio.c (1159, 1)
	// pixWriteMemPnm(pdata, psize, pix) as int
	// pixWriteMemPnm(l_uint8 **, size_t *, PIX *) as l_ok
	///  <summary>
	/// (1) See pixWriteStreamPnm() for usage.  This version writes to
	/// memory instead of to a file stream.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMemPnm/*"/>
	///  <param name="pdata">[out] - data of PNM image</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="pix">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemPnm (out Byte[] pdata,
							out uint psize,
							Pix pix)
	{
		int RetObj = _All.pixWriteMemPnm(out pdata, out psize, pix);
		return RetObj;
	}

	// pnmio.c (1214, 1)
	// pixWriteMemPam(pdata, psize, pix) as int
	// pixWriteMemPam(l_uint8 **, size_t *, PIX *) as l_ok
	///  <summary>
	/// (1) See pixWriteStreamPnm() for usage.  This version writes to
	/// memory instead of to a file stream.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMemPam/*"/>
	///  <param name="pdata">[out] - data of PAM image</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="pix">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemPam (out Byte[] pdata,
							out uint psize,
							Pix pix)
	{
		int RetObj = _All.pixWriteMemPam(out pdata, out psize, pix);
		return RetObj;
	}

	// projective.c (141, 1)
	// pixProjectiveSampledPta(pixs, ptad, ptas, incolor) as Pix
	// pixProjectiveSampledPta(PIX *, PTA *, PTA *, l_int32) as PIX *
	///  <summary>
	/// (1) Brings in either black or white pixels from the boundary.<para/>
	///
	/// (2) Retains colormap, which you can do for a sampled transform..<para/>
	///
	/// (3) No 3 of the 4 points may be collinear.<para/>
	///
	/// (4) For 8 and 32 bpp pix, better quality is obtained by the
	/// somewhat slower pixProjectivePta().  See that
	/// function for relative timings between sampled and interpolated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixProjectiveSampledPta/*"/>
	///  <param name="ptad">[in] - 4 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 4 pts of initial coordinate space</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ProjectiveSampledPta (Pta ptad,
									 Pta ptas,
									 int incolor)
	{
		Pix RetObj = _All.pixProjectiveSampledPta(this, ptad, ptas, incolor);
		return RetObj;
	}

	// projective.c (191, 1)
	// pixProjectiveSampled(pixs, vc, incolor) as Pix
	// pixProjectiveSampled(PIX *, l_float32 *, l_int32) as PIX *
	///  <summary>
	/// (1) Brings in either black or white pixels from the boundary.<para/>
	///
	/// (2) Retains colormap, which you can do for a sampled transform..<para/>
	///
	/// (3) For 8 or 32 bpp, much better quality is obtained by the
	/// somewhat slower pixProjective().  See that function
	/// for relative timings between sampled and interpolated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixProjectiveSampled/*"/>
	///  <param name="vc">[in] - vector of 8 coefficients for projective transformation</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ProjectiveSampled (Single[] vc,
								  int incolor)
	{
		Pix RetObj = _All.pixProjectiveSampled(this, vc, incolor);
		return RetObj;
	}

	// projective.c (284, 1)
	// pixProjectivePta(pixs, ptad, ptas, incolor) as Pix
	// pixProjectivePta(PIX *, PTA *, PTA *, l_int32) as PIX *
	///  <summary>
	/// (1) Brings in either black or white pixels from the boundary<para/>
	///
	/// (2) Removes any existing colormap, if necessary, before transforming
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixProjectivePta/*"/>
	///  <param name="ptad">[in] - 4 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 4 pts of initial coordinate space</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ProjectivePta (Pta ptad,
							  Pta ptas,
							  int incolor)
	{
		Pix RetObj = _All.pixProjectivePta(this, ptad, ptas, incolor);
		return RetObj;
	}

	// projective.c (354, 1)
	// pixProjective(pixs, vc, incolor) as Pix
	// pixProjective(PIX *, l_float32 *, l_int32) as PIX *
	///  <summary>
	/// (1) Brings in either black or white pixels from the boundary<para/>
	///
	/// (2) Removes any existing colormap, if necessary, before transforming
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixProjective/*"/>
	///  <param name="vc">[in] - vector of 8 coefficients for projective transformation</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Projective (Single[] vc,
						   int incolor)
	{
		Pix RetObj = _All.pixProjective(this, vc, incolor);
		return RetObj;
	}

	// projective.c (410, 1)
	// pixProjectivePtaColor(pixs, ptad, ptas, colorval) as Pix
	// pixProjectivePtaColor(PIX *, PTA *, PTA *, l_uint32) as PIX *
	///  <summary>
	/// pixProjectivePtaColor()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixProjectivePtaColor/*"/>
	///  <param name="ptad">[in] - 4 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 4 pts of initial coordinate space</param>
	///  <param name="colorval">[in] - e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ProjectivePtaColor (Pta ptad,
								   Pta ptas,
								   uint colorval)
	{
		Pix RetObj = _All.pixProjectivePtaColor(this, ptad, ptas, colorval);
		return RetObj;
	}

	// projective.c (451, 1)
	// pixProjectiveColor(pixs, vc, colorval) as Pix
	// pixProjectiveColor(PIX *, l_float32 *, l_uint32) as PIX *
	///  <summary>
	/// pixProjectiveColor()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixProjectiveColor/*"/>
	///  <param name="vc">[in] - vector of 8 coefficients for projective transformation</param>
	///  <param name="colorval">[in] - e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ProjectiveColor (Single[] vc,
								uint colorval)
	{
		Pix RetObj = _All.pixProjectiveColor(this, vc, colorval);
		return RetObj;
	}

	// projective.c (513, 1)
	// pixProjectivePtaGray(pixs, ptad, ptas, grayval) as Pix
	// pixProjectivePtaGray(PIX *, PTA *, PTA *, l_uint8) as PIX *
	///  <summary>
	/// pixProjectivePtaGray()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixProjectivePtaGray/*"/>
	///  <param name="ptad">[in] - 4 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 4 pts of initial coordinate space</param>
	///  <param name="grayval">[in] - 0 to bring in BLACK, 255 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ProjectivePtaGray (Pta ptad,
								  Pta ptas,
								  byte grayval)
	{
		Pix RetObj = _All.pixProjectivePtaGray(this, ptad, ptas, grayval);
		return RetObj;
	}

	// projective.c (555, 1)
	// pixProjectiveGray(pixs, vc, grayval) as Pix
	// pixProjectiveGray(PIX *, l_float32 *, l_uint8) as PIX *
	///  <summary>
	/// pixProjectiveGray()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixProjectiveGray/*"/>
	///  <param name="vc">[in] - vector of 8 coefficients for projective transformation</param>
	///  <param name="grayval">[in] - 0 to bring in BLACK, 255 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ProjectiveGray (Single[] vc,
							   byte grayval)
	{
		Pix RetObj = _All.pixProjectiveGray(this, vc, grayval);
		return RetObj;
	}

	// projective.c (644, 1)
	// pixProjectivePtaWithAlpha(pixs, ptad, ptas, pixg, fract, border) as Pix
	// pixProjectivePtaWithAlpha(PIX *, PTA *, PTA *, PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) The alpha channel is transformed separately from pixs,
	/// and aligns with it, being fully transparent outside the
	/// boundary of the transformed pixs.  For pixels that are fully
	/// transparent, a blending function like pixBlendWithGrayMask()
	/// will give zero weight to corresponding pixels in pixs.<para/>
	///
	/// (2) If pixg is NULL, it is generated as an alpha layer that is
	/// partially opaque, using %fract.  Otherwise, it is cropped
	/// to pixs if required and %fract is ignored.  The alpha channel
	/// in pixs is never used.<para/>
	///
	/// (3) Colormaps are removed.<para/>
	///
	/// (4) When pixs is transformed, it doesn't matter what color is brought
	/// in because the alpha channel will be transparent (0) there.<para/>
	///
	/// (5) To avoid losing source pixels in the destination, it may be
	/// necessary to add a border to the source pix before doing
	/// the projective transformation.  This can be any non-negative
	/// number.<para/>
	///
	/// (6) The input %ptad and %ptas are in a coordinate space before
	/// the border is added.  Internally, we compensate for this
	/// before doing the projective transform on the image after
	/// the border is added.<para/>
	///
	/// (7) The default setting for the border values in the alpha channel
	/// is 0 (transparent) for the outermost ring of pixels and
	/// (0.5  fract  255) for the second ring.  When blended over
	/// a second image, this
	/// (a) shrinks the visible image to make a clean overlap edge
	/// with an image below, and
	/// (b) softens the edges by weakening the aliasing there.
	/// Use l_setAlphaMaskBorder() to change these values.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixProjectivePtaWithAlpha/*"/>
	///  <param name="ptad">[in] - 4 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 4 pts of initial coordinate space</param>
	///  <param name="pixg">[in][optional] - 8 bpp, for alpha channel, can be null</param>
	///  <param name="fract">[in] - between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	///  <param name="border">[in] - of pixels added to capture transformed source pixels</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ProjectivePtaWithAlpha (Pta ptad,
									   Pta ptas,
									   Single fract,
									   int border,
									   Pix pixg)
	{
		Pix RetObj = _All.pixProjectivePtaWithAlpha(this, ptad, ptas, pixg, fract, border);
		return RetObj;
	}

	// psio1.c (596, 1)
	// pixWriteSegmentedPageToPS(pixs, pixm, textscale, imagescale, threshold, pageno, fileout) as int
	// pixWriteSegmentedPageToPS(PIX *, PIX *, l_float32, l_float32, l_int32, l_int32, const char *) as l_ok
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteSegmentedPageToPS/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteSegmentedPageToPS (Pix pixm,
									   Single textscale,
									   Single imagescale,
									   int threshold,
									   int pageno,
									   String fileout)
	{
		int RetObj = _All.pixWriteSegmentedPageToPS(this, pixm, textscale, imagescale, threshold, pageno, fileout);
		return RetObj;
	}

	// psio1.c (747, 1)
	// pixWriteMixedToPS(pixb, pixc, scale, pageno, fileout) as int
	// pixWriteMixedToPS(PIX *, PIX *, l_float32, l_int32, const char *) as l_ok
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMixedToPS/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMixedToPS (Pix pixb,
							   Pix pixc,
							   Single scale,
							   int pageno,
							   String fileout)
	{
		int RetObj = _All.pixWriteMixedToPS(pixb, pixc, scale, pageno, fileout);
		return RetObj;
	}

	// psio2.c (152, 1)
	// pixWritePSEmbed(filein, fileout) as int
	// pixWritePSEmbed(const char *, const char *) as l_ok
	///  <summary>
	/// (1) This is a simple wrapper function that generates an
	/// uncompressed PS file, with a bounding box.<para/>
	///
	/// (2) The bounding box is required when a program such as TeX
	/// (through epsf) places and rescales the image.<para/>
	///
	/// (3) The bounding box is sized for fitting the image to an
	/// 8.5 x 11.0 inch page.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWritePSEmbed/*"/>
	///  <param name="filein">[in] - input file, all depths, colormap OK</param>
	///  <param name="fileout">[in] - output ps file</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WritePSEmbed (String filein,
							 String fileout)
	{
		int RetObj = _All.pixWritePSEmbed(filein, fileout);
		return RetObj;
	}

	// psio2.c (205, 1)
	// pixWriteStreamPS(fp, pix, box, res, scale) as int
	// pixWriteStreamPS(FILE *, PIX *, BOX *, l_int32, l_float32) as l_ok
	///  <summary>
	/// (1) This writes image in PS format, optionally scaled,
	/// adjusted for the printer resolution, and with
	/// a bounding box.<para/>
	///
	/// (2) For details on use of parameters, see pixWriteStringPS().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamPS/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="pix">[in] - </param>
	///  <param name="box">[in][optional] - </param>
	///  <param name="res">[in] - can use 0 for default of 300 ppi</param>
	///  <param name="scale">[in] - to prevent scaling, use either 1.0 or 0.0</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamPS (FILE fp,
							  Pix pix,
							  int res,
							  Single scale,
							  Box box)
	{
		int RetObj = _All.pixWriteStreamPS(fp, pix, box, res, scale);
		return RetObj;
	}

	// psio2.c (303, 1)
	// pixWriteStringPS(pixs, box, res, scale) as String
	// pixWriteStringPS(PIX *, BOX *, l_int32, l_float32) as char *
	///  <summary>
	/// a) If %box == NULL, image is placed, optionally scaled,
	/// in a standard b.b. at the center of the page.
	/// This is to be used when another program like
	/// TeX through epsf places the image.
	/// b) If %box != NULL, image is placed without a
	/// b.b. at the specified page location and with
	/// optional scaling.  This is to be used when
	/// you want to specify exactly where and optionally
	/// how big you want the image to be.
	/// Note that all coordinates are in PS convention,
	/// with 0,0 at LL corner of the page:
	/// x,y  location of LL corner of image, in mils.
	/// w,h  scaled size, in mils.  Use 0 to
	/// scale with "scale" and "res" input.
	/// %scale: If no scaling is desired, use either 1.0 or 0.0.
	/// Scaling just resets the resolution parameter the actual
	/// scaling is done in the interpreter at rendering time.
	/// This is important:  it allows you to scale the image up
	/// without increasing the file size.
	/// Notes:<para/>
	///
	/// (1) OK, this seems a bit complicated, because there are various
	/// ways to scale and not to scale.  Here's a summary:<para/>
	///
	/// (2) If you don't want any scaling at all:
	/// if you are using a box:
	/// set w = 0, h = 0, and use scale = 1.0 it will print
	/// each pixel unscaled at printer resolution
	/// if you are not using a box:
	/// set scale = 1.0 it will print at printer resolution<para/>
	///
	/// (3) If you want the image to be a certain size in inches:
	/// you must use a box and set the box (w,h) in mils<para/>
	///
	/// (4) If you want the image to be scaled by a scale factor != 1.0:
	/// if you are using a box:
	/// set w = 0, h = 0, and use the desired scale factor
	/// the higher the printer resolution, the smaller the
	/// image will actually appear.
	/// if you are not using a box:
	/// set the desired scale factor the higher the printer
	/// resolution, the smaller the image will actually appear.<para/>
	///
	/// (5) Another complication is the proliferation of distance units:
	/// The interface distances are in milli-inches.
	/// Three different units are used internally:
	/// ~ pixels  (units of 1/res inch)
	/// ~ printer pts (units of 1/72 inch)
	/// ~ inches
	/// Here is a quiz on volume units from a reviewer:
	/// How many UK milli-cups in a US kilo-teaspoon?
	/// (Hint: 1.0 US cup = 0.75 UK cup + 0.2 US gill
	/// 1.0 US gill = 24.0 US teaspoons)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStringPS/*"/>
	///  <param name="box">[in] - bounding box can be NULL</param>
	///  <param name="res">[in] - resolution, in printer ppi.  Use 0 for default 300 ppi.</param>
	///  <param name="scale">[in] - scale factor.  If no scaling is desired, use either 1.0 or 0.0.   Scaling just resets the resolution parameter the actual scaling is done in the interpreter at rendering time.  This is important: it allows you to scale the image up without increasing the file size.</param>
	///   <returns>ps string if OK, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public String WriteStringPS (Box box,
								 int res,
								 Single scale)
	{
		String RetObj = _All.pixWriteStringPS(this, box, res, scale);
		return RetObj;
	}

	// psio2.c (1922, 1)
	// pixWriteMemPS(pdata, psize, pix, box, res, scale) as int
	// pixWriteMemPS(l_uint8 **, size_t *, PIX *, BOX *, l_int32, l_float32) as l_ok
	///  <summary>
	/// (1) See pixWriteStringPS() for usage.<para/>
	///
	/// (2) This is just a wrapper for pixWriteStringPS(), which
	/// writes uncompressed image data to memory.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMemPS/*"/>
	///  <param name="pdata">[out] - data of tiff compressed image</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="pix">[in] - </param>
	///  <param name="box">[in][optional] - </param>
	///  <param name="res">[in] - can use 0 for default of 300 ppi</param>
	///  <param name="scale">[in] - to prevent scaling, use either 1.0 or 0.0</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemPS (out Byte[] pdata,
						   out uint psize,
						   Pix pix,
						   int res,
						   Single scale,
						   Box box)
	{
		int RetObj = _All.pixWriteMemPS(out pdata, out psize, pix, box, res, scale);
		return RetObj;
	}

	// ptafunc1.c (558, 1)
	// pixFindCornerPixels(pixs) as Pta
	// pixFindCornerPixels(PIX *) as PTA *
	///  <summary>
	/// (1) Finds the 4 corner-most pixels, as defined by a search
	/// inward from each corner, using a 45 degree line.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindCornerPixels/*"/>
	///   <returns>pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta FindCornerPixels ()
	{
		Pta RetObj = _All.pixFindCornerPixels(this);
		return RetObj;
	}

	// ptafunc1.c (1792, 1)
	// pixPlotAlongPta(pixs, pta, outformat, title) as int
	// pixPlotAlongPta(PIX *, PTA *, l_int32, const char *) as l_ok
	///  <summary>
	/// (1) This is a debugging function.<para/>
	///
	/// (2) Removes existing colormaps and clips the pta to the input %pixs.<para/>
	///
	/// (3) If the image is RGB, three separate plots are generated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixPlotAlongPta/*"/>
	///  <param name="pta">[in] - set of points on which to plot</param>
	///  <param name="outformat">[in] - GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	///  <param name="title">[in][optional] - for plot can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int PlotAlongPta (Pta pta,
							 int outformat,
							 String title)
	{
		int RetObj = _All.pixPlotAlongPta(this, pta, outformat, title);
		return RetObj;
	}

	// ptafunc1.c (1946, 1)
	// pixGenerateFromPta(pta, w, h) as Pix
	// pixGenerateFromPta(PTA *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Points are rounded to nearest ints.<para/>
	///
	/// (2) Any points outside (w,h) are silently discarded.<para/>
	///
	/// (3) Output 1 bpp pix has values 1 for each point in the pta.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenerateFromPta/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="w">[in] - of pix</param>
	///  <param name="h">[in] - of pix</param>
	///   <returns>pix 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GenerateFromPta (Pta pta,
								int w,
								int h)
	{
		Pix RetObj = _All.pixGenerateFromPta(pta, w, h);
		return RetObj;
	}

	// ptafunc1.c (2349, 1)
	// pixDisplayPta(pixd, pixs, pta) as Pix
	// pixDisplayPta(PIX *, PIX *, PTA *) as PIX *
	///  <summary>
	/// (1) To write on an existing pixs, pixs must be 32 bpp and
	/// call with pixd == pixs:
	/// pixDisplayPta(pixs, pixs, pta)
	/// To write to a new pix, use pixd == NULL and call:
	/// pixd = pixDisplayPta(NULL, pixs, pta)<para/>
	///
	/// (2) On error, returns pixd to avoid losing pixs if called as
	/// pixs = pixDisplayPta(pixs, pixs, pta)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDisplayPta/*"/>
	///  <param name="pixd">[in] - can be same as pixs or NULL 32 bpp if in-place</param>
	///  <param name="pta">[in] - of path to be plotted</param>
	///   <returns>pixd 32 bpp RGB version of pixs, with path in green.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayPta (Pix pixd,
						   Pta pta)
	{
		Pix RetObj = _All.pixDisplayPta(pixd, this, pta);
		return RetObj;
	}

	// ptafunc1.c (2415, 1)
	// pixDisplayPtaaPattern(pixd, pixs, ptaa, pixp, cx, cy) as Pix
	// pixDisplayPtaaPattern(PIX *, PIX *, PTAA *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) To write on an existing pixs, pixs must be 32 bpp and
	/// call with pixd == pixs:
	/// pixDisplayPtaPattern(pixs, pixs, pta, ...)
	/// To write to a new pix, use pixd == NULL and call:
	/// pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...)<para/>
	///
	/// (2) Puts a random color on each pattern associated with a pta.<para/>
	///
	/// (3) On error, returns pixd to avoid losing pixs if called as
	/// pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...)<para/>
	///
	/// (4) A typical pattern to be used is a circle, generated with
	/// generatePtaFilledCircle()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDisplayPtaaPattern/*"/>
	///  <param name="pixd">[in] - 32 bpp</param>
	///  <param name="ptaa">[in] - giving locations at which the pattern is displayed</param>
	///  <param name="pixp">[in] - 1 bpp pattern to be placed such that its reference point co-locates with each point in pta</param>
	///  <param name="cx">[in] - reference point in pattern</param>
	///  <param name="cy">[in] - reference point in pattern</param>
	///   <returns>pixd 32 bpp RGB version of pixs.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayPtaaPattern (Pix pixd,
								   Ptaa ptaa,
								   Pix pixp,
								   int cx,
								   int cy)
	{
		Pix RetObj = _All.pixDisplayPtaaPattern(pixd, this, ptaa, pixp, cx, cy);
		return RetObj;
	}

	// ptafunc1.c (2482, 1)
	// pixDisplayPtaPattern(pixd, pixs, pta, pixp, cx, cy, color) as Pix
	// pixDisplayPtaPattern(PIX *, PIX *, PTA *, PIX *, l_int32, l_int32, l_uint32) as PIX *
	///  <summary>
	/// (1) To write on an existing pixs, pixs must be 32 bpp and
	/// call with pixd == pixs:
	/// pixDisplayPtaPattern(pixs, pixs, pta, ...)
	/// To write to a new pix, use pixd == NULL and call:
	/// pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...)<para/>
	///
	/// (2) On error, returns pixd to avoid losing pixs if called as
	/// pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...)<para/>
	///
	/// (3) A typical pattern to be used is a circle, generated with
	/// generatePtaFilledCircle()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDisplayPtaPattern/*"/>
	///  <param name="pixd">[in] - can be same as pixs or NULL 32 bpp if in-place</param>
	///  <param name="pta">[in] - giving locations at which the pattern is displayed</param>
	///  <param name="pixp">[in] - 1 bpp pattern to be placed such that its reference point co-locates with each point in pta</param>
	///  <param name="cx">[in] - reference point in pattern</param>
	///  <param name="cy">[in] - reference point in pattern</param>
	///  <param name="color">[in] - in 0xrrggbb00 format</param>
	///   <returns>pixd 32 bpp RGB version of pixs.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayPtaPattern (Pix pixd,
								  Pta pta,
								  Pix pixp,
								  int cx,
								  int cy,
								  uint color)
	{
		Pix RetObj = _All.pixDisplayPtaPattern(pixd, this, pta, pixp, cx, cy, color);
		return RetObj;
	}

	// ptafunc1.c (2594, 1)
	// pixDisplayPtaa(pixs, ptaa) as Pix
	// pixDisplayPtaa(PIX *, PTAA *) as PIX *
	///  <summary>
	/// pixDisplayPtaa()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDisplayPtaa/*"/>
	///  <param name="ptaa">[in] - array of paths to be plotted</param>
	///   <returns>pixd 32 bpp RGB version of pixs, with paths plotted in different colors, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayPtaa (Ptaa ptaa)
	{
		Pix RetObj = _All.pixDisplayPtaa(this, ptaa);
		return RetObj;
	}

	// quadtree.c (92, 1)
	// pixQuadtreeMean(pixs, nlevels, pix_ma, pfpixa) as int
	// pixQuadtreeMean(PIX *, l_int32, PIX *, FPIXA **) as l_ok
	///  <summary>
	/// (1) The returned fpixa has %nlevels of fpix, each containing
	/// the mean values at its level.  Level 0 has a
	/// single value level 1 has 4 values level 2 has 16 etc.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixQuadtreeMean/*"/>
	///  <param name="nlevels">[in] - in quadtree max allowed depends on image size</param>
	///  <param name="pix_ma">[in] - input mean accumulator can be null</param>
	///  <param name="pfpixa">[out] - mean values in quadtree</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int QuadtreeMean (int nlevels,
							 Pix pix_ma,
							 out FPixa pfpixa)
	{
		int RetObj = _All.pixQuadtreeMean(this, nlevels, pix_ma, out pfpixa);
		return RetObj;
	}

	// quadtree.c (169, 1)
	// pixQuadtreeVariance(pixs, nlevels, pix_ma, dpix_msa, pfpixa_v, pfpixa_rv) as int
	// pixQuadtreeVariance(PIX *, l_int32, PIX *, DPIX *, FPIXA **, FPIXA **) as l_ok
	///  <summary>
	/// (1) The returned fpixav and fpixarv have %nlevels of fpix,
	/// each containing at the respective levels the variance
	/// and root variance values.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixQuadtreeVariance/*"/>
	///  <param name="nlevels">[in] - in quadtree</param>
	///  <param name="pix_ma">[in] - input mean accumulator can be null</param>
	///  <param name="dpix_msa">[in] - input mean square accumulator can be null</param>
	///  <param name="pfpixa_v">[out][optional] - variance values in quadtree</param>
	///  <param name="pfpixa_rv">[out][optional] - root variance values in quadtree</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int QuadtreeVariance (int nlevels,
								 Pix pix_ma,
								 DPix dpix_msa,
								 out FPixa pfpixa_v,
								 out FPixa pfpixa_rv)
	{
		int RetObj = _All.pixQuadtreeVariance(this, nlevels, pix_ma, dpix_msa, out pfpixa_v, out pfpixa_rv);
		return RetObj;
	}

	// quadtree.c (265, 1)
	// pixMeanInRectangle(pixs, box, pixma, pval) as int
	// pixMeanInRectangle(PIX *, BOX *, PIX *, l_float32 *) as l_ok
	///  <summary>
	/// (1) This function is intended to be used for many rectangles
	/// on the same image.  It can find the mean within a
	/// rectangle in O(1), independent of the size of the rectangle.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMeanInRectangle/*"/>
	///  <param name="box">[in] - region to compute mean value</param>
	///  <param name="pixma">[in] - mean accumulator</param>
	///  <param name="pval">[out] - mean value</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int MeanInRectangle (Box box,
								Pix pixma,
								out Single pval)
	{
		int RetObj = _All.pixMeanInRectangle(this, box, pixma, out pval);
		return RetObj;
	}

	// quadtree.c (341, 1)
	// pixVarianceInRectangle(pixs, box, pix_ma, dpix_msa, pvar, prvar) as int
	// pixVarianceInRectangle(PIX *, BOX *, PIX *, DPIX *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) This function is intended to be used for many rectangles
	/// on the same image.  It can find the variance and/or the
	/// square root of the variance within a rectangle in O(1),
	/// independent of the size of the rectangle.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixVarianceInRectangle/*"/>
	///  <param name="box">[in] - region to compute variance and/or root variance</param>
	///  <param name="pix_ma">[in] - mean accumulator</param>
	///  <param name="dpix_msa">[in] - mean square accumulator</param>
	///  <param name="pvar">[out][optional] - variance</param>
	///  <param name="prvar">[out][optional] - root variance</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int VarianceInRectangle (Box box,
									Pix pix_ma,
									DPix dpix_msa,
									out Single pvar,
									out Single prvar)
	{
		int RetObj = _All.pixVarianceInRectangle(this, box, pix_ma, dpix_msa, out pvar, out prvar);
		return RetObj;
	}

	// rank.c (147, 1)
	// pixRankFilter(pixs, wf, hf, rank) as Pix
	// pixRankFilter(PIX *, l_int32, l_int32, l_float32) as PIX *
	///  <summary>
	/// (1) This defines, for each pixel in pixs, a neighborhood of
	/// pixels given by a rectangle "centered" on the pixel.
	/// This set of wfhf pixels has a distribution of values.
	/// For each component, if the values are sorted in increasing
	/// order, we choose the component such that rank(wfhf-1)
	/// pixels have a lower or equal value and
	/// (1-rank)(wfhf-1) pixels have an equal or greater value.<para/>
	///
	/// (2) See notes in pixRankFilterGray() for further details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRankFilter/*"/>
	///  <param name="wf">[in] - width and height of filter each is greater or equal 1</param>
	///  <param name="hf">[in] - width and height of filter each is greater or equal 1</param>
	///  <param name="rank">[in] - in [0.0 ... 1.0]</param>
	///   <returns>pixd of rank values, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RankFilter (int wf,
						   int hf,
						   Single rank)
	{
		Pix RetObj = _All.pixRankFilter(this, wf, hf, rank);
		return RetObj;
	}

	// rank.c (199, 1)
	// pixRankFilterRGB(pixs, wf, hf, rank) as Pix
	// pixRankFilterRGB(PIX *, l_int32, l_int32, l_float32) as PIX *
	///  <summary>
	/// (1) This defines, for each pixel in pixs, a neighborhood of
	/// pixels given by a rectangle "centered" on the pixel.
	/// This set of wfhf pixels has a distribution of values.
	/// For each component, if the values are sorted in increasing
	/// order, we choose the component such that rank(wfhf-1)
	/// pixels have a lower or equal value and
	/// (1-rank)(wfhf-1) pixels have an equal or greater value.<para/>
	///
	/// (2) Apply gray rank filtering to each component independently.<para/>
	///
	/// (3) See notes in pixRankFilterGray() for further details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRankFilterRGB/*"/>
	///  <param name="wf">[in] - width and height of filter each is greater or equal 1</param>
	///  <param name="hf">[in] - width and height of filter each is greater or equal 1</param>
	///  <param name="rank">[in] - in [0.0 ... 1.0]</param>
	///   <returns>pixd of rank values, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RankFilterRGB (int wf,
							  int hf,
							  Single rank)
	{
		Pix RetObj = _All.pixRankFilterRGB(this, wf, hf, rank);
		return RetObj;
	}

	// rank.c (267, 1)
	// pixRankFilterGray(pixs, wf, hf, rank) as Pix
	// pixRankFilterGray(PIX *, l_int32, l_int32, l_float32) as PIX *
	///  <summary>
	/// (1) This defines, for each pixel in pixs, a neighborhood of
	/// pixels given by a rectangle "centered" on the pixel.
	/// This set of wfhf pixels has a distribution of values,
	/// and if they are sorted in increasing order, we choose
	/// the pixel such that rank(wfhf-1) pixels have a lower
	/// or equal value and (1-rank)(wfhf-1) pixels have an equal
	/// or greater value.<para/>
	///
	/// (2) By this definition, the rank = 0.0 pixel has the lowest
	/// value, and the rank = 1.0 pixel has the highest value.<para/>
	///
	/// (3) We add mirrored boundary pixels to avoid boundary effects,
	/// and put the filter center at (0, 0).<para/>
	///
	/// (4) This dispatches to grayscale erosion or dilation if the
	/// filter dimensions are odd and the rank is 0.0 or 1.0, rsp.<para/>
	///
	/// (5) Returns a copy if both wf and hf are 1.<para/>
	///
	/// (6) Uses row-major or column-major incremental updates to the
	/// histograms depending on whether hf  is greater  wf or hv smaller or equal wf, rsp.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRankFilterGray/*"/>
	///  <param name="wf">[in] - width and height of filter each is greater or equal 1</param>
	///  <param name="hf">[in] - width and height of filter each is greater or equal 1</param>
	///  <param name="rank">[in] - in [0.0 ... 1.0]</param>
	///   <returns>pixd of rank values, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RankFilterGray (int wf,
							   int hf,
							   Single rank)
	{
		Pix RetObj = _All.pixRankFilterGray(this, wf, hf, rank);
		return RetObj;
	}

	// rank.c (467, 1)
	// pixMedianFilter(pixs, wf, hf) as Pix
	// pixMedianFilter(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixMedianFilter()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixMedianFilter/*"/>
	///  <param name="wf">[in] - width and height of filter each is greater or equal 1</param>
	///  <param name="hf">[in] - width and height of filter each is greater or equal 1</param>
	///   <returns>pixd of median values, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix MedianFilter (int wf,
							 int hf)
	{
		Pix RetObj = _All.pixMedianFilter(this, wf, hf);
		return RetObj;
	}

	// rank.c (502, 1)
	// pixRankFilterWithScaling(pixs, wf, hf, rank, scalefactor) as Pix
	// pixRankFilterWithScaling(PIX *, l_int32, l_int32, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) This is a convenience function that downscales, does
	/// the rank filtering, and upscales.  Because the down-
	/// and up-scaling functions are very fast compared to
	/// rank filtering, the time it takes is reduced from that
	/// for the simple rank filtering operation by approximately
	/// the square of the scaling factor.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRankFilterWithScaling/*"/>
	///  <param name="wf">[in] - width and height of filter each is greater or equal 1</param>
	///  <param name="hf">[in] - width and height of filter each is greater or equal 1</param>
	///  <param name="rank">[in] - in [0.0 ... 1.0]</param>
	///  <param name="scalefactor">[in] - scale factor must be greater or equal 0.2 and smaller or equal 0.7</param>
	///   <returns>pixd of rank values, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RankFilterWithScaling (int wf,
									  int hf,
									  Single rank,
									  Single scalefactor)
	{
		Pix RetObj = _All.pixRankFilterWithScaling(this, wf, hf, rank, scalefactor);
		return RetObj;
	}

	// readbarcode.c (134, 1)
	// pixProcessBarcodes(pixs, format, method, psaw, debugflag) as Sarray
	// pixProcessBarcodes(PIX *, l_int32, l_int32, SARRAY **, l_int32) as SARRAY *
	///  <summary>
	/// pixProcessBarcodes()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixProcessBarcodes/*"/>
	///  <param name="format">[in] - L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...</param>
	///  <param name="method">[in] - L_USE_WIDTHS, L_USE_WINDOWS</param>
	///  <param name="psaw">[out][optional] - sarray of bar widths</param>
	///  <param name="debugflag">[in] - use 1 to generate debug output</param>
	///   <returns>sarray text of barcodes, or NULL if none found or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray ProcessBarcodes (IFF format,
								   int method,
								   int debugflag,
								   out Sarray psaw)
	{
		Sarray RetObj = _All.pixProcessBarcodes(this, format, method, out psaw, debugflag);
		return RetObj;
	}

	// readbarcode.c (182, 1)
	// pixExtractBarcodes(pixs, debugflag) as Pixa
	// pixExtractBarcodes(PIX *, l_int32) as PIXA *
	///  <summary>
	/// pixExtractBarcodes()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExtractBarcodes/*"/>
	///  <param name="debugflag">[in] - use 1 to generate debug output</param>
	///   <returns>pixa deskewed and cropped barcodes, or NULL if none found or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ExtractBarcodes (int debugflag)
	{
		Pixa RetObj = _All.pixExtractBarcodes(this, debugflag);
		return RetObj;
	}

	// readbarcode.c (254, 1)
	// pixReadBarcodes(pixa, format, method, psaw, debugflag) as Sarray
	// pixReadBarcodes(PIXA *, l_int32, l_int32, SARRAY **, l_int32) as SARRAY *
	///  <summary>
	/// pixReadBarcodes()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadBarcodes/*"/>
	///  <param name="pixa">[in] - of 8 bpp deskewed and cropped barcodes</param>
	///  <param name="format">[in] - L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...</param>
	///  <param name="method">[in] - L_USE_WIDTHS, L_USE_WINDOWS</param>
	///  <param name="psaw">[out][optional] - sarray of bar widths</param>
	///  <param name="debugflag">[in] - use 1 to generate debug output</param>
	///   <returns>sa sarray of widths, one string for each barcode found, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sarray ReadBarcodes (Pixa pixa,
								IFF format,
								int method,
								int debugflag,
								out Sarray psaw)
	{
		Sarray RetObj = _All.pixReadBarcodes(pixa, format, method, out psaw, debugflag);
		return RetObj;
	}

	// readbarcode.c (335, 1)
	// pixReadBarcodeWidths(pixs, method, debugflag) as Numa
	// pixReadBarcodeWidths(PIX *, l_int32, l_int32) as NUMA *
	///  <summary>
	/// pixReadBarcodeWidths()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadBarcodeWidths/*"/>
	///  <param name="method">[in] - L_USE_WIDTHS, L_USE_WINDOWS</param>
	///  <param name="debugflag">[in] - use 1 to generate debug output</param>
	///   <returns>na numa of widths (each in set {1,2,3,4}, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa ReadBarcodeWidths (int method,
								   int debugflag)
	{
		Numa RetObj = _All.pixReadBarcodeWidths(this, method, debugflag);
		return RetObj;
	}

	// readbarcode.c (384, 1)
	// pixLocateBarcodes(pixs, thresh, ppixb, ppixm) as Boxa
	// pixLocateBarcodes(PIX *, l_int32, PIX **, PIX **) as BOXA *
	///  <summary>
	/// pixLocateBarcodes()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixLocateBarcodes/*"/>
	///  <param name="thresh">[in] - for binarization of edge filter output typ. 20</param>
	///  <param name="ppixb">[out][optional] - binarized edge filtered input image</param>
	///  <param name="ppixm">[out][optional] - mask over barcodes</param>
	///   <returns>boxa location of barcodes, or NULL if none found or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa LocateBarcodes (int thresh,
								out Pix ppixb,
								out Pix ppixm)
	{
		Boxa RetObj = _All.pixLocateBarcodes(this, thresh, out ppixb, out ppixm);
		return RetObj;
	}

	// readbarcode.c (500, 1)
	// pixDeskewBarcode(pixs, pixb, box, margin, threshold, pangle, pconf) as Pix
	// pixDeskewBarcode(PIX *, PIX *, BOX *, l_int32, l_int32, l_float32 *, l_float32 *) as PIX *
	///  <summary>
	/// (1) The (optional) angle returned is the angle in degrees (cw positive)
	/// necessary to rotate the image so that it is deskewed.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDeskewBarcode/*"/>
	///  <param name="pixb">[in] - binarized edge-filtered input image</param>
	///  <param name="box">[in] - identified region containing barcode</param>
	///  <param name="margin">[in] - of extra pixels around box to extract</param>
	///  <param name="threshold">[in] - for binarization ~20</param>
	///  <param name="pangle">[out][optional] - in degrees, clockwise is positive</param>
	///  <param name="pconf">[out][optional] - confidence</param>
	///   <returns>pixd deskewed barcode, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DeskewBarcode (Pix pixb,
							  Box box,
							  int margin,
							  int threshold,
							  out Single pangle,
							  out Single pconf)
	{
		Pix RetObj = _All.pixDeskewBarcode(this, pixb, box, margin, threshold, out pangle, out pconf);
		return RetObj;
	}

	// readbarcode.c (626, 1)
	// pixExtractBarcodeWidths1(pixs, thresh, binfract, pnaehist, pnaohist, debugflag) as Numa
	// pixExtractBarcodeWidths1(PIX *, l_float32, l_float32, NUMA **, NUMA **, l_int32) as NUMA *
	///  <summary>
	/// (1) The widths are alternating black/white, starting with black
	/// and ending with black.<para/>
	///
	/// (2) This method uses the widths of the bars directly, in terms
	/// of the (float) number of pixels between transitions.
	/// The histograms of these widths for black and white bars is
	/// generated and interpreted.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExtractBarcodeWidths1/*"/>
	///  <param name="thresh">[in] - estimated pixel threshold for crossing white  is smallerto black typ. ~120</param>
	///  <param name="binfract">[in] - histo binsize as a fraction of minsize e.g., 0.25</param>
	///  <param name="pnaehist">[out][optional] - histogram of black widths NULL ok</param>
	///  <param name="pnaohist">[out][optional] - histogram of white widths NULL ok</param>
	///  <param name="debugflag">[in] - use 1 to generate debug output</param>
	///   <returns>nad numa of barcode widths in encoded integer units, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa ExtractBarcodeWidths1 (Single thresh,
									   Single binfract,
									   int debugflag,
									   out Numa pnaehist,
									   out Numa pnaohist)
	{
		Numa RetObj = _All.pixExtractBarcodeWidths1(this, thresh, binfract, out pnaehist, out pnaohist, debugflag);
		return RetObj;
	}

	// readbarcode.c (679, 1)
	// pixExtractBarcodeWidths2(pixs, thresh, pwidth, pnac, debugflag) as Numa
	// pixExtractBarcodeWidths2(PIX *, l_float32, l_float32 *, NUMA **, l_int32) as NUMA *
	///  <summary>
	/// (1) The widths are alternating black/white, starting with black
	/// and ending with black.<para/>
	///
	/// (2) The optional best decoding window width is the width of the window
	/// that is used to make a decision about whether a transition occurs.
	/// It is approximately the average width in pixels of the narrowest
	/// white and black bars (i.e., those corresponding to unit width).<para/>
	///
	/// (3) The optional return signal %nac is a sequence of 0s, 1s,
	/// and perhaps a few 2s, giving the number of crossings in each window.
	/// On the occasion where there is a '2', it is interpreted as
	/// as ending two runs: the previous one and another one that has length 1.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExtractBarcodeWidths2/*"/>
	///  <param name="thresh">[in] - estimated pixel threshold for crossing white  is smallerto black typ. ~120</param>
	///  <param name="pwidth">[out][optional] - best decoding window width, in pixels</param>
	///  <param name="pnac">[out][optional] - number of transitions in each window</param>
	///  <param name="debugflag">[in] - use 1 to generate debug output</param>
	///   <returns>nad numa of barcode widths in encoded integer units, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa ExtractBarcodeWidths2 (Single thresh,
									   int debugflag,
									   out Single pwidth,
									   out Numa pnac)
	{
		Numa RetObj = _All.pixExtractBarcodeWidths2(this, thresh, out pwidth, out pnac, debugflag);
		return RetObj;
	}

	// readbarcode.c (713, 1)
	// pixExtractBarcodeCrossings(pixs, thresh, debugflag) as Numa
	// pixExtractBarcodeCrossings(PIX *, l_float32, l_int32) as NUMA *
	///  <summary>
	/// pixExtractBarcodeCrossings()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExtractBarcodeCrossings/*"/>
	///  <param name="thresh">[in] - estimated pixel threshold for crossing white  is smallerto black typ. ~120</param>
	///  <param name="debugflag">[in] - use 1 to generate debug output</param>
	///   <returns>numa of crossings, in pixel units, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa ExtractBarcodeCrossings (Single thresh,
										 int debugflag)
	{
		Numa RetObj = _All.pixExtractBarcodeCrossings(this, thresh, debugflag);
		return RetObj;
	}

	// readfile.c (225, 1)
	// pixReadWithHint(filename, hint) as Pix
	// pixReadWithHint(const char *, l_int32) as PIX *
	///  <summary>
	/// (1) The hint is not binding, but may be used to optimize jpeg decoding.
	/// Use 0 for no hinting.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadWithHint/*"/>
	///  <param name="filename">[in] - with full pathname or in local directory</param>
	///  <param name="hint">[in] - bitwise OR of L_HINT_ values for jpeg use 0 for no hint</param>
	///   <returns>pix if OK NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadWithHint (String filename,
							 int hint)
	{
		Pix RetObj = _All.pixReadWithHint(filename, hint);
		return RetObj;
	}

	// readfile.c (276, 1)
	// pixReadIndexed(sa, index) as Pix
	// pixReadIndexed(SARRAY *, l_int32) as PIX *
	///  <summary>
	/// (1) This function is useful for selecting image files from a
	/// directory, where the integer %index is embedded into
	/// the file name.<para/>
	///
	/// (2) This is typically done by generating the sarray using
	/// getNumberedPathnamesInDirectory(), so that the %index
	/// pathname would have the number %index in it.  The size
	/// of the sarray should be the largest number (plus 1) appearing
	/// in the file names, respecting the constraints in the
	/// call to getNumberedPathnamesInDirectory().<para/>
	///
	/// (3) Consequently, for some indices into the sarray, there may
	/// be no pathnames in the directory containing that number.
	/// By convention, we place empty C strings ("") in those
	/// locations in the sarray, and it is not an error if such
	/// a string is encountered and no pix is returned.
	/// Therefore, the caller must verify that a pix is returned.<para/>
	///
	/// (4) See convertSegmentedPagesToPS() in src/psio1.c for an
	/// example of usage.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadIndexed/*"/>
	///  <param name="sa">[in] - string array of full pathnames</param>
	///  <param name="index">[in] - into pathname array</param>
	///   <returns>pix if OK null if not found</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadIndexed (Sarray sa,
							int index)
	{
		Pix RetObj = _All.pixReadIndexed(sa, index);
		return RetObj;
	}

	// readfile.c (317, 1)
	// pixReadStream(fp, hint) as Pix
	// pixReadStream(FILE *, l_int32) as PIX *
	///  <summary>
	/// (1) The hint only applies to jpeg.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="hint">[in] - bitwise OR of L_HINT_ values for jpeg use 0 for no hint</param>
	///   <returns>pix if OK NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadStream (FILE fp,
						   int hint)
	{
		Pix RetObj = _All.pixReadStream(fp, hint);
		return RetObj;
	}

	// readfile.c (431, 1)
	// pixReadHeader(filename, pformat, pw, ph, pbps, pspp, piscmap) as int
	// pixReadHeader(const char *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This reads the actual headers for jpeg, png, tiff and pnm.
	/// For bmp and gif, we cheat and read the entire file into a pix,
	/// from which we extract the "header" information.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadHeader/*"/>
	///  <param name="filename">[in] - with full pathname or in local directory</param>
	///  <param name="pformat">[out][optional] - file format</param>
	///  <param name="pw">[out][optional] - width and height</param>
	///  <param name="ph">[out][optional] - width and height</param>
	///  <param name="pbps">[out][optional] - bits/sample</param>
	///  <param name="pspp">[out][optional] - samples/pixel 1, 3 or 4</param>
	///  <param name="piscmap">[out][optional] - 1 if cmap exists 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ReadHeader (String filename,
						   out int pformat,
						   out int pw,
						   out int ph,
						   out int pbps,
						   out int pspp,
						   out int piscmap)
	{
		int RetObj = _All.pixReadHeader(filename, out pformat, out pw, out ph, out pbps, out pspp, out piscmap);
		return RetObj;
	}

	// readfile.c (827, 1)
	// pixReadMem(data, size) as Pix
	// pixReadMem(const l_uint8 *, size_t) as PIX *
	///  <summary>
	/// (1) This is a variation of pixReadStream(), where the data is read
	/// from a memory buffer rather than a file.<para/>
	///
	/// (2) On windows, this only reads tiff formatted files directly from
	/// memory.  For other formats, it writes to a temp file and
	/// decompresses from file.<para/>
	///
	/// (3) findFileFormatBuffer() requires up to 12 bytes to decide on
	/// the format.  That determines the constraint here.  But in
	/// fact the data must contain the entire compressed string for
	/// the image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadMem/*"/>
	///  <param name="data">[in] - const encoded</param>
	///  <param name="size">[in] - size of data</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadMem (Byte[] data,
						uint size)
	{
		Pix RetObj = _All.pixReadMem(data, size);
		return RetObj;
	}

	// readfile.c (948, 1)
	// pixReadHeaderMem(data, size, pformat, pw, ph, pbps, pspp, piscmap) as int
	// pixReadHeaderMem(const l_uint8 *, size_t, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This reads the actual headers for jpeg, png, tiff, jp2k and pnm.
	/// For bmp and gif, we cheat and read all the data into a pix,
	/// from which we extract the "header" information.<para/>
	///
	/// (2) The amount of data required depends on the format.  For
	/// png, it requires less than 30 bytes, but for jpeg it can
	/// require most of the compressed file.  In practice, the data
	/// is typically the entire compressed file in memory.<para/>
	///
	/// (3) findFileFormatBuffer() requires up to 8 bytes to decide on
	/// the format, which we require.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadHeaderMem/*"/>
	///  <param name="data">[in] - const encoded</param>
	///  <param name="size">[in] - size of data</param>
	///  <param name="pformat">[out][optional] - image format</param>
	///  <param name="pw">[out][optional] - width and height</param>
	///  <param name="ph">[out][optional] - width and height</param>
	///  <param name="pbps">[out][optional] - bits/sample</param>
	///  <param name="pspp">[out][optional] - samples/pixel 1, 3 or 4</param>
	///  <param name="piscmap">[out][optional] - 1 if cmap exists 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ReadHeaderMem (Byte[] data,
							  uint size,
							  out int pformat,
							  out int pw,
							  out int ph,
							  out int pbps,
							  out int pspp,
							  out int piscmap)
	{
		int RetObj = _All.pixReadHeaderMem(data, size, out pformat, out pw, out ph, out pbps, out pspp, out piscmap);
		return RetObj;
	}

	// rop.c (193, 1)
	// pixRasterop(pixd, dx, dy, dw, dh, op, pixs, sx, sy) as int
	// pixRasterop(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, PIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This has the standard set of 9 args for rasterop.
	/// This function is your friend it is worth memorizing!<para/>
	///
	/// (2) If the operation involves only dest, this calls
	/// rasteropUniLow().  Otherwise, checks depth of the
	/// src and dest, and if they match, calls rasteropLow().<para/>
	///
	/// (3) For the two-image operation, where both pixs and pixd
	/// are defined, they are typically different images.  However
	/// there are cases, such as pixSetMirroredBorder(), where
	/// in-place operations can be done, blitting pixels from
	/// one part of pixd to another.  Consequently, we permit
	/// such operations.  If you use them, be sure that there
	/// is no overlap between the source and destination rectangles
	/// in pixd (!)
	/// Background:
	/// -----------
	/// There are 18 operations, described by the op codes in pix.h.
	/// One, PIX_DST, is a no-op.
	/// Three, PIX_CLR, PIX_SET, and PIX_NOT(PIX_DST) operate only on the dest.
	/// These are handled by the low-level rasteropUniLow().
	/// The other 14 involve the both the src and the dest, and depend on
	/// the bit values of either just the src or the bit values of both
	/// src and dest.  They are handled by rasteropLow():
	/// PIX_SRC     s
	/// PIX_NOT(PIX_SRC)   ~s
	/// PIX_SRC | PIX_DST   s | d
	/// PIX_SRC [and] PIX_DST   s [and] d
	/// PIX_SRC ^ PIX_DST   s ^ d
	/// PIX_NOT(PIX_SRC) | PIX_DST ~s | d
	/// PIX_NOT(PIX_SRC) [and] PIX_DST ~s [and] d
	/// PIX_NOT(PIX_SRC) ^ PIX_DST ~s ^ d
	/// PIX_SRC | PIX_NOT(PIX_DST)  s | ~d
	/// PIX_SRC [and] PIX_NOT(PIX_DST)  s [and] ~d
	/// PIX_SRC ^ PIX_NOT(PIX_DST)  s ^ ~d
	/// PIX_NOT(PIX_SRC | PIX_DST) ~(s | d)
	/// PIX_NOT(PIX_SRC [and] PIX_DST) ~(s [and] d)
	/// PIX_NOT(PIX_SRC ^ PIX_DST) ~(s ^ d)
	/// Each of these is implemented with one of three low-level
	/// functions, depending on the alignment of the left edge
	/// of the src and dest rectangles:
	/// a fastest implementation if both left edges are
	/// (32-bit) word aligned
	/// a very slightly slower implementation if both left
	/// edges have the same relative (32-bit) word alignment
	/// the general routine that is invoked when
	/// both left edges have different word alignment
	/// Of the 14 binary rasterops above, only 12 are unique
	/// logical combinations (out of a possible 16) of src
	/// and dst bits:
	/// (sd) (11) (10) (01) (00)
	/// -----------------------------------------------
	/// s  1  1  0  0
	/// ~s  0  1  0  1
	/// s | d  1  1  1  0
	/// s [and] d  1  0  0  0
	/// s ^ d  0  1  1  0
	/// ~s | d  1  0  1  1
	/// ~s [and] d  0  0  1  0
	/// ~s ^ d  1  0  0  1
	/// s | ~d 1  1  0  1
	/// s [and] ~d 0  1  0  0
	/// s ^ ~d 1  0  0  1
	/// ~(s | d)  0  0  0  1
	/// ~(s [and] d)  0  1  1  1
	/// ~(s ^ d)  1  0  0  1
	/// Note that the following three operations are equivalent:
	/// ~(s ^ d)
	/// ~s ^ d
	/// s ^ ~d
	/// and in the implementation, we call them out with the first form
	/// namely, ~(s ^ d).
	/// Of the 16 possible binary combinations of src and dest bits,
	/// the remaining 4 unique ones are independent of the src bit.
	/// They depend on either just the dest bit or on neither
	/// the src nor dest bits:
	/// d  1  0  1  0  (indep. of s)
	/// ~d  0  1  0  1  (indep. of s)
	/// CLR   0  0  0  0  (indep. of both s [and] d)
	/// SET   1  1  1  1  (indep. of both s [and] d)
	/// As mentioned above, three of these are implemented by
	/// rasteropUniLow(), and one is a no-op.
	/// How can these operation codes be represented by bits
	/// in such a way that when the basic operations are performed
	/// on the bits the results are unique for unique
	/// operations, and mimic the logic table given above?
	/// The answer is to choose a particular order of the pairings:
	/// (sd) (11) (10) (01) (00)
	/// (which happens to be the same as in the above table)
	/// and to translate the result into 4-bit representations
	/// of s and d.  For example, the Sun rasterop choice
	/// (omitting the extra bit for clipping) is
	/// PIX_SRC  0xc
	/// PIX_DST  0xa
	/// This corresponds to our pairing order given above:
	/// (sd) (11) (10) (01) (00)
	/// where for s = 1 we get the bit pattern
	/// PIX_SRC:  1  1  0  0 (0xc)
	/// and for d = 1 we get the pattern
	/// PIX_DST: 1  0  1  0  (0xa)
	/// OK, that's the pairing order that Sun chose.  How many different
	/// ways can we assign bit patterns to PIX_SRC and PIX_DST to get
	/// the boolean ops to work out?  Any of the 4 pairs can be put
	/// in the first position, any of the remaining 3 pairs can go
	/// in the second and one of the remaining 2 pairs can go the the third.
	/// There is a total of 432 = 24 ways these pairs can be permuted.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRasterop/*"/>
	///  <param name="pixd">[in] - dest pix</param>
	///  <param name="dx">[in] - x val of UL corner of dest rectangle</param>
	///  <param name="dy">[in] - y val of UL corner of dest rectangle</param>
	///  <param name="dw">[in] - width of dest rectangle</param>
	///  <param name="dh">[in] - height of dest rectangle</param>
	///  <param name="op">[in] - op code</param>
	///  <param name="sx">[in] - x val of UL corner of src rectangle</param>
	///  <param name="sy">[in] - y val of UL corner of src rectangle</param>
	///   <returns>0 if OK 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int Rasterop (Pix pixd,
						 int dx,
						 int dy,
						 int dw,
						 int dh,
						 int op,
						 int sx,
						 int sy)
	{
		int RetObj = _All.pixRasterop(pixd, dx, dy, dw, dh, op, this, sx, sy);
		return RetObj;
	}

	// rop.c (269, 1)
	// pixRasteropVip(pixd, bx, bw, vshift, incolor) as int
	// pixRasteropVip(PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This rasterop translates a vertical band of the
	/// image either up or down, bringing in either white
	/// or black pixels from outside the image.<para/>
	///
	/// (2) The vertical band extends the full height of pixd.<para/>
	///
	/// (3) If a colormap exists, the nearest color to white or black
	/// is brought in.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRasteropVip/*"/>
	///  <param name="pixd">[in] - in-place</param>
	///  <param name="bx">[in] - left edge of vertical band</param>
	///  <param name="bw">[in] - width of vertical band</param>
	///  <param name="vshift">[in] - vertical shift of band vshift  is greater  0 is down</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RasteropVip (Pix pixd,
							int bx,
							int bw,
							int vshift,
							int incolor)
	{
		int RetObj = _All.pixRasteropVip(pixd, bx, bw, vshift, incolor);
		return RetObj;
	}

	// rop.c (347, 1)
	// pixRasteropHip(pixd, by, bh, hshift, incolor) as int
	// pixRasteropHip(PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This rasterop translates a horizontal band of the
	/// image either left or right, bringing in either white
	/// or black pixels from outside the image.<para/>
	///
	/// (2) The horizontal band extends the full width of pixd.<para/>
	///
	/// (3) If a colormap exists, the nearest color to white or black
	/// is brought in.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRasteropHip/*"/>
	///  <param name="pixd">[in] - in-place operation</param>
	///  <param name="by">[in] - top of horizontal band</param>
	///  <param name="bh">[in] - height of horizontal band</param>
	///  <param name="hshift">[in] - horizontal shift of band hshift  is greater  0 is to right</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RasteropHip (Pix pixd,
							int by,
							int bh,
							int hshift,
							int incolor)
	{
		int RetObj = _All.pixRasteropHip(pixd, by, bh, hshift, incolor);
		return RetObj;
	}

	// rop.c (431, 1)
	// pixTranslate(pixd, pixs, hshift, vshift, incolor) as Pix
	// pixTranslate(PIX *, PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The general pattern is:
	/// pixd = pixTranslate(pixd, pixs, ...)
	/// For clarity, when you know the case, use one of these:
	/// pixd = pixTranslate(NULL, pixs, ...)  // new
	/// pixTranslate(pixs, pixs, ...) // in-place
	/// pixTranslate(pixd, pixs, ...) // to existing pixd<para/>
	///
	/// (2) If an existing pixd is not the same size as pixs, the
	/// image data will be reallocated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixTranslate/*"/>
	///  <param name="pixd">[in][optional] - destination: this can be null, equal to pixs, or different from pixs</param>
	///  <param name="hshift">[in] - horizontal shift hshift  is greater  0 is to right</param>
	///  <param name="vshift">[in] - vertical shift vshift  is greater  0 is down</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Translate (int hshift,
						  int vshift,
						  int incolor,
						  Pix pixd)
	{
		Pix RetObj = _All.pixTranslate(pixd, this, hshift, vshift, incolor);
		return RetObj;
	}

	// rop.c (461, 1)
	// pixRasteropIP(pixd, hshift, vshift, incolor) as int
	// pixRasteropIP(PIX *, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixRasteropIP()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRasteropIP/*"/>
	///  <param name="pixd">[in] - in-place translation</param>
	///  <param name="hshift">[in] - horizontal shift hshift  is greater  0 is to right</param>
	///  <param name="vshift">[in] - vertical shift vshift  is greater  0 is down</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RasteropIP (Pix pixd,
						   int hshift,
						   int vshift,
						   int incolor)
	{
		int RetObj = _All.pixRasteropIP(pixd, hshift, vshift, incolor);
		return RetObj;
	}

	// rop.c (502, 1)
	// pixRasteropFullImage(pixd, pixs, op) as int
	// pixRasteropFullImage(PIX *, PIX *, l_int32) as l_ok
	///  <summary>
	/// ~ this is a wrapper for a common 2-image raster operation
	/// ~ both pixs and pixd must be defined
	/// ~ the operation is performed with aligned UL corners of pixs and pixd
	/// ~ the operation clips to the smallest pix if the width or height
	/// of pixd is larger than pixs, some pixels in pixd will be unchanged
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRasteropFullImage/*"/>
	///  <param name="pixd">[in] - </param>
	///  <param name="op">[in] - any of the op-codes</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RasteropFullImage (Pix pixd,
								  int op)
	{
		int RetObj = _All.pixRasteropFullImage(pixd, this, op);
		return RetObj;
	}

	// rotate.c (99, 1)
	// pixRotate(pixs, angle, type, incolor, width, height) as Pix
	// pixRotate(PIX *, l_float32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This is a high-level, simple interface for rotating images
	/// about their center.<para/>
	///
	/// (2) For very small rotations, just return a clone.<para/>
	///
	/// (3) Rotation brings either white or black pixels in
	/// from outside the image.<para/>
	///
	/// (4) The rotation type is adjusted if necessary for the image
	/// depth and size of rotation angle.  For 1 bpp images, we
	/// rotate either by shear or sampling.<para/>
	///
	/// (5) Colormaps are removed for rotation by area mapping.<para/>
	///
	/// (6) The dest can be expanded so that no image pixels
	/// are lost.  To invoke expansion, input the original
	/// width and height.  For repeated rotation, use of the
	/// original width and height allows the expansion to
	/// stop at the maximum required size, which is a square
	/// with side = sqrt(ww + hh).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotate/*"/>
	///  <param name="angle">[in] - radians clockwise is positive</param>
	///  <param name="type">[in] - L_ROTATE_AREA_MAP, L_ROTATE_SHEAR, L_ROTATE_SAMPLING</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///  <param name="width">[in] - original width use 0 to avoid embedding</param>
	///  <param name="height">[in] - original height use 0 to avoid embedding</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Rotate (Single angle,
					   int type,
					   int incolor,
					   int width,
					   int height)
	{
		Pix RetObj = _All.pixRotate(this, angle, type, incolor, width, height);
		return RetObj;
	}

	// rotate.c (241, 1)
	// pixEmbedForRotation(pixs, angle, incolor, width, height) as Pix
	// pixEmbedForRotation(PIX *, l_float32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) For very small rotations, just return a clone.<para/>
	///
	/// (2) Generate larger image to embed pixs if necessary, and
	/// place the center of the input image in the center.<para/>
	///
	/// (3) Rotation brings either white or black pixels in
	/// from outside the image.  For colormapped images where
	/// there is no white or black, a new color is added if
	/// possible for these pixels otherwise, either the
	/// lightest or darkest color is used.  In most cases,
	/// the colormap will be removed prior to rotation.<para/>
	///
	/// (4) The dest is to be expanded so that no image pixels
	/// are lost after rotation.  Input of the original width
	/// and height allows the expansion to stop at the maximum
	/// required size, which is a square with side equal to
	/// sqrt(ww + hh).<para/>
	///
	/// (5) For an arbitrary angle, the expansion can be found by
	/// considering the UL and UR corners.  As the image is
	/// rotated, these move in an arc centered at the center of
	/// the image.  Normalize to a unit circle by dividing by half
	/// the image diagonal.  After a rotation of T radians, the UL
	/// and UR corners are at points T radians along the unit
	/// circle.  Compute the x and y coordinates of both these
	/// points and take the max of absolute values these represent
	/// the half width and half height of the containing rectangle.
	/// The arithmetic is done using formulas for sin(a+b) and cos(a+b),
	/// where b = T.  For the UR corner, sin(a) = h/d and cos(a) = w/d.
	/// For the UL corner, replace a by (pi - a), and you have
	/// sin(pi - a) = h/d, cos(pi - a) = -w/d.  The equations
	/// given below follow directly.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixEmbedForRotation/*"/>
	///  <param name="angle">[in] - radians clockwise is positive</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///  <param name="width">[in] - original width use 0 to avoid embedding</param>
	///  <param name="height">[in] - original height use 0 to avoid embedding</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix EmbedForRotation (Single angle,
								 int incolor,
								 int width,
								 int height)
	{
		Pix RetObj = _All.pixEmbedForRotation(this, angle, incolor, width, height);
		return RetObj;
	}

	// rotate.c (322, 1)
	// pixRotateBySampling(pixs, xcen, ycen, angle, incolor) as Pix
	// pixRotateBySampling(PIX *, l_int32, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) For very small rotations, just return a clone.<para/>
	///
	/// (2) Rotation brings either white or black pixels in
	/// from outside the image.<para/>
	///
	/// (3) Colormaps are retained.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateBySampling/*"/>
	///  <param name="xcen">[in] - x value of center of rotation</param>
	///  <param name="ycen">[in] - y value of center of rotation</param>
	///  <param name="angle">[in] - radians clockwise is positive</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RotateBySampling (int xcen,
								 int ycen,
								 Single angle,
								 int incolor)
	{
		Pix RetObj = _All.pixRotateBySampling(this, xcen, ycen, angle, incolor);
		return RetObj;
	}

	// rotate.c (455, 1)
	// pixRotateBinaryNice(pixs, angle, incolor) as Pix
	// pixRotateBinaryNice(PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) For very small rotations, just return a clone.<para/>
	///
	/// (2) This does a computationally expensive rotation of 1 bpp images.
	/// The fastest rotators (using shears or subsampling) leave
	/// visible horizontal and vertical shear lines across which
	/// the image shear changes by one pixel.  To ameliorate the
	/// visual effect one can introduce random dithering.  One
	/// way to do this in a not-too-random fashion is given here.
	/// We convert to 8 bpp, do a very small blur, rotate using
	/// linear interpolation (same as area mapping), do a
	/// small amount of sharpening to compensate for the initial
	/// blur, and threshold back to binary.  The shear lines
	/// are magically removed.<para/>
	///
	/// (3) This operation is about 5x slower than rotation by sampling.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateBinaryNice/*"/>
	///  <param name="angle">[in] - radians clockwise is positive about the center</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RotateBinaryNice (Single angle,
								 int incolor)
	{
		Pix RetObj = _All.pixRotateBinaryNice(this, angle, incolor);
		return RetObj;
	}

	// rotate.c (533, 1)
	// pixRotateWithAlpha(pixs, angle, pixg, fract) as Pix
	// pixRotateWithAlpha(PIX *, l_float32, PIX *, l_float32) as PIX *
	///  <summary>
	/// (1) The alpha channel is transformed separately from pixs,
	/// and aligns with it, being fully transparent outside the
	/// boundary of the transformed pixs.  For pixels that are fully
	/// transparent, a blending function like pixBlendWithGrayMask()
	/// will give zero weight to corresponding pixels in pixs.<para/>
	///
	/// (2) Rotation is about the center of the image for very small
	/// rotations, just return a clone.  The dest is automatically
	/// expanded so that no image pixels are lost.<para/>
	///
	/// (3) Rotation is by area mapping.  It doesn't matter what
	/// color is brought in because the alpha channel will
	/// be transparent (black) there.<para/>
	///
	/// (4) If pixg is NULL, it is generated as an alpha layer that is
	/// partially opaque, using %fract.  Otherwise, it is cropped
	/// to pixs if required and %fract is ignored.  The alpha
	/// channel in pixs is never used.<para/>
	///
	/// (4) Colormaps are removed to 32 bpp.<para/>
	///
	/// (5) The default setting for the border values in the alpha channel
	/// is 0 (transparent) for the outermost ring of pixels and
	/// (0.5  fract  255) for the second ring.  When blended over
	/// a second image, this
	/// (a) shrinks the visible image to make a clean overlap edge
	/// with an image below, and
	/// (b) softens the edges by weakening the aliasing there.
	/// Use l_setAlphaMaskBorder() to change these values.<para/>
	///
	/// (6) A subtle use of gamma correction is to remove gamma correction
	/// before rotation and restore it afterwards.  This is done
	/// by sandwiching this function between a gamma/inverse-gamma
	/// photometric transform:
	/// pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255)
	/// pixd = pixRotateWithAlpha(pixt, angle, NULL, fract)
	/// pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255)
	/// pixDestroy([and]pixt)
	/// This has the side-effect of producing artifacts in the very
	/// dark regions.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateWithAlpha/*"/>
	///  <param name="angle">[in] - radians clockwise is positive</param>
	///  <param name="pixg">[in][optional] - 8 bpp, can be null</param>
	///  <param name="fract">[in] - between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	///   <returns>pixd 32 bpp rgba, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RotateWithAlpha (Single angle,
								Single fract,
								Pix pixg)
	{
		Pix RetObj = _All.pixRotateWithAlpha(this, angle, pixg, fract);
		return RetObj;
	}

	// rotateam.c (149, 1)
	// pixRotateAM(pixs, angle, incolor) as Pix
	// pixRotateAM(PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) Rotates about image center.<para/>
	///
	/// (2) A positive angle gives a clockwise rotation.<para/>
	///
	/// (3) Brings in either black or white pixels from the boundary.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateAM/*"/>
	///  <param name="angle">[in] - radians clockwise is positive</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RotateAM (Single angle,
						 int incolor)
	{
		Pix RetObj = _All.pixRotateAM(this, angle, incolor);
		return RetObj;
	}

	// rotateam.c (212, 1)
	// pixRotateAMColor(pixs, angle, colorval) as Pix
	// pixRotateAMColor(PIX *, l_float32, l_uint32) as PIX *
	///  <summary>
	/// (1) Rotates about image center.<para/>
	///
	/// (2) A positive angle gives a clockwise rotation.<para/>
	///
	/// (3) Specify the color to be brought in from outside the image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateAMColor/*"/>
	///  <param name="angle">[in] - radians clockwise is positive</param>
	///  <param name="colorval">[in] - e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RotateAMColor (Single angle,
							  uint colorval)
	{
		Pix RetObj = _All.pixRotateAMColor(this, angle, colorval);
		return RetObj;
	}

	// rotateam.c (266, 1)
	// pixRotateAMGray(pixs, angle, grayval) as Pix
	// pixRotateAMGray(PIX *, l_float32, l_uint8) as PIX *
	///  <summary>
	/// (1) Rotates about image center.<para/>
	///
	/// (2) A positive angle gives a clockwise rotation.<para/>
	///
	/// (3) Specify the grayvalue to be brought in from outside the image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateAMGray/*"/>
	///  <param name="angle">[in] - radians clockwise is positive</param>
	///  <param name="grayval">[in] - 0 to bring in BLACK, 255 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RotateAMGray (Single angle,
							 byte grayval)
	{
		Pix RetObj = _All.pixRotateAMGray(this, angle, grayval);
		return RetObj;
	}

	// rotateam.c (447, 1)
	// pixRotateAMCorner(pixs, angle, incolor) as Pix
	// pixRotateAMCorner(PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) Rotates about the UL corner of the image.<para/>
	///
	/// (2) A positive angle gives a clockwise rotation.<para/>
	///
	/// (3) Brings in either black or white pixels from the boundary.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateAMCorner/*"/>
	///  <param name="angle">[in] - radians clockwise is positive</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RotateAMCorner (Single angle,
							   int incolor)
	{
		Pix RetObj = _All.pixRotateAMCorner(this, angle, incolor);
		return RetObj;
	}

	// rotateam.c (508, 1)
	// pixRotateAMColorCorner(pixs, angle, fillval) as Pix
	// pixRotateAMColorCorner(PIX *, l_float32, l_uint32) as PIX *
	///  <summary>
	/// (1) Rotates the image about the UL corner.<para/>
	///
	/// (2) A positive angle gives a clockwise rotation.<para/>
	///
	/// (3) Specify the color to be brought in from outside the image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateAMColorCorner/*"/>
	///  <param name="angle">[in] - radians clockwise is positive</param>
	///  <param name="fillval">[in] - e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RotateAMColorCorner (Single angle,
									uint fillval)
	{
		Pix RetObj = _All.pixRotateAMColorCorner(this, angle, fillval);
		return RetObj;
	}

	// rotateam.c (562, 1)
	// pixRotateAMGrayCorner(pixs, angle, grayval) as Pix
	// pixRotateAMGrayCorner(PIX *, l_float32, l_uint8) as PIX *
	///  <summary>
	/// (1) Rotates the image about the UL corner.<para/>
	///
	/// (2) A positive angle gives a clockwise rotation.<para/>
	///
	/// (3) Specify the grayvalue to be brought in from outside the image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateAMGrayCorner/*"/>
	///  <param name="angle">[in] - radians clockwise is positive</param>
	///  <param name="grayval">[in] - 0 to bring in BLACK, 255 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RotateAMGrayCorner (Single angle,
								   byte grayval)
	{
		Pix RetObj = _All.pixRotateAMGrayCorner(this, angle, grayval);
		return RetObj;
	}

	// rotateam.c (741, 1)
	// pixRotateAMColorFast(pixs, angle, colorval) as Pix
	// pixRotateAMColorFast(PIX *, l_float32, l_uint32) as PIX *
	///  <summary>
	/// (1) This rotates a color image about the image center.<para/>
	///
	/// (2) A positive angle gives a clockwise rotation.<para/>
	///
	/// (3) It uses area mapping, dividing each pixel into
	/// 16 subpixels.<para/>
	///
	/// (4) It is about 10% to 20% faster than the more accurate linear
	/// interpolation function pixRotateAMColor(),
	/// which uses 256 subpixels.<para/>
	///
	/// (5) For some reason it shifts the image center.
	/// No attempt is made to rotate the alpha component.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateAMColorFast/*"/>
	///  <param name="angle">[in] - radians clockwise is positive</param>
	///  <param name="colorval">[in] - e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RotateAMColorFast (Single angle,
								  uint colorval)
	{
		Pix RetObj = _All.pixRotateAMColorFast(this, angle, colorval);
		return RetObj;
	}

	// rotateorth.c (72, 1)
	// pixRotateOrth(pixs, quads) as Pix
	// pixRotateOrth(PIX *, l_int32) as PIX *
	///  <summary>
	/// pixRotateOrth()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateOrth/*"/>
	///  <param name="quads">[in] - 0-3 number of 90 degree cw rotations</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RotateOrth (int quads)
	{
		Pix RetObj = _All.pixRotateOrth(this, quads);
		return RetObj;
	}

	// rotateorth.c (121, 1)
	// pixRotate180(pixd, pixs) as Pix
	// pixRotate180(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) This does a 180 rotation of the image about the center,
	/// which is equivalent to a left-right flip about a vertical
	/// line through the image center, followed by a top-bottom
	/// flip about a horizontal line through the image center.<para/>
	///
	/// (2) There are 3 cases for input:
	/// (a) pixd == null (creates a new pixd)
	/// (b) pixd == pixs (in-place operation)
	/// (c) pixd != pixs (existing pixd)<para/>
	///
	/// (3) For clarity, use these three patterns, respectively:
	/// (a) pixd = pixRotate180(NULL, pixs)
	/// (b) pixRotate180(pixs, pixs)
	/// (c) pixRotate180(pixd, pixs)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotate180/*"/>
	///  <param name="pixd">[in][optional] - can be null, equal to pixs, or different from pixs</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Rotate180 (Pix pixd)
	{
		Pix RetObj = _All.pixRotate180(pixd, this);
		return RetObj;
	}

	// rotateorth.c (163, 1)
	// pixRotate90(pixs, direction) as Pix
	// pixRotate90(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This does a 90 degree rotation of the image about the center,
	/// either cw or ccw, returning a new pix.<para/>
	///
	/// (2) The direction must be either 1 (cw) or -1 (ccw).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotate90/*"/>
	///  <param name="direction">[in] - 1 = clockwise,  -1 = counter-clockwise</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Rotate90 (int direction)
	{
		Pix RetObj = _All.pixRotate90(this, direction);
		return RetObj;
	}

	// rotateorth.c (423, 1)
	// pixFlipLR(pixd, pixs) as Pix
	// pixFlipLR(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) This does a left-right flip of the image, which is
	/// equivalent to a rotation out of the plane about a
	/// vertical line through the image center.<para/>
	///
	/// (2) There are 3 cases for input:
	/// (a) pixd == null (creates a new pixd)
	/// (b) pixd == pixs (in-place operation)
	/// (c) pixd != pixs (existing pixd)<para/>
	///
	/// (3) For clarity, use these three patterns, respectively:
	/// (a) pixd = pixFlipLR(NULL, pixs)
	/// (b) pixFlipLR(pixs, pixs)
	/// (c) pixFlipLR(pixd, pixs)<para/>
	///
	/// (4) If an existing pixd is not the same size as pixs, the
	/// image data will be reallocated.<para/>
	///
	/// (5) The pixel access routines allow a trivial implementation.
	/// However, for d  is smaller 8, it is more efficient to right-justify
	/// each line to a 32-bit boundary and then extract bytes and
	/// do pixel reversing. In those cases, as in the 180 degree
	/// rotation, we right-shift the data (if necessary) to
	/// right-justify on the 32 bit boundary, and then read the
	/// bytes off each raster line in reverse order, reversing
	/// the pixels in each byte using a table.  These functions
	/// for 1, 2 and 4 bpp were tested against the "trivial"
	/// version (shown here for 4 bpp):
	/// for (i = 0 i  is smaller h i++) {
	/// line = data + i  wpl
	/// memcpy(buffer, line, bpl)
	/// for (j = 0 j  is smaller w j++) {
	/// val = GET_DATA_QBIT(buffer, w - 1 - j)
	/// SET_DATA_QBIT(line, j, val)
	/// }
	/// }
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFlipLR/*"/>
	///  <param name="pixd">[in][optional] - can be null, equal to pixs, or different from pixs</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FlipLR (Pix pixd)
	{
		Pix RetObj = _All.pixFlipLR(pixd, this);
		return RetObj;
	}

	// rotateorth.c (601, 1)
	// pixFlipTB(pixd, pixs) as Pix
	// pixFlipTB(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) This does a top-bottom flip of the image, which is
	/// equivalent to a rotation out of the plane about a
	/// horizontal line through the image center.<para/>
	///
	/// (2) There are 3 cases for input:
	/// (a) pixd == null (creates a new pixd)
	/// (b) pixd == pixs (in-place operation)
	/// (c) pixd != pixs (existing pixd)<para/>
	///
	/// (3) For clarity, use these three patterns, respectively:
	/// (a) pixd = pixFlipTB(NULL, pixs)
	/// (b) pixFlipTB(pixs, pixs)
	/// (c) pixFlipTB(pixd, pixs)<para/>
	///
	/// (4) If an existing pixd is not the same size as pixs, the
	/// image data will be reallocated.<para/>
	///
	/// (5) This is simple and fast.  We use the memcpy function
	/// to do all the work on aligned data, regardless of pixel
	/// depth.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFlipTB/*"/>
	///  <param name="pixd">[in][optional] - can be null, equal to pixs, or different from pixs</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FlipTB (Pix pixd)
	{
		Pix RetObj = _All.pixFlipTB(pixd, this);
		return RetObj;
	}

	// rotateshear.c (196, 1)
	// pixRotateShear(pixs, xcen, ycen, angle, incolor) as Pix
	// pixRotateShear(PIX *, l_int32, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) This rotates an image about the given point, using
	/// either 2 or 3 shears.<para/>
	///
	/// (2) A positive angle gives a clockwise rotation.<para/>
	///
	/// (3) This brings in 'incolor' pixels from outside the image.<para/>
	///
	/// (4) For rotation angles larger than about 0.35 radians, we issue
	/// a warning because you should probably be using another method
	/// (either sampling or area mapping)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateShear/*"/>
	///  <param name="xcen">[in] - x value for which there is no horizontal shear</param>
	///  <param name="ycen">[in] - y value for which there is no vertical shear</param>
	///  <param name="angle">[in] - radians</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RotateShear (int xcen,
							int ycen,
							Single angle,
							int incolor)
	{
		Pix RetObj = _All.pixRotateShear(this, xcen, ycen, angle, incolor);
		return RetObj;
	}

	// rotateshear.c (248, 1)
	// pixRotate2Shear(pixs, xcen, ycen, angle, incolor) as Pix
	// pixRotate2Shear(PIX *, l_int32, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) This rotates the image about the given point, using the 2-shear
	/// method.  It should only be used for angles smaller than
	/// MAX_2_SHEAR_ANGLE.  For larger angles, a warning is issued.<para/>
	///
	/// (2) A positive angle gives a clockwise rotation.<para/>
	///
	/// (3) 2-shear rotation by a specified angle is equivalent
	/// to the sequential transformations
	/// x' = x + tan(angle)  (y - ycen) for x-shear
	/// y' = y + tan(angle)  (x - xcen) for y-shear<para/>
	///
	/// (4) Computation of tan(angle) is performed within the shear operation.<para/>
	///
	/// (5) This brings in 'incolor' pixels from outside the image.<para/>
	///
	/// (6) If the image has an alpha layer, it is rotated separately by
	/// two shears.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotate2Shear/*"/>
	///  <param name="xcen">[in] - center of rotation</param>
	///  <param name="ycen">[in] - center of rotation</param>
	///  <param name="angle">[in] - radians</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Rotate2Shear (int xcen,
							 int ycen,
							 Single angle,
							 int incolor)
	{
		Pix RetObj = _All.pixRotate2Shear(this, xcen, ycen, angle, incolor);
		return RetObj;
	}

	// rotateshear.c (319, 1)
	// pixRotate3Shear(pixs, xcen, ycen, angle, incolor) as Pix
	// pixRotate3Shear(PIX *, l_int32, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) This rotates the image about the given point, using the 3-shear
	/// method.  It should only be used for angles smaller than
	/// LIMIT_SHEAR_ANGLE.  For larger angles, a warning is issued.<para/>
	///
	/// (2) A positive angle gives a clockwise rotation.<para/>
	///
	/// (3) 3-shear rotation by a specified angle is equivalent
	/// to the sequential transformations
	/// y' = y + tan(angle/2)  (x - xcen) for first y-shear
	/// x' = x + sin(angle)  (y - ycen) for x-shear
	/// y' = y + tan(angle/2)  (x - xcen) for second y-shear<para/>
	///
	/// (4) Computation of tan(angle) is performed in the shear operations.<para/>
	///
	/// (5) This brings in 'incolor' pixels from outside the image.<para/>
	///
	/// (6) If the image has an alpha layer, it is rotated separately by
	/// two shears.<para/>
	///
	/// (7) The algorithm was published by Alan Paeth: "A Fast Algorithm
	/// for General Raster Rotation," Graphics Interface '86,
	/// pp. 77-81, May 1986.  A description of the method, along with
	/// an implementation, can be found in Graphics Gems, p. 179,
	/// edited by Andrew Glassner, published by Academic Press, 1990.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotate3Shear/*"/>
	///  <param name="xcen">[in] - center of rotation</param>
	///  <param name="ycen">[in] - center of rotation</param>
	///  <param name="angle">[in] - radians</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Rotate3Shear (int xcen,
							 int ycen,
							 Single angle,
							 int incolor)
	{
		Pix RetObj = _All.pixRotate3Shear(this, xcen, ycen, angle, incolor);
		return RetObj;
	}

	// rotateshear.c (395, 1)
	// pixRotateShearIP(pixs, xcen, ycen, angle, incolor) as int
	// pixRotateShearIP(PIX *, l_int32, l_int32, l_float32, l_int32) as l_ok
	///  <summary>
	/// (1) This does an in-place rotation of the image about the
	/// specified point, using the 3-shear method.  It should only
	/// be used for angles smaller than LIMIT_SHEAR_ANGLE.
	/// For larger angles, a warning is issued.<para/>
	///
	/// (2) A positive angle gives a clockwise rotation.<para/>
	///
	/// (3) 3-shear rotation by a specified angle is equivalent
	/// to the sequential transformations
	/// y' = y + tan(angle/2)  (x - xcen)  for first y-shear
	/// x' = x + sin(angle)  (y - ycen)  for x-shear
	/// y' = y + tan(angle/2)  (x - xcen)  for second y-shear<para/>
	///
	/// (4) Computation of tan(angle) is performed in the shear operations.<para/>
	///
	/// (5) This brings in 'incolor' pixels from outside the image.<para/>
	///
	/// (6) The pix cannot be colormapped, because the in-place operation
	/// only blits in 0 or 1 bits, not an arbitrary colormap index.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateShearIP/*"/>
	///  <param name="xcen">[in] - center of rotation</param>
	///  <param name="ycen">[in] - center of rotation</param>
	///  <param name="angle">[in] - radians</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RotateShearIP (int xcen,
							  int ycen,
							  Single angle,
							  int incolor)
	{
		int RetObj = _All.pixRotateShearIP(this, xcen, ycen, angle, incolor);
		return RetObj;
	}

	// rotateshear.c (439, 1)
	// pixRotateShearCenter(pixs, angle, incolor) as Pix
	// pixRotateShearCenter(PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// pixRotateShearCenter()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateShearCenter/*"/>
	///  <param name="angle">[in] - radians</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RotateShearCenter (Single angle,
								  int incolor)
	{
		Pix RetObj = _All.pixRotateShearCenter(this, angle, incolor);
		return RetObj;
	}

	// rotateshear.c (462, 1)
	// pixRotateShearCenterIP(pixs, angle, incolor) as int
	// pixRotateShearCenterIP(PIX *, l_float32, l_int32) as l_ok
	///  <summary>
	/// pixRotateShearCenterIP()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRotateShearCenterIP/*"/>
	///  <param name="angle">[in] - radians</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RotateShearCenterIP (Single angle,
									int incolor)
	{
		int RetObj = _All.pixRotateShearCenterIP(this, angle, incolor);
		return RetObj;
	}

	// runlength.c (99, 1)
	// pixStrokeWidthTransform(pixs, color, depth, nangles) as Pix
	// pixStrokeWidthTransform(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The dest Pix is 8 or 16 bpp, with the pixel values
	/// equal to the stroke width in which it is a member.
	/// The values are clipped to the max pixel value if necessary.<para/>
	///
	/// (2) The color determines if we're labelling white or black strokes.<para/>
	///
	/// (3) A pixel that is not a member of the chosen color gets
	/// value 0 it belongs to a width of length 0 of the
	/// chosen color.<para/>
	///
	/// (4) This chooses, for each dest pixel, the minimum of sets
	/// of runlengths through each pixel.  Here are the sets:
	/// nangles  increment  set
	/// -------  ---------  --------------------------------
	/// 2  90 {0, 90}
	/// 4  45 {0, 45, 90, 135}
	/// 6  30 {0, 30, 60, 90, 120, 150}
	/// 8  22.5 {0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5}<para/>
	///
	/// (5) Runtime scales linearly with (nangles - 2).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixStrokeWidthTransform/*"/>
	///  <param name="color">[in] - 0 for white runs, 1 for black runs</param>
	///  <param name="depth">[in] - of pixd: 8 or 16 bpp</param>
	///  <param name="nangles">[in] - 2, 4, 6 or 8</param>
	///   <returns>pixd 8 or 16 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix StrokeWidthTransform (int color,
									 int depth,
									 int nangles)
	{
		Pix RetObj = _All.pixStrokeWidthTransform(this, color, depth, nangles);
		return RetObj;
	}

	// runlength.c (262, 1)
	// pixRunlengthTransform(pixs, color, direction, depth) as Pix
	// pixRunlengthTransform(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The dest Pix is 8 or 16 bpp, with the pixel values
	/// equal to the runlength in which it is a member.
	/// The length is clipped to the max pixel value if necessary.<para/>
	///
	/// (2) The color determines if we're labelling white or black runs.<para/>
	///
	/// (3) A pixel that is not a member of the chosen color gets
	/// value 0 it belongs to a run of length 0 of the
	/// chosen color.<para/>
	///
	/// (4) To convert for maximum dynamic range, either linear or
	/// log, use pixMaxDynamicRange().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRunlengthTransform/*"/>
	///  <param name="color">[in] - 0 for white runs, 1 for black runs</param>
	///  <param name="direction">[in] - L_HORIZONTAL_RUNS, L_VERTICAL_RUNS</param>
	///  <param name="depth">[in] - 8 or 16 bpp</param>
	///   <returns>pixd 8 or 16 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RunlengthTransform (int color,
								   int direction,
								   int depth)
	{
		Pix RetObj = _All.pixRunlengthTransform(this, color, direction, depth);
		return RetObj;
	}

	// runlength.c (372, 1)
	// pixFindHorizontalRuns(pix, y, xstart, xend, pn) as int
	// pixFindHorizontalRuns(PIX *, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This finds foreground horizontal runs on a single scanline.<para/>
	///
	/// (2) To find background runs, use pixInvert() before applying
	/// this function.<para/>
	///
	/// (3) The xstart and xend arrays are input.  They should be
	/// of size w/2 + 1 to insure that they can hold
	/// the maximum number of runs in the raster line.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindHorizontalRuns/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///  <param name="y">[in] - line to traverse</param>
	///  <param name="xstart">[in] - returns array of start positions for fg runs</param>
	///  <param name="xend">[in] - returns array of end positions for fg runs</param>
	///  <param name="pn">[out] - the number of runs found</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindHorizontalRuns (Pix pix,
								   int y,
								   int[] xstart,
								   int[] xend,
								   out int pn)
	{
		int RetObj = _All.pixFindHorizontalRuns(pix, y, xstart, xend, out pn);
		return RetObj;
	}

	// runlength.c (449, 1)
	// pixFindVerticalRuns(pix, x, ystart, yend, pn) as int
	// pixFindVerticalRuns(PIX *, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This finds foreground vertical runs on a single scanline.<para/>
	///
	/// (2) To find background runs, use pixInvert() before applying
	/// this function.<para/>
	///
	/// (3) The ystart and yend arrays are input.  They should be
	/// of size h/2 + 1 to insure that they can hold
	/// the maximum number of runs in the raster line.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindVerticalRuns/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///  <param name="x">[in] - line to traverse</param>
	///  <param name="ystart">[in] - returns array of start positions for fg runs</param>
	///  <param name="yend">[in] - returns array of end positions for fg runs</param>
	///  <param name="pn">[out] - the number of runs found</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindVerticalRuns (Pix pix,
								 int x,
								 int[] ystart,
								 int[] yend,
								 out int pn)
	{
		int RetObj = _All.pixFindVerticalRuns(pix, x, ystart, yend, out pn);
		return RetObj;
	}

	// runlength.c (525, 1)
	// pixFindMaxRuns(pix, direction, pnastart) as Numa
	// pixFindMaxRuns(PIX *, l_int32, NUMA **) as NUMA *
	///  <summary>
	/// (1) This finds the longest foreground runs by row or column<para/>
	///
	/// (2) To find background runs, use pixInvert() before applying
	/// this function.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindMaxRuns/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///  <param name="direction">[in] - L_HORIZONTAL_RUNS or L_VERTICAL_RUNS</param>
	///  <param name="pnastart">[out][optional] - start locations of longest runs</param>
	///   <returns>na of lengths of runs, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa FindMaxRuns (Pix pix,
							 int direction,
							 out Numa pnastart)
	{
		Numa RetObj = _All.pixFindMaxRuns(pix, direction, out pnastart);
		return RetObj;
	}

	// runlength.c (578, 1)
	// pixFindMaxHorizontalRunOnLine(pix, y, pxstart, psize) as int
	// pixFindMaxHorizontalRunOnLine(PIX *, l_int32, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This finds the longest foreground horizontal run on a scanline.<para/>
	///
	/// (2) To find background runs, use pixInvert() before applying
	/// this function.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindMaxHorizontalRunOnLine/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///  <param name="y">[in] - line to traverse</param>
	///  <param name="pxstart">[out][optional] - start position</param>
	///  <param name="psize">[out] - the size of the run</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindMaxHorizontalRunOnLine (Pix pix,
										   int y,
										   out int psize,
										   out int pxstart)
	{
		int RetObj = _All.pixFindMaxHorizontalRunOnLine(pix, y, out pxstart, out psize);
		return RetObj;
	}

	// runlength.c (652, 1)
	// pixFindMaxVerticalRunOnLine(pix, x, pystart, psize) as int
	// pixFindMaxVerticalRunOnLine(PIX *, l_int32, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This finds the longest foreground vertical run on a scanline.<para/>
	///
	/// (2) To find background runs, use pixInvert() before applying
	/// this function.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindMaxVerticalRunOnLine/*"/>
	///  <param name="pix">[in] - 1 bpp</param>
	///  <param name="x">[in] - column to traverse</param>
	///  <param name="pystart">[out][optional] - start position</param>
	///  <param name="psize">[out] - the size of the run</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindMaxVerticalRunOnLine (Pix pix,
										 int x,
										 out int psize,
										 out int pystart)
	{
		int RetObj = _All.pixFindMaxVerticalRunOnLine(pix, x, out pystart, out psize);
		return RetObj;
	}

	// scale1.c (243, 1)
	// pixScale(pixs, scalex, scaley) as Pix
	// pixScale(PIX *, l_float32, l_float32) as PIX *
	///  <summary>
	/// pixScale()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScale/*"/>
	///  <param name="scalex">[in] - </param>
	///  <param name="scaley">[in] - </param>
	///   <returns>pixd, or NULL on error This function scales 32 bpp RGB 2, 4 or 8 bpp palette color 2, 4, 8 or 16 bpp gray and binary images. When the input has palette color, the colormap is removed and the result is either 8 bpp gray or 32 bpp RGB, depending on whether the colormap has color entries.  Images with 2, 4 or 16 bpp are converted to 8 bpp. Because pixScale is meant to be a very simple interface to a number of scaling functions, including the use of unsharp masking, the type of scaling and the sharpening parameters are chosen by default.  Grayscale and color images are scaled using one of four methods, depending on the scale factors: 1 antialiased subsampling (lowpass filtering followed by subsampling, implemented here by area mapping), for scale factors less than 0.2 2 antialiased subsampling with sharpening, for scale factors between 0.2 and 0.7 3 linear interpolation with sharpening, for scale factors between 0.7 and 1.4 4 linear interpolation without sharpening, for scale factors greater or equal 1.4. One could use subsampling for scale factors very close to 1.0, because it preserves sharp edges.  Linear interpolation blurs edges because the dest pixels will typically straddle two src edge pixels.  Subsmpling removes entire columns and rows, so the edge is not blurred.  However, there are two reasons for not doing this. First, it moves edges, so that a straight line at a large angle to both horizontal and vertical will have noticeable kinks where horizontal and vertical rasters are removed.  Second, although it is very fast, you get good results on sharp edges by applying a sharpening filter. For images with sharp edges, sharpening substantially improves the image quality for scale factors between about 0.2 and about 2.0. pixScale uses a small amount of sharpening by default because it strengthens edge pixels that are weak due to anti-aliasing. The default sharpening factors are: for scaling factors  is smaller 0.7:   sharpfract = 0.2    sharpwidth = 1 for scaling factors greater or equal 0.7:  sharpfract = 0.4    sharpwidth = 2 The cases where the sharpening halfwidth is 1 or 2 have special implementations and are about twice as fast as the general case. However, sharpening is computationally expensive, and one needs to consider the speed-quality tradeoff: For upscaling of RGB images, linear interpolation plus default sharpening is about 5 times slower than upscaling alone. For downscaling, area mapping plus default sharpening is about 10 times slower than downscaling alone. When the scale factor is larger than 1.4, the cost of sharpening, which is proportional to image area, is very large compared to the incremental quality improvement, so we cut off the default use of sharpening at 1.4.  Thus, for scale factors greater than 1.4, pixScale only does linear interpolation. In many situations you will get a satisfactory result by scaling without sharpening: call pixScaleGeneral with %sharpfract = 0.0. Alternatively, if you wish to sharpen but not use the default value, first call pixScaleGeneral with %sharpfract = 0.0, and then sharpen explicitly using pixUnsharpMasking. Binary images are scaled to binary by sampling the closest pixel, without any low-pass filtering averaging of neighboring pixels. This will introduce aliasing for reductions.  Aliasing can be prevented by using pixScaleToGray instead.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Scale (Single scalex,
					  Single scaley)
	{
		Pix RetObj = _All.pixScale(this, scalex, scaley);
		return RetObj;
	}

	// scale1.c (273, 1)
	// pixScaleToSizeRel(pixs, delw, delh) as Pix
	// pixScaleToSizeRel(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixScaleToSizeRel()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleToSizeRel/*"/>
	///  <param name="delw">[in] - change in width, in pixels 0 means no change</param>
	///  <param name="delh">[in] - change in height, in pixels 0 means no change</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleToSizeRel (int delw,
							   int delh)
	{
		Pix RetObj = _All.pixScaleToSizeRel(this, delw, delh);
		return RetObj;
	}

	// scale1.c (316, 1)
	// pixScaleToSize(pixs, wd, hd) as Pix
	// pixScaleToSize(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The output scaled image has the dimension(s) you specify:
	/// To specify the width with isotropic scaling, set %hd = 0.
	/// To specify the height with isotropic scaling, set %wd = 0.
	/// If both %wd and %hd are specified, the image is scaled
	/// (in general, anisotropically) to that size.
	/// It is an error to set both %wd and %hd to 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleToSize/*"/>
	///  <param name="wd">[in] - target width use 0 if using height as target</param>
	///  <param name="hd">[in] - target height use 0 if using width as target</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleToSize (int wd,
							int hd)
	{
		Pix RetObj = _All.pixScaleToSize(this, wd, hd);
		return RetObj;
	}

	// scale1.c (374, 1)
	// pixScaleGeneral(pixs, scalex, scaley, sharpfract, sharpwidth) as Pix
	// pixScaleGeneral(PIX *, l_float32, l_float32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) See pixScale() for usage.<para/>
	///
	/// (2) This interface may change in the future, as other special
	/// cases are added.<para/>
	///
	/// (3) The actual sharpening factors used depend on the maximum
	/// of the two scale factors (maxscale):
	/// maxscale smaller or equal 0.2:  no sharpening
	/// 0.2  is smaller maxscale  is smaller 1.4: uses the input parameters
	/// maxscale greater or equal 1.4:  no sharpening<para/>
	///
	/// (4) To avoid sharpening for grayscale and color images with
	/// scaling factors between 0.2 and 1.4, call this function
	/// with %sharpfract == 0.0.<para/>
	///
	/// (5) To use arbitrary sharpening in conjunction with scaling,
	/// call this function with %sharpfract = 0.0, and follow this
	/// with a call to pixUnsharpMasking() with your chosen parameters.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleGeneral/*"/>
	///  <param name="scalex">[in] - both  is greater  0.0</param>
	///  <param name="scaley">[in] - both  is greater  0.0</param>
	///  <param name="sharpfract">[in] - use 0.0 to skip sharpening</param>
	///  <param name="sharpwidth">[in] - halfwidth of low-pass filter typ. 1 or 2</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleGeneral (Single sharpfract,
							 int sharpwidth,
							 Single scalex,
							 Single scaley)
	{
		Pix RetObj = _All.pixScaleGeneral(this, scalex, scaley, sharpfract, sharpwidth);
		return RetObj;
	}

	// scale1.c (458, 1)
	// pixScaleLI(pixs, scalex, scaley) as Pix
	// pixScaleLI(PIX *, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) This function should only be used when the scale factors are
	/// greater than or equal to 0.7, and typically greater than 1.
	/// If either scale factor is larger than 0.7, we issue a warning
	/// and call pixScaleGeneral(), which will invoke area mapping
	/// without sharpening.<para/>
	///
	/// (2) This works on 2, 4, 8, 16 and 32 bpp images, as well as on
	/// 2, 4 and 8 bpp images that have a colormap.  If there is a
	/// colormap, it is removed to either gray or RGB, depending
	/// on the colormap.<para/>
	///
	/// (3) This does a linear interpolation on the src image.<para/>
	///
	/// (4) It dispatches to much faster implementations for
	/// the special cases of 2x and 4x expansion.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleLI/*"/>
	///  <param name="scalex">[in] - must both be greater or equal 0.7</param>
	///  <param name="scaley">[in] - must both be greater or equal 0.7</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleLI (Single scalex,
						Single scaley)
	{
		Pix RetObj = _All.pixScaleLI(this, scalex, scaley);
		return RetObj;
	}

	// scale1.c (519, 1)
	// pixScaleColorLI(pixs, scalex, scaley) as Pix
	// pixScaleColorLI(PIX *, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) If either scale factor is larger than 0.7, we issue a warning
	/// and call pixScaleGeneral(), which will invoke area mapping
	/// without sharpening.  This is particularly important for
	/// document images with sharp edges.<para/>
	///
	/// (2) For the general case, it's about 4x faster to manipulate
	/// the color pixels directly, rather than to make images
	/// out of each of the 3 components, scale each component
	/// using the pixScaleGrayLI(), and combine the results back
	/// into an rgb image.<para/>
	///
	/// (3) The speed on intel hardware for the general case (not 2x)
	/// is about 10  10^6 dest-pixels/sec/GHz.  (The special 2x
	/// case runs at about 80  10^6 dest-pixels/sec/GHz.)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleColorLI/*"/>
	///  <param name="scalex">[in] - must both be greater or equal 0.7</param>
	///  <param name="scaley">[in] - must both be greater or equal 0.7</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleColorLI (Single scalex,
							 Single scaley)
	{
		Pix RetObj = _All.pixScaleColorLI(this, scalex, scaley);
		return RetObj;
	}

	// scale1.c (585, 1)
	// pixScaleColor2xLI(pixs) as Pix
	// pixScaleColor2xLI(PIX *) as PIX *
	///  <summary>
	/// (1) This is a special case of linear interpolated scaling,
	/// for 2x upscaling.  It is about 8x faster than using
	/// the generic pixScaleColorLI(), and about 4x faster than
	/// using the special 2x scale function pixScaleGray2xLI()
	/// on each of the three components separately.<para/>
	///
	/// (2) The speed on intel hardware is about
	/// 80  10^6 dest-pixels/sec/GHz.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleColor2xLI/*"/>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleColor2xLI ()
	{
		Pix RetObj = _All.pixScaleColor2xLI(this);
		return RetObj;
	}

	// scale1.c (634, 1)
	// pixScaleColor4xLI(pixs) as Pix
	// pixScaleColor4xLI(PIX *) as PIX *
	///  <summary>
	/// (1) This is a special case of color linear interpolated scaling,
	/// for 4x upscaling.  It is about 3x faster than using
	/// the generic pixScaleColorLI().<para/>
	///
	/// (2) The speed on intel hardware is about
	/// 30  10^6 dest-pixels/sec/GHz<para/>
	///
	/// (3) This scales each component separately, using pixScaleGray4xLI().
	/// It would be about 4x faster to inline the color code properly,
	/// in analogy to scaleColor4xLILow(), and I leave this as
	/// an exercise for someone who really needs it.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleColor4xLI/*"/>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleColor4xLI ()
	{
		Pix RetObj = _All.pixScaleColor4xLI(this);
		return RetObj;
	}

	// scale1.c (738, 1)
	// pixScaleGrayLI(pixs, scalex, scaley) as Pix
	// pixScaleGrayLI(PIX *, l_float32, l_float32) as PIX *
	///  <summary>
	/// pixScaleGrayLI()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleGrayLI/*"/>
	///  <param name="scalex">[in] - must both be greater or equal 0.7</param>
	///  <param name="scaley">[in] - must both be greater or equal 0.7</param>
	///   <returns>pixd, or NULL on error This function is appropriate for upscaling magnification, where the scale factor is  is greater  1, as well as for a small amount of downscaling reduction, with scale factor  is greater  0.7.  If the scale factor is  is smaller 0.7, the best result is obtained by area mapping, but this is relatiely expensive.  A less expensive alternative with scale factor  is smaller 0.7 is low-pass filtering followed by subsampling (pixScaleSmooth()), which is effectively a cheap form of area mapping. Some more details follow. For each pixel in the dest, this does a linear interpolation of 4 neighboring pixels in the src. Specifically, consider the UL corner of src and dest pixels.  The UL corner of the dest falls within a src pixel, whose four corners are the UL corners of 4 adjacent src pixels.  The value of the dest is taken by linear interpolation using the values of the four src pixels and the distance of the UL corner of the dest from each corner. If the image is expanded so that the dest pixel is smaller than the src pixel, such interpolation is a reasonable approach.  This interpolation is also good for a small image reduction factor that is not more than a 2x reduction. Note that the linear interpolation algorithm for scaling is identical in form to the area-mapping algorithm for grayscale rotation.  The latter corresponds to a translation of each pixel without scaling. This function is NOT optimal if the scaling involves a large reduction.    If the image is significantly reduced, so that the dest pixel is much larger than the src pixels, this interpolation, which is over src pixels only near the UL corner of the dest pixel, is not going to give a good area-mapping average. Because area mapping for image scaling is considerably more computationally intensive than linear interpolation, we choose not to use it.   For large image reduction, linear interpolation over adjacent src pixels degenerates asymptotically to subsampling.  But subsampling without a low-pass pre-filter causes aliasing by the nyquist theorem.  To avoid aliasing, a low-pass filter e.g., an averaging filter of size roughly equal to the dest pixel i.e., the reduction factor should be applied to the src before subsampling. As an alternative to low-pass filtering and subsampling for large reduction factors, linear interpolation can also be done between the widely separated src pixels in which the corners of the dest pixel lie.  This also is not optimal, as it samples src pixels only near the corners of the dest pixel, and it is not implemented. The speed on circa 2005 Intel hardware for the general case (not 2x) is about 13  10^6 dest-pixels/sec/GHz.  The special 2x case runs at about 100  10^6 dest-pixels/sec/GHz.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleGrayLI (Single scalex,
							Single scaley)
	{
		Pix RetObj = _All.pixScaleGrayLI(this, scalex, scaley);
		return RetObj;
	}

	// scale1.c (801, 1)
	// pixScaleGray2xLI(pixs) as Pix
	// pixScaleGray2xLI(PIX *) as PIX *
	///  <summary>
	/// (1) This is a special case of gray linear interpolated scaling,
	/// for 2x upscaling.  It is about 6x faster than using
	/// the generic pixScaleGrayLI().<para/>
	///
	/// (2) The speed on intel hardware is about
	/// 100  10^6 dest-pixels/sec/GHz
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleGray2xLI/*"/>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleGray2xLI ()
	{
		Pix RetObj = _All.pixScaleGray2xLI(this);
		return RetObj;
	}

	// scale1.c (844, 1)
	// pixScaleGray4xLI(pixs) as Pix
	// pixScaleGray4xLI(PIX *) as PIX *
	///  <summary>
	/// (1) This is a special case of gray linear interpolated scaling,
	/// for 4x upscaling.  It is about 12x faster than using
	/// the generic pixScaleGrayLI().<para/>
	///
	/// (2) The speed on intel hardware is about
	/// 160  10^6 dest-pixels/sec/GHz.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleGray4xLI/*"/>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleGray4xLI ()
	{
		Pix RetObj = _All.pixScaleGray4xLI(this);
		return RetObj;
	}

	// scale1.c (889, 1)
	// pixScaleGray2xLIThresh(pixs, thresh) as Pix
	// pixScaleGray2xLIThresh(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This does 2x upscale on pixs, using linear interpolation,
	/// followed by thresholding to binary.<para/>
	///
	/// (2) Buffers are used to avoid making a large grayscale image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleGray2xLIThresh/*"/>
	///  <param name="thresh">[in] - between 0 and 256</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleGray2xLIThresh (int thresh)
	{
		Pix RetObj = _All.pixScaleGray2xLIThresh(this, thresh);
		return RetObj;
	}

	// scale1.c (968, 1)
	// pixScaleGray2xLIDither(pixs) as Pix
	// pixScaleGray2xLIDither(PIX *) as PIX *
	///  <summary>
	/// (1) This does 2x upscale on pixs, using linear interpolation,
	/// followed by Floyd-Steinberg dithering to binary.<para/>
	///
	/// (2) Buffers are used to avoid making a large grayscale image.
	/// ~ Two line buffers are used for the src, required for the 2x
	/// LI upscale.
	/// ~ Three line buffers are used for the intermediate image.
	/// Two are filled with each 2xLI row operation the third is
	/// needed because the upscale and dithering ops are out of sync.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleGray2xLIDither/*"/>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleGray2xLIDither ()
	{
		Pix RetObj = _All.pixScaleGray2xLIDither(this);
		return RetObj;
	}

	// scale1.c (1087, 1)
	// pixScaleGray4xLIThresh(pixs, thresh) as Pix
	// pixScaleGray4xLIThresh(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This does 4x upscale on pixs, using linear interpolation,
	/// followed by thresholding to binary.<para/>
	///
	/// (2) Buffers are used to avoid making a large grayscale image.<para/>
	///
	/// (3) If a full 4x expanded grayscale image can be kept in memory,
	/// this function is only about 10% faster than separately doing
	/// a linear interpolation to a large grayscale image, followed
	/// by thresholding to binary.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleGray4xLIThresh/*"/>
	///  <param name="thresh">[in] - between 0 and 256</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleGray4xLIThresh (int thresh)
	{
		Pix RetObj = _All.pixScaleGray4xLIThresh(this, thresh);
		return RetObj;
	}

	// scale1.c (1175, 1)
	// pixScaleGray4xLIDither(pixs) as Pix
	// pixScaleGray4xLIDither(PIX *) as PIX *
	///  <summary>
	/// (1) This does 4x upscale on pixs, using linear interpolation,
	/// followed by Floyd-Steinberg dithering to binary.<para/>
	///
	/// (2) Buffers are used to avoid making a large grayscale image.
	/// ~ Two line buffers are used for the src, required for the
	/// 4xLI upscale.
	/// ~ Five line buffers are used for the intermediate image.
	/// Four are filled with each 4xLI row operation the fifth
	/// is needed because the upscale and dithering ops are
	/// out of sync.<para/>
	///
	/// (3) If a full 4x expanded grayscale image can be kept in memory,
	/// this function is only about 5% faster than separately doing
	/// a linear interpolation to a large grayscale image, followed
	/// by error-diffusion dithering to binary.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleGray4xLIDither/*"/>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleGray4xLIDither ()
	{
		Pix RetObj = _All.pixScaleGray4xLIDither(this);
		return RetObj;
	}

	// scale1.c (1298, 1)
	// pixScaleBySampling(pixs, scalex, scaley) as Pix
	// pixScaleBySampling(PIX *, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) This function samples from the source without
	/// filtering.  As a result, aliasing will occur for
	/// subsampling (%scalex and/or %scaley  is smaller 1.0).<para/>
	///
	/// (2) If %scalex == 1.0 and %scaley == 1.0, returns a copy.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleBySampling/*"/>
	///  <param name="scalex">[in] - both  is greater  0.0</param>
	///  <param name="scaley">[in] - both  is greater  0.0</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleBySampling (Single scalex,
								Single scaley)
	{
		Pix RetObj = _All.pixScaleBySampling(this, scalex, scaley);
		return RetObj;
	}

	// scale1.c (1360, 1)
	// pixScaleBySamplingToSize(pixs, wd, hd) as Pix
	// pixScaleBySamplingToSize(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This guarantees that the output scaled image has the
	/// dimension(s) you specify.
	/// ~ To specify the width with isotropic scaling, set %hd = 0.
	/// ~ To specify the height with isotropic scaling, set %wd = 0.
	/// ~ If both %wd and %hd are specified, the image is scaled
	/// (in general, anisotropically) to that size.
	/// ~ It is an error to set both %wd and %hd to 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleBySamplingToSize/*"/>
	///  <param name="wd">[in] - target width use 0 if using height as target</param>
	///  <param name="hd">[in] - target height use 0 if using width as target</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleBySamplingToSize (int wd,
									  int hd)
	{
		Pix RetObj = _All.pixScaleBySamplingToSize(this, wd, hd);
		return RetObj;
	}

	// scale1.c (1405, 1)
	// pixScaleByIntSampling(pixs, factor) as Pix
	// pixScaleByIntSampling(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Simple interface to pixScaleBySampling(), for
	/// isotropic integer reduction.<para/>
	///
	/// (2) If %factor == 1, returns a copy.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleByIntSampling/*"/>
	///  <param name="factor">[in] - integer subsampling</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleByIntSampling (int factor)
	{
		Pix RetObj = _All.pixScaleByIntSampling(this, factor);
		return RetObj;
	}

	// scale1.c (1447, 1)
	// pixScaleRGBToGrayFast(pixs, factor, color) as Pix
	// pixScaleRGBToGrayFast(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This does simultaneous subsampling by an integer factor and
	/// extraction of the color from the RGB pix.<para/>
	///
	/// (2) It is designed for maximum speed, and is used for quickly
	/// generating a downsized grayscale image from a higher resolution
	/// RGB image.  This would typically be used for image analysis.<para/>
	///
	/// (3) The standard color byte order (RGBA) is assumed.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleRGBToGrayFast/*"/>
	///  <param name="factor">[in] - integer reduction factor greater or equal 1</param>
	///  <param name="color">[in] - one of COLOR_RED, COLOR_GREEN, COLOR_BLUE</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleRGBToGrayFast (int factor,
								   int color)
	{
		Pix RetObj = _All.pixScaleRGBToGrayFast(this, factor, color);
		return RetObj;
	}

	// scale1.c (1522, 1)
	// pixScaleRGBToBinaryFast(pixs, factor, thresh) as Pix
	// pixScaleRGBToBinaryFast(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This does simultaneous subsampling by an integer factor and
	/// conversion from RGB to gray to binary.<para/>
	///
	/// (2) It is designed for maximum speed, and is used for quickly
	/// generating a downsized binary image from a higher resolution
	/// RGB image.  This would typically be used for image analysis.<para/>
	///
	/// (3) It uses the green channel to represent the RGB pixel intensity.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleRGBToBinaryFast/*"/>
	///  <param name="factor">[in] - integer reduction factor greater or equal 1</param>
	///  <param name="thresh">[in] - binarization threshold</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleRGBToBinaryFast (int factor,
									 int thresh)
	{
		Pix RetObj = _All.pixScaleRGBToBinaryFast(this, factor, thresh);
		return RetObj;
	}

	// scale1.c (1588, 1)
	// pixScaleGrayToBinaryFast(pixs, factor, thresh) as Pix
	// pixScaleGrayToBinaryFast(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This does simultaneous subsampling by an integer factor and
	/// thresholding from gray to binary.<para/>
	///
	/// (2) It is designed for maximum speed, and is used for quickly
	/// generating a downsized binary image from a higher resolution
	/// gray image.  This would typically be used for image analysis.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleGrayToBinaryFast/*"/>
	///  <param name="factor">[in] - integer reduction factor greater or equal 1</param>
	///  <param name="thresh">[in] - binarization threshold</param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleGrayToBinaryFast (int factor,
									  int thresh)
	{
		Pix RetObj = _All.pixScaleGrayToBinaryFast(this, factor, thresh);
		return RetObj;
	}

	// scale1.c (1671, 1)
	// pixScaleSmooth(pix, scalex, scaley) as Pix
	// pixScaleSmooth(PIX *, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) This function should only be used when the scale factors are less
	/// than or equal to 0.7 (i.e., more than about 1.42x reduction).
	/// If either scale factor is larger than 0.7, we issue a warning
	/// and call pixScaleGeneral(), which will invoke linear
	/// interpolation without sharpening.<para/>
	///
	/// (2) This works only on 2, 4, 8 and 32 bpp images, and if there is
	/// a colormap, it is removed by converting to RGB.  In other
	/// cases, we issue a warning and call pixScaleGeneral().<para/>
	///
	/// (3) It does simple (flat filter) convolution, with a filter size
	/// commensurate with the amount of reduction, to avoid antialiasing.<para/>
	///
	/// (4) It does simple subsampling after smoothing, which is appropriate
	/// for this range of scaling.  Linear interpolation gives essentially
	/// the same result with more computation for these scale factors,
	/// so we don't use it.<para/>
	///
	/// (5) The result is the same as doing a full block convolution followed by
	/// subsampling, but this is faster because the results of the block
	/// convolution are only computed at the subsampling locations.
	/// In fact, the computation time is approximately independent of
	/// the scale factor, because the convolution kernel is adjusted
	/// so that each source pixel is summed approximately once.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleSmooth/*"/>
	///  <param name="pix">[in] - 2, 4, 8 or 32 bpp and 2, 4, 8 bpp with colormap</param>
	///  <param name="scalex">[in] - must both be  is smaller 0.7</param>
	///  <param name="scaley">[in] - must both be  is smaller 0.7</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleSmooth (Pix pix,
							Single scalex,
							Single scaley)
	{
		Pix RetObj = _All.pixScaleSmooth(pix, scalex, scaley);
		return RetObj;
	}

	// scale1.c (1767, 1)
	// pixScaleSmoothToSize(pixs, wd, hd) as Pix
	// pixScaleSmoothToSize(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See notes in pixScaleSmooth().<para/>
	///
	/// (2) The output scaled image has the dimension(s) you specify:
	/// To specify the width with isotropic scaling, set %hd = 0.
	/// To specify the height with isotropic scaling, set %wd = 0.
	/// If both %wd and %hd are specified, the image is scaled
	/// (in general, anisotropically) to that size.
	/// It is an error to set both %wd and %hd to 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleSmoothToSize/*"/>
	///  <param name="wd">[in] - target width use 0 if using height as target</param>
	///  <param name="hd">[in] - target height use 0 if using width as target</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleSmoothToSize (int wd,
								  int hd)
	{
		Pix RetObj = _All.pixScaleSmoothToSize(this, wd, hd);
		return RetObj;
	}

	// scale1.c (1805, 1)
	// pixScaleRGBToGray2(pixs, rwt, gwt, bwt) as Pix
	// pixScaleRGBToGray2(PIX *, l_float32, l_float32, l_float32) as PIX *
	///  <summary>
	/// pixScaleRGBToGray2()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleRGBToGray2/*"/>
	///  <param name="rwt">[in] - must sum to 1.0</param>
	///  <param name="gwt">[in] - must sum to 1.0</param>
	///  <param name="bwt">[in] - must sum to 1.0</param>
	///   <returns>pixd, 8 bpp, 2x reduced, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleRGBToGray2 (Single rwt,
								Single gwt,
								Single bwt)
	{
		Pix RetObj = _All.pixScaleRGBToGray2(this, rwt, gwt, bwt);
		return RetObj;
	}

	// scale1.c (1872, 1)
	// pixScaleAreaMap(pix, scalex, scaley) as Pix
	// pixScaleAreaMap(PIX *, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) This function should only be used when the scale factors are less
	/// than or equal to 0.7 (i.e., more than about 1.42x reduction).
	/// If either scale factor is larger than 0.7, we issue a warning
	/// and call pixScaleGeneral(), which will invoke linear
	/// interpolation without sharpening.<para/>
	///
	/// (2) This works only on 2, 4, 8 and 32 bpp images.  If there is
	/// a colormap, it is removed by converting to RGB.  In other
	/// cases, we issue a warning and call pixScaleGeneral().<para/>
	///
	/// (3) This is faster than pixScale() because it does not do sharpening.<para/>
	///
	/// (4) It does a relatively expensive area mapping computation, to
	/// avoid antialiasing.  It is about 2x slower than pixScaleSmooth(),
	/// but the results are much better on fine text.<para/>
	///
	/// (5) This is typically about 20% faster for the special cases of
	/// 2x, 4x, 8x and 16x reduction.<para/>
	///
	/// (6) Surprisingly, there is no speedup (and a slight quality
	/// impairment) if you do as many successive 2x reductions as
	/// possible, ending with a reduction with a scale factor larger
	/// than 0.5.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleAreaMap/*"/>
	///  <param name="pix">[in] - 2, 4, 8 or 32 bpp and 2, 4, 8 bpp with colormap</param>
	///  <param name="scalex">[in] - must both be smaller or equal 0.7</param>
	///  <param name="scaley">[in] - must both be smaller or equal 0.7</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleAreaMap (Pix pix,
							 Single scalex,
							 Single scaley)
	{
		Pix RetObj = _All.pixScaleAreaMap(pix, scalex, scaley);
		return RetObj;
	}

	// scale1.c (1992, 1)
	// pixScaleAreaMap2(pix) as Pix
	// pixScaleAreaMap2(PIX *) as PIX *
	///  <summary>
	/// (1) This function does an area mapping (average) for 2x
	/// reduction.<para/>
	///
	/// (2) This works only on 2, 4, 8 and 32 bpp images.  If there is
	/// a colormap, it is removed by converting to RGB.<para/>
	///
	/// (3) Speed on 3 GHz processor:
	/// Color: 160 Mpix/sec
	/// Gray: 700 Mpix/sec
	/// This contrasts with the speed of the general pixScaleAreaMap():
	/// Color: 35 Mpix/sec
	/// Gray: 50 Mpix/sec<para/>
	///
	/// (4) From (3), we see that this special function is about 4.5x
	/// faster for color and 14x faster for grayscale<para/>
	///
	/// (5) Consequently, pixScaleAreaMap2() is incorporated into the
	/// general area map scaling function, for the special cases
	/// of 2x, 4x, 8x and 16x reduction.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleAreaMap2/*"/>
	///  <param name="pix">[in] - 2, 4, 8 or 32 bpp and 2, 4, 8 bpp with colormap</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleAreaMap2 (Pix pix)
	{
		Pix RetObj = _All.pixScaleAreaMap2(pix);
		return RetObj;
	}

	// scale1.c (2057, 1)
	// pixScaleAreaMapToSize(pixs, wd, hd) as Pix
	// pixScaleAreaMapToSize(PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See notes in pixScaleAreaMap().<para/>
	///
	/// (2) The output scaled image has the dimension(s) you specify:
	/// To specify the width with isotropic scaling, set %hd = 0.
	/// To specify the height with isotropic scaling, set %wd = 0.
	/// If both %wd and %hd are specified, the image is scaled
	/// (in general, anisotropically) to that size.
	/// It is an error to set both %wd and %hd to 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleAreaMapToSize/*"/>
	///  <param name="wd">[in] - target width use 0 if using height as target</param>
	///  <param name="hd">[in] - target height use 0 if using width as target</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleAreaMapToSize (int wd,
								   int hd)
	{
		Pix RetObj = _All.pixScaleAreaMapToSize(this, wd, hd);
		return RetObj;
	}

	// scale1.c (2105, 1)
	// pixScaleBinary(pixs, scalex, scaley) as Pix
	// pixScaleBinary(PIX *, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) This function samples from the source without
	/// filtering.  As a result, aliasing will occur for
	/// subsampling (scalex and scaley  is smaller 1.0).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleBinary/*"/>
	///  <param name="scalex">[in] - both  is greater  0.0</param>
	///  <param name="scaley">[in] - both  is greater  0.0</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleBinary (Single scalex,
							Single scaley)
	{
		Pix RetObj = _All.pixScaleBinary(this, scalex, scaley);
		return RetObj;
	}

	// scale2.c (204, 1)
	// pixScaleToGray(pixs, scalefactor) as Pix
	// pixScaleToGray(PIX *, l_float32) as PIX *
	///  <summary>
	/// For faster scaling in the range of scalefactors from 0.0625 to 0.5,
	/// with very little difference in quality, use pixScaleToGrayFast().
	/// Binary images have sharp edges, so they intrinsically have very
	/// high frequency content.  To avoid aliasing, they must be low-pass
	/// filtered, which tends to blur the edges.  How can we keep relatively
	/// crisp edges without aliasing?  The trick is to do binary upscaling
	/// followed by a power-of-2 scaleToGray.  For large reductions, where
	/// you don't end up with much detail, some corners can be cut.
	/// The intent here is to get high quality reduced grayscale
	/// images with relatively little computation.  We do binary
	/// pre-scaling followed by scaleToGrayN() for best results,
	/// esp. to avoid excess blur when the scale factor is near
	/// an inverse power of 2.  Where a low-pass filter is required,
	/// we use simple convolution kernels: either the hat filter for
	/// linear interpolation or a flat filter for larger downscaling.
	/// Other choices, such as a perfect bandpass filter with infinite extent
	/// (the sinc) or various approximations to it (e.g., lanczos), are
	/// unnecessarily expensive.
	/// The choices made are as follows:<para/>
	///
	/// (1) Do binary upscaling before scaleToGrayN() for scalefactors  is greater  1/8<para/>
	///
	/// (2) Do binary downscaling before scaleToGray8() for scalefactors
	/// between 1/16 and 1/8.<para/>
	///
	/// (3) Use scaleToGray16() before grayscale downscaling for
	/// scalefactors less than 1/16
	/// Another reasonable choice would be to start binary downscaling
	/// for scalefactors below 1/4, rather than below 1/8 as we do here.
	/// The general scaling rules, not all of which are used here, go as follows:<para/>
	///
	/// (1) For grayscale upscaling, use pixScaleGrayLI().  However,
	/// note that edges will be visibly blurred for scalefactors
	/// near (but above) 1.0.  Replication will avoid edge blur,
	/// and should be considered for factors very near 1.0.<para/>
	///
	/// (2) For grayscale downscaling with a scale factor larger than
	/// about 0.7, use pixScaleGrayLI().  For scalefactors near
	/// (but below) 1.0, you tread between Scylla and Charybdis.
	/// pixScaleGrayLI() again gives edge blurring, but
	/// pixScaleBySampling() gives visible aliasing.<para/>
	///
	/// (3) For grayscale downscaling with a scale factor smaller than
	/// about 0.7, use pixScaleSmooth()<para/>
	///
	/// (4) For binary input images, do as much scale to gray as possible
	/// using the special integer functions (2, 3, 4, 8 and 16).<para/>
	///
	/// (5) It is better to upscale in binary, followed by scaleToGrayN()
	/// than to do scaleToGrayN() followed by an upscale using either
	/// LI or oversampling.<para/>
	///
	/// (6) It may be better to downscale in binary, followed by
	/// scaleToGrayN() than to first use scaleToGrayN() followed by
	/// downscaling.  For downscaling between 8x and 16x, this is
	/// a reasonable option.<para/>
	///
	/// (7) For reductions greater than 16x, it's reasonable to use
	/// scaleToGray16() followed by further grayscale downscaling.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleToGray/*"/>
	///  <param name="scalefactor">[in] - reduction: must be  is greater  0.0 and  is smaller 1.0</param>
	///   <returns>pixd 8 bpp, scaled down by scalefactor in each direction, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleToGray (Single scalefactor)
	{
		Pix RetObj = _All.pixScaleToGray(this, scalefactor);
		return RetObj;
	}

	// scale2.c (315, 1)
	// pixScaleToGrayFast(pixs, scalefactor) as Pix
	// pixScaleToGrayFast(PIX *, l_float32) as PIX *
	///  <summary>
	/// (1) See notes in pixScaleToGray() for the basic approach.<para/>
	///
	/// (2) This function is considerably less expensive than pixScaleToGray()
	/// for scalefactor in the range (0.0625 ... 0.5), and the
	/// quality is nearly as good.<para/>
	///
	/// (3) Unlike pixScaleToGray(), which does binary upscaling before
	/// downscaling for scale factors greater or equal 0.0625, pixScaleToGrayFast()
	/// first downscales in binary for all scale factors  is smaller 0.5, and
	/// then does a 2x scale-to-gray as the final step.  For
	/// scale factors  is smaller 0.0625, both do a 16x scale-to-gray, followed
	/// by further grayscale reduction.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleToGrayFast/*"/>
	///  <param name="scalefactor">[in] - reduction: must be  is greater  0.0 and  is smaller 1.0</param>
	///   <returns>pixd 8 bpp, scaled down by scalefactor in each direction, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleToGrayFast (Single scalefactor)
	{
		Pix RetObj = _All.pixScaleToGrayFast(this, scalefactor);
		return RetObj;
	}

	// scale2.c (386, 1)
	// pixScaleToGray2(pixs) as Pix
	// pixScaleToGray2(PIX *) as PIX *
	///  <summary>
	/// pixScaleToGray2()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleToGray2/*"/>
	///   <returns>pixd 8 bpp, scaled down by 2x in each direction, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleToGray2 ()
	{
		Pix RetObj = _All.pixScaleToGray2(this);
		return RetObj;
	}

	// scale2.c (443, 1)
	// pixScaleToGray3(pixs) as Pix
	// pixScaleToGray3(PIX *) as PIX *
	///  <summary>
	/// (1) Speed is about 100 x 10^6 src-pixels/sec/GHz.
	/// Another way to express this is it processes 1 src pixel
	/// in about 10 cycles.<para/>
	///
	/// (2) The width of pixd is truncated is truncated to a factor of 8.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleToGray3/*"/>
	///   <returns>pixd 8 bpp, scaled down by 3x in each direction, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleToGray3 ()
	{
		Pix RetObj = _All.pixScaleToGray3(this);
		return RetObj;
	}

	// scale2.c (497, 1)
	// pixScaleToGray4(pixs) as Pix
	// pixScaleToGray4(PIX *) as PIX *
	///  <summary>
	/// (1) The width of pixd is truncated is truncated to a factor of 2.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleToGray4/*"/>
	///   <returns>pixd 8 bpp, scaled down by 4x in each direction, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleToGray4 ()
	{
		Pix RetObj = _All.pixScaleToGray4(this);
		return RetObj;
	}

	// scale2.c (552, 1)
	// pixScaleToGray6(pixs) as Pix
	// pixScaleToGray6(PIX *) as PIX *
	///  <summary>
	/// (1) The width of pixd is truncated is truncated to a factor of 8.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleToGray6/*"/>
	///   <returns>pixd 8 bpp, scaled down by 6x in each direction, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleToGray6 ()
	{
		Pix RetObj = _All.pixScaleToGray6(this);
		return RetObj;
	}

	// scale2.c (600, 1)
	// pixScaleToGray8(pixs) as Pix
	// pixScaleToGray8(PIX *) as PIX *
	///  <summary>
	/// pixScaleToGray8()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleToGray8/*"/>
	///   <returns>pixd 8 bpp, scaled down by 8x in each direction, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleToGray8 ()
	{
		Pix RetObj = _All.pixScaleToGray8(this);
		return RetObj;
	}

	// scale2.c (649, 1)
	// pixScaleToGray16(pixs) as Pix
	// pixScaleToGray16(PIX *) as PIX *
	///  <summary>
	/// pixScaleToGray16()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleToGray16/*"/>
	///   <returns>pixd 8 bpp, scaled down by 16x in each direction, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleToGray16 ()
	{
		Pix RetObj = _All.pixScaleToGray16(this);
		return RetObj;
	}

	// scale2.c (722, 1)
	// pixScaleToGrayMipmap(pixs, scalefactor) as Pix
	// pixScaleToGrayMipmap(PIX *, l_float32) as PIX *
	///  <summary>
	/// This function is here mainly for pedagogical reasons.
	/// Mip-mapping is widely used in graphics for texture mapping, because
	/// the texture changes smoothly with scale.  This is accomplished by
	/// constructing a multiresolution pyramid and, for each pixel,
	/// doing a linear interpolation between corresponding pixels in
	/// the two planes of the pyramid that bracket the desired resolution.
	/// The computation is very efficient, and is implemented in hardware
	/// in high-end graphics cards.
	/// We can use mip-mapping for scale-to-gray by using two scale-to-gray
	/// reduced images (we don't need the entire pyramid) selected from
	/// the set {2x, 4x, ... 16x}, and interpolating.  However, we get
	/// severe aliasing, probably because we are subsampling from the
	/// higher resolution image.  The method is very fast, but the result
	/// is very poor.  In fact, the results don't look any better than
	/// either subsampling off the higher-res grayscale image or oversampling
	/// on the lower-res image.  Consequently, this method should NOT be used
	/// for generating reduced images, scale-to-gray or otherwise.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleToGrayMipmap/*"/>
	///  <param name="scalefactor">[in] - reduction: must be  is greater  0.0 and  is smaller 1.0</param>
	///   <returns>pixd 8 bpp, scaled down by scalefactor in each direction, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleToGrayMipmap (Single scalefactor)
	{
		Pix RetObj = _All.pixScaleToGrayMipmap(this, scalefactor);
		return RetObj;
	}

	// scale2.c (810, 1)
	// pixScaleMipmap(pixs1, pixs2, scale) as Pix
	// pixScaleMipmap(PIX *, PIX *, l_float32) as PIX *
	///  <summary>
	/// (1) See notes in pixScaleToGrayMipmap().<para/>
	///
	/// (2) This function suffers from aliasing effects that are
	/// easily seen in document images.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleMipmap/*"/>
	///  <param name="pixs1">[in] - high res 8 bpp, no cmap</param>
	///  <param name="pixs2">[in] - low res -- 2x reduced -- 8 bpp, no cmap</param>
	///  <param name="scale">[in] - reduction with respect to high res image,  is greater  0.5</param>
	///   <returns>8 bpp pix, scaled down by reduction in each direction, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleMipmap (Pix pixs1,
							Pix pixs2,
							Single scale)
	{
		Pix RetObj = _All.pixScaleMipmap(pixs1, pixs2, scale);
		return RetObj;
	}

	// scale2.c (867, 1)
	// pixExpandReplicate(pixs, factor) as Pix
	// pixExpandReplicate(PIX *, l_int32) as PIX *
	///  <summary>
	/// pixExpandReplicate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExpandReplicate/*"/>
	///  <param name="factor">[in] - integer scale factor for replicative expansion</param>
	///   <returns>pixd scaled up, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ExpandReplicate (int factor)
	{
		Pix RetObj = _All.pixExpandReplicate(this, factor);
		return RetObj;
	}

	// scale2.c (1014, 1)
	// pixScaleGrayMinMax(pixs, xfact, yfact, type) as Pix
	// pixScaleGrayMinMax(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The downscaled pixels in pixd are the min, max or (max - min)
	/// of the corresponding set of xfact  yfact pixels in pixs.<para/>
	///
	/// (2) Using L_CHOOSE_MIN is equivalent to a grayscale erosion,
	/// using a brick Sel of size (xfact  yfact), followed by
	/// subsampling within each (xfact  yfact) cell.  Using
	/// L_CHOOSE_MAX is equivalent to the corresponding dilation.<para/>
	///
	/// (3) Using L_CHOOSE_MAXDIFF finds the difference between max
	/// and min values in each cell.<para/>
	///
	/// (4) For the special case of downscaling by 2x in both directions,
	/// pixScaleGrayMinMax2() is about 2x more efficient.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleGrayMinMax/*"/>
	///  <param name="xfact">[in] - x downscaling factor integer</param>
	///  <param name="yfact">[in] - y downscaling factor integer</param>
	///  <param name="type">[in] - L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF</param>
	///   <returns>pixd 8 bpp</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleGrayMinMax (int xfact,
								int yfact,
								int type)
	{
		Pix RetObj = _All.pixScaleGrayMinMax(this, xfact, yfact, type);
		return RetObj;
	}

	// scale2.c (1121, 1)
	// pixScaleGrayMinMax2(pixs, type) as Pix
	// pixScaleGrayMinMax2(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Special version for 2x reduction.  The downscaled pixels
	/// in pixd are the min, max or (max - min) of the corresponding
	/// set of 4 pixels in pixs.<para/>
	///
	/// (2) The max and min operations are a special case (for levels 1
	/// and 4) of grayscale analog to the binary rank scaling operation
	/// pixReduceRankBinary2().  Note, however, that because of
	/// the photometric definition that higher gray values are
	/// lighter, the erosion-like L_CHOOSE_MIN will darken
	/// the resulting image, corresponding to a threshold level 1
	/// in the binary case.  Likewise, L_CHOOSE_MAX will lighten
	/// the pixd, corresponding to a threshold level of 4.<para/>
	///
	/// (3) To choose any of the four rank levels in a 2x grayscale
	/// reduction, use pixScaleGrayRank2().<para/>
	///
	/// (4) This runs at about 70 MPix/sec/GHz of source data for
	/// erosion and dilation.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleGrayMinMax2/*"/>
	///  <param name="type">[in] - L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF</param>
	///   <returns>pixd 8 bpp downscaled by 2x</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleGrayMinMax2 (int type)
	{
		Pix RetObj = _All.pixScaleGrayMinMax2(this, type);
		return RetObj;
	}

	// scale2.c (1204, 1)
	// pixScaleGrayRankCascade(pixs, level1, level2, level3, level4) as Pix
	// pixScaleGrayRankCascade(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This performs up to four cascaded 2x rank reductions.<para/>
	///
	/// (2) Use level = 0 to truncate the cascade.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleGrayRankCascade/*"/>
	///  <param name="level1">[in] - rank thresholds, in set {0, 1, 2, 3, 4}</param>
	///  <param name="level2">[in] - rank thresholds, in set {0, 1, 2, 3, 4}</param>
	///  <param name="level3">[in] - rank thresholds, in set {0, 1, 2, 3, 4}</param>
	///  <param name="level4">[in] - rank thresholds, in set {0, 1, 2, 3, 4}</param>
	///   <returns>pixd 8 bpp, downscaled by up to 16x</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleGrayRankCascade (int level1,
									 int level2,
									 int level3,
									 int level4)
	{
		Pix RetObj = _All.pixScaleGrayRankCascade(this, level1, level2, level3, level4);
		return RetObj;
	}

	// scale2.c (1268, 1)
	// pixScaleGrayRank2(pixs, rank) as Pix
	// pixScaleGrayRank2(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Rank 2x reduction.  If rank == 1(4), the downscaled pixels
	/// in pixd are the min(max) of the corresponding set of
	/// 4 pixels in pixs.  Values 2 and 3 are intermediate.<para/>
	///
	/// (2) This is the grayscale analog to the binary rank scaling operation
	/// pixReduceRankBinary2().  Here, because of the photometric
	/// definition that higher gray values are lighter, rank 1 gives
	/// the darkest pixel, whereas rank 4 gives the lightest pixel.
	/// This is opposite to the binary rank operation.<para/>
	///
	/// (3) For rank = 1 and 4, this calls pixScaleGrayMinMax2(),
	/// which runs at about 70 MPix/sec/GHz of source data.
	/// For rank 2 and 3, this runs 3x slower, at about 25 MPix/sec/GHz.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleGrayRank2/*"/>
	///  <param name="rank">[in] - 1 (darkest), 2, 3, 4 (lightest)</param>
	///   <returns>pixd 8 bpp, downscaled by 2x</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleGrayRank2 (int rank)
	{
		Pix RetObj = _All.pixScaleGrayRank2(this, rank);
		return RetObj;
	}

	// scale2.c (1358, 1)
	// pixScaleAndTransferAlpha(pixd, pixs, scalex, scaley) as int
	// pixScaleAndTransferAlpha(PIX *, PIX *, l_float32, l_float32) as l_ok
	///  <summary>
	/// (1) This scales the alpha component of pixs and inserts into pixd.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleAndTransferAlpha/*"/>
	///  <param name="pixd">[in] - 32 bpp, scaled image</param>
	///  <param name="scalex">[in] - both  is greater  0.0</param>
	///  <param name="scaley">[in] - both  is greater  0.0</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ScaleAndTransferAlpha (Pix pixd,
									  Single scalex,
									  Single scaley)
	{
		int RetObj = _All.pixScaleAndTransferAlpha(pixd, this, scalex, scaley);
		return RetObj;
	}

	// scale2.c (1436, 1)
	// pixScaleWithAlpha(pixs, scalex, scaley, pixg, fract) as Pix
	// pixScaleWithAlpha(PIX *, l_float32, l_float32, PIX *, l_float32) as PIX *
	///  <summary>
	/// (1) The alpha channel is transformed separately from pixs,
	/// and aligns with it, being fully transparent outside the
	/// boundary of the transformed pixs.  For pixels that are fully
	/// transparent, a blending function like pixBlendWithGrayMask()
	/// will give zero weight to corresponding pixels in pixs.<para/>
	///
	/// (2) Scaling is done with area mapping or linear interpolation,
	/// depending on the scale factors.  Default sharpening is done.<para/>
	///
	/// (3) If pixg is NULL, it is generated as an alpha layer that is
	/// partially opaque, using %fract.  Otherwise, it is cropped
	/// to pixs if required, and %fract is ignored.  The alpha
	/// channel in pixs is never used.<para/>
	///
	/// (4) Colormaps are removed to 32 bpp.<para/>
	///
	/// (5) The default setting for the border values in the alpha channel
	/// is 0 (transparent) for the outermost ring of pixels and
	/// (0.5  fract  255) for the second ring.  When blended over
	/// a second image, this
	/// (a) shrinks the visible image to make a clean overlap edge
	/// with an image below, and
	/// (b) softens the edges by weakening the aliasing there.
	/// Use l_setAlphaMaskBorder() to change these values.<para/>
	///
	/// (6) A subtle use of gamma correction is to remove gamma correction
	/// before scaling and restore it afterwards.  This is done
	/// by sandwiching this function between a gamma/inverse-gamma
	/// photometric transform:
	/// pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255)
	/// pixd = pixScaleWithAlpha(pixt, scalex, scaley, NULL, fract)
	/// pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255)
	/// pixDestroy([and]pixt)
	/// This has the side-effect of producing artifacts in the very
	/// dark regions.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixScaleWithAlpha/*"/>
	///  <param name="scalex">[in] - must be  is greater  0.0</param>
	///  <param name="scaley">[in] - must be  is greater  0.0</param>
	///  <param name="pixg">[in][optional] - 8 bpp, can be null</param>
	///  <param name="fract">[in] - between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	///   <returns>pixd 32 bpp rgba, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ScaleWithAlpha (Single fract,
							   Single scalex,
							   Single scaley,
							   Pix pixg)
	{
		Pix RetObj = _All.pixScaleWithAlpha(this, scalex, scaley, pixg, fract);
		return RetObj;
	}

	// seedfill.c (243, 1)
	// pixSeedfillBinary(pixd, pixs, pixm, connectivity) as Pix
	// pixSeedfillBinary(PIX *, PIX *, PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This is for binary seedfill (aka "binary reconstruction").<para/>
	///
	/// (2) There are 3 cases:
	/// (a) pixd == null (make a new pixd)
	/// (b) pixd == pixs (in-place)
	/// (c) pixd != pixs<para/>
	///
	/// (3) If you know the case, use these patterns for clarity:
	/// (a) pixd = pixSeedfillBinary(NULL, pixs, ...)
	/// (b) pixSeedfillBinary(pixs, pixs, ...)
	/// (c) pixSeedfillBinary(pixd, pixs, ...)<para/>
	///
	/// (4) The resulting pixd contains the filled seed.  For some
	/// applications you want to OR it with the inverse of
	/// the filling mask.<para/>
	///
	/// (5) The input seed and mask images can be different sizes, but
	/// in typical use the difference, if any, would be only
	/// a few pixels in each direction.  If the sizes differ,
	/// the clipping is handled by the low-level function
	/// seedfillBinaryLow().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfillBinary/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs 1 bpp</param>
	///  <param name="pixm">[in] - 1 bpp filling mask</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SeedfillBinary (Pix pixm,
							   int connectivity,
							   Pix pixd)
	{
		Pix RetObj = _All.pixSeedfillBinary(pixd, this, pixm, connectivity);
		return RetObj;
	}

	// seedfill.c (330, 1)
	// pixSeedfillBinaryRestricted(pixd, pixs, pixm, connectivity, xmax, ymax) as Pix
	// pixSeedfillBinaryRestricted(PIX *, PIX *, PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See usage for pixSeedfillBinary(), which has unrestricted fill.
	/// In pixSeedfillBinary(), the filling distance is unrestricted
	/// and can be larger than pixs, depending on the topology of
	/// th mask.<para/>
	///
	/// (2) There are occasions where it is useful not to permit the
	/// fill to go more than a certain distance into the mask.
	/// %xmax specifies the maximum horizontal distance allowed
	/// in the fill %ymax does likewise in the vertical direction.<para/>
	///
	/// (3) Operationally, the max "distance" allowed for the fill
	/// is a linear distance from the original seed, independent
	/// of the actual mask topology.<para/>
	///
	/// (4) Another formulation of this problem, not implemented,
	/// would use the manhattan distance from the seed, as
	/// determined by a breadth-first search starting at the seed
	/// boundaries and working outward where the mask fg allows.
	/// How this might use the constraints of separate xmax and ymax
	/// is not clear.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfillBinaryRestricted/*"/>
	///  <param name="pixd">[in][optional] - this can be null, equal to pixs, or different from pixs 1 bpp</param>
	///  <param name="pixm">[in] - 1 bpp filling mask</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="xmax">[in] - max distance in x direction of fill into the mask</param>
	///  <param name="ymax">[in] - max distance in y direction of fill into the mask</param>
	///   <returns>pixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SeedfillBinaryRestricted (Pix pixm,
										 int connectivity,
										 int xmax,
										 int ymax,
										 Pix pixd)
	{
		Pix RetObj = _All.pixSeedfillBinaryRestricted(pixd, this, pixm, connectivity, xmax, ymax);
		return RetObj;
	}

	// seedfill.c (605, 1)
	// pixHolesByFilling(pixs, connectivity) as Pix
	// pixHolesByFilling(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) To get 4-c.c. holes of the 8-c.c. as foreground, use
	/// 4-connected filling to get 8-c.c. holes of the 4-c.c.
	/// as foreground, use 8-connected filling.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixHolesByFilling/*"/>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>pixd  inverted image of all holes, or NULL on error Action: 1 Start with 1-pixel black border on otherwise white pixd 2 Use the inverted pixs as the filling mask to fill in all the pixels from the border to the pixs foreground 3 OR the result with pixs to have an image with all ON pixels except for the holes. 4 Invert the result to get the holes as foreground</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix HolesByFilling (int connectivity)
	{
		Pix RetObj = _All.pixHolesByFilling(this, connectivity);
		return RetObj;
	}

	// seedfill.c (656, 1)
	// pixFillClosedBorders(pixs, connectivity) as Pix
	// pixFillClosedBorders(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) Start with 1-pixel black border on otherwise white pixd<para/>
	///
	/// (2) Subtract input pixs to remove border pixels that were
	/// also on the closed border<para/>
	///
	/// (3) Use the inverted pixs as the filling mask to fill in
	/// all the pixels from the outer border to the closed border
	/// on pixs<para/>
	///
	/// (4) Invert the result to get the filled component, including
	/// the input border<para/>
	///
	/// (5) If the borders are 4-c.c., use 8-c.c. filling, and v.v.<para/>
	///
	/// (6) Closed borders within c.c. that represent holes, etc., are filled.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFillClosedBorders/*"/>
	///  <param name="connectivity">[in] - filling connectivity 4 or 8</param>
	///   <returns>pixd  all topologically outer closed borders are filled as connected comonents, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FillClosedBorders (int connectivity)
	{
		Pix RetObj = _All.pixFillClosedBorders(this, connectivity);
		return RetObj;
	}

	// seedfill.c (694, 1)
	// pixExtractBorderConnComps(pixs, connectivity) as Pix
	// pixExtractBorderConnComps(PIX *, l_int32) as PIX *
	///  <summary>
	/// pixExtractBorderConnComps()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixExtractBorderConnComps/*"/>
	///  <param name="connectivity">[in] - filling connectivity 4 or 8</param>
	///   <returns>pixd  all pixels in the src that are in connected components touching the border, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ExtractBorderConnComps (int connectivity)
	{
		Pix RetObj = _All.pixExtractBorderConnComps(this, connectivity);
		return RetObj;
	}

	// seedfill.c (733, 1)
	// pixRemoveBorderConnComps(pixs, connectivity) as Pix
	// pixRemoveBorderConnComps(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This removes all fg components touching the border.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRemoveBorderConnComps/*"/>
	///  <param name="connectivity">[in] - filling connectivity 4 or 8</param>
	///   <returns>pixd  all pixels in the src that are not touching the border or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RemoveBorderConnComps (int connectivity)
	{
		Pix RetObj = _All.pixRemoveBorderConnComps(this, connectivity);
		return RetObj;
	}

	// seedfill.c (783, 1)
	// pixFillBgFromBorder(pixs, connectivity) as Pix
	// pixFillBgFromBorder(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This fills all bg components touching the border to fg.
	/// It is the photometric inverse of pixRemoveBorderConnComps().<para/>
	///
	/// (2) Invert the result to get the "holes" left after this fill.
	/// This can be done multiple times, extracting holes within
	/// holes after each pair of fillings.  Specifically, this code
	/// peels away n successive embeddings of components:
	/// \code
	/// pix1 =  is smallerinitial image is greater
	/// for (i = 0 i  is smaller 2  n i++) {
	/// pix2 = pixFillBgFromBorder(pix1, 8)
	/// pixInvert(pix2, pix2)
	/// pixDestroy([and]pix1)
	/// pix1 = pix2
	/// }
	/// \endcode
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFillBgFromBorder/*"/>
	///  <param name="connectivity">[in] - filling connectivity 4 or 8</param>
	///   <returns>pixd with the background c.c. touching the border filled to foreground, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FillBgFromBorder (int connectivity)
	{
		Pix RetObj = _All.pixFillBgFromBorder(this, connectivity);
		return RetObj;
	}

	// seedfill.c (842, 1)
	// pixFillHolesToBoundingRect(pixs, minsize, maxhfract, minfgfract) as Pix
	// pixFillHolesToBoundingRect(PIX *, l_int32, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) This does not fill holes that are smaller in area than 'minsize'.<para/>
	///
	/// (2) This does not fill holes with an area larger than
	/// 'maxhfract' times the fg area of the c.c.<para/>
	///
	/// (3) This does not expand the fg of the c.c. to bounding rect if
	/// the fg area is less than 'minfgfract' times the area of the
	/// bounding rect.<para/>
	///
	/// (4) The decisions are made as follows:
	/// ~ Decide if we are filling the holes if so, when using
	/// the fg area, include the filled holes.
	/// ~ Decide based on the fg area if we are filling to a bounding rect.
	/// If so, do it.
	/// If not, fill the holes if the condition is satisfied.<para/>
	///
	/// (5) The choice of minsize depends on the resolution.<para/>
	///
	/// (6) For solidifying image mask regions on printed materials,
	/// which tend to be rectangular, values for maxhfract
	/// and minfgfract around 0.5 are reasonable.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFillHolesToBoundingRect/*"/>
	///  <param name="minsize">[in] - min number of pixels in the hole</param>
	///  <param name="maxhfract">[in] - max hole area as fraction of fg pixels in the cc</param>
	///  <param name="minfgfract">[in] - min fg area as fraction of bounding rectangle</param>
	///   <returns>pixd pixs, with some holes possibly filled and some c.c. possibly expanded to their bounding rects, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FillHolesToBoundingRect (int minsize,
										Single maxhfract,
										Single minfgfract)
	{
		Pix RetObj = _All.pixFillHolesToBoundingRect(this, minsize, maxhfract, minfgfract);
		return RetObj;
	}

	// seedfill.c (923, 1)
	// pixSeedfillGray(pixs, pixm, connectivity) as int
	// pixSeedfillGray(PIX *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place filling operation on the seed, pixs,
	/// where the clipping mask is always above or at the level
	/// of the seed as it is filled.<para/>
	///
	/// (2) For details of the operation, see the description in
	/// seedfillGrayLow() and the code there.<para/>
	///
	/// (3) As an example of use, see the description in pixHDome().
	/// There, the seed is an image where each pixel is a fixed
	/// amount smaller than the corresponding mask pixel.<para/>
	///
	/// (4) Reference paper :
	/// L. Vincent, Morphological grayscale reconstruction in image
	/// analysis: applications and efficient algorithms, IEEE Transactions
	/// on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfillGray/*"/>
	///  <param name="pixm">[in] - 8 bpp filling mask</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SeedfillGray (Pix pixm,
							 int connectivity)
	{
		int RetObj = _All.pixSeedfillGray(this, pixm, connectivity);
		return RetObj;
	}

	// seedfill.c (982, 1)
	// pixSeedfillGrayInv(pixs, pixm, connectivity) as int
	// pixSeedfillGrayInv(PIX *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place filling operation on the seed, pixs,
	/// where the clipping mask is always below or at the level
	/// of the seed as it is filled.  Think of filling up a basin
	/// to a particular level, given by the maximum seed value
	/// in the basin.  Outside the filled region, the mask
	/// is above the filling level.<para/>
	///
	/// (2) Contrast this with pixSeedfillGray(), where the clipping mask
	/// is always above or at the level of the fill.  An example
	/// of its use is the hdome fill, where the seed is an image
	/// where each pixel is a fixed amount smaller than the
	/// corresponding mask pixel.<para/>
	///
	/// (3) The basin fill, pixSeedfillGrayBasin(), is a special case
	/// where the seed pixel values are generated from the mask,
	/// and where the implementation uses pixSeedfillGray() by
	/// inverting both the seed and mask.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfillGrayInv/*"/>
	///  <param name="pixm">[in] - 8 bpp filling mask</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SeedfillGrayInv (Pix pixm,
								int connectivity)
	{
		int RetObj = _All.pixSeedfillGrayInv(this, pixm, connectivity);
		return RetObj;
	}

	// seedfill.c (1969, 1)
	// pixSeedfillGraySimple(pixs, pixm, connectivity) as int
	// pixSeedfillGraySimple(PIX *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place filling operation on the seed, pixs,
	/// where the clipping mask is always above or at the level
	/// of the seed as it is filled.<para/>
	///
	/// (2) For details of the operation, see the description in
	/// seedfillGrayLowSimple() and the code there.<para/>
	///
	/// (3) As an example of use, see the description in pixHDome().
	/// There, the seed is an image where each pixel is a fixed
	/// amount smaller than the corresponding mask pixel.<para/>
	///
	/// (4) Reference paper :
	/// L. Vincent, Morphological grayscale reconstruction in image
	/// analysis: applications and efficient algorithms, IEEE Transactions
	/// on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfillGraySimple/*"/>
	///  <param name="pixm">[in] - 8 bpp filling mask</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SeedfillGraySimple (Pix pixm,
								   int connectivity)
	{
		int RetObj = _All.pixSeedfillGraySimple(this, pixm, connectivity);
		return RetObj;
	}

	// seedfill.c (2040, 1)
	// pixSeedfillGrayInvSimple(pixs, pixm, connectivity) as int
	// pixSeedfillGrayInvSimple(PIX *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place filling operation on the seed, pixs,
	/// where the clipping mask is always below or at the level
	/// of the seed as it is filled.  Think of filling up a basin
	/// to a particular level, given by the maximum seed value
	/// in the basin.  Outside the filled region, the mask
	/// is above the filling level.<para/>
	///
	/// (2) Contrast this with pixSeedfillGraySimple(), where the clipping mask
	/// is always above or at the level of the fill.  An example
	/// of its use is the hdome fill, where the seed is an image
	/// where each pixel is a fixed amount smaller than the
	/// corresponding mask pixel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfillGrayInvSimple/*"/>
	///  <param name="pixm">[in] - 8 bpp filling mask</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SeedfillGrayInvSimple (Pix pixm,
									  int connectivity)
	{
		int RetObj = _All.pixSeedfillGrayInvSimple(this, pixm, connectivity);
		return RetObj;
	}

	// seedfill.c (2442, 1)
	// pixSeedfillGrayBasin(pixb, pixm, delta, connectivity) as Pix
	// pixSeedfillGrayBasin(PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This fills from a seed within basins defined by a filling mask.
	/// The seed value(s) are greater than the corresponding
	/// filling mask value, and the result has the bottoms of
	/// the basins raised by the initial seed value.<para/>
	///
	/// (2) The seed has value 255 except where pixb has fg (1), which
	/// are the seed 'locations'.  At the seed locations, the seed
	/// value is the corresponding value of the mask pixel in pixm
	/// plus %delta.  If %delta == 0, we return a copy of pixm.<para/>
	///
	/// (3) The actual filling is done using the standard grayscale filling
	/// operation on the inverse of the mask and using the inverse
	/// of the seed image.  After filling, we return the inverse of
	/// the filled seed.<para/>
	///
	/// (4) As an example of use: pixm can describe a grayscale image
	/// of text, where the (dark) text pixels are basins of
	/// low values pixb can identify the local minima in pixm (say, at
	/// the bottom of the basins) and delta is the amount that we wish
	/// to raise (lighten) the basins.  We construct the seed
	/// (a.k.a marker) image from pixb, pixm and %delta.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedfillGrayBasin/*"/>
	///  <param name="pixb">[in] - binary mask giving seed locations</param>
	///  <param name="pixm">[in] - 8 bpp basin-type filling mask</param>
	///  <param name="delta">[in] - amount of seed value above mask</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>pixd filled seed if OK, NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SeedfillGrayBasin (Pix pixb,
								  Pix pixm,
								  int delta,
								  int connectivity)
	{
		Pix RetObj = _All.pixSeedfillGrayBasin(pixb, pixm, delta, connectivity);
		return RetObj;
	}

	// seedfill.c (2533, 1)
	// pixDistanceFunction(pixs, connectivity, outdepth, boundcond) as Pix
	// pixDistanceFunction(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This computes the distance of each pixel from the nearest
	/// background pixel.  All bg pixels therefore have a distance of 0,
	/// and the fg pixel distances increase linearly from 1 at the
	/// boundary.  It can also be used to compute the distance of
	/// each pixel from the nearest fg pixel, by inverting the input
	/// image before calling this function.  Then all fg pixels have
	/// a distance 0 and the bg pixel distances increase linearly
	/// from 1 at the boundary.<para/>
	///
	/// (2) The algorithm, described in Leptonica on the page on seed
	/// filling and connected components, is due to Luc Vincent.
	/// In brief, we generate an 8 or 16 bpp image, initialized
	/// with the fg pixels of the input pix set to 1 and the
	/// 1-boundary pixels (i.e., the boundary pixels of width 1 on
	/// the four sides set as either:
	/// L_BOUNDARY_BG: 0
	/// L_BOUNDARY_FG:  max
	/// where max = 0xff for 8 bpp and 0xffff for 16 bpp.
	/// Then do raster/anti-raster sweeps over all pixels interior
	/// to the 1-boundary, where the value of each new pixel is
	/// taken to be 1 more than the minimum of the previously-seen
	/// connected pixels (using either 4 or 8 connectivity).
	/// Finally, set the 1-boundary pixels using the mirrored method
	/// this removes the max values there.<para/>
	///
	/// (3) Using L_BOUNDARY_BG clamps the distance to 0 at the
	/// boundary.  Using L_BOUNDARY_FG allows the distance
	/// at the image boundary to "float".<para/>
	///
	/// (4) For 4-connected, one could initialize only the left and top
	/// 1-boundary pixels, and go all the way to the right
	/// and bottom then coming back reset left and top.  But we
	/// instead use a method that works for both 4- and 8-connected.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDistanceFunction/*"/>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="outdepth">[in] - 8 or 16 bits for pixd</param>
	///  <param name="boundcond">[in] - L_BOUNDARY_BG, L_BOUNDARY_FG</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DistanceFunction (int connectivity,
								 int outdepth,
								 int boundcond)
	{
		Pix RetObj = _All.pixDistanceFunction(this, connectivity, outdepth, boundcond);
		return RetObj;
	}

	// seedfill.c (2791, 1)
	// pixSeedspread(pixs, connectivity) as Pix
	// pixSeedspread(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) The raster/anti-raster method for implementing this filling
	/// operation was suggested by Ray Smith.<para/>
	///
	/// (2) This takes an arbitrary set of nonzero pixels in pixs, which
	/// can be sparse, and spreads (extrapolates) the values to
	/// fill all the pixels in pixd with the nonzero value it is
	/// closest to in pixs.  This is similar (though not completely
	/// equivalent) to doing a Voronoi tiling of the image, with a
	/// tile surrounding each pixel that has a nonzero value.
	/// All pixels within a tile are then closer to its "central"
	/// pixel than to any others.  Then assign the value of the
	/// "central" pixel to each pixel in the tile.<para/>
	///
	/// (3) This is implemented by computing a distance function in parallel
	/// with the fill.  The distance function uses free boundary
	/// conditions (assumed maxval outside), and it controls the
	/// propagation of the pixels in pixd away from the nonzero
	/// (seed) values.  This is done in 2 traversals (raster/antiraster).
	/// In the raster direction, whenever the distance function
	/// is nonzero, the spread pixel takes on the value of its
	/// predecessor that has the minimum distance value.  In the
	/// antiraster direction, whenever the distance function is nonzero
	/// and its value is replaced by a smaller value, the spread
	/// pixel takes the value of the predecessor with the minimum
	/// distance value.<para/>
	///
	/// (4) At boundaries where a pixel is equidistant from two
	/// nearest nonzero (seed) pixels, the decision of which value
	/// to use is arbitrary (greedy in search for minimum distance).
	/// This can give rise to strange-looking results, particularly
	/// for 4-connectivity where the L1 distance is computed from
	/// steps in N,S,E and W directions (no diagonals).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSeedspread/*"/>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Seedspread (int connectivity)
	{
		Pix RetObj = _All.pixSeedspread(this, connectivity);
		return RetObj;
	}

	// seedfill.c (3018, 1)
	// pixLocalExtrema(pixs, maxmin, minmax, ppixmin, ppixmax) as int
	// pixLocalExtrema(PIX *, l_int32, l_int32, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) This gives the actual local minima and maxima.
	/// A local minimum is a pixel whose surrounding pixels all
	/// have values at least as large, and likewise for a local
	/// maximum.  For the local minima, %maxmin is the upper
	/// bound for the value of pixs.  Likewise, for the local maxima,
	/// %minmax is the lower bound for the value of pixs.<para/>
	///
	/// (2) The minima are found by starting with the erosion-and-equality
	/// approach of pixSelectedLocalExtrema().  This is followed
	/// by a qualification step, where each c.c. in the resulting
	/// minimum mask is extracted, the pixels bordering it are
	/// located, and they are queried.  If all of those pixels
	/// are larger than the value of that minimum, it is a true
	/// minimum and its c.c. is saved otherwise the c.c. is
	/// rejected.  Note that if a bordering pixel has the
	/// same value as the minimum, it must then have a
	/// neighbor that is smaller, so the component is not a
	/// true minimum.<para/>
	///
	/// (3) The maxima are found by inverting the image and looking
	/// for the minima there.<para/>
	///
	/// (4) The generated masks can be used as markers for
	/// further operations.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixLocalExtrema/*"/>
	///  <param name="maxmin">[in] - max allowed for the min in a 3x3 neighborhood use 0 for default which is to have no upper bound</param>
	///  <param name="minmax">[in] - min allowed for the max in a 3x3 neighborhood use 0 for default which is to have no lower bound</param>
	///  <param name="ppixmin">[out][optional] - mask of local minima</param>
	///  <param name="ppixmax">[out][optional] - mask of local maxima</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int LocalExtrema (int maxmin,
							 int minmax,
							 out Pix ppixmin,
							 out Pix ppixmax)
	{
		int RetObj = _All.pixLocalExtrema(this, maxmin, minmax, out ppixmin, out ppixmax);
		return RetObj;
	}

	// seedfill.c (3190, 1)
	// pixSelectedLocalExtrema(pixs, mindist, ppixmin, ppixmax) as int
	// pixSelectedLocalExtrema(PIX *, l_int32, PIX **, PIX **) as l_ok
	///  <summary>
	/// (1) This selects those local 3x3 minima that are at least a
	/// specified distance from the nearest local 3x3 maxima, and v.v.
	/// for the selected set of local 3x3 maxima.
	/// The local 3x3 minima is the set of pixels whose value equals
	/// the value after a 3x3 brick erosion, and the local 3x3 maxima
	/// is the set of pixels whose value equals the value after
	/// a 3x3 brick dilation.<para/>
	///
	/// (2) mindist is the minimum distance allowed between
	/// local 3x3 minima and local 3x3 maxima, in an 8-connected sense.
	/// mindist == 1 keeps all pixels found in step 1.
	/// mindist == 0 removes all pixels from each mask that are
	/// both a local 3x3 minimum and a local 3x3 maximum.
	/// mindist == 1 removes any local 3x3 minimum pixel that touches a
	/// local 3x3 maximum pixel, and likewise for the local maxima.
	/// To make the decision, visualize each local 3x3 minimum pixel
	/// as being surrounded by a square of size (2  mindist + 1)
	/// on each side, such that no local 3x3 maximum pixel is within
	/// that square and v.v.<para/>
	///
	/// (3) The generated masks can be used as markers for further operations.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSelectedLocalExtrema/*"/>
	///  <param name="mindist">[in] - -1 for keeping all pixels greater or equal 0 specifies distance</param>
	///  <param name="ppixmin">[out] - mask of local minima</param>
	///  <param name="ppixmax">[out] - mask of local maxima</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SelectedLocalExtrema (int mindist,
									 out Pix ppixmin,
									 out Pix ppixmax)
	{
		int RetObj = _All.pixSelectedLocalExtrema(this, mindist, out ppixmin, out ppixmax);
		return RetObj;
	}

	// seedfill.c (3250, 1)
	// pixFindEqualValues(pixs1, pixs2) as Pix
	// pixFindEqualValues(PIX *, PIX *) as PIX *
	///  <summary>
	/// (1) The two images are aligned at the UL corner, and the returned
	/// image has ON pixels where the pixels in pixs1 and pixs2
	/// have equal values.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindEqualValues/*"/>
	///  <param name="pixs1">[in] - 8 bpp</param>
	///  <param name="pixs2">[in] - 8 bpp</param>
	///   <returns>pixd 1 bpp mask, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FindEqualValues (Pix pixs1,
								Pix pixs2)
	{
		Pix RetObj = _All.pixFindEqualValues(pixs1, pixs2);
		return RetObj;
	}

	// seedfill.c (3317, 1)
	// pixSelectMinInConnComp(pixs, pixm, ppta, pnav) as int
	// pixSelectMinInConnComp(PIX *, PIX *, PTA **, NUMA **) as l_ok
	///  <summary>
	/// (1) For each 8 connected component in pixm, this finds
	/// a pixel in pixs that has the lowest value, and saves
	/// it in a Pta.  If several pixels in pixs have the same
	/// minimum value, it picks the first one found.<para/>
	///
	/// (2) For a mask pixm of true local minima, all pixels in each
	/// connected component have the same value in pixs, so it is
	/// fastest to select one of them using a special seedfill
	/// operation.  Not yet implemented.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSelectMinInConnComp/*"/>
	///  <param name="pixm">[in] - 1 bpp</param>
	///  <param name="ppta">[out] - pta of min pixel locations</param>
	///  <param name="pnav">[out][optional] - numa of minima values</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int SelectMinInConnComp (Pix pixm,
									out Pta ppta,
									out Numa pnav)
	{
		int RetObj = _All.pixSelectMinInConnComp(this, pixm, out ppta, out pnav);
		return RetObj;
	}

	// seedfill.c (3430, 1)
	// pixRemoveSeededComponents(pixd, pixs, pixm, connectivity, bordersize) as Pix
	// pixRemoveSeededComponents(PIX *, PIX *, PIX *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This removes each component in pixm for which there is
	/// at least one seed in pixs.  If pixd == NULL, this returns
	/// the result in a new pixd.  Otherwise, it is an in-place
	/// operation on pixm.  In no situation is pixs altered,
	/// because we do the filling with a copy of pixs.<para/>
	///
	/// (2) If bordersize  is greater  0, it also clears all pixels within a
	/// distance %bordersize of the edge of pixd.  This is here
	/// because pixLocalExtrema() typically finds local minima
	/// at the border.  Use %bordersize greater or equal 2 to remove these.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRemoveSeededComponents/*"/>
	///  <param name="pixd">[in][optional] - this can be null or equal to pixm 1 bpp</param>
	///  <param name="pixm">[in] - 1 bpp filling mask</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="bordersize">[in] - amount of border clearing</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RemoveSeededComponents (Pix pixm,
									   int connectivity,
									   int bordersize,
									   Pix pixd)
	{
		Pix RetObj = _All.pixRemoveSeededComponents(pixd, this, pixm, connectivity, bordersize);
		return RetObj;
	}

	// selgen.c (146, 1)
	// pixGenerateSelWithRuns(pixs, nhlines, nvlines, distance, minlength, toppix, botpix, leftpix, rightpix, ppixe) as Sel
	// pixGenerateSelWithRuns(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, PIX **) as SEL *
	///  <summary>
	/// (1) The horizontal and vertical lines along which elements are
	/// selected are roughly equally spaced.  The actual locations of
	/// the hits and misses are the centers of respective run-lengths.<para/>
	///
	/// (2) No elements are selected that are less than 'distance' pixels away
	/// from a boundary pixel of the same color.  This makes the
	/// match much more robust to edge noise.  Valid inputs of
	/// 'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or
	/// greater than 4, we reset it to the default value.<para/>
	///
	/// (3) The 4 numbers for adding rectangles of pixels outside the fg
	/// can be use if the pattern is expected to be surrounded by bg
	/// (white) pixels.  On the other hand, if the pattern may be near
	/// other fg (black) components on some sides, use 0 for those sides.<para/>
	///
	/// (4) The pixels added to a side allow you to have miss elements there.
	/// There is a constraint between distance, minlength, and
	/// the added pixels for this to work.  We illustrate using the
	/// default values.  If you add 5 pixels to the top, and use a
	/// distance of 1, then you end up with a vertical run of at least
	/// 4 bg pixels along the top edge of the image.  If you use a
	/// minimum runlength of 3, each vertical line will always find
	/// a miss near the center of its run.  However, if you use a
	/// minimum runlength of 5, you will not get a miss on every vertical
	/// line.  As another example, if you have 7 added pixels and a
	/// distance of 2, you can use a runlength up to 5 to guarantee
	/// that the miss element is recorded.  We give a warning if the
	/// constraint does not guarantee a miss element outside the
	/// image proper.<para/>
	///
	/// (5) The input pix, as extended by the extra pixels on selected sides,
	/// can optionally be returned.  For debugging, call
	/// pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
	/// on the generating bitmap.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenerateSelWithRuns/*"/>
	///  <param name="nhlines">[in] - number of hor lines along which elements are found</param>
	///  <param name="nvlines">[in] - number of vert lines along which elements are found</param>
	///  <param name="distance">[in] - min distance from boundary pixel use 0 for default</param>
	///  <param name="minlength">[in] - min runlength to set hit or miss use 0 for default</param>
	///  <param name="toppix">[in] - number of extra pixels of bg added above</param>
	///  <param name="botpix">[in] - number of extra pixels of bg added below</param>
	///  <param name="leftpix">[in] - number of extra pixels of bg added to left</param>
	///  <param name="rightpix">[in] - number of extra pixels of bg added to right</param>
	///  <param name="ppixe">[out][optional] - input pix expanded by extra pixels</param>
	///   <returns>sel hit-miss for input pattern, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel GenerateSelWithRuns (int nhlines,
									int nvlines,
									int distance,
									int minlength,
									int toppix,
									int botpix,
									int leftpix,
									int rightpix,
									out Pix ppixe)
	{
		Sel RetObj = _All.pixGenerateSelWithRuns(this, nhlines, nvlines, distance, minlength, toppix, botpix, leftpix, rightpix, out ppixe);
		return RetObj;
	}

	// selgen.c (336, 1)
	// pixGenerateSelRandom(pixs, hitfract, missfract, distance, toppix, botpix, leftpix, rightpix, ppixe) as Sel
	// pixGenerateSelRandom(PIX *, l_float32, l_float32, l_int32, l_int32, l_int32, l_int32, l_int32, PIX **) as SEL *
	///  <summary>
	/// (1) Either of hitfract and missfract can be zero.  If both are zero,
	/// the sel would be empty, and NULL is returned.<para/>
	///
	/// (2) No elements are selected that are less than 'distance' pixels away
	/// from a boundary pixel of the same color.  This makes the
	/// match much more robust to edge noise.  Valid inputs of
	/// 'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or
	/// greater than 4, we reset it to the default value.<para/>
	///
	/// (3) The 4 numbers for adding rectangles of pixels outside the fg
	/// can be use if the pattern is expected to be surrounded by bg
	/// (white) pixels.  On the other hand, if the pattern may be near
	/// other fg (black) components on some sides, use 0 for those sides.<para/>
	///
	/// (4) The input pix, as extended by the extra pixels on selected sides,
	/// can optionally be returned.  For debugging, call
	/// pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
	/// on the generating bitmap.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenerateSelRandom/*"/>
	///  <param name="hitfract">[in] - fraction of allowable fg pixels that are hits</param>
	///  <param name="missfract">[in] - fraction of allowable bg pixels that are misses</param>
	///  <param name="distance">[in] - min distance from boundary pixel use 0 for default</param>
	///  <param name="toppix">[in] - number of extra pixels of bg added above</param>
	///  <param name="botpix">[in] - number of extra pixels of bg added below</param>
	///  <param name="leftpix">[in] - number of extra pixels of bg added to left</param>
	///  <param name="rightpix">[in] - number of extra pixels of bg added to right</param>
	///  <param name="ppixe">[out][optional] - input pix expanded by extra pixels</param>
	///   <returns>sel hit-miss for input pattern, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel GenerateSelRandom (Single hitfract,
								  Single missfract,
								  int distance,
								  int toppix,
								  int botpix,
								  int leftpix,
								  int rightpix,
								  out Pix ppixe)
	{
		Sel RetObj = _All.pixGenerateSelRandom(this, hitfract, missfract, distance, toppix, botpix, leftpix, rightpix, out ppixe);
		return RetObj;
	}

	// selgen.c (489, 1)
	// pixGenerateSelBoundary(pixs, hitdist, missdist, hitskip, missskip, topflag, botflag, leftflag, rightflag, ppixe) as Sel
	// pixGenerateSelBoundary(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, PIX **) as SEL *
	///  <summary>
	/// (1) All fg elements selected are exactly hitdist pixels away from
	/// the nearest fg boundary pixel, and ditto for bg elements.
	/// Valid inputs of hitdist and missdist are 0, 1, 2, 3 and 4.
	/// For example, a hitdist of 0 puts the hits at the fg boundary.
	/// Usually, the distances should be  is greater  0 avoid the effect of
	/// noise at the boundary.<para/>
	///
	/// (2) Set hitskip  is smaller 0 if no hits are to be used.  Ditto for missskip.
	/// If both hitskip and missskip are  is smaller 0, the sel would be empty,
	/// and NULL is returned.<para/>
	///
	/// (3) The 4 flags determine whether the sel is increased on that side
	/// to allow bg misses to be placed all along that boundary.
	/// The increase in sel size on that side is the minimum necessary
	/// to allow the misses to be placed at mindist.  For text characters,
	/// the topflag and botflag are typically set to 1, and the leftflag
	/// and rightflag to 0.<para/>
	///
	/// (4) The input pix, as extended by the extra pixels on selected sides,
	/// can optionally be returned.  For debugging, call
	/// pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
	/// on the generating bitmap.<para/>
	///
	/// (5) This is probably the best of the three sel generators, in the
	/// sense that you have the most flexibility with the smallest number
	/// of hits and misses.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGenerateSelBoundary/*"/>
	///  <param name="hitdist">[in] - min distance from fg boundary pixel</param>
	///  <param name="missdist">[in] - min distance from bg boundary pixel</param>
	///  <param name="hitskip">[in] - number of boundary pixels skipped between hits</param>
	///  <param name="missskip">[in] - number of boundary pixels skipped between misses</param>
	///  <param name="topflag">[in] - flag for extra pixels of bg added above</param>
	///  <param name="botflag">[in] - flag for extra pixels of bg added below</param>
	///  <param name="leftflag">[in] - flag for extra pixels of bg added to left</param>
	///  <param name="rightflag">[in] - flag for extra pixels of bg added to right</param>
	///  <param name="ppixe">[out][optional] - input pix expanded by extra pixels</param>
	///   <returns>sel hit-miss for input pattern, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Sel GenerateSelBoundary (int hitdist,
									int missdist,
									int hitskip,
									int missskip,
									int topflag,
									int botflag,
									int leftflag,
									int rightflag,
									out Pix ppixe)
	{
		Sel RetObj = _All.pixGenerateSelBoundary(this, hitdist, missdist, hitskip, missskip, topflag, botflag, leftflag, rightflag, out ppixe);
		return RetObj;
	}

	// selgen.c (636, 1)
	// pixGetRunCentersOnLine(pixs, x, y, minlength) as Numa
	// pixGetRunCentersOnLine(PIX *, l_int32, l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) Action: this function computes the fg (black) and bg (white)
	/// pixel runlengths along the specified horizontal or vertical line,
	/// and returns a Numa of the "center" pixels of each fg run
	/// whose length equals or exceeds the minimum length.<para/>
	///
	/// (2) This only works on horizontal and vertical lines.<para/>
	///
	/// (3) For horizontal runs, set x = -1 and y to the value
	/// for all points along the raster line.  For vertical runs,
	/// set y = -1 and x to the value for all points along the
	/// pixel column.<para/>
	///
	/// (4) For horizontal runs, the points in the Numa are the x
	/// values in the center of fg runs that are of length at
	/// least 'minlength'.  For vertical runs, the points in the
	/// Numa are the y values in the center of fg runs, again
	/// of length 'minlength' or greater.<para/>
	///
	/// (5) If there are no fg runs along the line that satisfy the
	/// minlength constraint, the returned Numa is empty.  This
	/// is not an error.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRunCentersOnLine/*"/>
	///  <param name="x">[in] - set one of these to -1 see notes</param>
	///  <param name="y">[in] - set one of these to -1 see notes</param>
	///  <param name="minlength">[in] - minimum length of acceptable run</param>
	///   <returns>numa of fg runs, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetRunCentersOnLine (int x,
									 int y,
									 int minlength)
	{
		Numa RetObj = _All.pixGetRunCentersOnLine(this, x, y, minlength);
		return RetObj;
	}

	// selgen.c (708, 1)
	// pixGetRunsOnLine(pixs, x1, y1, x2, y2) as Numa
	// pixGetRunsOnLine(PIX *, l_int32, l_int32, l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) Action: this function uses the bresenham algorithm to compute
	/// the pixels along the specified line.  It returns a Numa of the
	/// runlengths of the fg (black) and bg (white) runs, always
	/// starting with a white run.<para/>
	///
	/// (2) If the first pixel on the line is black, the length of the
	/// first returned run (which is white) is 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetRunsOnLine/*"/>
	///  <param name="x1">[in] - </param>
	///  <param name="y1">[in] - </param>
	///  <param name="x2">[in] - </param>
	///  <param name="y2">[in] - </param>
	///   <returns>numa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa GetRunsOnLine (int x1,
							   int y1,
							   int x2,
							   int y2)
	{
		Numa RetObj = _All.pixGetRunsOnLine(this, x1, y1, x2, y2);
		return RetObj;
	}

	// selgen.c (803, 1)
	// pixSubsampleBoundaryPixels(pixs, skip) as Pta
	// pixSubsampleBoundaryPixels(PIX *, l_int32) as PTA *
	///  <summary>
	/// (1) If skip = 0, we take all the fg pixels.<para/>
	///
	/// (2) We try to traverse the boundaries in a regular way.
	/// Some pixels may be missed, and these are then subsampled
	/// randomly with a fraction determined by 'skip'.<para/>
	///
	/// (3) The most natural approach is to use a depth first (stack-based)
	/// method to find the fg pixels.  However, the pixel runs are
	/// 4-connected and there are relatively few branches.  So
	/// instead of doing a proper depth-first search, we get nearly
	/// the same result using two nested while loops: the outer
	/// one continues a raster-based search for the next fg pixel,
	/// and the inner one does a reasonable job running along
	/// each 4-connected coutour.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSubsampleBoundaryPixels/*"/>
	///  <param name="skip">[in] - number to skip between samples as you traverse boundary</param>
	///   <returns>pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta SubsampleBoundaryPixels (int skip)
	{
		Pta RetObj = _All.pixSubsampleBoundaryPixels(this, skip);
		return RetObj;
	}

	// selgen.c (928, 1)
	// pixDisplayHitMissSel(pixs, sel, scalefactor, hitcolor, misscolor) as Pix
	// pixDisplayHitMissSel(PIX *, SEL *, l_int32, l_uint32, l_uint32) as PIX *
	///  <summary>
	/// (1) We don't allow scalefactor to be larger than MAX_SEL_SCALEFACTOR<para/>
	///
	/// (2) The colors are conveniently given as 4 bytes in hex format,
	/// such as 0xff008800.  The least significant byte is ignored.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDisplayHitMissSel/*"/>
	///  <param name="sel">[in] - hit-miss in general</param>
	///  <param name="scalefactor">[in] - an integer greater or equal 1 use 0 for default</param>
	///  <param name="hitcolor">[in] - RGB0 color for center of hit pixels</param>
	///  <param name="misscolor">[in] - RGB0 color for center of miss pixels</param>
	///   <returns>pixd RGB showing both pixs and sel, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayHitMissSel (Sel sel,
								  int scalefactor,
								  uint hitcolor,
								  uint misscolor)
	{
		Pix RetObj = _All.pixDisplayHitMissSel(this, sel, scalefactor, hitcolor, misscolor);
		return RetObj;
	}

	// shear.c (113, 1)
	// pixHShear(pixd, pixs, yloc, radang, incolor) as Pix
	// pixHShear(PIX *, PIX *, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) There are 3 cases:
	/// (a) pixd == null (make a new pixd)
	/// (b) pixd == pixs (in-place)
	/// (c) pixd != pixs<para/>
	///
	/// (2) For these three cases, use these patterns, respectively:
	/// pixd = pixHShear(NULL, pixs, ...)
	/// pixHShear(pixs, pixs, ...)
	/// pixHShear(pixd, pixs, ...)<para/>
	///
	/// (3) This shear leaves the horizontal line of pixels at y = yloc
	/// invariant.  For a positive shear angle, pixels above this
	/// line are shoved to the right, and pixels below this line
	/// move to the left.<para/>
	///
	/// (4) With positive shear angle, this can be used, along with
	/// pixVShear(), to perform a cw rotation, either with 2 shears
	/// (for small angles) or in the general case with 3 shears.<para/>
	///
	/// (5) Changing the value of yloc is equivalent to translating
	/// the result horizontally.<para/>
	///
	/// (6) This brings in 'incolor' pixels from outside the image.<para/>
	///
	/// (7) For in-place operation, pixs cannot be colormapped,
	/// because the in-place operation only blits in 0 or 1 bits,
	/// not an arbitrary colormap index.<para/>
	///
	/// (8) The angle is brought into the range [-pi, -pi].  It is
	/// not permitted to be within MIN_DIFF_FROM_HALF_PI radians
	/// from either -pi/2 or pi/2.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixHShear/*"/>
	///  <param name="pixd">[in][optional] - , this can be null, equal to pixs, or different from pixs</param>
	///  <param name="yloc">[in] - location of horizontal line, measured from origin</param>
	///  <param name="radang">[in] - angle in radians</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, always</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix HShear (int yloc,
					   Single radang,
					   int incolor,
					   Pix pixd)
	{
		Pix RetObj = _All.pixHShear(pixd, this, yloc, radang, incolor);
		return RetObj;
	}

	// shear.c (230, 1)
	// pixVShear(pixd, pixs, xloc, radang, incolor) as Pix
	// pixVShear(PIX *, PIX *, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) There are 3 cases:
	/// (a) pixd == null (make a new pixd)
	/// (b) pixd == pixs (in-place)
	/// (c) pixd != pixs<para/>
	///
	/// (2) For these three cases, use these patterns, respectively:
	/// pixd = pixVShear(NULL, pixs, ...)
	/// pixVShear(pixs, pixs, ...)
	/// pixVShear(pixd, pixs, ...)<para/>
	///
	/// (3) This shear leaves the vertical line of pixels at x = xloc
	/// invariant.  For a positive shear angle, pixels to the right
	/// of this line are shoved downward, and pixels to the left
	/// of the line move upward.<para/>
	///
	/// (4) With positive shear angle, this can be used, along with
	/// pixHShear(), to perform a cw rotation, either with 2 shears
	/// (for small angles) or in the general case with 3 shears.<para/>
	///
	/// (5) Changing the value of xloc is equivalent to translating
	/// the result vertically.<para/>
	///
	/// (6) This brings in 'incolor' pixels from outside the image.<para/>
	///
	/// (7) For in-place operation, pixs cannot be colormapped,
	/// because the in-place operation only blits in 0 or 1 bits,
	/// not an arbitrary colormap index.<para/>
	///
	/// (8) The angle is brought into the range [-pi, -pi].  It is
	/// not permitted to be within MIN_DIFF_FROM_HALF_PI radians
	/// from either -pi/2 or pi/2.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixVShear/*"/>
	///  <param name="pixd">[in][optional] - , this can be null, equal to pixs, or different from pixs</param>
	///  <param name="xloc">[in] - location of vertical line, measured from origin</param>
	///  <param name="radang">[in] - angle in radians not too close to +-(pi / 2)</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix VShear (int xloc,
					   Single radang,
					   int incolor,
					   Pix pixd)
	{
		Pix RetObj = _All.pixVShear(pixd, this, xloc, radang, incolor);
		return RetObj;
	}

	// shear.c (328, 1)
	// pixHShearCorner(pixd, pixs, radang, incolor) as Pix
	// pixHShearCorner(PIX *, PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) See pixHShear() for usage.<para/>
	///
	/// (2) This does a horizontal shear about the UL corner, with (+) shear
	/// pushing increasingly leftward (-x) with increasing y.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixHShearCorner/*"/>
	///  <param name="pixd">[in][optional] - , if not null, must be equal to pixs</param>
	///  <param name="radang">[in] - angle in radians</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix HShearCorner (Single radang,
							 int incolor,
							 Pix pixd)
	{
		Pix RetObj = _All.pixHShearCorner(pixd, this, radang, incolor);
		return RetObj;
	}

	// shear.c (359, 1)
	// pixVShearCorner(pixd, pixs, radang, incolor) as Pix
	// pixVShearCorner(PIX *, PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) See pixVShear() for usage.<para/>
	///
	/// (2) This does a vertical shear about the UL corner, with (+) shear
	/// pushing increasingly downward (+y) with increasing x.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixVShearCorner/*"/>
	///  <param name="pixd">[in][optional] - , if not null, must be equal to pixs</param>
	///  <param name="radang">[in] - angle in radians</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix VShearCorner (Single radang,
							 int incolor,
							 Pix pixd)
	{
		Pix RetObj = _All.pixVShearCorner(pixd, this, radang, incolor);
		return RetObj;
	}

	// shear.c (390, 1)
	// pixHShearCenter(pixd, pixs, radang, incolor) as Pix
	// pixHShearCenter(PIX *, PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) See pixHShear() for usage.<para/>
	///
	/// (2) This does a horizontal shear about the center, with (+) shear
	/// pushing increasingly leftward (-x) with increasing y.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixHShearCenter/*"/>
	///  <param name="pixd">[in][optional] - , if not null, must be equal to pixs</param>
	///  <param name="radang">[in] - angle in radians</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix HShearCenter (Single radang,
							 int incolor,
							 Pix pixd)
	{
		Pix RetObj = _All.pixHShearCenter(pixd, this, radang, incolor);
		return RetObj;
	}

	// shear.c (421, 1)
	// pixVShearCenter(pixd, pixs, radang, incolor) as Pix
	// pixVShearCenter(PIX *, PIX *, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) See pixVShear() for usage.<para/>
	///
	/// (2) This does a vertical shear about the center, with (+) shear
	/// pushing increasingly downward (+y) with increasing x.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixVShearCenter/*"/>
	///  <param name="pixd">[in][optional] - , if not null, must be equal to pixs</param>
	///  <param name="radang">[in] - angle in radians</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix VShearCenter (Single radang,
							 int incolor,
							 Pix pixd)
	{
		Pix RetObj = _All.pixVShearCenter(pixd, this, radang, incolor);
		return RetObj;
	}

	// shear.c (459, 1)
	// pixHShearIP(pixs, yloc, radang, incolor) as int
	// pixHShearIP(PIX *, l_int32, l_float32, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place version of pixHShear() see comments there.<para/>
	///
	/// (2) This brings in 'incolor' pixels from outside the image.<para/>
	///
	/// (3) pixs cannot be colormapped, because the in-place operation
	/// only blits in 0 or 1 bits, not an arbitrary colormap index.<para/>
	///
	/// (4) Does a horizontal full-band shear about the line with (+) shear
	/// pushing increasingly leftward (-x) with increasing y.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixHShearIP/*"/>
	///  <param name="yloc">[in] - location of horizontal line, measured from origin</param>
	///  <param name="radang">[in] - angle in radians</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int HShearIP (int yloc,
						 Single radang,
						 int incolor)
	{
		int RetObj = _All.pixHShearIP(this, yloc, radang, incolor);
		return RetObj;
	}

	// shear.c (534, 1)
	// pixVShearIP(pixs, xloc, radang, incolor) as int
	// pixVShearIP(PIX *, l_int32, l_float32, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place version of pixVShear() see comments there.<para/>
	///
	/// (2) This brings in 'incolor' pixels from outside the image.<para/>
	///
	/// (3) pixs cannot be colormapped, because the in-place operation
	/// only blits in 0 or 1 bits, not an arbitrary colormap index.<para/>
	///
	/// (4) Does a vertical full-band shear about the line with (+) shear
	/// pushing increasingly downward (+y) with increasing x.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixVShearIP/*"/>
	///  <param name="xloc">[in] - location of vertical line, measured from origin</param>
	///  <param name="radang">[in] - angle in radians</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int VShearIP (int xloc,
						 Single radang,
						 int incolor)
	{
		int RetObj = _All.pixVShearIP(this, xloc, radang, incolor);
		return RetObj;
	}

	// shear.c (617, 1)
	// pixHShearLI(pixs, yloc, radang, incolor) as Pix
	// pixHShearLI(PIX *, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) This does horizontal shear with linear interpolation for
	/// accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.
	/// It is relatively slow compared to the sampled version
	/// implemented by rasterop, but the result is much smoother.<para/>
	///
	/// (2) This shear leaves the horizontal line of pixels at y = yloc
	/// invariant.  For a positive shear angle, pixels above this
	/// line are shoved to the right, and pixels below this line
	/// move to the left.<para/>
	///
	/// (3) Any colormap is removed.<para/>
	///
	/// (4) The angle is brought into the range [-pi/2 + del, pi/2 - del],
	/// where del == MIN_DIFF_FROM_HALF_PI.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixHShearLI/*"/>
	///  <param name="yloc">[in] - location of horizontal line, measured from origin</param>
	///  <param name="radang">[in] - angle in radians, in range (-pi/2 ... pi/2)</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd sheared, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix HShearLI (int yloc,
						 Single radang,
						 int incolor)
	{
		Pix RetObj = _All.pixHShearLI(this, yloc, radang, incolor);
		return RetObj;
	}

	// shear.c (729, 1)
	// pixVShearLI(pixs, xloc, radang, incolor) as Pix
	// pixVShearLI(PIX *, l_int32, l_float32, l_int32) as PIX *
	///  <summary>
	/// (1) This does vertical shear with linear interpolation for
	/// accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.
	/// It is relatively slow compared to the sampled version
	/// implemented by rasterop, but the result is much smoother.<para/>
	///
	/// (2) This shear leaves the vertical line of pixels at x = xloc
	/// invariant.  For a positive shear angle, pixels to the right
	/// of this line are shoved downward, and pixels to the left
	/// of the line move upward.<para/>
	///
	/// (3) Any colormap is removed.<para/>
	///
	/// (4) The angle is brought into the range [-pi/2 + del, pi/2 - del],
	/// where del == MIN_DIFF_FROM_HALF_PI.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixVShearLI/*"/>
	///  <param name="xloc">[in] - location of vertical line, measured from origin</param>
	///  <param name="radang">[in] - angle in radians, in range (-pi/2 ... pi/2)</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixd sheared, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix VShearLI (int xloc,
						 Single radang,
						 int incolor)
	{
		Pix RetObj = _All.pixVShearLI(this, xloc, radang, incolor);
		return RetObj;
	}

	// skew.c (162, 1)
	// pixDeskewBoth(pixs, redsearch) as Pix
	// pixDeskewBoth(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This binarizes if necessary and does both horizontal
	/// and vertical deskewing, using the default parameters in
	/// the underlying pixDeskew().  See usage there.<para/>
	///
	/// (2) This may return a clone.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDeskewBoth/*"/>
	///  <param name="redsearch">[in] - for binary search: reduction factor = 1, 2 or 4 use 0 for default</param>
	///   <returns>pixd deskewed pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DeskewBoth (int redsearch)
	{
		Pix RetObj = _All.pixDeskewBoth(this, redsearch);
		return RetObj;
	}

	// skew.c (205, 1)
	// pixDeskew(pixs, redsearch) as Pix
	// pixDeskew(PIX *, l_int32) as PIX *
	///  <summary>
	/// (1) This binarizes if necessary and finds the skew angle.  If the
	/// angle is large enough and there is sufficient confidence,
	/// it returns a deskewed image otherwise, it returns a clone.<para/>
	///
	/// (2) Typical values at 300 ppi for %redsearch are 2 and 4.
	/// At 75 ppi, one should use %redsearch = 1.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDeskew/*"/>
	///  <param name="redsearch">[in] - for binary search: reduction factor = 1, 2 or 4 use 0 for default</param>
	///   <returns>pixd deskewed pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Deskew (int redsearch)
	{
		Pix RetObj = _All.pixDeskew(this, redsearch);
		return RetObj;
	}

	// skew.c (241, 1)
	// pixFindSkewAndDeskew(pixs, redsearch, pangle, pconf) as Pix
	// pixFindSkewAndDeskew(PIX *, l_int32, l_float32 *, l_float32 *) as PIX *
	///  <summary>
	/// (1) This binarizes if necessary and finds the skew angle.  If the
	/// angle is large enough and there is sufficient confidence,
	/// it returns a deskewed image otherwise, it returns a clone.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindSkewAndDeskew/*"/>
	///  <param name="redsearch">[in] - for binary search: reduction factor = 1, 2 or 4 use 0 for default</param>
	///  <param name="pangle">[out][optional] - angle required to deskew, in degrees use NULL to skip</param>
	///  <param name="pconf">[out][optional] - conf value is ratio of max/min scores use NULL to skip</param>
	///   <returns>pixd deskewed pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix FindSkewAndDeskew (int redsearch,
								  out Single pangle,
								  out Single pconf)
	{
		Pix RetObj = _All.pixFindSkewAndDeskew(this, redsearch, out pangle, out pconf);
		return RetObj;
	}

	// skew.c (285, 1)
	// pixDeskewGeneral(pixs, redsweep, sweeprange, sweepdelta, redsearch, thresh, pangle, pconf) as Pix
	// pixDeskewGeneral(PIX *, l_int32, l_float32, l_float32, l_int32, l_int32, l_float32 *, l_float32 *) as PIX *
	///  <summary>
	/// (1) This binarizes if necessary and finds the skew angle.  If the
	/// angle is large enough and there is sufficient confidence,
	/// it returns a deskewed image otherwise, it returns a clone.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDeskewGeneral/*"/>
	///  <param name="redsweep">[in] - for linear search: reduction factor = 1, 2 or 4 use 0 for default</param>
	///  <param name="sweeprange">[in] - in degrees in each direction from 0 use 0.0 for default</param>
	///  <param name="sweepdelta">[in] - in degrees use 0.0 for default</param>
	///  <param name="redsearch">[in] - for binary search: reduction factor = 1, 2 or 4 use 0 for default</param>
	///  <param name="thresh">[in] - for binarizing the image use 0 for default</param>
	///  <param name="pangle">[out][optional] - angle required to deskew, in degrees use NULL to skip</param>
	///  <param name="pconf">[out][optional] - conf value is ratio of max/min scores use NULL to skip</param>
	///   <returns>pixd deskewed pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DeskewGeneral (int redsweep,
							  Single sweeprange,
							  Single sweepdelta,
							  int redsearch,
							  int thresh,
							  out Single pangle,
							  out Single pconf)
	{
		Pix RetObj = _All.pixDeskewGeneral(this, redsweep, sweeprange, sweepdelta, redsearch, thresh, out pangle, out pconf);
		return RetObj;
	}

	// skew.c (370, 1)
	// pixFindSkew(pixs, pangle, pconf) as int
	// pixFindSkew(PIX *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) This is a simple high-level interface, that uses default
	/// values of the parameters for reasonable speed and accuracy.<para/>
	///
	/// (2) The angle returned is the negative of the skew angle of
	/// the image.  It is the angle required for deskew.
	/// Clockwise rotations are positive angles.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindSkew/*"/>
	///  <param name="pangle">[out] - angle required to deskew, in degrees</param>
	///  <param name="pconf">[out] - confidence value is ratio max/min scores</param>
	///   <returns>0 if OK, 1 on error or if angle measurement not valid</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindSkew (out Single pangle,
						 out Single pconf)
	{
		int RetObj = _All.pixFindSkew(this, out pangle, out pconf);
		return RetObj;
	}

	// skew.c (414, 1)
	// pixFindSkewSweep(pixs, pangle, reduction, sweeprange, sweepdelta) as int
	// pixFindSkewSweep(PIX *, l_float32 *, l_int32, l_float32, l_float32) as l_ok
	///  <summary>
	/// (1) This examines the 'score' for skew angles with equal intervals.<para/>
	///
	/// (2) Caller must check the return value for validity of the result.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindSkewSweep/*"/>
	///  <param name="pangle">[out] - angle required to deskew, in degrees</param>
	///  <param name="reduction">[in] - factor = 1, 2, 4 or 8</param>
	///  <param name="sweeprange">[in] - half the full range assumed about 0 in degrees</param>
	///  <param name="sweepdelta">[in] - angle increment of sweep in degrees</param>
	///   <returns>0 if OK, 1 on error or if angle measurement not valid</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindSkewSweep (out Single pangle,
							  int reduction,
							  Single sweeprange,
							  Single sweepdelta)
	{
		int RetObj = _All.pixFindSkewSweep(this, out pangle, reduction, sweeprange, sweepdelta);
		return RetObj;
	}

	// skew.c (558, 1)
	// pixFindSkewSweepAndSearch(pixs, pangle, pconf, redsweep, redsearch, sweeprange, sweepdelta, minbsdelta) as int
	// pixFindSkewSweepAndSearch(PIX *, l_float32 *, l_float32 *, l_int32, l_int32, l_float32, l_float32, l_float32) as l_ok
	///  <summary>
	/// (1) This finds the skew angle, doing first a sweep through a set
	/// of equal angles, and then doing a binary search until
	/// convergence.<para/>
	///
	/// (2) Caller must check the return value for validity of the result.<para/>
	///
	/// (3) In computing the differential line sum variance score, we sum
	/// the result over scanlines, but we always skip:
	/// ~ at least one scanline
	/// ~ not more than 10% of the image height
	/// ~ not more than 5% of the image width<para/>
	///
	/// (4) See also notes in pixFindSkewSweepAndSearchScore()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindSkewSweepAndSearch/*"/>
	///  <param name="pangle">[out] - angle required to deskew in degrees</param>
	///  <param name="pconf">[out] - confidence given by ratio of max/min score</param>
	///  <param name="redsweep">[in] - sweep reduction factor = 1, 2, 4 or 8</param>
	///  <param name="redsearch">[in] - binary search reduction factor = 1, 2, 4 or 8 and must not exceed redsweep</param>
	///  <param name="sweeprange">[in] - half the full range, assumed about 0 in degrees</param>
	///  <param name="sweepdelta">[in] - angle increment of sweep in degrees</param>
	///  <param name="minbsdelta">[in] - min binary search increment angle in degrees</param>
	///   <returns>0 if OK, 1 on error or if angle measurement not valid</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindSkewSweepAndSearch (out Single pangle,
									   out Single pconf,
									   Single sweeprange,
									   Single sweepdelta,
									   Single minbsdelta,
									   int redsweep,
									   int redsearch)
	{
		int RetObj = _All.pixFindSkewSweepAndSearch(this, out pangle, out pconf, redsweep, redsearch, sweeprange, sweepdelta, minbsdelta);
		return RetObj;
	}

	// skew.c (612, 1)
	// pixFindSkewSweepAndSearchScore(pixs, pangle, pconf, pendscore, redsweep, redsearch, sweepcenter, sweeprange, sweepdelta, minbsdelta) as int
	// pixFindSkewSweepAndSearchScore(PIX *, l_float32 *, l_float32 *, l_float32 *, l_int32, l_int32, l_float32, l_float32, l_float32, l_float32) as l_ok
	///  <summary>
	/// (1) This finds the skew angle, doing first a sweep through a set
	/// of equal angles, and then doing a binary search until convergence.<para/>
	///
	/// (2) There are two built-in constants that determine if the
	/// returned confidence is nonzero:
	/// ~ MIN_VALID_MAXSCORE (minimum allowed maxscore)
	/// ~ MINSCORE_THRESHOLD_CONSTANT (determines minimum allowed
	/// minscore, by multiplying by (height  width^2)
	/// If either of these conditions is not satisfied, the returned
	/// confidence value will be zero.  The maxscore is optionally
	/// returned in this function to allow evaluation of the
	/// resulting angle by a method that is independent of the
	/// returned confidence value.<para/>
	///
	/// (3) The larger the confidence value, the greater the probability
	/// that the proper alignment is given by the angle that maximizes
	/// variance.  It should be compared to a threshold, which depends
	/// on the application.  Values between 3.0 and 6.0 are common.<para/>
	///
	/// (4) By default, the shear is about the UL corner.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindSkewSweepAndSearchScore/*"/>
	///  <param name="pangle">[out] - angle required to deskew in degrees</param>
	///  <param name="pconf">[out] - confidence given by ratio of max/min score</param>
	///  <param name="pendscore">[out][optional] - max score use NULL to ignore</param>
	///  <param name="redsweep">[in] - sweep reduction factor = 1, 2, 4 or 8</param>
	///  <param name="redsearch">[in] - binary search reduction factor = 1, 2, 4 or 8 and must not exceed redsweep</param>
	///  <param name="sweepcenter">[in] - angle about which sweep is performed in degrees</param>
	///  <param name="sweeprange">[in] - half the full range, taken about sweepcenter in degrees</param>
	///  <param name="sweepdelta">[in] - angle increment of sweep in degrees</param>
	///  <param name="minbsdelta">[in] - min binary search increment angle in degrees</param>
	///   <returns>0 if OK, 1 on error or if angle measurement not valid</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindSkewSweepAndSearchScore (out Single pangle,
											out Single pconf,
											Single sweepcenter,
											Single sweeprange,
											Single sweepdelta,
											Single minbsdelta,
											out Single pendscore,
											int redsweep,
											int redsearch)
	{
		int RetObj = _All.pixFindSkewSweepAndSearchScore(this, out pangle, out pconf, out pendscore, redsweep, redsearch, sweepcenter, sweeprange, sweepdelta, minbsdelta);
		return RetObj;
	}

	// skew.c (661, 1)
	// pixFindSkewSweepAndSearchScorePivot(pixs, pangle, pconf, pendscore, redsweep, redsearch, sweepcenter, sweeprange, sweepdelta, minbsdelta, pivot) as int
	// pixFindSkewSweepAndSearchScorePivot(PIX *, l_float32 *, l_float32 *, l_float32 *, l_int32, l_int32, l_float32, l_float32, l_float32, l_float32, l_int32) as l_ok
	///  <summary>
	/// (1) See notes in pixFindSkewSweepAndSearchScore().<para/>
	///
	/// (2) This allows choice of shear pivoting from either the UL corner
	/// or the center.  For small angles, the ability to discriminate
	/// angles is better with shearing from the UL corner.  However,
	/// for large angles (say, greater than 20 degrees), it is better
	/// to shear about the center because a shear from the UL corner
	/// loses too much of the image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindSkewSweepAndSearchScorePivot/*"/>
	///  <param name="pangle">[out] - angle required to deskew in degrees</param>
	///  <param name="pconf">[out] - confidence given by ratio of max/min score</param>
	///  <param name="pendscore">[out][optional] - max score use NULL to ignore</param>
	///  <param name="redsweep">[in] - sweep reduction factor = 1, 2, 4 or 8</param>
	///  <param name="redsearch">[in] - binary search reduction factor = 1, 2, 4 or 8 and must not exceed redsweep</param>
	///  <param name="sweepcenter">[in] - angle about which sweep is performed in degrees</param>
	///  <param name="sweeprange">[in] - half the full range, taken about sweepcenter in degrees</param>
	///  <param name="sweepdelta">[in] - angle increment of sweep in degrees</param>
	///  <param name="minbsdelta">[in] - min binary search increment angle in degrees</param>
	///  <param name="pivot">[in] - L_SHEAR_ABOUT_CORNER, L_SHEAR_ABOUT_CENTER</param>
	///   <returns>0 if OK, 1 on error or if angle measurement not valid</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindSkewSweepAndSearchScorePivot (out Single pangle,
												 out Single pconf,
												 Single sweepcenter,
												 Single sweeprange,
												 Single sweepdelta,
												 Single minbsdelta,
												 int pivot,
												 out Single pendscore,
												 int redsweep,
												 int redsearch)
	{
		int RetObj = _All.pixFindSkewSweepAndSearchScorePivot(this, out pangle, out pconf, out pendscore, redsweep, redsearch, sweepcenter, sweeprange, sweepdelta, minbsdelta, pivot);
		return RetObj;
	}

	// skew.c (1032, 1)
	// pixFindSkewOrthogonalRange(pixs, pangle, pconf, redsweep, redsearch, sweeprange, sweepdelta, minbsdelta, confprior) as int
	// pixFindSkewOrthogonalRange(PIX *, l_float32 *, l_float32 *, l_int32, l_int32, l_float32, l_float32, l_float32, l_float32) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindSkewOrthogonalRange/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int FindSkewOrthogonalRange (Single[] pangle,
										Single[] pconf,
										Single sweeprange,
										Single sweepdelta,
										Single minbsdelta,
										Single confprior,
										int redsweep,
										int redsearch)
	{
		int RetObj = _All.pixFindSkewOrthogonalRange(this, pangle, pconf, redsweep, redsearch, sweeprange, sweepdelta, minbsdelta, confprior);
		return RetObj;
	}

	// skew.c (1105, 1)
	// pixFindDifferentialSquareSum(pixs, psum) as int
	// pixFindDifferentialSquareSum(PIX *, l_float32 *) as l_ok
	///  <summary>
	/// (1) At the top and bottom, we skip:
	/// ~ at least one scanline
	/// ~ not more than 10% of the image height
	/// ~ not more than 5% of the image width
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindDifferentialSquareSum/*"/>
	///  <param name="psum">[out] - result</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindDifferentialSquareSum (out Single psum)
	{
		int RetObj = _All.pixFindDifferentialSquareSum(this, out psum);
		return RetObj;
	}

	// skew.c (1178, 1)
	// pixFindNormalizedSquareSum(pixs, phratio, pvratio, pfract) as int
	// pixFindNormalizedSquareSum(PIX *, l_float32 *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) Let the image have h scanlines and N fg pixels.
	/// If the pixels were uniformly distributed on scanlines,
	/// the sum of squares of fg pixels on each scanline would be
	/// h  (N / h)^2.  However, if the pixels are not uniformly
	/// distributed (e.g., for text), the sum of squares of fg
	/// pixels will be larger.  We return in hratio and vratio the
	/// ratio of these two values.<para/>
	///
	/// (2) If there are no fg pixels, hratio and vratio are returned as 0.0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindNormalizedSquareSum/*"/>
	///  <param name="phratio">[out][optional] - ratio of normalized horiz square sum to result if the pixel distribution were uniform</param>
	///  <param name="pvratio">[out][optional] - ratio of normalized vert square sum to result if the pixel distribution were uniform</param>
	///  <param name="pfract">[out][optional] - ratio of fg pixels to total pixels</param>
	///   <returns>0 if OK, 1 on error or if there are no fg pixels</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindNormalizedSquareSum (out Single phratio,
										out Single pvratio,
										out Single pfract)
	{
		int RetObj = _All.pixFindNormalizedSquareSum(this, out phratio, out pvratio, out pfract);
		return RetObj;
	}

	// spixio.c (88, 1)
	// pixReadStreamSpix(fp) as Pix
	// pixReadStreamSpix(FILE *) as PIX *
	///  <summary>
	/// (1) If called from pixReadStream(), the stream is positioned
	/// at the beginning of the file.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadStreamSpix/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>pix, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadStreamSpix (FILE fp)
	{
		Pix RetObj = _All.pixReadStreamSpix(fp);
		return RetObj;
	}

	// spixio.c (265, 1)
	// pixWriteStreamSpix(fp, pix) as int
	// pixWriteStreamSpix(FILE *, PIX *) as l_ok
	///  <summary>
	/// pixWriteStreamSpix()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamSpix/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="pix">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamSpix (FILE fp,
								Pix pix)
	{
		int RetObj = _All.pixWriteStreamSpix(fp, pix);
		return RetObj;
	}

	// spixio.c (297, 1)
	// pixReadMemSpix(data, size) as Pix
	// pixReadMemSpix(const l_uint8 *, size_t) as PIX *
	///  <summary>
	/// pixReadMemSpix()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadMemSpix/*"/>
	///  <param name="data">[in] - const uncompressed</param>
	///  <param name="size">[in] - bytes of data</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadMemSpix (Byte[] data,
							uint size)
	{
		Pix RetObj = _All.pixReadMemSpix(data, size);
		return RetObj;
	}

	// spixio.c (313, 1)
	// pixWriteMemSpix(pdata, psize, pix) as int
	// pixWriteMemSpix(l_uint8 **, size_t *, PIX *) as l_ok
	///  <summary>
	/// pixWriteMemSpix()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMemSpix/*"/>
	///  <param name="pdata">[out] - data of serialized, uncompressed pix</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="pix">[in] - all depths colormap OK</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemSpix (out Byte[] pdata,
							 out uint psize,
							 Pix pix)
	{
		int RetObj = _All.pixWriteMemSpix(out pdata, out psize, pix);
		return RetObj;
	}

	// spixio.c (346, 1)
	// pixSerializeToMemory(pixs, pdata, pnbytes) as int
	// pixSerializeToMemory(PIX *, l_uint32 **, size_t *) as l_ok
	///  <summary>
	/// (1) This does a fast serialization of the principal elements
	/// of the pix, as follows:
	/// "spix"  (4 bytes) -- ID for file type
	/// w (4 bytes)
	/// h (4 bytes)
	/// d (4 bytes)
	/// wpl (4 bytes)
	/// ncolors (4 bytes) -- in colormap 0 if there is no colormap
	/// cdata (4  ncolors)  -- size of serialized colormap array
	/// rdatasize (4 bytes) -- size of serialized raster data
	/// = 4  wpl  h
	/// rdata (rdatasize)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSerializeToMemory/*"/>
	///  <param name="pdata">[out] - serialized data in memory</param>
	///  <param name="pnbytes">[out] - number of bytes in data string</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SerializeToMemory (out Byte[] pdata,
								  out uint pnbytes)
	{
		int RetObj = _All.pixSerializeToMemory(this, out pdata, out pnbytes);
		return RetObj;
	}

	// spixio.c (424, 1)
	// pixDeserializeFromMemory(data, nbytes) as Pix
	// pixDeserializeFromMemory(const l_uint32 *, size_t) as PIX *
	///  <summary>
	/// (1) See pixSerializeToMemory() for the binary format.<para/>
	///
	/// (2) Note the image size limits.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDeserializeFromMemory/*"/>
	///  <param name="data">[in] - serialized data in memory</param>
	///  <param name="nbytes">[in] - number of bytes in data string</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DeserializeFromMemory (Byte[] data,
									  uint nbytes)
	{
		Pix RetObj = _All.pixDeserializeFromMemory(data, nbytes);
		return RetObj;
	}

	// strokes.c (75, 1)
	// pixFindStrokeLength(pixs, tab8, plength) as int
	// pixFindStrokeLength(PIX *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) Returns half the number of fg boundary pixels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindStrokeLength/*"/>
	///  <param name="tab8">[in][optional] - table for counting fg pixels can be NULL</param>
	///  <param name="plength">[out] - estimated length of the strokes</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindStrokeLength (out int plength,
								 int[] tab8)
	{
		int RetObj = _All.pixFindStrokeLength(this, tab8, out plength);
		return RetObj;
	}

	// strokes.c (123, 1)
	// pixFindStrokeWidth(pixs, thresh, tab8, pwidth, pnahisto) as int
	// pixFindStrokeWidth(PIX *, l_float32, l_int32 *, l_float32 *, NUMA **) as l_ok
	///  <summary>
	/// (1) This uses two methods to estimate the stroke width:
	/// (a) half the fg boundary length
	/// (b) a value derived from the histogram of the fg distance transform<para/>
	///
	/// (2) Distance is measured in 8-connected<para/>
	///
	/// (3) %thresh is the minimum fraction N(dist=d)/N(dist=1) of pixels
	/// required to determine if the pixels at distance d are above
	/// the noise. It is typically about 0.15.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixFindStrokeWidth/*"/>
	///  <param name="thresh">[in] - fractional count threshold relative to distance 1</param>
	///  <param name="tab8">[in][optional] - table for counting fg pixels can be NULL</param>
	///  <param name="pwidth">[out] - estimated width of the strokes</param>
	///  <param name="pnahisto">[out][optional] - histo of pixel distances from bg</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindStrokeWidth (Single thresh,
								out Single pwidth,
								int[] tab8,
								out Numa pnahisto)
	{
		int RetObj = _All.pixFindStrokeWidth(this, thresh, tab8, out pwidth, out pnahisto);
		return RetObj;
	}

	// strokes.c (298, 1)
	// pixModifyStrokeWidth(pixs, width, targetw) as Pix
	// pixModifyStrokeWidth(PIX *, l_float32, l_float32) as PIX *
	///  <summary>
	/// pixModifyStrokeWidth()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixModifyStrokeWidth/*"/>
	///  <param name="width">[in] - measured average stroke width</param>
	///  <param name="targetw">[in] - desired stroke width</param>
	///   <returns>pix  with modified stroke width, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ModifyStrokeWidth (Single width,
								  Single targetw)
	{
		Pix RetObj = _All.pixModifyStrokeWidth(this, width, targetw);
		return RetObj;
	}

	// strokes.c (397, 1)
	// pixSetStrokeWidth(pixs, width, thinfirst, connectivity) as Pix
	// pixSetStrokeWidth(PIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See notes in pixaSetStrokeWidth().<para/>
	///
	/// (2) A white border of sufficient width to avoid boundary
	/// artifacts in the thickening step is added before thinning.<para/>
	///
	/// (3) %connectivity == 8 usually gives a slightly smoother result.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetStrokeWidth/*"/>
	///  <param name="width">[in] - set stroke width to this value, in [1 ... 100].</param>
	///  <param name="thinfirst">[in] - 1 to thin all pix to a skeleton first 0 to skip</param>
	///  <param name="connectivity">[in] - 4 or 8, to be used if %thinfirst == 1</param>
	///   <returns>pixd  with stroke width set to %width, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SetStrokeWidth (int width,
							   int thinfirst,
							   int connectivity)
	{
		Pix RetObj = _All.pixSetStrokeWidth(this, width, thinfirst, connectivity);
		return RetObj;
	}

	// textops.c (115, 1)
	// pixAddSingleTextblock(pixs, bmf, textstr, val, location, poverflow) as Pix
	// pixAddSingleTextblock(PIX *, L_BMF *, const char *, l_uint32, l_int32, l_int32 *) as PIX *
	///  <summary>
	/// (1) This function paints a set of lines of text over an image.
	/// If %location is L_ADD_ABOVE or L_ADD_BELOW, the pix size
	/// is expanded with a border and rendered over the border.<para/>
	///
	/// (2) %val is the pixel value to be painted through the font mask.
	/// It should be chosen to agree with the depth of pixs.
	/// If it is out of bounds, an intermediate value is chosen.
	/// For RGB, use hex notation: 0xRRGGBB00, where RR is the
	/// hex representation of the red intensity, etc.<para/>
	///
	/// (3) If textstr == NULL, use the text field in the pix.<para/>
	///
	/// (4) If there is a colormap, this does the best it can to use
	/// the requested color, or something similar to it.<para/>
	///
	/// (5) Typical usage is for labelling a pix with some text data.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddSingleTextblock/*"/>
	///  <param name="bmf">[in] - bitmap font data</param>
	///  <param name="textstr">[in][optional] - text string to be added</param>
	///  <param name="val">[in] - color to set the text</param>
	///  <param name="location">[in] - L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW</param>
	///  <param name="poverflow">[out][optional] - 1 if text overflows allocated region and is clipped 0 otherwise</param>
	///   <returns>pixd new pix with rendered text, or either a copy or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddSingleTextblock (L_Bmf bmf,
								   uint val,
								   int location,
								   String textstr,
								   out int poverflow)
	{
		Pix RetObj = _All.pixAddSingleTextblock(this, bmf, textstr, val, location, out poverflow);
		return RetObj;
	}

	// textops.c (270, 1)
	// pixAddTextlines(pixs, bmf, textstr, val, location) as Pix
	// pixAddTextlines(PIX *, L_BMF *, const char *, l_uint32, l_int32) as PIX *
	///  <summary>
	/// (1) This function expands an image as required to paint one or
	/// more lines of text adjacent to the image.  If %bmf == NULL,
	/// this returns a copy.  If above or below, the lines are
	/// centered with respect to the image if left or right, they
	/// are left justified.<para/>
	///
	/// (2) %val is the pixel value to be painted through the font mask.
	/// It should be chosen to agree with the depth of pixs.
	/// If it is out of bounds, an intermediate value is chosen.
	/// For RGB, use hex notation: 0xRRGGBB00, where RR is the
	/// hex representation of the red intensity, etc.<para/>
	///
	/// (3) If textstr == NULL, use the text field in the pix.  The
	/// text field contains one or most "lines" of text, where newlines
	/// are used as line separators.<para/>
	///
	/// (4) If there is a colormap, this does the best it can to use
	/// the requested color, or something similar to it.<para/>
	///
	/// (5) Typical usage is for labelling a pix with some text data.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixAddTextlines/*"/>
	///  <param name="bmf">[in] - bitmap font data</param>
	///  <param name="textstr">[in][optional] - text string to be added</param>
	///  <param name="val">[in] - color to set the text</param>
	///  <param name="location">[in] - L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
	///   <returns>pixd new pix with rendered text, or either a copy or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AddTextlines (L_Bmf bmf,
							 uint val,
							 int location,
							 String textstr)
	{
		Pix RetObj = _All.pixAddTextlines(this, bmf, textstr, val, location);
		return RetObj;
	}

	// textops.c (431, 1)
	// pixSetTextblock(pixs, bmf, textstr, val, x0, y0, wtext, firstindent, poverflow) as int
	// pixSetTextblock(PIX *, L_BMF *, const char *, l_uint32, l_int32, l_int32, l_int32, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) This function paints a set of lines of text over an image.<para/>
	///
	/// (2) %val is the pixel value to be painted through the font mask.
	/// It should be chosen to agree with the depth of pixs.
	/// If it is out of bounds, an intermediate value is chosen.
	/// For RGB, use hex notation: 0xRRGGBB00, where RR is the
	/// hex representation of the red intensity, etc.
	/// The last two hex digits are 00 (byte value 0), assigned to
	/// the A component.  Note that, as usual, RGBA proceeds from
	/// left to right in the order from MSB to LSB (see pix.h
	/// for details).<para/>
	///
	/// (3) If there is a colormap, this does the best it can to use
	/// the requested color, or something similar to it.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetTextblock/*"/>
	///  <param name="bmf">[in] - bitmap font data</param>
	///  <param name="textstr">[in] - block text string to be set</param>
	///  <param name="val">[in] - color to set the text</param>
	///  <param name="x0">[in] - left edge for each line of text</param>
	///  <param name="y0">[in] - baseline location for the first text line</param>
	///  <param name="wtext">[in] - max width of each line of generated text</param>
	///  <param name="firstindent">[in] - indentation of first line, in x-widths</param>
	///  <param name="poverflow">[out][optional] - 0 if text is contained in input pix 1 if it is clipped</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetTextblock (L_Bmf bmf,
							 String textstr,
							 uint val,
							 int x0,
							 int y0,
							 int wtext,
							 int firstindent,
							 out int poverflow)
	{
		int RetObj = _All.pixSetTextblock(this, bmf, textstr, val, x0, y0, wtext, firstindent, out poverflow);
		return RetObj;
	}

	// textops.c (544, 1)
	// pixSetTextline(pixs, bmf, textstr, val, x0, y0, pwidth, poverflow) as int
	// pixSetTextline(PIX *, L_BMF *, const char *, l_uint32, l_int32, l_int32, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This function paints a line of text over an image.<para/>
	///
	/// (2) %val is the pixel value to be painted through the font mask.
	/// It should be chosen to agree with the depth of pixs.
	/// If it is out of bounds, an intermediate value is chosen.
	/// For RGB, use hex notation: 0xRRGGBB00, where RR is the
	/// hex representation of the red intensity, etc.
	/// The last two hex digits are 00 (byte value 0), assigned to
	/// the A component.  Note that, as usual, RGBA proceeds from
	/// left to right in the order from MSB to LSB (see pix.h
	/// for details).<para/>
	///
	/// (3) If there is a colormap, this does the best it can to use
	/// the requested color, or something similar to it.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSetTextline/*"/>
	///  <param name="bmf">[in] - bitmap font data</param>
	///  <param name="textstr">[in] - text string to be set on the line</param>
	///  <param name="val">[in] - color to set the text</param>
	///  <param name="x0">[in] - left edge for first char</param>
	///  <param name="y0">[in] - baseline location for all text on line</param>
	///  <param name="pwidth">[out][optional] - width of generated text</param>
	///  <param name="poverflow">[out][optional] - 0 if text is contained in input pix 1 if it is clipped</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetTextline (L_Bmf bmf,
							String textstr,
							uint val,
							int x0,
							int y0,
							out int pwidth,
							out int poverflow)
	{
		int RetObj = _All.pixSetTextline(this, bmf, textstr, val, x0, y0, out pwidth, out poverflow);
		return RetObj;
	}

	// tiffio.c (371, 1)
	// pixReadTiff(filename, n) as Pix
	// pixReadTiff(const char *, l_int32) as PIX *
	///  <summary>
	/// (1) This is a version of pixRead(), specialized for tiff
	/// files, that allows specification of the page to be returned<para/>
	///
	/// (2) No warning messages on failure, because of how multi-page
	/// TIFF reading works. You are supposed to keep trying until
	/// it stops working.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadTiff/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="n">[in] - page number 0 based</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadTiff (String filename,
						 int n)
	{
		Pix RetObj = _All.pixReadTiff(filename, n);
		return RetObj;
	}

	// tiffio.c (408, 1)
	// pixReadStreamTiff(fp, n) as Pix
	// pixReadStreamTiff(FILE *, l_int32) as PIX *
	///  <summary>
	/// (1) No warning messages on failure, because of how multi-page
	/// TIFF reading works. You are supposed to keep trying until
	/// it stops working.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadStreamTiff/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="n">[in] - page number: 0 based</param>
	///   <returns>pix, or NULL on error or if there are no more images in the file</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadStreamTiff (FILE fp,
							   int n)
	{
		Pix RetObj = _All.pixReadStreamTiff(fp, n);
		return RetObj;
	}

	// tiffio.c (654, 1)
	// pixWriteTiff(filename, pix, comptype, modestr) as int
	// pixWriteTiff(const char *, PIX *, l_int32, const char *) as l_ok
	///  <summary>
	/// (1) For multipage tiff, write the first pix with mode "w" and
	/// all subsequent pix with mode "a".<para/>
	///
	/// (2) For multipage tiff, there is considerable overhead in the
	/// machinery to append an image and add the directory entry,
	/// and the time required for each image increases linearly
	/// with the number of images in the file.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteTiff/*"/>
	///  <param name="filename">[in] - to write to</param>
	///  <param name="pix">[in] - </param>
	///  <param name="comptype">[in] - IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	///  <param name="modestr">[in] - "a" or "w"</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteTiff (String filename,
						  Pix pix,
						  int comptype,
						  String modestr)
	{
		int RetObj = _All.pixWriteTiff(filename, pix, comptype, modestr);
		return RetObj;
	}

	// tiffio.c (711, 1)
	// pixWriteTiffCustom(filename, pix, comptype, modestr, natags, savals, satypes, nasizes) as int
	// pixWriteTiffCustom(const char *, PIX *, l_int32, const char *, NUMA *, SARRAY *, SARRAY *, NUMA *) as l_ok
	///  <summary>
	/// pixWriteTiffCustom()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteTiffCustom/*"/>
	///  <param name="filename">[in] - to write to</param>
	///  <param name="pix">[in] - </param>
	///  <param name="comptype">[in] - IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	///  <param name="modestr">[in] - "a" or "w"</param>
	///  <param name="natags">[in][optional] - NUMA of custom tiff tags</param>
	///  <param name="savals">[in][optional] - SARRAY of values</param>
	///  <param name="satypes">[in][optional] - SARRAY of types</param>
	///  <param name="nasizes">[in][optional] - NUMA of sizes</param>
	///   <returns>0 if OK, 1 on error Usage: 1 This writes a page image to a tiff file, with optional extra tags defined in tiff.h 2 For multipage tiff, write the first pix with mode "w" and all subsequent pix with mode "a". 3 For the custom tiff tags: a The three arrays {natags, savals, satypes} must all be either NULL or defined and of equal size. b If they are defined, the tags are an array of integers, the vals are an array of values in string format, and the types are an array of types in string format. c All valid tags are definined in tiff.h. d The types allowed are the set of strings: "char" "l_uint8" "l_uint16" "l_uint32" "l_int32" "l_float64" "l_uint16-l_uint16" note the dash use it between the two l_uint16 vals in the val string Of these, "char" and "l_uint16" are the most commonly used. e The last array, nasizes, is also optional.  It is for tags that take an array of bytes for a value, a number of elements in the array, and a type that is either "char" or "l_uint8" probably either will work. Use NULL if there are no such tags. f VERY IMPORTANT: if there are any tags that require the extra size value, stored in nasizes, they must be written first!</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteTiffCustom (String filename,
								Pix pix,
								int comptype,
								String modestr,
								Numa natags,
								Sarray savals,
								Sarray satypes,
								Numa nasizes)
	{
		int RetObj = _All.pixWriteTiffCustom(filename, pix, comptype, modestr, natags, savals, satypes, nasizes);
		return RetObj;
	}

	// tiffio.c (770, 1)
	// pixWriteStreamTiff(fp, pix, comptype) as int
	// pixWriteStreamTiff(FILE *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) This writes a single image to a file stream opened for writing.<para/>
	///
	/// (2) For images with bpp  is greater  1, this resets the comptype, if
	/// necessary, to write uncompressed data.<para/>
	///
	/// (3) G3 and G4 are only defined for 1 bpp.<para/>
	///
	/// (4) We only allow PACKBITS for bpp = 1, because for bpp  is greater  1
	/// it typically expands images that are not synthetically generated.<para/>
	///
	/// (5) G4 compression is typically about twice as good as G3.
	/// G4 is excellent for binary compression of text/line-art,
	/// but terrible for halftones and dithered patterns.  (In
	/// fact, G4 on halftones can give a file that is larger
	/// than uncompressed!)  If a binary image has dithered
	/// regions, it is usually better to compress with png.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamTiff/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="pix">[in] - </param>
	///  <param name="comptype">[in] - IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamTiff (FILE fp,
								Pix pix,
								int comptype)
	{
		int RetObj = _All.pixWriteStreamTiff(fp, pix, comptype);
		return RetObj;
	}

	// tiffio.c (790, 1)
	// pixWriteStreamTiffWA(fp, pix, comptype, modestr) as int
	// pixWriteStreamTiffWA(FILE *, PIX *, l_int32, const char *) as l_ok
	///  <summary>
	/// pixWriteStreamTiffWA()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamTiffWA/*"/>
	///  <param name="fp">[in] - file stream opened for append or write</param>
	///  <param name="pix">[in] - </param>
	///  <param name="comptype">[in] - IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	///  <param name="modestr">[in] - "w" or "a"</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamTiffWA (FILE fp,
								  Pix pix,
								  int comptype,
								  String modestr)
	{
		int RetObj = _All.pixWriteStreamTiffWA(fp, pix, comptype, modestr);
		return RetObj;
	}

	// tiffio.c (1177, 1)
	// pixReadFromMultipageTiff(fname, poffset) as Pix
	// pixReadFromMultipageTiff(const char *, size_t *) as PIX *
	///  <summary>
	/// (1) This allows overhead for traversal of a multipage tiff file
	/// to be linear in the number of images.  This will also work
	/// with a singlepage tiff file.<para/>
	///
	/// (2) No TIFF internal data structures are exposed to the caller
	/// (thanks to Jeff Breidenbach).<para/>
	///
	/// (3) offset is the byte offset of a particular image in a multipage
	/// tiff file. To get the first image in the file, input the
	/// special offset value of 0.<para/>
	///
	/// (4) The offset is updated to point to the next image, for a
	/// subsequent call.<para/>
	///
	/// (5) On the last image, the offset returned is 0.  Exit the loop
	/// when the returned offset is 0.<para/>
	///
	/// (6) For reading a multipage tiff from a memory buffer, see
	/// pixReadMemFromMultipageTiff()<para/>
	///
	/// (7) Example usage for reading all the images in the tif file:
	/// size_t offset = 0
	/// do {
	/// Pix pix = pixReadFromMultipageTiff(filename, [and]offset)
	/// // do something with pix
	/// } while (offset != 0)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadFromMultipageTiff/*"/>
	///  <param name="fname">[in] - filename</param>
	///  <param name="poffset">[in,out] - set offset to 0 for first image</param>
	///   <returns>pix, or NULL on error or if previous call returned the last image</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadFromMultipageTiff (String fname,
									  ref Byte[] poffset)
	{
		Pix RetObj = _All.pixReadFromMultipageTiff(fname, ref poffset);
		return RetObj;
	}

	// tiffio.c (2445, 1)
	// pixReadMemTiff(cdata, size, n) as Pix
	// pixReadMemTiff(const l_uint8 *, size_t, l_int32) as PIX *
	///  <summary>
	/// (1) This is a version of pixReadTiff(), where the data is read
	/// from a memory buffer and uncompressed.<para/>
	///
	/// (2) Use TIFFClose() TIFFCleanup() doesn't free internal memstream.<para/>
	///
	/// (3) No warning messages on failure, because of how multi-page
	/// TIFF reading works. You are supposed to keep trying until
	/// it stops working.<para/>
	///
	/// (4) Tiff directory overhead is linear in the input page number.
	/// If reading many images, use pixReadMemFromMultipageTiff().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadMemTiff/*"/>
	///  <param name="cdata">[in] - const tiff-encoded</param>
	///  <param name="size">[in] - size of cdata</param>
	///  <param name="n">[in] - page image number: 0-based</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadMemTiff (Byte[] cdata,
							uint size,
							int n)
	{
		Pix RetObj = _All.pixReadMemTiff(cdata, size, n);
		return RetObj;
	}

	// tiffio.c (2510, 1)
	// pixReadMemFromMultipageTiff(cdata, size, poffset) as Pix
	// pixReadMemFromMultipageTiff(const l_uint8 *, size_t, size_t *) as PIX *
	///  <summary>
	/// (1) This is a read-from-memory version of pixReadFromMultipageTiff().
	/// See that function for usage.<para/>
	///
	/// (2) If reading sequentially from the tiff data, this is more
	/// efficient than pixReadMemTiff(), which has an overhead
	/// proportional to the image index n.<para/>
	///
	/// (3) Example usage for reading all the images:
	/// size_t offset = 0
	/// do {
	/// Pix pix = pixReadMemFromMultipageTiff(data, size, [and]offset)
	/// // do something with pix
	/// } while (offset != 0)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadMemFromMultipageTiff/*"/>
	///  <param name="cdata">[in] - const tiff-encoded</param>
	///  <param name="size">[in] - size of cdata</param>
	///  <param name="poffset">[in,out] - set offset to 0 for first image</param>
	///   <returns>pix, or NULL on error or if previous call returned the last image</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadMemFromMultipageTiff (Byte[] cdata,
										 uint size,
										 ref Byte[] poffset)
	{
		Pix RetObj = _All.pixReadMemFromMultipageTiff(cdata, size, ref poffset);
		return RetObj;
	}

	// tiffio.c (2672, 1)
	// pixWriteMemTiff(pdata, psize, pix, comptype) as int
	// pixWriteMemTiff(l_uint8 **, size_t *, PIX *, l_int32) as l_ok
	///  <summary>
	/// pixWriteMemTiff()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMemTiff/*"/>
	///  <param name="pdata">[out] - data of tiff compressed image</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="pix">[in] - </param>
	///  <param name="comptype">[in] - IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	///   <returns>0 if OK, 1 on error Usage: 1) See pixWriteTiff(.  This version writes to memory instead of to a file.</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemTiff (out Byte[] pdata,
							 out uint psize,
							 Pix pix,
							 int comptype)
	{
		int RetObj = _All.pixWriteMemTiff(out pdata, out psize, pix, comptype);
		return RetObj;
	}

	// tiffio.c (2703, 1)
	// pixWriteMemTiffCustom(pdata, psize, pix, comptype, natags, savals, satypes, nasizes) as int
	// pixWriteMemTiffCustom(l_uint8 **, size_t *, PIX *, l_int32, NUMA *, SARRAY *, SARRAY *, NUMA *) as l_ok
	///  <summary>
	/// pixWriteMemTiffCustom()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMemTiffCustom/*"/>
	///  <param name="pdata">[out] - data of tiff compressed image</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="pix">[in] - </param>
	///  <param name="comptype">[in] - IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	///  <param name="natags">[in][optional] - NUMA of custom tiff tags</param>
	///  <param name="savals">[in][optional] - SARRAY of values</param>
	///  <param name="satypes">[in][optional] - SARRAY of types</param>
	///  <param name="nasizes">[in][optional] - NUMA of sizes</param>
	///   <returns>0 if OK, 1 on error Usage: 1) See pixWriteTiffCustom(.  This version writes to memory instead of to a file. 2) Use TIFFClose() TIFFCleanup( doesn't free internal memstream.</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemTiffCustom (out Byte[] pdata,
								   out uint psize,
								   Pix pix,
								   int comptype,
								   Numa natags,
								   Sarray savals,
								   Sarray satypes,
								   Numa nasizes)
	{
		int RetObj = _All.pixWriteMemTiffCustom(out pdata, out psize, pix, comptype, natags, savals, satypes, nasizes);
		return RetObj;
	}

	// warper.c (107, 1)
	// pixSimpleCaptcha(pixs, border, nterms, seed, color, cmapflag) as Pix
	// pixSimpleCaptcha(PIX *, l_int32, l_int32, l_uint32, l_uint32, l_int32) as PIX *
	///  <summary>
	/// (1) This uses typical default values for generating captchas.
	/// The magnitudes of the harmonic warp are typically to be
	/// smaller when more terms are used, even though the phases
	/// are random.  See, for example, prog/warptest.c.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSimpleCaptcha/*"/>
	///  <param name="border">[in] - added white pixels on each side</param>
	///  <param name="nterms">[in] - number of x and y harmonic terms</param>
	///  <param name="seed">[in] - of random number generator</param>
	///  <param name="color">[in] - for colorizing in 0xrrggbb00 format use 0 for black</param>
	///  <param name="cmapflag">[in] - 1 for colormap output 0 for rgb</param>
	///   <returns>pixd 8 bpp cmap or 32 bpp rgb, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix SimpleCaptcha (int border,
							  int nterms,
							  uint seed,
							  uint color,
							  int cmapflag)
	{
		Pix RetObj = _All.pixSimpleCaptcha(this, border, nterms, seed, color, cmapflag);
		return RetObj;
	}

	// warper.c (181, 1)
	// pixRandomHarmonicWarp(pixs, xmag, ymag, xfreq, yfreq, nx, ny, seed, grayval) as Pix
	// pixRandomHarmonicWarp(PIX *, l_float32, l_float32, l_float32, l_float32, l_int32, l_int32, l_uint32, l_int32) as PIX *
	///  <summary>
	/// (1) To generate the warped image p(x',y'), set up the transforms
	/// that are in getWarpTransform().  For each (x',y') in the
	/// dest, the warp function computes the originating location
	/// (x, y) in the src.  The differences (x - x') and (y - y')
	/// are given as a sum of products of sinusoidal terms.  Each
	/// term is multiplied by a maximum amplitude (in pixels), and the
	/// angle is determined by a frequency and phase, and depends
	/// on the (x', y') value of the dest.  Random numbers with
	/// a variable input seed are used to allow the warping to be
	/// unpredictable.  A linear interpolation is used to find
	/// the value for the source at (x, y) this value is written
	/// into the dest.<para/>
	///
	/// (2) This can be used to generate 'captcha's, which are somewhat
	/// randomly distorted images of text.  A typical set of parameters
	/// for a captcha are:
	/// xmag = 4.0 ymag = 6.0
	/// xfreq = 0.10 yfreq = 0.13
	/// nx = 3 ny = 3
	/// Other examples can be found in prog/warptest.c.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixRandomHarmonicWarp/*"/>
	///  <param name="xmag">[in] - maximum magnitude of x and y distortion</param>
	///  <param name="ymag">[in] - maximum magnitude of x and y distortion</param>
	///  <param name="xfreq">[in] - maximum magnitude of x and y frequency</param>
	///  <param name="yfreq">[in] - maximum magnitude of x and y frequency</param>
	///  <param name="nx">[in] - number of x and y harmonic terms</param>
	///  <param name="ny">[in] - number of x and y harmonic terms</param>
	///  <param name="seed">[in] - of random number generator</param>
	///  <param name="grayval">[in] - color brought in from the outside 0 for black, 255 for white</param>
	///   <returns>pixd 8 bpp no colormap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RandomHarmonicWarp (Single xmag,
								   Single ymag,
								   Single xfreq,
								   Single yfreq,
								   int nx,
								   int ny,
								   uint seed,
								   int grayval)
	{
		Pix RetObj = _All.pixRandomHarmonicWarp(this, xmag, ymag, xfreq, yfreq, nx, ny, seed, grayval);
		return RetObj;
	}

	// warper.c (586, 1)
	// pixWarpStereoscopic(pixs, zbend, zshiftt, zshiftb, ybendt, ybendb, redleft) as Pix
	// pixWarpStereoscopic(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This function splits out the red channel, mucks around with
	/// it, then recombines with the unmolested cyan channel.<para/>
	///
	/// (2) By using a quadratically increasing shift of the red
	/// pixels horizontally and away from the vertical centerline,
	/// the image appears to bend quadratically out of the image
	/// plane, symmetrically with respect to the vertical center
	/// line.  A positive value of %zbend causes the plane to be
	/// curved away from the viewer.  We use linearly interpolated
	/// stretching to avoid the appearance of kinks in the curve.<para/>
	///
	/// (3) The parameters %zshiftt and %zshiftb tilt the image plane
	/// about a horizontal line through the center, and at the
	/// same time move that line either in toward the viewer or away.
	/// This is implemented by a combination of horizontal shear
	/// about the center line (for the tilt) and horizontal
	/// translation (to move the entire plane in or out).
	/// A positive value of %zshiftt moves the top of the plane
	/// away from the viewer, and a positive value of %zshiftb
	/// moves the bottom of the plane away.  We use linear interpolated
	/// shear to avoid visible vertical steps in the tilted image.<para/>
	///
	/// (4) The image can be bent in the plane and about the vertical
	/// centerline.  The centerline does not shift, and the
	/// parameter %ybend gives the relative shift at left and right
	/// edges, with a downward shift for positive values of %ybend.<para/>
	///
	/// (6) When writing out a steroscopic (red/cyan) image in jpeg,
	/// first call pixSetChromaSampling(pix, 0) to get sufficient
	/// resolution in the red channel.<para/>
	///
	/// (7) Typical values are:
	/// zbend = 20
	/// zshiftt = 15
	/// zshiftb = -15
	/// ybendt = 30
	/// ybendb = 0
	/// If the disparity z-values are too large, it is difficult for
	/// the brain to register the two images.<para/>
	///
	/// (8) This function has been cleverly reimplemented by Jeff Breidenbach.
	/// The original implementation used two 32 bpp rgb images,
	/// and merged them at the end.  The result is somewhat faded,
	/// and has a parameter "thresh" that controls the amount of
	/// color in the result.  (The present implementation avoids these
	/// two problems, skipping both the colorization and the alpha
	/// blending at the end, and is about 3x faster)
	/// The basic operations with 32 bpp are as follows:
	/// // Immediate conversion to 32 bpp
	/// Pix pixt1 = pixConvertTo32(pixs)
	/// // Do vertical shear
	/// Pix pixr = pixQuadraticVerticalShear(pixt1, L_WARP_TO_RIGHT,
	/// ybendt, ybendb,
	/// L_BRING_IN_WHITE)
	/// // Colorize two versions, toward red and cyan
	/// Pix pixc = pixCopy(NULL, pixr)
	/// l_int32 thresh = 150  // if higher, get less original color
	/// pixColorGray(pixr, NULL, L_PAINT_DARK, thresh, 255, 0, 0)
	/// pixColorGray(pixc, NULL, L_PAINT_DARK, thresh, 0, 255, 255)
	/// // Shift the red pixels e.g., by stretching
	/// Pix pixrs = pixStretchHorizontal(pixr, L_WARP_TO_RIGHT,
	/// L_QUADRATIC_WARP, zbend,
	/// L_INTERPOLATED,
	/// L_BRING_IN_WHITE)
	/// // Blend the shifted red and unshifted cyan 50:50
	/// Pix pixg = pixCreate(w, h, 8)
	/// pixSetAllArbitrary(pixg, 128)
	/// pixd = pixBlendWithGrayMask(pixrs, pixc, pixg, 0, 0)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWarpStereoscopic/*"/>
	///  <param name="zbend">[in] - horizontal separation in pixels of red and cyan at the left and right sides, that gives rise to quadratic curvature out of the image plane</param>
	///  <param name="zshiftt">[in] - uniform pixel translation difference between red and cyan, that pushes the top of the image plane away from the viewer (zshiftt  is greater  0) or towards the viewer (zshiftt  is smaller 0)</param>
	///  <param name="zshiftb">[in] - uniform pixel translation difference between red and cyan, that pushes the bottom of the image plane away from the viewer (zshiftb  is greater  0) or towards the viewer (zshiftb  is smaller 0)</param>
	///  <param name="ybendt">[in] - multiplicative parameter for in-plane vertical displacement at the left or right edge at the top: y = ybendt  (2x/w - 1)^2</param>
	///  <param name="ybendb">[in] - same as ybendt, except at the left or right edge at the bottom</param>
	///  <param name="redleft">[in] - 1 if the red filter is on the left 0 otherwise</param>
	///   <returns>pixd 32 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix WarpStereoscopic (int zbend,
								 int zshiftt,
								 int zshiftb,
								 int ybendt,
								 int ybendb,
								 int redleft)
	{
		Pix RetObj = _All.pixWarpStereoscopic(this, zbend, zshiftt, zshiftb, ybendt, ybendb, redleft);
		return RetObj;
	}

	// warper.c (733, 1)
	// pixStretchHorizontal(pixs, dir, type, hmax, operation, incolor) as Pix
	// pixStretchHorizontal(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) If %hmax  is greater  0, this is an increase in the coordinate value of
	/// pixels in pixd, relative to the same pixel in pixs.<para/>
	///
	/// (2) If %dir == L_WARP_TO_LEFT, the pixels on the right edge of
	/// the image are not moved. So, for example, if %hmax  is greater  0
	/// and %dir == L_WARP_TO_LEFT, the pixels in pixd are
	/// contracted toward the right edge of the image, relative
	/// to those in pixs.<para/>
	///
	/// (3) If %type == L_LINEAR_WARP, the pixel positions are moved
	/// to the left or right by an amount that varies linearly with
	/// the horizontal location.<para/>
	///
	/// (4) If %operation == L_SAMPLED, the dest pixels are taken from
	/// the nearest src pixel.  Otherwise, we use linear interpolation
	/// between pairs of sampled pixels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixStretchHorizontal/*"/>
	///  <param name="dir">[in] - L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	///  <param name="type">[in] - L_LINEAR_WARP or L_QUADRATIC_WARP</param>
	///  <param name="hmax">[in] - horizontal displacement at edge</param>
	///  <param name="operation">[in] - L_SAMPLED or L_INTERPOLATED</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	///   <returns>pixd stretched/compressed, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix StretchHorizontal (int dir,
								  int type,
								  int hmax,
								  int operation,
								  int incolor)
	{
		Pix RetObj = _All.pixStretchHorizontal(this, dir, type, hmax, operation, incolor);
		return RetObj;
	}

	// warper.c (785, 1)
	// pixStretchHorizontalSampled(pixs, dir, type, hmax, incolor) as Pix
	// pixStretchHorizontalSampled(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See pixStretchHorizontal() for details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixStretchHorizontalSampled/*"/>
	///  <param name="dir">[in] - L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	///  <param name="type">[in] - L_LINEAR_WARP or L_QUADRATIC_WARP</param>
	///  <param name="hmax">[in] - horizontal displacement at edge</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	///   <returns>pixd stretched/compressed, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix StretchHorizontalSampled (int dir,
										 int type,
										 int hmax,
										 int incolor)
	{
		Pix RetObj = _All.pixStretchHorizontalSampled(this, dir, type, hmax, incolor);
		return RetObj;
	}

	// warper.c (883, 1)
	// pixStretchHorizontalLI(pixs, dir, type, hmax, incolor) as Pix
	// pixStretchHorizontalLI(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See pixStretchHorizontal() for details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixStretchHorizontalLI/*"/>
	///  <param name="dir">[in] - L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	///  <param name="type">[in] - L_LINEAR_WARP or L_QUADRATIC_WARP</param>
	///  <param name="hmax">[in] - horizontal displacement at edge</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	///   <returns>pixd stretched/compressed, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix StretchHorizontalLI (int dir,
									int type,
									int hmax,
									int incolor)
	{
		Pix RetObj = _All.pixStretchHorizontalLI(this, dir, type, hmax, incolor);
		return RetObj;
	}

	// warper.c (1019, 1)
	// pixQuadraticVShear(pixs, dir, vmaxt, vmaxb, operation, incolor) as Pix
	// pixQuadraticVShear(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This gives a quadratic bending, upward or downward, as you
	/// move to the left or right.<para/>
	///
	/// (2) If %dir == L_WARP_TO_LEFT, the right edge is unchanged, and
	/// the left edge pixels are moved maximally up or down.<para/>
	///
	/// (3) Parameters %vmaxt and %vmaxb control the maximum amount of
	/// vertical pixel shear at the top and bottom, respectively.
	/// If %vmaxt  is greater  0, the vertical displacement of pixels at the
	/// top is downward.  Likewise, if %vmaxb  is greater  0, the vertical
	/// displacement of pixels at the bottom is downward.<para/>
	///
	/// (4) If %operation == L_SAMPLED, the dest pixels are taken from
	/// the nearest src pixel.  Otherwise, we use linear interpolation
	/// between pairs of sampled pixels.<para/>
	///
	/// (5) This is for quadratic shear.  For uniform (linear) shear,
	/// use the standard shear operators.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixQuadraticVShear/*"/>
	///  <param name="dir">[in] - L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	///  <param name="vmaxt">[in] - max vertical displacement at edge and at top</param>
	///  <param name="vmaxb">[in] - max vertical displacement at edge and at bottom</param>
	///  <param name="operation">[in] - L_SAMPLED or L_INTERPOLATED</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	///   <returns>pixd stretched, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix QuadraticVShear (int dir,
								int vmaxt,
								int vmaxb,
								int operation,
								int incolor)
	{
		Pix RetObj = _All.pixQuadraticVShear(this, dir, vmaxt, vmaxb, operation, incolor);
		return RetObj;
	}

	// warper.c (1073, 1)
	// pixQuadraticVShearSampled(pixs, dir, vmaxt, vmaxb, incolor) as Pix
	// pixQuadraticVShearSampled(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See pixQuadraticVShear() for details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixQuadraticVShearSampled/*"/>
	///  <param name="dir">[in] - L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	///  <param name="vmaxt">[in] - max vertical displacement at edge and at top</param>
	///  <param name="vmaxb">[in] - max vertical displacement at edge and at bottom</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	///   <returns>pixd stretched, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix QuadraticVShearSampled (int dir,
									   int vmaxt,
									   int vmaxb,
									   int incolor)
	{
		Pix RetObj = _All.pixQuadraticVShearSampled(this, dir, vmaxt, vmaxb, incolor);
		return RetObj;
	}

	// warper.c (1179, 1)
	// pixQuadraticVShearLI(pixs, dir, vmaxt, vmaxb, incolor) as Pix
	// pixQuadraticVShearLI(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) See pixQuadraticVShear() for details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixQuadraticVShearLI/*"/>
	///  <param name="dir">[in] - L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	///  <param name="vmaxt">[in] - max vertical displacement at edge and at top</param>
	///  <param name="vmaxb">[in] - max vertical displacement at edge and at bottom</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	///   <returns>pixd stretched, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix QuadraticVShearLI (int dir,
								  int vmaxt,
								  int vmaxb,
								  int incolor)
	{
		Pix RetObj = _All.pixQuadraticVShearLI(this, dir, vmaxt, vmaxb, incolor);
		return RetObj;
	}

	// warper.c (1332, 1)
	// pixStereoFromPair(pix1, pix2, rwt, gwt, bwt) as Pix
	// pixStereoFromPair(PIX *, PIX *, l_float32, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) pix1 and pix2 are a pair of stereo images, ideally taken
	/// concurrently in the same plane, with some lateral translation.<para/>
	///
	/// (2) The output red channel is determined from %pix1.
	/// The output green and blue channels are taken from the green
	/// and blue channels, respectively, of %pix2.<para/>
	///
	/// (3) The weights determine how much of each component in %pix1
	/// goes into the output red channel.  The sum of weights
	/// must be 1.0.  If it's not, we scale the weights to
	/// satisfy this criterion.<para/>
	///
	/// (4) The most general pixel mapping allowed here is:
	/// rval = rwt  r1 + gwt  g1 + bwt  b1  (from pix1)
	/// gval = g2 (from pix2)
	/// bval = b2 (from pix2)<para/>
	///
	/// (5) The simplest method is to use rwt = 1.0, gwt = 0.0, bwt = 0.0,
	/// but this causes unpleasant visual artifacts with red in the image.
	/// Use of green and blue from %pix1 in the red channel,
	/// instead of red, tends to fix that problem.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixStereoFromPair/*"/>
	///  <param name="pix1">[in] - 32 bpp rgb</param>
	///  <param name="pix2">[in] - 32 bpp rgb</param>
	///  <param name="rwt">[in] - weighting factors used for each component in                                pix1 to determine the output red channel</param>
	///  <param name="gwt">[in] - weighting factors used for each component in                                pix1 to determine the output red channel</param>
	///  <param name="bwt">[in] - weighting factors used for each component in                                pix1 to determine the output red channel</param>
	///   <returns>pixd stereo enhanced, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix StereoFromPair (Pix pix1,
							   Pix pix2,
							   Single rwt,
							   Single gwt,
							   Single bwt)
	{
		Pix RetObj = _All.pixStereoFromPair(pix1, pix2, rwt, gwt, bwt);
		return RetObj;
	}

	// webpiostub.c (45, 7)
	// pixReadStreamWebP(fp) as Pix
	// pixReadStreamWebP(FILE *) as PIX *
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadStreamWebP/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadStreamWebP (FILE fp)
	{
		Pix RetObj = _All.pixReadStreamWebP(fp);
		return RetObj;
	}

	// webpiostub.c (52, 7)
	// pixReadMemWebP(filedata, filesize) as Pix
	// pixReadMemWebP(const l_uint8 *, size_t) as PIX *
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixReadMemWebP/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ReadMemWebP (Byte[] filedata,
							uint filesize)
	{
		Pix RetObj = _All.pixReadMemWebP(filedata, filesize);
		return RetObj;
	}

	// webpiostub.c (75, 6)
	// pixWriteWebP(filename, pixs, quality, lossless) as int
	// pixWriteWebP(const char *, PIX *, l_int32, l_int32) as l_ok
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteWebP/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteWebP (String filename,
						  int lossless,
						  int quality)
	{
		int RetObj = _All.pixWriteWebP(filename, this, quality, lossless);
		return RetObj;
	}

	// webpiostub.c (83, 6)
	// pixWriteStreamWebP(fp, pixs, quality, lossless) as int
	// pixWriteStreamWebP(FILE *, PIX *, l_int32, l_int32) as l_ok
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStreamWebP/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamWebP (FILE fp,
								int lossless,
								int quality)
	{
		int RetObj = _All.pixWriteStreamWebP(fp, this, quality, lossless);
		return RetObj;
	}

	// webpiostub.c (91, 6)
	// pixWriteMemWebP(pencdata, pencsize, pixs, quality, lossless) as int
	// pixWriteMemWebP(l_uint8 **, size_t *, PIX *, l_int32, l_int32) as l_ok
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMemWebP/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemWebP (object pencdata,
							 object pencsize,
							 int lossless,
							 int quality)
	{
		int RetObj = _All.pixWriteMemWebP(pencdata, pencsize, this, quality, lossless);
		return RetObj;
	}

	// writefile.c (295, 1)
	// pixWriteDebug(fname, pix, format) as int
	// pixWriteDebug(const char *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) Debug version, intended for use in the library when writing
	/// to files in a temp directory with names that are compiled in.
	/// This is used instead of pixWrite() for all such library calls.<para/>
	///
	/// (2) The global variable LeptDebugOK defaults to 0, and can be set
	/// or cleared by the function setLeptDebugOK().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteDebug/*"/>
	///  <param name="fname">[in] - </param>
	///  <param name="pix">[in] - </param>
	///  <param name="format">[in] - defined in imageio.h</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteDebug (String fname,
						   Pix pix,
						   IFF format)
	{
		int RetObj = _All.pixWriteDebug(fname, pix, format);
		return RetObj;
	}

	// writefile.c (332, 1)
	// pixWrite(fname, pix, format) as int
	// pixWrite(const char *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) Open for write using binary mode (with the "b" flag)
	/// to avoid having Windows automatically translate the NL
	/// into CRLF, which corrupts image files.  On non-windows
	/// systems this flag should be ignored, per ISO C90.
	/// Thanks to Dave Bryan for pointing this out.<para/>
	///
	/// (2) If the default image format IFF_DEFAULT is requested:
	/// use the input format if known otherwise, use a lossless format.<para/>
	///
	/// (3) The default jpeg quality is 75.  For some other value,
	/// Use l_jpegSetQuality().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWrite/*"/>
	///  <param name="fname">[in] - </param>
	///  <param name="pix">[in] - </param>
	///  <param name="format">[in] - defined in imageio.h</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String fname,
					  Pix pix,
					  IFF format)
	{
		int RetObj = _All.pixWrite(fname, pix, format);
		return RetObj;
	}

	// writefile.c (365, 1)
	// pixWriteAutoFormat(filename, pix) as int
	// pixWriteAutoFormat(const char *, PIX *) as l_ok
	///  <summary>
	/// pixWriteAutoFormat()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteAutoFormat/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="pix">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteAutoFormat (String filename,
								Pix pix)
	{
		int RetObj = _All.pixWriteAutoFormat(filename, pix);
		return RetObj;
	}

	// writefile.c (392, 1)
	// pixWriteStream(fp, pix, format) as int
	// pixWriteStream(FILE *, PIX *, l_int32) as l_ok
	///  <summary>
	/// pixWriteStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="pix">[in] - </param>
	///  <param name="format">[in] - </param>
	///   <returns>0 if OK 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp,
							Pix pix,
							IFF format)
	{
		int RetObj = _All.pixWriteStream(fp, pix, format);
		return RetObj;
	}

	// writefile.c (484, 1)
	// pixWriteImpliedFormat(filename, pix, quality, progressive) as int
	// pixWriteImpliedFormat(const char *, PIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This determines the output format from the filename extension.<para/>
	///
	/// (2) The last two args are ignored except for requests for jpeg files.<para/>
	///
	/// (3) The jpeg default quality is 75.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteImpliedFormat/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="pix">[in] - </param>
	///  <param name="quality">[in] - iff JPEG 1 - 100, 0 for default</param>
	///  <param name="progressive">[in] - iff JPEG 0 for baseline seq., 1 for progressive</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteImpliedFormat (String filename,
								   Pix pix,
								   int quality,
								   int progressive)
	{
		int RetObj = _All.pixWriteImpliedFormat(filename, pix, quality, progressive);
		return RetObj;
	}

	// writefile.c (549, 1)
	// pixChooseOutputFormat(pix) as int
	// pixChooseOutputFormat(PIX *) as l_int32
	///  <summary>
	/// (1) This should only be called if the requested format is IFF_DEFAULT.<para/>
	///
	/// (2) If the pix wasn't read from a file, its input format value
	/// will be IFF_UNKNOWN, and in that case it is written out
	/// in a compressed but lossless format.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixChooseOutputFormat/*"/>
	///  <param name="pix">[in] - </param>
	///   <returns>output format, or 0 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ChooseOutputFormat (Pix pix)
	{
		int RetObj = _All.pixChooseOutputFormat(pix);
		return RetObj;
	}

	// writefile.c (625, 1)
	// pixGetAutoFormat(pix, pformat) as int
	// pixGetAutoFormat(PIX *, l_int32 *) as l_ok
	///  <summary>
	/// (1) The output formats are restricted to tiff, jpeg and png
	/// because these are the most commonly used image formats and
	/// the ones that are typically installed with leptonica.<para/>
	///
	/// (2) This decides what compression to use based on the pix.
	/// It chooses tiff-g4 if 1 bpp without a colormap, jpeg with
	/// quality 75 if grayscale, rgb or rgba (where it loses
	/// the alpha layer), and lossless png for all other situations.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixGetAutoFormat/*"/>
	///  <param name="pix">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetAutoFormat (Pix pix,
							  object pformat)
	{
		int RetObj = _All.pixGetAutoFormat(pix, pformat);
		return RetObj;
	}

	// writefile.c (701, 1)
	// pixWriteMem(pdata, psize, pix, format) as int
	// pixWriteMem(l_uint8 **, size_t *, PIX *, l_int32) as l_ok
	///  <summary>
	/// (1) On windows, this will only write tiff and PostScript to memory.
	/// For other formats, it requires open_memstream(3).<para/>
	///
	/// (2) PostScript output is uncompressed, in hex ascii.
	/// Most printers support level 2 compression (tiff_g4 for 1 bpp,
	/// jpeg for 8 and 32 bpp).<para/>
	///
	/// (3) The default jpeg quality is 75.  For some other value,
	/// Use l_jpegSetQuality().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixWriteMem/*"/>
	///  <param name="pdata">[out] - data of tiff compressed image</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="pix">[in] - </param>
	///  <param name="format">[in] - defined in imageio.h</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMem (out Byte[] pdata,
						 out uint psize,
						 Pix pix,
						 IFF format)
	{
		int RetObj = _All.pixWriteMem(out pdata, out psize, pix, format);
		return RetObj;
	}

	// writefile.c (877, 1)
	// pixDisplay(pixs, x, y) as int
	// pixDisplay(PIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is debugging code that displays an image on the screen.
	/// It uses a static internal variable to number the output files
	/// written by a single process.  Behavior with a shared library
	/// may be unpredictable.<para/>
	///
	/// (2) It does nothing unless LeptDebugOK == TRUE.<para/>
	///
	/// (3) It uses these programs to display the image:
	/// On Unix: xzgv, xli or xv
	/// On Windows: i_view
	/// The display program must be on your $PATH variable.  It is
	/// chosen by setting the global var_DISPLAY_PROG, using
	/// l_chooseDisplayProg().  Default on Unix is xzgv.<para/>
	///
	/// (4) Images with dimensions larger than MAX_DISPLAY_WIDTH or
	/// MAX_DISPLAY_HEIGHT are downscaled to fit those constraints.
	/// This is particularly important for displaying 1 bpp images
	/// with xv, because xv automatically downscales large images
	/// by subsampling, which looks poor.  For 1 bpp, we use
	/// scale-to-gray to get decent-looking anti-aliased images.
	/// In all cases, we write a temporary file to /tmp/lept/disp,
	/// that is read by the display program.<para/>
	///
	/// (5) The temporary file is written as png if, after initial
	/// processing for special cases, any of these obtain:
	/// pix dimensions are smaller than some thresholds
	/// pix depth is less than 8 bpp
	/// pix is colormapped<para/>
	///
	/// (6) For spp == 4, we call pixDisplayLayersRGBA() to show 3
	/// versions of the image: the image with a fully opaque
	/// alpha, the alpha, and the image as it would appear with
	/// a white background.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDisplay/*"/>
	///  <param name="x">[in] - location of display frame on the screen</param>
	///  <param name="y">[in] - location of display frame on the screen</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Display (int x,
						int y)
	{
		int RetObj = _All.pixDisplay(this, x, y);
		return RetObj;
	}

	// writefile.c (901, 1)
	// pixDisplayWithTitle(pixs, x, y, title, dispflag) as int
	// pixDisplayWithTitle(PIX *, l_int32, l_int32, const char *, l_int32) as l_ok
	///  <summary>
	/// (1) See notes for pixDisplay().<para/>
	///
	/// (2) This displays the image if dispflag == 1 otherwise it punts.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDisplayWithTitle/*"/>
	///  <param name="x">[in] - location of display frame</param>
	///  <param name="y">[in] - location of display frame</param>
	///  <param name="title">[in][optional] - on frame can be NULL</param>
	///  <param name="dispflag">[in] - 1 to write, else disabled</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int DisplayWithTitle (int x,
								 int y,
								 int dispflag,
								 String title)
	{
		int RetObj = _All.pixDisplayWithTitle(this, x, y, title, dispflag);
		return RetObj;
	}

	// writefile.c (1077, 1)
	// pixSaveTiled(pixs, pixa, scalefactor, newrow, space, dp) as int
	// pixSaveTiled(PIX *, PIXA *, l_float32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixSaveTiled()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSaveTiled/*"/>
	///  <param name="pixa">[in] - the pix are accumulated here</param>
	///  <param name="scalefactor">[in] - 0.0 to disable otherwise this is a scale factor</param>
	///  <param name="newrow">[in] - 0 if placed on the same row as previous 1 otherwise</param>
	///  <param name="space">[in] - horizontal and vertical spacing, in pixels</param>
	///  <param name="dp">[in] - depth of pixa 8 or 32 bpp only used on first call</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int SaveTiled (Pixa pixa,
						  Single scalefactor,
						  int newrow,
						  int space,
						  int dp)
	{
		int RetObj = _All.pixSaveTiled(this, pixa, scalefactor, newrow, space, dp);
		return RetObj;
	}

	// writefile.c (1128, 1)
	// pixSaveTiledOutline(pixs, pixa, scalefactor, newrow, space, linewidth, dp) as int
	// pixSaveTiledOutline(PIX *, PIXA *, l_float32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) Before calling this function for the first time, use
	/// pixaCreate() to make the %pixa that will accumulate the pix.
	/// This is passed in each time pixSaveTiled() is called.<para/>
	///
	/// (2) %scalefactor scales the input image.  After scaling and
	/// possible depth conversion, the image is saved in the input
	/// pixa, along with a box that specifies the location to
	/// place it when tiled later.  Disable saving the pix by
	/// setting %scalefactor == 0.0.<para/>
	///
	/// (3) %newrow and %space specify the location of the new pix
	/// with respect to the last one(s) that were entered.<para/>
	///
	/// (4) %dp specifies the depth at which all pix are saved.  It can
	/// be only 8 or 32 bpp.  Any colormap is removed.  This is only
	/// used at the first invocation.<para/>
	///
	/// (5) This function uses two variables from call to call.
	/// If they were static, the function would not be .so or thread
	/// safe, and furthermore, there would be interference with two or
	/// more pixa accumulating images at a time.  Consequently,
	/// we use the first pix in the pixa to store and obtain both
	/// the depth and the current position of the bottom (one pixel
	/// below the lowest image raster line when laid out using
	/// the boxa).  The bottom variable is stored in the input format
	/// field, which is the only field available for storing an int.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSaveTiledOutline/*"/>
	///  <param name="pixa">[in] - the pix are accumulated here</param>
	///  <param name="scalefactor">[in] - 0.0 to disable otherwise this is a scale factor</param>
	///  <param name="newrow">[in] - 0 if placed on the same row as previous 1 otherwise</param>
	///  <param name="space">[in] - horizontal and vertical spacing, in pixels</param>
	///  <param name="linewidth">[in] - width of added outline for image 0 for no outline</param>
	///  <param name="dp">[in] - depth of pixa 8 or 32 bpp only used on first call</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int SaveTiledOutline (Pixa pixa,
								 Single scalefactor,
								 int newrow,
								 int space,
								 int linewidth,
								 int dp)
	{
		int RetObj = _All.pixSaveTiledOutline(this, pixa, scalefactor, newrow, space, linewidth, dp);
		return RetObj;
	}

	// writefile.c (1258, 1)
	// pixSaveTiledWithText(pixs, pixa, outwidth, newrow, space, linewidth, bmf, textstr, val, location) as int
	// pixSaveTiledWithText(PIX *, PIXA *, l_int32, l_int32, l_int32, l_int32, L_BMF *, const char *, l_uint32, l_int32) as l_ok
	///  <summary>
	/// (1) Before calling this function for the first time, use
	/// pixaCreate() to make the %pixa that will accumulate the pix.
	/// This is passed in each time pixSaveTiled() is called.<para/>
	///
	/// (2) %outwidth is the scaled width.  After scaling, the image is
	/// saved in the input pixa, along with a box that specifies
	/// the location to place it when tiled later.  Disable saving
	/// the pix by setting %outwidth == 0.<para/>
	///
	/// (3) %newrow and %space specify the location of the new pix
	/// with respect to the last one(s) that were entered.<para/>
	///
	/// (4) All pix are saved as 32 bpp RGB.<para/>
	///
	/// (5) If both %bmf and %textstr are defined, this generates a pix
	/// with the additional text otherwise, no text is written.<para/>
	///
	/// (6) The text is written before scaling, so it is properly
	/// antialiased in the scaled pix.  However, if the pix on
	/// different calls have different widths, the size of the
	/// text will vary.<para/>
	///
	/// (7) See pixSaveTiledOutline() for other implementation details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixSaveTiledWithText/*"/>
	///  <param name="pixa">[in] - the pix are accumulated here as 32 bpp</param>
	///  <param name="outwidth">[in] - in pixels use 0 to disable entirely</param>
	///  <param name="newrow">[in] - 1 to start a new row 0 to go on same row as previous</param>
	///  <param name="space">[in] - horizontal and vertical spacing, in pixels</param>
	///  <param name="linewidth">[in] - width of added outline for image 0 for no outline</param>
	///  <param name="bmf">[in][optional] - font struct</param>
	///  <param name="textstr">[in][optional] - text string to be added</param>
	///  <param name="val">[in] - color to set the text</param>
	///  <param name="location">[in] - L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int SaveTiledWithText (Pixa pixa,
								  int outwidth,
								  int newrow,
								  int space,
								  int linewidth,
								  uint val,
								  int location,
								  L_Bmf bmf,
								  String textstr)
	{
		int RetObj = _All.pixSaveTiledWithText(this, pixa, outwidth, newrow, space, linewidth, bmf, textstr, val, location);
		return RetObj;
	}

	// writefile.c (1347, 1)
	// pixDisplayWrite(pixs, reduction) as int
	// pixDisplayWrite(PIX *, l_int32) as l_ok
	///  <summary>
	/// (0) Deprecated.<para/>
	///
	/// (1) This is a simple interface for writing a set of files.<para/>
	///
	/// (2) This uses jpeg output for pix that are 32 bpp or 8 bpp
	/// without a colormap otherwise, it uses png.<para/>
	///
	/// (3) To erase any previously written files in the output directory:
	/// pixDisplayWrite(NULL, -1)<para/>
	///
	/// (4) If reduction  is greater  1 and depth == 1, this does a scale-to-gray
	/// reduction.<para/>
	///
	/// (5) This function uses a static internal variable to number
	/// output files written by a single process.  Behavior
	/// with a shared library may be unpredictable.<para/>
	///
	/// (6) For 16 bpp, this displays the full dynamic range with log scale.
	/// Alternative image transforms to generate 8 bpp pix are:
	/// pix8 = pixMaxDynamicRange(pixt, L_LINEAR_SCALE)
	/// pix8 = pixConvert16To8(pixt, 0)  // low order byte
	/// pix8 = pixConvert16To8(pixt, 1)  // high order byte
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixDisplayWrite/*"/>
	///  <param name="reduction">[in] - -1 to reset/erase 0 to disable otherwise this is a reduction factor</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int DisplayWrite (int reduction)
	{
		int RetObj = _All.pixDisplayWrite(this, reduction);
		return RetObj;
	}


}
public partial class PixColormap
{
	// colormap.c (110, 1)
	// pixcmapCreate(depth) as PixColormap
	// pixcmapCreate(l_int32) as PIXCMAP *
	///  <summary>
	/// pixcmapCreate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapCreate/*"/>
	///  <param name="depth">[in] - bpp, of pix</param>
	// CreateAdditiveFunction: Constructor
	public PixColormap (int depth)
	{
		PixColormap RetObj = _All.pixcmapCreate(depth);
		Pointer = RetObj.Pointer;
	}

	// colormap.c (157, 1)
	// pixcmapCreateRandom(depth, hasblack, haswhite) as PixColormap
	// pixcmapCreateRandom(l_int32, l_int32, l_int32) as PIXCMAP *
	///  <summary>
	/// (1) This sets up a colormap with random colors,
	/// where the first color is optionally black, the last color
	/// is optionally white, and the remaining colors are
	/// chosen randomly.<para/>
	///
	/// (2) The number of randomly chosen colors is:
	/// 2^(depth) - haswhite - hasblack<para/>
	///
	/// (3) Because rand() is seeded, it might disrupt otherwise
	/// deterministic results if also used elsewhere in a program.<para/>
	///
	/// (4) rand() is not threadsafe, and will generate garbage if run
	/// on multiple threads at once -- though garbage is generally
	/// what you want from a random number generator!<para/>
	///
	/// (5) Modern rand()s have equal randomness in low and high order
	/// bits, but older ones don't.  Here, we're just using rand()
	/// to choose colors for output.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapCreateRandom/*"/>
	///  <param name="depth">[in] - bpp, of pix 2, 4 or 8</param>
	///  <param name="hasblack">[in] - 1 if the first color is black 0 if no black</param>
	///  <param name="haswhite">[in] - 1 if the last color is white 0 if no white</param>
	///   <returns>cmap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public PixColormap CreateRandom (int depth,
									 int hasblack,
									 int haswhite)
	{
		PixColormap RetObj = _All.pixcmapCreateRandom(depth, hasblack, haswhite);
		return RetObj;
	}

	// colormap.c (203, 1)
	// pixcmapCreateLinear(d, nlevels) as PixColormap
	// pixcmapCreateLinear(l_int32, l_int32) as PIXCMAP *
	///  <summary>
	/// (1) Colormap has equally spaced gray color values
	/// from black (0, 0, 0) to white (255, 255, 255).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapCreateLinear/*"/>
	///  <param name="d">[in] - depth of pix for this colormap 1, 2, 4 or 8</param>
	///  <param name="nlevels">[in] - valid in range [2, 2^d]</param>
	///   <returns>cmap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public PixColormap CreateLinear (int d,
									 int nlevels)
	{
		PixColormap RetObj = _All.pixcmapCreateLinear(d, nlevels);
		return RetObj;
	}

	// colormap.c (233, 1)
	// pixcmapCopy(cmaps) as PixColormap
	// pixcmapCopy(PIXCMAP *) as PIXCMAP *
	///  <summary>
	/// pixcmapCopy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapCopy/*"/>
	///  <param name="cmaps">[in] - </param>
	///   <returns>cmapd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public PixColormap Copy (PixColormap cmaps)
	{
		PixColormap RetObj = _All.pixcmapCopy(cmaps);
		return RetObj;
	}

	// colormap.c (263, 1)
	// pixcmapDestroy(pcmap) as Object
	// pixcmapDestroy(PIXCMAP **) as void
	///  <summary>
	/// pixcmapDestroy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapDestroy/*"/>
	///  <param name="pcmap">[in,out] - set to null</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref PixColormap pcmap)
	{
		_All.pixcmapDestroy(ref pcmap);
	}

	// colormap.c (299, 1)
	// pixcmapAddColor(cmap, rval, gval, bval) as int
	// pixcmapAddColor(PIXCMAP *, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This always adds the color if there is room.<para/>
	///
	/// (2) The alpha component is 255 (opaque)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapAddColor/*"/>
	///  <param name="rval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="gval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="bval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddColor (int rval,
						 int gval,
						 int bval)
	{
		int RetObj = _All.pixcmapAddColor(this, rval, gval, bval);
		return RetObj;
	}

	// colormap.c (337, 1)
	// pixcmapAddRGBA(cmap, rval, gval, bval, aval) as int
	// pixcmapAddRGBA(PIXCMAP *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This always adds the color if there is room.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapAddRGBA/*"/>
	///  <param name="rval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="gval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="bval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="aval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddRGBA (int rval,
						int gval,
						int bval,
						int aval)
	{
		int RetObj = _All.pixcmapAddRGBA(this, rval, gval, bval, aval);
		return RetObj;
	}

	// colormap.c (381, 1)
	// pixcmapAddNewColor(cmap, rval, gval, bval, pindex) as int
	// pixcmapAddNewColor(PIXCMAP *, l_int32, l_int32, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) This only adds color if not already there.<para/>
	///
	/// (2) The alpha component is 255 (opaque)<para/>
	///
	/// (3) This returns the index of the new (or existing) color.<para/>
	///
	/// (4) Returns 2 with a warning if unable to add this color
	/// the caller should check the return value.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapAddNewColor/*"/>
	///  <param name="rval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="gval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="bval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="pindex">[out] - index of color</param>
	///   <returns>0 if OK, 1 on error 2 if unable to add color</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddNewColor (int rval,
							int gval,
							int bval,
							out int pindex)
	{
		int RetObj = _All.pixcmapAddNewColor(this, rval, gval, bval, out pindex);
		return RetObj;
	}

	// colormap.c (430, 1)
	// pixcmapAddNearestColor(cmap, rval, gval, bval, pindex) as int
	// pixcmapAddNearestColor(PIXCMAP *, l_int32, l_int32, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) This only adds color if not already there.<para/>
	///
	/// (2) The alpha component is 255 (opaque)<para/>
	///
	/// (3) If it's not in the colormap and there is no room to add
	/// another color, this returns the index of the nearest color.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapAddNearestColor/*"/>
	///  <param name="rval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="gval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="bval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="pindex">[out] - index of color</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddNearestColor (int rval,
								int gval,
								int bval,
								out int pindex)
	{
		int RetObj = _All.pixcmapAddNearestColor(this, rval, gval, bval, out pindex);
		return RetObj;
	}

	// colormap.c (477, 1)
	// pixcmapUsableColor(cmap, rval, gval, bval, pusable) as int
	// pixcmapUsableColor(PIXCMAP *, l_int32, l_int32, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) This checks if the color already exists or if there is
	/// room to add it.  It makes no change in the colormap.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapUsableColor/*"/>
	///  <param name="rval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="gval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="bval">[in] - colormap entry to be added each number is in range [0, ... 255]</param>
	///  <param name="pusable">[out] - 1 if usable 0 if not</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int UsableColor (int rval,
							int gval,
							int bval,
							out int pusable)
	{
		int RetObj = _All.pixcmapUsableColor(this, rval, gval, bval, out pusable);
		return RetObj;
	}

	// colormap.c (524, 1)
	// pixcmapAddBlackOrWhite(cmap, color, pindex) as int
	// pixcmapAddBlackOrWhite(PIXCMAP *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) This only adds color if not already there.<para/>
	///
	/// (2) The alpha component is 255 (opaque)<para/>
	///
	/// (3) This sets index to the requested color.<para/>
	///
	/// (4) If there is no room in the colormap, returns the index
	/// of the closest color.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapAddBlackOrWhite/*"/>
	///  <param name="color">[in] - 0 for black, 1 for white</param>
	///  <param name="pindex">[out][optional] - index of color can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddBlackOrWhite (int color,
								out int pindex)
	{
		int RetObj = _All.pixcmapAddBlackOrWhite(this, color, out pindex);
		return RetObj;
	}

	// colormap.c (563, 1)
	// pixcmapSetBlackAndWhite(cmap, setblack, setwhite) as int
	// pixcmapSetBlackAndWhite(PIXCMAP *, l_int32, l_int32) as l_ok
	///  <summary>
	/// pixcmapSetBlackAndWhite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapSetBlackAndWhite/*"/>
	///  <param name="setblack">[in] - 0 for no operation 1 to set darkest color to black</param>
	///  <param name="setwhite">[in] - 0 for no operation 1 to set lightest color to white</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetBlackAndWhite (int setblack,
								 int setwhite)
	{
		int RetObj = _All.pixcmapSetBlackAndWhite(this, setblack, setwhite);
		return RetObj;
	}

	// colormap.c (593, 1)
	// pixcmapGetCount(cmap) as int
	// pixcmapGetCount(PIXCMAP *) as l_int32
	///  <summary>
	/// pixcmapGetCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetCount/*"/>
	///   <returns>count, or 0 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCount ()
	{
		int RetObj = _All.pixcmapGetCount(this);
		return RetObj;
	}

	// colormap.c (610, 1)
	// pixcmapGetFreeCount(cmap) as int
	// pixcmapGetFreeCount(PIXCMAP *) as l_int32
	///  <summary>
	/// pixcmapGetFreeCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetFreeCount/*"/>
	///   <returns>free entries, or 0 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetFreeCount ()
	{
		int RetObj = _All.pixcmapGetFreeCount(this);
		return RetObj;
	}

	// colormap.c (627, 1)
	// pixcmapGetDepth(cmap) as int
	// pixcmapGetDepth(PIXCMAP *) as l_int32
	///  <summary>
	/// pixcmapGetDepth()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetDepth/*"/>
	///   <returns>depth, or 0 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetDepth ()
	{
		int RetObj = _All.pixcmapGetDepth(this);
		return RetObj;
	}

	// colormap.c (650, 1)
	// pixcmapGetMinDepth(cmap, pmindepth) as int
	// pixcmapGetMinDepth(PIXCMAP *, l_int32 *) as l_ok
	///  <summary>
	/// (1) On error, [and]mindepth is returned as 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetMinDepth/*"/>
	///  <param name="pmindepth">[out] - minimum depth to support the colormap</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMinDepth (out int pmindepth)
	{
		int RetObj = _All.pixcmapGetMinDepth(this, out pmindepth);
		return RetObj;
	}

	// colormap.c (686, 1)
	// pixcmapClear(cmap) as int
	// pixcmapClear(PIXCMAP *) as l_ok
	///  <summary>
	/// (1) This removes the colors by setting the count to 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapClear/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Clear ()
	{
		int RetObj = _All.pixcmapClear(this);
		return RetObj;
	}

	// colormap.c (709, 1)
	// pixcmapGetColor(cmap, index, prval, pgval, pbval) as int
	// pixcmapGetColor(PIXCMAP *, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixcmapGetColor()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetColor/*"/>
	///  <param name="index">[in] - </param>
	///  <param name="prval">[out] - each color value</param>
	///  <param name="pgval">[out] - each color value</param>
	///  <param name="pbval">[out] - each color value</param>
	///   <returns>0 if OK, 1 if not accessible caller should check</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetColor (int index,
						 out int prval,
						 out int pgval,
						 out int pbval)
	{
		int RetObj = _All.pixcmapGetColor(this, index, out prval, out pgval, out pbval);
		return RetObj;
	}

	// colormap.c (749, 1)
	// pixcmapGetColor32(cmap, index, pval32) as int
	// pixcmapGetColor32(PIXCMAP *, l_int32, l_uint32 *) as l_ok
	///  <summary>
	/// (1) The returned alpha channel value is 255.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetColor32/*"/>
	///  <param name="index">[in] - </param>
	///  <param name="pval32">[out] - 32-bit rgb color value</param>
	///   <returns>0 if OK, 1 if not accessible caller should check</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetColor32 (int index,
						   out uint pval32)
	{
		int RetObj = _All.pixcmapGetColor32(this, index, out pval32);
		return RetObj;
	}

	// colormap.c (777, 1)
	// pixcmapGetRGBA(cmap, index, prval, pgval, pbval, paval) as int
	// pixcmapGetRGBA(PIXCMAP *, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixcmapGetRGBA()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetRGBA/*"/>
	///  <param name="index">[in] - </param>
	///  <param name="prval">[out] - each color value</param>
	///  <param name="pgval">[out] - each color value</param>
	///  <param name="pbval">[out] - each color value</param>
	///  <param name="paval">[out] - each color value</param>
	///   <returns>0 if OK, 1 if not accessible caller should check</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRGBA (int index,
						out int prval,
						out int pgval,
						out int pbval,
						out int paval)
	{
		int RetObj = _All.pixcmapGetRGBA(this, index, out prval, out pgval, out pbval, out paval);
		return RetObj;
	}

	// colormap.c (815, 1)
	// pixcmapGetRGBA32(cmap, index, pval32) as int
	// pixcmapGetRGBA32(PIXCMAP *, l_int32, l_uint32 *) as l_ok
	///  <summary>
	/// pixcmapGetRGBA32()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetRGBA32/*"/>
	///  <param name="index">[in] - </param>
	///  <param name="pval32">[out] - 32-bit rgba color value</param>
	///   <returns>0 if OK, 1 if not accessible caller should check</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRGBA32 (int index,
						  out uint pval32)
	{
		int RetObj = _All.pixcmapGetRGBA32(this, index, out pval32);
		return RetObj;
	}

	// colormap.c (851, 1)
	// pixcmapResetColor(cmap, index, rval, gval, bval) as int
	// pixcmapResetColor(PIXCMAP *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This resets sets the color of an entry that has already
	/// been set and included in the count of colors.<para/>
	///
	/// (2) The alpha component is 255 (opaque)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapResetColor/*"/>
	///  <param name="index">[in] - </param>
	///  <param name="rval">[in] - colormap entry to be reset each number is in range [0, ... 255]</param>
	///  <param name="gval">[in] - colormap entry to be reset each number is in range [0, ... 255]</param>
	///  <param name="bval">[in] - colormap entry to be reset each number is in range [0, ... 255]</param>
	///   <returns>0 if OK, 1 if not accessible caller should check</returns>
	// CreateAdditiveFunction: Function/Else
	public int ResetColor (int index,
						   int rval,
						   int gval,
						   int bval)
	{
		int RetObj = _All.pixcmapResetColor(this, index, rval, gval, bval);
		return RetObj;
	}

	// colormap.c (892, 1)
	// pixcmapSetAlpha(cmap, index, aval) as int
	// pixcmapSetAlpha(PIXCMAP *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This modifies the transparency of one entry in a colormap.
	/// The alpha component by default is 255 (opaque).
	/// This is used when extracting the colormap from a PNG file
	/// without decoding the image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapSetAlpha/*"/>
	///  <param name="index">[in] - </param>
	///  <param name="aval">[in] - in range [0, ... 255]</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetAlpha (int index,
						 int aval)
	{
		int RetObj = _All.pixcmapSetAlpha(this, index, aval);
		return RetObj;
	}

	// colormap.c (921, 1)
	// pixcmapGetIndex(cmap, rval, gval, bval, pindex) as int
	// pixcmapGetIndex(PIXCMAP *, l_int32, l_int32, l_int32, l_int32 *) as l_int32
	///  <summary>
	/// pixcmapGetIndex()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetIndex/*"/>
	///  <param name="rval">[in] - colormap colors to search for each number is in range [0, ... 255]</param>
	///  <param name="gval">[in] - colormap colors to search for each number is in range [0, ... 255]</param>
	///  <param name="bval">[in] - colormap colors to search for each number is in range [0, ... 255]</param>
	///  <param name="pindex">[out] - found index</param>
	///   <returns>0 if found, 1 if not found caller must check</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetIndex (int rval,
						 int gval,
						 int bval,
						 out int pindex)
	{
		int RetObj = _All.pixcmapGetIndex(this, rval, gval, bval, out pindex);
		return RetObj;
	}

	// colormap.c (960, 1)
	// pixcmapHasColor(cmap, pcolor) as int
	// pixcmapHasColor(PIXCMAP *, l_int32 *) as l_ok
	///  <summary>
	/// pixcmapHasColor()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapHasColor/*"/>
	///  <param name="pcolor">[out] - TRUE if cmap has color FALSE otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int HasColor (out int pcolor)
	{
		int RetObj = _All.pixcmapHasColor(this, out pcolor);
		return RetObj;
	}

	// colormap.c (999, 1)
	// pixcmapIsOpaque(cmap, popaque) as int
	// pixcmapIsOpaque(PIXCMAP *, l_int32 *) as l_ok
	///  <summary>
	/// pixcmapIsOpaque()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapIsOpaque/*"/>
	///  <param name="popaque">[out] - TRUE if fully opaque: all entries are 255</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int IsOpaque (out int popaque)
	{
		int RetObj = _All.pixcmapIsOpaque(this, out popaque);
		return RetObj;
	}

	// colormap.c (1034, 1)
	// pixcmapIsBlackAndWhite(cmap, pblackwhite) as int
	// pixcmapIsBlackAndWhite(PIXCMAP *, l_int32 *) as l_ok
	///  <summary>
	/// pixcmapIsBlackAndWhite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapIsBlackAndWhite/*"/>
	///  <param name="pblackwhite">[out] - TRUE if the cmap has only two colors: black (0,0,0) and white (255,255,255)</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int IsBlackAndWhite (out int pblackwhite)
	{
		int RetObj = _All.pixcmapIsBlackAndWhite(this, out pblackwhite);
		return RetObj;
	}

	// colormap.c (1075, 1)
	// pixcmapCountGrayColors(cmap, pngray) as int
	// pixcmapCountGrayColors(PIXCMAP *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This counts the unique gray colors, including black and white.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapCountGrayColors/*"/>
	///  <param name="pngray">[out] - number of gray colors</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CountGrayColors (out int pngray)
	{
		int RetObj = _All.pixcmapCountGrayColors(this, out pngray);
		return RetObj;
	}

	// colormap.c (1116, 1)
	// pixcmapGetRankIntensity(cmap, rankval, pindex) as int
	// pixcmapGetRankIntensity(PIXCMAP *, l_float32, l_int32 *) as l_ok
	///  <summary>
	/// pixcmapGetRankIntensity()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetRankIntensity/*"/>
	///  <param name="rankval">[in] - 0.0 for darkest, 1.0 for lightest color</param>
	///  <param name="pindex">[out] - the index into the colormap that corresponds to the rank intensity color</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRankIntensity (Single rankval,
								 out int pindex)
	{
		int RetObj = _All.pixcmapGetRankIntensity(this, rankval, out pindex);
		return RetObj;
	}

	// colormap.c (1167, 1)
	// pixcmapGetNearestIndex(cmap, rval, gval, bval, pindex) as int
	// pixcmapGetNearestIndex(PIXCMAP *, l_int32, l_int32, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) Returns the index of the exact color if possible, otherwise the
	/// index of the color closest to the target color.<para/>
	///
	/// (2) Nearest color is that which is the least sum-of-squares distance
	/// from the target color.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetNearestIndex/*"/>
	///  <param name="rval">[in] - colormap colors to search for each number is in range [0, ... 255]</param>
	///  <param name="gval">[in] - colormap colors to search for each number is in range [0, ... 255]</param>
	///  <param name="bval">[in] - colormap colors to search for each number is in range [0, ... 255]</param>
	///  <param name="pindex">[out] - the index of the nearest color</param>
	///   <returns>0 if OK, 1 on error caller must check</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetNearestIndex (int rval,
								int gval,
								int bval,
								out int pindex)
	{
		int RetObj = _All.pixcmapGetNearestIndex(this, rval, gval, bval, out pindex);
		return RetObj;
	}

	// colormap.c (1225, 1)
	// pixcmapGetNearestGrayIndex(cmap, val, pindex) as int
	// pixcmapGetNearestGrayIndex(PIXCMAP *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) This should be used on gray colormaps.  It uses only the
	/// green value of the colormap.<para/>
	///
	/// (2) Returns the index of the exact color if possible, otherwise the
	/// index of the color closest to the target color.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetNearestGrayIndex/*"/>
	///  <param name="val">[in] - gray value to search for in range [0, ... 255]</param>
	///  <param name="pindex">[out] - the index of the nearest color</param>
	///   <returns>0 if OK, 1 on error caller must check</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetNearestGrayIndex (int val,
									out int pindex)
	{
		int RetObj = _All.pixcmapGetNearestGrayIndex(this, val, out pindex);
		return RetObj;
	}

	// colormap.c (1278, 1)
	// pixcmapGetDistanceToColor(cmap, index, rval, gval, bval, pdist) as int
	// pixcmapGetDistanceToColor(PIXCMAP *, l_int32, l_int32, l_int32, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) Returns the L2 distance (squared) between the color at index i
	/// and the target color.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetDistanceToColor/*"/>
	///  <param name="index">[in] - </param>
	///  <param name="rval">[in] - target color</param>
	///  <param name="gval">[in] - target color</param>
	///  <param name="bval">[in] - target color</param>
	///  <param name="pdist">[out] - the distance from the cmap entry to target</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetDistanceToColor (int index,
								   int rval,
								   int gval,
								   int bval,
								   out int pdist)
	{
		int RetObj = _All.pixcmapGetDistanceToColor(this, index, rval, gval, bval, out pdist);
		return RetObj;
	}

	// colormap.c (1334, 1)
	// pixcmapGetRangeValues(cmap, select, pminval, pmaxval, pminindex, pmaxindex) as int
	// pixcmapGetRangeValues(PIXCMAP *, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) Returns, for selected components (or the average), the
	/// the extreme values (min and/or max) and their indices
	/// that are found in the cmap.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGetRangeValues/*"/>
	///  <param name="pminval">[out][optional] - minimum value of component</param>
	///  <param name="pmaxval">[out][optional] - maximum value of component</param>
	///  <param name="pminindex">[out][optional] - index of minimum value</param>
	///  <param name="pmaxindex">[out][optional] - index of maximum value</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRangeValues (int _select_,
							   out int pminval,
							   out int pmaxval,
							   out int pminindex,
							   out int pmaxindex)
	{
		int RetObj = _All.pixcmapGetRangeValues(this, _select_, out pminval, out pmaxval, out pminindex, out pmaxindex);
		return RetObj;
	}

	// colormap.c (1430, 1)
	// pixcmapGrayToColor(color) as PixColormap
	// pixcmapGrayToColor(l_uint32) as PIXCMAP *
	///  <summary>
	/// (1) This creates a colormap that maps from gray to
	/// a specific color.  In the mapping, each component
	/// is faded to white, depending on the gray value.<para/>
	///
	/// (2) In use, this is simply attached to a grayscale pix
	/// to give it the input color.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGrayToColor/*"/>
	///  <param name="color">[in] - </param>
	///   <returns>cmap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public PixColormap GrayToColor (uint color)
	{
		PixColormap RetObj = _All.pixcmapGrayToColor(color);
		return RetObj;
	}

	// colormap.c (1462, 1)
	// pixcmapColorToGray(cmaps, rwt, gwt, bwt) as PixColormap
	// pixcmapColorToGray(PIXCMAP *, l_float32, l_float32, l_float32) as PIXCMAP *
	///  <summary>
	/// (1) This creates a gray colormap from an arbitrary colormap.<para/>
	///
	/// (2) In use, attach the output gray colormap to the pix
	/// (or a copy of it) that provided the input colormap.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapColorToGray/*"/>
	///  <param name="cmaps">[in] - </param>
	///  <param name="rwt">[in] - non-negative these should add to 1.0</param>
	///  <param name="gwt">[in] - non-negative these should add to 1.0</param>
	///  <param name="bwt">[in] - non-negative these should add to 1.0</param>
	///   <returns>cmap gray, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public PixColormap ColorToGray (PixColormap cmaps,
									Single rwt,
									Single gwt,
									Single bwt)
	{
		PixColormap RetObj = _All.pixcmapColorToGray(cmaps, rwt, gwt, bwt);
		return RetObj;
	}

	// colormap.c (1518, 1)
	// pixcmapConvertTo4(cmaps) as PixColormap
	// pixcmapConvertTo4(PIXCMAP *) as PIXCMAP *
	///  <summary>
	/// (1) This converts a 2 bpp colormap to 4 bpp.  The colors
	/// are the same the output colormap entry array has size 16.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapConvertTo4/*"/>
	///  <param name="cmaps">[in] - colormap for 2 bpp pix</param>
	///   <returns>cmapd   (4 bpp)</returns>
	// CreateAdditiveFunction: Function/Else
	public PixColormap ConvertTo4 (PixColormap cmaps)
	{
		PixColormap RetObj = _All.pixcmapConvertTo4(cmaps);
		return RetObj;
	}

	// colormap.c (1553, 1)
	// pixcmapConvertTo8(cmaps) as PixColormap
	// pixcmapConvertTo8(PIXCMAP *) as PIXCMAP *
	///  <summary>
	/// (1) This converts a 2 bpp or 4 bpp colormap to 8 bpp.  The colors
	/// are the same the output colormap entry array has size 256.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapConvertTo8/*"/>
	///  <param name="cmaps">[in] - colormap for 2 bpp or 4 bpp pix</param>
	///   <returns>cmapd   (8 bpp)</returns>
	// CreateAdditiveFunction: Function/Else
	public PixColormap ConvertTo8 (PixColormap cmaps)
	{
		PixColormap RetObj = _All.pixcmapConvertTo8(cmaps);
		return RetObj;
	}

	// colormap.c (1587, 1)
	// pixcmapRead(filename) as PixColormap
	// pixcmapRead(const char *) as PIXCMAP *
	///  <summary>
	/// pixcmapRead()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapRead/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>cmap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public PixColormap Read (String filename)
	{
		PixColormap RetObj = _All.pixcmapRead(filename);
		return RetObj;
	}

	// colormap.c (1614, 1)
	// pixcmapReadStream(fp) as PixColormap
	// pixcmapReadStream(FILE *) as PIXCMAP *
	///  <summary>
	/// pixcmapReadStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>cmap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public PixColormap ReadStream (FILE fp)
	{
		PixColormap RetObj = _All.pixcmapReadStream(fp);
		return RetObj;
	}

	// colormap.c (1655, 1)
	// pixcmapReadMem(data, size) as PixColormap
	// pixcmapReadMem(const l_uint8 *, size_t) as PIXCMAP *
	///  <summary>
	/// pixcmapReadMem()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapReadMem/*"/>
	///  <param name="data">[in] - serialization of pixcmap in ascii</param>
	///  <param name="size">[in] - of data in bytes can use strlen to get it</param>
	///   <returns>cmap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public PixColormap ReadMem (Byte[] data,
								uint size)
	{
		PixColormap RetObj = _All.pixcmapReadMem(data, size);
		return RetObj;
	}

	// colormap.c (1683, 1)
	// pixcmapWrite(filename, cmap) as int
	// pixcmapWrite(const char *, PIXCMAP *) as l_ok
	///  <summary>
	/// pixcmapWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapWrite/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String filename)
	{
		int RetObj = _All.pixcmapWrite(filename, this);
		return RetObj;
	}

	// colormap.c (1715, 1)
	// pixcmapWriteStream(fp, cmap) as int
	// pixcmapWriteStream(FILE *, PIXCMAP *) as l_ok
	///  <summary>
	/// pixcmapWriteStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapWriteStream/*"/>
	///  <param name="fp">[in] - file stream    \param[in]    cmap</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp)
	{
		int RetObj = _All.pixcmapWriteStream(fp, this);
		return RetObj;
	}

	// colormap.c (1761, 1)
	// pixcmapWriteMem(pdata, psize, cmap) as int
	// pixcmapWriteMem(l_uint8 **, size_t *, PIXCMAP *) as l_ok
	///  <summary>
	/// (1) Serializes a pixcmap in memory and puts the result in a buffer.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapWriteMem/*"/>
	///  <param name="pdata">[out] - data of serialized pixcmap ascii</param>
	///  <param name="psize">[out] - size of returned data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMem (out Byte[] pdata,
						 out uint psize)
	{
		int RetObj = _All.pixcmapWriteMem(out pdata, out psize, this);
		return RetObj;
	}

	// colormap.c (1813, 1)
	// pixcmapToArrays(cmap, prmap, pgmap, pbmap, pamap) as int
	// pixcmapToArrays(PIXCMAP *, l_int32 **, l_int32 **, l_int32 **, l_int32 **) as l_ok
	///  <summary>
	/// pixcmapToArrays()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapToArrays/*"/>
	///  <param name="prmap">[out] - colormap arrays</param>
	///  <param name="pgmap">[out] - colormap arrays</param>
	///  <param name="pbmap">[out] - colormap arrays</param>
	///  <param name="pamap">[out][optional] - alpha array</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ToArrays (out List<int[]> prmap,
						 out List<int[]> pgmap,
						 out List<int[]> pbmap,
						 out List<int[]> pamap)
	{
		int RetObj = _All.pixcmapToArrays(this, out prmap, out pgmap, out pbmap, out pamap);
		return RetObj;
	}

	// colormap.c (1867, 1)
	// pixcmapToRGBTable(cmap, ptab, pncolors) as int
	// pixcmapToRGBTable(PIXCMAP *, l_uint32 **, l_int32 *) as l_ok
	///  <summary>
	/// pixcmapToRGBTable()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapToRGBTable/*"/>
	///  <param name="ptab">[out] - table of rgba values for the colormap</param>
	///  <param name="pncolors">[out][optional] - size of table</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ToRGBTable (out Byte[] ptab,
						   out int pncolors)
	{
		int RetObj = _All.pixcmapToRGBTable(this, out ptab, out pncolors);
		return RetObj;
	}

	// colormap.c (1912, 1)
	// pixcmapSerializeToMemory(cmap, cpc, pncolors, pdata) as int
	// pixcmapSerializeToMemory(PIXCMAP *, l_int32, l_int32 *, l_uint8 **) as l_ok
	///  <summary>
	/// (1) When serializing to store in a pdf, use %cpc = 3.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapSerializeToMemory/*"/>
	///  <param name="cpc">[in] - components/color: 3 for rgb, 4 for rgba</param>
	///  <param name="pncolors">[out] - number of colors in table</param>
	///  <param name="pdata">[out] - binary string, cpc bytes per color</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SerializeToMemory (int cpc,
								  out int pncolors,
								  out Byte[] pdata)
	{
		int RetObj = _All.pixcmapSerializeToMemory(this, cpc, out pncolors, out pdata);
		return RetObj;
	}

	// colormap.c (1960, 1)
	// pixcmapDeserializeFromMemory(data, cpc, ncolors) as PixColormap
	// pixcmapDeserializeFromMemory(l_uint8 *, l_int32, l_int32) as PIXCMAP *
	///  <summary>
	/// pixcmapDeserializeFromMemory()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapDeserializeFromMemory/*"/>
	///  <param name="data">[in] - binary string, 3 or 4 bytes per color</param>
	///  <param name="cpc">[in] - components/color: 3 for rgb, 4 for rgba</param>
	///  <param name="ncolors">[in] - </param>
	///   <returns>cmap, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public PixColormap DeserializeFromMemory (Byte[] data,
											  int cpc,
											  int ncolors)
	{
		PixColormap RetObj = _All.pixcmapDeserializeFromMemory(data, cpc, ncolors);
		return RetObj;
	}

	// colormap.c (2021, 1)
	// pixcmapConvertToHex(data, ncolors) as String
	// pixcmapConvertToHex(l_uint8 *, l_int32) as char *
	///  <summary>
	/// (1) The number of bytes in %data is 3  ncolors.<para/>
	///
	/// (2) Output is in form:
	///  is smaller r0g0b0 r1g1b1 ... rngnbn  is greater
	/// where r0, g0, b0 ... are each 2 bytes of hex ascii<para/>
	///
	/// (3) This is used in pdf files to express the colormap as an
	/// array in ascii (human-readable) format.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapConvertToHex/*"/>
	///  <param name="data">[in] - binary serialized data</param>
	///  <param name="ncolors">[in] - in colormap</param>
	///   <returns>hexdata bracketed, space-separated ascii hex string, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public String ConvertToHex (Byte[] data,
								int ncolors)
	{
		String RetObj = _All.pixcmapConvertToHex(data, ncolors);
		return RetObj;
	}

	// colormap.c (2079, 1)
	// pixcmapGammaTRC(cmap, gamma, minval, maxval) as int
	// pixcmapGammaTRC(PIXCMAP *, l_float32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is an in-place transform<para/>
	///
	/// (2) See pixGammaTRC() and numaGammaTRC() in enhance.c
	/// for description and use of transform
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapGammaTRC/*"/>
	///  <param name="gamma">[in] - gamma correction must be  is greater  0.0</param>
	///  <param name="minval">[in] - input value that gives 0 for output can be  is smaller 0</param>
	///  <param name="maxval">[in] - input value that gives 255 for output can be  is greater  255</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GammaTRC (Single gamma,
						 int minval,
						 int maxval)
	{
		int RetObj = _All.pixcmapGammaTRC(this, gamma, minval, maxval);
		return RetObj;
	}

	// colormap.c (2134, 1)
	// pixcmapContrastTRC(cmap, factor) as int
	// pixcmapContrastTRC(PIXCMAP *, l_float32) as l_ok
	///  <summary>
	/// (1) This is an in-place transform<para/>
	///
	/// (2) See pixContrastTRC() and numaContrastTRC() in enhance.c
	/// for description and use of transform
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapContrastTRC/*"/>
	///  <param name="factor">[in] - generally between 0.0 [no enhancement] and 1.0, but can be larger than 1.0</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ContrastTRC (Single factor)
	{
		int RetObj = _All.pixcmapContrastTRC(this, factor);
		return RetObj;
	}

	// colormap.c (2186, 1)
	// pixcmapShiftIntensity(cmap, fraction) as int
	// pixcmapShiftIntensity(PIXCMAP *, l_float32) as l_ok
	///  <summary>
	/// (1) This is an in-place transform<para/>
	///
	/// (2) It does a proportional shift of the intensity for each color.<para/>
	///
	/// (3) If fraction  is smaller 0.0, it moves all colors towards (0,0,0).
	/// This darkens the image.
	/// If fraction  is greater  0.0, it moves all colors towards (255,255,255)
	/// This fades the image.<para/>
	///
	/// (4) The equivalent transform can be accomplished with pixcmapGammaTRC(),
	/// but it is considerably more difficult (see numaGammaTRC()).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapShiftIntensity/*"/>
	///  <param name="fraction">[in] - between -1.0 and +1.0</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ShiftIntensity (Single fraction)
	{
		int RetObj = _All.pixcmapShiftIntensity(this, fraction);
		return RetObj;
	}

	// colormap.c (2236, 1)
	// pixcmapShiftByComponent(cmap, srcval, dstval) as int
	// pixcmapShiftByComponent(PIXCMAP *, l_uint32, l_uint32) as l_ok
	///  <summary>
	/// (1) This is an in-place transform<para/>
	///
	/// (2) It implements pixelShiftByComponent() for each color.
	/// The mapping is specified by srcval and dstval.<para/>
	///
	/// (3) If a component decreases, the component in the colormap
	/// decreases by the same ratio.  Likewise for increasing, except
	/// all ratios are taken with respect to the distance from 255.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapShiftByComponent/*"/>
	///  <param name="srcval">[in] - source color: 0xrrggbb00</param>
	///  <param name="dstval">[in] - target color: 0xrrggbb00</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ShiftByComponent (uint srcval,
								 uint dstval)
	{
		int RetObj = _All.pixcmapShiftByComponent(this, srcval, dstval);
		return RetObj;
	}

	// colorquant1.c (3852, 1)
	// pixcmapToOctcubeLUT(cmap, level, metric) as int[]
	// pixcmapToOctcubeLUT(PIXCMAP *, l_int32, l_int32) as l_int32 *
	///  <summary>
	/// (1) This function is used to quickly find the colormap color
	/// that is closest to any rgb color.  It is used to assign
	/// rgb colors to an existing colormap.  It can be very expensive
	/// to search through the entire colormap for the closest color
	/// to each pixel.  Instead, we first set up this table, which is
	/// populated by the colormap index nearest to each octcube
	/// color.  Then we go through the image for each pixel,
	/// do two table lookups: first to generate the octcube index
	/// from rgb and second to use this table to read out the
	/// colormap index.<para/>
	///
	/// (2) Do a slight modification for white and black.  For level = 4,
	/// each octcube size is 16.  The center of the whitest octcube
	/// is at (248, 248, 248), which is closer to 242 than 255.
	/// Consequently, any gray color between 242 and 254 will
	/// be selected, even if white (255, 255, 255) exists.  This is
	/// typically not optimal, because the original color was
	/// likely white.  Therefore, if white exists in the colormap,
	/// use it for any rgb color that falls into the most white octcube.
	/// Do the similar thing for black.<para/>
	///
	/// (3) Here are the actual function calls for quantizing to a
	/// specified colormap:
	/// ~ first make the tables that map from rgb to octcube index
	/// makeRGBToIndexTables()
	/// ~ then for each pixel:
	/// use the tables to get the octcube index
	/// getOctcubeIndexFromRGB()
	/// use this table to get the nearest color in the colormap
	/// cmap_index = tab[index]<para/>
	///
	/// (4) Distance can be either manhattan or euclidean.<para/>
	///
	/// (5) In typical use, level = 4 gives reasonable results, and
	/// level = 5 is slightly better.  When this function is used
	/// for color segmentation, there are typically a small number
	/// of colors and the number of levels can be small (e.g., level = 3).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapToOctcubeLUT/*"/>
	///  <param name="level">[in] - significant bits for each of RGB valid in [1...6]</param>
	///  <param name="metric">[in] - L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
	///   <returns>tab[23  level]</returns>
	// CreateAdditiveFunction: Function/Else
	public int[] ToOctcubeLUT (int level,
							   int metric)
	{
		int[] RetObj = _All.pixcmapToOctcubeLUT(this, level, metric);
		return RetObj;
	}

	// colorspace.c (424, 1)
	// pixcmapConvertRGBToHSV(cmap) as int
	// pixcmapConvertRGBToHSV(PIXCMAP *) as l_ok
	///  <summary>
	/// ~ in-place transform
	/// ~ See convertRGBToHSV() for def'n of HSV space.
	/// ~ replaces: r to h, g to s, b to v
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapConvertRGBToHSV/*"/>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConvertRGBToHSV ()
	{
		int RetObj = _All.pixcmapConvertRGBToHSV(this);
		return RetObj;
	}

	// colorspace.c (457, 1)
	// pixcmapConvertHSVToRGB(cmap) as int
	// pixcmapConvertHSVToRGB(PIXCMAP *) as l_ok
	///  <summary>
	/// ~ in-place transform
	/// ~ See convertRGBToHSV() for def'n of HSV space.
	/// ~ replaces: h to r, s to g, v to b
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapConvertHSVToRGB/*"/>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConvertHSVToRGB ()
	{
		int RetObj = _All.pixcmapConvertHSVToRGB(this);
		return RetObj;
	}

	// colorspace.c (1678, 1)
	// pixcmapConvertRGBToYUV(cmap) as int
	// pixcmapConvertRGBToYUV(PIXCMAP *) as l_ok
	///  <summary>
	/// ~ in-place transform
	/// ~ See convertRGBToYUV() for def'n of YUV space.
	/// ~ replaces: r to y, g to u, b to v
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapConvertRGBToYUV/*"/>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConvertRGBToYUV ()
	{
		int RetObj = _All.pixcmapConvertRGBToYUV(this);
		return RetObj;
	}

	// colorspace.c (1711, 1)
	// pixcmapConvertYUVToRGB(cmap) as int
	// pixcmapConvertYUVToRGB(PIXCMAP *) as l_ok
	///  <summary>
	/// ~ in-place transform
	/// ~ See convertRGBToYUV() for def'n of YUV space.
	/// ~ replaces: y to r, u to g, v to b
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixcmapConvertYUVToRGB/*"/>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConvertYUVToRGB ()
	{
		int RetObj = _All.pixcmapConvertYUVToRGB(this);
		return RetObj;
	}


}
public partial class Pixa
{
	// bmf.c (322, 1)
	// pixaGetFont(dir, fontsize, pbl0, pbl1, pbl2) as Pixa
	// pixaGetFont(const char *, l_int32, l_int32 *, l_int32 *, l_int32 *) as PIXA *
	///  <summary>
	/// (1) This reads a pre-computed pixa file with the 95 ascii chars.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaGetFont/*"/>
	///  <param name="dir">[in] - directory holding pixa of character set</param>
	///  <param name="fontsize">[in] - 4, 6, 8, ... , 20</param>
	///  <param name="pbl0">[out] - baseline of row 1</param>
	///  <param name="pbl1">[out] - baseline of row 2</param>
	///  <param name="pbl2">[out] - baseline of row 3</param>
	///   <returns>pixa of font bitmaps for 95 characters, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa GetFont (String dir,
						 int fontsize,
						 out int pbl0,
						 out int pbl1,
						 out int pbl2)
	{
		Pixa RetObj = _All.pixaGetFont(dir, fontsize, out pbl0, out pbl1, out pbl2);
		return RetObj;
	}

	// bmf.c (372, 1)
	// pixaSaveFont(indir, outdir, fontsize) as int
	// pixaSaveFont(const char *, const char *, l_int32) as l_ok
	///  <summary>
	/// (1) This saves a font of a particular size.<para/>
	///
	/// (2) If %dir == null, this generates the font bitmaps from a
	/// compiled string.<para/>
	///
	/// (3) prog/genfonts calls this function for each of the
	/// nine font sizes, to generate all the font pixa files.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSaveFont/*"/>
	///  <param name="indir">[in][optional] - directory holding image of character set</param>
	///  <param name="outdir">[in] - directory into which the output pixa file will be written</param>
	///  <param name="fontsize">[in] - in pts, at 300 ppi</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SaveFont (String outdir,
						 int fontsize,
						 String indir)
	{
		int RetObj = _All.pixaSaveFont(indir, outdir, fontsize);
		return RetObj;
	}

	// boxfunc3.c (716, 1)
	// pixaDisplayBoxaa(pixas, baa, colorflag, width) as Pixa
	// pixaDisplayBoxaa(PIXA *, BOXAA *, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) All pix in %pixas that are not rgb are converted to rgb.<para/>
	///
	/// (2) Each boxa in %baa contains boxes that will be drawn on
	/// the corresponding pix in %pixas.<para/>
	///
	/// (3) The color of the boxes drawn on each pix are selected with
	/// %colorflag:
	/// For red, green or blue: use L_DRAW_RED, etc.
	/// For sequential r, g, b: use L_DRAW_RGB
	/// For random colors: use L_DRAW_RANDOM
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplayBoxaa/*"/>
	///  <param name="pixas">[in] - any depth, can be cmapped</param>
	///  <param name="baa">[in] - boxes to draw on input pixa</param>
	///  <param name="colorflag">[in] - (L_DRAW_RED, L_DRAW_GREEN, etc)</param>
	///  <param name="width">[in] - thickness of lines</param>
	///   <returns>pixa with box outlines drawn on each pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa DisplayBoxaa (Pixa pixas,
							  Boxaa baa,
							  int colorflag,
							  int width)
	{
		Pixa RetObj = _All.pixaDisplayBoxaa(pixas, baa, colorflag, width);
		return RetObj;
	}

	// ccthin.c (68, 1)
	// pixaThinConnected(pixas, type, connectivity, maxiters) as Pixa
	// pixaThinConnected(PIXA *, l_int32, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) See notes in pixThinConnected().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaThinConnected/*"/>
	///  <param name="pixas">[in] - of 1 bpp pix</param>
	///  <param name="type">[in] - L_THIN_FG, L_THIN_BG</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="maxiters">[in] - max number of iters allowed use 0 to iterate until completion</param>
	///   <returns>pixds, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ThinConnected (Pixa pixas,
							   int type,
							   int connectivity,
							   int maxiters)
	{
		Pixa RetObj = _All.pixaThinConnected(pixas, type, connectivity, maxiters);
		return RetObj;
	}

	// compare.c (1893, 1)
	// pixaComparePhotoRegionsByHisto(pixa, minratio, textthresh, factor, nx, ny, simthresh, pnai, pscores, ppixd, debug) as int
	// pixaComparePhotoRegionsByHisto(PIXA *, l_float32, l_float32, l_int32, l_int32, l_int32, l_float32, NUMA **, l_float32 **, PIX **, l_int32) as l_ok
	///  <summary>
	/// (1) This function takes a pixa of cropped photo images and
	/// compares each one to the others for similarity.
	/// Each image is first tested to see if it is a photo that can
	/// be compared by tiled histograms.  If so, it is padded to put
	/// the centroid in the center of the image, and the histograms
	/// are generated.  The final step of comparing each histogram
	/// with all the others is very fast.<para/>
	///
	/// (2) An initial filter gives %score = 0 if the ratio of widths
	/// and heights (smallest / largest) does not exceed a
	/// threshold %minratio.  If set at 1.0, both images must be
	/// exactly the same size.  A typical value for %minratio is 0.9.<para/>
	///
	/// (3) The comparison score between two images is a value in [0.0 .. 1.0].
	/// If the comparison score greater or equal %simthresh, the images are placed in
	/// the same similarity class.  Default value for %simthresh is 0.25.<para/>
	///
	/// (4) An array %nai of similarity class indices for pix in the
	/// input pixa is returned.<para/>
	///
	/// (5) There are two debugging options:
	/// An optional 2D matrix of scores is returned as a 1D array.
	/// A visualization of this is written to a temp file.
	/// An optional pix showing the similarity classes can be
	/// returned.  Text in each input pix is reproduced.<para/>
	///
	/// (6) See the notes in pixComparePhotoRegionsByHisto() for details
	/// on the implementation.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaComparePhotoRegionsByHisto/*"/>
	///  <param name="minratio">[in] - requiring sizes be compatible  is smaller 1.0</param>
	///  <param name="textthresh">[in] - threshold for text/photo use 0 for default</param>
	///  <param name="factor">[in] - subsampling greater or equal 1</param>
	///  <param name="nx">[in] - num subregions to use for histograms e.g. 3x3</param>
	///  <param name="ny">[in] - num subregions to use for histograms e.g. 3x3</param>
	///  <param name="simthresh">[in] - threshold for similarity use 0 for default</param>
	///  <param name="pnai">[out] - array  giving similarity class indices</param>
	///  <param name="pscores">[out][optional] - score matrix as 1-D array of size N^2</param>
	///  <param name="ppixd">[out][optional] - pix of similarity classes</param>
	///  <param name="debug">[in] - 1 to output histograms 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ComparePhotoRegionsByHisto (Single minratio,
										   Single textthresh,
										   int factor,
										   int nx,
										   int ny,
										   Single simthresh,
										   out Numa pnai,
										   out List<Single[]> pscores,
										   out Pix ppixd,
										   DebugOnOff debug)
	{
		int RetObj = _All.pixaComparePhotoRegionsByHisto(this, minratio, textthresh, factor, nx, ny, simthresh, out pnai, out pscores, out ppixd, debug);
		return RetObj;
	}

	// morphapp.c (265, 1)
	// pixaMorphSequenceByComponent(pixas, sequence, minw, minh) as Pixa
	// pixaMorphSequenceByComponent(PIXA *, const char *, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) See pixMorphSequence() for composing operation sequences.<para/>
	///
	/// (2) This operates separately on each c.c. in the input pixa.<para/>
	///
	/// (3) You can specify that the width and/or height must equal
	/// or exceed a minimum size for the operation to take place.<para/>
	///
	/// (4) The input pixa should have a boxa giving the locations
	/// of the pix components.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaMorphSequenceByComponent/*"/>
	///  <param name="pixas">[in] - of 1 bpp pix</param>
	///  <param name="sequence">[in] - string specifying sequence</param>
	///  <param name="minw">[in] - minimum width to consider use 0 or 1 for any width</param>
	///  <param name="minh">[in] - minimum height to consider use 0 or 1 for any height</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa MorphSequenceByComponent (Pixa pixas,
										  String sequence,
										  int minw,
										  int minh)
	{
		Pixa RetObj = _All.pixaMorphSequenceByComponent(pixas, sequence, minw, minh);
		return RetObj;
	}

	// morphapp.c (427, 1)
	// pixaMorphSequenceByRegion(pixs, pixam, sequence, minw, minh) as Pixa
	// pixaMorphSequenceByRegion(PIX *, PIXA *, const char *, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) See pixMorphSequence() for composing operation sequences.<para/>
	///
	/// (2) This operates separately on each region in the input pixs
	/// defined by the components in pixam.<para/>
	///
	/// (3) You can specify that the width and/or height of a mask
	/// component must equal or exceed a minimum size for the
	/// operation to take place.<para/>
	///
	/// (4) The input pixam should have a boxa giving the locations
	/// of the regions in pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaMorphSequenceByRegion/*"/>
	///  <param name="pixs">[in] - 1 bpp</param>
	///  <param name="pixam">[in] - of 1 bpp mask elements</param>
	///  <param name="sequence">[in] - string specifying sequence</param>
	///  <param name="minw">[in] - minimum width to consider use 0 or 1 for any width</param>
	///  <param name="minh">[in] - minimum height to consider use 0 or 1 for any height</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa MorphSequenceByRegion (Pix pixs,
									   Pixa pixam,
									   String sequence,
									   int minw,
									   int minh)
	{
		Pixa RetObj = _All.pixaMorphSequenceByRegion(pixs, pixam, sequence, minw, minh);
		return RetObj;
	}

	// morphapp.c (901, 1)
	// pixaExtendByMorph(pixas, type, niters, sel, include) as Pixa
	// pixaExtendByMorph(PIXA *, l_int32, l_int32, SEL *, l_int32) as PIXA *
	///  <summary>
	/// (1) This dilates or erodes every pix in %pixas, iteratively,
	/// using the input Sel (or, if null, a 2x2 Sel by default),
	/// and puts the results in %pixad.<para/>
	///
	/// (2) If %niters smaller or equal 0, this is a no-op it returns a clone of pixas.<para/>
	///
	/// (3) If %include == 1, the output %pixad contains all the pix
	/// in %pixas.  Otherwise, it doesn't, but pixaJoin() can be
	/// used later to join pixas with pixad.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaExtendByMorph/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="type">[in] - L_MORPH_DILATE, L_MORPH_ERODE</param>
	///  <param name="niters">[in] - </param>
	///  <param name="sel">[in] - used for dilation, erosion uses 2x2 if null</param>
	///  <param name="include">[in] - 1 to include a copy of the input pixas in pixad 0 to omit</param>
	///   <returns>pixad   with derived pix, using all iterations, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ExtendByMorph (Pixa pixas,
							   int type,
							   int niters,
							   Sel sel,
							   int include)
	{
		Pixa RetObj = _All.pixaExtendByMorph(pixas, type, niters, sel, include);
		return RetObj;
	}

	// morphapp.c (973, 1)
	// pixaExtendByScaling(pixas, nasc, type, include) as Pixa
	// pixaExtendByScaling(PIXA *, NUMA *, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) This scales every pix in %pixas by each factor in %nasc.
	/// and puts the results in %pixad.<para/>
	///
	/// (2) If %include == 1, the output %pixad contains all the pix
	/// in %pixas.  Otherwise, it doesn't, but pixaJoin() can be
	/// used later to join pixas with pixad.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaExtendByScaling/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="nasc">[in] - numa of scaling factors</param>
	///  <param name="type">[in] - L_HORIZ, L_VERT, L_BOTH_DIRECTIONS</param>
	///  <param name="include">[in] - 1 to include a copy of the input pixas in pixad 0 to omit</param>
	///   <returns>pixad   with derived pix, using all scalings, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ExtendByScaling (Pixa pixas,
								 Numa nasc,
								 int type,
								 int include)
	{
		Pixa RetObj = _All.pixaExtendByScaling(pixas, nasc, type, include);
		return RetObj;
	}

	// morphapp.c (1475, 1)
	// pixaCentroids(pixa) as Pta
	// pixaCentroids(PIXA *) as PTA *
	///  <summary>
	/// (1) An error message is returned if any pix has something other
	/// than 1 bpp or 8 bpp depth, and the centroid from that pix
	/// is saved as (0, 0).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaCentroids/*"/>
	///   <returns>pta of centroids relative to the UL corner of each pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta Centroids ()
	{
		Pta RetObj = _All.pixaCentroids(this);
		return RetObj;
	}

	// pdfio1.c (752, 1)
	// pixaConvertToPdf(pixa, res, scalefactor, type, quality, title, fileout) as int
	// pixaConvertToPdf(PIXA *, l_int32, l_float32, l_int32, l_int32, const char *, const char *) as l_ok
	///  <summary>
	/// (1) The images are encoded with G4 if 1 bpp JPEG if 8 bpp without
	/// colormap and many colors, or 32 bpp FLATE for anything else.<para/>
	///
	/// (2) The scalefactor must be  is greater  0.0 otherwise it is set to 1.0.<para/>
	///
	/// (3) Specifying one of the three encoding types for %type forces
	/// all images to be compressed with that type.  Use 0 to have
	/// the type determined for each image based on depth and whether
	/// or not it has a colormap.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaConvertToPdf/*"/>
	///  <param name="res">[in] - override the resolution of each input image, in ppi use 0 to respect the resolution embedded in the input</param>
	///  <param name="scalefactor">[in] - scaling factor applied to each image  is greater  0.0</param>
	///  <param name="type">[in] - encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	///  <param name="quality">[in] - used for JPEG only 0 for default (75)</param>
	///  <param name="title">[in][optional] - pdf title</param>
	///  <param name="fileout">[in] - pdf file of all images</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConvertToPdf (int res,
							 Single scalefactor,
							 int type,
							 String fileout,
							 int quality,
							 String title)
	{
		int RetObj = _All.pixaConvertToPdf(this, res, scalefactor, type, quality, title, fileout);
		return RetObj;
	}

	// pdfio1.c (804, 1)
	// pixaConvertToPdfData(pixa, res, scalefactor, type, quality, title, pdata, pnbytes) as int
	// pixaConvertToPdfData(PIXA *, l_int32, l_float32, l_int32, l_int32, const char *, l_uint8 **, size_t *) as l_ok
	///  <summary>
	/// (1) See pixaConvertToPdf().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaConvertToPdfData/*"/>
	///  <param name="res">[in] - input resolution of all images</param>
	///  <param name="scalefactor">[in] - scaling factor applied to each image  is greater  0.0</param>
	///  <param name="type">[in] - encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	///  <param name="quality">[in] - used for JPEG only 0 for default (75)</param>
	///  <param name="title">[in][optional] - pdf title</param>
	///  <param name="pdata">[out] - output pdf data (of all images</param>
	///  <param name="pnbytes">[out] - size of output pdf data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConvertToPdfData (int res,
								 Single scalefactor,
								 int type,
								 out Byte[] pdata,
								 out uint pnbytes,
								 int quality,
								 String title)
	{
		int RetObj = _All.pixaConvertToPdfData(this, res, scalefactor, type, quality, title, out pdata, out pnbytes);
		return RetObj;
	}

	// pix3.c (1778, 1)
	// pixaCountPixels(pixa) as Numa
	// pixaCountPixels(PIXA *) as NUMA *
	///  <summary>
	/// pixaCountPixels()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaCountPixels/*"/>
	///   <returns>na of ON pixels in each pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa CountPixels ()
	{
		Numa RetObj = _All.pixaCountPixels(this);
		return RetObj;
	}

	// pix4.c (2928, 1)
	// pixaGetAlignedStats(pixa, type, nbins, thresh) as Pix
	// pixaGetAlignedStats(PIXA *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Each pixel in the returned pix represents an average
	/// (or median, or mode) over the corresponding pixels in each
	/// pix in the pixa.<para/>
	///
	/// (2) The %thresh parameter works with L_MODE_VAL only, and
	/// sets a minimum occupancy of the mode bin.
	/// If the occupancy of the mode bin is less than %thresh, the
	/// mode value is returned as 0.  To always return the actual
	/// mode value, set %thresh = 0.  See pixGetRowStats().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaGetAlignedStats/*"/>
	///  <param name="type">[in] - L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT</param>
	///  <param name="nbins">[in] - of histogram for median and mode ignored for mean</param>
	///  <param name="thresh">[in] - on histogram for mode val ignored for all other types</param>
	///   <returns>pix with pixelwise aligned stats, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GetAlignedStats (int type,
								int nbins,
								int thresh)
	{
		Pix RetObj = _All.pixaGetAlignedStats(this, type, nbins, thresh);
		return RetObj;
	}

	// pix4.c (2975, 1)
	// pixaExtractColumnFromEachPix(pixa, col, pixd) as int
	// pixaExtractColumnFromEachPix(PIXA *, l_int32, PIX *) as l_ok
	///  <summary>
	/// pixaExtractColumnFromEachPix()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaExtractColumnFromEachPix/*"/>
	///  <param name="col">[in] - column index</param>
	///  <param name="pixd">[in] - pix into which each column is inserted</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ExtractColumnFromEachPix (int col,
										 Pix pixd)
	{
		int RetObj = _All.pixaExtractColumnFromEachPix(this, col, pixd);
		return RetObj;
	}

	// pix5.c (130, 1)
	// pixaFindDimensions(pixa, pnaw, pnah) as int
	// pixaFindDimensions(PIXA *, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// pixaFindDimensions()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaFindDimensions/*"/>
	///  <param name="pnaw">[out][optional] - numa of pix widths</param>
	///  <param name="pnah">[out][optional] - numa of pix heights</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindDimensions (out Numa pnaw,
							   out Numa pnah)
	{
		int RetObj = _All.pixaFindDimensions(this, out pnaw, out pnah);
		return RetObj;
	}

	// pix5.c (231, 1)
	// pixaFindPerimToAreaRatio(pixa) as Numa
	// pixaFindPerimToAreaRatio(PIXA *) as NUMA *
	///  <summary>
	/// (1) This is typically used for a pixa consisting of
	/// 1 bpp connected components.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaFindPerimToAreaRatio/*"/>
	///   <returns>na   of perimeter/arear ratio for each pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa FindPerimToAreaRatio ()
	{
		Numa RetObj = _All.pixaFindPerimToAreaRatio(this);
		return RetObj;
	}

	// pix5.c (335, 1)
	// pixaFindPerimSizeRatio(pixa) as Numa
	// pixaFindPerimSizeRatio(PIXA *) as NUMA *
	///  <summary>
	/// (1) This is typically used for a pixa consisting of
	/// 1 bpp connected components.<para/>
	///
	/// (2) This has a minimum value for a circle of pi/4 a value for
	/// a rectangle component of approx. 1.0 and a value much larger
	/// than 1.0 for a component with a highly irregular boundary.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaFindPerimSizeRatio/*"/>
	///   <returns>na   of fg perimeter/(2(w+h)) ratio for each pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa FindPerimSizeRatio ()
	{
		Numa RetObj = _All.pixaFindPerimSizeRatio(this);
		return RetObj;
	}

	// pix5.c (431, 1)
	// pixaFindAreaFraction(pixa) as Numa
	// pixaFindAreaFraction(PIXA *) as NUMA *
	///  <summary>
	/// (1) This is typically used for a pixa consisting of
	/// 1 bpp connected components.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaFindAreaFraction/*"/>
	///   <returns>na  of area fractions for each pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa FindAreaFraction ()
	{
		Numa RetObj = _All.pixaFindAreaFraction(this);
		return RetObj;
	}

	// pix5.c (522, 1)
	// pixaFindAreaFractionMasked(pixa, pixm, debug) as Numa
	// pixaFindAreaFractionMasked(PIXA *, PIX *, l_int32) as NUMA *
	///  <summary>
	/// (1) This is typically used for a pixa consisting of
	/// 1 bpp connected components, which has an associated
	/// boxa giving the location of the components relative
	/// to the mask origin.<para/>
	///
	/// (2) The debug flag displays in green and red the masked and
	/// unmasked parts of the image from which pixa was derived.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaFindAreaFractionMasked/*"/>
	///  <param name="pixm">[in] - mask image</param>
	///  <param name="debug">[in] - 1 for output, 0 to suppress</param>
	///   <returns>na of ratio masked/total fractions for each pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa FindAreaFractionMasked (Pix pixm,
										DebugOnOff debug)
	{
		Numa RetObj = _All.pixaFindAreaFractionMasked(this, pixm, debug);
		return RetObj;
	}

	// pix5.c (660, 1)
	// pixaFindWidthHeightRatio(pixa) as Numa
	// pixaFindWidthHeightRatio(PIXA *) as NUMA *
	///  <summary>
	/// (1) This is typically used for a pixa consisting of
	/// 1 bpp connected components.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaFindWidthHeightRatio/*"/>
	///   <returns>na of width/height ratios for each pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa FindWidthHeightRatio ()
	{
		Numa RetObj = _All.pixaFindWidthHeightRatio(this);
		return RetObj;
	}

	// pix5.c (696, 1)
	// pixaFindWidthHeightProduct(pixa) as Numa
	// pixaFindWidthHeightProduct(PIXA *) as NUMA *
	///  <summary>
	/// (1) This is typically used for a pixa consisting of
	/// 1 bpp connected components.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaFindWidthHeightProduct/*"/>
	///   <returns>na of widthheight products for each pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa FindWidthHeightProduct ()
	{
		Numa RetObj = _All.pixaFindWidthHeightProduct(this);
		return RetObj;
	}

	// pixabasic.c (162, 1)
	// pixaCreate(n) as Pixa
	// pixaCreate(l_int32) as PIXA *
	///  <summary>
	/// (1) This creates an empty boxa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaCreate/*"/>
	///  <param name="n">[in] - initial number of ptrs</param>
	///   <returns>pixa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa Create (int n)
	{
		Pixa RetObj = _All.pixaCreate(n);
		return RetObj;
	}

	// pixabasic.c (201, 1)
	// pixaCreateFromPix(pixs, n, cellw, cellh) as Pixa
	// pixaCreateFromPix(PIX *, l_int32, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) For bpp = 1, we truncate each retrieved pix to the ON
	/// pixels, which we assume for now start at (0,0)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaCreateFromPix/*"/>
	///  <param name="pixs">[in] - with individual components on a lattice</param>
	///  <param name="n">[in] - number of components</param>
	///  <param name="cellw">[in] - width of each cell</param>
	///  <param name="cellh">[in] - height of each cell</param>
	///   <returns>pixa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa CreateFromPix (Pix pixs,
							   int n,
							   int cellw,
							   int cellh)
	{
		Pixa RetObj = _All.pixaCreateFromPix(pixs, n, cellw, cellh);
		return RetObj;
	}

	// pixabasic.c (264, 1)
	// pixaCreateFromBoxa(pixs, boxa, pcropwarn) as Pixa
	// pixaCreateFromBoxa(PIX *, BOXA *, l_int32 *) as PIXA *
	///  <summary>
	/// (1) This simply extracts from pixs the region corresponding to each
	/// box in the boxa.<para/>
	///
	/// (2) The 3rd arg is optional.  If the extent of the boxa exceeds the
	/// size of the pixa, so that some boxes are either clipped
	/// or entirely outside the pix, a warning is returned as TRUE.<para/>
	///
	/// (3) pixad will have only the properly clipped elements, and
	/// the internal boxa will be correct.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaCreateFromBoxa/*"/>
	///  <param name="pixs">[in] - </param>
	///  <param name="boxa">[in] - </param>
	///  <param name="pcropwarn">[out][optional] - TRUE if the boxa extent is larger than pixs.</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa CreateFromBoxa (Pix pixs,
								Boxa boxa,
								out int pcropwarn)
	{
		Pixa RetObj = _All.pixaCreateFromBoxa(pixs, boxa, out pcropwarn);
		return RetObj;
	}

	// pixabasic.c (337, 1)
	// pixaSplitPix(pixs, nx, ny, borderwidth, bordercolor) as Pixa
	// pixaSplitPix(PIX *, l_int32, l_int32, l_int32, l_uint32) as PIXA *
	///  <summary>
	/// (1) This is a variant on pixaCreateFromPix(), where we
	/// simply divide the image up into (approximately) equal
	/// subunits.  If you want the subimages to have essentially
	/// the same aspect ratio as the input pix, use nx = ny.<para/>
	///
	/// (2) If borderwidth is 0, we ignore the input bordercolor and
	/// redefine it to white.<para/>
	///
	/// (3) The bordercolor is always used to initialize each tiled pix,
	/// so that if the src is clipped, the unblitted part will
	/// be this color.  This avoids 1 pixel wide black stripes at the
	/// left and lower edges.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSplitPix/*"/>
	///  <param name="pixs">[in] - with individual components on a lattice</param>
	///  <param name="nx">[in] - number of mosaic cells horizontally</param>
	///  <param name="ny">[in] - number of mosaic cells vertically</param>
	///  <param name="borderwidth">[in] - of added border on all sides</param>
	///  <param name="bordercolor">[in] - in our RGBA format: 0xrrggbbaa</param>
	///   <returns>pixa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa SplitPix (Pix pixs,
						  int nx,
						  int ny,
						  int borderwidth,
						  uint bordercolor)
	{
		Pixa RetObj = _All.pixaSplitPix(pixs, nx, ny, borderwidth, bordercolor);
		return RetObj;
	}

	// pixabasic.c (399, 1)
	// pixaDestroy(ppixa) as Object
	// pixaDestroy(PIXA **) as void
	///  <summary>
	/// (1) Decrements the ref count and, if 0, destroys the pixa.<para/>
	///
	/// (2) Always nulls the input ptr.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDestroy/*"/>
	///  <param name="ppixa">[in,out]can be null - ed</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref Pixa ppixa)
	{
		_All.pixaDestroy(ref ppixa);
	}

	// pixabasic.c (441, 1)
	// pixaCopy(pixa, copyflag) as Pixa
	// pixaCopy(PIXA *, l_int32) as PIXA *
	///  <summary>
	/// pixaCopy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaCopy/*"/>
	///  <param name="copyflag">[in] - see pix.h for details: L_COPY makes a new pixa and copies each pix and each box L_CLONE gives a new ref-counted handle to the input pixa L_COPY_CLONE makes a new pixa and inserts clones of all pix and boxes</param>
	///   <returns>new pixa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa Copy (int copyflag,
					  Pixa pixa)
	{
		Pixa RetObj = _All.pixaCopy(this, copyflag);
		return RetObj;
	}

	// pixabasic.c (494, 1)
	// pixaAddPix(pixa, pix, copyflag) as int
	// pixaAddPix(PIXA *, PIX *, l_int32) as l_ok
	///  <summary>
	/// pixaAddPix()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaAddPix/*"/>
	///  <param name="pix">[in] - to be added</param>
	///  <param name="copyflag">[in] - L_INSERT, L_COPY, L_CLONE</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddPix (Pix pix,
					   int copyflag)
	{
		int RetObj = _All.pixaAddPix(this, pix, copyflag);
		return RetObj;
	}

	// pixabasic.c (538, 1)
	// pixaAddBox(pixa, box, copyflag) as int
	// pixaAddBox(PIXA *, BOX *, l_int32) as l_ok
	///  <summary>
	/// pixaAddBox()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaAddBox/*"/>
	///  <param name="box">[in] - </param>
	///  <param name="copyflag">[in] - L_INSERT, L_COPY, L_CLONE</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddBox (Box box,
					   int copyflag)
	{
		int RetObj = _All.pixaAddBox(this, box, copyflag);
		return RetObj;
	}

	// pixabasic.c (593, 1)
	// pixaExtendArrayToSize(pixa, size) as int
	// pixaExtendArrayToSize(PIXA *, l_int32) as l_ok
	///  <summary>
	/// (1) If necessary, reallocs new pixa and boxa ptrs arrays to %size.
	/// The pixa and boxa ptr arrays must always be equal in size.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaExtendArrayToSize/*"/>
	///  <param name="size">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ExtendArrayToSize (int size)
	{
		int RetObj = _All.pixaExtendArrayToSize(this, size);
		return RetObj;
	}

	// pixabasic.c (622, 1)
	// pixaGetCount(pixa) as int
	// pixaGetCount(PIXA *) as l_int32
	///  <summary>
	/// pixaGetCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaGetCount/*"/>
	///   <returns>count, or 0 if no pixa</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCount ()
	{
		int RetObj = _All.pixaGetCount(this);
		return RetObj;
	}

	// pixabasic.c (641, 1)
	// pixaChangeRefcount(pixa, delta) as int
	// pixaChangeRefcount(PIXA *, l_int32) as l_ok
	///  <summary>
	/// pixaChangeRefcount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaChangeRefcount/*"/>
	///  <param name="delta">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ChangeRefcount (int delta)
	{
		int RetObj = _All.pixaChangeRefcount(this, delta);
		return RetObj;
	}

	// pixabasic.c (663, 1)
	// pixaGetPix(pixa, index, accesstype) as Pix
	// pixaGetPix(PIXA *, l_int32, l_int32) as PIX *
	///  <summary>
	/// pixaGetPix()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaGetPix/*"/>
	///  <param name="index">[in] - to the index-th pix</param>
	///  <param name="accesstype">[in] - L_COPY or L_CLONE</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GetPix (int index,
					   int accesstype)
	{
		Pix RetObj = _All.pixaGetPix(this, index, accesstype);
		return RetObj;
	}

	// pixabasic.c (698, 1)
	// pixaGetPixDimensions(pixa, index, pw, ph, pd) as int
	// pixaGetPixDimensions(PIXA *, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixaGetPixDimensions()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaGetPixDimensions/*"/>
	///  <param name="index">[in] - to the index-th box</param>
	///  <param name="pw">[out][optional] - each can be null</param>
	///  <param name="ph">[out][optional] - each can be null</param>
	///  <param name="pd">[out][optional] - each can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetPixDimensions (int index,
								 out int pw,
								 out int ph,
								 out int pd)
	{
		int RetObj = _All.pixaGetPixDimensions(this, index, out pw, out ph, out pd);
		return RetObj;
	}

	// pixabasic.c (732, 1)
	// pixaGetBoxa(pixa, accesstype) as Boxa
	// pixaGetBoxa(PIXA *, l_int32) as BOXA *
	///  <summary>
	/// pixaGetBoxa()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaGetBoxa/*"/>
	///  <param name="accesstype">[in] - L_COPY, L_CLONE, L_COPY_CLONE</param>
	///   <returns>boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa GetBoxa (int accesstype)
	{
		Boxa RetObj = _All.pixaGetBoxa(this, accesstype);
		return RetObj;
	}

	// pixabasic.c (756, 1)
	// pixaGetBoxaCount(pixa) as int
	// pixaGetBoxaCount(PIXA *) as l_int32
	///  <summary>
	/// pixaGetBoxaCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaGetBoxaCount/*"/>
	///   <returns>count, or 0 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetBoxaCount ()
	{
		int RetObj = _All.pixaGetBoxaCount(this);
		return RetObj;
	}

	// pixabasic.c (788, 1)
	// pixaGetBox(pixa, index, accesstype) as Box
	// pixaGetBox(PIXA *, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) There is always a boxa with a pixa, and it is initialized so
	/// that each box ptr is NULL.<para/>
	///
	/// (2) In general, we expect that there is either a box associated
	/// with each pix, or no boxes at all in the boxa.<para/>
	///
	/// (3) Having no boxes is thus not an automatic error.  Whether it
	/// is an actual error is determined by the calling program.
	/// If the caller expects to get a box, it is an error see, e.g.,
	/// pixaGetBoxGeometry().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaGetBox/*"/>
	///  <param name="index">[in] - to the index-th pix</param>
	///  <param name="accesstype">[in] - L_COPY or L_CLONE</param>
	///   <returns>box if null, not automatically an error, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box GetBox (int index,
					   int accesstype)
	{
		Box RetObj = _All.pixaGetBox(this, index, accesstype);
		return RetObj;
	}

	// pixabasic.c (826, 1)
	// pixaGetBoxGeometry(pixa, index, px, py, pw, ph) as int
	// pixaGetBoxGeometry(PIXA *, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixaGetBoxGeometry()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaGetBoxGeometry/*"/>
	///  <param name="index">[in] - to the index-th box</param>
	///  <param name="px">[out][optional] - each can be null</param>
	///  <param name="py">[out][optional] - each can be null</param>
	///  <param name="pw">[out][optional] - each can be null</param>
	///  <param name="ph">[out][optional] - each can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetBoxGeometry (int index,
							   out int px,
							   out int py,
							   out int pw,
							   out int ph)
	{
		int RetObj = _All.pixaGetBoxGeometry(this, index, out px, out py, out pw, out ph);
		return RetObj;
	}

	// pixabasic.c (868, 1)
	// pixaSetBoxa(pixa, boxa, accesstype) as int
	// pixaSetBoxa(PIXA *, BOXA *, l_int32) as l_ok
	///  <summary>
	/// (1) This destroys the existing boxa in the pixa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSetBoxa/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="accesstype">[in] - L_INSERT, L_COPY, L_CLONE</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetBoxa (Boxa boxa,
						int accesstype)
	{
		int RetObj = _All.pixaSetBoxa(this, boxa, accesstype);
		return RetObj;
	}

	// pixabasic.c (907, 1)
	// pixaGetPixArray(pixa) as Pix
	// pixaGetPixArray(PIXA *) as PIX **
	///  <summary>
	/// (1) This returns a ptr to the actual array.  The array is
	/// owned by the pixa, so it must not be destroyed.<para/>
	///
	/// (2) The caller should always check if the return value is NULL
	/// before accessing any of the pix ptrs in this array!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaGetPixArray/*"/>
	///   <returns>pix array, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix GetPixArray ()
	{
		Pix RetObj = _All.pixaGetPixArray(this);
		return RetObj;
	}

	// pixabasic.c (932, 1)
	// pixaVerifyDepth(pixa, psame, pmaxd) as int
	// pixaVerifyDepth(PIXA *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) It is considered to be an error if there are no pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaVerifyDepth/*"/>
	///  <param name="psame">[out] - 1 if depth is the same for all pix 0 otherwise</param>
	///  <param name="pmaxd">[out][optional] - max depth of all pix</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int VerifyDepth (out int psame,
							out int pmaxd)
	{
		int RetObj = _All.pixaVerifyDepth(this, out psame, out pmaxd);
		return RetObj;
	}

	// pixabasic.c (978, 1)
	// pixaVerifyDimensions(pixa, psame, pmaxw, pmaxh) as int
	// pixaVerifyDimensions(PIXA *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) It is considered to be an error if there are no pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaVerifyDimensions/*"/>
	///  <param name="psame">[out] - 1 if dimensions are the same for all pix 0 otherwise</param>
	///  <param name="pmaxw">[out][optional] - max width of all pix</param>
	///  <param name="pmaxh">[out][optional] - max height of all pix</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int VerifyDimensions (out int psame,
								 out int pmaxw,
								 out int pmaxh)
	{
		int RetObj = _All.pixaVerifyDimensions(this, out psame, out pmaxw, out pmaxh);
		return RetObj;
	}

	// pixabasic.c (1029, 1)
	// pixaIsFull(pixa, pfullpa, pfullba) as int
	// pixaIsFull(PIXA *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) A pixa is "full" if the array of pix is fully
	/// occupied from index 0 to index (pixaton - 1).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaIsFull/*"/>
	///  <param name="pfullpa">[out][optional] - 1 if pixa is full</param>
	///  <param name="pfullba">[out][optional] - 1 if boxa is full</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int IsFull (out int pfullpa,
					   out int pfullba)
	{
		int RetObj = _All.pixaIsFull(this, out pfullpa, out pfullba);
		return RetObj;
	}

	// pixabasic.c (1079, 1)
	// pixaCountText(pixa, pntext) as int
	// pixaCountText(PIXA *, l_int32 *) as l_ok
	///  <summary>
	/// (1) All pix have non-empty text strings if the returned value %ntext
	/// equals the pixa count.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaCountText/*"/>
	///  <param name="pntext">[out] - number of pix with non-empty text strings</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int CountText (out int pntext)
	{
		int RetObj = _All.pixaCountText(this, out pntext);
		return RetObj;
	}

	// pixabasic.c (1122, 1)
	// pixaSetText(pixa, sa) as int
	// pixaSetText(PIXA *, SARRAY *) as l_ok
	///  <summary>
	/// (1) To clear all the text fields, use sa == NULL<para/>
	///
	/// (2) If sa is defined, it must be the same size as %pixa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSetText/*"/>
	///  <param name="sa">[in][optional] - array of text strings, to insert in each pix</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetText (Sarray sa)
	{
		int RetObj = _All.pixaSetText(this, sa);
		return RetObj;
	}

	// pixabasic.c (1180, 1)
	// pixaGetLinePtrs(pixa, psize) as IntPtr
	// pixaGetLinePtrs(PIXA *, l_int32 *) as void ***
	///  <summary>
	/// (1) See pixGetLinePtrs() for details.<para/>
	///
	/// (2) It is best if all pix in the pixa are the same size.
	/// The size of each line ptr array is equal to the height
	/// of the pix that it refers to.<para/>
	///
	/// (3) This is an array of arrays.  To destroy it:
	/// for (i = 0 i  is smaller size i++)
	/// LEPT_FREE(lineset[i])
	/// LEPT_FREE(lineset)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaGetLinePtrs/*"/>
	///  <param name="psize">[out][optional] - number of pix in the pixa</param>
	///   <returns>array of array of line ptrs, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public IntPtr GetLinePtrs (out int psize)
	{
		IntPtr RetObj = _All.pixaGetLinePtrs(this, out psize);
		return RetObj;
	}

	// pixabasic.c (1228, 1)
	// pixaWriteStreamInfo(fp, pixa) as int
	// pixaWriteStreamInfo(FILE *, PIXA *) as l_ok
	///  <summary>
	/// (1) For each pix in the pixa, write out the pix dimensions, spp,
	/// text string (if it exists), and cmap info.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaWriteStreamInfo/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStreamInfo (FILE fp)
	{
		int RetObj = _All.pixaWriteStreamInfo(fp, this);
		return RetObj;
	}

	// pixabasic.c (1286, 1)
	// pixaReplacePix(pixa, index, pix, box) as int
	// pixaReplacePix(PIXA *, l_int32, PIX *, BOX *) as l_ok
	///  <summary>
	/// (1) In-place replacement of one pix.<para/>
	///
	/// (2) The previous pix at that location is destroyed.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaReplacePix/*"/>
	///  <param name="index">[in] - to the index-th pix</param>
	///  <param name="pix">[in] - insert to replace existing one</param>
	///  <param name="box">[in][optional] - insert to replace existing</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ReplacePix (int index,
						   Pix pix,
						   Box box)
	{
		int RetObj = _All.pixaReplacePix(this, index, pix, box);
		return RetObj;
	}

	// pixabasic.c (1336, 1)
	// pixaInsertPix(pixa, index, pixs, box) as int
	// pixaInsertPix(PIXA *, l_int32, PIX *, BOX *) as l_ok
	///  <summary>
	/// (1) This shifts pixa[i] to pixa[i + 1] for all i greater or equal index,
	/// and then inserts at pixa[index].<para/>
	///
	/// (2) To insert at the beginning of the array, set index = 0.<para/>
	///
	/// (3) It should not be used repeatedly on large arrays,
	/// because the function is O(n).<para/>
	///
	/// (4) To append a pix to a pixa, it's easier to use pixaAddPix().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaInsertPix/*"/>
	///  <param name="index">[in] - at which pix is to be inserted</param>
	///  <param name="pixs">[in] - new pix to be inserted</param>
	///  <param name="box">[in][optional] - new box to be inserted</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int InsertPix (int index,
						  Pix pixs,
						  Box box)
	{
		int RetObj = _All.pixaInsertPix(this, index, pixs, box);
		return RetObj;
	}

	// pixabasic.c (1386, 1)
	// pixaRemovePix(pixa, index) as int
	// pixaRemovePix(PIXA *, l_int32) as l_ok
	///  <summary>
	/// (1) This shifts pixa[i] to pixa[i - 1] for all i  is greater  index.<para/>
	///
	/// (2) It should not be used repeatedly on large arrays,
	/// because the function is O(n).<para/>
	///
	/// (3) The corresponding box is removed as well, if it exists.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaRemovePix/*"/>
	///  <param name="index">[in] - of pix to be removed</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RemovePix (int index)
	{
		int RetObj = _All.pixaRemovePix(this, index);
		return RetObj;
	}

	// pixabasic.c (1438, 1)
	// pixaRemovePixAndSave(pixa, index, ppix, pbox) as int
	// pixaRemovePixAndSave(PIXA *, l_int32, PIX **, BOX **) as l_ok
	///  <summary>
	/// (1) This shifts pixa[i] to pixa[i - 1] for all i  is greater  index.<para/>
	///
	/// (2) It should not be used repeatedly on large arrays,
	/// because the function is O(n).<para/>
	///
	/// (3) The corresponding box is removed as well, if it exists.<para/>
	///
	/// (4) The removed pix and box can either be retained or destroyed.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaRemovePixAndSave/*"/>
	///  <param name="index">[in] - of pix to be removed</param>
	///  <param name="ppix">[out][optional] - removed pix</param>
	///  <param name="pbox">[out][optional] - removed box</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RemovePixAndSave (int index,
								 out Pix ppix,
								 out Box pbox)
	{
		int RetObj = _All.pixaRemovePixAndSave(this, index, out ppix, out pbox);
		return RetObj;
	}

	// pixabasic.c (1513, 1)
	// pixaInitFull(pixa, pix, box) as int
	// pixaInitFull(PIXA *, PIX *, BOX *) as l_ok
	///  <summary>
	/// (1) This initializes a pixa by filling up the entire pix ptr array
	/// with copies of %pix.  If %pix == NULL, we use a tiny placeholder
	/// pix (w = h = d = 1).  Any existing pix are destroyed.
	/// It also optionally fills the boxa with copies of %box.
	/// After this operation, the numbers of pix and (optionally)
	/// boxes are equal to the number of allocated ptrs.<para/>
	///
	/// (2) Note that we use pixaReplacePix() instead of pixaInsertPix().
	/// They both have the same effect when inserting into a NULL ptr
	/// in the pixa ptr array:<para/>
	///
	/// (3) If the boxa is not initialized (i.e., filled with boxes),
	/// later insertion of boxes will cause an error, because the
	/// 'n' field is 0.<para/>
	///
	/// (4) Example usage.  This function is useful to prepare for a
	/// random insertion (or replacement) of pix into a pixa.
	/// To randomly insert pix into a pixa, without boxes, up to
	/// some index "max":
	/// Pixa pixa = pixaCreate(max)
	/// pixaInitFull(pixa, NULL, NULL)
	/// An existing pixa with a smaller ptr array can also be reused:
	/// pixaExtendArrayToSize(pixa, max)
	/// pixaInitFull(pixa, NULL, NULL)
	/// The initialization allows the pixa to always be properly
	/// filled, even if all pix (and boxes) are not later replaced.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaInitFull/*"/>
	///  <param name="pix">[in][optional] - to be replicated into the entire pixa ptr array</param>
	///  <param name="box">[in][optional] - to be replicated into the entire boxa ptr array</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int InitFull (Pix pix,
						 Box box)
	{
		int RetObj = _All.pixaInitFull(this, pix, box);
		return RetObj;
	}

	// pixabasic.c (1555, 1)
	// pixaClear(pixa) as int
	// pixaClear(PIXA *) as l_ok
	///  <summary>
	/// (1) This destroys all pix in the pixa, as well as
	/// all boxes in the boxa.  The ptrs in the pix ptr array
	/// are all null'd.  The number of allocated pix, n, is set to 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaClear/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Clear ()
	{
		int RetObj = _All.pixaClear(this);
		return RetObj;
	}

	// pixabasic.c (1593, 1)
	// pixaJoin(pixad, pixas, istart, iend) as int
	// pixaJoin(PIXA *, PIXA *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This appends a clone of each indicated pix in pixas to pixad<para/>
	///
	/// (2) istart  is smaller 0 is taken to mean 'read from the start' (istart = 0)<para/>
	///
	/// (3) iend  is smaller 0 means 'read to the end'<para/>
	///
	/// (4) If pixas is NULL or contains no pix, this is a no-op.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaJoin/*"/>
	///  <param name="pixad">[in] - dest pixa add to this one</param>
	///  <param name="pixas">[in][optional] - source pixa add from this one</param>
	///  <param name="istart">[in] - starting index in pixas</param>
	///  <param name="iend">[in] - ending index in pixas use -1 to cat all</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Join (Pixa pixad,
					 int istart,
					 int iend,
					 Pixa pixas)
	{
		int RetObj = _All.pixaJoin(pixad, pixas, istart, iend);
		return RetObj;
	}

	// pixabasic.c (1649, 1)
	// pixaInterleave(pixa1, pixa2, copyflag) as Pixa
	// pixaInterleave(PIXA *, PIXA *, l_int32) as PIXA *
	///  <summary>
	/// (1) %copyflag determines if the pix are copied or cloned.
	/// The boxes, if they exist, are copied.<para/>
	///
	/// (2) If the two pixa have different sizes, a warning is issued,
	/// and the number of pairs returned is the minimum size.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaInterleave/*"/>
	///  <param name="pixa1">[in] - first src pixa</param>
	///  <param name="pixa2">[in] - second src pixa</param>
	///  <param name="copyflag">[in] - L_CLONE, L_COPY</param>
	///   <returns>pixa  interleaved from sources, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa Interleave (Pixa pixa1,
							Pixa pixa2,
							int copyflag)
	{
		Pixa RetObj = _All.pixaInterleave(pixa1, pixa2, copyflag);
		return RetObj;
	}

	// pixabasic.c (2519, 1)
	// pixaRead(filename) as Pixa
	// pixaRead(const char *) as PIXA *
	///  <summary>
	/// (1) The pix are stored in the file as png.
	/// If the png library is not linked, this will fail.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaRead/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>pixa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa Read (String filename)
	{
		Pixa RetObj = _All.pixaRead(filename);
		return RetObj;
	}

	// pixabasic.c (2556, 1)
	// pixaReadStream(fp) as Pixa
	// pixaReadStream(FILE *) as PIXA *
	///  <summary>
	/// (1) The pix are stored in the file as png.
	/// If the png library is not linked, this will fail.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>pixa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ReadStream (FILE fp)
	{
		Pixa RetObj = _All.pixaReadStream(fp);
		return RetObj;
	}

	// pixabasic.c (2615, 1)
	// pixaReadMem(data, size) as Pixa
	// pixaReadMem(const l_uint8 *, size_t) as PIXA *
	///  <summary>
	/// pixaReadMem()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaReadMem/*"/>
	///  <param name="data">[in] - of serialized pixa</param>
	///  <param name="size">[in] - of data in bytes</param>
	///   <returns>pixa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ReadMem (Byte[] data,
						 uint size)
	{
		Pixa RetObj = _All.pixaReadMem(data, size);
		return RetObj;
	}

	// pixabasic.c (2652, 1)
	// pixaWriteDebug(fname, pixa) as int
	// pixaWriteDebug(const char *, PIXA *) as l_ok
	///  <summary>
	/// (1) Debug version, intended for use in the library when writing
	/// to files in a temp directory with names that are compiled in.
	/// This is used instead of pixaWrite() for all such library calls.<para/>
	///
	/// (2) The global variable LeptDebugOK defaults to 0, and can be set
	/// or cleared by the function setLeptDebugOK().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaWriteDebug/*"/>
	///  <param name="fname">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteDebug (String fname)
	{
		int RetObj = _All.pixaWriteDebug(fname, this);
		return RetObj;
	}

	// pixabasic.c (2680, 1)
	// pixaWrite(filename, pixa) as int
	// pixaWrite(const char *, PIXA *) as l_ok
	///  <summary>
	/// (1) The pix are stored in the file as png.
	/// If the png library is not linked, this will fail.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaWrite/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String filename)
	{
		int RetObj = _All.pixaWrite(filename, this);
		return RetObj;
	}

	// pixabasic.c (2721, 1)
	// pixaWriteStream(fp, pixa) as int
	// pixaWriteStream(FILE *, PIXA *) as l_ok
	///  <summary>
	/// (1) The pix are stored in the file as png.
	/// If the png library is not linked, this will fail.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaWriteStream/*"/>
	///  <param name="fp">[in] - file stream opened for "wb"</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp)
	{
		int RetObj = _All.pixaWriteStream(fp, this);
		return RetObj;
	}

	// pixabasic.c (2768, 1)
	// pixaWriteMem(pdata, psize, pixa) as int
	// pixaWriteMem(l_uint8 **, size_t *, PIXA *) as l_ok
	///  <summary>
	/// (1) Serializes a pixa in memory and puts the result in a buffer.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaWriteMem/*"/>
	///  <param name="pdata">[out] - data of serialized pixa</param>
	///  <param name="psize">[out] - size of returned data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMem (out Byte[] pdata,
						 out uint psize)
	{
		int RetObj = _All.pixaWriteMem(out pdata, out psize, this);
		return RetObj;
	}

	// pixabasic.c (2821, 1)
	// pixaReadBoth(filename) as Pixa
	// pixaReadBoth(const char *) as PIXA *
	///  <summary>
	/// (1) This reads serialized files of either a pixa or a pixacomp,
	/// and returns a pixa in memory.  It requires png and jpeg libraries.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaReadBoth/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>pixa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ReadBoth (String filename)
	{
		Pixa RetObj = _All.pixaReadBoth(filename);
		return RetObj;
	}

	// pixafunc1.c (299, 1)
	// pixaSelectBySize(pixas, width, height, type, relation, pchanged) as Pixa
	// pixaSelectBySize(PIXA *, l_int32, l_int32, l_int32, l_int32, l_int32 *) as PIXA *
	///  <summary>
	/// (1) The args specify constraints on the size of the
	/// components that are kept.<para/>
	///
	/// (2) Uses pix and box clones in the new pixa.<para/>
	///
	/// (3) If the selection type is L_SELECT_WIDTH, the input
	/// height is ignored, and v.v.<para/>
	///
	/// (4) To keep small components, use relation = L_SELECT_IF_LT or
	/// L_SELECT_IF_LTE.
	/// To keep large components, use relation = L_SELECT_IF_GT or
	/// L_SELECT_IF_GTE.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSelectBySize/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="width">[in] - threshold dimensions</param>
	///  <param name="height">[in] - threshold dimensions</param>
	///  <param name="type">[in] - L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	///  <param name="relation">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 otherwise</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa SelectBySize (Pixa pixas,
							  int width,
							  int height,
							  int type,
							  int relation,
							  out int pchanged)
	{
		Pixa RetObj = _All.pixaSelectBySize(pixas, width, height, type, relation, out pchanged);
		return RetObj;
	}

	// pixafunc1.c (355, 1)
	// pixaMakeSizeIndicator(pixa, width, height, type, relation) as Numa
	// pixaMakeSizeIndicator(PIXA *, l_int32, l_int32, l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) The args specify constraints on the size of the
	/// components that are kept.<para/>
	///
	/// (2) If the selection type is L_SELECT_WIDTH, the input
	/// height is ignored, and v.v.<para/>
	///
	/// (3) To keep small components, use relation = L_SELECT_IF_LT or
	/// L_SELECT_IF_LTE.
	/// To keep large components, use relation = L_SELECT_IF_GT or
	/// L_SELECT_IF_GTE.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaMakeSizeIndicator/*"/>
	///  <param name="width">[in] - threshold dimensions</param>
	///  <param name="height">[in] - threshold dimensions</param>
	///  <param name="type">[in] - L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	///  <param name="relation">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///   <returns>na indicator array, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa MakeSizeIndicator (int width,
								   int height,
								   int type,
								   int relation)
	{
		Numa RetObj = _All.pixaMakeSizeIndicator(this, width, height, type, relation);
		return RetObj;
	}

	// pixafunc1.c (520, 1)
	// pixaSelectByPerimToAreaRatio(pixas, thresh, type, pchanged) as Pixa
	// pixaSelectByPerimToAreaRatio(PIXA *, l_float32, l_int32, l_int32 *) as PIXA *
	///  <summary>
	/// (1) Returns a pixa clone if no components are removed.<para/>
	///
	/// (2) Uses pix and box clones in the new pixa.<para/>
	///
	/// (3) See pixSelectByPerimToAreaRatio().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSelectByPerimToAreaRatio/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="thresh">[in] - threshold ratio of fg boundary to fg pixels</param>
	///  <param name="type">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa SelectByPerimToAreaRatio (Pixa pixas,
										  Single thresh,
										  int type,
										  out int pchanged)
	{
		Pixa RetObj = _All.pixaSelectByPerimToAreaRatio(pixas, thresh, type, out pchanged);
		return RetObj;
	}

	// pixafunc1.c (651, 1)
	// pixaSelectByPerimSizeRatio(pixas, thresh, type, pchanged) as Pixa
	// pixaSelectByPerimSizeRatio(PIXA *, l_float32, l_int32, l_int32 *) as PIXA *
	///  <summary>
	/// (1) Returns a pixa clone if no components are removed.<para/>
	///
	/// (2) Uses pix and box clones in the new pixa.<para/>
	///
	/// (3) See pixSelectByPerimSizeRatio().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSelectByPerimSizeRatio/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="thresh">[in] - threshold ratio of fg boundary to b.b. circumference</param>
	///  <param name="type">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa SelectByPerimSizeRatio (Pixa pixas,
										Single thresh,
										int type,
										out int pchanged)
	{
		Pixa RetObj = _All.pixaSelectByPerimSizeRatio(pixas, thresh, type, out pchanged);
		return RetObj;
	}

	// pixafunc1.c (785, 1)
	// pixaSelectByAreaFraction(pixas, thresh, type, pchanged) as Pixa
	// pixaSelectByAreaFraction(PIXA *, l_float32, l_int32, l_int32 *) as PIXA *
	///  <summary>
	/// (1) Returns a pixa clone if no components are removed.<para/>
	///
	/// (2) Uses pix and box clones in the new pixa.<para/>
	///
	/// (3) This filters components based on the fraction of fg pixels
	/// of the component in its bounding box.<para/>
	///
	/// (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
	/// with less than the threshold fraction of foreground, and
	/// L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSelectByAreaFraction/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="thresh">[in] - threshold ratio of fg pixels to (w  h)</param>
	///  <param name="type">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa SelectByAreaFraction (Pixa pixas,
									  Single thresh,
									  int type,
									  out int pchanged)
	{
		Pixa RetObj = _All.pixaSelectByAreaFraction(pixas, thresh, type, out pchanged);
		return RetObj;
	}

	// pixafunc1.c (918, 1)
	// pixaSelectByWidthHeightRatio(pixas, thresh, type, pchanged) as Pixa
	// pixaSelectByWidthHeightRatio(PIXA *, l_float32, l_int32, l_int32 *) as PIXA *
	///  <summary>
	/// (1) Returns a pixa clone if no components are removed.<para/>
	///
	/// (2) Uses pix and box clones in the new pixa.<para/>
	///
	/// (3) This filters components based on the width-to-height ratio
	/// of each pix.<para/>
	///
	/// (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
	/// with less than the threshold ratio, and
	/// L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSelectByWidthHeightRatio/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="thresh">[in] - threshold ratio of width/height</param>
	///  <param name="type">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa SelectByWidthHeightRatio (Pixa pixas,
										  Single thresh,
										  int type,
										  out int pchanged)
	{
		Pixa RetObj = _All.pixaSelectByWidthHeightRatio(pixas, thresh, type, out pchanged);
		return RetObj;
	}

	// pixafunc1.c (968, 1)
	// pixaSelectByNumConnComp(pixas, nmin, nmax, connectivity, pchanged) as Pixa
	// pixaSelectByNumConnComp(PIXA *, l_int32, l_int32, l_int32, l_int32 *) as PIXA *
	///  <summary>
	/// (1) Returns a pixa clone if no components are removed.<para/>
	///
	/// (2) Uses pix and box clones in the new pixa.<para/>
	///
	/// (3) This filters by the number of connected components in
	/// a given range.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSelectByNumConnComp/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="nmin">[in] - minimum number of components</param>
	///  <param name="nmax">[in] - maximum number of components</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa SelectByNumConnComp (Pixa pixas,
									 int nmin,
									 int nmax,
									 int connectivity,
									 out int pchanged)
	{
		Pixa RetObj = _All.pixaSelectByNumConnComp(pixas, nmin, nmax, connectivity, out pchanged);
		return RetObj;
	}

	// pixafunc1.c (1027, 1)
	// pixaSelectWithIndicator(pixas, na, pchanged) as Pixa
	// pixaSelectWithIndicator(PIXA *, NUMA *, l_int32 *) as PIXA *
	///  <summary>
	/// (1) Returns a pixa clone if no components are removed.<para/>
	///
	/// (2) Uses pix and box clones in the new pixa.<para/>
	///
	/// (3) The indicator numa has values 0 (ignore) and 1 (accept).<para/>
	///
	/// (4) If the source boxa is not fully populated, it is left
	/// empty in the dest pixa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSelectWithIndicator/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="na">[in] - indicator numa</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa SelectWithIndicator (Pixa pixas,
									 Numa na,
									 out int pchanged)
	{
		Pixa RetObj = _All.pixaSelectWithIndicator(pixas, na, out pchanged);
		return RetObj;
	}

	// pixafunc1.c (1193, 1)
	// pixaSelectWithString(pixas, str, perror) as Pixa
	// pixaSelectWithString(PIXA *, const char *, l_int32 *) as PIXA *
	///  <summary>
	/// (1) Returns a pixa with copies of selected pix.<para/>
	///
	/// (2) Associated boxes are also copied, if fully populated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSelectWithString/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="str">[in] - string of indices into pixa, giving the pix to be selected</param>
	///  <param name="perror">[out][optional] - 1 if any indices are invalid 0 if all indices are valid</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa SelectWithString (Pixa pixas,
								  String str,
								  out int perror)
	{
		Pixa RetObj = _All.pixaSelectWithString(pixas, str, out perror);
		return RetObj;
	}

	// pixafunc1.c (1264, 1)
	// pixaRenderComponent(pixs, pixa, index) as Pix
	// pixaRenderComponent(PIX *, PIXA *, l_int32) as PIX *
	///  <summary>
	/// (1) If pixs is null, this generates an empty pix of a size determined
	/// by union of the component bounding boxes, and including the origin.<para/>
	///
	/// (2) The selected component is blitted into pixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaRenderComponent/*"/>
	///  <param name="pixs">[in][optional] - 1 bpp pix</param>
	///  <param name="index">[in] - of component to be rendered</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RenderComponent (int index,
								Pix pixs)
	{
		Pix RetObj = _All.pixaRenderComponent(pixs, this, index);
		return RetObj;
	}

	// pixafunc1.c (1334, 1)
	// pixaSort(pixas, sorttype, sortorder, pnaindex, copyflag) as Pixa
	// pixaSort(PIXA *, l_int32, l_int32, NUMA **, l_int32) as PIXA *
	///  <summary>
	/// (1) This sorts based on the data in the boxa.  If the boxa
	/// count is not the same as the pixa count, this returns an error.<para/>
	///
	/// (2) If the boxa is empty, it makes one corresponding to the
	/// dimensions of each pix, which allows meaningful sorting on
	/// all types except x and y.<para/>
	///
	/// (3) The copyflag refers to the pix and box copies that are
	/// inserted into the sorted pixa.  These are either L_COPY
	/// or L_CLONE.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSort/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="sorttype">[in] - L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER, L_SORT_BY_AREA, L_SORT_BY_ASPECT_RATIO</param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING, L_SORT_DECREASING</param>
	///  <param name="pnaindex">[out][optional] - index of sorted order into original array</param>
	///  <param name="copyflag">[in] - L_COPY, L_CLONE</param>
	///   <returns>pixad sorted version of pixas, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa Sort (Pixa pixas,
					  int sorttype,
					  int sortorder,
					  int copyflag,
					  out Numa pnaindex)
	{
		Pixa RetObj = _All.pixaSort(pixas, sorttype, sortorder, out pnaindex, copyflag);
		return RetObj;
	}

	// pixafunc1.c (1474, 1)
	// pixaBinSort(pixas, sorttype, sortorder, pnaindex, copyflag) as Pixa
	// pixaBinSort(PIXA *, l_int32, l_int32, NUMA **, l_int32) as PIXA *
	///  <summary>
	/// (1) This sorts based on the data in the boxa.  If the boxa
	/// count is not the same as the pixa count, this returns an error.<para/>
	///
	/// (2) The copyflag refers to the pix and box copies that are
	/// inserted into the sorted pixa.  These are either L_COPY
	/// or L_CLONE.<para/>
	///
	/// (3) For a large number of boxes (say, greater than 1000), this
	/// O(n) binsort is much faster than the O(nlogn) shellsort.
	/// For 5000 components, this is over 20x faster than boxaSort().<para/>
	///
	/// (4) Consequently, pixaSort() calls this function if it will
	/// likely go much faster.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaBinSort/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="sorttype">[in] - L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_PERIMETER</param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING, L_SORT_DECREASING</param>
	///  <param name="pnaindex">[out][optional] - index of sorted order into original array</param>
	///  <param name="copyflag">[in] - L_COPY, L_CLONE</param>
	///   <returns>pixad sorted version of pixas, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa BinSort (Pixa pixas,
						 int sorttype,
						 int sortorder,
						 int copyflag,
						 out Numa pnaindex)
	{
		Pixa RetObj = _All.pixaBinSort(pixas, sorttype, sortorder, out pnaindex, copyflag);
		return RetObj;
	}

	// pixafunc1.c (1562, 1)
	// pixaSortByIndex(pixas, naindex, copyflag) as Pixa
	// pixaSortByIndex(PIXA *, NUMA *, l_int32) as PIXA *
	///  <summary>
	/// pixaSortByIndex()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSortByIndex/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="naindex">[in] - na that maps from the new pixa to the input pixa</param>
	///  <param name="copyflag">[in] - L_COPY, L_CLONE</param>
	///   <returns>pixad sorted, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa SortByIndex (Pixa pixas,
							 Numa naindex,
							 int copyflag)
	{
		Pixa RetObj = _All.pixaSortByIndex(pixas, naindex, copyflag);
		return RetObj;
	}

	// pixafunc1.c (1603, 1)
	// pixaSort2dByIndex(pixas, naa, copyflag) as Pixaa
	// pixaSort2dByIndex(PIXA *, NUMAA *, l_int32) as PIXAA *
	///  <summary>
	/// pixaSort2dByIndex()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSort2dByIndex/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="naa">[in] - numaa that maps from the new pixaa to the input pixas</param>
	///  <param name="copyflag">[in] - L_CLONE or L_COPY</param>
	///   <returns>paa sorted, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixaa Sort2dByIndex (Pixa pixas,
								Numaa naa,
								int copyflag)
	{
		Pixaa RetObj = _All.pixaSort2dByIndex(pixas, naa, copyflag);
		return RetObj;
	}

	// pixafunc1.c (1668, 1)
	// pixaSelectRange(pixas, first, last, copyflag) as Pixa
	// pixaSelectRange(PIXA *, l_int32, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) The copyflag specifies what we do with each pix from pixas.
	/// Specifically, L_CLONE inserts a clone into pixad of each
	/// selected pix from pixas.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSelectRange/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="first">[in] - use 0 to select from the beginning</param>
	///  <param name="last">[in] - use 0 to select to the end</param>
	///  <param name="copyflag">[in] - L_COPY, L_CLONE</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa SelectRange (Pixa pixas,
							 int first,
							 int last,
							 int copyflag)
	{
		Pixa RetObj = _All.pixaSelectRange(pixas, first, last, copyflag);
		return RetObj;
	}

	// pixafunc1.c (1871, 1)
	// pixaScaleToSize(pixas, wd, hd) as Pixa
	// pixaScaleToSize(PIXA *, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) See pixaaScaleToSize()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaScaleToSize/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="wd">[in] - target width use 0 if using height as target</param>
	///  <param name="hd">[in] - target height use 0 if using width as target</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ScaleToSize (Pixa pixas,
							 int wd,
							 int hd)
	{
		Pixa RetObj = _All.pixaScaleToSize(pixas, wd, hd);
		return RetObj;
	}

	// pixafunc1.c (1916, 1)
	// pixaScaleToSizeRel(pixas, delw, delh) as Pixa
	// pixaScaleToSizeRel(PIXA *, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) If a requested change in a pix is not possible because
	/// either the requested width or height is smaller or equal 0, issue a
	/// warning and return a copy.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaScaleToSizeRel/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="delw">[in] - change in width, in pixels 0 means no change</param>
	///  <param name="delh">[in] - change in height, in pixels 0 means no change return  pixad, or NULL on error</param>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ScaleToSizeRel (Pixa pixas,
								int delw,
								int delh)
	{
		Pixa RetObj = _All.pixaScaleToSizeRel(pixas, delw, delh);
		return RetObj;
	}

	// pixafunc1.c (1960, 1)
	// pixaScale(pixas, scalex, scaley) as Pixa
	// pixaScale(PIXA *, l_float32, l_float32) as PIXA *
	///  <summary>
	/// (1) If pixas has a full boxes, it is scaled as well.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaScale/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="scalex">[in] - </param>
	///  <param name="scaley">[in] - </param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa Scale (Pixa pixas,
					   Single scalex,
					   Single scaley)
	{
		Pixa RetObj = _All.pixaScale(pixas, scalex, scaley);
		return RetObj;
	}

	// pixafunc1.c (2011, 1)
	// pixaScaleBySampling(pixas, scalex, scaley) as Pixa
	// pixaScaleBySampling(PIXA *, l_float32, l_float32) as PIXA *
	///  <summary>
	/// (1) If pixas has a full boxes, it is scaled as well.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaScaleBySampling/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="scalex">[in] - </param>
	///  <param name="scaley">[in] - </param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ScaleBySampling (Pixa pixas,
								 Single scalex,
								 Single scaley)
	{
		Pixa RetObj = _All.pixaScaleBySampling(pixas, scalex, scaley);
		return RetObj;
	}

	// pixafunc1.c (2076, 1)
	// pixaRotate(pixas, angle, type, incolor, width, height) as Pixa
	// pixaRotate(PIXA *, l_float32, l_int32, l_int32, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) Each pix is rotated about its center.  See pixRotate() for details.<para/>
	///
	/// (2) The boxa array is copied.  Why is it not rotated?
	/// If a boxa exists, the array of boxes is in 1-to-1
	/// correspondence with the array of pix, and each box typically
	/// represents the location of the pix relative to an image from
	/// which it has been extracted.  Like the pix, we could rotate
	/// each box around its center, and then generate a box that
	/// contains all four corners, as is done in boxaRotate(), but
	/// this seems unnecessary.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaRotate/*"/>
	///  <param name="pixas">[in] - 1, 2, 4, 8, 32 bpp rgb</param>
	///  <param name="angle">[in] - rotation angle in radians clockwise is positive</param>
	///  <param name="type">[in] - L_ROTATE_AREA_MAP, L_ROTATE_SHEAR, L_ROTATE_SAMPLING</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///  <param name="width">[in] - original width use 0 to avoid embedding</param>
	///  <param name="height">[in] - original height use 0 to avoid embedding</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa Rotate (Pixa pixas,
						Single angle,
						int type,
						int incolor,
						int width,
						int height)
	{
		Pixa RetObj = _All.pixaRotate(pixas, angle, type, incolor, width, height);
		return RetObj;
	}

	// pixafunc1.c (2134, 1)
	// pixaRotateOrth(pixas, rotation) as Pixa
	// pixaRotateOrth(PIXA *, l_int32) as PIXA *
	///  <summary>
	/// (1) Rotates each pix in the pixa.  Rotates and saves the boxes in
	/// the boxa if the boxa is full.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaRotateOrth/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="rotation">[in] - 0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg all rotations are clockwise</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa RotateOrth (Pixa pixas,
							int rotation)
	{
		Pixa RetObj = _All.pixaRotateOrth(pixas, rotation);
		return RetObj;
	}

	// pixafunc1.c (2186, 1)
	// pixaTranslate(pixas, hshift, vshift, incolor) as Pixa
	// pixaTranslate(PIXA *, l_int32, l_int32, l_int32) as PIXA *
	///  <summary>
	/// pixaTranslate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaTranslate/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="hshift">[in] - horizontal shift hshift  is greater  0 is to right</param>
	///  <param name="vshift">[in] - vertical shift vshift  is greater  0 is down</param>
	///  <param name="incolor">[in] - L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	///   <returns>pixad, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa Translate (Pixa pixas,
						   int hshift,
						   int vshift,
						   int incolor)
	{
		Pixa RetObj = _All.pixaTranslate(pixas, hshift, vshift, incolor);
		return RetObj;
	}

	// pixafunc1.c (2260, 1)
	// pixaAddBorderGeneral(pixad, pixas, left, right, top, bot, val) as Pixa
	// pixaAddBorderGeneral(PIXA *, PIXA *, l_int32, l_int32, l_int32, l_int32, l_uint32) as PIXA *
	///  <summary>
	/// (1) For binary images:
	/// white:  val = 0
	/// black:  val = 1
	/// For grayscale images:
	/// white:  val = 2  d - 1
	/// black:  val = 0
	/// For rgb color images:
	/// white:  val = 0xffffff00
	/// black:  val = 0
	/// For colormapped images, use 'index' found this way:
	/// white: pixcmapGetRankIntensity(cmap, 1.0, [and]index)
	/// black: pixcmapGetRankIntensity(cmap, 0.0, [and]index)<para/>
	///
	/// (2) For in-place replacement of each pix with a bordered version,
	/// use %pixad = %pixas.  To make a new pixa, use %pixad = NULL.<para/>
	///
	/// (3) In both cases, the boxa has sides adjusted as if it were
	/// expanded by the border.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaAddBorderGeneral/*"/>
	///  <param name="pixad">[in]can be null - or equal to pixas</param>
	///  <param name="pixas">[in] - containing pix of all depths colormap ok</param>
	///  <param name="left">[in] - number of pixels added</param>
	///  <param name="right">[in] - number of pixels added</param>
	///  <param name="top">[in] - number of pixels added</param>
	///  <param name="bot">[in] - number of pixels added</param>
	///  <param name="val">[in] - value of added border pixels</param>
	///   <returns>pixad with border added to each pix, including on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa AddBorderGeneral (Pixa pixas,
								  int left,
								  int right,
								  int top,
								  int bot,
								  uint val,
								  Pixa pixad)
	{
		Pixa RetObj = _All.pixaAddBorderGeneral(pixad, pixas, left, right, top, bot, val);
		return RetObj;
	}

	// pixafunc1.c (2440, 1)
	// pixaSizeRange(pixa, pminw, pminh, pmaxw, pmaxh) as int
	// pixaSizeRange(PIXA *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixaSizeRange()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSizeRange/*"/>
	///  <param name="pminw">[out][optional] - range of dimensions of pix in the array</param>
	///  <param name="pminh">[out][optional] - range of dimensions of pix in the array</param>
	///  <param name="pmaxw">[out][optional] - range of dimensions of pix in the array</param>
	///  <param name="pmaxh">[out][optional] - range of dimensions of pix in the array</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SizeRange (out int pminw,
						  out int pminh,
						  out int pmaxw,
						  out int pmaxh)
	{
		int RetObj = _All.pixaSizeRange(this, out pminw, out pminh, out pmaxw, out pmaxh);
		return RetObj;
	}

	// pixafunc1.c (2510, 1)
	// pixaClipToPix(pixas, pixs) as Pixa
	// pixaClipToPix(PIXA *, PIX *) as PIXA *
	///  <summary>
	/// (1) This is intended for use in situations where pixas
	/// was originally generated from the input pixs.<para/>
	///
	/// (2) Returns a pixad where each pix in pixas is ANDed
	/// with its associated region of the input pixs.  This
	/// region is specified by the the box that is associated
	/// with the pix.<para/>
	///
	/// (3) In a typical application of this function, pixas has
	/// a set of region masks, so this generates a pixa of
	/// the parts of pixs that correspond to each region
	/// mask component, along with the bounding box for
	/// the region.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaClipToPix/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="pixs">[in] - </param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ClipToPix (Pixa pixas,
						   Pix pixs)
	{
		Pixa RetObj = _All.pixaClipToPix(pixas, pixs);
		return RetObj;
	}

	// pixafunc1.c (2559, 1)
	// pixaClipToForeground(pixas, ppixad, pboxa) as int
	// pixaClipToForeground(PIXA *, PIXA **, BOXA **) as l_ok
	///  <summary>
	/// (1) At least one of [[and]pixd, [and]boxa] must be specified.<para/>
	///
	/// (2) Any pix with no fg pixels is skipped.<para/>
	///
	/// (3) See pixClipToForeground().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaClipToForeground/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="ppixad">[out][optional] - pixa of clipped pix returned</param>
	///  <param name="pboxa">[out][optional] - clipping boxes returned</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ClipToForeground (Pixa pixas,
								 out Pixa ppixad,
								 out Boxa pboxa)
	{
		int RetObj = _All.pixaClipToForeground(pixas, out ppixad, out pboxa);
		return RetObj;
	}

	// pixafunc1.c (2605, 1)
	// pixaGetRenderingDepth(pixa, pdepth) as int
	// pixaGetRenderingDepth(PIXA *, l_int32 *) as l_ok
	///  <summary>
	/// pixaGetRenderingDepth()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaGetRenderingDepth/*"/>
	///  <param name="pdepth">[out] - depth required to render if all colormaps are removed</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRenderingDepth (out int pdepth)
	{
		int RetObj = _All.pixaGetRenderingDepth(this, out pdepth);
		return RetObj;
	}

	// pixafunc1.c (2642, 1)
	// pixaHasColor(pixa, phascolor) as int
	// pixaHasColor(PIXA *, l_int32 *) as l_ok
	///  <summary>
	/// pixaHasColor()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaHasColor/*"/>
	///  <param name="phascolor">[out] - 1 if any pix is rgb or has a colormap with color 0 otherwise</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int HasColor (out int phascolor)
	{
		int RetObj = _All.pixaHasColor(this, out phascolor);
		return RetObj;
	}

	// pixafunc1.c (2683, 1)
	// pixaAnyColormaps(pixa, phascmap) as int
	// pixaAnyColormaps(PIXA *, l_int32 *) as l_ok
	///  <summary>
	/// pixaAnyColormaps()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaAnyColormaps/*"/>
	///  <param name="phascmap">[out] - 1 if any pix has a colormap 0 otherwise</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AnyColormaps (out int phascmap)
	{
		int RetObj = _All.pixaAnyColormaps(this, out phascmap);
		return RetObj;
	}

	// pixafunc1.c (2722, 1)
	// pixaGetDepthInfo(pixa, pmaxdepth, psame) as int
	// pixaGetDepthInfo(PIXA *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// pixaGetDepthInfo()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaGetDepthInfo/*"/>
	///  <param name="pmaxdepth">[out][optional] - max pixel depth of pix in pixa</param>
	///  <param name="psame">[out][optional] - true if all depths are equal</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetDepthInfo (out int pmaxdepth,
							 out int psame)
	{
		int RetObj = _All.pixaGetDepthInfo(this, out pmaxdepth, out psame);
		return RetObj;
	}

	// pixafunc1.c (2771, 1)
	// pixaConvertToSameDepth(pixas) as Pixa
	// pixaConvertToSameDepth(PIXA *) as PIXA *
	///  <summary>
	/// (1) If any pix has a colormap, they are all converted to rgb.
	/// Otherwise, they are all converted to the maximum depth of
	/// all the pix.<para/>
	///
	/// (2) This can be used to allow lossless rendering onto a single pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaConvertToSameDepth/*"/>
	///  <param name="pixas">[in] - </param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ConvertToSameDepth (Pixa pixas)
	{
		Pixa RetObj = _All.pixaConvertToSameDepth(pixas);
		return RetObj;
	}

	// pixafunc1.c (2851, 1)
	// pixaEqual(pixa1, pixa2, maxdist, pnaindex, psame) as int
	// pixaEqual(PIXA *, PIXA *, l_int32, NUMA **, l_int32 *) as l_ok
	///  <summary>
	/// (1) The two pixa are the "same" if they contain the same
	/// boxa and the same ordered set of pix.  However, if they
	/// have boxa, the pix in each pixa can differ in ordering
	/// by an amount given by the parameter %maxdist.  If they
	/// don't have a boxa, the %maxdist parameter is ignored,
	/// and the ordering must be identical.<para/>
	///
	/// (2) This applies only to boxa geometry, pixels and ordering
	/// other fields in the pix are ignored.<para/>
	///
	/// (3) naindex[i] gives the position of the box in pixa2 that
	/// corresponds to box i in pixa1.  It is only returned if the
	/// pixa have boxa and the boxa are equal.<para/>
	///
	/// (4) In situations where the ordering is very different, so that
	/// a large %maxdist is required for "equality", this should be
	/// implemented with a hash function for efficiency.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaEqual/*"/>
	///  <param name="pixa1">[in] - </param>
	///  <param name="pixa2">[in] - </param>
	///  <param name="maxdist">[in] - </param>
	///  <param name="pnaindex">[out][optional] - index array of correspondences</param>
	///  <param name="psame">[out] - 1 if equal 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Equal (Pixa pixa1,
					  Pixa pixa2,
					  int maxdist,
					  out int psame,
					  out Numa pnaindex)
	{
		int RetObj = _All.pixaEqual(pixa1, pixa2, maxdist, out pnaindex, out psame);
		return RetObj;
	}

	// pixafunc1.c (2936, 1)
	// pixaSetFullSizeBoxa(pixa) as int
	// pixaSetFullSizeBoxa(PIXA *) as l_ok
	///  <summary>
	/// (1) Replaces the existing boxa.  Each box gives the dimensions
	/// of the corresponding pix.  This is needed for functions
	/// like pixaSort() that sort based on the boxes.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSetFullSizeBoxa/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetFullSizeBoxa ()
	{
		int RetObj = _All.pixaSetFullSizeBoxa(this);
		return RetObj;
	}

	// pixafunc2.c (179, 1)
	// pixaDisplay(pixa, w, h) as Pix
	// pixaDisplay(PIXA *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This uses the boxes to place each pix in the rendered composite.<para/>
	///
	/// (2) Set w = h = 0 to use the b.b. of the components to determine
	/// the size of the returned pix.<para/>
	///
	/// (3) Uses the first pix in pixa to determine the depth.<para/>
	///
	/// (4) The background is written "white".  On 1 bpp, each successive
	/// pix is "painted" (adding foreground), whereas for grayscale
	/// or color each successive pix is blitted with just the src.<para/>
	///
	/// (5) If the pixa is empty, returns an empty 1 bpp pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplay/*"/>
	///  <param name="w">[in] - if set to 0, the size is determined from the bounding box of the components in pixa</param>
	///  <param name="h">[in] - if set to 0, the size is determined from the bounding box of the components in pixa</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Display (int w,
						int h)
	{
		Pix RetObj = _All.pixaDisplay(this, w, h);
		return RetObj;
	}

	// pixafunc2.c (259, 1)
	// pixaDisplayOnColor(pixa, w, h, bgcolor) as Pix
	// pixaDisplayOnColor(PIXA *, l_int32, l_int32, l_uint32) as PIX *
	///  <summary>
	/// (1) This uses the boxes to place each pix in the rendered composite.<para/>
	///
	/// (2) Set w = h = 0 to use the b.b. of the components to determine
	/// the size of the returned pix.<para/>
	///
	/// (3) If any pix in %pixa are colormapped, or if the pix have
	/// different depths, it returns a 32 bpp pix.  Otherwise,
	/// the depth of the returned pixa equals that of the pix in %pixa.<para/>
	///
	/// (4) If the pixa is empty, return null.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplayOnColor/*"/>
	///  <param name="w">[in] - if set to 0, the size is determined from the bounding box of the components in pixa</param>
	///  <param name="h">[in] - if set to 0, the size is determined from the bounding box of the components in pixa</param>
	///  <param name="bgcolor">[in] - background color to use</param>
	///   <returns>pix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayOnColor (int w,
							   int h,
							   uint bgcolor)
	{
		Pix RetObj = _All.pixaDisplayOnColor(this, w, h, bgcolor);
		return RetObj;
	}

	// pixafunc2.c (354, 1)
	// pixaDisplayRandomCmap(pixa, w, h) as Pix
	// pixaDisplayRandomCmap(PIXA *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This uses the boxes to place each pix in the rendered composite.
	/// The fg of each pix in %pixa, such as a single connected
	/// component or a line of text, is given a random color.<para/>
	///
	/// (2) By default, the background color is black (cmap index 0).
	/// This can be changed by pixcmapResetColor()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplayRandomCmap/*"/>
	///  <param name="w">[in] - if set to 0, the size is determined from the bounding box of the components in pixa</param>
	///  <param name="h">[in] - if set to 0, the size is determined from the bounding box of the components in pixa</param>
	///   <returns>pix   8 bpp, cmapped, with random colors assigned to each region, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayRandomCmap (int w,
								  int h)
	{
		Pix RetObj = _All.pixaDisplayRandomCmap(this, w, h);
		return RetObj;
	}

	// pixafunc2.c (428, 1)
	// pixaDisplayLinearly(pixas, direction, scalefactor, background, spacing, border, pboxa) as Pix
	// pixaDisplayLinearly(PIXA *, l_int32, l_float32, l_int32, l_int32, l_int32, BOXA **) as PIX *
	///  <summary>
	/// (1) This puts each pix, sequentially, in a line, either horizontally
	/// or vertically.<para/>
	///
	/// (2) If any pix has a colormap, all pix are rendered in rgb.<para/>
	///
	/// (3) The boxa gives the location of each image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplayLinearly/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="direction">[in] - L_HORIZ or L_VERT</param>
	///  <param name="scalefactor">[in] - applied to every pix use 1.0 for no scaling</param>
	///  <param name="background">[in] - 0 for white, 1 for black this is the color of the spacing between the images</param>
	///  <param name="spacing">[in] - between images, and on outside</param>
	///  <param name="border">[in] - width of black border added to each image use 0 for no border</param>
	///  <param name="pboxa">[out][optional] - location of images in output pix</param>
	///   <returns>pix of composite images, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayLinearly (Pixa pixas,
								int direction,
								Single scalefactor,
								int background,
								int spacing,
								int border,
								out Boxa pboxa)
	{
		Pix RetObj = _All.pixaDisplayLinearly(pixas, direction, scalefactor, background, spacing, border, out pboxa);
		return RetObj;
	}

	// pixafunc2.c (522, 1)
	// pixaDisplayOnLattice(pixa, cellw, cellh, pncols, pboxa) as Pix
	// pixaDisplayOnLattice(PIXA *, l_int32, l_int32, l_int32 *, BOXA **) as PIX *
	///  <summary>
	/// (1) This places each pix on sequentially on a regular lattice
	/// in the rendered composite.  If a pix is too large to fit in the
	/// allocated lattice space, it is not rendered.<para/>
	///
	/// (2) If any pix has a colormap, all pix are rendered in rgb.<para/>
	///
	/// (3) This is useful when putting bitmaps of components,
	/// such as characters, into a single image.<para/>
	///
	/// (4) The boxa gives the location of each image.  The UL corner
	/// of each image is on a lattice cell corner.  Omitted images
	/// (due to size) are assigned an invalid width and height of 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplayOnLattice/*"/>
	///  <param name="cellw">[in] - lattice cell width</param>
	///  <param name="cellh">[in] - lattice cell height</param>
	///  <param name="pncols">[out][optional] - number of columns in output lattice</param>
	///  <param name="pboxa">[out][optional] - location of images in lattice</param>
	///   <returns>pix of composite images, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayOnLattice (int cellw,
								 int cellh,
								 out int pncols,
								 out Boxa pboxa)
	{
		Pix RetObj = _All.pixaDisplayOnLattice(this, cellw, cellh, out pncols, out pboxa);
		return RetObj;
	}

	// pixafunc2.c (633, 1)
	// pixaDisplayUnsplit(pixa, nx, ny, borderwidth, bordercolor) as Pix
	// pixaDisplayUnsplit(PIXA *, l_int32, l_int32, l_int32, l_uint32) as PIX *
	///  <summary>
	/// (1) This is a logical inverse of pixaSplitPix().  It
	/// constructs a pix from a mosaic of tiles, all of equal size.<para/>
	///
	/// (2) For added generality, a border of arbitrary color can
	/// be added to each of the tiles.<para/>
	///
	/// (3) In use, pixa will typically have either been generated
	/// from pixaSplitPix() or will derived from a pixa that
	/// was so generated.<para/>
	///
	/// (4) All pix in the pixa must be of equal depth, and, if
	/// colormapped, have the same colormap.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplayUnsplit/*"/>
	///  <param name="nx">[in] - number of mosaic cells horizontally</param>
	///  <param name="ny">[in] - number of mosaic cells vertically</param>
	///  <param name="borderwidth">[in] - of added border on all sides</param>
	///  <param name="bordercolor">[in] - in our RGBA format: 0xrrggbbaa</param>
	///   <returns>pix of tiled images, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayUnsplit (int nx,
							   int ny,
							   int borderwidth,
							   uint bordercolor)
	{
		Pix RetObj = _All.pixaDisplayUnsplit(this, nx, ny, borderwidth, bordercolor);
		return RetObj;
	}

	// pixafunc2.c (708, 1)
	// pixaDisplayTiled(pixa, maxwidth, background, spacing) as Pix
	// pixaDisplayTiled(PIXA *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This renders a pixa to a single image of width not to
	/// exceed maxwidth, with background color either white or black,
	/// and with each subimage spaced on a regular lattice.<para/>
	///
	/// (2) The lattice size is determined from the largest width and height,
	/// separately, of all pix in the pixa.<para/>
	///
	/// (3) All pix in the pixa must be of equal depth.<para/>
	///
	/// (4) If any pix has a colormap, all pix are rendered in rgb.<para/>
	///
	/// (5) Careful: because no components are omitted, this is
	/// dangerous if there are thousands of small components and
	/// one or more very large one, because the size of the
	/// resulting pix can be huge!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplayTiled/*"/>
	///  <param name="maxwidth">[in] - of output image</param>
	///  <param name="background">[in] - 0 for white, 1 for black</param>
	///  <param name="spacing">[in] - </param>
	///   <returns>pix of tiled images, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayTiled (int maxwidth,
							 int background,
							 int spacing)
	{
		Pix RetObj = _All.pixaDisplayTiled(this, maxwidth, background, spacing);
		return RetObj;
	}

	// pixafunc2.c (822, 1)
	// pixaDisplayTiledInRows(pixa, outdepth, maxwidth, scalefactor, background, spacing, border) as Pix
	// pixaDisplayTiledInRows(PIXA *, l_int32, l_int32, l_float32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This renders a pixa to a single image of width not to
	/// exceed maxwidth, with background color either white or black,
	/// and with each row tiled such that the top of each pix is
	/// aligned and separated by 'spacing' from the next one.
	/// A black border can be added to each pix.<para/>
	///
	/// (2) All pix are converted to outdepth existing colormaps are removed.<para/>
	///
	/// (3) This does a reasonably spacewise-efficient job of laying
	/// out the individual pix images into a tiled composite.<para/>
	///
	/// (4) A serialized boxa giving the location in pixd of each input
	/// pix (without added border) is stored in the text string of pixd.
	/// This allows, e.g., regeneration of a pixa from pixd, using
	/// pixaCreateFromBoxa().  If there is no scaling and the depth of
	/// each input pix in the pixa is the same, this tiling operation
	/// can be inverted using the boxa (except for loss of text in
	/// each of the input pix):
	/// pix1 = pixaDisplayTiledInRows(pixa1, 1, 1500, 1.0, 0, 30, 0)
	/// char boxatxt = pixGetText(pix1)
	/// boxa1 = boxaReadMem((l_uint8 )boxatxt, strlen(boxatxt))
	/// pixa2 = pixaCreateFromBoxa(pix1, boxa1, NULL)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplayTiledInRows/*"/>
	///  <param name="outdepth">[in] - output depth: 1, 8 or 32 bpp</param>
	///  <param name="maxwidth">[in] - of output image</param>
	///  <param name="scalefactor">[in] - applied to every pix use 1.0 for no scaling</param>
	///  <param name="background">[in] - 0 for white, 1 for black this is the color of the spacing between the images</param>
	///  <param name="spacing">[in] - between images, and on outside</param>
	///  <param name="border">[in] - width of black border added to each image use 0 for no border</param>
	///   <returns>pixd of tiled images, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayTiledInRows (int outdepth,
								   int maxwidth,
								   Single scalefactor,
								   int background,
								   int spacing,
								   int border)
	{
		Pix RetObj = _All.pixaDisplayTiledInRows(this, outdepth, maxwidth, scalefactor, background, spacing, border);
		return RetObj;
	}

	// pixafunc2.c (1006, 1)
	// pixaDisplayTiledInColumns(pixas, nx, scalefactor, spacing, border) as Pix
	// pixaDisplayTiledInColumns(PIXA *, l_int32, l_float32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This renders a pixa to a single image with [and]nx columns of
	/// subimages.  The background color is white, and each row
	/// is tiled such that the top of each pix is aligned and
	/// each pix is separated by 'spacing' from the next one.
	/// A black border can be added to each pix.<para/>
	///
	/// (2) The output depth is determined by the largest depth
	/// required by the pix in the pixa.  Colormaps are removed.<para/>
	///
	/// (3) A serialized boxa giving the location in pixd of each input
	/// pix (without added border) is stored in the text string of pixd.
	/// This allows, e.g., regeneration of a pixa from pixd, using
	/// pixaCreateFromBoxa().  If there is no scaling and the depth of
	/// each input pix in the pixa is the same, this tiling operation
	/// can be inverted using the boxa (except for loss of text in
	/// each of the input pix):
	/// pix1 = pixaDisplayTiledInColumns(pixa1, 3, 1.0, 0, 30, 2)
	/// char boxatxt = pixGetText(pix1)
	/// boxa1 = boxaReadMem((l_uint8 )boxatxt, strlen(boxatxt))
	/// pixa2 = pixaCreateFromBoxa(pix1, boxa1, NULL)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplayTiledInColumns/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="nx">[in] - number of columns in output image</param>
	///  <param name="scalefactor">[in] - applied to every pix use 1.0 for no scaling</param>
	///  <param name="spacing">[in] - between images, and on outside</param>
	///  <param name="border">[in] - width of black border added to each image use 0 for no border</param>
	///   <returns>pixd of tiled images, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayTiledInColumns (Pixa pixas,
									  int nx,
									  Single scalefactor,
									  int spacing,
									  int border)
	{
		Pix RetObj = _All.pixaDisplayTiledInColumns(pixas, nx, scalefactor, spacing, border);
		return RetObj;
	}

	// pixafunc2.c (1123, 1)
	// pixaDisplayTiledAndScaled(pixa, outdepth, tilewidth, ncols, background, spacing, border) as Pix
	// pixaDisplayTiledAndScaled(PIXA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) This can be used to tile a number of renderings of
	/// an image that are at different scales and depths.<para/>
	///
	/// (2) Each image, after scaling and optionally adding the
	/// black border, has width 'tilewidth'.  Thus, the border does
	/// not affect the spacing between the image tiles.  The
	/// maximum allowed border width is tilewidth / 5.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplayTiledAndScaled/*"/>
	///  <param name="outdepth">[in] - output depth: 1, 8 or 32 bpp</param>
	///  <param name="tilewidth">[in] - each pix is scaled to this width</param>
	///  <param name="ncols">[in] - number of tiles in each row</param>
	///  <param name="background">[in] - 0 for white, 1 for black this is the color of the spacing between the images</param>
	///  <param name="spacing">[in] - between images, and on outside</param>
	///  <param name="border">[in] - width of additional black border on each image use 0 for no border</param>
	///   <returns>pix of tiled images, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayTiledAndScaled (int outdepth,
									  int tilewidth,
									  int ncols,
									  int background,
									  int spacing,
									  int border)
	{
		Pix RetObj = _All.pixaDisplayTiledAndScaled(this, outdepth, tilewidth, ncols, background, spacing, border);
		return RetObj;
	}

	// pixafunc2.c (1278, 1)
	// pixaDisplayTiledWithText(pixa, maxwidth, scalefactor, spacing, border, fontsize, textcolor) as Pix
	// pixaDisplayTiledWithText(PIXA *, l_int32, l_float32, l_int32, l_int32, l_int32, l_uint32) as PIX *
	///  <summary>
	/// (1) This is a version of pixaDisplayTiledInRows() that prints, below
	/// each pix, the text in the pix text field.  Up to 127 chars
	/// of text in the pix text field are rendered below each pix.<para/>
	///
	/// (2) It renders a pixa to a single image of width not to
	/// exceed %maxwidth, with white background color, with each row
	/// tiled such that the top of each pix is aligned and separated
	/// by %spacing from the next one.<para/>
	///
	/// (3) All pix are converted to 32 bpp.<para/>
	///
	/// (4) This does a reasonably spacewise-efficient job of laying
	/// out the individual pix images into a tiled composite.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplayTiledWithText/*"/>
	///  <param name="maxwidth">[in] - of output image</param>
	///  <param name="scalefactor">[in] - applied to every pix use 1.0 for no scaling</param>
	///  <param name="spacing">[in] - between images, and on outside</param>
	///  <param name="border">[in] - width of black border added to each image use 0 for no border</param>
	///  <param name="fontsize">[in] - 4, 6, ... 20</param>
	///  <param name="textcolor">[in] - 0xrrggbb00</param>
	///   <returns>pixd of tiled images, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayTiledWithText (int maxwidth,
									 Single scalefactor,
									 int spacing,
									 int border,
									 int fontsize,
									 uint textcolor)
	{
		Pix RetObj = _All.pixaDisplayTiledWithText(this, maxwidth, scalefactor, spacing, border, fontsize, textcolor);
		return RetObj;
	}

	// pixafunc2.c (1377, 1)
	// pixaDisplayTiledByIndex(pixa, na, width, spacing, border, fontsize, textcolor) as Pix
	// pixaDisplayTiledByIndex(PIXA *, NUMA *, l_int32, l_int32, l_int32, l_int32, l_uint32) as PIX *
	///  <summary>
	/// (1) This renders a pixa to a single image with white
	/// background color, where the pix are placed in columns
	/// given by the index value in the numa.  Each pix
	/// is separated by %spacing from the adjacent ones, and
	/// an optional border is placed around them.<para/>
	///
	/// (2) Up to 127 chars of text in the pix text field are rendered
	/// below each pix.  Use newlines in the text field to write
	/// the text in multiple lines that fit within the pix width.<para/>
	///
	/// (3) To avoid having empty columns, if there are N different
	/// index values, they should be in [0 ... N-1].<para/>
	///
	/// (4) All pix are converted to 32 bpp.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplayTiledByIndex/*"/>
	///  <param name="na">[in] - numa with indices corresponding to the pix in pixa</param>
	///  <param name="width">[in] - each pix is scaled to this width</param>
	///  <param name="spacing">[in] - between images, and on outside</param>
	///  <param name="border">[in] - width of black border added to each image use 0 for no border</param>
	///  <param name="fontsize">[in] - 4, 6, ... 20</param>
	///  <param name="textcolor">[in] - 0xrrggbb00</param>
	///   <returns>pixd of tiled images, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayTiledByIndex (Numa na,
									int width,
									int spacing,
									int border,
									int fontsize,
									uint textcolor)
	{
		Pix RetObj = _All.pixaDisplayTiledByIndex(this, na, width, spacing, border, fontsize, textcolor);
		return RetObj;
	}

	// pixafunc2.c (1761, 1)
	// pixaConvertTo1(pixas, thresh) as Pixa
	// pixaConvertTo1(PIXA *, l_int32) as PIXA *
	///  <summary>
	/// pixaConvertTo1()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaConvertTo1/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="thresh">[in] - threshold for final binarization from 8 bpp gray</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ConvertTo1 (Pixa pixas,
							int thresh)
	{
		Pixa RetObj = _All.pixaConvertTo1(pixas, thresh);
		return RetObj;
	}

	// pixafunc2.c (1802, 1)
	// pixaConvertTo8(pixas, cmapflag) as Pixa
	// pixaConvertTo8(PIXA *, l_int32) as PIXA *
	///  <summary>
	/// (1) See notes for pixConvertTo8(), applied to each pix in pixas.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaConvertTo8/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="cmapflag">[in] - 1 to give pixd a colormap 0 otherwise</param>
	///   <returns>pixad each pix is 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ConvertTo8 (Pixa pixas,
							int cmapflag)
	{
		Pixa RetObj = _All.pixaConvertTo8(pixas, cmapflag);
		return RetObj;
	}

	// pixafunc2.c (1843, 1)
	// pixaConvertTo8Colormap(pixas, dither) as Pixa
	// pixaConvertTo8Colormap(PIXA *, l_int32) as PIXA *
	///  <summary>
	/// (1) See notes for pixConvertTo8Colormap(), applied to each pix in pixas.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaConvertTo8Colormap/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="dither">[in] - 1 to dither if necessary 0 otherwise</param>
	///   <returns>pixad each pix is 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ConvertTo8Colormap (Pixa pixas,
									int dither)
	{
		Pixa RetObj = _All.pixaConvertTo8Colormap(pixas, dither);
		return RetObj;
	}

	// pixafunc2.c (1885, 1)
	// pixaConvertTo32(pixas) as Pixa
	// pixaConvertTo32(PIXA *) as PIXA *
	///  <summary>
	/// (1) See notes for pixConvertTo32(), applied to each pix in pixas.<para/>
	///
	/// (2) This can be used to allow 1 bpp pix in a pixa to be displayed
	/// with color.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaConvertTo32/*"/>
	///  <param name="pixas">[in] - </param>
	///   <returns>pixad 32 bpp rgb, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ConvertTo32 (Pixa pixas)
	{
		Pixa RetObj = _All.pixaConvertTo32(pixas);
		return RetObj;
	}

	// pixafunc2.c (1938, 1)
	// pixaConstrainedSelect(pixas, first, last, nmax, use_pairs, copyflag) as Pixa
	// pixaConstrainedSelect(PIXA *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) See notes in genConstrainedNumaInRange() for how selection
	/// is made.<para/>
	///
	/// (2) This returns a selection of the pix in the input pixa.<para/>
	///
	/// (3) Use copyflag == L_COPY if you don't want changes in the pix
	/// in the returned pixa to affect those in the input pixa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaConstrainedSelect/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="first">[in] - first index to choose greater or equal 0</param>
	///  <param name="last">[in] - biggest possible index to reach use -1 to go to the end otherwise, last greater or equal first</param>
	///  <param name="nmax">[in] - maximum number of pix to select  is greater  0</param>
	///  <param name="use_pairs">[in] - 1 = select pairs of adjacent pix 0 = select individual pix</param>
	///  <param name="copyflag">[in] - L_COPY, L_CLONE</param>
	///   <returns>pixad if OK, NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ConstrainedSelect (Pixa pixas,
								   int first,
								   int last,
								   int nmax,
								   int use_pairs,
								   int copyflag)
	{
		Pixa RetObj = _All.pixaConstrainedSelect(pixas, first, last, nmax, use_pairs, copyflag);
		return RetObj;
	}

	// pixafunc2.c (2006, 1)
	// pixaSelectToPdf(pixas, first, last, res, scalefactor, type, quality, color, fontsize, fileout) as int
	// pixaSelectToPdf(PIXA *, l_int32, l_int32, l_int32, l_float32, l_int32, l_int32, l_uint32, l_int32, const char *) as l_ok
	///  <summary>
	/// (1) This writes a pdf of the selected images from %pixas, one to
	/// a page.  They are optionally scaled and annotated with the
	/// index printed to the left of the image.<para/>
	///
	/// (2) If the input images are 1 bpp and you want the numbers to be
	/// in color, first promote each pix to 8 bpp with a colormap:
	/// pixa1 = pixaConvertTo8(pixas, 1)
	/// and then call this function with the specified color
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSelectToPdf/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="first">[in] - first index to choose greater or equal 0</param>
	///  <param name="last">[in] - biggest possible index to reach use -1 to go to the end otherwise, last greater or equal first</param>
	///  <param name="res">[in] - override the resolution of each input image, in ppi use 0 to respect the resolution embedded in the input</param>
	///  <param name="scalefactor">[in] - scaling factor applied to each image  is greater  0.0</param>
	///  <param name="type">[in] - encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	///  <param name="quality">[in] - used for JPEG only 0 for default (75)</param>
	///  <param name="color">[in] - of numbers added to each image (e.g., 0xff000000)</param>
	///  <param name="fontsize">[in] - to print number below each image.  The valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	///  <param name="fileout">[in] - pdf file of all images</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SelectToPdf (Pixa pixas,
							int first,
							int last,
							int res,
							Single scalefactor,
							int type,
							uint color,
							int fontsize,
							String fileout,
							int quality)
	{
		int RetObj = _All.pixaSelectToPdf(pixas, first, last, res, scalefactor, type, quality, color, fontsize, fileout);
		return RetObj;
	}

	// pixafunc2.c (2086, 1)
	// pixaDisplayMultiTiled(pixas, nx, ny, maxw, maxh, scalefactor, spacing, border) as Pixa
	// pixaDisplayMultiTiled(PIXA *, l_int32, l_int32, l_int32, l_int32, l_float32, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) Each set of %nx  %ny images is optionally scaled and saved
	/// into a new pix, and then aggregated.<para/>
	///
	/// (2) Set %maxw = %maxh = 0 if you want to include all pix from %pixs.<para/>
	///
	/// (3) This is useful for generating a pdf from the output pixa, where
	/// each page is a tile of (%nx  %ny) images from the input pixa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaDisplayMultiTiled/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="nx">[in] - in [1, ... 50], tiling factors in each direction</param>
	///  <param name="ny">[in] - in [1, ... 50], tiling factors in each direction</param>
	///  <param name="maxw">[in] - max sizes to keep</param>
	///  <param name="maxh">[in] - max sizes to keep</param>
	///  <param name="scalefactor">[in] - scale each image by this</param>
	///  <param name="spacing">[in] - between images, and on outside</param>
	///  <param name="border">[in] - width of additional black border on each image use 0 for no border</param>
	///   <returns>pixad if OK, NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa DisplayMultiTiled (Pixa pixas,
								   int nx,
								   int ny,
								   int maxw,
								   int maxh,
								   Single scalefactor,
								   int spacing,
								   int border)
	{
		Pixa RetObj = _All.pixaDisplayMultiTiled(pixas, nx, ny, maxw, maxh, scalefactor, spacing, border);
		return RetObj;
	}

	// pixafunc2.c (2165, 1)
	// pixaSplitIntoFiles(pixas, nsplit, scale, outwidth, write_pixa, write_pix, write_pdf) as int
	// pixaSplitIntoFiles(PIXA *, l_int32, l_float32, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) For each requested output, %nsplit files are written into
	/// directory /tmp/lept/split/.<para/>
	///
	/// (2) This is useful when a pixa is so large that the images
	/// are not conveniently displayed as a single tiled image at
	/// full resolution.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSplitIntoFiles/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="nsplit">[in] - split pixas into this number of pixa greater or equal 2</param>
	///  <param name="scale">[in] - scalefactor applied to each pix</param>
	///  <param name="outwidth">[in] - the maxwidth parameter of tiled images for write_pix</param>
	///  <param name="write_pixa">[in] - 1 to write the split pixa as separate files</param>
	///  <param name="write_pix">[in] - 1 to write tiled images of the split pixa</param>
	///  <param name="write_pdf">[in] - 1 to write pdfs of the split pixa</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SplitIntoFiles (Pixa pixas,
							   int nsplit,
							   Single scale,
							   int outwidth,
							   int write_pixa,
							   int write_pix,
							   int write_pdf)
	{
		int RetObj = _All.pixaSplitIntoFiles(pixas, nsplit, scale, outwidth, write_pixa, write_pix, write_pdf);
		return RetObj;
	}

	// pixafunc2.c (2382, 1)
	// pixaConvertToNUpPixa(pixas, sa, nx, ny, tw, spacing, border, fontsize) as Pixa
	// pixaConvertToNUpPixa(PIXA *, SARRAY *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) This takes an input pixa and an optional array of strings, and
	/// generates a pixa of NUp tiles from the input, labeled with
	/// the strings if they exist and %fontsize != 0.<para/>
	///
	/// (2) See notes for convertToNUpFiles()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaConvertToNUpPixa/*"/>
	///  <param name="pixas">[in] - </param>
	///  <param name="sa">[in][optional] - array of strings associated with each pix</param>
	///  <param name="nx">[in] - in [1, ... 50], tiling factors in each direction</param>
	///  <param name="ny">[in] - in [1, ... 50], tiling factors in each direction</param>
	///  <param name="tw">[in] - target width, in pixels must be greater or equal 20</param>
	///  <param name="spacing">[in] - between images, and on outside</param>
	///  <param name="border">[in] - width of additional black border on each image use 0 for no border</param>
	///  <param name="fontsize">[in] - to print string with each image.  Valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	///   <returns>pixad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ConvertToNUpPixa (Pixa pixas,
								  int nx,
								  int ny,
								  int tw,
								  int spacing,
								  int border,
								  int fontsize,
								  Sarray sa)
	{
		Pixa RetObj = _All.pixaConvertToNUpPixa(pixas, sa, nx, ny, tw, spacing, border, fontsize);
		return RetObj;
	}

	// pixafunc2.c (2495, 1)
	// pixaCompareInPdf(pixa1, pixa2, nx, ny, tw, spacing, border, fontsize, fileout) as int
	// pixaCompareInPdf(PIXA *, PIXA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, const char *) as l_ok
	///  <summary>
	/// (1) This takes two pixa and renders them interleaved, side-by-side
	/// in a pdf.  A warning is issued if the input pixa arrays
	/// have different lengths.<para/>
	///
	/// (2) %nx and %ny specify how many side-by-side pairs are displayed
	/// on each pdf page.  For example, if %nx = 1 and %ny = 2, then
	/// two pairs are shown, one above the other, on each page.<para/>
	///
	/// (3) The input pix are scaled to a target width of %tw, and
	/// then paired with optional %spacing between and optional
	/// black border of width %border.<para/>
	///
	/// (4) After a pixa is generated of these tiled images, it is
	/// written to %fileout as a pdf.<para/>
	///
	/// (5) Typical numbers for the input parameters are:
	/// %nx = small integer (1 - 4)
	/// %ny = 2  %nx
	/// %tw = 200 - 500 pixels
	/// %spacing = 10
	/// %border = 2
	/// %fontsize = 10<para/>
	///
	/// (6) If %fontsize != 0, the index of the pix pair in their pixa
	/// is printed out below each pair.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaCompareInPdf/*"/>
	///  <param name="pixa1">[in] - </param>
	///  <param name="pixa2">[in] - </param>
	///  <param name="nx">[in] - in [1, ... 20], tiling factors in each direction</param>
	///  <param name="ny">[in] - in [1, ... 20], tiling factors in each direction</param>
	///  <param name="tw">[in] - target width, in pixels must be greater or equal 20</param>
	///  <param name="spacing">[in] - between images, and on outside</param>
	///  <param name="border">[in] - width of additional black border on each image and on each pair use 0 for no border</param>
	///  <param name="fontsize">[in] - to print index of each pair of images.  Valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	///  <param name="fileout">[in] - output pdf file</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CompareInPdf (Pixa pixa1,
							 Pixa pixa2,
							 int nx,
							 int ny,
							 int tw,
							 int spacing,
							 int border,
							 int fontsize,
							 String fileout)
	{
		int RetObj = _All.pixaCompareInPdf(pixa1, pixa2, nx, ny, tw, spacing, border, fontsize, fileout);
		return RetObj;
	}

	// pixcomp.c (1466, 1)
	// pixaCreateFromPixacomp(pixac, accesstype) as Pixa
	// pixaCreateFromPixacomp(PIXAC *, l_int32) as PIXA *
	///  <summary>
	/// (1) Because the pixa has no notion of offset, the offset must
	/// be set to 0 before the conversion, so that pixacompGetPix()
	/// fetches all the pixcomps.  It is reset at the end.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaCreateFromPixacomp/*"/>
	///  <param name="pixac">[in] - </param>
	///  <param name="accesstype">[in] - L_COPY, L_CLONE, L_COPY_CLONE for boxa</param>
	///   <returns>pixa if OK, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa CreateFromPixacomp (PixaComp pixac,
									int accesstype)
	{
		Pixa RetObj = _All.pixaCreateFromPixacomp(pixac, accesstype);
		return RetObj;
	}

	// psio1.c (935, 1)
	// pixaWriteCompressedToPS(pixa, fileout, res, level) as int
	// pixaWriteCompressedToPS(PIXA *, const char *, l_int32, l_int32) as l_ok
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaWriteCompressedToPS/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteCompressedToPS (String fileout,
									int res,
									int level)
	{
		int RetObj = _All.pixaWriteCompressedToPS(this, fileout, res, level);
		return RetObj;
	}

	// readfile.c (123, 1)
	// pixaReadFiles(dirname, substr) as Pixa
	// pixaReadFiles(const char *, const char *) as PIXA *
	///  <summary>
	/// (1) %dirname is the full path for the directory.<para/>
	///
	/// (2) %substr is the part of the file name (excluding
	/// the directory) that is to be matched.  All matching
	/// filenames are read into the Pixa.  If substr is NULL,
	/// all filenames are read into the Pixa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaReadFiles/*"/>
	///  <param name="dirname">[in] - </param>
	///  <param name="substr">[in][optional] - substring filter on filenames can be null</param>
	///   <returns>pixa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ReadFiles (String dirname,
						   String substr)
	{
		Pixa RetObj = _All.pixaReadFiles(dirname, substr);
		return RetObj;
	}

	// readfile.c (150, 1)
	// pixaReadFilesSA(sa) as Pixa
	// pixaReadFilesSA(SARRAY *) as PIXA *
	///  <summary>
	/// pixaReadFilesSA()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaReadFilesSA/*"/>
	///  <param name="sa">[in] - full pathnames for all files</param>
	///   <returns>pixa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ReadFilesSA (Sarray sa)
	{
		Pixa RetObj = _All.pixaReadFilesSA(sa);
		return RetObj;
	}

	// recogtrain.c (664, 1)
	// pixaAccumulateSamples(pixa, pta, ppixd, px, py) as int
	// pixaAccumulateSamples(PIXA *, PTA *, PIX **, l_float32 *, l_float32 *) as l_int32
	///  <summary>
	/// (1) This generates an aligned (by centroid) sum of the input pix.<para/>
	///
	/// (2) We use only the first 256 samples that's plenty.<para/>
	///
	/// (3) If pta is not input, we generate two tables, and discard
	/// after use.  If this is called many times, it is better
	/// to precompute the pta.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaAccumulateSamples/*"/>
	///  <param name="pta">[in][optional] - of centroids of the samples</param>
	///  <param name="ppixd">[out] - accumulated samples, 8 bpp</param>
	///  <param name="px">[out][optional] - average x coordinate of centroids</param>
	///  <param name="py">[out][optional] - average y coordinate of centroids</param>
	///   <returns>0 on success, 1 on failure</returns>
	// CreateAdditiveFunction: Function/Else
	public int AccumulateSamples (out Pix ppixd,
								  Pta pta,
								  out Single px,
								  out Single py)
	{
		int RetObj = _All.pixaAccumulateSamples(this, pta, out ppixd, out px, out py);
		return RetObj;
	}

	// recogtrain.c (1159, 1)
	// pixaRemoveOutliers1(pixas, minscore, mintarget, minsize, ppixsave, ppixrem) as Pixa
	// pixaRemoveOutliers1(PIXA *, l_float32, l_int32, l_int32, PIX **, PIX **) as PIXA *
	///  <summary>
	/// (1) Removing outliers is particularly important when recognition
	/// goes against all the samples in the training set, as opposed
	/// to the averages for each class.  The reason is that we get
	/// an identification error if a mislabeled template is a best
	/// match for an input sample.<para/>
	///
	/// (2) Because the score values depend strongly on the quality
	/// of the character images, to avoid losing too many samples
	/// we supplement a minimum score for retention with a score
	/// necessary to acquire the minimum target number of templates.
	/// To do this we are willing to use a lower threshold,
	/// LOWER_SCORE_THRESHOLD, on the score.  Consequently, with
	/// poor quality templates, we may keep samples with a score
	/// less than %minscore, but never less than LOWER_SCORE_THRESHOLD.
	/// And if the number of samples is less than %minsize, we do
	/// not use any.<para/>
	///
	/// (3) This is meant to be used on a BAR, where the templates all
	/// come from the same book use minscore ~0.75.<para/>
	///
	/// (4) Method: make a scaled recog from the input %pixas.  Then,
	/// for each class: generate the averages, match each
	/// scaled template against the average, and save unscaled
	/// templates that had a sufficiently good match.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaRemoveOutliers1/*"/>
	///  <param name="pixas">[in] - unscaled labeled templates</param>
	///  <param name="minscore">[in] - keep everything with at least this score use -1.0 for default.</param>
	///  <param name="mintarget">[in] - minimum desired number to retain if possible use -1 for default.</param>
	///  <param name="minsize">[in] - minimum number of samples required for a class use -1 for default.</param>
	///  <param name="ppixsave">[out][optional debug] - saved templates, with scores</param>
	///  <param name="ppixrem">[out][optional debug] - removed templates, with scores</param>
	///   <returns>pixa   of unscaled templates to be kept, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa RemoveOutliers1 (Pixa pixas,
								 Single minscore,
								 int mintarget,
								 int minsize,
								 out Pix ppixsave,
								 out Pix ppixrem)
	{
		Pixa RetObj = _All.pixaRemoveOutliers1(pixas, minscore, mintarget, minsize, out ppixsave, out ppixrem);
		return RetObj;
	}

	// recogtrain.c (1363, 1)
	// pixaRemoveOutliers2(pixas, minscore, minsize, ppixsave, ppixrem) as Pixa
	// pixaRemoveOutliers2(PIXA *, l_float32, l_int32, PIX **, PIX **) as PIXA *
	///  <summary>
	/// (1) Removing outliers is particularly important when recognition
	/// goes against all the samples in the training set, as opposed
	/// to the averages for each class.  The reason is that we get
	/// an identification error if a mislabeled template is a best
	/// match for an input sample.<para/>
	///
	/// (2) This method compares each template against the average templates
	/// of each class, and discards any template that has a higher
	/// correlation to a class different from its own.  It also
	/// sets a lower bound on correlation scores with its class average.<para/>
	///
	/// (3) This is meant to be used on a BAR, where the templates all
	/// come from the same book use minscore ~0.75.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaRemoveOutliers2/*"/>
	///  <param name="pixas">[in] - unscaled labeled templates</param>
	///  <param name="minscore">[in] - keep everything with at least this score use -1.0 for default.</param>
	///  <param name="minsize">[in] - minimum number of samples required for a class use -1 for default.</param>
	///  <param name="ppixsave">[out][optional debug] - saved templates, with scores</param>
	///  <param name="ppixrem">[out][optional debug] - removed templates, with scores</param>
	///   <returns>pixa   of unscaled templates to be kept, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa RemoveOutliers2 (Pixa pixas,
								 Single minscore,
								 int minsize,
								 out Pix ppixsave,
								 out Pix ppixrem)
	{
		Pixa RetObj = _All.pixaRemoveOutliers2(pixas, minscore, minsize, out ppixsave, out ppixrem);
		return RetObj;
	}

	// strokes.c (208, 1)
	// pixaFindStrokeWidth(pixa, thresh, tab8, debug) as Numa
	// pixaFindStrokeWidth(PIXA *, l_float32, l_int32 *, l_int32) as NUMA *
	///  <summary>
	/// (1) See pixFindStrokeWidth() for details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaFindStrokeWidth/*"/>
	///  <param name="thresh">[in] - fractional count threshold relative to distance 1</param>
	///  <param name="tab8">[in][optional] - table for counting fg pixels can be NULL</param>
	///  <param name="debug">[in] - 1 for debug output 0 to skip</param>
	///   <returns>na  array of stroke widths for each pix in %pixa NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa FindStrokeWidth (Single thresh,
								 int[] tab8,
								 DebugOnOff debug)
	{
		Numa RetObj = _All.pixaFindStrokeWidth(this, thresh, tab8, debug);
		return RetObj;
	}

	// strokes.c (254, 1)
	// pixaModifyStrokeWidth(pixas, targetw) as Pixa
	// pixaModifyStrokeWidth(PIXA *, l_float32) as PIXA *
	///  <summary>
	/// pixaModifyStrokeWidth()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaModifyStrokeWidth/*"/>
	///  <param name="pixas">[in] - of 1 bpp pix</param>
	///  <param name="targetw">[out] - desired width for strokes in each pix</param>
	///   <returns>pixa  with modified stroke widths, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ModifyStrokeWidth (Pixa pixas,
								   out Single targetw)
	{
		Pixa RetObj = _All.pixaModifyStrokeWidth(pixas, out targetw);
		return RetObj;
	}

	// strokes.c (345, 1)
	// pixaSetStrokeWidth(pixas, width, thinfirst, connectivity) as Pixa
	// pixaSetStrokeWidth(PIXA *, l_int32, l_int32, l_int32) as PIXA *
	///  <summary>
	/// (1) If %thinfirst == 1, thin to a skeleton using the specified
	/// %connectivity.  Use %thinfirst == 0 if all pix in pixas
	/// have already been thinned as far as possible.<para/>
	///
	/// (2) The image is dilated to the required %width.  This dilation
	/// is not connectivity preserving, so this is typically
	/// used in a situation where merging of c.c. in the individual
	/// pix is not a problem e.g., where each pix is a single c.c.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaSetStrokeWidth/*"/>
	///  <param name="pixas">[in] - of 1 bpp pix</param>
	///  <param name="width">[in] - set stroke width to this value, in [1 ... 100].</param>
	///  <param name="thinfirst">[in] - 1 to thin all pix to a skeleton first 0 to skip</param>
	///  <param name="connectivity">[in] - 4 or 8, to be used if %thinfirst == 1</param>
	///   <returns>pixa  with all stroke widths being %width, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa SetStrokeWidth (Pixa pixas,
								int width,
								int thinfirst,
								int connectivity)
	{
		Pixa RetObj = _All.pixaSetStrokeWidth(pixas, width, thinfirst, connectivity);
		return RetObj;
	}

	// textops.c (641, 1)
	// pixaAddTextNumber(pixas, bmf, na, val, location) as Pixa
	// pixaAddTextNumber(PIXA *, L_BMF *, NUMA *, l_uint32, l_int32) as PIXA *
	///  <summary>
	/// (1) Typical usage is for labelling each pix in a pixa with a number.<para/>
	///
	/// (2) This function paints numbers external to each pix, in a position
	/// given by %location.  In all cases, the pix is expanded on
	/// on side and the number is painted over white in the added region.<para/>
	///
	/// (3) %val is the pixel value to be painted through the font mask.
	/// It should be chosen to agree with the depth of pixs.
	/// If it is out of bounds, an intermediate value is chosen.
	/// For RGB, use hex notation: 0xRRGGBB00, where RR is the
	/// hex representation of the red intensity, etc.<para/>
	///
	/// (4) If na == NULL, number each pix sequentially, starting with 1.<para/>
	///
	/// (5) If there is a colormap, this does the best it can to use
	/// the requested color, or something similar to it.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaAddTextNumber/*"/>
	///  <param name="pixas">[in] - input pixa colormap ok</param>
	///  <param name="bmf">[in] - bitmap font data</param>
	///  <param name="na">[in][optional] - number array use 1 ... n if null</param>
	///  <param name="val">[in] - color to set the text</param>
	///  <param name="location">[in] - L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
	///   <returns>pixad new pixa with rendered numbers, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa AddTextNumber (Pixa pixas,
							   L_Bmf bmf,
							   uint val,
							   int location,
							   Numa na)
	{
		Pixa RetObj = _All.pixaAddTextNumber(pixas, bmf, na, val, location);
		return RetObj;
	}

	// textops.c (710, 1)
	// pixaAddTextlines(pixas, bmf, sa, val, location) as Pixa
	// pixaAddTextlines(PIXA *, L_BMF *, SARRAY *, l_uint32, l_int32) as PIXA *
	///  <summary>
	/// (1) This function adds one or more lines of text externally to
	/// each pix, in a position given by %location.  In all cases,
	/// the pix is expanded as necessary to accommodate the text.<para/>
	///
	/// (2) %val is the pixel value to be painted through the font mask.
	/// It should be chosen to agree with the depth of pixs.
	/// If it is out of bounds, an intermediate value is chosen.
	/// For RGB, use hex notation: 0xRRGGBB00, where RR is the
	/// hex representation of the red intensity, etc.<para/>
	///
	/// (3) If sa == NULL, use the text embedded in each pix.  In all
	/// cases, newlines in the text string are used to separate the
	/// lines of text that are added to the pix.<para/>
	///
	/// (4) If sa has a smaller count than pixa, issue a warning
	/// and do not use any embedded text.<para/>
	///
	/// (5) If there is a colormap, this does the best it can to use
	/// the requested color, or something similar to it.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaAddTextlines/*"/>
	///  <param name="pixas">[in] - input pixa colormap ok</param>
	///  <param name="bmf">[in] - bitmap font data</param>
	///  <param name="sa">[in][optional] - sarray use text embedded in each pix if null</param>
	///  <param name="val">[in] - color to set the text</param>
	///  <param name="location">[in] - L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
	///   <returns>pixad new pixa with rendered text, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa AddTextlines (Pixa pixas,
							  L_Bmf bmf,
							  uint val,
							  int location,
							  Sarray sa)
	{
		Pixa RetObj = _All.pixaAddTextlines(pixas, bmf, sa, val, location);
		return RetObj;
	}

	// textops.c (780, 1)
	// pixaAddPixWithText(pixa, pixs, reduction, bmf, textstr, val, location) as int
	// pixaAddPixWithText(PIXA *, PIX *, l_int32, L_BMF *, const char *, l_uint32, l_int32) as l_ok
	///  <summary>
	/// (1) This function generates a new pix with added text, and adds
	/// it by insertion into the pixa.<para/>
	///
	/// (2) If the input pixs is not cmapped and not 32 bpp, it is
	/// converted to 32 bpp rgb.  %val is a standard 32 bpp pixel,
	/// expressed as 0xrrggbb00.  If there is a colormap, this does
	/// the best it can to use the requested color, or something close.<para/>
	///
	/// (3) if %bmf == NULL, generate an 8 pt font this takes about 5 msec.<para/>
	///
	/// (4) If %textstr == NULL, use the text field in the pix.<para/>
	///
	/// (5) In general, the text string can be written in multiple lines
	/// use newlines as the separators.<para/>
	///
	/// (6) Typical usage is for debugging, where the pixa of labeled images
	/// is used to generate a pdf.  Suggest using 1.0 for scalefactor.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaAddPixWithText/*"/>
	///  <param name="pixs">[in] - any depth, colormap ok</param>
	///  <param name="reduction">[in] - integer subsampling factor</param>
	///  <param name="bmf">[in][optional] - bitmap font data</param>
	///  <param name="textstr">[in][optional] - text string to be added</param>
	///  <param name="val">[in] - color to set the text</param>
	///  <param name="location">[in] - L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddPixWithText (Pix pixs,
							   int reduction,
							   uint val,
							   int location,
							   L_Bmf bmf,
							   String textstr)
	{
		int RetObj = _All.pixaAddPixWithText(this, pixs, reduction, bmf, textstr, val, location);
		return RetObj;
	}

	// tiffio.c (1226, 1)
	// pixaReadMultipageTiff(filename) as Pixa
	// pixaReadMultipageTiff(const char *) as PIXA *
	///  <summary>
	/// pixaReadMultipageTiff()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaReadMultipageTiff/*"/>
	///  <param name="filename">[in] - input tiff file</param>
	///   <returns>pixa of page images, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ReadMultipageTiff (String filename)
	{
		Pixa RetObj = _All.pixaReadMultipageTiff(filename);
		return RetObj;
	}

	// tiffio.c (1286, 1)
	// pixaWriteMultipageTiff(fname, pixa) as int
	// pixaWriteMultipageTiff(const char *, PIXA *) as l_ok
	///  <summary>
	/// (1) The tiff directory overhead is O(n^2).  I have not been
	/// able to reduce it to O(n).  The overhead for n = 2000 is
	/// about 1 second.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaWriteMultipageTiff/*"/>
	///  <param name="fname">[in] - input tiff file</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMultipageTiff (String fname)
	{
		int RetObj = _All.pixaWriteMultipageTiff(fname, this);
		return RetObj;
	}

	// tiffio.c (2566, 1)
	// pixaReadMemMultipageTiff(data, size) as Pixa
	// pixaReadMemMultipageTiff(const l_uint8 *, size_t) as PIXA *
	///  <summary>
	/// (1) This is an O(n) read-from-memory version of pixaReadMultipageTiff().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaReadMemMultipageTiff/*"/>
	///  <param name="data">[in] - const multiple pages tiff-encoded</param>
	///  <param name="size">[in] - size of cdata</param>
	///   <returns>pixa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pixa ReadMemMultipageTiff (Byte[] data,
									  uint size)
	{
		Pixa RetObj = _All.pixaReadMemMultipageTiff(data, size);
		return RetObj;
	}

	// tiffio.c (2606, 1)
	// pixaWriteMemMultipageTiff(pdata, psize, pixa) as int
	// pixaWriteMemMultipageTiff(l_uint8 **, size_t *, PIXA *) as l_ok
	///  <summary>
	/// (1) fopenTiffMemstream() does not work in append mode, so we
	/// must work-around with a temporary file.<para/>
	///
	/// (2) Getting a file stream from
	/// open_memstream((char )pdata, psize)
	/// does not work with the tiff directory.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaWriteMemMultipageTiff/*"/>
	///  <param name="pdata">[out] - const tiff-encoded</param>
	///  <param name="psize">[out] - size of data</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMemMultipageTiff (out Byte[] pdata,
									  out uint psize)
	{
		int RetObj = _All.pixaWriteMemMultipageTiff(out pdata, out psize, this);
		return RetObj;
	}

	// writefile.c (242, 1)
	// pixaWriteFiles(rootname, pixa, format) as int
	// pixaWriteFiles(const char *, PIXA *, l_int32) as l_ok
	///  <summary>
	/// (1) Use %format = IFF_DEFAULT to decide the output format
	/// individually for each pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/pixaWriteFiles/*"/>
	///  <param name="rootname">[in] - </param>
	///  <param name="format">[in] - defined in imageio.h see notes for default</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteFiles (String rootname,
						   IFF format)
	{
		int RetObj = _All.pixaWriteFiles(rootname, this, format);
		return RetObj;
	}


}
public partial class Box
{
	// boxbasic.c (165, 1)
	// boxCreate(x, y, w, h) as Box
	// boxCreate(l_int32, l_int32, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) This clips the box to the +quad.  If no part of the
	/// box is in the +quad, this returns NULL.<para/>
	///
	/// (2) We allow you to make a box with w = 0 and/or h = 0.
	/// This does not represent a valid region, but it is useful
	/// as a placeholder in a boxa for which the index of the
	/// box in the boxa is important.  This is an atypical
	/// situation usually you want to put only valid boxes with
	/// nonzero width and height in a boxa.  If you have a boxa
	/// with invalid boxes, the accessor boxaGetValidBox()
	/// will return NULL on each invalid box.<para/>
	///
	/// (3) If you want to create only valid boxes, use boxCreateValid(),
	/// which returns NULL if either w or h is 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxCreate/*"/>
	///  <param name="x">[in] - </param>
	///  <param name="y">[in] - </param>
	///  <param name="w">[in] - </param>
	///  <param name="h">[in] - </param>
	///   <returns>box, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box Create (int x,
					   int y,
					   int w,
					   int h)
	{
		Box RetObj = _All.boxCreate(x, y, w, h);
		return RetObj;
	}

	// boxbasic.c (210, 1)
	// boxCreateValid(x, y, w, h) as Box
	// boxCreateValid(l_int32, l_int32, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) This returns NULL if either w = 0 or h = 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxCreateValid/*"/>
	///  <param name="x">[in] - </param>
	///  <param name="y">[in] - </param>
	///  <param name="w">[in] - </param>
	///  <param name="h">[in] - </param>
	///   <returns>box, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box CreateValid (int x,
							int y,
							int w,
							int h)
	{
		Box RetObj = _All.boxCreateValid(x, y, w, h);
		return RetObj;
	}

	// boxbasic.c (230, 1)
	// boxCopy(box) as Box
	// boxCopy(BOX *) as BOX *
	///  <summary>
	/// boxCopy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxCopy/*"/>
	///  <param name="box">[in] - </param>
	///   <returns>copy of box, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box Copy (Box box)
	{
		Box RetObj = _All.boxCopy(box);
		return RetObj;
	}

	// boxbasic.c (252, 1)
	// boxClone(box) as Box
	// boxClone(BOX *) as BOX *
	///  <summary>
	/// boxClone()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxClone/*"/>
	///  <param name="box">[in] - </param>
	///   <returns>ptr to same box, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box Clone (Box box)
	{
		Box RetObj = _All.boxClone(box);
		return RetObj;
	}

	// boxbasic.c (278, 1)
	// boxDestroy(pbox) as Object
	// boxDestroy(BOX **) as void
	///  <summary>
	/// (1) Decrements the ref count and, if 0, destroys the box.<para/>
	///
	/// (2) Always nulls the input ptr.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxDestroy/*"/>
	///  <param name="pbox">[in,out] - will be set to null before returning</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref Box pbox)
	{
		_All.boxDestroy(ref pbox);
	}

	// boxbasic.c (310, 1)
	// boxGetGeometry(box, px, py, pw, ph) as int
	// boxGetGeometry(BOX *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// boxGetGeometry()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxGetGeometry/*"/>
	///  <param name="box">[in] - </param>
	///  <param name="px">[out][optional] - each can be null</param>
	///  <param name="py">[out][optional] - each can be null</param>
	///  <param name="pw">[out][optional] - each can be null</param>
	///  <param name="ph">[out][optional] - each can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetGeometry (Box box,
							out int px,
							out int py,
							out int pw,
							out int ph)
	{
		int RetObj = _All.boxGetGeometry(box, out px, out py, out pw, out ph);
		return RetObj;
	}

	// boxbasic.c (340, 1)
	// boxSetGeometry(box, x, y, w, h) as int
	// boxSetGeometry(BOX *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// boxSetGeometry()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxSetGeometry/*"/>
	///  <param name="box">[in] - </param>
	///  <param name="x">[in][optional] - use -1 to leave unchanged</param>
	///  <param name="y">[in][optional] - use -1 to leave unchanged</param>
	///  <param name="w">[in][optional] - use -1 to leave unchanged</param>
	///  <param name="h">[in][optional] - use -1 to leave unchanged</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetGeometry (Box box,
							int x,
							int y,
							int w,
							int h)
	{
		int RetObj = _All.boxSetGeometry(box, x, y, w, h);
		return RetObj;
	}

	// boxbasic.c (371, 1)
	// boxGetSideLocations(box, pl, pr, pt, pb) as int
	// boxGetSideLocations(BOX *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) All returned values are within the box.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxGetSideLocations/*"/>
	///  <param name="box">[in] - </param>
	///  <param name="pl">[out][optional] - each can be null</param>
	///  <param name="pr">[out][optional] - each can be null</param>
	///  <param name="pt">[out][optional] - each can be null</param>
	///  <param name="pb">[out][optional] - each can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetSideLocations (Box box,
								 out int pl,
								 out int pr,
								 out int pt,
								 out int pb)
	{
		int RetObj = _All.boxGetSideLocations(box, out pl, out pr, out pt, out pb);
		return RetObj;
	}

	// boxbasic.c (405, 1)
	// boxSetSideLocations(box, l, r, t, b) as int
	// boxSetSideLocations(BOX *, l_int32, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// boxSetSideLocations()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxSetSideLocations/*"/>
	///  <param name="box">[in] - </param>
	///  <param name="l">[in][optional] - use -1 to leave unchanged</param>
	///  <param name="r">[in][optional] - use -1 to leave unchanged</param>
	///  <param name="t">[in][optional] - use -1 to leave unchanged</param>
	///  <param name="b">[in][optional] - use -1 to leave unchanged</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetSideLocations (Box box,
								 int l,
								 int r,
								 int t,
								 int b)
	{
		int RetObj = _All.boxSetSideLocations(box, l, r, t, b);
		return RetObj;
	}

	// boxbasic.c (432, 1)
	// boxGetRefcount(box) as int
	// boxGetRefcount(BOX *) as l_int32
	///  <summary>
	/// Return the current reference count of %box
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxGetRefcount/*"/>
	///  <param name="box">[in] - ptr to Box</param>
	///   <returns>refcount</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRefcount (Box box)
	{
		int RetObj = _All.boxGetRefcount(box);
		return RetObj;
	}

	// boxbasic.c (449, 1)
	// boxChangeRefcount(box, delta) as int
	// boxChangeRefcount(BOX *, l_int32) as l_ok
	///  <summary>
	/// Adjust the current references count of %box by %delta
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxChangeRefcount/*"/>
	///  <param name="box">[in] - ptr to box</param>
	///  <param name="delta">[in] - adjustment, usually -1 or 1</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ChangeRefcount (Box box,
							   int delta)
	{
		int RetObj = _All.boxChangeRefcount(box, delta);
		return RetObj;
	}

	// boxbasic.c (470, 1)
	// boxIsValid(box, pvalid) as int
	// boxIsValid(BOX *, l_int32 *) as l_ok
	///  <summary>
	/// boxIsValid()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxIsValid/*"/>
	///  <param name="box">[in] - </param>
	///  <param name="pvalid">[out] - 1 if valid 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int IsValid (Box box,
						out int pvalid)
	{
		int RetObj = _All.boxIsValid(box, out pvalid);
		return RetObj;
	}

	// boxbasic.c (2355, 1)
	// boxPrintStreamInfo(fp, box) as int
	// boxPrintStreamInfo(FILE *, BOX *) as l_ok
	///  <summary>
	/// (1) This outputs debug info.  Use serialization functions to
	/// write to file if you want to read the data back.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxPrintStreamInfo/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="box">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int PrintStreamInfo (FILE fp,
								Box box)
	{
		int RetObj = _All.boxPrintStreamInfo(fp, box);
		return RetObj;
	}

	// boxfunc1.c (99, 1)
	// boxContains(box1, box2, presult) as int
	// boxContains(BOX *, BOX *, l_int32 *) as l_ok
	///  <summary>
	/// boxContains()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxContains/*"/>
	///  <param name="box1">[in] - </param>
	///  <param name="box2">[in] - </param>
	///  <param name="presult">[out] - 1 if box2 is entirely contained within box1, and 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Contains (Box box1,
						 Box box2,
						 out int presult)
	{
		int RetObj = _All.boxContains(box1, box2, out presult);
		return RetObj;
	}

	// boxfunc1.c (130, 1)
	// boxIntersects(box1, box2, presult) as int
	// boxIntersects(BOX *, BOX *, l_int32 *) as l_ok
	///  <summary>
	/// boxIntersects()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxIntersects/*"/>
	///  <param name="box1">[in] - </param>
	///  <param name="box2">[in] - </param>
	///  <param name="presult">[out] - 1 if any part of box2 is contained in box1, and 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Intersects (Box box1,
						   Box box2,
						   out int presult)
	{
		int RetObj = _All.boxIntersects(box1, box2, out presult);
		return RetObj;
	}

	// boxfunc1.c (674, 1)
	// boxOverlapRegion(box1, box2) as Box
	// boxOverlapRegion(BOX *, BOX *) as BOX *
	///  <summary>
	/// (1) This is the geometric intersection of the two rectangles.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxOverlapRegion/*"/>
	///  <param name="box1">[in] - two boxes</param>
	///  <param name="box2">[in] - two boxes</param>
	///   <returns>box of overlap region between input boxes, or NULL if no overlap or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box OverlapRegion (Box box1,
							  Box box2)
	{
		Box RetObj = _All.boxOverlapRegion(box1, box2);
		return RetObj;
	}

	// boxfunc1.c (716, 1)
	// boxBoundingRegion(box1, box2) as Box
	// boxBoundingRegion(BOX *, BOX *) as BOX *
	///  <summary>
	/// (1) This is the geometric union of the two rectangles.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxBoundingRegion/*"/>
	///  <param name="box1">[in] - two boxes</param>
	///  <param name="box2">[in] - two boxes</param>
	///   <returns>box of bounding region containing the input boxes, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box BoundingRegion (Box box1,
							   Box box2)
	{
		Box RetObj = _All.boxBoundingRegion(box1, box2);
		return RetObj;
	}

	// boxfunc1.c (756, 1)
	// boxOverlapFraction(box1, box2, pfract) as int
	// boxOverlapFraction(BOX *, BOX *, l_float32 *) as l_ok
	///  <summary>
	/// (1) The result depends on the order of the input boxes,
	/// because the overlap is taken as a fraction of box2.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxOverlapFraction/*"/>
	///  <param name="box1">[in] - two boxes</param>
	///  <param name="box2">[in] - two boxes</param>
	///  <param name="pfract">[out] - the fraction of box2 overlapped by box1</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int OverlapFraction (Box box1,
								Box box2,
								out Single pfract)
	{
		int RetObj = _All.boxOverlapFraction(box1, box2, out pfract);
		return RetObj;
	}

	// boxfunc1.c (792, 1)
	// boxOverlapArea(box1, box2, parea) as int
	// boxOverlapArea(BOX *, BOX *, l_int32 *) as l_ok
	///  <summary>
	/// boxOverlapArea()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxOverlapArea/*"/>
	///  <param name="box1">[in] - two boxes</param>
	///  <param name="box2">[in] - two boxes</param>
	///  <param name="parea">[out] - the number of pixels in the overlap</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int OverlapArea (Box box1,
							Box box2,
							out int parea)
	{
		int RetObj = _All.boxOverlapArea(box1, box2, out parea);
		return RetObj;
	}

	// boxfunc1.c (973, 1)
	// boxSeparationDistance(box1, box2, ph_sep, pv_sep) as int
	// boxSeparationDistance(BOX *, BOX *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This measures horizontal and vertical separation of the
	/// two boxes.  If the boxes are touching but have no pixels
	/// in common, the separation is 0.  If the boxes overlap by
	/// a distance d, the returned separation is -d.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxSeparationDistance/*"/>
	///  <param name="box1">[in] - two boxes, in any order</param>
	///  <param name="box2">[in] - two boxes, in any order</param>
	///  <param name="ph_sep">[out][optional] - horizontal separation</param>
	///  <param name="pv_sep">[out][optional] - vertical separation</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SeparationDistance (Box box1,
								   Box box2,
								   out int ph_sep,
								   out int pv_sep)
	{
		int RetObj = _All.boxSeparationDistance(box1, box2, out ph_sep, out pv_sep);
		return RetObj;
	}

	// boxfunc1.c (1029, 1)
	// boxCompareSize(box1, box2, type, prel) as int
	// boxCompareSize(BOX *, BOX *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) We're re-using the SORT enum for these comparisons.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxCompareSize/*"/>
	///  <param name="box1">[in] - </param>
	///  <param name="box2">[in] - </param>
	///  <param name="type">[in] - L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER, L_SORT_BY_AREA,</param>
	///  <param name="prel">[out] - 1 if box1  is greater  box2, 0 if the same, -1 if box1  is smaller box2</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CompareSize (Box box1,
							Box box2,
							int type,
							out int prel)
	{
		int RetObj = _All.boxCompareSize(box1, box2, type, out prel);
		return RetObj;
	}

	// boxfunc1.c (1080, 1)
	// boxContainsPt(box, x, y, pcontains) as int
	// boxContainsPt(BOX *, l_float32, l_float32, l_int32 *) as l_ok
	///  <summary>
	/// boxContainsPt()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxContainsPt/*"/>
	///  <param name="box">[in] - </param>
	///  <param name="x">[in] - a point</param>
	///  <param name="y">[in] - a point</param>
	///  <param name="pcontains">[out] - 1 if box contains point 0 otherwise</param>
	///   <returns>0 if OK, 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int ContainsPt (Box box,
						   Single x,
						   Single y,
						   out int pcontains)
	{
		int RetObj = _All.boxContainsPt(box, x, y, out pcontains);
		return RetObj;
	}

	// boxfunc1.c (1444, 1)
	// boxGetCenter(box, pcx, pcy) as int
	// boxGetCenter(BOX *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// boxGetCenter()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxGetCenter/*"/>
	///  <param name="box">[in] - </param>
	///  <param name="pcx">[out] - location of center of box</param>
	///  <param name="pcy">[out] - location of center of box</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCenter (Box box,
						  out Single pcx,
						  out Single pcy)
	{
		int RetObj = _All.boxGetCenter(box, out pcx, out pcy);
		return RetObj;
	}

	// boxfunc1.c (1485, 1)
	// boxIntersectByLine(box, x, y, slope, px1, py1, px2, py2, pn) as int
	// boxIntersectByLine(BOX *, l_int32, l_int32, l_float32, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) If the intersection is at only one point (a corner), the
	/// coordinates are returned in (x1, y1).<para/>
	///
	/// (2) Represent a vertical line by one with a large but finite slope.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxIntersectByLine/*"/>
	///  <param name="box">[in] - </param>
	///  <param name="x">[in] - point that line goes through</param>
	///  <param name="y">[in] - point that line goes through</param>
	///  <param name="slope">[in] - of line</param>
	///  <param name="px1">[out] - 1st point of intersection with box</param>
	///  <param name="py1">[out] - 1st point of intersection with box</param>
	///  <param name="px2">[out] - 2nd point of intersection with box</param>
	///  <param name="py2">[out] - 2nd point of intersection with box</param>
	///  <param name="pn">[out] - number of points of intersection</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int IntersectByLine (Box box,
								int x,
								int y,
								Single slope,
								out int px1,
								out int py1,
								out int px2,
								out int py2,
								out int pn)
	{
		int RetObj = _All.boxIntersectByLine(box, x, y, slope, out px1, out py1, out px2, out py2, out pn);
		return RetObj;
	}

	// boxfunc1.c (1587, 1)
	// boxClipToRectangle(box, wi, hi) as Box
	// boxClipToRectangle(BOX *, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) This can be used to clip a rectangle to an image.
	/// The clipping rectangle is assumed to have a UL corner at (0, 0),
	/// and a LR corner at (wi - 1, hi - 1).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxClipToRectangle/*"/>
	///  <param name="box">[in] - </param>
	///  <param name="wi">[in] - rectangle representing image</param>
	///  <param name="hi">[in] - rectangle representing image</param>
	///   <returns>part of box within given rectangle, or NULL on error or if box is entirely outside the rectangle</returns>
	// CreateAdditiveFunction: Function/Else
	public Box ClipToRectangle (int wi,
								int hi,
								Box box)
	{
		Box RetObj = _All.boxClipToRectangle(box, wi, hi);
		return RetObj;
	}

	// boxfunc1.c (1644, 1)
	// boxClipToRectangleParams(box, w, h, pxstart, pystart, pxend, pyend, pbw, pbh) as int
	// boxClipToRectangleParams(BOX *, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) The return value should be checked.  If it is 1, the
	/// returned parameter values are bogus.<para/>
	///
	/// (2) This simplifies the selection of pixel locations within
	/// a given rectangle:
	/// for (i = ystart i  is smaller yend i++ {
	/// ...
	/// for (j = xstart j  is smaller xend j++ {
	/// ....
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxClipToRectangleParams/*"/>
	///  <param name="box">[in][optional] - requested box can be null</param>
	///  <param name="w">[in] - clipping box size typ. the size of an image</param>
	///  <param name="h">[in] - clipping box size typ. the size of an image</param>
	///  <param name="pxstart">[out] - start x coordinate</param>
	///  <param name="pystart">[out] - start y coordinate</param>
	///  <param name="pxend">[out] - one pixel beyond clipping box</param>
	///  <param name="pyend">[out] - one pixel beyond clipping box</param>
	///  <param name="pbw">[out][optional] - clipped width</param>
	///  <param name="pbh">[out][optional] - clipped height</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ClipToRectangleParams (int w,
									  int h,
									  out int pxstart,
									  out int pystart,
									  out int pxend,
									  out int pyend,
									  Box box,
									  out int pbw,
									  out int pbh)
	{
		int RetObj = _All.boxClipToRectangleParams(box, w, h, out pxstart, out pystart, out pxend, out pyend, out pbw, out pbh);
		return RetObj;
	}

	// boxfunc1.c (1706, 1)
	// boxRelocateOneSide(boxd, boxs, loc, sideflag) as Box
	// boxRelocateOneSide(BOX *, BOX *, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) Set boxd == NULL to get new box boxd == boxs for in-place
	/// or otherwise to resize existing boxd.<para/>
	///
	/// (2) For usage, suggest one of these:
	/// boxd = boxRelocateOneSide(NULL, boxs, ...) // new
	/// boxRelocateOneSide(boxs, boxs, ...)  // in-place
	/// boxRelocateOneSide(boxd, boxs, ...)  // other
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxRelocateOneSide/*"/>
	///  <param name="boxd">[in][optional] - this can be null, equal to boxs, or different from boxs</param>
	///  <param name="loc">[in] - new location of the side that is changing</param>
	///  <param name="sideflag">[in] - L_FROM_LEFT, etc., indicating the side that moves</param>
	///   <returns>boxd, or NULL on error or if the computed boxd has width or height smaller or equal 0.</returns>
	// CreateAdditiveFunction: Function/Else
	public Box RelocateOneSide (int loc,
								int sideflag,
								Box boxd)
	{
		Box RetObj = _All.boxRelocateOneSide(boxd, this, loc, sideflag);
		return RetObj;
	}

	// boxfunc1.c (1807, 1)
	// boxAdjustSides(boxd, boxs, delleft, delright, deltop, delbot) as Box
	// boxAdjustSides(BOX *, BOX *, l_int32, l_int32, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) Set boxd == NULL to get new box boxd == boxs for in-place
	/// or otherwise to resize existing boxd.<para/>
	///
	/// (2) For usage, suggest one of these:
	/// boxd = boxAdjustSides(NULL, boxs, ...) // new
	/// boxAdjustSides(boxs, boxs, ...)  // in-place
	/// boxAdjustSides(boxd, boxs, ...)  // other<para/>
	///
	/// (3) New box dimensions are cropped at left and top to x greater or equal 0 and y greater or equal 0.<para/>
	///
	/// (4) For example, to expand in-place by 20 pixels on each side, use
	/// boxAdjustSides(box, box, -20, 20, -20, 20)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxAdjustSides/*"/>
	///  <param name="boxd">[in][optional] - this can be null, equal to boxs, or different from boxs</param>
	///  <param name="delleft">[in] - changes in location of each side</param>
	///  <param name="delright">[in] - changes in location of each side</param>
	///  <param name="deltop">[in] - changes in location of each side</param>
	///  <param name="delbot">[in] - changes in location of each side</param>
	///   <returns>boxd, or NULL on error or if the computed boxd has width or height smaller or equal 0.</returns>
	// CreateAdditiveFunction: Function/Else
	public Box AdjustSides (int delleft,
							int delright,
							int deltop,
							int delbot,
							Box boxd)
	{
		Box RetObj = _All.boxAdjustSides(boxd, this, delleft, delright, deltop, delbot);
		return RetObj;
	}

	// boxfunc1.c (2057, 1)
	// boxEqual(box1, box2, psame) as int
	// boxEqual(BOX *, BOX *, l_int32 *) as l_ok
	///  <summary>
	/// boxEqual()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxEqual/*"/>
	///  <param name="box1">[in] - </param>
	///  <param name="box2">[in] - </param>
	///  <param name="psame">[out] - 1 if equal 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Equal (Box box1,
					  Box box2,
					  out int psame)
	{
		int RetObj = _All.boxEqual(box1, box2, out psame);
		return RetObj;
	}

	// boxfunc1.c (2183, 1)
	// boxSimilar(box1, box2, leftdiff, rightdiff, topdiff, botdiff, psimilar) as int
	// boxSimilar(BOX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) The values of leftdiff (etc) are the maximum allowed deviations
	/// between the locations of the left (etc) sides.  If any side
	/// pairs differ by more than this amount, the boxes are not similar.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxSimilar/*"/>
	///  <param name="box1">[in] - </param>
	///  <param name="box2">[in] - </param>
	///  <param name="leftdiff">[in] - </param>
	///  <param name="rightdiff">[in] - </param>
	///  <param name="topdiff">[in] - </param>
	///  <param name="botdiff">[in] - </param>
	///  <param name="psimilar">[out] - 1 if similar 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Similar (Box box1,
						Box box2,
						int leftdiff,
						int rightdiff,
						int topdiff,
						int botdiff,
						out int psimilar)
	{
		int RetObj = _All.boxSimilar(box1, box2, leftdiff, rightdiff, topdiff, botdiff, out psimilar);
		return RetObj;
	}

	// boxfunc2.c (137, 1)
	// boxTransform(box, shiftx, shifty, scalex, scaley) as Box
	// boxTransform(BOX *, l_int32, l_int32, l_float32, l_float32) as BOX *
	///  <summary>
	/// (1) This is a very simple function that first shifts, then scales.<para/>
	///
	/// (2) If the box is invalid, a new invalid box is returned.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxTransform/*"/>
	///  <param name="box">[in] - </param>
	///  <param name="shiftx">[in] - </param>
	///  <param name="shifty">[in] - </param>
	///  <param name="scalex">[in] - </param>
	///  <param name="scaley">[in] - </param>
	///   <returns>boxd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box Transform (int shiftx,
						  int shifty,
						  Box box,
						  Single scalex,
						  Single scaley)
	{
		Box RetObj = _All.boxTransform(box, shiftx, shifty, scalex, scaley);
		return RetObj;
	}

	// boxfunc2.c (280, 1)
	// boxTransformOrdered(boxs, shiftx, shifty, scalex, scaley, xcen, ycen, angle, order) as Box
	// boxTransformOrdered(BOX *, l_int32, l_int32, l_float32, l_float32, l_int32, l_int32, l_float32, l_int32) as BOX *
	///  <summary>
	/// (1) This allows a sequence of linear transforms, composed of
	/// shift, scaling and rotation, where the order of the
	/// transforms is specified.<para/>
	///
	/// (2) The rotation is taken about a point specified by (xcen, ycen).
	/// Let the components of the vector from the center of rotation
	/// to the box center be (xdif, ydif):
	/// xdif = (bx + 0.5  bw) - xcen
	/// ydif = (by + 0.5  bh) - ycen
	/// Then the box center after rotation has new components:
	/// bxcen = xcen + xdif  cosa + ydif  sina
	/// bycen = ycen + ydif  cosa - xdif  sina
	/// where cosa and sina are the cos and sin of the angle,
	/// and the enclosing box for the rotated box has size:
	/// rw = |bw  cosa| + |bh  sina|
	/// rh = |bh  cosa| + |bw  sina|
	/// where bw and bh are the unrotated width and height.
	/// Then the box UL corner (rx, ry) is
	/// rx = bxcen - 0.5  rw
	/// ry = bycen - 0.5  rh<para/>
	///
	/// (3) The center of rotation specified by args %xcen and %ycen
	/// is the point BEFORE any translation or scaling.  If the
	/// rotation is not the first operation, this function finds
	/// the actual center at the time of rotation.  It does this
	/// by making the following assumptions:<para/>
	///
	/// (1) Any scaling is with respect to the UL corner, so
	/// that the center location scales accordingly.<para/>
	///
	/// (2) A translation does not affect the center of
	/// the image it just moves the boxes.
	/// We always use assumption (1).  However, assumption (2)
	/// will be incorrect if the apparent translation is due
	/// to a clipping operation that, in effect, moves the
	/// origin of the image.  In that case, you should NOT use
	/// these simple functions.  Instead, use the functions
	/// in affinecompose.c, where the rotation center can be
	/// computed from the actual clipping due to translation
	/// of the image origin.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxTransformOrdered/*"/>
	///  <param name="shiftx">[in] - </param>
	///  <param name="shifty">[in] - </param>
	///  <param name="scalex">[in] - </param>
	///  <param name="scaley">[in] - </param>
	///  <param name="xcen">[in] - center of rotation</param>
	///  <param name="ycen">[in] - center of rotation</param>
	///  <param name="angle">[in] - in radians clockwise is positive</param>
	///  <param name="order">[in] - one of 6 combinations: L_TR_SC_RO, ...</param>
	///   <returns>boxd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box TransformOrdered (int shiftx,
								 int shifty,
								 int xcen,
								 int ycen,
								 Single angle,
								 int order,
								 Single scalex,
								 Single scaley)
	{
		Box RetObj = _All.boxTransformOrdered(this, shiftx, shifty, scalex, scaley, xcen, ycen, angle, order);
		return RetObj;
	}

	// boxfunc2.c (506, 1)
	// boxRotateOrth(box, w, h, rotation) as Box
	// boxRotateOrth(BOX *, l_int32, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) Rotate the image with the embedded box by the specified amount.<para/>
	///
	/// (2) After rotation, the rotated box is always measured with
	/// respect to the UL corner of the image.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxRotateOrth/*"/>
	///  <param name="box">[in] - </param>
	///  <param name="w">[in] - of image in which the box is embedded</param>
	///  <param name="h">[in] - of image in which the box is embedded</param>
	///  <param name="rotation">[in] - 0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg all rotations are clockwise</param>
	///   <returns>boxd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box RotateOrth (int w,
						   int h,
						   int rotation,
						   Box box)
	{
		Box RetObj = _All.boxRotateOrth(box, w, h, rotation);
		return RetObj;
	}

	// boxfunc4.c (863, 1)
	// boxConvertToPta(box, ncorners) as Pta
	// boxConvertToPta(BOX *, l_int32) as PTA *
	///  <summary>
	/// (1) If ncorners == 2, we select the UL and LR corners.
	/// Otherwise we save all 4 corners in this order: UL, UR, LL, LR.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxConvertToPta/*"/>
	///  <param name="box">[in] - </param>
	///  <param name="ncorners">[in] - 2 or 4 for the representation of the box</param>
	///   <returns>pta with %ncorners points, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta ConvertToPta (Box box,
							 int ncorners)
	{
		Pta RetObj = _All.boxConvertToPta(box, ncorners);
		return RetObj;
	}


}
public partial class Boxa
{
	// affinecompose.c (358, 1)
	// boxaTranslate(boxas, transx, transy) as Boxa
	// boxaTranslate(BOXA *, l_float32, l_float32) as BOXA *
	///  <summary>
	/// boxaTranslate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaTranslate/*"/>
	///  <param name="transx">[in] - x component of translation wrt. the origin</param>
	///  <param name="transy">[in] - y component of translation wrt. the origin</param>
	///   <returns>boxad  translated boxas, or NULL on error Notes: (1) See createMatrix2dTranslate() for details of transform.</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa Translate (Single transx,
						   Single transy)
	{
		Boxa RetObj = _All.boxaTranslate(this, transx, transy);
		return RetObj;
	}

	// affinecompose.c (391, 1)
	// boxaScale(boxas, scalex, scaley) as Boxa
	// boxaScale(BOXA *, l_float32, l_float32) as BOXA *
	///  <summary>
	/// boxaScale()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaScale/*"/>
	///  <param name="scalex">[in] - horizontal scale factor</param>
	///  <param name="scaley">[in] - vertical scale factor</param>
	///   <returns>boxad  scaled boxas, or NULL on error Notes: (1) See createMatrix2dScale() for details of transform.</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa Scale (Single scalex,
					   Single scaley)
	{
		Boxa RetObj = _All.boxaScale(this, scalex, scaley);
		return RetObj;
	}

	// affinecompose.c (424, 1)
	// boxaRotate(boxas, xc, yc, angle) as Boxa
	// boxaRotate(BOXA *, l_float32, l_float32, l_float32) as BOXA *
	///  <summary>
	/// boxaRotate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaRotate/*"/>
	///  <param name="xc">[in] - location of center of rotation</param>
	///  <param name="yc">[in] - location of center of rotation</param>
	///  <param name="angle">[in] - rotation in radians clockwise is positive</param>
	///   <returns>boxad  scaled boxas, or NULL on error Notes: (1) See createMatrix2dRotate() for details of transform.</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa Rotate (Single xc,
						Single yc,
						Single angle)
	{
		Boxa RetObj = _All.boxaRotate(this, xc, yc, angle);
		return RetObj;
	}

	// affinecompose.c (493, 1)
	// boxaAffineTransform(boxas, mat) as Boxa
	// boxaAffineTransform(BOXA *, l_float32 *) as BOXA *
	///  <summary>
	/// boxaAffineTransform()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaAffineTransform/*"/>
	///  <param name="mat">[in] - 3x3 transform matrix canonical form</param>
	///   <returns>boxad  transformed boxas, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa AffineTransform (Single[] mat)
	{
		Boxa RetObj = _All.boxaAffineTransform(this, mat);
		return RetObj;
	}

	// boxbasic.c (497, 1)
	// boxaCreate(n) as Boxa
	// boxaCreate(l_int32) as BOXA *
	///  <summary>
	/// boxaCreate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaCreate/*"/>
	///  <param name="n">[in] - initial number of ptrs</param>
	///   <returns>boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa Create (int n)
	{
		Boxa RetObj = _All.boxaCreate(n);
		return RetObj;
	}

	// boxbasic.c (532, 1)
	// boxaCopy(boxa, copyflag) as Boxa
	// boxaCopy(BOXA *, l_int32) as BOXA *
	///  <summary>
	/// (1) See pix.h for description of the copyflag.<para/>
	///
	/// (2) The copy-clone makes a new boxa that holds clones of each box.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaCopy/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="copyflag">[in] - L_COPY, L_CLONE, L_COPY_CLONE</param>
	///   <returns>new boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa Copy (int copyflag,
					  Boxa boxa)
	{
		Boxa RetObj = _All.boxaCopy(boxa, copyflag);
		return RetObj;
	}

	// boxbasic.c (578, 1)
	// boxaDestroy(pboxa) as Object
	// boxaDestroy(BOXA **) as void
	///  <summary>
	/// (1) Decrements the ref count and, if 0, destroys the boxa.<para/>
	///
	/// (2) Always nulls the input ptr.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaDestroy/*"/>
	///  <param name="pboxa">[in,out] - will be set to null before returning</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref Boxa pboxa)
	{
		_All.boxaDestroy(ref pboxa);
	}

	// boxbasic.c (616, 1)
	// boxaAddBox(boxa, box, copyflag) as int
	// boxaAddBox(BOXA *, BOX *, l_int32) as l_ok
	///  <summary>
	/// boxaAddBox()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaAddBox/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="box">[in] - to be added</param>
	///  <param name="copyflag">[in] - L_INSERT, L_COPY, L_CLONE</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddBox (Boxa boxa,
					   Box box,
					   int copyflag)
	{
		int RetObj = _All.boxaAddBox(boxa, box, copyflag);
		return RetObj;
	}

	// boxbasic.c (663, 1)
	// boxaExtendArray(boxa) as int
	// boxaExtendArray(BOXA *) as l_ok
	///  <summary>
	/// (1) Reallocs with doubled size of ptr array.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaExtendArray/*"/>
	///  <param name="boxa">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ExtendArray (Boxa boxa)
	{
		int RetObj = _All.boxaExtendArray(boxa);
		return RetObj;
	}

	// boxbasic.c (687, 1)
	// boxaExtendArrayToSize(boxa, size) as int
	// boxaExtendArrayToSize(BOXA *, l_int32) as l_ok
	///  <summary>
	/// (1) If necessary, reallocs new boxa ptr array to %size.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaExtendArrayToSize/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="size">[in] - new size of boxa array</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ExtendArrayToSize (Boxa boxa,
								  int size)
	{
		int RetObj = _All.boxaExtendArrayToSize(boxa, size);
		return RetObj;
	}

	// boxbasic.c (716, 1)
	// boxaGetCount(boxa) as int
	// boxaGetCount(BOXA *) as l_int32
	///  <summary>
	/// boxaGetCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetCount/*"/>
	///  <param name="boxa">[in] - </param>
	///   <returns>count of all boxes 0 if no boxes or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCount (Boxa boxa)
	{
		int RetObj = _All.boxaGetCount(boxa);
		return RetObj;
	}

	// boxbasic.c (733, 1)
	// boxaGetValidCount(boxa) as int
	// boxaGetValidCount(BOXA *) as l_int32
	///  <summary>
	/// boxaGetValidCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetValidCount/*"/>
	///  <param name="boxa">[in] - </param>
	///   <returns>count of valid boxes 0 if no valid boxes or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetValidCount (Boxa boxa)
	{
		int RetObj = _All.boxaGetValidCount(boxa);
		return RetObj;
	}

	// boxbasic.c (761, 1)
	// boxaGetBox(boxa, index, accessflag) as Box
	// boxaGetBox(BOXA *, l_int32, l_int32) as BOX *
	///  <summary>
	/// boxaGetBox()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetBox/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="index">[in] - to the index-th box</param>
	///  <param name="accessflag">[in] - L_COPY or L_CLONE</param>
	///   <returns>box, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box GetBox (Boxa boxa,
					   int index,
					   int accessflag)
	{
		Box RetObj = _All.boxaGetBox(boxa, index, accessflag);
		return RetObj;
	}

	// boxbasic.c (800, 1)
	// boxaGetValidBox(boxa, index, accessflag) as Box
	// boxaGetValidBox(BOXA *, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) This returns NULL for an invalid box in a boxa.
	/// For a box to be valid, both the width and height must be  is greater  0.<para/>
	///
	/// (2) We allow invalid boxes, with w = 0 or h = 0, as placeholders
	/// in boxa for which the index of the box in the boxa is important.
	/// This is an atypical situation usually you want to put only
	/// valid boxes in a boxa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetValidBox/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="index">[in] - to the index-th box</param>
	///  <param name="accessflag">[in] - L_COPY or L_CLONE</param>
	///   <returns>box, or NULL if box is not valid or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box GetValidBox (Boxa boxa,
							int index,
							int accessflag)
	{
		Box RetObj = _All.boxaGetValidBox(boxa, index, accessflag);
		return RetObj;
	}

	// boxbasic.c (828, 1)
	// boxaFindInvalidBoxes(boxa) as Numa
	// boxaFindInvalidBoxes(BOXA *) as NUMA *
	///  <summary>
	/// boxaFindInvalidBoxes()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaFindInvalidBoxes/*"/>
	///  <param name="boxa">[in] - </param>
	///   <returns>na   numa of invalid boxes NULL if there are none or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa FindInvalidBoxes (Boxa boxa)
	{
		Numa RetObj = _All.boxaFindInvalidBoxes(boxa);
		return RetObj;
	}

	// boxbasic.c (861, 1)
	// boxaGetBoxGeometry(boxa, index, px, py, pw, ph) as int
	// boxaGetBoxGeometry(BOXA *, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// boxaGetBoxGeometry()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetBoxGeometry/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="index">[in] - to the index-th box</param>
	///  <param name="px">[out][optional] - each can be null</param>
	///  <param name="py">[out][optional] - each can be null</param>
	///  <param name="pw">[out][optional] - each can be null</param>
	///  <param name="ph">[out][optional] - each can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetBoxGeometry (Boxa boxa,
							   int index,
							   out int px,
							   out int py,
							   out int pw,
							   out int ph)
	{
		int RetObj = _All.boxaGetBoxGeometry(boxa, index, out px, out py, out pw, out ph);
		return RetObj;
	}

	// boxbasic.c (897, 1)
	// boxaIsFull(boxa, pfull) as int
	// boxaIsFull(BOXA *, l_int32 *) as l_ok
	///  <summary>
	/// boxaIsFull()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaIsFull/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="pfull">[out] - 1 if boxa is full</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int IsFull (Boxa boxa,
					   out int pfull)
	{
		int RetObj = _All.boxaIsFull(boxa, out pfull);
		return RetObj;
	}

	// boxbasic.c (943, 1)
	// boxaReplaceBox(boxa, index, box) as int
	// boxaReplaceBox(BOXA *, l_int32, BOX *) as l_ok
	///  <summary>
	/// (1) In-place replacement of one box.<para/>
	///
	/// (2) The previous box at that location, if any, is destroyed.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaReplaceBox/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="index">[in] - to the index-th box</param>
	///  <param name="box">[in] - insert to replace existing one</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ReplaceBox (Boxa boxa,
						   int index,
						   Box box)
	{
		int RetObj = _All.boxaReplaceBox(boxa, index, box);
		return RetObj;
	}

	// boxbasic.c (981, 1)
	// boxaInsertBox(boxa, index, box) as int
	// boxaInsertBox(BOXA *, l_int32, BOX *) as l_ok
	///  <summary>
	/// (1) This shifts box[i] to box[i + 1] for all i greater or equal index,
	/// and then inserts box as box[index].<para/>
	///
	/// (2) To insert at the beginning of the array, set index = 0.<para/>
	///
	/// (3) To append to the array, it's easier to use boxaAddBox().<para/>
	///
	/// (4) This should not be used repeatedly to insert into large arrays,
	/// because the function is O(n).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaInsertBox/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="index">[in] - location in boxa to insert new value</param>
	///  <param name="box">[in] - new box to be inserted</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int InsertBox (Boxa boxa,
						  int index,
						  Box box)
	{
		int RetObj = _All.boxaInsertBox(boxa, index, box);
		return RetObj;
	}

	// boxbasic.c (1026, 1)
	// boxaRemoveBox(boxa, index) as int
	// boxaRemoveBox(BOXA *, l_int32) as l_ok
	///  <summary>
	/// (1) This removes box[index] and then shifts
	/// box[i] to box[i - 1] for all i  is greater  index.<para/>
	///
	/// (2) It should not be used repeatedly to remove boxes from
	/// large arrays, because the function is O(n).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaRemoveBox/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="index">[in] - of box to be removed</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RemoveBox (Boxa boxa,
						  int index)
	{
		int RetObj = _All.boxaRemoveBox(boxa, index);
		return RetObj;
	}

	// boxbasic.c (1068, 1)
	// boxaRemoveBoxAndSave(boxa, index, pbox) as int
	// boxaRemoveBoxAndSave(BOXA *, l_int32, BOX **) as l_ok
	///  <summary>
	/// (1) This removes box[index] and then shifts
	/// box[i] to box[i - 1] for all i  is greater  index.<para/>
	///
	/// (2) It should not be used repeatedly to remove boxes from
	/// large arrays, because the function is O(n).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaRemoveBoxAndSave/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="index">[in] - of box to be removed</param>
	///  <param name="pbox">[out][optional] - removed box</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RemoveBoxAndSave (Boxa boxa,
								 int index,
								 out Box pbox)
	{
		int RetObj = _All.boxaRemoveBoxAndSave(boxa, index, out pbox);
		return RetObj;
	}

	// boxbasic.c (1110, 1)
	// boxaSaveValid(boxas, copyflag) as Boxa
	// boxaSaveValid(BOXA *, l_int32) as BOXA *
	///  <summary>
	/// (1) This makes a copy/clone of each valid box.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSaveValid/*"/>
	///  <param name="copyflag">[in] - L_COPY or L_CLONE</param>
	///   <returns>boxad if OK, NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa SaveValid (int copyflag)
	{
		Boxa RetObj = _All.boxaSaveValid(this, copyflag);
		return RetObj;
	}

	// boxbasic.c (1174, 1)
	// boxaInitFull(boxa, box) as int
	// boxaInitFull(BOXA *, BOX *) as l_ok
	///  <summary>
	/// (1) This initializes a boxa by filling up the entire box ptr array
	/// with copies of %box.  If %box == NULL, use a placeholder box
	/// of zero size.  Any existing boxes are destroyed.
	/// After this opepration, the number of boxes is equal to
	/// the number of allocated ptrs.<para/>
	///
	/// (2) Note that we use boxaReplaceBox() instead of boxaInsertBox().
	/// They both have the same effect when inserting into a NULL ptr
	/// in the boxa ptr array:<para/>
	///
	/// (3) Example usage.  This function is useful to prepare for a
	/// random insertion (or replacement) of boxes into a boxa.
	/// To randomly insert boxes into a boxa, up to some index "max":
	/// Boxa boxa = boxaCreate(max)
	/// boxaInitFull(boxa, NULL)
	/// If you want placeholder boxes of non-zero size:
	/// Boxa boxa = boxaCreate(max)
	/// Box box = boxCreate(...)
	/// boxaInitFull(boxa, box)
	/// boxDestroy([and]box)
	/// If we have an existing boxa with a smaller ptr array, it can
	/// be reused for up to max boxes:
	/// boxaExtendArrayToSize(boxa, max)
	/// boxaInitFull(boxa, NULL)
	/// The initialization allows the boxa to always be properly
	/// filled, even if all the boxes are not later replaced.
	/// If you want to know which boxes have been replaced,
	/// and you initialized with invalid zero-sized boxes,
	/// use boxaGetValidBox() to return NULL for the invalid boxes.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaInitFull/*"/>
	///  <param name="boxa">[in] - typically empty</param>
	///  <param name="box">[in][optional] - to be replicated into the entire ptr array</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int InitFull (Boxa boxa,
						 Box box)
	{
		int RetObj = _All.boxaInitFull(boxa, box);
		return RetObj;
	}

	// boxbasic.c (1211, 1)
	// boxaClear(boxa) as int
	// boxaClear(BOXA *) as l_ok
	///  <summary>
	/// (1) This destroys all boxes in the boxa, setting the ptrs
	/// to null.  The number of allocated boxes, n, is set to 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaClear/*"/>
	///  <param name="boxa">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Clear (Boxa boxa)
	{
		int RetObj = _All.boxaClear(boxa);
		return RetObj;
	}

	// boxbasic.c (2096, 1)
	// boxaRead(filename) as Boxa
	// boxaRead(const char *) as BOXA *
	///  <summary>
	/// boxaRead()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaRead/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa Read (String filename)
	{
		Boxa RetObj = _All.boxaRead(filename);
		return RetObj;
	}

	// boxbasic.c (2123, 1)
	// boxaReadStream(fp) as Boxa
	// boxaReadStream(FILE *) as BOXA *
	///  <summary>
	/// boxaReadStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa ReadStream (FILE fp)
	{
		Boxa RetObj = _All.boxaReadStream(fp);
		return RetObj;
	}

	// boxbasic.c (2166, 1)
	// boxaReadMem(data, size) as Boxa
	// boxaReadMem(const l_uint8 *, size_t) as BOXA *
	///  <summary>
	/// boxaReadMem()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaReadMem/*"/>
	///  <param name="data">[in] - serialization of boxa in ascii</param>
	///  <param name="size">[in] - of data in bytes can use strlen to get it</param>
	///   <returns>boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa ReadMem (Byte[] data,
						 uint size)
	{
		Boxa RetObj = _All.boxaReadMem(data, size);
		return RetObj;
	}

	// boxbasic.c (2203, 1)
	// boxaWriteDebug(filename, boxa) as int
	// boxaWriteDebug(const char *, BOXA *) as l_ok
	///  <summary>
	/// (1) Debug version, intended for use in the library when writing
	/// to files in a temp directory with names that are compiled in.
	/// This is used instead of boxaWrite() for all such library calls.<para/>
	///
	/// (2) The global variable LeptDebugOK defaults to 0, and can be set
	/// or cleared by the function setLeptDebugOK().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaWriteDebug/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="boxa">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteDebug (String filename,
						   Boxa boxa)
	{
		int RetObj = _All.boxaWriteDebug(filename, boxa);
		return RetObj;
	}

	// boxbasic.c (2225, 1)
	// boxaWrite(filename, boxa) as int
	// boxaWrite(const char *, BOXA *) as l_ok
	///  <summary>
	/// boxaWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaWrite/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="boxa">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String filename,
					  Boxa boxa)
	{
		int RetObj = _All.boxaWrite(filename, boxa);
		return RetObj;
	}

	// boxbasic.c (2257, 1)
	// boxaWriteStream(fp, boxa) as int
	// boxaWriteStream(FILE *, BOXA *) as l_ok
	///  <summary>
	/// boxaWriteStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaWriteStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="boxa">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp,
							Boxa boxa)
	{
		int RetObj = _All.boxaWriteStream(fp, boxa);
		return RetObj;
	}

	// boxbasic.c (2298, 1)
	// boxaWriteMem(pdata, psize, boxa) as int
	// boxaWriteMem(l_uint8 **, size_t *, BOXA *) as l_ok
	///  <summary>
	/// (1) Serializes a boxa in memory and puts the result in a buffer.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaWriteMem/*"/>
	///  <param name="pdata">[out] - data of serialized boxa ascii</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="boxa">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMem (out Byte[] pdata,
						 out uint psize,
						 Boxa boxa)
	{
		int RetObj = _All.boxaWriteMem(out pdata, out psize, boxa);
		return RetObj;
	}

	// boxfunc1.c (172, 1)
	// boxaContainedInBox(boxas, box) as Boxa
	// boxaContainedInBox(BOXA *, BOX *) as BOXA *
	///  <summary>
	/// (1) All boxes in boxa that are entirely outside box are removed.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaContainedInBox/*"/>
	///  <param name="box">[in] - for containment</param>
	///   <returns>boxad boxa with all boxes in boxas that are entirely contained in box, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa ContainedInBox (Box box)
	{
		Boxa RetObj = _All.boxaContainedInBox(this, box);
		return RetObj;
	}

	// boxfunc1.c (210, 1)
	// boxaContainedInBoxCount(boxa, box, pcount) as int
	// boxaContainedInBoxCount(BOXA *, BOX *, l_int32 *) as l_ok
	///  <summary>
	/// boxaContainedInBoxCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaContainedInBoxCount/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="box">[in] - for selecting contained boxes in %boxa</param>
	///  <param name="pcount">[out] - number of boxes intersecting the box</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ContainedInBoxCount (Boxa boxa,
									Box box,
									out int pcount)
	{
		int RetObj = _All.boxaContainedInBoxCount(boxa, box, out pcount);
		return RetObj;
	}

	// boxfunc1.c (249, 1)
	// boxaContainedInBoxa(boxa1, boxa2, pcontained) as int
	// boxaContainedInBoxa(BOXA *, BOXA *, l_int32 *) as l_ok
	///  <summary>
	/// boxaContainedInBoxa()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaContainedInBoxa/*"/>
	///  <param name="boxa1">[in] - </param>
	///  <param name="boxa2">[in] - </param>
	///  <param name="pcontained">[out] - 1 if every box in boxa2 is contained in some box in boxa1 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ContainedInBoxa (Boxa boxa1,
								Boxa boxa2,
								out int pcontained)
	{
		int RetObj = _All.boxaContainedInBoxa(boxa1, boxa2, out pcontained);
		return RetObj;
	}

	// boxfunc1.c (302, 1)
	// boxaIntersectsBox(boxas, box) as Boxa
	// boxaIntersectsBox(BOXA *, BOX *) as BOXA *
	///  <summary>
	/// (1) All boxes in boxa that intersect with box (i.e., are completely
	/// or partially contained in box) are retained.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaIntersectsBox/*"/>
	///  <param name="box">[in] - for intersecting</param>
	///   <returns>boxad boxa with all boxes in boxas that intersect box, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa IntersectsBox (Box box)
	{
		Boxa RetObj = _All.boxaIntersectsBox(this, box);
		return RetObj;
	}

	// boxfunc1.c (340, 1)
	// boxaIntersectsBoxCount(boxa, box, pcount) as int
	// boxaIntersectsBoxCount(BOXA *, BOX *, l_int32 *) as l_ok
	///  <summary>
	/// boxaIntersectsBoxCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaIntersectsBoxCount/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="box">[in] - for selecting intersecting boxes in %boxa</param>
	///  <param name="pcount">[out] - number of boxes intersecting the box</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int IntersectsBoxCount (Boxa boxa,
								   Box box,
								   out int pcount)
	{
		int RetObj = _All.boxaIntersectsBoxCount(boxa, box, out pcount);
		return RetObj;
	}

	// boxfunc1.c (385, 1)
	// boxaClipToBox(boxas, box) as Boxa
	// boxaClipToBox(BOXA *, BOX *) as BOXA *
	///  <summary>
	/// (1) All boxes in boxa not intersecting with box are removed, and
	/// the remaining boxes are clipped to box.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaClipToBox/*"/>
	///  <param name="box">[in] - for clipping</param>
	///   <returns>boxad boxa with boxes in boxas clipped to box, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa ClipToBox (Box box)
	{
		Boxa RetObj = _All.boxaClipToBox(this, box);
		return RetObj;
	}

	// boxfunc1.c (442, 1)
	// boxaCombineOverlaps(boxas, pixadb) as Boxa
	// boxaCombineOverlaps(BOXA *, PIXA *) as BOXA *
	///  <summary>
	/// (1) If there are no overlapping boxes, it simply returns a copy
	/// of %boxas.<para/>
	///
	/// (2) Input an empty %pixadb, using pixaCreate(0), for debug output.
	/// The output gives 2 visualizations of the boxes per iteration
	/// boxes in red before, and added boxes in green after. Note that
	/// all pixels in the red boxes are contained in the green ones.<para/>
	///
	/// (3) The alternative method of painting each rectangle and finding
	/// the 4-connected components gives a different result in
	/// general, because two non-overlapping (but touching)
	/// rectangles, when rendered, are 4-connected and will be joined.<para/>
	///
	/// (4) A bad case computationally is to have n boxes, none of which
	/// overlap.  Then you have one iteration with O(n^2) compares.
	/// This is still faster than painting each rectangle and finding
	/// the bounding boxes of the connected components, even for
	/// thousands of rectangles.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaCombineOverlaps/*"/>
	///  <param name="pixadb">[in,out] - debug output</param>
	///   <returns>boxad where each set of boxes in boxas that overlap are combined into a single bounding box in boxad, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa CombineOverlaps (ref Pixa pixadb)
	{
		Boxa RetObj = _All.boxaCombineOverlaps(this, ref pixadb);
		return RetObj;
	}

	// boxfunc1.c (536, 1)
	// boxaCombineOverlapsInPair(boxas1, boxas2, pboxad1, pboxad2, pixadb) as int
	// boxaCombineOverlapsInPair(BOXA *, BOXA *, BOXA **, BOXA **, PIXA *) as l_ok
	///  <summary>
	/// (1) One of three things happens to each box in %boxa1 and %boxa2:
	/// it gets absorbed into a larger box that it overlaps with
	/// it absorbs a smaller (by area) box that it overlaps with
	/// and gets larger, using the bounding region of the 2 boxes
	/// it is unchanged (including absorbing smaller boxes that
	/// are contained within it).<para/>
	///
	/// (2) If all the boxes from one of the input boxa are absorbed, this
	/// returns an empty boxa.<para/>
	///
	/// (3) Input an empty %pixadb, using pixaCreate(0), for debug output<para/>
	///
	/// (4) This is useful if different operations are to be carried out
	/// on possibly overlapping rectangular regions, and it is desired
	/// to have only one operation on any rectangular region.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaCombineOverlapsInPair/*"/>
	///  <param name="boxas1">[in] - input boxa1</param>
	///  <param name="boxas2">[in] - input boxa2</param>
	///  <param name="pboxad1">[out] - output boxa1</param>
	///  <param name="pboxad2">[out] - output boxa2</param>
	///  <param name="pixadb">[in,out] - debug output</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CombineOverlapsInPair (Boxa boxas1,
									  Boxa boxas2,
									  out Boxa pboxad1,
									  out Boxa pboxad2,
									  ref Pixa pixadb)
	{
		int RetObj = _All.boxaCombineOverlapsInPair(boxas1, boxas2, out pboxad1, out pboxad2, ref pixadb);
		return RetObj;
	}

	// boxfunc1.c (853, 1)
	// boxaHandleOverlaps(boxas, op, range, min_overlap, max_ratio, pnamap) as Boxa
	// boxaHandleOverlaps(BOXA *, l_int32, l_int32, l_float32, l_float32, NUMA **) as BOXA *
	///  <summary>
	/// (1) For all n(n-1)/2 box pairings, if two boxes overlap, either:
	/// (a) op == L_COMBINE: get the bounding region for the two,
	/// replace the larger with the bounding region, and remove
	/// the smaller of the two, or
	/// (b) op == L_REMOVE_SMALL: just remove the smaller.<para/>
	///
	/// (2) If boxas is 2D sorted, range can be small, but if it is
	/// not spatially sorted, range should be large to allow all
	/// pairwise comparisons to be made.<para/>
	///
	/// (3) The %min_overlap parameter allows ignoring small overlaps.
	/// If %min_overlap == 1.0, only boxes fully contained in larger
	/// boxes can be considered for removal if %min_overlap == 0.0,
	/// this constraint is ignored.<para/>
	///
	/// (4) The %max_ratio parameter allows ignoring overlaps between
	/// boxes that are not too different in size.  If %max_ratio == 0.0,
	/// no boxes can be removed if %max_ratio == 1.0, this constraint
	/// is ignored.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaHandleOverlaps/*"/>
	///  <param name="op">[in] - L_COMBINE, L_REMOVE_SMALL</param>
	///  <param name="range">[in] - is greater  0, forward distance over which overlaps are checked</param>
	///  <param name="min_overlap">[in] - minimum fraction of smaller box required for overlap to count 0.0 to ignore</param>
	///  <param name="max_ratio">[in] - maximum fraction of small/large areas for overlap to count 1.0 to ignore</param>
	///  <param name="pnamap">[out][optional] - combining map</param>
	///   <returns>boxad, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa HandleOverlaps (int op,
								int range,
								Single min_overlap,
								Single max_ratio,
								out Numa pnamap)
	{
		Boxa RetObj = _All.boxaHandleOverlaps(this, op, range, min_overlap, max_ratio, out pnamap);
		return RetObj;
	}

	// boxfunc1.c (1115, 1)
	// boxaGetNearestToPt(boxa, x, y) as Box
	// boxaGetNearestToPt(BOXA *, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) Uses euclidean distance between centroid and point.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetNearestToPt/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="x">[in] - point</param>
	///  <param name="y">[in] - point</param>
	///   <returns>box with centroid closest to the given point [x,y], or NULL if no boxes in boxa</returns>
	// CreateAdditiveFunction: Function/Else
	public Box GetNearestToPt (Boxa boxa,
							   int x,
							   int y)
	{
		Box RetObj = _All.boxaGetNearestToPt(boxa, x, y);
		return RetObj;
	}

	// boxfunc1.c (1167, 1)
	// boxaGetNearestToLine(boxa, x, y) as Box
	// boxaGetNearestToLine(BOXA *, l_int32, l_int32) as BOX *
	///  <summary>
	/// (1) For a horizontal line at some value y, get the minimum of the
	/// distance |yc - y| from the box centroid yc value to y
	/// likewise minimize |xc - x| for a vertical line at x.<para/>
	///
	/// (2) Input y  is smaller 0, x greater or equal 0 to indicate a vertical line at x, and
	/// x  is smaller 0, y greater or equal 0 for a horizontal line at y.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetNearestToLine/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="x">[in] - (y = -1 for vertical line x = -1 for horiz line)</param>
	///  <param name="y">[in] - (y = -1 for vertical line x = -1 for horiz line)</param>
	///   <returns>box with centroid closest to the given line, or NULL if no boxes in boxa</returns>
	// CreateAdditiveFunction: Function/Else
	public Box GetNearestToLine (Boxa boxa,
								 int x,
								 int y)
	{
		Box RetObj = _All.boxaGetNearestToLine(boxa, x, y);
		return RetObj;
	}

	// boxfunc1.c (1224, 1)
	// boxaFindNearestBoxes(boxa, dist_select, range, pnaaindex, pnaadist) as int
	// boxaFindNearestBoxes(BOXA *, l_int32, l_int32, NUMAA **, NUMAA **) as l_ok
	///  <summary>
	/// (1) See boxaGetNearestByDirection() for usage of %dist_select
	/// and %range.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaFindNearestBoxes/*"/>
	///  <param name="boxa">[in] - either unsorted, or 2D sorted in LR/TB scan order</param>
	///  <param name="dist_select">[in] - L_NON_NEGATIVE, L_ALL</param>
	///  <param name="range">[in] - search distance from box i use 0 to search entire boxa (e.g., if it's not 2D sorted)</param>
	///  <param name="pnaaindex">[out] - for each box in %boxa, contains a numa of 4 box indices (per direction) of the nearest box</param>
	///  <param name="pnaadist">[out] - for each box in %boxa, this contains a numa</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindNearestBoxes (Boxa boxa,
								 int dist_select,
								 int range,
								 out Numaa pnaaindex,
								 out Numaa pnaadist)
	{
		int RetObj = _All.boxaFindNearestBoxes(boxa, dist_select, range, out pnaaindex, out pnaadist);
		return RetObj;
	}

	// boxfunc1.c (1305, 1)
	// boxaGetNearestByDirection(boxa, i, dir, dist_select, range, pindex, pdist) as int
	// boxaGetNearestByDirection(BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) For efficiency, use a LR/TD sorted %boxa, which can be
	/// made by flattening a 2D sorted boxaa.  In that case,
	/// %range can be some positive integer like 50.<para/>
	///
	/// (2) If boxes overlap, the distance will be  is smaller 0.  Use %dist_select
	/// to determine if these should count or not.  If L_ALL, then
	/// one box will match as the nearest to another in 2 or more
	/// directions.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetNearestByDirection/*"/>
	///  <param name="boxa">[in] - either unsorted, or 2D sorted in LR/TB scan order</param>
	///  <param name="i">[in] - box we test against</param>
	///  <param name="dir">[in] - direction to look: L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
	///  <param name="dist_select">[in] - L_NON_NEGATIVE, L_ALL</param>
	///  <param name="range">[in] - search distance from box i use 0 to search entire boxa (e.g., if it's not 2D sorted)</param>
	///  <param name="pindex">[out] - index in boxa of nearest box with overlapping coordinates in the indicated direction -1 if there is no box</param>
	///  <param name="pdist">[out] - distance of the nearest box in the indicated direction 100000 if no box</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetNearestByDirection (Boxa boxa,
									  int i,
									  int dir,
									  int dist_select,
									  int range,
									  out int pindex,
									  out int pdist)
	{
		int RetObj = _All.boxaGetNearestByDirection(boxa, i, dir, dist_select, range, out pindex, out pdist);
		return RetObj;
	}

	// boxfunc1.c (1750, 1)
	// boxaAdjustSides(boxas, delleft, delright, deltop, delbot) as Boxa
	// boxaAdjustSides(BOXA *, l_int32, l_int32, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) New box dimensions are cropped at left and top to x greater or equal 0 and y greater or equal 0.<para/>
	///
	/// (2) If the width or height of a box goes to 0, we generate a box with
	/// w == 1 and h == 1, as a placeholder.<para/>
	///
	/// (3) See boxAdjustSides().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaAdjustSides/*"/>
	///  <param name="delleft">[in] - changes in location of each side for each box</param>
	///  <param name="delright">[in] - changes in location of each side for each box</param>
	///  <param name="deltop">[in] - changes in location of each side for each box</param>
	///  <param name="delbot">[in] - changes in location of each side for each box</param>
	///   <returns>boxad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa AdjustSides (int delleft,
							 int delright,
							 int deltop,
							 int delbot)
	{
		Boxa RetObj = _All.boxaAdjustSides(this, delleft, delright, deltop, delbot);
		return RetObj;
	}

	// boxfunc1.c (1859, 1)
	// boxaSetSide(boxad, boxas, side, val, thresh) as Boxa
	// boxaSetSide(BOXA *, BOXA *, l_int32, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) Sets the given side of each box.  Use boxad == NULL for a new
	/// boxa, and boxad == boxas for in-place.<para/>
	///
	/// (2) Use one of these:
	/// boxad = boxaSetSide(NULL, boxas, ...) // new
	/// boxaSetSide(boxas, boxas, ...)  // in-place
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSetSide/*"/>
	///  <param name="boxad">[in] - use NULL to get a new one same as boxas for in-place</param>
	///  <param name="side">[in] - L_SET_LEFT, L_SET_RIGHT, L_SET_TOP, L_SET_BOT</param>
	///  <param name="val">[in] - location to set for given side, for each box</param>
	///  <param name="thresh">[in] - min abs difference to cause resetting to %val</param>
	///   <returns>boxad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa SetSide (Boxa boxad,
						 int side,
						 int val,
						 int thresh)
	{
		Boxa RetObj = _All.boxaSetSide(boxad, this, side, val, thresh);
		return RetObj;
	}

	// boxfunc1.c (1932, 1)
	// boxaAdjustWidthToTarget(boxad, boxas, sides, target, thresh) as Boxa
	// boxaAdjustWidthToTarget(BOXA *, BOXA *, l_int32, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) Conditionally adjusts the width of each box, by moving
	/// the indicated edges (left and/or right) if the width differs
	/// by %thresh or more from %target.<para/>
	///
	/// (2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.
	/// Use one of these:
	/// boxad = boxaAdjustWidthToTarget(NULL, boxas, ...) // new
	/// boxaAdjustWidthToTarget(boxas, boxas, ...)  // in-place
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaAdjustWidthToTarget/*"/>
	///  <param name="boxad">[in] - use NULL to get a new one same as boxas for in-place</param>
	///  <param name="sides">[in] - L_ADJUST_LEFT, L_ADJUST_RIGHT, L_ADJUST_LEFT_AND_RIGHT</param>
	///  <param name="target">[in] - target width if differs by more than thresh</param>
	///  <param name="thresh">[in] - min abs difference in width to cause adjustment</param>
	///   <returns>boxad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa AdjustWidthToTarget (Boxa boxad,
									 int sides,
									 int target,
									 int thresh)
	{
		Boxa RetObj = _All.boxaAdjustWidthToTarget(boxad, this, sides, target, thresh);
		return RetObj;
	}

	// boxfunc1.c (1999, 1)
	// boxaAdjustHeightToTarget(boxad, boxas, sides, target, thresh) as Boxa
	// boxaAdjustHeightToTarget(BOXA *, BOXA *, l_int32, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) Conditionally adjusts the height of each box, by moving
	/// the indicated edges (top and/or bot) if the height differs
	/// by %thresh or more from %target.<para/>
	///
	/// (2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.
	/// Use one of these:
	/// boxad = boxaAdjustHeightToTarget(NULL, boxas, ...) // new
	/// boxaAdjustHeightToTarget(boxas, boxas, ...)  // in-place
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaAdjustHeightToTarget/*"/>
	///  <param name="boxad">[in] - use NULL to get a new one</param>
	///  <param name="sides">[in] - L_ADJUST_TOP, L_ADJUST_BOT, L_ADJUST_TOP_AND_BOT</param>
	///  <param name="target">[in] - target height if differs by more than thresh</param>
	///  <param name="thresh">[in] - min abs difference in height to cause adjustment</param>
	///   <returns>boxad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa AdjustHeightToTarget (Boxa boxad,
									  int sides,
									  int target,
									  int thresh)
	{
		Boxa RetObj = _All.boxaAdjustHeightToTarget(boxad, this, sides, target, thresh);
		return RetObj;
	}

	// boxfunc1.c (2104, 1)
	// boxaEqual(boxa1, boxa2, maxdist, pnaindex, psame) as int
	// boxaEqual(BOXA *, BOXA *, l_int32, NUMA **, l_int32 *) as l_ok
	///  <summary>
	/// (1) The two boxa are the "same" if they contain the same
	/// boxes and each box is within %maxdist of its counterpart
	/// in their positions within the boxa.  This allows for
	/// small rearrangements.  Use 0 for maxdist if the boxa
	/// must be identical.<para/>
	///
	/// (2) This applies only to geometry and ordering refcounts
	/// are not considered.<para/>
	///
	/// (3) %maxdist allows some latitude in the ordering of the boxes.
	/// For the boxa to be the "same", corresponding boxes must
	/// be within %maxdist of each other.  Note that for large
	/// %maxdist, we should use a hash function for efficiency.<para/>
	///
	/// (4) naindex[i] gives the position of the box in boxa2 that
	/// corresponds to box i in boxa1.  It is only returned if the
	/// boxa are equal.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaEqual/*"/>
	///  <param name="boxa1">[in] - </param>
	///  <param name="boxa2">[in] - </param>
	///  <param name="maxdist">[in] - </param>
	///  <param name="pnaindex">[out][optional] - index array of correspondences</param>
	///  <param name="psame">[out] - (1 if equal 0 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Equal (Boxa boxa1,
					  Boxa boxa2,
					  int maxdist,
					  out int psame,
					  out Numa pnaindex)
	{
		int RetObj = _All.boxaEqual(boxa1, boxa2, maxdist, out pnaindex, out psame);
		return RetObj;
	}

	// boxfunc1.c (2238, 1)
	// boxaSimilar(boxa1, boxa2, leftdiff, rightdiff, topdiff, botdiff, debug, psimilar, pnasim) as int
	// boxaSimilar(BOXA *, BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32 *, NUMA **) as l_ok
	///  <summary>
	/// (1) See boxSimilar() for parameter usage.<para/>
	///
	/// (2) Corresponding boxes are taken in order in the two boxa.<para/>
	///
	/// (3) %nasim is an indicator array with a (0/1) for each box pair.<para/>
	///
	/// (4) With %nasim or debug == 1, boxes continue to be tested
	/// after failure.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSimilar/*"/>
	///  <param name="boxa1">[in] - </param>
	///  <param name="boxa2">[in] - </param>
	///  <param name="leftdiff">[in] - </param>
	///  <param name="rightdiff">[in] - </param>
	///  <param name="topdiff">[in] - </param>
	///  <param name="botdiff">[in] - </param>
	///  <param name="debug">[in] - output details of non-similar boxes</param>
	///  <param name="psimilar">[out] - 1 if similar 0 otherwise</param>
	///  <param name="pnasim">[out][optional] - na containing 1 if similar else 0</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Similar (Boxa boxa1,
						Boxa boxa2,
						int leftdiff,
						int rightdiff,
						int topdiff,
						int botdiff,
						out int psimilar,
						DebugOnOff debug,
						out Numa pnasim)
	{
		int RetObj = _All.boxaSimilar(boxa1, boxa2, leftdiff, rightdiff, topdiff, botdiff, debug, out psimilar, out pnasim);
		return RetObj;
	}

	// boxfunc1.c (2312, 1)
	// boxaJoin(boxad, boxas, istart, iend) as int
	// boxaJoin(BOXA *, BOXA *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This appends a clone of each indicated box in boxas to boxad<para/>
	///
	/// (2) istart  is smaller 0 is taken to mean 'read from the start' (istart = 0)<para/>
	///
	/// (3) iend  is smaller 0 means 'read to the end'<para/>
	///
	/// (4) if boxas == NULL or has no boxes, this is a no-op.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaJoin/*"/>
	///  <param name="boxad">[in] - dest boxa add to this one</param>
	///  <param name="istart">[in] - starting index in boxas</param>
	///  <param name="iend">[in] - ending index in boxas use -1 to cat all</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Join (Boxa boxad,
					 int istart,
					 int iend)
	{
		int RetObj = _All.boxaJoin(boxad, this, istart, iend);
		return RetObj;
	}

	// boxfunc1.c (2411, 1)
	// boxaSplitEvenOdd(boxa, fillflag, pboxae, pboxao) as int
	// boxaSplitEvenOdd(BOXA *, l_int32, BOXA **, BOXA **) as l_ok
	///  <summary>
	/// (1) If %fillflag == 1, boxae has copies of the even boxes
	/// in their original location, and nvalid boxes are placed
	/// in the odd array locations.  And v.v.<para/>
	///
	/// (2) If %fillflag == 0, boxae has only copies of the even boxes.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSplitEvenOdd/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="fillflag">[in] - 1 to put invalid boxes in place 0 to omit</param>
	///  <param name="pboxae">[out] - save even and odd boxes in their separate boxa, setting the other type to invalid boxes.</param>
	///  <param name="pboxao">[out] - save even and odd boxes in their separate boxa, setting the other type to invalid boxes.</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SplitEvenOdd (Boxa boxa,
							 int fillflag,
							 out Boxa pboxae,
							 out Boxa pboxao)
	{
		int RetObj = _All.boxaSplitEvenOdd(boxa, fillflag, out pboxae, out pboxao);
		return RetObj;
	}

	// boxfunc1.c (2475, 1)
	// boxaMergeEvenOdd(boxae, boxao, fillflag) as Boxa
	// boxaMergeEvenOdd(BOXA *, BOXA *, l_int32) as BOXA *
	///  <summary>
	/// (1) This is essentially the inverse of boxaSplitEvenOdd().
	/// Typically, boxae and boxao were generated by boxaSplitEvenOdd(),
	/// and the value of %fillflag needs to be the same in both calls.<para/>
	///
	/// (2) If %fillflag == 1, both boxae and boxao are of the same size
	/// otherwise boxae may have one more box than boxao.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaMergeEvenOdd/*"/>
	///  <param name="boxae">[in] - boxes to go in even positions in merged boxa</param>
	///  <param name="boxao">[in] - boxes to go in odd positions in merged boxa</param>
	///  <param name="fillflag">[in] - 1 if there are invalid boxes in placeholders</param>
	///   <returns>boxad merged, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa MergeEvenOdd (Boxa boxae,
							  Boxa boxao,
							  int fillflag)
	{
		Boxa RetObj = _All.boxaMergeEvenOdd(boxae, boxao, fillflag);
		return RetObj;
	}

	// boxfunc2.c (91, 1)
	// boxaTransform(boxas, shiftx, shifty, scalex, scaley) as Boxa
	// boxaTransform(BOXA *, l_int32, l_int32, l_float32, l_float32) as BOXA *
	///  <summary>
	/// (1) This is a very simple function that first shifts, then scales.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaTransform/*"/>
	///  <param name="shiftx">[in] - </param>
	///  <param name="shifty">[in] - </param>
	///  <param name="scalex">[in] - </param>
	///  <param name="scaley">[in] - </param>
	///   <returns>boxad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa Transform (int shiftx,
						   int shifty,
						   Single scalex,
						   Single scaley)
	{
		Boxa RetObj = _All.boxaTransform(this, shiftx, shifty, scalex, scaley);
		return RetObj;
	}

	// boxfunc2.c (192, 1)
	// boxaTransformOrdered(boxas, shiftx, shifty, scalex, scaley, xcen, ycen, angle, order) as Boxa
	// boxaTransformOrdered(BOXA *, l_int32, l_int32, l_float32, l_float32, l_int32, l_int32, l_float32, l_int32) as BOXA *
	///  <summary>
	/// (1) This allows a sequence of linear transforms on each box.
	/// the transforms are from the affine set, composed of
	/// shift, scaling and rotation, and the order of the
	/// transforms is specified.<para/>
	///
	/// (2) Although these operations appear to be on an infinite
	/// 2D plane, in practice the region of interest is clipped
	/// to a finite image.  The center of rotation is usually taken
	/// with respect to the image (either the UL corner or the
	/// center).  A translation can have two very different effects:
	/// (a) Moves the boxes across the fixed image region.
	/// (b) Moves the image origin, causing a change in the image
	/// region and an opposite effective translation of the boxes.
	/// This function should only be used for (a), where the image
	/// region is fixed on translation.  If the image region is
	/// changed by the translation, use instead the functions
	/// in affinecompose.c, where the image region and rotation
	/// center can be computed from the actual clipping due to
	/// translation of the image origin.<para/>
	///
	/// (3) See boxTransformOrdered() for usage and implementation details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaTransformOrdered/*"/>
	///  <param name="shiftx">[in] - </param>
	///  <param name="shifty">[in] - </param>
	///  <param name="scalex">[in] - </param>
	///  <param name="scaley">[in] - </param>
	///  <param name="xcen">[in] - center of rotation</param>
	///  <param name="ycen">[in] - center of rotation</param>
	///  <param name="angle">[in] - in radians clockwise is positive</param>
	///  <param name="order">[in] - one of 6 combinations: L_TR_SC_RO, ...</param>
	///   <returns>boxd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa TransformOrdered (int shiftx,
								  int shifty,
								  int xcen,
								  int ycen,
								  Single angle,
								  int order,
								  Single scalex,
								  Single scaley)
	{
		Boxa RetObj = _All.boxaTransformOrdered(this, shiftx, shifty, scalex, scaley, xcen, ycen, angle, order);
		return RetObj;
	}

	// boxfunc2.c (454, 1)
	// boxaRotateOrth(boxas, w, h, rotation) as Boxa
	// boxaRotateOrth(BOXA *, l_int32, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) See boxRotateOrth() for details.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaRotateOrth/*"/>
	///  <param name="w">[in] - of image in which the boxa is embedded</param>
	///  <param name="h">[in] - of image in which the boxa is embedded</param>
	///  <param name="rotation">[in] - 0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg all rotations are clockwise</param>
	///   <returns>boxad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa RotateOrth (int w,
							int h,
							int rotation)
	{
		Boxa RetObj = _All.boxaRotateOrth(this, w, h, rotation);
		return RetObj;
	}

	// boxfunc2.c (560, 1)
	// boxaSort(boxas, sorttype, sortorder, pnaindex) as Boxa
	// boxaSort(BOXA *, l_int32, l_int32, NUMA **) as BOXA *
	///  <summary>
	/// (1) An empty boxa returns a copy, with a warning.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSort/*"/>
	///  <param name="sorttype">[in] - L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_RIGHT, L_SORT_BY_BOT, L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER, L_SORT_BY_AREA, L_SORT_BY_ASPECT_RATIO</param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING, L_SORT_DECREASING</param>
	///  <param name="pnaindex">[out][optional] - index of sorted order into original array</param>
	///   <returns>boxad sorted version of boxas, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa Sort (int sorttype,
					  int sortorder,
					  out Numa pnaindex)
	{
		Boxa RetObj = _All.boxaSort(this, sorttype, sortorder, out pnaindex);
		return RetObj;
	}

	// boxfunc2.c (684, 1)
	// boxaBinSort(boxas, sorttype, sortorder, pnaindex) as Boxa
	// boxaBinSort(BOXA *, l_int32, l_int32, NUMA **) as BOXA *
	///  <summary>
	/// (1) For a large number of boxes (say, greater than 1000), this
	/// O(n) binsort is much faster than the O(nlogn) shellsort.
	/// For 5000 components, this is over 20x faster than boxaSort().<para/>
	///
	/// (2) Consequently, boxaSort() calls this function if it will
	/// likely go much faster.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaBinSort/*"/>
	///  <param name="sorttype">[in] - L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_PERIMETER</param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING, L_SORT_DECREASING</param>
	///  <param name="pnaindex">[out][optional] - index of sorted order into original array</param>
	///   <returns>boxad sorted version of boxas, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa BinSort (int sorttype,
						 int sortorder,
						 out Numa pnaindex)
	{
		Boxa RetObj = _All.boxaBinSort(this, sorttype, sortorder, out pnaindex);
		return RetObj;
	}

	// boxfunc2.c (761, 1)
	// boxaSortByIndex(boxas, naindex) as Boxa
	// boxaSortByIndex(BOXA *, NUMA *) as BOXA *
	///  <summary>
	/// boxaSortByIndex()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSortByIndex/*"/>
	///  <param name="naindex">[in] - na that maps from the new boxa to the input boxa</param>
	///   <returns>boxad sorted, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa SortByIndex (Numa naindex)
	{
		Boxa RetObj = _All.boxaSortByIndex(this, naindex);
		return RetObj;
	}

	// boxfunc2.c (837, 1)
	// boxaSort2d(boxas, pnaad, delta1, delta2, minh1) as Boxaa
	// boxaSort2d(BOXA *, NUMAA **, l_int32, l_int32, l_int32) as BOXAA *
	///  <summary>
	/// (1) The final result is a sort where the 'fast scan' direction is
	/// left to right, and the 'slow scan' direction is from top
	/// to bottom.  Each boxa in the baa represents a sorted set
	/// of boxes from left to right.<para/>
	///
	/// (2) Three passes are used to aggregate the boxas, which can correspond
	/// to characters or words in a line of text.  In pass 1, only
	/// taller components, which correspond to xheight or larger,
	/// are permitted to start a new boxa.  In pass 2, the remaining
	/// vertically-challenged components are allowed to join an
	/// existing boxa or start a new one.  In pass 3, boxa whose extent
	/// is overlapping are joined.  After that, the boxes in each
	/// boxa are sorted horizontally, and finally the boxa are
	/// sorted vertically.<para/>
	///
	/// (3) If delta1  is smaller 0, the first pass allows aggregation when
	/// boxes in the same boxa do not overlap vertically.
	/// The distance by which they can miss and still be aggregated
	/// is the absolute value |delta1|. Similar for delta2 on
	/// the second pass.<para/>
	///
	/// (4) On the first pass, any component of height less than minh1
	/// cannot start a new boxa it's put aside for later insertion.<para/>
	///
	/// (5) On the second pass, any small component that doesn't align
	/// with an existing boxa can start a new one.<para/>
	///
	/// (6) This can be used to identify lines of text from
	/// character or word bounding boxes.<para/>
	///
	/// (7) Typical values for the input parameters on 300 ppi text are:
	/// delta1 ~ 0
	/// delta2 ~ 0
	/// minh1 ~ 5
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSort2d/*"/>
	///  <param name="pnaad">[out][optional] - numaa with sorted indices whose values are the indices of the input array</param>
	///  <param name="delta1">[in] - min overlap that permits aggregation of a box onto a boxa of horizontally-aligned boxes pass 1</param>
	///  <param name="delta2">[in] - min overlap that permits aggregation of a box onto a boxa of horizontally-aligned boxes pass 2</param>
	///  <param name="minh1">[in] - components less than this height either join an existing boxa or are set aside for pass 2</param>
	///   <returns>baa 2d sorted version of boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxaa Sort2d (int delta1,
						 int delta2,
						 int minh1,
						 out Numaa pnaad)
	{
		Boxaa RetObj = _All.boxaSort2d(this, out pnaad, delta1, delta2, minh1);
		return RetObj;
	}

	// boxfunc2.c (1024, 1)
	// boxaSort2dByIndex(boxas, naa) as Boxaa
	// boxaSort2dByIndex(BOXA *, NUMAA *) as BOXAA *
	///  <summary>
	/// boxaSort2dByIndex()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSort2dByIndex/*"/>
	///  <param name="naa">[in] - numaa that maps from the new baa to the input boxa</param>
	///   <returns>baa sorted boxaa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxaa Sort2dByIndex (Numaa naa)
	{
		Boxaa RetObj = _All.boxaSort2dByIndex(this, naa);
		return RetObj;
	}

	// boxfunc2.c (1093, 1)
	// boxaExtractAsNuma(boxa, pnal, pnat, pnar, pnab, pnaw, pnah, keepinvalid) as int
	// boxaExtractAsNuma(BOXA *, NUMA **, NUMA **, NUMA **, NUMA **, NUMA **, NUMA **, l_int32) as l_ok
	///  <summary>
	/// (1) If you are counting or sorting values, such as determining
	/// rank order, you must remove invalid boxes.<para/>
	///
	/// (2) If you are parametrizing the values, or doing an evaluation
	/// where the position in the boxa sequence is important, you
	/// must replace the invalid boxes with valid ones before
	/// doing the extraction. This is easily done with boxaFillSequence().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaExtractAsNuma/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="pnal">[out][optional] - array of left locations</param>
	///  <param name="pnat">[out][optional] - array of top locations</param>
	///  <param name="pnar">[out][optional] - array of right locations</param>
	///  <param name="pnab">[out][optional] - array of bottom locations</param>
	///  <param name="pnaw">[out][optional] - array of widths</param>
	///  <param name="pnah">[out][optional] - array of heights</param>
	///  <param name="keepinvalid">[in] - 1 to keep invalid boxes 0 to remove them</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ExtractAsNuma (Boxa boxa,
							  int keepinvalid,
							  out Numa pnal,
							  out Numa pnat,
							  out Numa pnar,
							  out Numa pnab,
							  out Numa pnaw,
							  out Numa pnah)
	{
		int RetObj = _All.boxaExtractAsNuma(boxa, out pnal, out pnat, out pnar, out pnab, out pnaw, out pnah, keepinvalid);
		return RetObj;
	}

	// boxfunc2.c (1170, 1)
	// boxaExtractAsPta(boxa, pptal, pptat, pptar, pptab, pptaw, pptah, keepinvalid) as int
	// boxaExtractAsPta(BOXA *, PTA **, PTA **, PTA **, PTA **, PTA **, PTA **, l_int32) as l_ok
	///  <summary>
	/// (1) For most applications, such as counting, sorting, fitting
	/// to some parametrized form, plotting or filtering in general,
	/// you should remove the invalid boxes.  Each pta saves the
	/// box index in the x array, so replacing invalid boxes by
	/// filling with boxaFillSequence(), which is required for
	/// boxaExtractAsNuma(), is not necessary.<para/>
	///
	/// (2) If invalid boxes are retained, each one will result in
	/// entries (typically 0) in all selected output pta.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaExtractAsPta/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="pptal">[out][optional] - array of left locations vs. index</param>
	///  <param name="pptat">[out][optional] - array of top locations vs. index</param>
	///  <param name="pptar">[out][optional] - array of right locations vs. index</param>
	///  <param name="pptab">[out][optional] - array of bottom locations vs. index</param>
	///  <param name="pptaw">[out][optional] - array of widths vs. index</param>
	///  <param name="pptah">[out][optional] - array of heights vs. index</param>
	///  <param name="keepinvalid">[in] - 1 to keep invalid boxes 0 to remove them</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ExtractAsPta (Boxa boxa,
							 int keepinvalid,
							 out Pta pptal,
							 out Pta pptat,
							 out Pta pptar,
							 out Pta pptab,
							 out Pta pptaw,
							 out Pta pptah)
	{
		int RetObj = _All.boxaExtractAsPta(boxa, out pptal, out pptat, out pptar, out pptab, out pptaw, out pptah, keepinvalid);
		return RetObj;
	}

	// boxfunc2.c (1251, 1)
	// boxaGetRankVals(boxa, fract, px, py, pw, ph) as int
	// boxaGetRankVals(BOXA *, l_float32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) This function does not assume that all boxes in the boxa are valid<para/>
	///
	/// (2) The four box parameters are sorted independently.
	/// For rank order, the width and height are sorted in increasing
	/// order.  But what does it mean to sort x and y in "rank order"?
	/// If the boxes are of comparable size and somewhat
	/// aligned (e.g., from multiple images), it makes some sense
	/// to give a "rank order" for x and y by sorting them in
	/// decreasing order.  But in general, the interpretation of a rank
	/// order on x and y is highly application dependent.  In summary:
	/// ~ x and y are sorted in decreasing order
	/// ~ w and h are sorted in increasing order
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetRankVals/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="fract">[in] - use 0.0 for smallest, 1.0 for largest width and height</param>
	///  <param name="px">[out][optional] - rank value of x</param>
	///  <param name="py">[out][optional] - rank value of y</param>
	///  <param name="pw">[out][optional] - rank value of width</param>
	///  <param name="ph">[out][optional] - rank value of height</param>
	///   <returns>0 if OK, 1 on error or if the boxa is empty or has no valid boxes</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRankVals (Boxa boxa,
							Single fract,
							out int px,
							out int py,
							out int pw,
							out int ph)
	{
		int RetObj = _All.boxaGetRankVals(boxa, fract, out px, out py, out pw, out ph);
		return RetObj;
	}

	// boxfunc2.c (1317, 1)
	// boxaGetMedianVals(boxa, px, py, pw, ph) as int
	// boxaGetMedianVals(BOXA *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// (1) See boxaGetRankVals()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetMedianVals/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="px">[out][optional] - median value of x</param>
	///  <param name="py">[out][optional] - median value of y</param>
	///  <param name="pw">[out][optional] - median value of width</param>
	///  <param name="ph">[out][optional] - median value of height</param>
	///   <returns>0 if OK, 1 on error or if the boxa is empty or has no valid boxes</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMedianVals (Boxa boxa,
							  out int px,
							  out int py,
							  out int pw,
							  out int ph)
	{
		int RetObj = _All.boxaGetMedianVals(boxa, out px, out py, out pw, out ph);
		return RetObj;
	}

	// boxfunc2.c (1343, 1)
	// boxaGetAverageSize(boxa, pw, ph) as int
	// boxaGetAverageSize(BOXA *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// boxaGetAverageSize()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetAverageSize/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="pw">[out][optional] - average width</param>
	///  <param name="ph">[out][optional] - average height</param>
	///   <returns>0 if OK, 1 on error or if the boxa is empty</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetAverageSize (Boxa boxa,
							   out Single pw,
							   out Single ph)
	{
		int RetObj = _All.boxaGetAverageSize(boxa, out pw, out ph);
		return RetObj;
	}

	// boxfunc2.c (1602, 1)
	// boxaEncapsulateAligned(boxa, num, copyflag) as Boxaa
	// boxaEncapsulateAligned(BOXA *, l_int32, l_int32) as BOXAA *
	///  <summary>
	/// (1) This puts %num boxes from the input %boxa into each of a
	/// set of boxa within an output baa.<para/>
	///
	/// (2) This assumes that the boxes in %boxa are in sets of %num each.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaEncapsulateAligned/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="num">[in] - number put into each boxa in the baa</param>
	///  <param name="copyflag">[in] - L_COPY or L_CLONE</param>
	///   <returns>baa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxaa EncapsulateAligned (Boxa boxa,
									 int num,
									 int copyflag)
	{
		Boxaa RetObj = _All.boxaEncapsulateAligned(boxa, num, copyflag);
		return RetObj;
	}

	// boxfunc3.c (1388, 1)
	// boxaCompareRegions(boxa1, boxa2, areathresh, pnsame, pdiffarea, pdiffxor, ppixdb) as int
	// boxaCompareRegions(BOXA *, BOXA *, l_int32, l_int32 *, l_float32 *, l_float32 *, PIX **) as l_ok
	///  <summary>
	/// (1) This takes 2 boxa, removes all boxes smaller than a given area,
	/// and compares the remaining boxes between the boxa.<para/>
	///
	/// (2) The area threshold is introduced to help remove noise from
	/// small components.  Any box with a smaller value of w  h
	/// will be removed from consideration.<para/>
	///
	/// (3) The xor difference is the most stringent test, requiring alignment
	/// of the corresponding boxes.  It is also more computationally
	/// intensive and is optionally returned.  Alignment is to the
	/// UL corner of each region containing all boxes, as given by
	/// boxaGetExtent().<para/>
	///
	/// (4) Both fractional differences are with respect to the total
	/// area in the two boxa.  They range from 0.0 to 1.0.
	/// A perfect match has value 0.0.  If both boxa are empty,
	/// we return 0.0 if one is empty we return 1.0.<para/>
	///
	/// (5) An example input might be the rectangular regions of a
	/// segmentation mask for text or images from two pages.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaCompareRegions/*"/>
	///  <param name="boxa1">[in] - </param>
	///  <param name="boxa2">[in] - </param>
	///  <param name="areathresh">[in] - minimum area of boxes to be considered</param>
	///  <param name="pnsame">[out] - true if same number of boxes</param>
	///  <param name="pdiffarea">[out] - fractional difference in total area</param>
	///  <param name="pdiffxor">[out][optional] - fractional difference in xor of regions</param>
	///  <param name="ppixdb">[out][optional] - debug pix showing two boxa</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CompareRegions (Boxa boxa1,
							   Boxa boxa2,
							   int areathresh,
							   out int pnsame,
							   out Single pdiffarea,
							   out Single pdiffxor,
							   out Pix ppixdb)
	{
		int RetObj = _All.boxaCompareRegions(boxa1, boxa2, areathresh, out pnsame, out pdiffarea, out pdiffxor, out ppixdb);
		return RetObj;
	}

	// boxfunc3.c (1573, 1)
	// boxaSelectLargeULBox(boxas, areaslop, yslop) as Box
	// boxaSelectLargeULBox(BOXA *, l_float32, l_int32) as BOX *
	///  <summary>
	/// (1) See usage notes in pixSelectLargeULComp().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSelectLargeULBox/*"/>
	///  <param name="areaslop">[in] - fraction near but less than 1.0</param>
	///  <param name="yslop">[in] - number of pixels in y direction</param>
	///   <returns>box, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box SelectLargeULBox (Single areaslop,
								 int yslop)
	{
		Box RetObj = _All.boxaSelectLargeULBox(this, areaslop, yslop);
		return RetObj;
	}

	// boxfunc4.c (111, 1)
	// boxaSelectRange(boxas, first, last, copyflag) as Boxa
	// boxaSelectRange(BOXA *, l_int32, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) The copyflag specifies what we do with each box from boxas.
	/// Specifically, L_CLONE inserts a clone into boxad of each
	/// selected box from boxas.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSelectRange/*"/>
	///  <param name="first">[in] - use 0 to select from the beginning</param>
	///  <param name="last">[in] - use 0 to select to the end</param>
	///  <param name="copyflag">[in] - L_COPY, L_CLONE</param>
	///   <returns>boxad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa SelectRange (int first,
							 int last,
							 int copyflag)
	{
		Boxa RetObj = _All.boxaSelectRange(this, first, last, copyflag);
		return RetObj;
	}

	// boxfunc4.c (227, 1)
	// boxaSelectBySize(boxas, width, height, type, relation, pchanged) as Boxa
	// boxaSelectBySize(BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32 *) as BOXA *
	///  <summary>
	/// (1) The args specify constraints on the size of the
	/// components that are kept.<para/>
	///
	/// (2) Uses box copies in the new boxa.<para/>
	///
	/// (3) If the selection type is L_SELECT_WIDTH, the input
	/// height is ignored, and v.v.<para/>
	///
	/// (4) To keep small components, use relation = L_SELECT_IF_LT or
	/// L_SELECT_IF_LTE.
	/// To keep large components, use relation = L_SELECT_IF_GT or
	/// L_SELECT_IF_GTE.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSelectBySize/*"/>
	///  <param name="width">[in] - threshold dimensions</param>
	///  <param name="height">[in] - threshold dimensions</param>
	///  <param name="type">[in] - L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	///  <param name="relation">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>boxad filtered set, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa SelectBySize (int width,
							  int height,
							  int type,
							  int relation,
							  out int pchanged)
	{
		Boxa RetObj = _All.boxaSelectBySize(this, width, height, type, relation, out pchanged);
		return RetObj;
	}

	// boxfunc4.c (290, 1)
	// boxaMakeSizeIndicator(boxa, width, height, type, relation) as Numa
	// boxaMakeSizeIndicator(BOXA *, l_int32, l_int32, l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) The args specify constraints on the size of the
	/// components that are kept.<para/>
	///
	/// (2) If the selection type is L_SELECT_WIDTH, the input
	/// height is ignored, and v.v.<para/>
	///
	/// (3) To keep small components, use relation = L_SELECT_IF_LT or
	/// L_SELECT_IF_LTE.
	/// To keep large components, use relation = L_SELECT_IF_GT or
	/// L_SELECT_IF_GTE.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaMakeSizeIndicator/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="width">[in] - threshold dimensions</param>
	///  <param name="height">[in] - threshold dimensions</param>
	///  <param name="type">[in] - L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	///  <param name="relation">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///   <returns>na indicator array, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa MakeSizeIndicator (Boxa boxa,
								   int width,
								   int height,
								   int type,
								   int relation)
	{
		Numa RetObj = _All.boxaMakeSizeIndicator(boxa, width, height, type, relation);
		return RetObj;
	}

	// boxfunc4.c (377, 1)
	// boxaSelectByArea(boxas, area, relation, pchanged) as Boxa
	// boxaSelectByArea(BOXA *, l_int32, l_int32, l_int32 *) as BOXA *
	///  <summary>
	/// (1) Uses box copies in the new boxa.<para/>
	///
	/// (2) To keep small components, use relation = L_SELECT_IF_LT or
	/// L_SELECT_IF_LTE.
	/// To keep large components, use relation = L_SELECT_IF_GT or
	/// L_SELECT_IF_GTE.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSelectByArea/*"/>
	///  <param name="area">[in] - threshold value of width  height</param>
	///  <param name="relation">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>boxad filtered set, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa SelectByArea (int area,
							  int relation,
							  out int pchanged)
	{
		Boxa RetObj = _All.boxaSelectByArea(this, area, relation, out pchanged);
		return RetObj;
	}

	// boxfunc4.c (427, 1)
	// boxaMakeAreaIndicator(boxa, area, relation) as Numa
	// boxaMakeAreaIndicator(BOXA *, l_int32, l_int32) as NUMA *
	///  <summary>
	/// (1) To keep small components, use relation = L_SELECT_IF_LT or
	/// L_SELECT_IF_LTE.
	/// To keep large components, use relation = L_SELECT_IF_GT or
	/// L_SELECT_IF_GTE.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaMakeAreaIndicator/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="area">[in] - threshold value of width  height</param>
	///  <param name="relation">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///   <returns>na indicator array, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa MakeAreaIndicator (Boxa boxa,
								   int area,
								   int relation)
	{
		Numa RetObj = _All.boxaMakeAreaIndicator(boxa, area, relation);
		return RetObj;
	}

	// boxfunc4.c (481, 1)
	// boxaSelectByWHRatio(boxas, ratio, relation, pchanged) as Boxa
	// boxaSelectByWHRatio(BOXA *, l_float32, l_int32, l_int32 *) as BOXA *
	///  <summary>
	/// (1) Uses box copies in the new boxa.<para/>
	///
	/// (2) To keep narrow components, use relation = L_SELECT_IF_LT or
	/// L_SELECT_IF_LTE.
	/// To keep wide components, use relation = L_SELECT_IF_GT or
	/// L_SELECT_IF_GTE.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSelectByWHRatio/*"/>
	///  <param name="ratio">[in] - width/height threshold value</param>
	///  <param name="relation">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>boxad filtered set, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa SelectByWHRatio (Single ratio,
								 int relation,
								 out int pchanged)
	{
		Boxa RetObj = _All.boxaSelectByWHRatio(this, ratio, relation, out pchanged);
		return RetObj;
	}

	// boxfunc4.c (531, 1)
	// boxaMakeWHRatioIndicator(boxa, ratio, relation) as Numa
	// boxaMakeWHRatioIndicator(BOXA *, l_float32, l_int32) as NUMA *
	///  <summary>
	/// (1) To keep narrow components, use relation = L_SELECT_IF_LT or
	/// L_SELECT_IF_LTE.
	/// To keep wide components, use relation = L_SELECT_IF_GT or
	/// L_SELECT_IF_GTE.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaMakeWHRatioIndicator/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="ratio">[in] - width/height threshold value</param>
	///  <param name="relation">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///   <returns>na indicator array, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numa MakeWHRatioIndicator (Boxa boxa,
									  Single ratio,
									  int relation)
	{
		Numa RetObj = _All.boxaMakeWHRatioIndicator(boxa, ratio, relation);
		return RetObj;
	}

	// boxfunc4.c (583, 1)
	// boxaSelectWithIndicator(boxas, na, pchanged) as Boxa
	// boxaSelectWithIndicator(BOXA *, NUMA *, l_int32 *) as BOXA *
	///  <summary>
	/// (1) Returns a copy of the boxa if no components are removed.<para/>
	///
	/// (2) Uses box copies in the new boxa.<para/>
	///
	/// (3) The indicator numa has values 0 (ignore) and 1 (accept).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSelectWithIndicator/*"/>
	///  <param name="na">[in] - indicator numa</param>
	///  <param name="pchanged">[out][optional] - 1 if changed 0 if clone returned</param>
	///   <returns>boxad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa SelectWithIndicator (Numa na,
									 out int pchanged)
	{
		Boxa RetObj = _All.boxaSelectWithIndicator(this, na, out pchanged);
		return RetObj;
	}

	// boxfunc4.c (641, 1)
	// boxaPermutePseudorandom(boxas) as Boxa
	// boxaPermutePseudorandom(BOXA *) as BOXA *
	///  <summary>
	/// (1) This does a pseudorandom in-place permutation of the boxes.<para/>
	///
	/// (2) The result is guaranteed not to have any boxes in their
	/// original position, but it is not very random.  If you
	/// need randomness, use boxaPermuteRandom().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaPermutePseudorandom/*"/>
	///   <returns>boxad with boxes permuted, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa PermutePseudorandom ()
	{
		Boxa RetObj = _All.boxaPermutePseudorandom(this);
		return RetObj;
	}

	// boxfunc4.c (682, 1)
	// boxaPermuteRandom(boxad, boxas) as Boxa
	// boxaPermuteRandom(BOXA *, BOXA *) as BOXA *
	///  <summary>
	/// (1) If boxad is null, make a copy of boxas and permute the copy.
	/// Otherwise, boxad must be equal to boxas, and the operation
	/// is done in-place.<para/>
	///
	/// (2) If boxas is empty, return an empty boxad.<para/>
	///
	/// (3) This does a random in-place permutation of the boxes,
	/// by swapping each box in turn with a random box.  The
	/// result is almost guaranteed not to have any boxes in their
	/// original position.<para/>
	///
	/// (4) MSVC rand() has MAX_RAND = 2^15 - 1, so it will not do
	/// a proper permutation is the number of boxes exceeds this.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaPermuteRandom/*"/>
	///  <param name="boxad">[in][optional] - can be null or equal to boxas</param>
	///   <returns>boxad with boxes permuted, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa PermuteRandom (Boxa boxad)
	{
		Boxa RetObj = _All.boxaPermuteRandom(boxad, this);
		return RetObj;
	}

	// boxfunc4.c (719, 1)
	// boxaSwapBoxes(boxa, i, j) as int
	// boxaSwapBoxes(BOXA *, l_int32, l_int32) as l_ok
	///  <summary>
	/// boxaSwapBoxes()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSwapBoxes/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="i">[in] - two indices of boxes, that are to be swapped</param>
	///  <param name="j">[in] - two indices of boxes, that are to be swapped</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SwapBoxes (Boxa boxa,
						  int i,
						  int j)
	{
		int RetObj = _All.boxaSwapBoxes(boxa, i, j);
		return RetObj;
	}

	// boxfunc4.c (763, 1)
	// boxaConvertToPta(boxa, ncorners) as Pta
	// boxaConvertToPta(BOXA *, l_int32) as PTA *
	///  <summary>
	/// (1) If ncorners == 2, we select the UL and LR corners.
	/// Otherwise we save all 4 corners in this order: UL, UR, LL, LR.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaConvertToPta/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="ncorners">[in] - 2 or 4 for the representation of each box</param>
	///   <returns>pta with %ncorners points for each box in the boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta ConvertToPta (Boxa boxa,
							 int ncorners)
	{
		Pta RetObj = _All.boxaConvertToPta(boxa, ncorners);
		return RetObj;
	}

	// boxfunc4.c (967, 1)
	// boxaSmoothSequenceLS(boxas, factor, subflag, maxdiff, extrapixels, debug) as Boxa
	// boxaSmoothSequenceLS(BOXA *, l_float32, l_int32, l_int32, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) This returns a modified version of %boxas by constructing
	/// for each input box a box that has been linear least square fit
	/// (LSF) to the entire set.  The linear fitting is done to each of
	/// the box sides independently, after outliers are rejected,
	/// and it is computed separately for sequences of even and
	/// odd boxes.  Once the linear LSF box is found, the output box
	/// (in %boxad) is constructed from the input box and the LSF
	/// box, depending on %subflag.  See boxaModifyWithBoxa() for
	/// details on the use of %subflag and %maxdiff.<para/>
	///
	/// (2) This is useful if, in both the even and odd sets, the box
	/// edges vary roughly linearly with its index in the set.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSmoothSequenceLS/*"/>
	///  <param name="factor">[in] - reject outliers with widths and heights deviating from the median by more than %factor times the median variation from the median typically ~3</param>
	///  <param name="subflag">[in] - L_USE_MINSIZE, L_USE_MAXSIZE, L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	///  <param name="maxdiff">[in] - parameter used with L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	///  <param name="extrapixels">[in] - pixels added on all sides (or subtracted if %extrapixels  is smaller 0) when using L_SUB_ON_LOC_DIFF and L_SUB_ON_SIZE_DIFF</param>
	///  <param name="debug">[in] - 1 for debug output</param>
	///   <returns>boxad fitted boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa SmoothSequenceLS (Single factor,
								  int subflag,
								  int maxdiff,
								  int extrapixels,
								  DebugOnOff debug)
	{
		Boxa RetObj = _All.boxaSmoothSequenceLS(this, factor, subflag, maxdiff, extrapixels, debug);
		return RetObj;
	}

	// boxfunc4.c (1073, 1)
	// boxaSmoothSequenceMedian(boxas, halfwin, subflag, maxdiff, extrapixels, debug) as Boxa
	// boxaSmoothSequenceMedian(BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) The target width of the sliding window is 2  %halfwin + 1.
	/// If necessary, this will be reduced by boxaWindowedMedian().<para/>
	///
	/// (2) This returns a modified version of %boxas by constructing
	/// for each input box a box that has been smoothed with windowed
	/// median filtering.  The filtering is done to each of the
	/// box sides independently, and it is computed separately for
	/// sequences of even and odd boxes.  The output %boxad is
	/// constructed from the input boxa and the filtered boxa,
	/// depending on %subflag.  See boxaModifyWithBoxa() for
	/// details on the use of %subflag, %maxdiff and %extrapixels.<para/>
	///
	/// (3) This is useful for removing noise separately in the even
	/// and odd sets, where the box edge locations can have
	/// discontinuities but otherwise vary roughly linearly within
	/// intervals of size %halfwin or larger.<para/>
	///
	/// (4) If you don't need to handle even and odd sets separately,
	/// just do this:
	/// boxam = boxaWindowedMedian(boxas, halfwin, debug)
	/// boxad = boxaModifyWithBoxa(boxas, boxam, subflag, maxdiff,
	/// extrapixels)
	/// boxaDestroy([and]boxam)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSmoothSequenceMedian/*"/>
	///  <param name="halfwin">[in] - half-width of sliding window used to find median</param>
	///  <param name="subflag">[in] - L_USE_MINSIZE, L_USE_MAXSIZE, L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	///  <param name="maxdiff">[in] - parameter used with L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	///  <param name="extrapixels">[in] - pixels added on all sides (or subtracted if %extrapixels  is smaller 0) when using L_SUB_ON_LOC_DIFF and L_SUB_ON_SIZE_DIFF</param>
	///  <param name="debug">[in] - 1 for debug output</param>
	///   <returns>boxad fitted boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa SmoothSequenceMedian (int halfwin,
									  int subflag,
									  int maxdiff,
									  int extrapixels,
									  DebugOnOff debug)
	{
		Boxa RetObj = _All.boxaSmoothSequenceMedian(this, halfwin, subflag, maxdiff, extrapixels, debug);
		return RetObj;
	}

	// boxfunc4.c (1179, 1)
	// boxaLinearFit(boxas, factor, debug) as Boxa
	// boxaLinearFit(BOXA *, l_float32, l_int32) as BOXA *
	///  <summary>
	/// (1) This finds a set of boxes (boxad) where each edge of each box is
	/// a linear least square fit (LSF) to the edges of the
	/// input set of boxes (boxas).  Before fitting, outliers in
	/// the boxes in boxas are removed (see below).<para/>
	///
	/// (2) This is useful when each of the box edges in boxas are expected
	/// to vary linearly with box index in the set.  These could
	/// be, for example, noisy measurements of similar regions
	/// on successive scanned pages.<para/>
	///
	/// (3) Method: there are 2 steps:
	/// (a) Find and remove outliers, separately based on the deviation
	/// from the median of the width and height of the box.
	/// Use %factor to specify tolerance to outliers use a very
	/// large value of %factor to avoid rejecting any box sides
	/// in the linear LSF.
	/// (b) On the remaining boxes, do a linear LSF independently
	/// for each of the four sides.<para/>
	///
	/// (4) Invalid input boxes are not used in computation of the LSF.<para/>
	///
	/// (5) The returned boxad can then be used in boxaModifyWithBoxa()
	/// to selectively change the boxes in boxas.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaLinearFit/*"/>
	///  <param name="factor">[in] - reject outliers with widths and heights deviating from the median by more than %factor times the median deviation from the median typically ~3</param>
	///  <param name="debug">[in] - 1 for debug output</param>
	///   <returns>boxad fitted boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa LinearFit (Single factor,
						   DebugOnOff debug)
	{
		Boxa RetObj = _All.boxaLinearFit(this, factor, debug);
		return RetObj;
	}

	// boxfunc4.c (1331, 1)
	// boxaWindowedMedian(boxas, halfwin, debug) as Boxa
	// boxaWindowedMedian(BOXA *, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) This finds a set of boxes (boxad) where each edge of each box is
	/// a windowed median smoothed value to the edges of the
	/// input set of boxes (boxas).<para/>
	///
	/// (2) Invalid input boxes are filled from nearby ones.<para/>
	///
	/// (3) The returned boxad can then be used in boxaModifyWithBoxa()
	/// to selectively change the boxes in the source boxa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaWindowedMedian/*"/>
	///  <param name="halfwin">[in] - half width of window over which the median is found</param>
	///  <param name="debug">[in] - 1 for debug output</param>
	///   <returns>boxad smoothed boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa WindowedMedian (int halfwin,
								DebugOnOff debug)
	{
		Boxa RetObj = _All.boxaWindowedMedian(this, halfwin, debug);
		return RetObj;
	}

	// boxfunc4.c (1469, 1)
	// boxaModifyWithBoxa(boxas, boxam, subflag, maxdiff, extrapixels) as Boxa
	// boxaModifyWithBoxa(BOXA *, BOXA *, l_int32, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) This takes two input boxa (boxas, boxam) and constructs boxad,
	/// where each box in boxad is generated from the corresponding
	/// boxes in boxas and boxam.  The rule for constructing each
	/// output box depends on %subflag and %maxdiff.  Let boxs be
	/// a box from %boxas and boxm be a box from %boxam.
	/// If %subflag == L_USE_MINSIZE: the output box is the intersection
	/// of the two input boxes.
	/// If %subflag == L_USE_MAXSIZE: the output box is the union of the
	/// two input boxes i.e., the minimum bounding rectangle for the
	/// two input boxes.
	/// If %subflag == L_SUB_ON_LOC_DIFF: each side of the output box
	/// is found separately from the corresponding side of boxs and boxm.
	/// Use the boxm side, expanded by %extrapixels, if greater than
	/// %maxdiff pixels from the boxs side.
	/// If %subflag == L_SUB_ON_SIZE_DIFF: the sides of the output box
	/// are determined in pairs from the width and height of boxs
	/// and boxm.  If the boxm width differs by more than %maxdiff
	/// pixels from boxs, use the boxm left and right sides,
	/// expanded by %extrapixels.  Ditto for the height difference.
	/// For the last two flags, each side of the output box is found
	/// separately from the corresponding side of boxs and boxm,
	/// according to these rules, where "smaller"("bigger") mean in a
	/// direction that decreases(increases) the size of the output box:
	/// If %subflag == L_USE_CAPPED_MIN: use the Min of boxm
	/// with the Max of (boxs, boxm +- %maxdiff), where the sign
	/// is adjusted to make the box smaller (e.g., use "+" on left side).
	/// If %subflag == L_USE_CAPPED_MAX: use the Max of boxm
	/// with the Min of (boxs, boxm +- %maxdiff), where the sign
	/// is adjusted to make the box bigger (e.g., use "-" on left side).
	/// Use of the last 2 flags is further explained in (3) and (4).<para/>
	///
	/// (2) boxas and boxam must be the same size.  If boxam == NULL,
	/// this returns a copy of boxas with a warning.<para/>
	///
	/// (3) If %subflag == L_SUB_ON_LOC_DIFF, use boxm for each side
	/// where the corresponding sides differ by more than %maxdiff.
	/// Two extreme cases:
	/// (a) set %maxdiff == 0 to use only values from boxam in boxad.
	/// (b) set %maxdiff == 10000 to ignore all values from boxam
	/// then boxad will be the same as boxas.<para/>
	///
	/// (4) If %subflag == L_USE_CAPPED_MAX: use boxm if boxs is smaller
	/// use boxs if boxs is bigger than boxm by an amount up to %maxdiff
	/// and use boxm +- %maxdiff (the 'capped' value) if boxs is
	/// bigger than boxm by an amount larger than %maxdiff.
	/// Similarly, with interchange of Min/Max and sign of %maxdiff,
	/// for %subflag == L_USE_CAPPED_MIN.<para/>
	///
	/// (5) If either of corresponding boxes in boxas and boxam is invalid,
	/// an invalid box is copied to the result.<para/>
	///
	/// (6) Typical input for boxam may be the output of boxaLinearFit().
	/// where outliers have been removed and each side is LS fit to a line.<para/>
	///
	/// (7) Unlike boxaAdjustWidthToTarget() and boxaAdjustHeightToTarget(),
	/// this uses two boxes and does not specify target dimensions.
	/// Additional constraints on the size of each box can be enforced
	/// by following this operation with boxaConstrainSize(), taking
	/// boxad as input.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaModifyWithBoxa/*"/>
	///  <param name="boxam">[in] - boxa with boxes used to modify those in boxas</param>
	///  <param name="subflag">[in] - L_USE_MINSIZE, L_USE_MAXSIZE, L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	///  <param name="maxdiff">[in] - parameter used with L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	///  <param name="extrapixels">[in] - pixels added on all sides (or subtracted if %extrapixels  is smaller 0) when using L_SUB_ON_LOC_DIFF and L_SUB_ON_SIZE_DIFF</param>
	///   <returns>boxad result after adjusting boxes in boxas, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa ModifyWithBoxa (Boxa boxam,
								int subflag,
								int maxdiff,
								int extrapixels)
	{
		Boxa RetObj = _All.boxaModifyWithBoxa(this, boxam, subflag, maxdiff, extrapixels);
		return RetObj;
	}

	// boxfunc4.c (1585, 1)
	// boxaConstrainSize(boxas, width, widthflag, height, heightflag) as Boxa
	// boxaConstrainSize(BOXA *, l_int32, l_int32, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) Forces either width or height (or both) of every box in
	/// the boxa to a specified size, by moving the indicated sides.<para/>
	///
	/// (2) Not all input boxes need to be valid.  Median values will be
	/// used with invalid boxes.<para/>
	///
	/// (3) Typical input might be the output of boxaLinearFit(),
	/// where each side has been fit.<para/>
	///
	/// (4) Unlike boxaAdjustWidthToTarget() and boxaAdjustHeightToTarget(),
	/// this is not dependent on a difference threshold to change the size.<para/>
	///
	/// (5) On error, a message is issued and a copy of the input boxa
	/// is returned.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaConstrainSize/*"/>
	///  <param name="width">[in] - force width of all boxes to this size input 0 to use the median width</param>
	///  <param name="widthflag">[in] - L_ADJUST_SKIP, L_ADJUST_LEFT, L_ADJUST_RIGHT, or L_ADJUST_LEFT_AND_RIGHT</param>
	///  <param name="height">[in] - force height of all boxes to this size input 0 to use the median height</param>
	///  <param name="heightflag">[in] - L_ADJUST_SKIP, L_ADJUST_TOP, L_ADJUST_BOT, or L_ADJUST_TOP_AND_BOT</param>
	///   <returns>boxad adjusted so all boxes are the same size</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa ConstrainSize (int width,
							   int widthflag,
							   int height,
							   int heightflag)
	{
		Boxa RetObj = _All.boxaConstrainSize(this, width, widthflag, height, heightflag);
		return RetObj;
	}

	// boxfunc4.c (1694, 1)
	// boxaReconcileEvenOddHeight(boxas, sides, delh, op, factor, start) as Boxa
	// boxaReconcileEvenOddHeight(BOXA *, l_int32, l_int32, l_int32, l_float32, l_int32) as BOXA *
	///  <summary>
	/// (1) The basic idea is to reconcile differences in box height
	/// in the even and odd boxes, by moving the top and/or bottom
	/// edges in the even and odd boxes.  Choose the edge or edges
	/// to be moved, whether to adjust the boxes with the min
	/// or the max of the medians, and the threshold on the median
	/// difference between even and odd box heights for the operations
	/// to take place.  The same threshold is also used to
	/// determine if each individual box edge is to be adjusted.<para/>
	///
	/// (2) Boxes are conditionally reset with either the same top (y)
	/// value or the same bottom value, or both.  The value is
	/// determined by the greater or lesser of the medians of the
	/// even and odd boxes, with the choice depending on the value
	/// of %op, which selects for either min or max median height.
	/// If the median difference between even and odd boxes is
	/// greater than %dely, then any individual box edge that differs
	/// from the selected median by more than %dely is set to
	/// the selected median times a factor typically near 1.0.<para/>
	///
	/// (3) Note that if selecting for minimum height, you will choose
	/// the largest y-value for the top and the smallest y-value for
	/// the bottom of the box.<para/>
	///
	/// (4) Typical input might be the output of boxaSmoothSequence(),
	/// where even and odd boxa have been independently regulated.<para/>
	///
	/// (5) Require at least 3 valid even boxes and 3 valid odd boxes.
	/// Median values will be used for invalid boxes.<para/>
	///
	/// (6) If the median height is not representative of the boxes
	/// in %boxas, this can make things much worse.  In that case,
	/// ignore the value of %op, and force pairwise equality of the
	/// heights, with pairwise maximal vertical extension.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaReconcileEvenOddHeight/*"/>
	///  <param name="sides">[in] - L_ADJUST_TOP, L_ADJUST_BOT, L_ADJUST_TOP_AND_BOT</param>
	///  <param name="delh">[in] - threshold on median height difference</param>
	///  <param name="op">[in] - L_ADJUST_CHOOSE_MIN, L_ADJUST_CHOOSE_MAX</param>
	///  <param name="factor">[in] - is greater  0.0, typically near 1.0</param>
	///  <param name="start">[in] - 0 if pairing (0,1), etc 1 if pairing (1,2), etc</param>
	///   <returns>boxad adjusted, or a copy of boxas on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa ReconcileEvenOddHeight (int sides,
										int delh,
										int op,
										Single factor,
										int start)
	{
		Boxa RetObj = _All.boxaReconcileEvenOddHeight(this, sides, delh, op, factor, start);
		return RetObj;
	}

	// boxfunc4.c (1875, 1)
	// boxaReconcilePairWidth(boxas, delw, op, factor, na) as Boxa
	// boxaReconcilePairWidth(BOXA *, l_int32, l_int32, l_float32, NUMA *) as BOXA *
	///  <summary>
	/// (1) This reconciles differences in the width of adjacent boxes,
	/// by moving one side of one of the boxes in each pair.
	/// If the widths in the pair differ by more than some
	/// threshold, move either the left side for even boxes or
	/// the right side for odd boxes, depending on if we're choosing
	/// the min or max.  If choosing min, the width of the max is
	/// set to factor  (width of min).  If choosing max, the width
	/// of the min is set to factor  (width of max).<para/>
	///
	/// (2) If %na exists, it is an indicator array corresponding to the
	/// boxes in %boxas.  If %na != NULL, only boxes with an
	/// indicator value of 1 are allowed to adjust otherwise,
	/// all boxes can adjust.<para/>
	///
	/// (3) Typical input might be the output of boxaSmoothSequence(),
	/// where even and odd boxa have been independently regulated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaReconcilePairWidth/*"/>
	///  <param name="delw">[in] - threshold on adjacent width difference</param>
	///  <param name="op">[in] - L_ADJUST_CHOOSE_MIN, L_ADJUST_CHOOSE_MAX</param>
	///  <param name="factor">[in] - is greater  0.0, typically near 1.0</param>
	///  <param name="na">[in][optional] - indicator array allowing change</param>
	///   <returns>boxad adjusted, or a copy of boxas on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa ReconcilePairWidth (int delw,
									int op,
									Single factor,
									Numa na)
	{
		Boxa RetObj = _All.boxaReconcilePairWidth(this, delw, op, factor, na);
		return RetObj;
	}

	// boxfunc4.c (1980, 1)
	// boxaPlotSides(boxa, plotname, pnal, pnat, pnar, pnab, ppixd) as int
	// boxaPlotSides(BOXA *, const char *, NUMA **, NUMA **, NUMA **, NUMA **, PIX **) as l_ok
	///  <summary>
	/// (1) This debugging function shows the progression of the four
	/// sides in the boxa.  There must be at least 2 boxes.<para/>
	///
	/// (2) If there are invalid boxes (e.g., if only even or odd
	/// indices have valid boxes), this will fill them with the
	/// nearest valid box before plotting.<para/>
	///
	/// (3) The plotfiles are put in /tmp/lept/plots/, and are named
	/// either with %plotname or, if NULL, a default name.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaPlotSides/*"/>
	///  <param name="boxa">[in] - source boxa</param>
	///  <param name="plotname">[in][optional] - , can be NULL</param>
	///  <param name="pnal">[out][optional] - na of left sides</param>
	///  <param name="pnat">[out][optional] - na of top sides</param>
	///  <param name="pnar">[out][optional] - na of right sides</param>
	///  <param name="pnab">[out][optional] - na of bottom sides</param>
	///  <param name="ppixd">[out][optional] - pix of the output plot</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int PlotSides (Boxa boxa,
						  String plotname,
						  out Numa pnal,
						  out Numa pnat,
						  out Numa pnar,
						  out Numa pnab,
						  out Pix ppixd)
	{
		int RetObj = _All.boxaPlotSides(boxa, plotname, out pnal, out pnat, out pnar, out pnab, out ppixd);
		return RetObj;
	}

	// boxfunc4.c (2092, 1)
	// boxaPlotSizes(boxa, plotname, pnaw, pnah, ppixd) as int
	// boxaPlotSizes(BOXA *, const char *, NUMA **, NUMA **, PIX **) as l_ok
	///  <summary>
	/// (1) This debugging function shows the progression of box width
	/// and height in the boxa.  There must be at least 2 boxes.<para/>
	///
	/// (2) If there are invalid boxes (e.g., if only even or odd
	/// indices have valid boxes), this will fill them with the
	/// nearest valid box before plotting.<para/>
	///
	/// (3) The plotfiles are put in /tmp/lept/plots/, and are named
	/// either with %plotname or, if NULL, a default name.  Make sure
	/// that %plotname is a string with no whitespace characters.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaPlotSizes/*"/>
	///  <param name="boxa">[in] - source boxa</param>
	///  <param name="plotname">[in][optional] - , can be NULL</param>
	///  <param name="pnaw">[out][optional] - na of widths</param>
	///  <param name="pnah">[out][optional] - na of heights</param>
	///  <param name="ppixd">[out][optional] - pix of the output plot</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int PlotSizes (Boxa boxa,
						  String plotname,
						  out Numa pnaw,
						  out Numa pnah,
						  out Pix ppixd)
	{
		int RetObj = _All.boxaPlotSizes(boxa, plotname, out pnaw, out pnah, out ppixd);
		return RetObj;
	}

	// boxfunc4.c (2180, 1)
	// boxaFillSequence(boxas, useflag, debug) as Boxa
	// boxaFillSequence(BOXA *, l_int32, l_int32) as BOXA *
	///  <summary>
	/// (1) This simple function replaces invalid boxes with a copy of
	/// the nearest valid box, selected from either the entire
	/// sequence (L_USE_ALL_BOXES) or from the boxes with the
	/// same parity (L_USE_SAME_PARITY_BOXES).  It returns a new boxa.<para/>
	///
	/// (2) This is useful if you expect boxes in the sequence to
	/// vary slowly with index.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaFillSequence/*"/>
	///  <param name="useflag">[in] - L_USE_ALL_BOXES, L_USE_SAME_PARITY_BOXES</param>
	///  <param name="debug">[in] - 1 for debug output</param>
	///   <returns>boxad filled boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa FillSequence (int useflag,
							  DebugOnOff debug)
	{
		Boxa RetObj = _All.boxaFillSequence(this, useflag, debug);
		return RetObj;
	}

	// boxfunc4.c (2322, 1)
	// boxaSizeVariation(boxa, type, pdel_evenodd, prms_even, prms_odd, prms_all) as int
	// boxaSizeVariation(BOXA *, l_int32, l_float32 *, l_float32 *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) This gives several measures of the smoothness of either the
	/// width or height of a sequence of boxes.<para/>
	///
	/// (2) Statistics can be found separately for even and odd boxes.
	/// Additionally, the average pair-wise difference between
	/// adjacent even and odd boxes can be returned.<para/>
	///
	/// (3) The use case is bounding boxes for scanned page images,
	/// where ideally the sizes should have little variance.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSizeVariation/*"/>
	///  <param name="boxa">[in] - at least 4 boxes</param>
	///  <param name="type">[in] - L_SELECT_WIDTH, L_SELECT_HEIGHT</param>
	///  <param name="pdel_evenodd">[out][optional] - average absolute value of (even - odd) size pairs</param>
	///  <param name="prms_even">[out][optional] - rms deviation of even boxes</param>
	///  <param name="prms_odd">[out][optional] - rms deviation of odd boxes</param>
	///  <param name="prms_all">[out][optional] - rms deviation of all boxes</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SizeVariation (Boxa boxa,
							  int type,
							  out Single pdel_evenodd,
							  out Single prms_even,
							  out Single prms_odd,
							  out Single prms_all)
	{
		int RetObj = _All.boxaSizeVariation(boxa, type, out pdel_evenodd, out prms_even, out prms_odd, out prms_all);
		return RetObj;
	}

	// boxfunc4.c (2419, 1)
	// boxaGetExtent(boxa, pw, ph, pbox) as int
	// boxaGetExtent(BOXA *, l_int32 *, l_int32 *, BOX **) as l_ok
	///  <summary>
	/// (1) The returned w and h are the minimum size image
	/// that would contain all boxes untranslated.<para/>
	///
	/// (2) If there are no valid boxes, returned w and h are 0 and
	/// all parameters in the returned box are 0.  This
	/// is not an error, because an empty boxa is valid and
	/// boxaGetExtent() is required for serialization.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetExtent/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="pw">[out][optional] - width</param>
	///  <param name="ph">[out][optional] - height</param>
	///  <param name="pbox">[out][optional] - minimum box containing all boxes in boxa</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetExtent (Boxa boxa,
						  out int pw,
						  out int ph,
						  out Box pbox)
	{
		int RetObj = _All.boxaGetExtent(boxa, out pw, out ph, out pbox);
		return RetObj;
	}

	// boxfunc4.c (2485, 1)
	// boxaGetCoverage(boxa, wc, hc, exactflag, pfract) as int
	// boxaGetCoverage(BOXA *, l_int32, l_int32, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// (1) The boxes in boxa are clipped to the input rectangle.<para/>
	///
	/// (2)  When %exactflag == 1, we generate a 1 bpp pix of size
	/// wc x hc, paint all the boxes black, and count the fg pixels.
	/// This can take 1 msec on a large page with many boxes.
	/// When %exactflag == 0, we clip each box to the wc x hc region
	/// and sum the resulting areas.  This is faster.
	/// The results are the same when none of the boxes overlap
	/// within the wc x hc region.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetCoverage/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="wc">[in] - dimensions of overall clipping rectangle with UL corner at (0, 0 that is covered by the boxes.</param>
	///  <param name="hc">[in] - dimensions of overall clipping rectangle with UL corner at (0, 0 that is covered by the boxes.</param>
	///  <param name="exactflag">[in] - 1 for guaranteeing an exact result 0 for getting an exact result only if the boxes do not overlap</param>
	///  <param name="pfract">[out] - sum of box area as fraction of w  h</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCoverage (Boxa boxa,
							int wc,
							int hc,
							int exactflag,
							out Single pfract)
	{
		int RetObj = _All.boxaGetCoverage(boxa, wc, hc, exactflag, out pfract);
		return RetObj;
	}

	// boxfunc4.c (2598, 1)
	// boxaSizeRange(boxa, pminw, pminh, pmaxw, pmaxh) as int
	// boxaSizeRange(BOXA *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// boxaSizeRange()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaSizeRange/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="pminw">[out][optional] - range of dimensions of box in the array</param>
	///  <param name="pminh">[out][optional] - range of dimensions of box in the array</param>
	///  <param name="pmaxw">[out][optional] - range of dimensions of box in the array</param>
	///  <param name="pmaxh">[out][optional] - range of dimensions of box in the array</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SizeRange (Boxa boxa,
						  out int pminw,
						  out int pminh,
						  out int pmaxw,
						  out int pmaxh)
	{
		int RetObj = _All.boxaSizeRange(boxa, out pminw, out pminh, out pmaxw, out pmaxh);
		return RetObj;
	}

	// boxfunc4.c (2649, 1)
	// boxaLocationRange(boxa, pminx, pminy, pmaxx, pmaxy) as int
	// boxaLocationRange(BOXA *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// boxaLocationRange()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaLocationRange/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="pminx">[out][optional] - range of UL corner positions</param>
	///  <param name="pminy">[out][optional] - range of UL corner positions</param>
	///  <param name="pmaxx">[out][optional] - range of UL corner positions</param>
	///  <param name="pmaxy">[out][optional] - range of UL corner positions</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int LocationRange (Boxa boxa,
							  out int pminx,
							  out int pminy,
							  out int pmaxx,
							  out int pmaxy)
	{
		int RetObj = _All.boxaLocationRange(boxa, out pminx, out pminy, out pmaxx, out pmaxy);
		return RetObj;
	}

	// boxfunc4.c (2700, 1)
	// boxaGetSizes(boxa, pnaw, pnah) as int
	// boxaGetSizes(BOXA *, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// boxaGetSizes()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetSizes/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="pnaw">[out][optional] - widths and heights of valid boxes</param>
	///  <param name="pnah">[out][optional] - widths and heights of valid boxes</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetSizes (Boxa boxa,
						 out Numa pnaw,
						 out Numa pnah)
	{
		int RetObj = _All.boxaGetSizes(boxa, out pnaw, out pnah);
		return RetObj;
	}

	// boxfunc4.c (2746, 1)
	// boxaGetArea(boxa, parea) as int
	// boxaGetArea(BOXA *, l_int32 *) as l_ok
	///  <summary>
	/// (1) Measures the total area of the boxes, without regard to overlaps.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetArea/*"/>
	///  <param name="boxa">[in] - </param>
	///  <param name="parea">[out] - total area of all boxes</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetArea (Boxa boxa,
						out int parea)
	{
		int RetObj = _All.boxaGetArea(boxa, out parea);
		return RetObj;
	}

	// boxfunc4.c (2794, 1)
	// boxaDisplayTiled(boxas, pixa, maxwidth, linewidth, scalefactor, background, spacing, border) as Pix
	// boxaDisplayTiled(BOXA *, PIXA *, l_int32, l_int32, l_float32, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Displays each box separately in a tiled 32 bpp image.<para/>
	///
	/// (2) If pixa is defined, it must have the same count as the boxa,
	/// and it will be a background over with each box is rendered.
	/// If pixa is not defined, the boxes will be rendered over
	/// blank images of identical size.<para/>
	///
	/// (3) See pixaDisplayTiledInRows() for other parameters.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaDisplayTiled/*"/>
	///  <param name="pixa">[in][optional] - background for each box</param>
	///  <param name="maxwidth">[in] - of output image</param>
	///  <param name="linewidth">[in] - width of box outlines, before scaling</param>
	///  <param name="scalefactor">[in] - applied to every box use 1.0 for no scaling</param>
	///  <param name="background">[in] - 0 for white, 1 for black this is the color of the spacing between the images</param>
	///  <param name="spacing">[in] - between images, and on outside</param>
	///  <param name="border">[in] - width of black border added to each image use 0 for no border</param>
	///   <returns>pixd of tiled images of boxes, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayTiled (int maxwidth,
							 int linewidth,
							 Single scalefactor,
							 int background,
							 int spacing,
							 int border,
							 Pixa pixa)
	{
		Pix RetObj = _All.boxaDisplayTiled(this, pixa, maxwidth, linewidth, scalefactor, background, spacing, border);
		return RetObj;
	}

	// classapp.c (515, 1)
	// boxaExtractSortedPattern(boxa, na) as Numaa
	// boxaExtractSortedPattern(BOXA *, NUMA *) as NUMAA *
	///  <summary>
	/// (1) The input is expected to come from pixGetWordBoxesInTextlines().<para/>
	///
	/// (2) Each numa in the output consists of an average y coordinate
	/// of the first box in the textline, followed by pairs of
	/// x coordinates representing the left and right edges of each
	/// of the boxes in the textline.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaExtractSortedPattern/*"/>
	///  <param name="boxa">[in] - typ. of word bounding boxes, in textline order</param>
	///  <param name="na">[in] - index of textline for each box in boxa</param>
	///   <returns>naa NUMAA, where each numa represents one textline, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Numaa ExtractSortedPattern (Boxa boxa,
									   Numa na)
	{
		Numaa RetObj = _All.boxaExtractSortedPattern(boxa, na);
		return RetObj;
	}

	// partition.c (189, 1)
	// boxaGetWhiteblocks(boxas, box, sortflag, maxboxes, maxoverlap, maxperim, fract, maxpops) as Boxa
	// boxaGetWhiteblocks(BOXA *, BOX *, l_int32, l_int32, l_float32, l_int32, l_float32, l_int32) as BOXA *
	///  <summary>
	/// (1) This uses the elegant Breuel algorithm, found in "Two
	/// Geometric Algorithms for Layout Analysis", 2002,
	/// url: "citeseer.ist.psu.edu/breuel02two.html".
	/// It starts with the bounding boxes (b.b.) of the connected
	/// components (c.c.) in a region, along with the rectangle
	/// representing that region.  It repeatedly divides the
	/// rectangle into four maximal rectangles that exclude a
	/// pivot rectangle, sorting them in a priority queue
	/// according to one of the six sort flags.  It returns a boxa
	/// of the "largest" set that have no intersection with boxes
	/// from the input boxas.<para/>
	///
	/// (2) If box == NULL, the initial region is the minimal region
	/// that includes the origin and every box in boxas.<para/>
	///
	/// (3) maxboxes is the maximum number of whitespace boxes that will
	/// be returned.  The actual number will depend on the image
	/// and the values chosen for maxoverlap and maxpops.  In many
	/// cases, the actual number will be 'maxboxes'.<para/>
	///
	/// (4) maxoverlap allows pruning of whitespace boxes depending on
	/// the overlap.  To avoid all pruning, use maxoverlap = 1.0.
	/// To select only boxes that have no overlap with each other
	/// (maximal pruning), choose maxoverlap = 0.0.
	/// Otherwise, no box can have more than the 'maxoverlap' fraction
	/// of its area overlapped by any larger (in the sense of the
	/// sortflag) box.<para/>
	///
	/// (5) Choose maxperim (actually, maximum half-perimeter) to
	/// represent a c.c. that is small enough so that you don't care
	/// about the white space that could be inside of it.  For all such
	/// c.c., the pivot for 'quadfurcation' of a rectangle is selected
	/// as having a reasonable proximity to the rectangle centroid.<para/>
	///
	/// (6) Use fract in the range [0.0 ... 1.0].  Set fract = 0.0
	/// to choose the small box nearest the centroid as the pivot.
	/// If you choose fract  is greater  0.0, it is suggested that you call
	/// boxaPermuteRandom() first, to permute the boxes (see usage below).
	/// This should reduce the search time for each of the pivot boxes.<para/>
	///
	/// (7) Choose maxpops to be the maximum number of rectangles that
	/// are popped from the heap.  This is an indirect way to limit the
	/// execution time.  Use 0 for default (a fairly large number).
	/// At any time, you can expect the heap to contain about
	/// 2.5 times as many boxes as have been popped off.<para/>
	///
	/// (8) The output result is a sorted set of overlapping
	/// boxes, constrained by 'maxboxes', 'maxoverlap' and 'maxpops'.<para/>
	///
	/// (9) The main defect of the method is that it abstracts out the
	/// actual components, retaining only the b.b. for analysis.
	/// Consider a component with a large b.b.  If this is chosen
	/// as a pivot, all white space inside is immediately taken
	/// out of consideration.  Furthermore, even if it is never chosen
	/// as a pivot, as the partitioning continues, at no time will
	/// any of the whitespace inside this component be part of a
	/// rectangle with zero overlapping boxes.  Thus, the interiors
	/// of all boxes are necessarily excluded from the union of
	/// the returned whitespace boxes.<para/>
	///
	/// (10) It should be noted that the algorithm puts a large number
	/// of partels on the queue.  Setting a limit of X partels to
	/// remove from the queue, one typically finds that there will be
	/// several times that number (say, 2X - 3X) left on the queue.
	/// For an efficient algorithm to find the largest white or
	/// or black rectangles, without permitting them to overlap,
	/// see pixFindLargeRectangles().<para/>
	///
	/// (11) USAGE: One way to accommodate to this weakness is to remove such
	/// large b.b. before starting the computation.  For example,
	/// if 'box' is an input image region containing 'boxa' b.b. of c.c.:
	/// // Faster pivot choosing
	/// boxaPermuteRandom(boxa, boxa)
	/// // Remove anything either large width or height
	/// boxat = boxaSelectBySize(boxa, maxwidth, maxheight,
	/// L_SELECT_IF_BOTH, L_SELECT_IF_LT,
	/// NULL)
	/// boxad = boxaGetWhiteblocks(boxat, box, type, maxboxes,
	/// maxoverlap, maxperim, fract,
	/// maxpops)
	/// The result will be rectangular regions of "white space" that
	/// extend into (and often through) the excluded components.<para/>
	///
	/// (11) As a simple example, suppose you wish to find the columns on a page.
	/// First exclude large c.c. that may block the columns, and then call:
	/// boxad = boxaGetWhiteblocks(boxa, box, L_SORT_BY_HEIGHT,
	/// 20, 0.15, 200, 0.2, 2000)
	/// to get the 20 tallest boxes with no more than 0.15 overlap
	/// between a box and any of the taller ones, and avoiding the
	/// use of any c.c. with a b.b. half perimeter greater than 200
	/// as a pivot.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaGetWhiteblocks/*"/>
	///  <param name="box">[in] - initial region typically including all boxes in boxas if null, it computes the region to include all boxes in boxas</param>
	///  <param name="sortflag">[in] - L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER, L_SORT_BY_AREA</param>
	///  <param name="maxboxes">[in] - maximum number of output whitespace boxes e.g., 100</param>
	///  <param name="maxoverlap">[in] - maximum fractional overlap of a box by any of the larger boxes e.g., 0.2</param>
	///  <param name="maxperim">[in] - maximum half-perimeter, in pixels, for which pivot is selected by proximity to box centroid e.g., 200</param>
	///  <param name="fract">[in] - fraction of box diagonal that is an acceptable distance from the box centroid to select the pivot e.g., 0.2</param>
	///  <param name="maxpops">[in] - maximum number of pops from the heap use 0 as default</param>
	///   <returns>boxa of sorted whitespace boxes, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa GetWhiteblocks (Box box,
								int sortflag,
								int maxboxes,
								Single maxoverlap,
								int maxperim,
								Single fract,
								int maxpops)
	{
		Boxa RetObj = _All.boxaGetWhiteblocks(this, box, sortflag, maxboxes, maxoverlap, maxperim, fract, maxpops);
		return RetObj;
	}

	// partition.c (621, 1)
	// boxaPruneSortedOnOverlap(boxas, maxoverlap) as Boxa
	// boxaPruneSortedOnOverlap(BOXA *, l_float32) as BOXA *
	///  <summary>
	/// (1) This selectively removes smaller boxes when they are overlapped
	/// by any larger box by more than the input 'maxoverlap' fraction.<para/>
	///
	/// (2) To avoid all pruning, use maxoverlap = 1.0.  To select only
	/// boxes that have no overlap with each other (maximal pruning),
	/// set maxoverlap = 0.0.<para/>
	///
	/// (3) If there are no boxes in boxas, returns an empty boxa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaPruneSortedOnOverlap/*"/>
	///  <param name="maxoverlap">[in] - maximum fractional overlap of a box by any of the larger boxes</param>
	///   <returns>boxad pruned, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa PruneSortedOnOverlap (Single maxoverlap)
	{
		Boxa RetObj = _All.boxaPruneSortedOnOverlap(this, maxoverlap);
		return RetObj;
	}


}
public partial class Boxaa
{
	// boxbasic.c (1238, 1)
	// boxaaCreate(n) as Boxaa
	// boxaaCreate(l_int32) as BOXAA *
	///  <summary>
	/// boxaaCreate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaCreate/*"/>
	///  <param name="n">[in] - size of boxa ptr array to be alloc'd 0 for default</param>
	///   <returns>baa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxaa Create (int n)
	{
		Boxaa RetObj = _All.boxaaCreate(n);
		return RetObj;
	}

	// boxbasic.c (1273, 1)
	// boxaaCopy(baas, copyflag) as Boxaa
	// boxaaCopy(BOXAA *, l_int32) as BOXAA *
	///  <summary>
	/// (1) L_COPY makes a copy of each boxa in baas.
	/// L_CLONE makes a clone of each boxa in baas.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaCopy/*"/>
	///  <param name="baas">[in] - input boxaa to be copied</param>
	///  <param name="copyflag">[in] - L_COPY, L_CLONE</param>
	///   <returns>baad new boxaa, composed of copies or clones of the boxa in baas, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxaa Copy (Boxaa baas,
					   int copyflag)
	{
		Boxaa RetObj = _All.boxaaCopy(baas, copyflag);
		return RetObj;
	}

	// boxbasic.c (1304, 1)
	// boxaaDestroy(pbaa) as Object
	// boxaaDestroy(BOXAA **) as void
	///  <summary>
	/// boxaaDestroy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaDestroy/*"/>
	///  <param name="pbaa">[in,out] - will be set to null before returning</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref Boxaa pbaa)
	{
		_All.boxaaDestroy(ref pbaa);
	}

	// boxbasic.c (1342, 1)
	// boxaaAddBoxa(baa, ba, copyflag) as int
	// boxaaAddBoxa(BOXAA *, BOXA *, l_int32) as l_ok
	///  <summary>
	/// boxaaAddBoxa()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaAddBoxa/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="ba">[in] - to be added</param>
	///  <param name="copyflag">[in] - L_INSERT, L_COPY, L_CLONE</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddBoxa (Boxaa baa,
						Boxa ba,
						int copyflag)
	{
		int RetObj = _All.boxaaAddBoxa(baa, ba, copyflag);
		return RetObj;
	}

	// boxbasic.c (1379, 1)
	// boxaaExtendArray(baa) as int
	// boxaaExtendArray(BOXAA *) as l_ok
	///  <summary>
	/// boxaaExtendArray()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaExtendArray/*"/>
	///  <param name="baa">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ExtendArray (Boxaa baa)
	{
		int RetObj = _All.boxaaExtendArray(baa);
		return RetObj;
	}

	// boxbasic.c (1410, 1)
	// boxaaExtendArrayToSize(baa, size) as int
	// boxaaExtendArrayToSize(BOXAA *, l_int32) as l_ok
	///  <summary>
	/// (1) If necessary, reallocs the boxa ptr array to %size.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaExtendArrayToSize/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="size">[in] - new size of boxa array</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ExtendArrayToSize (Boxaa baa,
								  int size)
	{
		int RetObj = _All.boxaaExtendArrayToSize(baa, size);
		return RetObj;
	}

	// boxbasic.c (1439, 1)
	// boxaaGetCount(baa) as int
	// boxaaGetCount(BOXAA *) as l_int32
	///  <summary>
	/// boxaaGetCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaGetCount/*"/>
	///  <param name="baa">[in] - </param>
	///   <returns>count number of boxa, or 0 if no boxa or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCount (Boxaa baa)
	{
		int RetObj = _All.boxaaGetCount(baa);
		return RetObj;
	}

	// boxbasic.c (1456, 1)
	// boxaaGetBoxCount(baa) as int
	// boxaaGetBoxCount(BOXAA *) as l_int32
	///  <summary>
	/// boxaaGetBoxCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaGetBoxCount/*"/>
	///  <param name="baa">[in] - </param>
	///   <returns>count number of boxes, or 0 if no boxes or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetBoxCount (Boxaa baa)
	{
		int RetObj = _All.boxaaGetBoxCount(baa);
		return RetObj;
	}

	// boxbasic.c (1486, 1)
	// boxaaGetBoxa(baa, index, accessflag) as Boxa
	// boxaaGetBoxa(BOXAA *, l_int32, l_int32) as BOXA *
	///  <summary>
	/// boxaaGetBoxa()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaGetBoxa/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="index">[in] - to the index-th boxa</param>
	///  <param name="accessflag">[in] - L_COPY or L_CLONE</param>
	///   <returns>boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa GetBoxa (Boxaa baa,
						 int index,
						 int accessflag)
	{
		Boxa RetObj = _All.boxaaGetBoxa(baa, index, accessflag);
		return RetObj;
	}

	// boxbasic.c (1516, 1)
	// boxaaGetBox(baa, iboxa, ibox, accessflag) as Box
	// boxaaGetBox(BOXAA *, l_int32, l_int32, l_int32) as BOX *
	///  <summary>
	/// boxaaGetBox()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaGetBox/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="iboxa">[in] - index into the boxa array in the boxaa</param>
	///  <param name="ibox">[in] - index into the box array in the boxa</param>
	///  <param name="accessflag">[in] - L_COPY or L_CLONE</param>
	///   <returns>box, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box GetBox (Boxaa baa,
					   int iboxa,
					   int ibox,
					   int accessflag)
	{
		Box RetObj = _All.boxaaGetBox(baa, iboxa, ibox, accessflag);
		return RetObj;
	}

	// boxbasic.c (1568, 1)
	// boxaaInitFull(baa, boxa) as int
	// boxaaInitFull(BOXAA *, BOXA *) as l_ok
	///  <summary>
	/// (1) This initializes a boxaa by filling up the entire boxa ptr array
	/// with copies of %boxa.  Any existing boxa are destroyed.
	/// After this operation, the number of boxa is equal to
	/// the number of allocated ptrs.<para/>
	///
	/// (2) Note that we use boxaaReplaceBox() instead of boxaInsertBox().
	/// They both have the same effect when inserting into a NULL ptr
	/// in the boxa ptr array<para/>
	///
	/// (3) Example usage.  This function is useful to prepare for a
	/// random insertion (or replacement) of boxa into a boxaa.
	/// To randomly insert boxa into a boxaa, up to some index "max":
	/// Boxaa baa = boxaaCreate(max)
	/// // initialize the boxa
	/// Boxa boxa = boxaCreate(...)
	/// ...  [optionally fix with boxes]
	/// boxaaInitFull(baa, boxa)
	/// A typical use is to initialize the array with empty boxa,
	/// and to replace only a subset that must be aligned with
	/// something else, such as a pixa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaInitFull/*"/>
	///  <param name="baa">[in] - typically empty</param>
	///  <param name="boxa">[in] - to be replicated into the entire ptr array</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int InitFull (Boxaa baa,
						 Boxa boxa)
	{
		int RetObj = _All.boxaaInitFull(baa, boxa);
		return RetObj;
	}

	// boxbasic.c (1608, 1)
	// boxaaExtendWithInit(baa, maxindex, boxa) as int
	// boxaaExtendWithInit(BOXAA *, l_int32, BOXA *) as l_ok
	///  <summary>
	/// (1) This should be used on an existing boxaa that has been
	/// fully loaded with boxa.  It then extends the boxaa,
	/// loading all the additional ptrs with copies of boxa.
	/// Typically, boxa will be empty.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaExtendWithInit/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="maxindex">[in] - </param>
	///  <param name="boxa">[in] - to be replicated into the extended ptr array</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ExtendWithInit (Boxaa baa,
							   int maxindex,
							   Boxa boxa)
	{
		int RetObj = _All.boxaaExtendWithInit(baa, maxindex, boxa);
		return RetObj;
	}

	// boxbasic.c (1649, 1)
	// boxaaReplaceBoxa(baa, index, boxa) as int
	// boxaaReplaceBoxa(BOXAA *, l_int32, BOXA *) as l_ok
	///  <summary>
	/// (1) Any existing boxa is destroyed, and the input one
	/// is inserted in its place.<para/>
	///
	/// (2) If the index is invalid, return 1 (error)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaReplaceBoxa/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="index">[in] - to the index-th boxa</param>
	///  <param name="boxa">[in] - insert and replace any existing one</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ReplaceBoxa (Boxaa baa,
							int index,
							Boxa boxa)
	{
		int RetObj = _All.boxaaReplaceBoxa(baa, index, boxa);
		return RetObj;
	}

	// boxbasic.c (1690, 1)
	// boxaaInsertBoxa(baa, index, boxa) as int
	// boxaaInsertBoxa(BOXAA *, l_int32, BOXA *) as l_ok
	///  <summary>
	/// (1) This shifts boxa[i] to boxa[i + 1] for all i greater or equal index,
	/// and then inserts boxa as boxa[index].<para/>
	///
	/// (2) To insert at the beginning of the array, set index = 0.<para/>
	///
	/// (3) To append to the array, it's easier to use boxaaAddBoxa().<para/>
	///
	/// (4) This should not be used repeatedly to insert into large arrays,
	/// because the function is O(n).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaInsertBoxa/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="index">[in] - location in boxaa to insert new boxa</param>
	///  <param name="boxa">[in] - new boxa to be inserted</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int InsertBoxa (Boxaa baa,
						   int index,
						   Boxa boxa)
	{
		int RetObj = _All.boxaaInsertBoxa(baa, index, boxa);
		return RetObj;
	}

	// boxbasic.c (1736, 1)
	// boxaaRemoveBoxa(baa, index) as int
	// boxaaRemoveBoxa(BOXAA *, l_int32) as l_ok
	///  <summary>
	/// (1) This removes boxa[index] and then shifts
	/// boxa[i] to boxa[i - 1] for all i  is greater  index.<para/>
	///
	/// (2) The removed boxaa is destroyed.<para/>
	///
	/// (2) This should not be used repeatedly on large arrays,
	/// because the function is O(n).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaRemoveBoxa/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="index">[in] - of the boxa to be removed</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RemoveBoxa (Boxaa baa,
						   int index)
	{
		int RetObj = _All.boxaaRemoveBoxa(baa, index);
		return RetObj;
	}

	// boxbasic.c (1776, 1)
	// boxaaAddBox(baa, index, box, accessflag) as int
	// boxaaAddBox(BOXAA *, l_int32, BOX *, l_int32) as l_ok
	///  <summary>
	/// (1) Adds to an existing boxa only.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaAddBox/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="index">[in] - of boxa with boxaa</param>
	///  <param name="box">[in] - to be added</param>
	///  <param name="accessflag">[in] - L_INSERT, L_COPY or L_CLONE</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddBox (Boxaa baa,
					   int index,
					   Box box,
					   int accessflag)
	{
		int RetObj = _All.boxaaAddBox(baa, index, box, accessflag);
		return RetObj;
	}

	// boxbasic.c (1824, 1)
	// boxaaReadFromFiles(dirname, substr, first, nfiles) as Boxaa
	// boxaaReadFromFiles(const char *, const char *, l_int32, l_int32) as BOXAA *
	///  <summary>
	/// (1) The files must be serialized boxa files (e.g., .ba).
	/// If some files cannot be read, warnings are issued.<para/>
	///
	/// (2) Use %substr to filter filenames in the directory.  If
	/// %substr == NULL, this takes all files.<para/>
	///
	/// (3) After filtering, use %first and %nfiles to select
	/// a contiguous set of files, that have been lexically
	/// sorted in increasing order.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaReadFromFiles/*"/>
	///  <param name="dirname">[in] - directory</param>
	///  <param name="substr">[in][optional] - substring filter on filenames can be NULL</param>
	///  <param name="first">[in] - 0-based</param>
	///  <param name="nfiles">[in] - use 0 for everything from %first to the end</param>
	///   <returns>baa, or NULL on error or if no boxa files are found.</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxaa ReadFromFiles (String dirname,
								int first,
								int nfiles,
								String substr)
	{
		Boxaa RetObj = _All.boxaaReadFromFiles(dirname, substr, first, nfiles);
		return RetObj;
	}

	// boxbasic.c (1868, 1)
	// boxaaRead(filename) as Boxaa
	// boxaaRead(const char *) as BOXAA *
	///  <summary>
	/// boxaaRead()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaRead/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>boxaa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxaa Read (String filename)
	{
		Boxaa RetObj = _All.boxaaRead(filename);
		return RetObj;
	}

	// boxbasic.c (1895, 1)
	// boxaaReadStream(fp) as Boxaa
	// boxaaReadStream(FILE *) as BOXAA *
	///  <summary>
	/// boxaaReadStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>boxaa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxaa ReadStream (FILE fp)
	{
		Boxaa RetObj = _All.boxaaReadStream(fp);
		return RetObj;
	}

	// boxbasic.c (1940, 1)
	// boxaaReadMem(data, size) as Boxaa
	// boxaaReadMem(const l_uint8 *, size_t) as BOXAA *
	///  <summary>
	/// boxaaReadMem()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaReadMem/*"/>
	///  <param name="data">[in] - serialization of boxaa in ascii</param>
	///  <param name="size">[in] - of data in bytes can use strlen to get it</param>
	///   <returns>baa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxaa ReadMem (Byte[] data,
						  uint size)
	{
		Boxaa RetObj = _All.boxaaReadMem(data, size);
		return RetObj;
	}

	// boxbasic.c (1968, 1)
	// boxaaWrite(filename, baa) as int
	// boxaaWrite(const char *, BOXAA *) as l_ok
	///  <summary>
	/// boxaaWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaWrite/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="baa">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String filename,
					  Boxaa baa)
	{
		int RetObj = _All.boxaaWrite(filename, baa);
		return RetObj;
	}

	// boxbasic.c (1999, 1)
	// boxaaWriteStream(fp, baa) as int
	// boxaaWriteStream(FILE *, BOXAA *) as l_ok
	///  <summary>
	/// boxaaWriteStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaWriteStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="baa">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp,
							Boxaa baa)
	{
		int RetObj = _All.boxaaWriteStream(fp, baa);
		return RetObj;
	}

	// boxbasic.c (2046, 1)
	// boxaaWriteMem(pdata, psize, baa) as int
	// boxaaWriteMem(l_uint8 **, size_t *, BOXAA *) as l_ok
	///  <summary>
	/// (1) Serializes a boxaa in memory and puts the result in a buffer.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaWriteMem/*"/>
	///  <param name="pdata">[out] - data of serialized boxaa ascii</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="baa">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMem (out Byte[] pdata,
						 out uint psize,
						 Boxaa baa)
	{
		int RetObj = _All.boxaaWriteMem(out pdata, out psize, baa);
		return RetObj;
	}

	// boxfunc1.c (2361, 1)
	// boxaaJoin(baad, baas, istart, iend) as int
	// boxaaJoin(BOXAA *, BOXAA *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This appends a clone of each indicated boxa in baas to baad<para/>
	///
	/// (2) istart  is smaller 0 is taken to mean 'read from the start' (istart = 0)<para/>
	///
	/// (3) iend  is smaller 0 means 'read to the end'<para/>
	///
	/// (4) if baas == NULL, this is a no-op.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaJoin/*"/>
	///  <param name="baad">[in] - dest boxaa add to this one</param>
	///  <param name="baas">[in] - source boxaa add from this one</param>
	///  <param name="istart">[in] - starting index in baas</param>
	///  <param name="iend">[in] - ending index in baas use -1 to cat all</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Join (Boxaa baad,
					 Boxaa baas,
					 int istart,
					 int iend)
	{
		int RetObj = _All.boxaaJoin(baad, baas, istart, iend);
		return RetObj;
	}

	// boxfunc2.c (1398, 1)
	// boxaaGetExtent(baa, pw, ph, pbox, pboxa) as int
	// boxaaGetExtent(BOXAA *, l_int32 *, l_int32 *, BOX **, BOXA **) as l_ok
	///  <summary>
	/// (1) The returned w and h are the minimum size image
	/// that would contain all boxes untranslated.<para/>
	///
	/// (2) Each box in the returned boxa is the minimum box required to
	/// hold all the boxes in the respective boxa of baa.<para/>
	///
	/// (3) If there are no valid boxes in a boxa, the box corresponding
	/// to its extent has all fields set to 0 (an invalid box).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaGetExtent/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="pw">[out][optional] - width</param>
	///  <param name="ph">[out][optional] - height</param>
	///  <param name="pbox">[out][optional] - minimum box containing all boxa in boxaa</param>
	///  <param name="pboxa">[out][optional] - boxa containing all boxes in each boxa in the boxaa</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetExtent (Boxaa baa,
						  out int pw,
						  out int ph,
						  out Box pbox,
						  out Boxa pboxa)
	{
		int RetObj = _All.boxaaGetExtent(baa, out pw, out ph, out pbox, out pboxa);
		return RetObj;
	}

	// boxfunc2.c (1478, 1)
	// boxaaFlattenToBoxa(baa, pnaindex, copyflag) as Boxa
	// boxaaFlattenToBoxa(BOXAA *, NUMA **, l_int32) as BOXA *
	///  <summary>
	/// (1) This 'flattens' the baa to a boxa, taking the boxes in
	/// order in the first boxa, then the second, etc.<para/>
	///
	/// (2) If a boxa is empty, we generate an invalid, placeholder box
	/// of zero size.  This is useful when converting from a baa
	/// where each boxa has either 0 or 1 boxes, and it is necessary
	/// to maintain a 1:1 correspondence between the initial
	/// boxa array and the resulting box array.<para/>
	///
	/// (3) If [and]naindex is defined, we generate a Numa that gives, for
	/// each box in the baa, the index of the boxa to which it belongs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaFlattenToBoxa/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="pnaindex">[out][optional] - the boxa index in the baa</param>
	///  <param name="copyflag">[in] - L_COPY or L_CLONE</param>
	///   <returns>boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa FlattenToBoxa (Boxaa baa,
							   int copyflag,
							   out Numa pnaindex)
	{
		Boxa RetObj = _All.boxaaFlattenToBoxa(baa, out pnaindex, copyflag);
		return RetObj;
	}

	// boxfunc2.c (1544, 1)
	// boxaaFlattenAligned(baa, num, fillerbox, copyflag) as Boxa
	// boxaaFlattenAligned(BOXAA *, l_int32, BOX *, l_int32) as BOXA *
	///  <summary>
	/// (1) This 'flattens' the baa to a boxa, taking the first %num
	/// boxes from each boxa.<para/>
	///
	/// (2) In each boxa, if there are less than %num boxes, we preserve
	/// the alignment between the input baa and the output boxa
	/// by inserting one or more fillerbox(es) or, if %fillerbox == NULL,
	/// one or more invalid placeholder boxes.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaFlattenAligned/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="num">[in] - number extracted from each</param>
	///  <param name="fillerbox">[in][optional] - that fills if necessary</param>
	///  <param name="copyflag">[in] - L_COPY or L_CLONE</param>
	///   <returns>boxa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa FlattenAligned (Boxaa baa,
								int num,
								int copyflag,
								Box fillerbox)
	{
		Boxa RetObj = _All.boxaaFlattenAligned(baa, num, fillerbox, copyflag);
		return RetObj;
	}

	// boxfunc2.c (1656, 1)
	// boxaaTranspose(baas) as Boxaa
	// boxaaTranspose(BOXAA *) as BOXAA *
	///  <summary>
	/// (1) If you think of a boxaa as a 2D array of boxes that is accessed
	/// row major, then each row is represented by one of the boxa.
	/// This function creates a new boxaa related to the input boxaa
	/// as a column major traversal of the input boxaa.<para/>
	///
	/// (2) For example, if %baas has 2 boxa, each with 10 boxes, then
	/// %baad will have 10 boxa, each with 2 boxes.<para/>
	///
	/// (3) Require for this transpose operation that each boxa in
	/// %baas has the same number of boxes.  This operation is useful
	/// when the i-th boxes in each boxa are meaningfully related.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaTranspose/*"/>
	///  <param name="baas">[in] - </param>
	///   <returns>baad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxaa Transpose (Boxaa baas)
	{
		Boxaa RetObj = _All.boxaaTranspose(baas);
		return RetObj;
	}

	// boxfunc2.c (1715, 1)
	// boxaaAlignBox(baa, box, delta, pindex) as int
	// boxaaAlignBox(BOXAA *, BOX *, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) This is not greedy.  It finds the boxa whose vertical
	/// extent has the closest overlap with the input box.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaAlignBox/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="box">[in] - to be aligned with the bext boxa in the baa, if possible</param>
	///  <param name="delta">[in] - amount by which consecutive components can miss in overlap and still be included in the array</param>
	///  <param name="pindex">[out] - index of boxa with best overlap, or if none match, this is the index of the next boxa to be generated</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AlignBox (Boxaa baa,
						 Box box,
						 int delta,
						 out int pindex)
	{
		int RetObj = _All.boxaaAlignBox(baa, box, delta, out pindex);
		return RetObj;
	}

	// boxfunc3.c (634, 1)
	// boxaaDisplay(pixs, baa, linewba, linewb, colorba, colorb, w, h) as Pix
	// boxaaDisplay(PIX *, BOXAA *, l_int32, l_int32, l_uint32, l_uint32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) If %pixs exists, this renders the boxes over an 8 bpp version
	/// of it.  Otherwise, it renders the boxes over an empty image
	/// with a white background.<para/>
	///
	/// (2) If %pixs exists, the dimensions of %pixd are the same,
	/// and input values of %w and %h are ignored.
	/// If %pixs is NULL, the dimensions of %pixd are determined by
	/// - %w and %h if both are  is greater  0, or
	/// - the minimum size required using all boxes in %baa.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaDisplay/*"/>
	///  <param name="pixs">[in][optional] - 1 bpp</param>
	///  <param name="baa">[in] - boxaa, typically from a 2d sort</param>
	///  <param name="linewba">[in] - line width to display outline of each boxa</param>
	///  <param name="linewb">[in] - line width to display outline of each box</param>
	///  <param name="colorba">[in] - color to display boxa</param>
	///  <param name="colorb">[in] - color to display box</param>
	///  <param name="w">[in] - width of outupt pix use 0 if determined by %pixs or %baa</param>
	///  <param name="h">[in] - height of outupt pix use 0 if determined by %pixs or %baa</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix Display (Boxaa baa,
						int linewba,
						int linewb,
						uint colorba,
						uint colorb,
						int w,
						int h,
						Pix pixs)
	{
		Pix RetObj = _All.boxaaDisplay(pixs, baa, linewba, linewb, colorba, colorb, w, h);
		return RetObj;
	}

	// boxfunc4.c (164, 1)
	// boxaaSelectRange(baas, first, last, copyflag) as Boxaa
	// boxaaSelectRange(BOXAA *, l_int32, l_int32, l_int32) as BOXAA *
	///  <summary>
	/// (1) The copyflag specifies what we do with each boxa from baas.
	/// Specifically, L_CLONE inserts a clone into baad of each
	/// selected boxa from baas.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaSelectRange/*"/>
	///  <param name="baas">[in] - </param>
	///  <param name="first">[in] - use 0 to select from the beginning</param>
	///  <param name="last">[in] - use 0 to select to the end</param>
	///  <param name="copyflag">[in] - L_COPY, L_CLONE</param>
	///   <returns>baad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxaa SelectRange (Boxaa baas,
							  int first,
							  int last,
							  int copyflag)
	{
		Boxaa RetObj = _All.boxaaSelectRange(baas, first, last, copyflag);
		return RetObj;
	}

	// boxfunc4.c (2544, 1)
	// boxaaSizeRange(baa, pminw, pminh, pmaxw, pmaxh) as int
	// boxaaSizeRange(BOXAA *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// boxaaSizeRange()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaSizeRange/*"/>
	///  <param name="baa">[in] - </param>
	///  <param name="pminw">[out][optional] - range of dimensions of all boxes</param>
	///  <param name="pminh">[out][optional] - range of dimensions of all boxes</param>
	///  <param name="pmaxw">[out][optional] - range of dimensions of all boxes</param>
	///  <param name="pmaxh">[out][optional] - range of dimensions of all boxes</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SizeRange (Boxaa baa,
						  out int pminw,
						  out int pminh,
						  out int pmaxw,
						  out int pmaxh)
	{
		int RetObj = _All.boxaaSizeRange(baa, out pminw, out pminh, out pmaxw, out pmaxh);
		return RetObj;
	}

	// quadtree.c (449, 1)
	// boxaaQuadtreeRegions(w, h, nlevels) as Boxaa
	// boxaaQuadtreeRegions(l_int32, l_int32, l_int32) as BOXAA *
	///  <summary>
	/// (1) The returned boxaa has %nlevels of boxa, each containing
	/// the set of rectangles at that level.  The rectangle at
	/// level 0 is the entire region at level 1 the region is
	/// divided into 4 rectangles, and at level n there are n^4
	/// rectangles.<para/>
	///
	/// (2) At each level, the rectangles in the boxa are in "raster"
	/// order, with LR (fast scan) and TB (slow scan).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/boxaaQuadtreeRegions/*"/>
	///  <param name="w">[in] - size of pix that is being quadtree-ized</param>
	///  <param name="h">[in] - size of pix that is being quadtree-ized</param>
	///  <param name="nlevels">[in] - number of levels in quadtree</param>
	///   <returns>baa for quadtree regions at each level, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxaa QuadtreeRegions (int w,
								  int h,
								  int nlevels)
	{
		Boxaa RetObj = _All.boxaaQuadtreeRegions(w, h, nlevels);
		return RetObj;
	}


}
public partial class Pta
{
	// affinecompose.c (223, 1)
	// ptaTranslate(ptas, transx, transy) as Pta
	// ptaTranslate(PTA *, l_float32, l_float32) as PTA *
	///  <summary>
	/// (1) See createMatrix2dTranslate() for details of transform.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaTranslate/*"/>
	///  <param name="transx">[in] - x component of translation wrt. the origin</param>
	///  <param name="transy">[in] - y component of translation wrt. the origin</param>
	///   <returns>ptad  translated points, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta Translate (Single transx,
						  Single transy)
	{
		Pta RetObj = _All.ptaTranslate(this, transx, transy);
		return RetObj;
	}

	// affinecompose.c (262, 1)
	// ptaScale(ptas, scalex, scaley) as Pta
	// ptaScale(PTA *, l_float32, l_float32) as PTA *
	///  <summary>
	/// (1) See createMatrix2dScale() for details of transform.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaScale/*"/>
	///  <param name="scalex">[in] - horizontal scale factor</param>
	///  <param name="scaley">[in] - vertical scale factor</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta Scale (Single scalex,
					  Single scaley)
	{
		Pta RetObj = _All.ptaScale(this, scalex, scaley);
		return RetObj;
	}

	// affinecompose.c (313, 1)
	// ptaRotate(ptas, xc, yc, angle) as Pta
	// ptaRotate(PTA *, l_float32, l_float32, l_float32) as PTA *
	///  <summary>
	/// Notes<para/>
	///
	/// (1) See createMatrix2dScale() for details of transform.<para/>
	///
	/// (2) This transform can be thought of as composed of the
	/// sum of two parts:
	/// a) an (x,y)-dependent rotation about the origin:
	/// xr = x  cosa - y  sina
	/// yr = x  sina + y  cosa
	/// b) an (x,y)-independent translation that depends on the
	/// rotation center and the angle:
	/// xt = xc - xc  cosa + yc  sina
	/// yt = yc - xc  sina - yc  cosa
	/// The translation part (xt,yt) is equal to the difference
	/// between the center (xc,yc) and the location of the
	/// center after it is rotated about the origin.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaRotate/*"/>
	///  <param name="xc">[in] - location of center of rotation</param>
	///  <param name="yc">[in] - location of center of rotation</param>
	///  <param name="angle">[in] - rotation in radians clockwise is positive</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta Rotate (Single xc,
					   Single yc,
					   Single angle)
	{
		Pta RetObj = _All.ptaRotate(this, xc, yc, angle);
		return RetObj;
	}

	// affinecompose.c (457, 1)
	// ptaAffineTransform(ptas, mat) as Pta
	// ptaAffineTransform(PTA *, l_float32 *) as PTA *
	///  <summary>
	/// ptaAffineTransform()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaAffineTransform/*"/>
	///  <param name="mat">[in] - 3x3 transform matrix canonical form</param>
	///   <returns>ptad  transformed points, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta AffineTransform (Single[] mat)
	{
		Pta RetObj = _All.ptaAffineTransform(this, mat);
		return RetObj;
	}

	// boxfunc4.c (808, 1)
	// ptaConvertToBoxa(pta, ncorners) as Boxa
	// ptaConvertToBoxa(PTA *, l_int32) as BOXA *
	///  <summary>
	/// (1) For 2 corners, the order of the 2 points is UL, LR.
	/// For 4 corners, the order of points is UL, UR, LL, LR.<para/>
	///
	/// (2) Each derived box is the minimum size containing all corners.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaConvertToBoxa/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="ncorners">[in] - 2 or 4 for the representation of each box</param>
	///   <returns>boxa with one box for each 2 or 4 points in the pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Boxa ConvertToBoxa (Pta pta,
							   int ncorners)
	{
		Boxa RetObj = _All.ptaConvertToBoxa(pta, ncorners);
		return RetObj;
	}

	// boxfunc4.c (905, 1)
	// ptaConvertToBox(pta) as Box
	// ptaConvertToBox(PTA *) as BOX *
	///  <summary>
	/// (1) For 2 corners, the order of the 2 points is UL, LR.
	/// For 4 corners, the order of points is UL, UR, LL, LR.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaConvertToBox/*"/>
	///  <param name="pta">[in] - </param>
	///   <returns>box minimum containing all points in the pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box ConvertToBox (Pta pta)
	{
		Box RetObj = _All.ptaConvertToBox(pta);
		return RetObj;
	}

	// ptabasic.c (116, 1)
	// ptaCreate(n) as Pta
	// ptaCreate(l_int32) as PTA *
	///  <summary>
	/// ptaCreate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaCreate/*"/>
	///  <param name="n">[in] - initial array sizes</param>
	///   <returns>pta, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta Create (int n)
	{
		Pta RetObj = _All.ptaCreate(n);
		return RetObj;
	}

	// ptabasic.c (149, 1)
	// ptaCreateFromNuma(nax, nay) as Pta
	// ptaCreateFromNuma(NUMA *, NUMA *) as PTA *
	///  <summary>
	/// ptaCreateFromNuma()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaCreateFromNuma/*"/>
	///  <param name="nax">[in][optional] - can be null</param>
	///  <param name="nay">[in] - </param>
	///   <returns>pta, or NULL on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta CreateFromNuma (Numa nay,
							   Numa nax)
	{
		Pta RetObj = _All.ptaCreateFromNuma(nax, nay);
		return RetObj;
	}

	// ptabasic.c (192, 1)
	// ptaDestroy(ppta) as Object
	// ptaDestroy(PTA **) as void
	///  <summary>
	/// (1) Decrements the ref count and, if 0, destroys the pta.<para/>
	///
	/// (2) Always nulls the input ptr.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaDestroy/*"/>
	///  <param name="ppta">[in,out] - to be nulled</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref Pta ppta)
	{
		_All.ptaDestroy(ref ppta);
	}

	// ptabasic.c (225, 1)
	// ptaCopy(pta) as Pta
	// ptaCopy(PTA *) as PTA *
	///  <summary>
	/// ptaCopy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaCopy/*"/>
	///  <param name="pta">[in] - </param>
	///   <returns>copy of pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta Copy (Pta pta)
	{
		Pta RetObj = _All.ptaCopy(pta);
		return RetObj;
	}

	// ptabasic.c (257, 1)
	// ptaCopyRange(ptas, istart, iend) as Pta
	// ptaCopyRange(PTA *, l_int32, l_int32) as PTA *
	///  <summary>
	/// ptaCopyRange()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaCopyRange/*"/>
	///  <param name="istart">[in] - starting index in ptas</param>
	///  <param name="iend">[in] - ending index in ptas use 0 to copy to end</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta CopyRange (int istart,
						  int iend)
	{
		Pta RetObj = _All.ptaCopyRange(this, istart, iend);
		return RetObj;
	}

	// ptabasic.c (296, 1)
	// ptaClone(pta) as Pta
	// ptaClone(PTA *) as PTA *
	///  <summary>
	/// ptaClone()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaClone/*"/>
	///  <param name="pta">[in] - </param>
	///   <returns>ptr to same pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta Clone (Pta pta)
	{
		Pta RetObj = _All.ptaClone(pta);
		return RetObj;
	}

	// ptabasic.c (320, 1)
	// ptaEmpty(pta) as int
	// ptaEmpty(PTA *) as l_ok
	///  <summary>
	/// This only resets the Pta::n field, for reuse
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaEmpty/*"/>
	///  <param name="pta">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Empty (Pta pta)
	{
		int RetObj = _All.ptaEmpty(pta);
		return RetObj;
	}

	// ptabasic.c (342, 1)
	// ptaAddPt(pta, x, y) as int
	// ptaAddPt(PTA *, l_float32, l_float32) as l_ok
	///  <summary>
	/// ptaAddPt()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaAddPt/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="x">[in] - </param>
	///  <param name="y">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddPt (Pta pta,
					  Single x,
					  Single y)
	{
		int RetObj = _All.ptaAddPt(pta, x, y);
		return RetObj;
	}

	// ptabasic.c (404, 1)
	// ptaInsertPt(pta, index, x, y) as int
	// ptaInsertPt(PTA *, l_int32, l_int32, l_int32) as l_ok
	///  <summary>
	/// ptaInsertPt()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaInsertPt/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="index">[in] - at which pt is to be inserted</param>
	///  <param name="x">[in] - point values</param>
	///  <param name="y">[in] - point values</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int InsertPt (Pta pta,
						 int index,
						 int x,
						 int y)
	{
		int RetObj = _All.ptaInsertPt(pta, index, x, y);
		return RetObj;
	}

	// ptabasic.c (447, 1)
	// ptaRemovePt(pta, index) as int
	// ptaRemovePt(PTA *, l_int32) as l_ok
	///  <summary>
	/// (1) This shifts pta[i] to pta[i - 1] for all i  is greater  index.<para/>
	///
	/// (2) It should not be used repeatedly on large arrays,
	/// because the function is O(n).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaRemovePt/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="index">[in] - of point to be removed</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RemovePt (Pta pta,
						 int index)
	{
		int RetObj = _All.ptaRemovePt(pta, index);
		return RetObj;
	}

	// ptabasic.c (474, 1)
	// ptaGetRefcount(pta) as int
	// ptaGetRefcount(PTA *) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetRefcount/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRefcount (Pta pta)
	{
		int RetObj = _All.ptaGetRefcount(pta);
		return RetObj;
	}

	// ptabasic.c (485, 1)
	// ptaChangeRefcount(pta, delta) as int
	// ptaChangeRefcount(PTA *, l_int32) as l_int32
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaChangeRefcount/*"/>
	///   <returns></returns>
	// CreateAdditiveFunction: Function/Else
	public int ChangeRefcount (Pta pta,
							   int delta)
	{
		int RetObj = _All.ptaChangeRefcount(pta, delta);
		return RetObj;
	}

	// ptabasic.c (504, 1)
	// ptaGetCount(pta) as int
	// ptaGetCount(PTA *) as l_int32
	///  <summary>
	/// ptaGetCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetCount/*"/>
	///  <param name="pta">[in] - </param>
	///   <returns>count, or 0 if no pta</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCount (Pta pta)
	{
		int RetObj = _All.ptaGetCount(pta);
		return RetObj;
	}

	// ptabasic.c (525, 1)
	// ptaGetPt(pta, index, px, py) as int
	// ptaGetPt(PTA *, l_int32, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// ptaGetPt()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetPt/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="index">[in] - into arrays</param>
	///  <param name="px">[out][optional] - float x value</param>
	///  <param name="py">[out][optional] - float y value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetPt (Pta pta,
					  int index,
					  out Single px,
					  out Single py)
	{
		int RetObj = _All.ptaGetPt(pta, index, out px, out py);
		return RetObj;
	}

	// ptabasic.c (555, 1)
	// ptaGetIPt(pta, index, px, py) as int
	// ptaGetIPt(PTA *, l_int32, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// ptaGetIPt()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetIPt/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="index">[in] - into arrays</param>
	///  <param name="px">[out][optional] - integer x value</param>
	///  <param name="py">[out][optional] - integer y value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetIPt (Pta pta,
					   int index,
					   out int px,
					   out int py)
	{
		int RetObj = _All.ptaGetIPt(pta, index, out px, out py);
		return RetObj;
	}

	// ptabasic.c (584, 1)
	// ptaSetPt(pta, index, x, y) as int
	// ptaSetPt(PTA *, l_int32, l_float32, l_float32) as l_ok
	///  <summary>
	/// ptaSetPt()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaSetPt/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="index">[in] - into arrays</param>
	///  <param name="x">[in] - </param>
	///  <param name="y">[in] - </param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetPt (Pta pta,
					  int index,
					  Single x,
					  Single y)
	{
		int RetObj = _All.ptaSetPt(pta, index, x, y);
		return RetObj;
	}

	// ptabasic.c (616, 1)
	// ptaGetArrays(pta, pnax, pnay) as int
	// ptaGetArrays(PTA *, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// (1) This copies the internal arrays into new Numas.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetArrays/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="pnax">[out][optional] - numa of x array</param>
	///  <param name="pnay">[out][optional] - numa of y array</param>
	///   <returns>0 if OK 1 on error or if pta is empty</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetArrays (Pta pta,
						  out Numa pnax,
						  out Numa pnay)
	{
		int RetObj = _All.ptaGetArrays(pta, out pnax, out pnay);
		return RetObj;
	}

	// ptabasic.c (664, 1)
	// ptaRead(filename) as Pta
	// ptaRead(const char *) as PTA *
	///  <summary>
	/// ptaRead()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaRead/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta Read (String filename)
	{
		Pta RetObj = _All.ptaRead(filename);
		return RetObj;
	}

	// ptabasic.c (691, 1)
	// ptaReadStream(fp) as Pta
	// ptaReadStream(FILE *) as PTA *
	///  <summary>
	/// ptaReadStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta ReadStream (FILE fp)
	{
		Pta RetObj = _All.ptaReadStream(fp);
		return RetObj;
	}

	// ptabasic.c (744, 1)
	// ptaReadMem(data, size) as Pta
	// ptaReadMem(const l_uint8 *, size_t) as PTA *
	///  <summary>
	/// ptaReadMem()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaReadMem/*"/>
	///  <param name="data">[in] - serialization in ascii</param>
	///  <param name="size">[in] - of data in bytes can use strlen to get it</param>
	///   <returns>pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta ReadMem (Byte[] data,
						uint size)
	{
		Pta RetObj = _All.ptaReadMem(data, size);
		return RetObj;
	}

	// ptabasic.c (782, 1)
	// ptaWriteDebug(filename, pta, type) as int
	// ptaWriteDebug(const char *, PTA *, l_int32) as l_ok
	///  <summary>
	/// (1) Debug version, intended for use in the library when writing
	/// to files in a temp directory with names that are compiled in.
	/// This is used instead of ptaWrite() for all such library calls.<para/>
	///
	/// (2) The global variable LeptDebugOK defaults to 0, and can be set
	/// or cleared by the function setLeptDebugOK().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaWriteDebug/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="pta">[in] - </param>
	///  <param name="type">[in] - 0 for float values 1 for integer values</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteDebug (String filename,
						   Pta pta,
						   int type)
	{
		int RetObj = _All.ptaWriteDebug(filename, pta, type);
		return RetObj;
	}

	// ptabasic.c (806, 1)
	// ptaWrite(filename, pta, type) as int
	// ptaWrite(const char *, PTA *, l_int32) as l_ok
	///  <summary>
	/// ptaWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaWrite/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="pta">[in] - </param>
	///  <param name="type">[in] - 0 for float values 1 for integer values</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String filename,
					  Pta pta,
					  int type)
	{
		int RetObj = _All.ptaWrite(filename, pta, type);
		return RetObj;
	}

	// ptabasic.c (839, 1)
	// ptaWriteStream(fp, pta, type) as int
	// ptaWriteStream(FILE *, PTA *, l_int32) as l_ok
	///  <summary>
	/// ptaWriteStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaWriteStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="pta">[in] - </param>
	///  <param name="type">[in] - 0 for float values 1 for integer values</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp,
							Pta pta,
							int type)
	{
		int RetObj = _All.ptaWriteStream(fp, pta, type);
		return RetObj;
	}

	// ptabasic.c (888, 1)
	// ptaWriteMem(pdata, psize, pta, type) as int
	// ptaWriteMem(l_uint8 **, size_t *, PTA *, l_int32) as l_ok
	///  <summary>
	/// (1) Serializes a pta in memory and puts the result in a buffer.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaWriteMem/*"/>
	///  <param name="pdata">[out] - data of serialized pta ascii</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="pta">[in] - </param>
	///  <param name="type">[in] - 0 for float values 1 for integer values</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMem (out Byte[] pdata,
						 out uint psize,
						 Pta pta,
						 int type)
	{
		int RetObj = _All.ptaWriteMem(out pdata, out psize, pta, type);
		return RetObj;
	}

	// ptafunc1.c (111, 1)
	// ptaSubsample(ptas, subfactor) as Pta
	// ptaSubsample(PTA *, l_int32) as PTA *
	///  <summary>
	/// ptaSubsample()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaSubsample/*"/>
	///  <param name="subfactor">[in] - subsample factor, greater or equal 1</param>
	///   <returns>ptad evenly sampled pt values from ptas, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta Subsample (int subfactor)
	{
		Pta RetObj = _All.ptaSubsample(this, subfactor);
		return RetObj;
	}

	// ptafunc1.c (154, 1)
	// ptaJoin(ptad, ptas, istart, iend) as int
	// ptaJoin(PTA *, PTA *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) istart  is smaller 0 is taken to mean 'read from the start' (istart = 0)<para/>
	///
	/// (2) iend  is smaller 0 means 'read to the end'<para/>
	///
	/// (3) if ptas == NULL, this is a no-op
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaJoin/*"/>
	///  <param name="ptad">[in] - dest pta add to this one</param>
	///  <param name="istart">[in] - starting index in ptas</param>
	///  <param name="iend">[in] - ending index in ptas use -1 to cat all</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Join (Pta ptad,
					 int istart,
					 int iend)
	{
		int RetObj = _All.ptaJoin(ptad, this, istart, iend);
		return RetObj;
	}

	// ptafunc1.c (242, 1)
	// ptaReverse(ptas, type) as Pta
	// ptaReverse(PTA *, l_int32) as PTA *
	///  <summary>
	/// ptaReverse()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaReverse/*"/>
	///  <param name="type">[in] - 0 for float values 1 for integer values</param>
	///   <returns>ptad reversed pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta Reverse (int type)
	{
		Pta RetObj = _All.ptaReverse(this, type);
		return RetObj;
	}

	// ptafunc1.c (278, 1)
	// ptaTranspose(ptas) as Pta
	// ptaTranspose(PTA *) as PTA *
	///  <summary>
	/// ptaTranspose()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaTranspose/*"/>
	///   <returns>ptad with x and y values swapped, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta Transpose ()
	{
		Pta RetObj = _All.ptaTranspose(this);
		return RetObj;
	}

	// ptafunc1.c (318, 1)
	// ptaCyclicPerm(ptas, xs, ys) as Pta
	// ptaCyclicPerm(PTA *, l_int32, l_int32) as PTA *
	///  <summary>
	/// (1) Check to insure that (a) ptas is a closed path where
	/// the first and last points are identical, and (b) the
	/// resulting pta also starts and ends on the same point
	/// (which in this case is (xs, ys).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaCyclicPerm/*"/>
	///  <param name="xs">[in] - start point must be in ptas</param>
	///  <param name="ys">[in] - start point must be in ptas</param>
	///   <returns>ptad cyclic permutation, starting and ending at (xs, ys, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta CyclicPerm (int xs,
						   int ys)
	{
		Pta RetObj = _All.ptaCyclicPerm(this, xs, ys);
		return RetObj;
	}

	// ptafunc1.c (374, 1)
	// ptaSelectRange(ptas, first, last) as Pta
	// ptaSelectRange(PTA *, l_int32, l_int32) as PTA *
	///  <summary>
	/// ptaSelectRange()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaSelectRange/*"/>
	///  <param name="first">[in] - use 0 to select from the beginning</param>
	///  <param name="last">[in] - use 0 to select to the end</param>
	///   <returns>ptad, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta SelectRange (int first,
							int last)
	{
		Pta RetObj = _All.ptaSelectRange(this, first, last);
		return RetObj;
	}

	// ptafunc1.c (424, 1)
	// ptaGetBoundingRegion(pta) as Box
	// ptaGetBoundingRegion(PTA *) as BOX *
	///  <summary>
	/// (1) This is used when the pta represents a set of points in
	/// a two-dimensional image.  It returns the box of minimum
	/// size containing the pts in the pta.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetBoundingRegion/*"/>
	///  <param name="pta">[in] - </param>
	///   <returns>box, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Box GetBoundingRegion (Pta pta)
	{
		Box RetObj = _All.ptaGetBoundingRegion(pta);
		return RetObj;
	}

	// ptafunc1.c (468, 1)
	// ptaGetRange(pta, pminx, pmaxx, pminy, pmaxy) as int
	// ptaGetRange(PTA *, l_float32 *, l_float32 *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// (1) We can use pts to represent pairs of floating values, that
	/// are not necessarily tied to a two-dimension region.  For
	/// example, the pts can represent a general function y(x).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetRange/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="pminx">[out][optional] - min value of x</param>
	///  <param name="pmaxx">[out][optional] - max value of x</param>
	///  <param name="pminy">[out][optional] - min value of y</param>
	///  <param name="pmaxy">[out][optional] - max value of y</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRange (Pta pta,
						 out Single pminx,
						 out Single pmaxx,
						 out Single pminy,
						 out Single pmaxy)
	{
		int RetObj = _All.ptaGetRange(pta, out pminx, out pmaxx, out pminy, out pmaxy);
		return RetObj;
	}

	// ptafunc1.c (518, 1)
	// ptaGetInsideBox(ptas, box) as Pta
	// ptaGetInsideBox(PTA *, BOX *) as PTA *
	///  <summary>
	/// ptaGetInsideBox()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetInsideBox/*"/>
	///  <param name="box">[in] - </param>
	///   <returns>ptad of pts in ptas that are inside the box, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta GetInsideBox (Box box)
	{
		Pta RetObj = _All.ptaGetInsideBox(this, box);
		return RetObj;
	}

	// ptafunc1.c (650, 1)
	// ptaContainsPt(pta, x, y) as int
	// ptaContainsPt(PTA *, l_int32, l_int32) as l_int32
	///  <summary>
	/// ptaContainsPt()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaContainsPt/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="x">[in] - point</param>
	///  <param name="y">[in] - point</param>
	///   <returns>1 if contained, 0 otherwise or on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ContainsPt (Pta pta,
						   int x,
						   int y)
	{
		int RetObj = _All.ptaContainsPt(pta, x, y);
		return RetObj;
	}

	// ptafunc1.c (679, 1)
	// ptaTestIntersection(pta1, pta2) as int
	// ptaTestIntersection(PTA *, PTA *) as l_int32
	///  <summary>
	/// ptaTestIntersection()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaTestIntersection/*"/>
	///  <param name="pta1">[in] - </param>
	///  <param name="pta2">[in] - </param>
	///   <returns>bval which is 1 if they have any elements in common 0 otherwise or on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int TestIntersection (Pta pta1,
								 Pta pta2)
	{
		int RetObj = _All.ptaTestIntersection(pta1, pta2);
		return RetObj;
	}

	// ptafunc1.c (720, 1)
	// ptaTransform(ptas, shiftx, shifty, scalex, scaley) as Pta
	// ptaTransform(PTA *, l_int32, l_int32, l_float32, l_float32) as PTA *
	///  <summary>
	/// (1) Shift first, then scale.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaTransform/*"/>
	///  <param name="shiftx">[in] - </param>
	///  <param name="shifty">[in] - </param>
	///  <param name="scalex">[in] - </param>
	///  <param name="scaley">[in] - </param>
	///   <returns>pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta Transform (int shiftx,
						  int shifty,
						  Single scalex,
						  Single scaley)
	{
		Pta RetObj = _All.ptaTransform(this, shiftx, shifty, scalex, scaley);
		return RetObj;
	}

	// ptafunc1.c (760, 1)
	// ptaPtInsidePolygon(pta, x, y, pinside) as int
	// ptaPtInsidePolygon(PTA *, l_float32, l_float32, l_int32 *) as l_int32
	///  <summary>
	/// ptaPtInsidePolygon()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaPtInsidePolygon/*"/>
	///  <param name="pta">[in] - vertices of a polygon</param>
	///  <param name="x">[in] - point to be tested</param>
	///  <param name="y">[in] - point to be tested</param>
	///  <param name="pinside">[out] - 1 if inside 0 if outside or on boundary</param>
	///   <returns>1 if OK, 0 on error The abs value of the sum of the angles subtended from a point by the sides of a polygon, when taken in order traversing the polygon, is 0 if the point is outside the polygon and 2pi if inside. The sign will be positive if traversed cw and negative if ccw.</returns>
	// CreateAdditiveFunction: Function/Else
	public int PtInsidePolygon (Pta pta,
								Single x,
								Single y,
								out int pinside)
	{
		int RetObj = _All.ptaPtInsidePolygon(pta, x, y, out pinside);
		return RetObj;
	}

	// ptafunc1.c (841, 1)
	// ptaGetMinMax(pta, pxmin, pymin, pxmax, pymax) as int
	// ptaGetMinMax(PTA *, l_float32 *, l_float32 *, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// ptaGetMinMax()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetMinMax/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="pxmin">[out][optional] - min of x</param>
	///  <param name="pymin">[out][optional] - min of y</param>
	///  <param name="pxmax">[out][optional] - max of x</param>
	///  <param name="pymax">[out][optional] - max of y</param>
	///   <returns>0 if OK, 1 on error.  If pta is empty, requested values are returned as -1.0.</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMinMax (Pta pta,
						  out Single pxmin,
						  out Single pymin,
						  out Single pxmax,
						  out Single pymax)
	{
		int RetObj = _All.ptaGetMinMax(pta, out pxmin, out pymin, out pxmax, out pymax);
		return RetObj;
	}

	// ptafunc1.c (894, 1)
	// ptaSelectByValue(ptas, xth, yth, type, relation) as Pta
	// ptaSelectByValue(PTA *, l_float32, l_float32, l_int32, l_int32) as PTA *
	///  <summary>
	/// ptaSelectByValue()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaSelectByValue/*"/>
	///  <param name="xth">[in] - threshold values</param>
	///  <param name="yth">[in] - threshold values</param>
	///  <param name="type">[in] - L_SELECT_XVAL, L_SELECT_YVAL, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	///  <param name="relation">[in] - L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	///   <returns>ptad filtered set, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta SelectByValue (Single xth,
							  Single yth,
							  int type,
							  int relation)
	{
		Pta RetObj = _All.ptaSelectByValue(this, xth, yth, type, relation);
		return RetObj;
	}

	// ptafunc1.c (962, 1)
	// ptaCropToMask(ptas, pixm) as Pta
	// ptaCropToMask(PTA *, PIX *) as PTA *
	///  <summary>
	/// ptaCropToMask()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaCropToMask/*"/>
	///  <param name="pixm">[in] - 1 bpp mask</param>
	///   <returns>ptad  with only pts under the mask fg, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta CropToMask (Pix pixm)
	{
		Pta RetObj = _All.ptaCropToMask(this, pixm);
		return RetObj;
	}

	// ptafunc1.c (1029, 1)
	// ptaGetLinearLSF(pta, pa, pb, pnafit) as int
	// ptaGetLinearLSF(PTA *, l_float32 *, l_float32 *, NUMA **) as l_ok
	///  <summary>
	/// (1) Either or both [and]a and [and]b must be input.  They determine the
	/// type of line that is fit.<para/>
	///
	/// (2) If both [and]a and [and]b are defined, this returns a and b that minimize:
	/// sum (yi - axi -b)^2
	/// i
	/// The method is simple: differentiate this expression w/rt a and b,
	/// and solve the resulting two equations for a and b in terms of
	/// various sums over the input data (xi, yi).<para/>
	///
	/// (3) We also allow two special cases, where either a = 0 or b = 0:
	/// (a) If [and]a is given and [and]b = null, find the linear LSF that
	/// goes through the origin (b = 0).
	/// (b) If [and]b is given and [and]a = null, find the linear LSF with
	/// zero slope (a = 0).<para/>
	///
	/// (4) If [and]nafit is defined, this returns an array of fitted values,
	/// corresponding to the two implicit Numa arrays (nax and nay) in pta.
	/// Thus, just as you can plot the data in pta as nay vs. nax,
	/// you can plot the linear least square fit as nafit vs. nax.
	/// Get the nax array using ptaGetArrays(pta, [and]nax, NULL)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetLinearLSF/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="pa">[out][optional] - slope a of least square fit: y = ax + b</param>
	///  <param name="pb">[out][optional] - intercept b of least square fit</param>
	///  <param name="pnafit">[out][optional] - numa of least square fit</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetLinearLSF (Pta pta,
							 out Single pa,
							 out Single pb,
							 out Numa pnafit)
	{
		int RetObj = _All.ptaGetLinearLSF(pta, out pa, out pb, out pnafit);
		return RetObj;
	}

	// ptafunc1.c (1130, 1)
	// ptaGetQuadraticLSF(pta, pa, pb, pc, pnafit) as int
	// ptaGetQuadraticLSF(PTA *, l_float32 *, l_float32 *, l_float32 *, NUMA **) as l_ok
	///  <summary>
	/// (1) This does a quadratic least square fit to the set of points
	/// in %pta.  That is, it finds coefficients a, b and c that minimize:
	/// sum (yi - axixi -bxi -c)^2
	/// i
	/// The method is simple: differentiate this expression w/rt
	/// a, b and c, and solve the resulting three equations for these
	/// coefficients in terms of various sums over the input data (xi, yi).
	/// The three equations are in the form:
	/// f[0][0]a + f[0][1]b + f[0][2]c = g[0]
	/// f[1][0]a + f[1][1]b + f[1][2]c = g[1]
	/// f[2][0]a + f[2][1]b + f[2][2]c = g[2]<para/>
	///
	/// (2) If [and]nafit is defined, this returns an array of fitted values,
	/// corresponding to the two implicit Numa arrays (nax and nay) in pta.
	/// Thus, just as you can plot the data in pta as nay vs. nax,
	/// you can plot the linear least square fit as nafit vs. nax.
	/// Get the nax array using ptaGetArrays(pta, [and]nax, NULL)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetQuadraticLSF/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="pa">[out][optional] - coeff a of LSF: y = ax^2 + bx + c</param>
	///  <param name="pb">[out][optional] - coeff b of LSF: y = ax^2 + bx + c</param>
	///  <param name="pc">[out][optional] - coeff c of LSF: y = ax^2 + bx + c</param>
	///  <param name="pnafit">[out][optional] - numa of least square fit</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetQuadraticLSF (Pta pta,
								out Single pa,
								out Single pb,
								out Single pc,
								out Numa pnafit)
	{
		int RetObj = _All.ptaGetQuadraticLSF(pta, out pa, out pb, out pc, out pnafit);
		return RetObj;
	}

	// ptafunc1.c (1243, 1)
	// ptaGetCubicLSF(pta, pa, pb, pc, pd, pnafit) as int
	// ptaGetCubicLSF(PTA *, l_float32 *, l_float32 *, l_float32 *, l_float32 *, NUMA **) as l_ok
	///  <summary>
	/// (1) This does a cubic least square fit to the set of points
	/// in %pta.  That is, it finds coefficients a, b, c and d
	/// that minimize:
	/// sum (yi - axixixi -bxixi -cxi - d)^2
	/// i
	/// Differentiate this expression w/rt a, b, c and d, and solve
	/// the resulting four equations for these coefficients in
	/// terms of various sums over the input data (xi, yi).
	/// The four equations are in the form:
	/// f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] = g[0]
	/// f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] = g[1]
	/// f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] = g[2]
	/// f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] = g[3]<para/>
	///
	/// (2) If [and]nafit is defined, this returns an array of fitted values,
	/// corresponding to the two implicit Numa arrays (nax and nay) in pta.
	/// Thus, just as you can plot the data in pta as nay vs. nax,
	/// you can plot the linear least square fit as nafit vs. nax.
	/// Get the nax array using ptaGetArrays(pta, [and]nax, NULL)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetCubicLSF/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="pa">[out][optional] - coeff a of LSF: y = ax^3 + bx^2 + cx + d</param>
	///  <param name="pb">[out][optional] - coeff b of LSF</param>
	///  <param name="pc">[out][optional] - coeff c of LSF</param>
	///  <param name="pd">[out][optional] - coeff d of LSF</param>
	///  <param name="pnafit">[out][optional] - numa of least square fit</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCubicLSF (Pta pta,
							out Single pa,
							out Single pb,
							out Single pc,
							out Single pd,
							out Numa pnafit)
	{
		int RetObj = _All.ptaGetCubicLSF(pta, out pa, out pb, out pc, out pd, out pnafit);
		return RetObj;
	}

	// ptafunc1.c (1373, 1)
	// ptaGetQuarticLSF(pta, pa, pb, pc, pd, pe, pnafit) as int
	// ptaGetQuarticLSF(PTA *, l_float32 *, l_float32 *, l_float32 *, l_float32 *, l_float32 *, NUMA **) as l_ok
	///  <summary>
	/// (1) This does a quartic least square fit to the set of points
	/// in %pta.  That is, it finds coefficients a, b, c, d and 3
	/// that minimize:
	/// sum (yi - axixixixi -bxixixi -cxixi - dxi - e)^2
	/// i
	/// Differentiate this expression w/rt a, b, c, d and e, and solve
	/// the resulting five equations for these coefficients in
	/// terms of various sums over the input data (xi, yi).
	/// The five equations are in the form:
	/// f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] + f[0][4] = g[0]
	/// f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] + f[1][4] = g[1]
	/// f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] + f[2][4] = g[2]
	/// f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] + f[3][4] = g[3]
	/// f[4][0]a + f[4][1]b + f[4][2]c + f[4][3] + f[4][4] = g[4]<para/>
	///
	/// (2) If [and]nafit is defined, this returns an array of fitted values,
	/// corresponding to the two implicit Numa arrays (nax and nay) in pta.
	/// Thus, just as you can plot the data in pta as nay vs. nax,
	/// you can plot the linear least square fit as nafit vs. nax.
	/// Get the nax array using ptaGetArrays(pta, [and]nax, NULL)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetQuarticLSF/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="pa">[out][optional] - coeff a of LSF: y = ax^4 + bx^3 + cx^2 + dx + e</param>
	///  <param name="pb">[out][optional] - coeff b of LSF</param>
	///  <param name="pc">[out][optional] - coeff c of LSF</param>
	///  <param name="pd">[out][optional] - coeff d of LSF</param>
	///  <param name="pe">[out][optional] - coeff e of LSF</param>
	///  <param name="pnafit">[out][optional] - numa of least square fit</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetQuarticLSF (Pta pta,
							  out Single pa,
							  out Single pb,
							  out Single pc,
							  out Single pd,
							  out Single pe,
							  out Numa pnafit)
	{
		int RetObj = _All.ptaGetQuarticLSF(pta, out pa, out pb, out pc, out pd, out pe, out pnafit);
		return RetObj;
	}

	// ptafunc1.c (1509, 1)
	// ptaNoisyLinearLSF(pta, factor, pptad, pa, pb, pmederr, pnafit) as int
	// ptaNoisyLinearLSF(PTA *, l_float32, PTA **, l_float32 *, l_float32 *, l_float32 *, NUMA **) as l_ok
	///  <summary>
	/// (1) This does a linear least square fit to the set of points
	/// in %pta.  It then evaluates the errors and removes points
	/// whose error is greater or equal factor  median_error.  It then re-runs
	/// the linear LSF on the resulting points.<para/>
	///
	/// (2) Either or both [and]a and [and]b must be input.  They determine the
	/// type of line that is fit.<para/>
	///
	/// (3) The median error can give an indication of how good the fit
	/// is likely to be.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaNoisyLinearLSF/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="factor">[in] - reject outliers with error greater than this number of medians typically ~ 3</param>
	///  <param name="pptad">[out][optional] - with outliers removed</param>
	///  <param name="pa">[out][optional] - slope a of least square fit: y = ax + b</param>
	///  <param name="pb">[out][optional] - intercept b of least square fit</param>
	///  <param name="pmederr">[out][optional] - median error</param>
	///  <param name="pnafit">[out][optional] - numa of least square fit to ptad</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int NoisyLinearLSF (Pta pta,
							   Single factor,
							   out Pta pptad,
							   out Single pa,
							   out Single pb,
							   out Single pmederr,
							   out Numa pnafit)
	{
		int RetObj = _All.ptaNoisyLinearLSF(pta, factor, out pptad, out pa, out pb, out pmederr, out pnafit);
		return RetObj;
	}

	// ptafunc1.c (1596, 1)
	// ptaNoisyQuadraticLSF(pta, factor, pptad, pa, pb, pc, pmederr, pnafit) as int
	// ptaNoisyQuadraticLSF(PTA *, l_float32, PTA **, l_float32 *, l_float32 *, l_float32 *, l_float32 *, NUMA **) as l_ok
	///  <summary>
	/// (1) This does a quadratic least square fit to the set of points
	/// in %pta.  It then evaluates the errors and removes points
	/// whose error is greater or equal factor  median_error.  It then re-runs
	/// a quadratic LSF on the resulting points.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaNoisyQuadraticLSF/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="factor">[in] - reject outliers with error greater than this number of medians typically ~ 3</param>
	///  <param name="pptad">[out][optional] - with outliers removed</param>
	///  <param name="pa">[out][optional] - coeff a of LSF: y = ax^2 + bx + c</param>
	///  <param name="pb">[out][optional] - coeff b of LSF: y = ax^2 + bx + c</param>
	///  <param name="pc">[out][optional] - coeff c of LSF: y = ax^2 + bx + c</param>
	///  <param name="pmederr">[out][optional] - median error</param>
	///  <param name="pnafit">[out][optional] - numa of least square fit to ptad</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int NoisyQuadraticLSF (Pta pta,
								  Single factor,
								  out Pta pptad,
								  out Single pa,
								  out Single pb,
								  out Single pc,
								  out Single pmederr,
								  out Numa pnafit)
	{
		int RetObj = _All.ptaNoisyQuadraticLSF(pta, factor, out pptad, out pa, out pb, out pc, out pmederr, out pnafit);
		return RetObj;
	}

	// ptafunc1.c (1893, 1)
	// ptaGetPixelsFromPix(pixs, box) as Pta
	// ptaGetPixelsFromPix(PIX *, BOX *) as PTA *
	///  <summary>
	/// (1) Generates a pta of fg pixels in the pix, within the box.
	/// If box == NULL, it uses the entire pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetPixelsFromPix/*"/>
	///  <param name="pixs">[in] - 1 bpp</param>
	///  <param name="box">[in][optional] - can be null</param>
	///   <returns>pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta GetPixelsFromPix (Pix pixs,
								 Box box)
	{
		Pta RetObj = _All.ptaGetPixelsFromPix(pixs, box);
		return RetObj;
	}

	// ptafunc1.c (1987, 1)
	// ptaGetBoundaryPixels(pixs, type) as Pta
	// ptaGetBoundaryPixels(PIX *, l_int32) as PTA *
	///  <summary>
	/// (1) This generates a pta of either fg or bg boundary pixels.<para/>
	///
	/// (2) See also pixGeneratePtaBoundary() for rendering of
	/// fg boundary pixels.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetBoundaryPixels/*"/>
	///  <param name="pixs">[in] - 1 bpp</param>
	///  <param name="type">[in] - L_BOUNDARY_FG, L_BOUNDARY_BG</param>
	///   <returns>pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta GetBoundaryPixels (Pix pixs,
								  int type)
	{
		Pta RetObj = _All.ptaGetBoundaryPixels(pixs, type);
		return RetObj;
	}

	// ptafunc1.c (2176, 1)
	// ptaGetNeighborPixLocs(pixs, x, y, conn) as Pta
	// ptaGetNeighborPixLocs(PIX *, l_int32, l_int32, l_int32) as PTA *
	///  <summary>
	/// (1) Generates a pta of all valid neighbor pixel locations,
	/// or NULL on error.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetNeighborPixLocs/*"/>
	///  <param name="pixs">[in] - any depth</param>
	///  <param name="x">[in] - pixel from which we search for nearest neighbors</param>
	///  <param name="y">[in] - pixel from which we search for nearest neighbors</param>
	///  <param name="conn">[in] - 4 or 8 connectivity</param>
	///   <returns>pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta GetNeighborPixLocs (Pix pixs,
								   int x,
								   int y,
								   int conn)
	{
		Pta RetObj = _All.ptaGetNeighborPixLocs(pixs, x, y, conn);
		return RetObj;
	}

	// ptafunc1.c (2298, 1)
	// ptaConvertToNuma(pta, pnax, pnay) as int
	// ptaConvertToNuma(PTA *, NUMA **, NUMA **) as l_ok
	///  <summary>
	/// ptaConvertToNuma()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaConvertToNuma/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="pnax">[out] - addr of nax</param>
	///  <param name="pnay">[out] - addr of nay</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ConvertToNuma (Pta pta,
							  out Numa pnax,
							  out Numa pnay)
	{
		int RetObj = _All.ptaConvertToNuma(pta, out pnax, out pnay);
		return RetObj;
	}

	// ptafunc1.c (2542, 1)
	// ptaReplicatePattern(ptas, pixp, ptap, cx, cy, w, h) as Pta
	// ptaReplicatePattern(PTA *, PIX *, PTA *, l_int32, l_int32, l_int32, l_int32) as PTA *
	///  <summary>
	/// (1) You can use either the image %pixp or the set of pts %ptap.<para/>
	///
	/// (2) The pattern is placed with its reference point at each point
	/// in ptas, and all the fg pixels are colleced into ptad.
	/// For %pixp, this is equivalent to blitting pixp at each point
	/// in ptas, and then converting the resulting pix to a pta.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaReplicatePattern/*"/>
	///  <param name="pixp">[in][optional] - 1 bpp pattern, to be replicated in output pta</param>
	///  <param name="ptap">[in][optional] - set of pts, to be replicated in output pta</param>
	///  <param name="cx">[in] - reference point in pattern</param>
	///  <param name="cy">[in] - reference point in pattern</param>
	///  <param name="w">[in] - clipping sizes for output pta</param>
	///  <param name="h">[in] - clipping sizes for output pta</param>
	///   <returns>ptad with all points of replicated pattern, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta ReplicatePattern (int cx,
								 int cy,
								 int w,
								 int h,
								 Pix pixp,
								 Pta ptap)
	{
		Pta RetObj = _All.ptaReplicatePattern(this, pixp, ptap, cx, cy, w, h);
		return RetObj;
	}

	// ptafunc2.c (89, 1)
	// ptaSort(ptas, sorttype, sortorder, pnaindex) as Pta
	// ptaSort(PTA *, l_int32, l_int32, NUMA **) as PTA *
	///  <summary>
	/// ptaSort()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaSort/*"/>
	///  <param name="sorttype">[in] - L_SORT_BY_X, L_SORT_BY_Y</param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING, L_SORT_DECREASING</param>
	///  <param name="pnaindex">[out][optional] - index of sorted order into original array</param>
	///   <returns>ptad sorted version of ptas, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta Sort (int sorttype,
					 int sortorder,
					 out Numa pnaindex)
	{
		Pta RetObj = _All.ptaSort(this, sorttype, sortorder, out pnaindex);
		return RetObj;
	}

	// ptafunc2.c (132, 1)
	// ptaGetSortIndex(ptas, sorttype, sortorder, pnaindex) as int
	// ptaGetSortIndex(PTA *, l_int32, l_int32, NUMA **) as l_ok
	///  <summary>
	/// ptaGetSortIndex()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetSortIndex/*"/>
	///  <param name="sorttype">[in] - L_SORT_BY_X, L_SORT_BY_Y</param>
	///  <param name="sortorder">[in] - L_SORT_INCREASING, L_SORT_DECREASING</param>
	///  <param name="pnaindex">[out] - index of sorted order into original array</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetSortIndex (int sorttype,
							 int sortorder,
							 out Numa pnaindex)
	{
		int RetObj = _All.ptaGetSortIndex(this, sorttype, sortorder, out pnaindex);
		return RetObj;
	}

	// ptafunc2.c (182, 1)
	// ptaSortByIndex(ptas, naindex) as Pta
	// ptaSortByIndex(PTA *, NUMA *) as PTA *
	///  <summary>
	/// ptaSortByIndex()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaSortByIndex/*"/>
	///  <param name="naindex">[in] - na that maps from the new pta to the input pta</param>
	///   <returns>ptad sorted, or NULL on  error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta SortByIndex (Numa naindex)
	{
		Pta RetObj = _All.ptaSortByIndex(this, naindex);
		return RetObj;
	}

	// ptafunc2.c (257, 1)
	// ptaGetRankValue(pta, fract, ptasort, sorttype, pval) as int
	// ptaGetRankValue(PTA *, l_float32, PTA *, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// ptaGetRankValue()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaGetRankValue/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="fract">[in] - use 0.0 for smallest, 1.0 for largest</param>
	///  <param name="ptasort">[in][optional] - version of %pta sorted by %sorttype</param>
	///  <param name="sorttype">[in] - L_SORT_BY_X, L_SORT_BY_Y</param>
	///  <param name="pval">[out] - [and]rankval: the x or y value at %fract</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRankValue (Pta pta,
							 Single fract,
							 int sorttype,
							 out Single pval,
							 Pta ptasort)
	{
		int RetObj = _All.ptaGetRankValue(pta, fract, ptasort, sorttype, out pval);
		return RetObj;
	}

	// ptafunc2.c (317, 1)
	// ptaUnionByAset(pta1, pta2) as Pta
	// ptaUnionByAset(PTA *, PTA *) as PTA *
	///  <summary>
	/// (1) See sarrayRemoveDupsByAset() for the approach.<para/>
	///
	/// (2) The key is a 64-bit hash from the (x,y) pair.<para/>
	///
	/// (3) This is slower than ptaUnionByHash(), mostly because of the
	/// nlogn sort to build up the rbtree.  Do not use for large
	/// numbers of points (say,  is greater  1M).<para/>
	///
	/// (4) The Aset() functions use the sorted l_Aset, which is just
	/// an rbtree in disguise.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaUnionByAset/*"/>
	///  <param name="pta1">[in] - </param>
	///  <param name="pta2">[in] - </param>
	///   <returns>ptad with the union of the set of points, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta UnionByAset (Pta pta1,
							Pta pta2)
	{
		Pta RetObj = _All.ptaUnionByAset(pta1, pta2);
		return RetObj;
	}

	// ptafunc2.c (354, 1)
	// ptaRemoveDupsByAset(ptas) as Pta
	// ptaRemoveDupsByAset(PTA *) as PTA *
	///  <summary>
	/// (1) This is slower than ptaRemoveDupsByHash(), mostly because
	/// of the nlogn sort to build up the rbtree.  Do not use for
	/// large numbers of points (say,  is greater  1M).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaRemoveDupsByAset/*"/>
	///   <returns>ptad with duplicates removed, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta RemoveDupsByAset ()
	{
		Pta RetObj = _All.ptaRemoveDupsByAset(this);
		return RetObj;
	}

	// ptafunc2.c (401, 1)
	// ptaIntersectionByAset(pta1, pta2) as Pta
	// ptaIntersectionByAset(PTA *, PTA *) as PTA *
	///  <summary>
	/// (1) See sarrayIntersectionByAset() for the approach.<para/>
	///
	/// (2) The key is a 64-bit hash from the (x,y) pair.<para/>
	///
	/// (3) This is slower than ptaIntersectionByHash(), mostly because
	/// of the nlogn sort to build up the rbtree.  Do not use for
	/// large numbers of points (say,  is greater  1M).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaIntersectionByAset/*"/>
	///  <param name="pta1">[in] - </param>
	///  <param name="pta2">[in] - </param>
	///   <returns>ptad intersection of the point sets, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta IntersectionByAset (Pta pta1,
								   Pta pta2)
	{
		Pta RetObj = _All.ptaIntersectionByAset(pta1, pta2);
		return RetObj;
	}

	// ptafunc2.c (493, 1)
	// ptaUnionByHash(pta1, pta2) as Pta
	// ptaUnionByHash(PTA *, PTA *) as PTA *
	///  <summary>
	/// (1) This is faster than ptaUnionByAset(), because the
	/// bucket lookup is O(n).  It should be used if the pts are
	/// integers (e.g., representing pixel positions).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaUnionByHash/*"/>
	///  <param name="pta1">[in] - </param>
	///  <param name="pta2">[in] - </param>
	///   <returns>ptad with the union of the set of points, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta UnionByHash (Pta pta1,
							Pta pta2)
	{
		Pta RetObj = _All.ptaUnionByHash(pta1, pta2);
		return RetObj;
	}

	// ptafunc2.c (543, 1)
	// ptaRemoveDupsByHash(ptas, pptad, pdahash) as int
	// ptaRemoveDupsByHash(PTA *, PTA **, L_DNAHASH **) as l_ok
	///  <summary>
	/// (1) Generates a pta with unique values.<para/>
	///
	/// (2) The dnahash is built up with ptad to assure uniqueness.
	/// It can be used to find if a point is in the set:
	/// ptaFindPtByHash(ptad, dahash, x, y, [and]index)<para/>
	///
	/// (3) The hash of the (x,y) location is simple and fast.  It scales
	/// up with the number of buckets to insure a fairly random
	/// bucket selection for adjacent points.<para/>
	///
	/// (4) A Dna is used rather than a Numa because we need accurate
	/// representation of 32-bit integers that are indices into ptas.
	/// Integer to float to integer conversion makes errors for
	/// integers larger than 10M.<para/>
	///
	/// (5) This is faster than ptaRemoveDupsByAset(), because the
	/// bucket lookup is O(n), although there is a double-loop
	/// lookup within the dna in each bucket.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaRemoveDupsByHash/*"/>
	///  <param name="pptad">[out] - unique set of pts duplicates removed</param>
	///  <param name="pdahash">[out][optional] - dnahash used for lookup</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int RemoveDupsByHash (out Pta pptad,
								 out L_DnaHash pdahash)
	{
		int RetObj = _All.ptaRemoveDupsByHash(this, out pptad, out pdahash);
		return RetObj;
	}

	// ptafunc2.c (600, 1)
	// ptaIntersectionByHash(pta1, pta2) as Pta
	// ptaIntersectionByHash(PTA *, PTA *) as PTA *
	///  <summary>
	/// (1) This is faster than ptaIntersectionByAset(), because the
	/// bucket lookup is O(n).  It should be used if the pts are
	/// integers (e.g., representing pixel positions).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaIntersectionByHash/*"/>
	///  <param name="pta1">[in] - </param>
	///  <param name="pta2">[in] - </param>
	///   <returns>ptad intersection of the point sets, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta IntersectionByHash (Pta pta1,
								   Pta pta2)
	{
		Pta RetObj = _All.ptaIntersectionByHash(pta1, pta2);
		return RetObj;
	}

	// ptafunc2.c (674, 1)
	// ptaFindPtByHash(pta, dahash, x, y, pindex) as int
	// ptaFindPtByHash(PTA *, L_DNAHASH *, l_int32, l_int32, l_int32 *) as l_ok
	///  <summary>
	/// (1) Fast lookup in dnaHash associated with a pta, to see if a
	/// random point (x,y) is already stored in the hash table.<para/>
	///
	/// (2) We use a strong hash function to minimize the chance that
	/// two different points hash to the same key value.<para/>
	///
	/// (3) We select the number of buckets to be about 5% of the size
	/// of the input %pta, so that when fully populated, each
	/// bucket (dna) will have about 20 entries, each being an index
	/// into %pta.  In lookup, after hashing to the key, and then
	/// again to the bucket, we traverse the bucket (dna), using the
	/// index into %pta to check if the point (x,y) has been found before.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaFindPtByHash/*"/>
	///  <param name="pta">[in] - </param>
	///  <param name="dahash">[in] - built from pta</param>
	///  <param name="x">[in] - arbitrary points</param>
	///  <param name="y">[in] - arbitrary points</param>
	///  <param name="pindex">[out] - index into pta if (x,y) is in pta -1 otherwise</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int FindPtByHash (Pta pta,
							 L_DnaHash dahash,
							 int x,
							 int y,
							 out int pindex)
	{
		int RetObj = _All.ptaFindPtByHash(pta, dahash, x, y, out pindex);
		return RetObj;
	}


}
public partial class Ptaa
{
	// ptabasic.c (939, 1)
	// ptaaCreate(n) as Ptaa
	// ptaaCreate(l_int32) as PTAA *
	///  <summary>
	/// ptaaCreate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaCreate/*"/>
	///  <param name="n">[in] - initial number of ptrs</param>
	///   <returns>ptaa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Ptaa Create (int n)
	{
		Ptaa RetObj = _All.ptaaCreate(n);
		return RetObj;
	}

	// ptabasic.c (967, 1)
	// ptaaDestroy(pptaa) as Object
	// ptaaDestroy(PTAA **) as void
	///  <summary>
	/// ptaaDestroy()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaDestroy/*"/>
	///  <param name="pptaa">[in,out] - to be nulled</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref Ptaa pptaa)
	{
		_All.ptaaDestroy(ref pptaa);
	}

	// ptabasic.c (1004, 1)
	// ptaaAddPta(ptaa, pta, copyflag) as int
	// ptaaAddPta(PTAA *, PTA *, l_int32) as l_ok
	///  <summary>
	/// ptaaAddPta()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaAddPta/*"/>
	///  <param name="pta">[in] - to be added</param>
	///  <param name="copyflag">[in] - L_INSERT, L_COPY, L_CLONE</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddPta (Pta pta,
					   int copyflag)
	{
		int RetObj = _All.ptaaAddPta(this, pta, copyflag);
		return RetObj;
	}

	// ptabasic.c (1074, 1)
	// ptaaGetCount(ptaa) as int
	// ptaaGetCount(PTAA *) as l_int32
	///  <summary>
	/// ptaaGetCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaGetCount/*"/>
	///   <returns>count, or 0 if no ptaa</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCount ()
	{
		int RetObj = _All.ptaaGetCount(this);
		return RetObj;
	}

	// ptabasic.c (1094, 1)
	// ptaaGetPta(ptaa, index, accessflag) as Pta
	// ptaaGetPta(PTAA *, l_int32, l_int32) as PTA *
	///  <summary>
	/// ptaaGetPta()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaGetPta/*"/>
	///  <param name="index">[in] - to the i-th pta</param>
	///  <param name="accessflag">[in] - L_COPY or L_CLONE</param>
	///   <returns>pta, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pta GetPta (int index,
					   int accessflag)
	{
		Pta RetObj = _All.ptaaGetPta(this, index, accessflag);
		return RetObj;
	}

	// ptabasic.c (1125, 1)
	// ptaaGetPt(ptaa, ipta, jpt, px, py) as int
	// ptaaGetPt(PTAA *, l_int32, l_int32, l_float32 *, l_float32 *) as l_ok
	///  <summary>
	/// ptaaGetPt()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaGetPt/*"/>
	///  <param name="ipta">[in] - to the i-th pta</param>
	///  <param name="jpt">[in] - index to the j-th pt in the pta</param>
	///  <param name="px">[out][optional] - float x value</param>
	///  <param name="py">[out][optional] - float y value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetPt (int ipta,
					  int jpt,
					  out Single px,
					  out Single py)
	{
		int RetObj = _All.ptaaGetPt(this, ipta, jpt, out px, out py);
		return RetObj;
	}

	// ptabasic.c (1165, 1)
	// ptaaInitFull(ptaa, pta) as int
	// ptaaInitFull(PTAA *, PTA *) as l_ok
	///  <summary>
	/// ptaaInitFull()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaInitFull/*"/>
	///  <param name="pta">[in] - to be replicated into the entire ptr array</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int InitFull (Pta pta)
	{
		int RetObj = _All.ptaaInitFull(this, pta);
		return RetObj;
	}

	// ptabasic.c (1204, 1)
	// ptaaReplacePta(ptaa, index, pta) as int
	// ptaaReplacePta(PTAA *, l_int32, PTA *) as l_ok
	///  <summary>
	/// (1) Any existing pta is destroyed, and the input one
	/// is inserted in its place.<para/>
	///
	/// (2) If the index is invalid, return 1 (error)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaReplacePta/*"/>
	///  <param name="index">[in] - to the index-th pta</param>
	///  <param name="pta">[in] - insert and replace any existing one</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ReplacePta (int index,
						   Pta pta)
	{
		int RetObj = _All.ptaaReplacePta(this, index, pta);
		return RetObj;
	}

	// ptabasic.c (1235, 1)
	// ptaaAddPt(ptaa, ipta, x, y) as int
	// ptaaAddPt(PTAA *, l_int32, l_float32, l_float32) as l_ok
	///  <summary>
	/// ptaaAddPt()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaAddPt/*"/>
	///  <param name="ipta">[in] - to the i-th pta</param>
	///  <param name="x">[in] - ,y point coordinates</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddPt (int ipta,
					  Single x,
					  Single y)
	{
		int RetObj = _All.ptaaAddPt(this, ipta, x, y);
		return RetObj;
	}

	// ptabasic.c (1270, 1)
	// ptaaTruncate(ptaa) as int
	// ptaaTruncate(PTAA *) as l_ok
	///  <summary>
	/// (1) This identifies the largest index containing a pta that
	/// has any points within it, destroys all pta above that index,
	/// and resets the count.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaTruncate/*"/>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Truncate ()
	{
		int RetObj = _All.ptaaTruncate(this);
		return RetObj;
	}

	// ptabasic.c (1310, 1)
	// ptaaRead(filename) as Ptaa
	// ptaaRead(const char *) as PTAA *
	///  <summary>
	/// ptaaRead()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaRead/*"/>
	///  <param name="filename">[in] - </param>
	///   <returns>ptaa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Ptaa Read (String filename)
	{
		Ptaa RetObj = _All.ptaaRead(filename);
		return RetObj;
	}

	// ptabasic.c (1337, 1)
	// ptaaReadStream(fp) as Ptaa
	// ptaaReadStream(FILE *) as PTAA *
	///  <summary>
	/// ptaaReadStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>ptaa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Ptaa ReadStream (FILE fp)
	{
		Ptaa RetObj = _All.ptaaReadStream(fp);
		return RetObj;
	}

	// ptabasic.c (1377, 1)
	// ptaaReadMem(data, size) as Ptaa
	// ptaaReadMem(const l_uint8 *, size_t) as PTAA *
	///  <summary>
	/// ptaaReadMem()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaReadMem/*"/>
	///  <param name="data">[in] - serialization in ascii</param>
	///  <param name="size">[in] - of data in bytes can use strlen to get it</param>
	///   <returns>ptaa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Ptaa ReadMem (Byte[] data,
						 uint size)
	{
		Ptaa RetObj = _All.ptaaReadMem(data, size);
		return RetObj;
	}

	// ptabasic.c (1415, 1)
	// ptaaWriteDebug(filename, ptaa, type) as int
	// ptaaWriteDebug(const char *, PTAA *, l_int32) as l_ok
	///  <summary>
	/// (1) Debug version, intended for use in the library when writing
	/// to files in a temp directory with names that are compiled in.
	/// This is used instead of ptaaWrite() for all such library calls.<para/>
	///
	/// (2) The global variable LeptDebugOK defaults to 0, and can be set
	/// or cleared by the function setLeptDebugOK().
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaWriteDebug/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="type">[in] - 0 for float values 1 for integer values</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteDebug (String filename,
						   int type)
	{
		int RetObj = _All.ptaaWriteDebug(filename, this, type);
		return RetObj;
	}

	// ptabasic.c (1439, 1)
	// ptaaWrite(filename, ptaa, type) as int
	// ptaaWrite(const char *, PTAA *, l_int32) as l_ok
	///  <summary>
	/// ptaaWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaWrite/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="type">[in] - 0 for float values 1 for integer values</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String filename,
					  int type)
	{
		int RetObj = _All.ptaaWrite(filename, this, type);
		return RetObj;
	}

	// ptabasic.c (1472, 1)
	// ptaaWriteStream(fp, ptaa, type) as int
	// ptaaWriteStream(FILE *, PTAA *, l_int32) as l_ok
	///  <summary>
	/// ptaaWriteStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaWriteStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="type">[in] - 0 for float values 1 for integer values</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp,
							int type)
	{
		int RetObj = _All.ptaaWriteStream(fp, this, type);
		return RetObj;
	}

	// ptabasic.c (1514, 1)
	// ptaaWriteMem(pdata, psize, ptaa, type) as int
	// ptaaWriteMem(l_uint8 **, size_t *, PTAA *, l_int32) as l_ok
	///  <summary>
	/// (1) Serializes a ptaa in memory and puts the result in a buffer.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaWriteMem/*"/>
	///  <param name="pdata">[out] - data of serialized ptaa ascii</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="type">[in] - 0 for float values 1 for integer values</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMem (out Byte[] pdata,
						 out uint psize,
						 int type)
	{
		int RetObj = _All.ptaaWriteMem(out pdata, out psize, this, type);
		return RetObj;
	}

	// ptafunc1.c (202, 1)
	// ptaaJoin(ptaad, ptaas, istart, iend) as int
	// ptaaJoin(PTAA *, PTAA *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) istart  is smaller 0 is taken to mean 'read from the start' (istart = 0)<para/>
	///
	/// (2) iend  is smaller 0 means 'read to the end'<para/>
	///
	/// (3) if ptas == NULL, this is a no-op
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaJoin/*"/>
	///  <param name="ptaad">[in] - dest ptaa add to this one</param>
	///  <param name="ptaas">[in] - source ptaa add from this one</param>
	///  <param name="istart">[in] - starting index in ptaas</param>
	///  <param name="iend">[in] - ending index in ptaas use -1 to cat all</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Join (Ptaa ptaad,
					 Ptaa ptaas,
					 int istart,
					 int iend)
	{
		int RetObj = _All.ptaaJoin(ptaad, ptaas, istart, iend);
		return RetObj;
	}

	// ptafunc1.c (2036, 1)
	// ptaaGetBoundaryPixels(pixs, type, connectivity, pboxa, ppixa) as Ptaa
	// ptaaGetBoundaryPixels(PIX *, l_int32, l_int32, BOXA **, PIXA **) as PTAA *
	///  <summary>
	/// (1) This generates a ptaa of either fg or bg boundary pixels,
	/// where each pta has the boundary pixels for a connected
	/// component.<para/>
	///
	/// (2) We can't simply find all the boundary pixels and then select
	/// those within the bounding box of each component, because
	/// bounding boxes can overlap.  It is necessary to extract and
	/// dilate or erode each component separately.  Note also that
	/// special handling is required for bg pixels when the
	/// component touches the pix boundary.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaGetBoundaryPixels/*"/>
	///  <param name="pixs">[in] - 1 bpp</param>
	///  <param name="type">[in] - L_BOUNDARY_FG, L_BOUNDARY_BG</param>
	///  <param name="connectivity">[in] - 4 or 8</param>
	///  <param name="pboxa">[out][optional] - bounding boxes of the c.c.</param>
	///  <param name="ppixa">[out][optional] - pixa of the c.c.</param>
	///   <returns>ptaa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Ptaa GetBoundaryPixels (Pix pixs,
								   int type,
								   int connectivity,
								   out Boxa pboxa,
								   out Pixa ppixa)
	{
		Ptaa RetObj = _All.ptaaGetBoundaryPixels(pixs, type, connectivity, out pboxa, out ppixa);
		return RetObj;
	}

	// ptafunc1.c (2119, 1)
	// ptaaIndexLabeledPixels(pixs, pncc) as Ptaa
	// ptaaIndexLabeledPixels(PIX *, l_int32 *) as PTAA *
	///  <summary>
	/// (1) The pixel values in %pixs are the index of the connected component
	/// to which the pixel belongs %pixs is typically generated from
	/// a 1 bpp pix by pixConnCompTransform().  Background pixels in
	/// the generating 1 bpp pix are represented in %pixs by 0.
	/// We do not check that the pixel values are correctly labelled.<para/>
	///
	/// (2) Each pta in the returned ptaa gives the pixel locations
	/// correspnding to a connected component, with the label of each
	/// given by the index of the pta into the ptaa.<para/>
	///
	/// (3) Initialize with the first pta in ptaa being empty and
	/// representing the background value (index 0) in the pix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaIndexLabeledPixels/*"/>
	///  <param name="pixs">[in] - 32 bpp, of indices of c.c.</param>
	///  <param name="pncc">[out][optional] - number of connected components</param>
	///   <returns>ptaa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Ptaa IndexLabeledPixels (Pix pixs,
									out int pncc)
	{
		Ptaa RetObj = _All.ptaaIndexLabeledPixels(pixs, out pncc);
		return RetObj;
	}

	// ptafunc2.c (218, 1)
	// ptaaSortByIndex(ptaas, naindex) as Ptaa
	// ptaaSortByIndex(PTAA *, NUMA *) as PTAA *
	///  <summary>
	/// ptaaSortByIndex()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/ptaaSortByIndex/*"/>
	///  <param name="ptaas">[in] - </param>
	///  <param name="naindex">[in] - na that maps from the new ptaa to the input ptaa</param>
	///   <returns>ptaad sorted, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Ptaa SortByIndex (Ptaa ptaas,
							 Numa naindex)
	{
		Ptaa RetObj = _All.ptaaSortByIndex(ptaas, naindex);
		return RetObj;
	}


}
public partial class FPix
{
	// fpix1.c (1696, 1)
	// fpixRead(filename) as FPix
	// fpixRead(const char *) as FPIX *
	///  <summary>
	/// fpixRead()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixRead/*"/>
	///  <param name="filename">[in] - </param>
	// CreateAdditiveFunction: Constructor
	public FPix (String filename)
	{
		FPix RetObj = _All.fpixRead(filename);
		Pointer = RetObj.Pointer;
	}

	// fpix1.c (149, 1)
	// fpixCreate(width, height) as FPix
	// fpixCreate(l_int32, l_int32) as FPIX *
	///  <summary>
	/// (1) Makes a FPix of specified size, with the data array
	/// allocated and initialized to 0.<para/>
	///
	/// (2) The number of pixels must be less than 2^29.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixCreate/*"/>
	///  <param name="width">[in] - </param>
	///  <param name="height">[in] - </param>
	// CreateAdditiveFunction: Constructor
	public FPix (int width,
				 int height)
	{
		FPix RetObj = _All.fpixCreate(width, height);
		Pointer = RetObj.Pointer;
	}

	// fpix1.c (199, 1)
	// fpixCreateTemplate(fpixs) as FPix
	// fpixCreateTemplate(FPIX *) as FPIX *
	///  <summary>
	/// (1) Makes a FPix of the same size as the input FPix, with the
	/// data array allocated and initialized to 0.<para/>
	///
	/// (2) Copies the resolution.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixCreateTemplate/*"/>
	// CreateAdditiveFunction: Constructor
	public FPix ()
	{
		FPix RetObj = _All.fpixCreateTemplate(this);
		Pointer = RetObj.Pointer;
	}

	// convolve.c (2195, 1)
	// fpixConvolve(fpixs, kel, normflag) as FPix
	// fpixConvolve(FPIX *, L_KERNEL *, l_int32) as FPIX *
	///  <summary>
	/// (1) This gives a float convolution with an arbitrary kernel.<para/>
	///
	/// (2) If normflag == 1, the result is normalized by scaling all
	/// kernel values for a unit sum.  If the sum of kernel values
	/// is very close to zero, the kernel can not be normalized and
	/// the convolution will not be performed.  A warning is issued.<para/>
	///
	/// (3) With the FPix, there are no issues about negative
	/// array or kernel values.  The convolution is performed
	/// with single precision arithmetic.<para/>
	///
	/// (4) To get a subsampled output, call l_setConvolveSampling().
	/// The time to make a subsampled output is reduced by the
	/// product of the sampling factors.<para/>
	///
	/// (5) This uses a mirrored border to avoid special casing on
	/// the boundaries.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixConvolve/*"/>
	///  <param name="kel">[in] - kernel</param>
	///  <param name="normflag">[in] - 1 to normalize kernel to unit sum 0 otherwise</param>
	///   <returns>fpixd 32 bit float array</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix Convolve (L_Kernel kel,
						  int normflag)
	{
		FPix RetObj = _All.fpixConvolve(this, kel, normflag);
		return RetObj;
	}

	// convolve.c (2289, 1)
	// fpixConvolveSep(fpixs, kelx, kely, normflag) as FPix
	// fpixConvolveSep(FPIX *, L_KERNEL *, L_KERNEL *, l_int32) as FPIX *
	///  <summary>
	/// (1) This does a convolution with a separable kernel that is
	/// is a sequence of convolutions in x and y.  The two
	/// one-dimensional kernel components must be input separately
	/// the full kernel is the product of these components.
	/// The support for the full kernel is thus a rectangular region.<para/>
	///
	/// (2) The normflag parameter is used as in fpixConvolve().<para/>
	///
	/// (3) Warning: if you use l_setConvolveSampling() to get a
	/// subsampled output, and the sampling factor is larger than
	/// the kernel half-width, it is faster to use the non-separable
	/// version pixConvolve().  This is because the first convolution
	/// here must be done on every raster line, regardless of the
	/// vertical sampling factor.  If the sampling factor is smaller
	/// than kernel half-width, it's faster to use the separable
	/// convolution.<para/>
	///
	/// (4) This uses mirrored borders to avoid special casing on
	/// the boundaries.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixConvolveSep/*"/>
	///  <param name="kelx">[in] - x-dependent kernel</param>
	///  <param name="kely">[in] - y-dependent kernel</param>
	///  <param name="normflag">[in] - 1 to normalize kernel to unit sum 0 otherwise</param>
	///   <returns>fpixd 32 bit float array</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix ConvolveSep (L_Kernel kelx,
							 L_Kernel kely,
							 int normflag)
	{
		FPix RetObj = _All.fpixConvolveSep(this, kelx, kely, normflag);
		return RetObj;
	}

	// fpix1.c (229, 1)
	// fpixClone(fpix) as FPix
	// fpixClone(FPIX *) as FPIX *
	///  <summary>
	/// (1) See pixClone() for definition and usage.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixClone/*"/>
	///  <param name="fpix">[in] - </param>
	///   <returns>same fpix ptr, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix Clone (FPix fpix)
	{
		FPix RetObj = _All.fpixClone(fpix);
		return RetObj;
	}

	// fpix1.c (272, 1)
	// fpixCopy(fpixd, fpixs) as FPix
	// fpixCopy(FPIX *, FPIX *) as FPIX *
	///  <summary>
	/// (1) There are three cases:
	/// (a) fpixd == null  (makes a new fpix refcount = 1)
	/// (b) fpixd == fpixs  (no-op)
	/// (c) fpixd != fpixs  (data copy no change in refcount)
	/// If the refcount of fpixd  is greater  1, case (c) will side-effect
	/// these handles.<para/>
	///
	/// (2) The general pattern of use is:
	/// fpixd = fpixCopy(fpixd, fpixs)
	/// This will work for all three cases.
	/// For clarity when the case is known, you can use:
	/// (a) fpixd = fpixCopy(NULL, fpixs)
	/// (c) fpixCopy(fpixd, fpixs)<para/>
	///
	/// (3) For case (c), we check if fpixs and fpixd are the same size.
	/// If so, the data is copied directly.
	/// Otherwise, the data is reallocated to the correct size
	/// and the copy proceeds.  The refcount of fpixd is unchanged.<para/>
	///
	/// (4) This operation, like all others that may involve a pre-existing
	/// fpixd, will side-effect any existing clones of fpixd.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixCopy/*"/>
	///  <param name="fpixd">[in][optional] - can be null, or equal to fpixs, or different from fpixs</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix Copy (FPix fpixd)
	{
		FPix RetObj = _All.fpixCopy(fpixd, this);
		return RetObj;
	}

	// fpix1.c (326, 1)
	// fpixResizeImageData(fpixd, fpixs) as int
	// fpixResizeImageData(FPIX *, FPIX *) as l_ok
	///  <summary>
	/// (1) If the data sizes differ, this destroys the existing
	/// data in fpixd and allocates a new, uninitialized, data array
	/// of the same size as the data in fpixs.  Otherwise, this
	/// doesn't do anything.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixResizeImageData/*"/>
	///  <param name="fpixd">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ResizeImageData (FPix fpixd)
	{
		int RetObj = _All.fpixResizeImageData(fpixd, this);
		return RetObj;
	}

	// fpix1.c (369, 1)
	// fpixDestroy(pfpix) as Object
	// fpixDestroy(FPIX **) as void
	///  <summary>
	/// (1) Decrements the ref count and, if 0, destroys the fpix.<para/>
	///
	/// (2) Always nulls the input ptr.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixDestroy/*"/>
	///  <param name="pfpix">[in,out] - will be nulled</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref FPix pfpix)
	{
		_All.fpixDestroy(ref pfpix);
	}

	// fpix1.c (408, 1)
	// fpixGetDimensions(fpix, pw, ph) as int
	// fpixGetDimensions(FPIX *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// fpixGetDimensions()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixGetDimensions/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="pw">[out][optional] - each can be null</param>
	///  <param name="ph">[out][optional] - each can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetDimensions (FPix fpix,
							  out int pw,
							  out int ph)
	{
		int RetObj = _All.fpixGetDimensions(fpix, out pw, out ph);
		return RetObj;
	}

	// fpix1.c (434, 1)
	// fpixSetDimensions(fpix, w, h) as int
	// fpixSetDimensions(FPIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// fpixSetDimensions()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixSetDimensions/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="w">[in] - </param>
	///  <param name="h">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetDimensions (FPix fpix,
							  int w,
							  int h)
	{
		int RetObj = _All.fpixSetDimensions(fpix, w, h);
		return RetObj;
	}

	// fpix1.c (455, 1)
	// fpixGetWpl(fpix) as int
	// fpixGetWpl(FPIX *) as l_int32
	///  <summary>
	/// fpixGetWpl()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixGetWpl/*"/>
	///  <param name="fpix">[in] - </param>
	///   <returns>wpl, or UNDEF on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetWpl (FPix fpix)
	{
		int RetObj = _All.fpixGetWpl(fpix);
		return RetObj;
	}

	// fpix1.c (473, 1)
	// fpixSetWpl(fpix, wpl) as int
	// fpixSetWpl(FPIX *, l_int32) as l_ok
	///  <summary>
	/// fpixSetWpl()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixSetWpl/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="wpl">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetWpl (FPix fpix,
					   int wpl)
	{
		int RetObj = _All.fpixSetWpl(fpix, wpl);
		return RetObj;
	}

	// fpix1.c (493, 1)
	// fpixGetRefcount(fpix) as int
	// fpixGetRefcount(FPIX *) as l_int32
	///  <summary>
	/// fpixGetRefcount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixGetRefcount/*"/>
	///  <param name="fpix">[in] - </param>
	///   <returns>refcount, or UNDEF on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRefcount (FPix fpix)
	{
		int RetObj = _All.fpixGetRefcount(fpix);
		return RetObj;
	}

	// fpix1.c (511, 1)
	// fpixChangeRefcount(fpix, delta) as int
	// fpixChangeRefcount(FPIX *, l_int32) as l_ok
	///  <summary>
	/// fpixChangeRefcount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixChangeRefcount/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="delta">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ChangeRefcount (FPix fpix,
							   int delta)
	{
		int RetObj = _All.fpixChangeRefcount(fpix, delta);
		return RetObj;
	}

	// fpix1.c (532, 1)
	// fpixGetResolution(fpix, pxres, pyres) as int
	// fpixGetResolution(FPIX *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// fpixGetResolution()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixGetResolution/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="pxres">[out][optional] - x and y resolution</param>
	///  <param name="pyres">[out][optional] - x and y resolution</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetResolution (FPix fpix,
							  out int pxres,
							  out int pyres)
	{
		int RetObj = _All.fpixGetResolution(fpix, out pxres, out pyres);
		return RetObj;
	}

	// fpix1.c (554, 1)
	// fpixSetResolution(fpix, xres, yres) as int
	// fpixSetResolution(FPIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// fpixSetResolution()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixSetResolution/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="xres">[in] - x and y resolution</param>
	///  <param name="yres">[in] - x and y resolution</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetResolution (FPix fpix,
							  int xres,
							  int yres)
	{
		int RetObj = _All.fpixSetResolution(fpix, xres, yres);
		return RetObj;
	}

	// fpix1.c (576, 1)
	// fpixCopyResolution(fpixd, fpixs) as int
	// fpixCopyResolution(FPIX *, FPIX *) as l_ok
	///  <summary>
	/// fpixCopyResolution()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixCopyResolution/*"/>
	///  <param name="fpixd">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CopyResolution (FPix fpixd)
	{
		int RetObj = _All.fpixCopyResolution(fpixd, this);
		return RetObj;
	}

	// fpix1.c (598, 1)
	// fpixGetData(fpix) as Single[]
	// fpixGetData(FPIX *) as l_float32 *
	///  <summary>
	/// fpixGetData()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixGetData/*"/>
	///  <param name="fpix">[in] - </param>
	///   <returns>ptr FPix::data, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Single[] GetData (FPix fpix)
	{
		Single[] RetObj = _All.fpixGetData(fpix);
		return RetObj;
	}

	// fpix1.c (616, 1)
	// fpixSetData(fpix, data) as int
	// fpixSetData(FPIX *, l_float32 *) as l_ok
	///  <summary>
	/// fpixSetData()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixSetData/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="data">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetData (FPix fpix,
						Single[] data)
	{
		int RetObj = _All.fpixSetData(fpix, data);
		return RetObj;
	}

	// fpix1.c (638, 1)
	// fpixGetPixel(fpix, x, y, pval) as int
	// fpixGetPixel(FPIX *, l_int32, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// fpixGetPixel()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixGetPixel/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="x">[in] - ,y pixel coords</param>
	///  <param name="pval">[out] - pixel value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetPixel (FPix fpix,
						 int x,
						 int y,
						 out Single pval)
	{
		int RetObj = _All.fpixGetPixel(fpix, x, y, out pval);
		return RetObj;
	}

	// fpix1.c (673, 1)
	// fpixSetPixel(fpix, x, y, val) as int
	// fpixSetPixel(FPIX *, l_int32, l_int32, l_float32) as l_ok
	///  <summary>
	/// fpixSetPixel()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixSetPixel/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="x">[in] - ,y pixel coords</param>
	///  <param name="val">[in] - pixel value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetPixel (FPix fpix,
						 int x,
						 int y,
						 Single val)
	{
		int RetObj = _All.fpixSetPixel(fpix, x, y, val);
		return RetObj;
	}

	// fpix1.c (1723, 1)
	// fpixReadStream(fp) as FPix
	// fpixReadStream(FILE *) as FPIX *
	///  <summary>
	/// fpixReadStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>fpix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix ReadStream (FILE fp)
	{
		FPix RetObj = _All.fpixReadStream(fp);
		return RetObj;
	}

	// fpix1.c (1776, 1)
	// fpixReadMem(data, size) as FPix
	// fpixReadMem(const l_uint8 *, size_t) as FPIX *
	///  <summary>
	/// fpixReadMem()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixReadMem/*"/>
	///  <param name="data">[in] - of serialized fpix</param>
	///  <param name="size">[in] - of data in bytes</param>
	///   <returns>fpix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix ReadMem (Byte[] data,
						 uint size)
	{
		FPix RetObj = _All.fpixReadMem(data, size);
		return RetObj;
	}

	// fpix1.c (1804, 1)
	// fpixWrite(filename, fpix) as int
	// fpixWrite(const char *, FPIX *) as l_ok
	///  <summary>
	/// fpixWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixWrite/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="fpix">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String filename,
					  FPix fpix)
	{
		int RetObj = _All.fpixWrite(filename, fpix);
		return RetObj;
	}

	// fpix1.c (1835, 1)
	// fpixWriteStream(fp, fpix) as int
	// fpixWriteStream(FILE *, FPIX *) as l_ok
	///  <summary>
	/// fpixWriteStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixWriteStream/*"/>
	///  <param name="fp">[in] - file stream opened for "wb"</param>
	///  <param name="fpix">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp,
							FPix fpix)
	{
		int RetObj = _All.fpixWriteStream(fp, fpix);
		return RetObj;
	}

	// fpix1.c (1881, 1)
	// fpixWriteMem(pdata, psize, fpix) as int
	// fpixWriteMem(l_uint8 **, size_t *, FPIX *) as l_ok
	///  <summary>
	/// (1) Serializes a fpix in memory and puts the result in a buffer.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixWriteMem/*"/>
	///  <param name="pdata">[out] - data of serialized fpix</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="fpix">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMem (out Byte[] pdata,
						 out uint psize,
						 FPix fpix)
	{
		int RetObj = _All.fpixWriteMem(out pdata, out psize, fpix);
		return RetObj;
	}

	// fpix1.c (1941, 1)
	// fpixEndianByteSwap(fpixd, fpixs) as FPix
	// fpixEndianByteSwap(FPIX *, FPIX *) as FPIX *
	///  <summary>
	/// (1) On big-endian hardware, this does byte-swapping on each of
	/// the 4-byte floats in the fpix data.  On little-endians,
	/// the data is unchanged.  This is used for serialization
	/// of fpix the data is serialized in little-endian byte
	/// order because most hardware is little-endian.<para/>
	///
	/// (2) The operation can be either in-place or, if fpixd == NULL,
	/// a new fpix is made.  If not in-place, caller must catch
	/// the returned pointer.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixEndianByteSwap/*"/>
	///  <param name="fpixd">[in] - can be equal to fpixs or NULL</param>
	///   <returns>fpixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix EndianByteSwap (FPix fpixd)
	{
		FPix RetObj = _All.fpixEndianByteSwap(fpixd, this);
		return RetObj;
	}

	// fpix1.c (2297, 1)
	// fpixPrintStream(fp, fpix, factor) as int
	// fpixPrintStream(FILE *, FPIX *, l_int32) as l_ok
	///  <summary>
	/// (1) Subsampled printout of fpix for debugging.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixPrintStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///  <param name="fpix">[in] - </param>
	///  <param name="factor">[in] - subsampled</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int PrintStream (FILE fp,
							FPix fpix,
							int factor)
	{
		int RetObj = _All.fpixPrintStream(fp, fpix, factor);
		return RetObj;
	}

	// fpix2.c (318, 1)
	// fpixConvertToPix(fpixs, outdepth, negvals, errorflag) as Pix
	// fpixConvertToPix(FPIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Use %outdepth = 0 to programmatically determine the
	/// output depth.  If no values are greater than 255,
	/// it will set outdepth = 8 otherwise to 16 or 32.<para/>
	///
	/// (2) Because we are converting a float to an unsigned int
	/// with a specified dynamic range (8, 16 or 32 bits), errors
	/// can occur.  If errorflag == TRUE, output the number
	/// of values out of range, both negative and positive.<para/>
	///
	/// (3) If a pixel value is positive and out of range, clip to
	/// the maximum value represented at the outdepth of 8, 16
	/// or 32 bits.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixConvertToPix/*"/>
	///  <param name="outdepth">[in] - 0, 8, 16 or 32 bpp</param>
	///  <param name="negvals">[in] - L_CLIP_TO_ZERO, L_TAKE_ABSVAL</param>
	///  <param name="errorflag">[in] - 1 to output error stats 0 otherwise</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertToPix (int outdepth,
							 int negvals,
							 int errorflag)
	{
		Pix RetObj = _All.fpixConvertToPix(this, outdepth, negvals, errorflag);
		return RetObj;
	}

	// fpix2.c (422, 1)
	// fpixDisplayMaxDynamicRange(fpixs) as Pix
	// fpixDisplayMaxDynamicRange(FPIX *) as PIX *
	///  <summary>
	/// fpixDisplayMaxDynamicRange()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixDisplayMaxDynamicRange/*"/>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayMaxDynamicRange ()
	{
		Pix RetObj = _All.fpixDisplayMaxDynamicRange(this);
		return RetObj;
	}

	// fpix2.c (479, 1)
	// fpixConvertToDPix(fpix) as DPix
	// fpixConvertToDPix(FPIX *) as DPIX *
	///  <summary>
	/// fpixConvertToDPix()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixConvertToDPix/*"/>
	///  <param name="fpix">[in] - </param>
	///   <returns>dpix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public DPix ConvertToDPix (FPix fpix)
	{
		DPix RetObj = _All.fpixConvertToDPix(fpix);
		return RetObj;
	}

	// fpix2.c (689, 1)
	// fpixGetMin(fpix, pminval, pxminloc, pyminloc) as int
	// fpixGetMin(FPIX *, l_float32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// fpixGetMin()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixGetMin/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="pminval">[out][optional] - min value</param>
	///  <param name="pxminloc">[out][optional] - x location of min</param>
	///  <param name="pyminloc">[out][optional] - y location of min</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMin (FPix fpix,
					   out Single pminval,
					   out int pxminloc,
					   out int pyminloc)
	{
		int RetObj = _All.fpixGetMin(fpix, out pminval, out pxminloc, out pyminloc);
		return RetObj;
	}

	// fpix2.c (742, 1)
	// fpixGetMax(fpix, pmaxval, pxmaxloc, pymaxloc) as int
	// fpixGetMax(FPIX *, l_float32 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// fpixGetMax()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixGetMax/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="pmaxval">[out][optional] - max value</param>
	///  <param name="pxmaxloc">[out][optional] - x location of max</param>
	///  <param name="pymaxloc">[out][optional] - y location of max</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMax (FPix fpix,
					   out Single pmaxval,
					   out int pxmaxloc,
					   out int pymaxloc)
	{
		int RetObj = _All.fpixGetMax(fpix, out pmaxval, out pxmaxloc, out pymaxloc);
		return RetObj;
	}

	// fpix2.c (915, 1)
	// fpixScaleByInteger(fpixs, factor) as FPix
	// fpixScaleByInteger(FPIX *, l_int32) as FPIX *
	///  <summary>
	/// (1) The width wd of fpixd is related to ws of fpixs by:
	/// wd = factor  (ws - 1) + 1 (and ditto for the height)
	/// We avoid special-casing boundary pixels in the interpolation
	/// by constructing fpixd by inserting (factor - 1) interpolated
	/// pixels between each pixel in fpixs.  Then
	/// wd = ws + (ws - 1)  (factor - 1)  (same as above)
	/// This also has the advantage that if we subsample by %factor,
	/// throwing out all the interpolated pixels, we regain the
	/// original low resolution fpix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixScaleByInteger/*"/>
	///  <param name="factor">[in] - scaling factor</param>
	///   <returns>fpixd interpolated result, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix ScaleByInteger (int factor)
	{
		FPix RetObj = _All.fpixScaleByInteger(this, factor);
		return RetObj;
	}

	// fpix2.c (1104, 1)
	// fpixLinearCombination(fpixd, fpixs1, fpixs2, a, b) as FPix
	// fpixLinearCombination(FPIX *, FPIX *, FPIX *, l_float32, l_float32) as FPIX *
	///  <summary>
	/// (1) Computes pixelwise linear combination: a  src1 + b  src2<para/>
	///
	/// (2) Alignment is to UL corner.<para/>
	///
	/// (3) There are 3 cases.  The result can go to a new dest,
	/// in-place to fpixs1, or to an existing input dest:
	/// fpixd == null: (src1 + src2) to new fpixd
	/// fpixd == fpixs1:  (src1 + src2) to src1  (in-place)
	/// fpixd != fpixs1: (src1 + src2) to input fpixd<para/>
	///
	/// (4) fpixs2 must be different from both fpixd and fpixs1.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixLinearCombination/*"/>
	///  <param name="fpixd">[in][optional] - this can be null, equal to fpixs1, or different from fpixs1</param>
	///  <param name="fpixs1">[in] - can be == to fpixd</param>
	///  <param name="fpixs2">[in] - </param>
	///  <param name="a">[in] - multiplication factors on fpixs1 and fpixs2, rsp.</param>
	///  <param name="b">[in] - multiplication factors on fpixs1 and fpixs2, rsp.</param>
	///   <returns>fpixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix LinearCombination (FPix fpixs1,
								   FPix fpixs2,
								   Single a,
								   Single b,
								   FPix fpixd)
	{
		FPix RetObj = _All.fpixLinearCombination(fpixd, fpixs1, fpixs2, a, b);
		return RetObj;
	}

	// fpix2.c (1163, 1)
	// fpixAddMultConstant(fpix, addc, multc) as int
	// fpixAddMultConstant(FPIX *, l_float32, l_float32) as l_ok
	///  <summary>
	/// (1) This is an in-place operation.<para/>
	///
	/// (2) It can be used to multiply each pixel by a constant,
	/// and also to add a constant to each pixel.  Multiplication
	/// is done first.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixAddMultConstant/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="addc">[in] - use 0.0 to skip the operation</param>
	///  <param name="multc">[in] - use 1.0 to skip the operation</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddMultConstant (FPix fpix,
								Single addc,
								Single multc)
	{
		int RetObj = _All.fpixAddMultConstant(fpix, addc, multc);
		return RetObj;
	}

	// fpix2.c (1329, 1)
	// fpixSetAllArbitrary(fpix, inval) as int
	// fpixSetAllArbitrary(FPIX *, l_float32) as l_ok
	///  <summary>
	/// fpixSetAllArbitrary()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixSetAllArbitrary/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="inval">[in] - to set at each pixel</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetAllArbitrary (FPix fpix,
								Single inval)
	{
		int RetObj = _All.fpixSetAllArbitrary(fpix, inval);
		return RetObj;
	}

	// fpix2.c (1399, 1)
	// fpixAddBorder(fpixs, left, right, top, bot) as FPix
	// fpixAddBorder(FPIX *, l_int32, l_int32, l_int32, l_int32) as FPIX *
	///  <summary>
	/// (1) Adds border of '0' 32-bit pixels
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixAddBorder/*"/>
	///  <param name="left">[in] - pixels on each side to be added</param>
	///  <param name="right">[in] - pixels on each side to be added</param>
	///  <param name="top">[in] - pixels on each side to be added</param>
	///  <param name="bot">[in] - pixels on each side to be added</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix AddBorder (int left,
						   int right,
						   int top,
						   int bot)
	{
		FPix RetObj = _All.fpixAddBorder(this, left, right, top, bot);
		return RetObj;
	}

	// fpix2.c (1435, 1)
	// fpixRemoveBorder(fpixs, left, right, top, bot) as FPix
	// fpixRemoveBorder(FPIX *, l_int32, l_int32, l_int32, l_int32) as FPIX *
	///  <summary>
	/// fpixRemoveBorder()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixRemoveBorder/*"/>
	///  <param name="left">[in] - pixels on each side to be removed</param>
	///  <param name="right">[in] - pixels on each side to be removed</param>
	///  <param name="top">[in] - pixels on each side to be removed</param>
	///  <param name="bot">[in] - pixels on each side to be removed</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix RemoveBorder (int left,
							  int right,
							  int top,
							  int bot)
	{
		FPix RetObj = _All.fpixRemoveBorder(this, left, right, top, bot);
		return RetObj;
	}

	// fpix2.c (1479, 1)
	// fpixAddMirroredBorder(fpixs, left, right, top, bot) as FPix
	// fpixAddMirroredBorder(FPIX *, l_int32, l_int32, l_int32, l_int32) as FPIX *
	///  <summary>
	/// (1) See pixAddMirroredBorder() for situations of usage.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixAddMirroredBorder/*"/>
	///  <param name="left">[in] - pixels on each side to be added</param>
	///  <param name="right">[in] - pixels on each side to be added</param>
	///  <param name="top">[in] - pixels on each side to be added</param>
	///  <param name="bot">[in] - pixels on each side to be added</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix AddMirroredBorder (int left,
								   int right,
								   int top,
								   int bot)
	{
		FPix RetObj = _All.fpixAddMirroredBorder(this, left, right, top, bot);
		return RetObj;
	}

	// fpix2.c (1526, 1)
	// fpixAddContinuedBorder(fpixs, left, right, top, bot) as FPix
	// fpixAddContinuedBorder(FPIX *, l_int32, l_int32, l_int32, l_int32) as FPIX *
	///  <summary>
	/// (1) This adds pixels on each side whose values are equal to
	/// the value on the closest boundary pixel.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixAddContinuedBorder/*"/>
	///  <param name="left">[in] - pixels on each side to be added</param>
	///  <param name="right">[in] - pixels on each side to be added</param>
	///  <param name="top">[in] - pixels on each side to be added</param>
	///  <param name="bot">[in] - pixels on each side to be added</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix AddContinuedBorder (int left,
									int right,
									int top,
									int bot)
	{
		FPix RetObj = _All.fpixAddContinuedBorder(this, left, right, top, bot);
		return RetObj;
	}

	// fpix2.c (1571, 1)
	// fpixAddSlopeBorder(fpixs, left, right, top, bot) as FPix
	// fpixAddSlopeBorder(FPIX *, l_int32, l_int32, l_int32, l_int32) as FPIX *
	///  <summary>
	/// (1) This adds pixels on each side whose values have a normal
	/// derivative equal to the normal derivative at the boundary
	/// of fpixs.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixAddSlopeBorder/*"/>
	///  <param name="left">[in] - pixels on each side to be added</param>
	///  <param name="right">[in] - pixels on each side to be added</param>
	///  <param name="top">[in] - pixels on each side to be added</param>
	///  <param name="bot">[in] - pixels on each side to be added</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix AddSlopeBorder (int left,
								int right,
								int top,
								int bot)
	{
		FPix RetObj = _All.fpixAddSlopeBorder(this, left, right, top, bot);
		return RetObj;
	}

	// fpix2.c (1660, 1)
	// fpixRasterop(fpixd, dx, dy, dw, dh, fpixs, sx, sy) as int
	// fpixRasterop(FPIX *, l_int32, l_int32, l_int32, l_int32, FPIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// (1) This is similar in structure to pixRasterop(), except
	/// it only allows copying from the source into the destination.
	/// For that reason, no op code is necessary.  Additionally,
	/// all pixels are 32 bit words (float values), which makes
	/// the copy very simple.<para/>
	///
	/// (2) Clipping of both src and dest fpix are done automatically.<para/>
	///
	/// (3) This allows in-place copying, without checking to see if
	/// the result is valid:  use for in-place with caution!
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixRasterop/*"/>
	///  <param name="fpixd">[in] - dest fpix</param>
	///  <param name="dx">[in] - x val of UL corner of dest rectangle</param>
	///  <param name="dy">[in] - y val of UL corner of dest rectangle</param>
	///  <param name="dw">[in] - width of dest rectangle</param>
	///  <param name="dh">[in] - height of dest rectangle</param>
	///  <param name="sx">[in] - x val of UL corner of src rectangle</param>
	///  <param name="sy">[in] - y val of UL corner of src rectangle</param>
	///   <returns>0 if OK 1 on error.</returns>
	// CreateAdditiveFunction: Function/Else
	public int Rasterop (FPix fpixd,
						 int dx,
						 int dy,
						 int dw,
						 int dh,
						 int sx,
						 int sy)
	{
		int RetObj = _All.fpixRasterop(fpixd, dx, dy, dw, dh, this, sx, sy);
		return RetObj;
	}

	// fpix2.c (1760, 1)
	// fpixRotateOrth(fpixs, quads) as FPix
	// fpixRotateOrth(FPIX *, l_int32) as FPIX *
	///  <summary>
	/// fpixRotateOrth()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixRotateOrth/*"/>
	///  <param name="quads">[in] - 0-3 number of 90 degree cw rotations</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix RotateOrth (int quads)
	{
		FPix RetObj = _All.fpixRotateOrth(this, quads);
		return RetObj;
	}

	// fpix2.c (1806, 1)
	// fpixRotate180(fpixd, fpixs) as FPix
	// fpixRotate180(FPIX *, FPIX *) as FPIX *
	///  <summary>
	/// (1) This does a 180 rotation of the image about the center,
	/// which is equivalent to a left-right flip about a vertical
	/// line through the image center, followed by a top-bottom
	/// flip about a horizontal line through the image center.<para/>
	///
	/// (2) There are 3 cases for input:
	/// (a) fpixd == null (creates a new fpixd)
	/// (b) fpixd == fpixs (in-place operation)
	/// (c) fpixd != fpixs (existing fpixd)<para/>
	///
	/// (3) For clarity, use these three patterns, respectively:
	/// (a) fpixd = fpixRotate180(NULL, fpixs)
	/// (b) fpixRotate180(fpixs, fpixs)
	/// (c) fpixRotate180(fpixd, fpixs)
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixRotate180/*"/>
	///  <param name="fpixd">[in][optional] - can be null, equal to fpixs, or different from fpixs</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix Rotate180 (FPix fpixd)
	{
		FPix RetObj = _All.fpixRotate180(fpixd, this);
		return RetObj;
	}

	// fpix2.c (1839, 1)
	// fpixRotate90(fpixs, direction) as FPix
	// fpixRotate90(FPIX *, l_int32) as FPIX *
	///  <summary>
	/// (1) This does a 90 degree rotation of the image about the center,
	/// either cw or ccw, returning a new pix.<para/>
	///
	/// (2) The direction must be either 1 (cw) or -1 (ccw).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixRotate90/*"/>
	///  <param name="direction">[in] - 1 = clockwise,  -1 = counter-clockwise</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix Rotate90 (int direction)
	{
		FPix RetObj = _All.fpixRotate90(this, direction);
		return RetObj;
	}

	// fpix2.c (1912, 1)
	// fpixFlipLR(fpixd, fpixs) as FPix
	// fpixFlipLR(FPIX *, FPIX *) as FPIX *
	///  <summary>
	/// (1) This does a left-right flip of the image, which is
	/// equivalent to a rotation out of the plane about a
	/// vertical line through the image center.<para/>
	///
	/// (2) There are 3 cases for input:
	/// (a) fpixd == null (creates a new fpixd)
	/// (b) fpixd == fpixs (in-place operation)
	/// (c) fpixd != fpixs (existing fpixd)<para/>
	///
	/// (3) For clarity, use these three patterns, respectively:
	/// (a) fpixd = fpixFlipLR(NULL, fpixs)
	/// (b) fpixFlipLR(fpixs, fpixs)
	/// (c) fpixFlipLR(fpixd, fpixs)<para/>
	///
	/// (4) If an existing fpixd is not the same size as fpixs, the
	/// image data will be reallocated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixFlipLR/*"/>
	///  <param name="fpixd">[in][optional] - can be null, equal to fpixs, or different from fpixs</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix FlipLR (FPix fpixd)
	{
		FPix RetObj = _All.fpixFlipLR(fpixd, this);
		return RetObj;
	}

	// fpix2.c (1973, 1)
	// fpixFlipTB(fpixd, fpixs) as FPix
	// fpixFlipTB(FPIX *, FPIX *) as FPIX *
	///  <summary>
	/// (1) This does a top-bottom flip of the image, which is
	/// equivalent to a rotation out of the plane about a
	/// horizontal line through the image center.<para/>
	///
	/// (2) There are 3 cases for input:
	/// (a) fpixd == null (creates a new fpixd)
	/// (b) fpixd == fpixs (in-place operation)
	/// (c) fpixd != fpixs (existing fpixd)<para/>
	///
	/// (3) For clarity, use these three patterns, respectively:
	/// (a) fpixd = fpixFlipTB(NULL, fpixs)
	/// (b) fpixFlipTB(fpixs, fpixs)
	/// (c) fpixFlipTB(fpixd, fpixs)<para/>
	///
	/// (4) If an existing fpixd is not the same size as fpixs, the
	/// image data will be reallocated.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixFlipTB/*"/>
	///  <param name="fpixd">[in][optional] - can be null, equal to fpixs, or different from fpixs</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix FlipTB (FPix fpixd)
	{
		FPix RetObj = _All.fpixFlipTB(fpixd, this);
		return RetObj;
	}

	// fpix2.c (2035, 1)
	// fpixAffinePta(fpixs, ptad, ptas, border, inval) as FPix
	// fpixAffinePta(FPIX *, PTA *, PTA *, l_int32, l_float32) as FPIX *
	///  <summary>
	/// (1) If %border  is greater  0, all four sides are extended by that distance,
	/// and removed after the transformation is finished.  Pixels
	/// that would be brought in to the trimmed result from outside
	/// the extended region are assigned %inval.  The purpose of
	/// extending the image is to avoid such assignments.<para/>
	///
	/// (2) On the other hand, you may want to give all pixels that
	/// are brought in from outside fpixs a specific value.  In that
	/// case, set %border == 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixAffinePta/*"/>
	///  <param name="ptad">[in] - 4 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 4 pts of initial coordinate space</param>
	///  <param name="border">[in] - size of extension with constant normal derivative</param>
	///  <param name="inval">[in] - value brought in typ. 0</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix AffinePta (Pta ptad,
						   Pta ptas,
						   int border,
						   Single inval)
	{
		FPix RetObj = _All.fpixAffinePta(this, ptad, ptas, border, inval);
		return RetObj;
	}

	// fpix2.c (2092, 1)
	// fpixAffine(fpixs, vc, inval) as FPix
	// fpixAffine(FPIX *, l_float32 *, l_float32) as FPIX *
	///  <summary>
	/// fpixAffine()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixAffine/*"/>
	///  <param name="vc">[in] - vector of 8 coefficients for projective transformation</param>
	///  <param name="inval">[in] - value brought in typ. 0</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix Affine (Single[] vc,
						Single inval)
	{
		FPix RetObj = _All.fpixAffine(this, vc, inval);
		return RetObj;
	}

	// fpix2.c (2154, 1)
	// fpixProjectivePta(fpixs, ptad, ptas, border, inval) as FPix
	// fpixProjectivePta(FPIX *, PTA *, PTA *, l_int32, l_float32) as FPIX *
	///  <summary>
	/// (1) If %border  is greater  0, all four sides are extended by that distance,
	/// and removed after the transformation is finished.  Pixels
	/// that would be brought in to the trimmed result from outside
	/// the extended region are assigned %inval.  The purpose of
	/// extending the image is to avoid such assignments.<para/>
	///
	/// (2) On the other hand, you may want to give all pixels that
	/// are brought in from outside fpixs a specific value.  In that
	/// case, set %border == 0.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixProjectivePta/*"/>
	///  <param name="ptad">[in] - 4 pts of final coordinate space</param>
	///  <param name="ptas">[in] - 4 pts of initial coordinate space</param>
	///  <param name="border">[in] - size of extension with constant normal derivative</param>
	///  <param name="inval">[in] - value brought in typ. 0</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix ProjectivePta (Pta ptad,
							   Pta ptas,
							   int border,
							   Single inval)
	{
		FPix RetObj = _All.fpixProjectivePta(this, ptad, ptas, border, inval);
		return RetObj;
	}

	// fpix2.c (2211, 1)
	// fpixProjective(fpixs, vc, inval) as FPix
	// fpixProjective(FPIX *, l_float32 *, l_float32) as FPIX *
	///  <summary>
	/// fpixProjective()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixProjective/*"/>
	///  <param name="vc">[in] - vector of 8 coefficients for projective transformation</param>
	///  <param name="inval">[in] - value brought in typ. 0</param>
	///   <returns>fpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix Projective (Single[] vc,
							Single inval)
	{
		FPix RetObj = _All.fpixProjective(this, vc, inval);
		return RetObj;
	}

	// fpix2.c (2333, 1)
	// fpixThresholdToPix(fpix, thresh) as Pix
	// fpixThresholdToPix(FPIX *, l_float32) as PIX *
	///  <summary>
	/// (1) For all values of fpix that are smaller or equal thresh, sets the pixel
	/// in pixd to 1.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixThresholdToPix/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="thresh">[in] - </param>
	///   <returns>pixd 1 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ThresholdToPix (FPix fpix,
							   Single thresh)
	{
		Pix RetObj = _All.fpixThresholdToPix(fpix, thresh);
		return RetObj;
	}

	// graphics.c (2745, 1)
	// fpixAutoRenderContours(fpix, ncontours) as Pix
	// fpixAutoRenderContours(FPIX *, l_int32) as PIX *
	///  <summary>
	/// (1) The increment is set to get approximately %ncontours.<para/>
	///
	/// (2) The proximity to the target value for contour display
	/// is set to 0.15.<para/>
	///
	/// (3) Negative values are rendered in red positive values as black.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixAutoRenderContours/*"/>
	///  <param name="fpix">[in] - </param>
	///  <param name="ncontours">[in] - is greater  1,  is smaller 500, typ. about 50</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix AutoRenderContours (FPix fpix,
								   int ncontours)
	{
		Pix RetObj = _All.fpixAutoRenderContours(fpix, ncontours);
		return RetObj;
	}

	// graphics.c (2783, 1)
	// fpixRenderContours(fpixs, incr, proxim) as Pix
	// fpixRenderContours(FPIX *, l_float32, l_float32) as PIX *
	///  <summary>
	/// (1) Values are displayed when val/incr is within +-proxim
	/// to an integer.  The default value is 0.15 smaller values
	/// result in thinner contour lines.<para/>
	///
	/// (2) Negative values are rendered in red positive values as black.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixRenderContours/*"/>
	///  <param name="incr">[in] - increment between contours must be  is greater  0.0</param>
	///  <param name="proxim">[in] - required proximity to target value default 0.15</param>
	///   <returns>pixd 8 bpp, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix RenderContours (Single incr,
							   Single proxim)
	{
		Pix RetObj = _All.fpixRenderContours(this, incr, proxim);
		return RetObj;
	}


}
public partial class FPixa
{
	// colorspace.c (1821, 1)
	// fpixaConvertXYZToRGB(fpixa) as Pix
	// fpixaConvertXYZToRGB(FPIXA *) as PIX *
	///  <summary>
	/// (1) The xyz image is stored in three fpix.<para/>
	///
	/// (2) For values of xyz that are out of gamut for rgb, the rgb
	/// components are set to the closest valid color.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaConvertXYZToRGB/*"/>
	///   <returns>pixd rgb</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertXYZToRGB ()
	{
		Pix RetObj = _All.fpixaConvertXYZToRGB(this);
		return RetObj;
	}

	// colorspace.c (1982, 1)
	// fpixaConvertXYZToLAB(fpixas) as FPixa
	// fpixaConvertXYZToLAB(FPIXA *) as FPIXA *
	///  <summary>
	/// (1) The input [x,y,z] and output [l,a,b] values are stored as
	/// float values, each set in three fpix.<para/>
	///
	/// (2) The CIE LAB color space was invented in 1976, as an
	/// absolute reference for specifying colors that we can
	/// perceive, independently of the rendering device.  It was
	/// invented to align color display and print images.
	/// For information, see:
	/// http://www.brucelindbloom.com/
	/// http://en.wikipedia.org/wiki/Lab_color_space
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaConvertXYZToLAB/*"/>
	///  <param name="fpixas">[in] - xyz</param>
	///   <returns>fpixa lab</returns>
	// CreateAdditiveFunction: Function/Else
	public FPixa ConvertXYZToLAB (FPixa fpixas)
	{
		FPixa RetObj = _All.fpixaConvertXYZToLAB(fpixas);
		return RetObj;
	}

	// colorspace.c (2048, 1)
	// fpixaConvertLABToXYZ(fpixas) as FPixa
	// fpixaConvertLABToXYZ(FPIXA *) as FPIXA *
	///  <summary>
	/// (1) The input [l,a,b] and output [x,y,z] values are stored as
	/// float values, each set in three fpix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaConvertLABToXYZ/*"/>
	///  <param name="fpixas">[in] - lab</param>
	///   <returns>fpixa xyz</returns>
	// CreateAdditiveFunction: Function/Else
	public FPixa ConvertLABToXYZ (FPixa fpixas)
	{
		FPixa RetObj = _All.fpixaConvertLABToXYZ(fpixas);
		return RetObj;
	}

	// colorspace.c (2300, 1)
	// fpixaConvertLABToRGB(fpixa) as Pix
	// fpixaConvertLABToRGB(FPIXA *) as PIX *
	///  <summary>
	/// (1) The lab image is stored in three fpix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaConvertLABToRGB/*"/>
	///   <returns>pixd rgb</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertLABToRGB ()
	{
		Pix RetObj = _All.fpixaConvertLABToRGB(this);
		return RetObj;
	}

	// fpix1.c (706, 1)
	// fpixaCreate(n) as FPixa
	// fpixaCreate(l_int32) as FPIXA *
	///  <summary>
	/// fpixaCreate()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaCreate/*"/>
	///  <param name="n">[in] - initial number of ptrs</param>
	///   <returns>fpixa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPixa Create (int n)
	{
		FPixa RetObj = _All.fpixaCreate(n);
		return RetObj;
	}

	// fpix1.c (746, 1)
	// fpixaCopy(fpixa, copyflag) as FPixa
	// fpixaCopy(FPIXA *, l_int32) as FPIXA *
	///  <summary>
	/// copyflag may be one of
	/// ~ L_COPY makes a new fpixa and copies each fpix
	/// ~ L_CLONE gives a new ref-counted handle to the input fpixa
	/// ~ L_COPY_CLONE makes a new fpixa with clones of all fpix
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaCopy/*"/>
	///  <param name="copyflag">[in] - L_COPY, L_CLODE or L_COPY_CLONE</param>
	///   <returns>new fpixa, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPixa Copy (int copyflag,
					   FPixa fpixa)
	{
		FPixa RetObj = _All.fpixaCopy(this, copyflag);
		return RetObj;
	}

	// fpix1.c (793, 1)
	// fpixaDestroy(pfpixa) as Object
	// fpixaDestroy(FPIXA **) as void
	///  <summary>
	/// (1) Decrements the ref count and, if 0, destroys the fpixa.<para/>
	///
	/// (2) Always nulls the input ptr.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaDestroy/*"/>
	///  <param name="pfpixa">[in,out] - to be nulled</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref FPixa pfpixa)
	{
		_All.fpixaDestroy(ref pfpixa);
	}

	// fpix1.c (834, 1)
	// fpixaAddFPix(fpixa, fpix, copyflag) as int
	// fpixaAddFPix(FPIXA *, FPIX *, l_int32) as l_ok
	///  <summary>
	/// fpixaAddFPix()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaAddFPix/*"/>
	///  <param name="fpix">[in] - to be added</param>
	///  <param name="copyflag">[in] - L_INSERT, L_COPY, L_CLONE</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddFPix (FPix fpix,
						int copyflag)
	{
		int RetObj = _All.fpixaAddFPix(this, fpix, copyflag);
		return RetObj;
	}

	// fpix1.c (934, 1)
	// fpixaGetCount(fpixa) as int
	// fpixaGetCount(FPIXA *) as l_int32
	///  <summary>
	/// fpixaGetCount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaGetCount/*"/>
	///   <returns>count, or 0 if no pixa</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetCount ()
	{
		int RetObj = _All.fpixaGetCount(this);
		return RetObj;
	}

	// fpix1.c (953, 1)
	// fpixaChangeRefcount(fpixa, delta) as int
	// fpixaChangeRefcount(FPIXA *, l_int32) as l_ok
	///  <summary>
	/// fpixaChangeRefcount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaChangeRefcount/*"/>
	///  <param name="delta">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ChangeRefcount (int delta)
	{
		int RetObj = _All.fpixaChangeRefcount(this, delta);
		return RetObj;
	}

	// fpix1.c (975, 1)
	// fpixaGetFPix(fpixa, index, accesstype) as FPix
	// fpixaGetFPix(FPIXA *, l_int32, l_int32) as FPIX *
	///  <summary>
	/// fpixaGetFPix()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaGetFPix/*"/>
	///  <param name="index">[in] - to the index-th fpix</param>
	///  <param name="accesstype">[in] - L_COPY or L_CLONE</param>
	///   <returns>fpix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix GetFPix (int index,
						 int accesstype)
	{
		FPix RetObj = _All.fpixaGetFPix(this, index, accesstype);
		return RetObj;
	}

	// fpix1.c (1004, 1)
	// fpixaGetFPixDimensions(fpixa, index, pw, ph) as int
	// fpixaGetFPixDimensions(FPIXA *, l_int32, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// fpixaGetFPixDimensions()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaGetFPixDimensions/*"/>
	///  <param name="index">[in] - to the index-th box</param>
	///  <param name="pw">[out][optional] - each can be null</param>
	///  <param name="ph">[out][optional] - each can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetFPixDimensions (int index,
								  out int pw,
								  out int ph)
	{
		int RetObj = _All.fpixaGetFPixDimensions(this, index, out pw, out ph);
		return RetObj;
	}

	// fpix1.c (1038, 1)
	// fpixaGetData(fpixa, index) as Single[]
	// fpixaGetData(FPIXA *, l_int32) as l_float32 *
	///  <summary>
	/// fpixaGetData()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaGetData/*"/>
	///  <param name="index">[in] - into fpixa array</param>
	///   <returns>data not a copy, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Single[] GetData (int index)
	{
		Single[] RetObj = _All.fpixaGetData(this, index);
		return RetObj;
	}

	// fpix1.c (1070, 1)
	// fpixaGetPixel(fpixa, index, x, y, pval) as int
	// fpixaGetPixel(FPIXA *, l_int32, l_int32, l_int32, l_float32 *) as l_ok
	///  <summary>
	/// fpixaGetPixel()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaGetPixel/*"/>
	///  <param name="index">[in] - into fpixa array</param>
	///  <param name="x">[in] - ,y pixel coords</param>
	///  <param name="pval">[out] - pixel value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetPixel (int index,
						 int x,
						 int y,
						 out Single pval)
	{
		int RetObj = _All.fpixaGetPixel(this, index, x, y, out pval);
		return RetObj;
	}

	// fpix1.c (1107, 1)
	// fpixaSetPixel(fpixa, index, x, y, val) as int
	// fpixaSetPixel(FPIXA *, l_int32, l_int32, l_int32, l_float32) as l_ok
	///  <summary>
	/// fpixaSetPixel()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaSetPixel/*"/>
	///  <param name="index">[in] - into fpixa array</param>
	///  <param name="x">[in] - ,y pixel coords</param>
	///  <param name="val">[in] - pixel value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetPixel (int index,
						 int x,
						 int y,
						 Single val)
	{
		int RetObj = _All.fpixaSetPixel(this, index, x, y, val);
		return RetObj;
	}

	// quadtree.c (654, 1)
	// fpixaDisplayQuadtree(fpixa, factor, fontsize) as Pix
	// fpixaDisplayQuadtree(FPIXA *, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) The mean and root variance fall naturally in the 8 bpp range,
	/// but the variance is typically outside the range.  This
	/// function displays 8 bpp pix clipped to 255, so the image
	/// pixels will mostly be 255 (white).
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/fpixaDisplayQuadtree/*"/>
	///  <param name="factor">[in] - replication factor at lowest level</param>
	///  <param name="fontsize">[in] - 4, ... 20</param>
	///   <returns>pixd 8 bpp, mosaic of quadtree images, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix DisplayQuadtree (int factor,
								int fontsize)
	{
		Pix RetObj = _All.fpixaDisplayQuadtree(this, factor, fontsize);
		return RetObj;
	}


}
public partial class DPix
{
	// fpix1.c (1993, 1)
	// dpixRead(filename) as DPix
	// dpixRead(const char *) as DPIX *
	///  <summary>
	/// dpixRead()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixRead/*"/>
	///  <param name="filename">[in] - </param>
	// CreateAdditiveFunction: Constructor
	public DPix (String filename)
	{
		DPix RetObj = _All.dpixRead(filename);
		Pointer = RetObj.Pointer;
	}

	// fpix1.c (1148, 1)
	// dpixCreate(width, height) as DPix
	// dpixCreate(l_int32, l_int32) as DPIX *
	///  <summary>
	/// (1) Makes a DPix of specified size, with the data array
	/// allocated and initialized to 0.<para/>
	///
	/// (2) The number of pixels must be less than 2^28.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixCreate/*"/>
	///  <param name="width">[in] - </param>
	///  <param name="height">[in] - </param>
	// CreateAdditiveFunction: Constructor
	public DPix (int width,
				 int height)
	{
		DPix RetObj = _All.dpixCreate(width, height);
		Pointer = RetObj.Pointer;
	}

	// fpix1.c (1198, 1)
	// dpixCreateTemplate(dpixs) as DPix
	// dpixCreateTemplate(DPIX *) as DPIX *
	///  <summary>
	/// (1) Makes a DPix of the same size as the input DPix, with the
	/// data array allocated and initialized to 0.<para/>
	///
	/// (2) Copies the resolution.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixCreateTemplate/*"/>
	///  <param name="dpixs">[in] - </param>
	// CreateAdditiveFunction: Constructor
	public DPix (DPix dpixs)
	{
		DPix RetObj = _All.dpixCreateTemplate(dpixs);
		Pointer = RetObj.Pointer;
	}

	// fpix1.c (1227, 1)
	// dpixClone(dpix) as DPix
	// dpixClone(DPIX *) as DPIX *
	///  <summary>
	/// (1) See pixClone() for definition and usage.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixClone/*"/>
	///  <param name="dpix">[in] - </param>
	///   <returns>same dpix ptr, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public DPix Clone (DPix dpix)
	{
		DPix RetObj = _All.dpixClone(dpix);
		return RetObj;
	}

	// fpix1.c (1270, 1)
	// dpixCopy(dpixd, dpixs) as DPix
	// dpixCopy(DPIX *, DPIX *) as DPIX *
	///  <summary>
	/// (1) There are three cases:
	/// (a) dpixd == null  (makes a new dpix refcount = 1)
	/// (b) dpixd == dpixs  (no-op)
	/// (c) dpixd != dpixs  (data copy no change in refcount)
	/// If the refcount of dpixd  is greater  1, case (c) will side-effect
	/// these handles.<para/>
	///
	/// (2) The general pattern of use is:
	/// dpixd = dpixCopy(dpixd, dpixs)
	/// This will work for all three cases.
	/// For clarity when the case is known, you can use:
	/// (a) dpixd = dpixCopy(NULL, dpixs)
	/// (c) dpixCopy(dpixd, dpixs)<para/>
	///
	/// (3) For case (c), we check if dpixs and dpixd are the same size.
	/// If so, the data is copied directly.
	/// Otherwise, the data is reallocated to the correct size
	/// and the copy proceeds.  The refcount of dpixd is unchanged.<para/>
	///
	/// (4) This operation, like all others that may involve a pre-existing
	/// dpixd, will side-effect any existing clones of dpixd.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixCopy/*"/>
	///  <param name="dpixd">[in][optional] - can be null, or equal to dpixs, or different from dpixs</param>
	///   <returns>dpixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public DPix Copy (DPix dpixd)
	{
		DPix RetObj = _All.dpixCopy(dpixd, this);
		return RetObj;
	}

	// fpix1.c (1316, 1)
	// dpixResizeImageData(dpixd, dpixs) as int
	// dpixResizeImageData(DPIX *, DPIX *) as l_ok
	///  <summary>
	/// dpixResizeImageData()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixResizeImageData/*"/>
	///  <param name="dpixd">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ResizeImageData (DPix dpixd)
	{
		int RetObj = _All.dpixResizeImageData(dpixd, this);
		return RetObj;
	}

	// fpix1.c (1359, 1)
	// dpixDestroy(pdpix) as Object
	// dpixDestroy(DPIX **) as void
	///  <summary>
	/// (1) Decrements the ref count and, if 0, destroys the dpix.<para/>
	///
	/// (2) Always nulls the input ptr.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixDestroy/*"/>
	///  <param name="pdpix">[in,out] - will be nulled</param>
	// CreateAdditiveFunction: Sub/Default
	public void Destroy (ref DPix pdpix)
	{
		_All.dpixDestroy(ref pdpix);
	}

	// fpix1.c (1398, 1)
	// dpixGetDimensions(dpix, pw, ph) as int
	// dpixGetDimensions(DPIX *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// dpixGetDimensions()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixGetDimensions/*"/>
	///  <param name="dpix">[in] - </param>
	///  <param name="pw">[out][optional] - each can be null</param>
	///  <param name="ph">[out][optional] - each can be null</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetDimensions (DPix dpix,
							  out int pw,
							  out int ph)
	{
		int RetObj = _All.dpixGetDimensions(dpix, out pw, out ph);
		return RetObj;
	}

	// fpix1.c (1424, 1)
	// dpixSetDimensions(dpix, w, h) as int
	// dpixSetDimensions(DPIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// dpixSetDimensions()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixSetDimensions/*"/>
	///  <param name="dpix">[in] - </param>
	///  <param name="w">[in] - </param>
	///  <param name="h">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetDimensions (DPix dpix,
							  int w,
							  int h)
	{
		int RetObj = _All.dpixSetDimensions(dpix, w, h);
		return RetObj;
	}

	// fpix1.c (1445, 1)
	// dpixGetWpl(dpix) as int
	// dpixGetWpl(DPIX *) as l_int32
	///  <summary>
	/// dpixGetWpl()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixGetWpl/*"/>
	///  <param name="dpix">[in] - </param>
	///   <returns>wpl, or UNDEF on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetWpl (DPix dpix)
	{
		int RetObj = _All.dpixGetWpl(dpix);
		return RetObj;
	}

	// fpix1.c (1463, 1)
	// dpixSetWpl(dpix, wpl) as int
	// dpixSetWpl(DPIX *, l_int32) as l_ok
	///  <summary>
	/// dpixSetWpl()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixSetWpl/*"/>
	///  <param name="dpix">[in] - </param>
	///  <param name="wpl">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetWpl (DPix dpix,
					   int wpl)
	{
		int RetObj = _All.dpixSetWpl(dpix, wpl);
		return RetObj;
	}

	// fpix1.c (1483, 1)
	// dpixGetRefcount(dpix) as int
	// dpixGetRefcount(DPIX *) as l_int32
	///  <summary>
	/// dpixGetRefcount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixGetRefcount/*"/>
	///  <param name="dpix">[in] - </param>
	///   <returns>refcount, or UNDEF on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetRefcount (DPix dpix)
	{
		int RetObj = _All.dpixGetRefcount(dpix);
		return RetObj;
	}

	// fpix1.c (1501, 1)
	// dpixChangeRefcount(dpix, delta) as int
	// dpixChangeRefcount(DPIX *, l_int32) as l_ok
	///  <summary>
	/// dpixChangeRefcount()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixChangeRefcount/*"/>
	///  <param name="dpix">[in] - </param>
	///  <param name="delta">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int ChangeRefcount (DPix dpix,
							   int delta)
	{
		int RetObj = _All.dpixChangeRefcount(dpix, delta);
		return RetObj;
	}

	// fpix1.c (1522, 1)
	// dpixGetResolution(dpix, pxres, pyres) as int
	// dpixGetResolution(DPIX *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// dpixGetResolution()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixGetResolution/*"/>
	///  <param name="dpix">[in] - </param>
	///  <param name="pxres">[out][optional] - x and y resolution</param>
	///  <param name="pyres">[out][optional] - x and y resolution</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetResolution (DPix dpix,
							  out int pxres,
							  out int pyres)
	{
		int RetObj = _All.dpixGetResolution(dpix, out pxres, out pyres);
		return RetObj;
	}

	// fpix1.c (1544, 1)
	// dpixSetResolution(dpix, xres, yres) as int
	// dpixSetResolution(DPIX *, l_int32, l_int32) as l_ok
	///  <summary>
	/// dpixSetResolution()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixSetResolution/*"/>
	///  <param name="dpix">[in] - </param>
	///  <param name="xres">[in] - x and y resolution</param>
	///  <param name="yres">[in] - x and y resolution</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetResolution (DPix dpix,
							  int xres,
							  int yres)
	{
		int RetObj = _All.dpixSetResolution(dpix, xres, yres);
		return RetObj;
	}

	// fpix1.c (1566, 1)
	// dpixCopyResolution(dpixd, dpixs) as int
	// dpixCopyResolution(DPIX *, DPIX *) as l_ok
	///  <summary>
	/// dpixCopyResolution()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixCopyResolution/*"/>
	///  <param name="dpixd">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int CopyResolution (DPix dpixd)
	{
		int RetObj = _All.dpixCopyResolution(dpixd, this);
		return RetObj;
	}

	// fpix1.c (1588, 1)
	// dpixGetData(dpix) as Double[]
	// dpixGetData(DPIX *) as l_float64 *
	///  <summary>
	/// dpixGetData()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixGetData/*"/>
	///  <param name="dpix">[in] - </param>
	///   <returns>ptr DPix::data, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Double[] GetData (DPix dpix)
	{
		Double[] RetObj = _All.dpixGetData(dpix);
		return RetObj;
	}

	// fpix1.c (1606, 1)
	// dpixSetData(dpix, data) as int
	// dpixSetData(DPIX *, l_float64 *) as l_ok
	///  <summary>
	/// dpixSetData()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixSetData/*"/>
	///  <param name="dpix">[in] - </param>
	///  <param name="data">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetData (DPix dpix,
						Double[] data)
	{
		int RetObj = _All.dpixSetData(dpix, data);
		return RetObj;
	}

	// fpix1.c (1628, 1)
	// dpixGetPixel(dpix, x, y, pval) as int
	// dpixGetPixel(DPIX *, l_int32, l_int32, l_float64 *) as l_ok
	///  <summary>
	/// dpixGetPixel()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixGetPixel/*"/>
	///  <param name="dpix">[in] - </param>
	///  <param name="x">[in] - ,y pixel coords</param>
	///  <param name="pval">[out] - pixel value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetPixel (DPix dpix,
						 int x,
						 int y,
						 out Double[] pval)
	{
		int RetObj = _All.dpixGetPixel(dpix, x, y, out pval);
		return RetObj;
	}

	// fpix1.c (1663, 1)
	// dpixSetPixel(dpix, x, y, val) as int
	// dpixSetPixel(DPIX *, l_int32, l_int32, l_float64) as l_ok
	///  <summary>
	/// dpixSetPixel()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixSetPixel/*"/>
	///  <param name="dpix">[in] - </param>
	///  <param name="x">[in] - ,y pixel coords</param>
	///  <param name="val">[in] - pixel value</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetPixel (DPix dpix,
						 int x,
						 int y,
						 double val)
	{
		int RetObj = _All.dpixSetPixel(dpix, x, y, val);
		return RetObj;
	}

	// fpix1.c (2020, 1)
	// dpixReadStream(fp) as DPix
	// dpixReadStream(FILE *) as DPIX *
	///  <summary>
	/// dpixReadStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixReadStream/*"/>
	///  <param name="fp">[in] - file stream</param>
	///   <returns>dpix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public DPix ReadStream (FILE fp)
	{
		DPix RetObj = _All.dpixReadStream(fp);
		return RetObj;
	}

	// fpix1.c (2073, 1)
	// dpixReadMem(data, size) as DPix
	// dpixReadMem(const l_uint8 *, size_t) as DPIX *
	///  <summary>
	/// dpixReadMem()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixReadMem/*"/>
	///  <param name="data">[in] - of serialized dpix</param>
	///  <param name="size">[in] - of data in bytes</param>
	///   <returns>dpix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public DPix ReadMem (Byte[] data,
						 uint size)
	{
		DPix RetObj = _All.dpixReadMem(data, size);
		return RetObj;
	}

	// fpix1.c (2101, 1)
	// dpixWrite(filename, dpix) as int
	// dpixWrite(const char *, DPIX *) as l_ok
	///  <summary>
	/// dpixWrite()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixWrite/*"/>
	///  <param name="filename">[in] - </param>
	///  <param name="dpix">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int Write (String filename,
					  DPix dpix)
	{
		int RetObj = _All.dpixWrite(filename, dpix);
		return RetObj;
	}

	// fpix1.c (2132, 1)
	// dpixWriteStream(fp, dpix) as int
	// dpixWriteStream(FILE *, DPIX *) as l_ok
	///  <summary>
	/// dpixWriteStream()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixWriteStream/*"/>
	///  <param name="fp">[in] - file stream opened for "wb"</param>
	///  <param name="dpix">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteStream (FILE fp,
							DPix dpix)
	{
		int RetObj = _All.dpixWriteStream(fp, dpix);
		return RetObj;
	}

	// fpix1.c (2178, 1)
	// dpixWriteMem(pdata, psize, dpix) as int
	// dpixWriteMem(l_uint8 **, size_t *, DPIX *) as l_ok
	///  <summary>
	/// (1) Serializes a dpix in memory and puts the result in a buffer.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixWriteMem/*"/>
	///  <param name="pdata">[out] - data of serialized dpix</param>
	///  <param name="psize">[out] - size of returned data</param>
	///  <param name="dpix">[in] - </param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int WriteMem (out Byte[] pdata,
						 out uint psize,
						 DPix dpix)
	{
		int RetObj = _All.dpixWriteMem(out pdata, out psize, dpix);
		return RetObj;
	}

	// fpix1.c (2238, 1)
	// dpixEndianByteSwap(dpixd, dpixs) as DPix
	// dpixEndianByteSwap(DPIX *, DPIX *) as DPIX *
	///  <summary>
	/// (1) On big-endian hardware, this does byte-swapping on each of
	/// the 4-byte words in the dpix data.  On little-endians,
	/// the data is unchanged.  This is used for serialization
	/// of dpix the data is serialized in little-endian byte
	/// order because most hardware is little-endian.<para/>
	///
	/// (2) The operation can be either in-place or, if dpixd == NULL,
	/// a new dpix is made.  If not in-place, caller must catch
	/// the returned pointer.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixEndianByteSwap/*"/>
	///  <param name="dpixd">[in] - can be equal to dpixs or NULL</param>
	///   <returns>dpixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public DPix EndianByteSwap (DPix dpixd)
	{
		DPix RetObj = _All.dpixEndianByteSwap(dpixd, this);
		return RetObj;
	}

	// fpix2.c (537, 1)
	// dpixConvertToPix(dpixs, outdepth, negvals, errorflag) as Pix
	// dpixConvertToPix(DPIX *, l_int32, l_int32, l_int32) as PIX *
	///  <summary>
	/// (1) Use %outdepth = 0 to programmatically determine the
	/// output depth.  If no values are greater than 255,
	/// it will set outdepth = 8 otherwise to 16 or 32.<para/>
	///
	/// (2) Because we are converting a float to an unsigned int
	/// with a specified dynamic range (8, 16 or 32 bits), errors
	/// can occur.  If errorflag == TRUE, output the number
	/// of values out of range, both negative and positive.<para/>
	///
	/// (3) If a pixel value is positive and out of range, clip to
	/// the maximum value represented at the outdepth of 8, 16
	/// or 32 bits.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixConvertToPix/*"/>
	///  <param name="outdepth">[in] - 0, 8, 16 or 32 bpp</param>
	///  <param name="negvals">[in] - L_CLIP_TO_ZERO, L_TAKE_ABSVAL</param>
	///  <param name="errorflag">[in] - 1 to output error stats 0 otherwise</param>
	///   <returns>pixd, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public Pix ConvertToPix (int outdepth,
							 int negvals,
							 int errorflag)
	{
		Pix RetObj = _All.dpixConvertToPix(this, outdepth, negvals, errorflag);
		return RetObj;
	}

	// fpix2.c (641, 1)
	// dpixConvertToFPix(dpix) as FPix
	// dpixConvertToFPix(DPIX *) as FPIX *
	///  <summary>
	/// dpixConvertToFPix()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixConvertToFPix/*"/>
	///  <param name="dpix">[in] - </param>
	///   <returns>fpix, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public FPix ConvertToFPix (DPix dpix)
	{
		FPix RetObj = _All.dpixConvertToFPix(dpix);
		return RetObj;
	}

	// fpix2.c (795, 1)
	// dpixGetMin(dpix, pminval, pxminloc, pyminloc) as int
	// dpixGetMin(DPIX *, l_float64 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// dpixGetMin()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixGetMin/*"/>
	///  <param name="dpix">[in] - </param>
	///  <param name="pminval">[out][optional] - min value</param>
	///  <param name="pxminloc">[out][optional] - x location of min</param>
	///  <param name="pyminloc">[out][optional] - y location of min</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMin (DPix dpix,
					   out Double[] pminval,
					   out int pxminloc,
					   out int pyminloc)
	{
		int RetObj = _All.dpixGetMin(dpix, out pminval, out pxminloc, out pyminloc);
		return RetObj;
	}

	// fpix2.c (848, 1)
	// dpixGetMax(dpix, pmaxval, pxmaxloc, pymaxloc) as int
	// dpixGetMax(DPIX *, l_float64 *, l_int32 *, l_int32 *) as l_ok
	///  <summary>
	/// dpixGetMax()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixGetMax/*"/>
	///  <param name="dpix">[in] - </param>
	///  <param name="pmaxval">[out][optional] - max value</param>
	///  <param name="pxmaxloc">[out][optional] - x location of max</param>
	///  <param name="pymaxloc">[out][optional] - y location of max</param>
	///   <returns>0 if OK 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int GetMax (DPix dpix,
					   out Double[] pmaxval,
					   out int pxmaxloc,
					   out int pymaxloc)
	{
		int RetObj = _All.dpixGetMax(dpix, out pmaxval, out pxmaxloc, out pymaxloc);
		return RetObj;
	}

	// fpix2.c (1007, 1)
	// dpixScaleByInteger(dpixs, factor) as DPix
	// dpixScaleByInteger(DPIX *, l_int32) as DPIX *
	///  <summary>
	/// (1) The width wd of dpixd is related to ws of dpixs by:
	/// wd = factor  (ws - 1) + 1 (and ditto for the height)
	/// We avoid special-casing boundary pixels in the interpolation
	/// by constructing fpixd by inserting (factor - 1) interpolated
	/// pixels between each pixel in fpixs.  Then
	/// wd = ws + (ws - 1)  (factor - 1)  (same as above)
	/// This also has the advantage that if we subsample by %factor,
	/// throwing out all the interpolated pixels, we regain the
	/// original low resolution dpix.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixScaleByInteger/*"/>
	///  <param name="factor">[in] - scaling factor</param>
	///   <returns>dpixd interpolated result, or NULL on error</returns>
	// CreateAdditiveFunction: Function/Else
	public DPix ScaleByInteger (int factor)
	{
		DPix RetObj = _All.dpixScaleByInteger(this, factor);
		return RetObj;
	}

	// fpix2.c (1223, 1)
	// dpixLinearCombination(dpixd, dpixs1, dpixs2, a, b) as DPix
	// dpixLinearCombination(DPIX *, DPIX *, DPIX *, l_float32, l_float32) as DPIX *
	///  <summary>
	/// (1) Computes pixelwise linear combination: a  src1 + b  src2<para/>
	///
	/// (2) Alignment is to UL corner.<para/>
	///
	/// (3) There are 3 cases.  The result can go to a new dest,
	/// in-place to dpixs1, or to an existing input dest:
	/// dpixd == null: (src1 + src2) to new dpixd
	/// dpixd == dpixs1:  (src1 + src2) to src1  (in-place)
	/// dpixd != dpixs1: (src1 + src2) to input dpixd<para/>
	///
	/// (4) dpixs2 must be different from both dpixd and dpixs1.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixLinearCombination/*"/>
	///  <param name="dpixd">[in][optional] - this can be null, equal to dpixs1, or different from dpixs1</param>
	///  <param name="dpixs1">[in] - can be == to dpixd</param>
	///  <param name="dpixs2">[in] - </param>
	///  <param name="a">[in] - multiplication factors on dpixs1 and dpixs2, rsp.</param>
	///  <param name="b">[in] - multiplication factors on dpixs1 and dpixs2, rsp.</param>
	///   <returns>dpixd always</returns>
	// CreateAdditiveFunction: Function/Else
	public DPix LinearCombination (DPix dpixs1,
								   DPix dpixs2,
								   Single a,
								   Single b,
								   DPix dpixd)
	{
		DPix RetObj = _All.dpixLinearCombination(dpixd, dpixs1, dpixs2, a, b);
		return RetObj;
	}

	// fpix2.c (1282, 1)
	// dpixAddMultConstant(dpix, addc, multc) as int
	// dpixAddMultConstant(DPIX *, l_float64, l_float64) as l_ok
	///  <summary>
	/// (1) This is an in-place operation.<para/>
	///
	/// (2) It can be used to multiply each pixel by a constant,
	/// and also to add a constant to each pixel.  Multiplication
	/// is done first.
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixAddMultConstant/*"/>
	///  <param name="dpix">[in] - </param>
	///  <param name="addc">[in] - use 0.0 to skip the operation</param>
	///  <param name="multc">[in] - use 1.0 to skip the operation</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int AddMultConstant (DPix dpix,
								double addc,
								double multc)
	{
		int RetObj = _All.dpixAddMultConstant(dpix, addc, multc);
		return RetObj;
	}

	// fpix2.c (1360, 1)
	// dpixSetAllArbitrary(dpix, inval) as int
	// dpixSetAllArbitrary(DPIX *, l_float64) as l_ok
	///  <summary>
	/// dpixSetAllArbitrary()
	///  </summary>
	///  <remarks>
	///  </remarks>
	///  <include file="..\CHM_Help\IncludeComments.xml" path="Comments/dpixSetAllArbitrary/*"/>
	///  <param name="dpix">[in] - </param>
	///  <param name="inval">[in] - to set at each pixel</param>
	///   <returns>0 if OK, 1 on error</returns>
	// CreateAdditiveFunction: Function/Else
	public int SetAllArbitrary (DPix dpix,
								double inval)
	{
		int RetObj = _All.dpixSetAllArbitrary(dpix, inval);
		return RetObj;
	}


}
