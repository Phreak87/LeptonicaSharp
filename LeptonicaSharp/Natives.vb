Imports System.Runtime.InteropServices
Public Class Natives
Const DllPath as String = "pvt.cppan.demo.danbloomberg.leptonica-1.76.0.dll"
Const CConv as CallingConvention = CallingConvention.Cdecl

#Region "SRC\adaptmap.c"
' SRC\adaptmap.c (152, 17)
' iaaGetLinearTRC()
' iaaGetLinearTRC(l_int32 **, l_int32) as l_int32 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ia LUT with input (val - minval) and output a</returns>
''' <param name="iaa"> \param[in]    iaa bare array of ptrs to l_int32</param>
''' <param name="diff"> \param[in]    diff between min and max pixel values that are</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="iaaGetLinearTRC")> _
Friend Shared Function iaaGetLinearTRC(iaa as Object, diff as Integer) as String
End Function

' SRC\adaptmap.c (185, 1)
' pixCleanBackgroundToWhite()
' pixCleanBackgroundToWhite(PIX *, PIX *, PIX *, l_float32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  * (1) This is a simplified interface for cleaning an image.
'''  *  For comparison, see pixAdaptThresholdToBinaryGen().
'''  * (2) The suggested default values for the input parameters are:
'''  * gamma: 1.0  (reduce this to increase the contrast; e.g.,
'''  *  for light text)
'''  * blackval   70  (a bit more than 60)
'''  * whiteval  190  (a bit less than 200)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp or 32 bpp rgb, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale or 32 bpp rgb</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null</param>
''' <param name="pixg"> \param[in]    pixg [optional] 8 bpp grayscale version; can be null</param>
''' <param name="gamma"> \param[in]    gamma gamma correction; must be > 0.0; typically ~1.0</param>
''' <param name="blackval"> \param[in]    blackval dark value to set to black (0)</param>
''' <param name="whiteval"> \param[in]    whiteval light value to set to white (255)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCleanBackgroundToWhite")> _
Friend Shared Function pixCleanBackgroundToWhite(pixs as IntPTR, pixim as IntPTR, pixg as IntPTR, gamma as single, blackval as Integer, whiteval as Integer) as IntPTR
End Function

' SRC\adaptmap.c (231, 1)
' pixBackgroundNormSimple()
' pixBackgroundNormSimple(PIX *, PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  * (1) This is a simplified interface to pixBackgroundNorm(),
'''  *  where seven parameters are defaulted.
'''  * (2) The input image is either grayscale or rgb.
'''  * (3) See pixBackgroundNorm() for usage and function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp or 32 bpp rgb, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale or 32 bpp rgb</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null</param>
''' <param name="pixg"> \param[in]    pixg [optional] 8 bpp grayscale version; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBackgroundNormSimple")> _
Friend Shared Function pixBackgroundNormSimple(pixs as IntPTR, pixim as IntPTR, pixg as IntPTR) as IntPTR
End Function

' SRC\adaptmap.c (302, 1)
' pixBackgroundNorm()
' pixBackgroundNorm(PIX *, PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  * (1) This is a top-level interface for normalizing the image intensity
'''  *  by mapping the image so that the background is near the input
'''  *  value 'bgval'.
'''  * (2) The input image is either grayscale or rgb.
'''  * (3) For each component in the input image, the background value
'''  *  in each tile is estimated using the values in the tile that
'''  *  are not part of the foreground, where the foreground is
'''  *  determined by the input 'thresh' argument.
'''  * (4) An optional binary mask can be specified, with the foreground
'''  *  pixels typically over image regions.  The resulting background
'''  *  map values will be determined by surrounding pixels that are
'''  *  not under the mask foreground.  The origin (0,0) of this mask
'''  *  is assumed to be aligned with the origin of the input image.
'''  *  This binary mask must not fully cover pixs, because then there
'''  *  will be no pixels in the input image available to compute
'''  *  the background.
'''  * (5) An optional grayscale version of the input pixs can be supplied.
'''  *  The only reason to do this is if the input is RGB and this
'''  *  grayscale version can be used elsewhere.  If the input is RGB
'''  *  and this is not supplied, it is made internally using only
'''  *  the green component, and destroyed after use.
'''  * (6) The dimensions of the pixel tile (sx, sy) give the amount by
'''  *  by which the map is reduced in size from the input image.
'''  * (7) The threshold is used to binarize the input image, in order to
'''  *  locate the foreground components.  If this is set too low,
'''  *  some actual foreground may be used to determine the maps;
'''  *  if set too high, there may not be enough background
'''  *  to determine the map values accurately.  Typically, it's
'''  *  better to err by setting the threshold too high.
'''  * (8) A 'mincount' threshold is a minimum count of pixels in a
'''  *  tile for which a background reading is made, in order for that
'''  *  pixel in the map to be valid.  This number should perhaps be
'''  *  at least 1/3 the size of the tile.
'''  * (9) A 'bgval' target background value for the normalized image.  This
'''  *  should be at least 128.  If set too close to 255, some
'''  *  clipping will occur in the result.
'''  * (10) Two factors, 'smoothx' and 'smoothy', are input for smoothing
'''  *  the map.  Each low-pass filter kernel dimension is
'''  *  is 2 * (smoothing factor) + 1, so a
'''  *  value of 0 means no smoothing. A value of 1 or 2 is recommended.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp or 32 bpp rgb, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale or 32 bpp rgb</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null</param>
''' <param name="pixg"> \param[in]    pixg [optional] 8 bpp grayscale version; can be null</param>
''' <param name="sx"> \param[in]    sx, sy tile size in pixels</param>
''' <param name="sy"> \param[in]    thresh threshold for determining foreground</param>
''' <param name="thresh"> \param[in]    mincount min threshold on counts in a tile</param>
''' <param name="mincount"> \param[in]    bgval target bg val; typ. > 128</param>
''' <param name="bgval"> \param[in]    smoothx half-width of block convolution kernel width</param>
''' <param name="smoothx"> \param[in]    smoothy half-width of block convolution kernel height</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBackgroundNorm")> _
Friend Shared Function pixBackgroundNorm(pixs as IntPTR, pixim as IntPTR, pixg as IntPTR, sx as Integer, sy as Integer, thresh as Integer, mincount as Integer, bgval as Integer, smoothx as Integer, smoothy as Integer) as IntPTR
End Function

' SRC\adaptmap.c (443, 1)
' pixBackgroundNormMorph()
' pixBackgroundNormMorph(PIX *, PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  * (1) This is a top-level interface for normalizing the image intensity
'''  *  by mapping the image so that the background is near the input
'''  *  value 'bgval'.
'''  * (2) The input image is either grayscale or rgb.
'''  * (3) For each component in the input image, the background value
'''  *  is estimated using a grayscale closing; hence the 'Morph'
'''  *  in the function name.
'''  * (4) An optional binary mask can be specified, with the foreground
'''  *  pixels typically over image regions.  The resulting background
'''  *  map values will be determined by surrounding pixels that are
'''  *  not under the mask foreground.  The origin (0,0) of this mask
'''  *  is assumed to be aligned with the origin of the input image.
'''  *  This binary mask must not fully cover pixs, because then there
'''  *  will be no pixels in the input image available to compute
'''  *  the background.
'''  * (5) The map is computed at reduced size (given by 'reduction')
'''  *  from the input pixs and optional pixim.  At this scale,
'''  *  pixs is closed to remove the background, using a square Sel
'''  *  of odd dimension.  The product of reduction * size should be
'''  *  large enough to remove most of the text foreground.
'''  * (6) No convolutional smoothing needs to be done on the map before
'''  *  inverting it.
'''  * (7) A 'bgval' target background value for the normalized image.  This
'''  *  should be at least 128.  If set too close to 255, some
'''  *  clipping will occur in the result.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale or 32 bpp rgb</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null</param>
''' <param name="reduction"> \param[in]    reduction at which morph closings are done; between 2 and 16</param>
''' <param name="size"> \param[in]    size of square Sel for the closing; use an odd number</param>
''' <param name="bgval"> \param[in]    bgval target bg val; typ. > 128</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBackgroundNormMorph")> _
Friend Shared Function pixBackgroundNormMorph(pixs as IntPTR, pixim as IntPTR, reduction as Integer, size as Integer, bgval as Integer) as IntPTR
End Function

' SRC\adaptmap.c (554, 1)
' pixBackgroundNormGrayArray()
' pixBackgroundNormGrayArray(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  * (1) See notes in pixBackgroundNorm().
'''  * (2) This returns a 16 bpp pix that can be used by
'''  *  pixApplyInvBackgroundGrayMap() to generate a normalized version
'''  *  of the input pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null</param>
''' <param name="sx"> \param[in]    sx, sy tile size in pixels</param>
''' <param name="sy"> \param[in]    thresh threshold for determining foreground</param>
''' <param name="thresh"> \param[in]    mincount min threshold on counts in a tile</param>
''' <param name="mincount"> \param[in]    bgval target bg val; typ. > 128</param>
''' <param name="bgval"> \param[in]    smoothx half-width of block convolution kernel width</param>
''' <param name="smoothx"> \param[in]    smoothy half-width of block convolution kernel height</param>
''' <param name="smoothy"> \param[out]   ppixd 16 bpp array of inverted background value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBackgroundNormGrayArray")> _
Friend Shared Function pixBackgroundNormGrayArray(pixs as IntPTR, pixim as IntPTR, sx as Integer, sy as Integer, thresh as Integer, mincount as Integer, bgval as Integer, smoothx as Integer, smoothy as Integer, ppixd as Object) as Integer
End Function

' SRC\adaptmap.c (631, 1)
' pixBackgroundNormRGBArrays()
' pixBackgroundNormRGBArrays(PIX *, PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  * (1) See notes in pixBackgroundNorm().
'''  * (2) This returns a set of three 16 bpp pix that can be used by
'''  *  pixApplyInvBackgroundGrayMap() to generate a normalized version
'''  *  of each component of the input pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null</param>
''' <param name="pixg"> \param[in]    pixg [optional] 8 bpp grayscale version; can be null</param>
''' <param name="sx"> \param[in]    sx, sy tile size in pixels</param>
''' <param name="sy"> \param[in]    thresh threshold for determining foreground</param>
''' <param name="thresh"> \param[in]    mincount min threshold on counts in a tile</param>
''' <param name="mincount"> \param[in]    bgval target bg val; typ. > 128</param>
''' <param name="bgval"> \param[in]    smoothx half-width of block convolution kernel width</param>
''' <param name="smoothx"> \param[in]    smoothy half-width of block convolution kernel height</param>
''' <param name="smoothy"> \param[out]   ppixr 16 bpp array of inverted R background value</param>
''' <param name="ppixr"> \param[out]   ppixg 16 bpp array of inverted G background value</param>
''' <param name="ppixg"> \param[out]   ppixb 16 bpp array of inverted B background value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBackgroundNormRGBArrays")> _
Friend Shared Function pixBackgroundNormRGBArrays(pixs as IntPTR, pixim as IntPTR, pixg as IntPTR, sx as Integer, sy as Integer, thresh as Integer, mincount as Integer, bgval as Integer, smoothx as Integer, smoothy as Integer, ppixr as Object, ppixg as Object, ppixb as Object) as Integer
End Function

' SRC\adaptmap.c (714, 1)
' pixBackgroundNormGrayArrayMorph()
' pixBackgroundNormGrayArrayMorph(PIX *, PIX *, l_int32, l_int32, l_int32, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  * (1) See notes in pixBackgroundNormMorph().
'''  * (2) This returns a 16 bpp pix that can be used by
'''  *  pixApplyInvBackgroundGrayMap() to generate a normalized version
'''  *  of the input pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null</param>
''' <param name="reduction"> \param[in]    reduction at which morph closings are done; between 2 and 16</param>
''' <param name="size"> \param[in]    size of square Sel for the closing; use an odd number</param>
''' <param name="bgval"> \param[in]    bgval target bg val; typ. > 128</param>
''' <param name="ppixd"> \param[out]   ppixd 16 bpp array of inverted background value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBackgroundNormGrayArrayMorph")> _
Friend Shared Function pixBackgroundNormGrayArrayMorph(pixs as IntPTR, pixim as IntPTR, reduction as Integer, size as Integer, bgval as Integer, ppixd as Object) as Integer
End Function

' SRC\adaptmap.c (779, 1)
' pixBackgroundNormRGBArraysMorph()
' pixBackgroundNormRGBArraysMorph(PIX *, PIX *, l_int32, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  * (1) See notes in pixBackgroundNormMorph().
'''  * (2) This returns a set of three 16 bpp pix that can be used by
'''  *  pixApplyInvBackgroundGrayMap() to generate a normalized version
'''  *  of each component of the input pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null</param>
''' <param name="reduction"> \param[in]    reduction at which morph closings are done; between 2 and 16</param>
''' <param name="size"> \param[in]    size of square Sel for the closing; use an odd number</param>
''' <param name="bgval"> \param[in]    bgval target bg val; typ. > 128</param>
''' <param name="ppixr"> \param[out]   ppixr 16 bpp array of inverted R background value</param>
''' <param name="ppixg"> \param[out]   ppixg 16 bpp array of inverted G background value</param>
''' <param name="ppixb"> \param[out]   ppixb 16 bpp array of inverted B background value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBackgroundNormRGBArraysMorph")> _
Friend Shared Function pixBackgroundNormRGBArraysMorph(pixs as IntPTR, pixim as IntPTR, reduction as Integer, size as Integer, bgval as Integer, ppixr as Object, ppixg as Object, ppixb as Object) as Integer
End Function

' SRC\adaptmap.c (856, 1)
' pixGetBackgroundGrayMap()
' pixGetBackgroundGrayMap(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The background is measured in regions that don't have
'''  * images.  It is then propagated into the image regions,
'''  * and finally smoothed in each image region.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; not cmapped</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null; it</param>
''' <param name="sx"> \param[in]    sx, sy tile size in pixels</param>
''' <param name="sy"> \param[in]    thresh threshold for determining foreground</param>
''' <param name="thresh"> \param[in]    mincount min threshold on counts in a tile</param>
''' <param name="mincount"> \param[out]   ppixd 8 bpp grayscale map</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetBackgroundGrayMap")> _
Friend Shared Function pixGetBackgroundGrayMap(pixs as IntPTR, pixim as IntPTR, sx as Integer, sy as Integer, thresh as Integer, mincount as Integer, ppixd as Object) as Integer
End Function

' SRC\adaptmap.c (1034, 1)
' pixGetBackgroundRGBMap()
' pixGetBackgroundRGBMap(PIX *, PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If pixg, which is a grayscale version of pixs, is provided,
'''  * use this internally to generate the foreground mask.
'''  * Otherwise, a grayscale version of pixs will be generated
'''  * from the green component only, used, and destroyed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null; it</param>
''' <param name="pixg"> \param[in]    pixg [optional] 8 bpp grayscale version; can be null</param>
''' <param name="sx"> \param[in]    sx, sy tile size in pixels</param>
''' <param name="sy"> \param[in]    thresh threshold for determining foreground</param>
''' <param name="thresh"> \param[in]    mincount min threshold on counts in a tile</param>
''' <param name="mincount"> \param[out]   ppixmr, ppixmg, ppixmb rgb maps</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetBackgroundRGBMap")> _
Friend Shared Function pixGetBackgroundRGBMap(pixs as IntPTR, pixim as IntPTR, pixg as IntPTR, sx as Integer, sy as Integer, thresh as Integer, mincount as Integer, ppixmr as Object, ppixmg as Object, ppixmb as Object) as Integer
End Function

' SRC\adaptmap.c (1219, 1)
' pixGetBackgroundGrayMapMorph()
' pixGetBackgroundGrayMapMorph(PIX *, PIX *, l_int32, l_int32, PIX **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; not cmapped</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null; it</param>
''' <param name="reduction"> \param[in]    reduction factor at which closing is performed</param>
''' <param name="size"> \param[in]    size of square Sel for the closing; use an odd number</param>
''' <param name="ppixm"> \param[out]   ppixm grayscale map</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetBackgroundGrayMapMorph")> _
Friend Shared Function pixGetBackgroundGrayMapMorph(pixs as IntPTR, pixim as IntPTR, reduction as Integer, size as Integer, ppixm as Object) as Integer
End Function

' SRC\adaptmap.c (1310, 1)
' pixGetBackgroundRGBMapMorph()
' pixGetBackgroundRGBMapMorph(PIX *, PIX *, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null; it</param>
''' <param name="reduction"> \param[in]    reduction factor at which closing is performed</param>
''' <param name="size"> \param[in]    size of square Sel for the closing; use an odd number</param>
''' <param name="ppixmr"> \param[out]   ppixmr red component map</param>
''' <param name="ppixmg"> \param[out]   ppixmg green component map</param>
''' <param name="ppixmb"> \param[out]   ppixmb blue component map</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetBackgroundRGBMapMorph")> _
Friend Shared Function pixGetBackgroundRGBMapMorph(pixs as IntPTR, pixim as IntPTR, reduction as Integer, size as Integer, ppixmr as Object, ppixmg as Object, ppixmb as Object) as Integer
End Function

' SRC\adaptmap.c (1464, 1)
' pixFillMapHoles()
' pixFillMapHoles(PIX *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place operation on pix (the map).  pix is
'''  * typically a low-resolution version of some other image
'''  * from which it was derived, where each pixel in pix
'''  * corresponds to a rectangular tile (say, m x n) of pixels
'''  * in the larger image.  All we need to know about the larger
'''  * image is whether or not the rightmost column and bottommost
'''  * row of pixels in pix correspond to tiles that are
'''  * only partially covered by pixels in the larger image.
'''  *   (2) Typically, some number of pixels in the input map are
'''  * not known, and their values must be determined by near
'''  * pixels that are known.  These unknown pixels are the 'holes'.
'''  * They can take on only two values, 0 and 255, and the
'''  * instruction about which to fill is given by the filltype flag.
'''  *   (3) The "holes" can come from two sources.  The first is when there
'''  * are not enough foreground or background pixels in a tile;
'''  * the second is when a tile is at least partially covered
'''  * by an image mask.  If we're filling holes in a fg mask,
'''  * the holes are initialized to black (0) and use L_FILL_BLACK.
'''  * For filling holes in a bg mask, initialize the holes to
'''  * white (255) and use L_FILL_WHITE.
'''  *   (4) If w is the map width, nx = w or nx = w - 1; ditto for h and ny.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix 8 bpp; a map, with one pixel for each tile in</param>
''' <param name="nx"> \param[in]    nx number of horizontal pixel tiles that are entirely</param>
''' <param name="ny"> \param[in]    ny ditto for the number of vertical pixel tiles</param>
''' <param name="filltype"> \param[in]    filltype L_FILL_WHITE or L_FILL_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFillMapHoles")> _
Friend Shared Function pixFillMapHoles(pix as IntPTR, nx as Integer, ny as Integer, filltype as Integer) as Integer
End Function

' SRC\adaptmap.c (1576, 1)
' pixExtendByReplication()
' pixExtendByReplication(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The pixel values are extended to the left and down, as required.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd extended with replicated pixel values, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="addw"> \param[in]    addw number of extra pixels horizontally to add</param>
''' <param name="addh"> \param[in]    addh number of extra pixels vertically to add</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExtendByReplication")> _
Friend Shared Function pixExtendByReplication(pixs as IntPTR, addw as Integer, addh as Integer) as IntPTR
End Function

' SRC\adaptmap.c (1639, 1)
' pixSmoothConnectedRegions()
' pixSmoothConnectedRegions(PIX *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The pixels in pixs corresponding to those in each
'''  * 8-connected region in the mask are set to the average value.
'''  *   (2) This is required for adaptive mapping to avoid the
'''  * generation of stripes in the background map, due to
'''  * variations in the pixel values near the edges of mask regions.
'''  *   (3) This function is optimized for background smoothing, where
'''  * there are a relatively small number of components.  It will
'''  * be inefficient if used where there are many small components.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; no colormap</param>
''' <param name="pixm"> \param[in]    pixm [optional] 1 bpp; if null, this is a no-op</param>
''' <param name="factor"> \param[in]    factor subsampling factor for getting average; >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSmoothConnectedRegions")> _
Friend Shared Function pixSmoothConnectedRegions(pixs as IntPTR, pixm as IntPTR, factor as Integer) as Integer
End Function

' SRC\adaptmap.c (1840, 1)
' pixGetInvBackgroundMap()
' pixGetInvBackgroundMap(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *  (1) bgval should typically be > 120 and  240
'''  *  (2) pixd is a normalization image; the original image is
'''  * multiplied by pixd and the result is divided by 256.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 16 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; no colormap</param>
''' <param name="bgval"> \param[in]    bgval target bg val; typ. > 128</param>
''' <param name="smoothx"> \param[in]    smoothx half-width of block convolution kernel width</param>
''' <param name="smoothy"> \param[in]    smoothy half-width of block convolution kernel height</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetInvBackgroundMap")> _
Friend Shared Function pixGetInvBackgroundMap(pixs as IntPTR, bgval as Integer, smoothx as Integer, smoothy as Integer) as IntPTR
End Function

' SRC\adaptmap.c (1903, 1)
' pixApplyInvBackgroundGrayMap()
' pixApplyInvBackgroundGrayMap(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; no colormap</param>
''' <param name="pixm"> \param[in]    pixm 16 bpp, inverse background map</param>
''' <param name="sx"> \param[in]    sx tile width in pixels</param>
''' <param name="sy"> \param[in]    sy tile height in pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixApplyInvBackgroundGrayMap")> _
Friend Shared Function pixApplyInvBackgroundGrayMap(pixs as IntPTR, pixm as IntPTR, sx as Integer, sy as Integer) as IntPTR
End Function

' SRC\adaptmap.c (1969, 1)
' pixApplyInvBackgroundRGBMap()
' pixApplyInvBackgroundRGBMap(PIX *, PIX *, PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp rbg, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rbg</param>
''' <param name="pixmr"> \param[in]    pixmr 16 bpp, red inverse background map</param>
''' <param name="pixmg"> \param[in]    pixmg 16 bpp, green inverse background map</param>
''' <param name="pixmb"> \param[in]    pixmb 16 bpp, blue inverse background map</param>
''' <param name="sx"> \param[in]    sx tile width in pixels</param>
''' <param name="sy"> \param[in]    sy tile height in pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixApplyInvBackgroundRGBMap")> _
Friend Shared Function pixApplyInvBackgroundRGBMap(pixs as IntPTR, pixmr as IntPTR, pixmg as IntPTR, pixmb as IntPTR, sx as Integer, sy as Integer) as IntPTR
End Function

' SRC\adaptmap.c (2067, 1)
' pixApplyVariableGrayMap()
' pixApplyVariableGrayMap(PIX *, PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Suppose you have an image that you want to transform based
'''  * on some photometric measurement at each point, such as the
'''  * threshold value for binarization.  Representing the photometric
'''  * measurement as an image pixg, you can threshold in input image
'''  * using pixVarThresholdToBinary().  Alternatively, you can map
'''  * the input image pointwise so that the threshold over the
'''  * entire image becomes a constant, such as 128.  For example,
'''  * if a pixel in pixg is 150 and the target is 128, the
'''  * corresponding pixel in pixs is mapped linearly to a value
'''  * (128/150) of the input value.  If the resulting mapped image
'''  * pixd were then thresholded at 128, you would obtain the
'''  * same result as a direct binarization using pixg with
'''  * pixVarThresholdToBinary().
'''  *   (2) The sizes of pixs and pixg must be equal.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="pixg"> \param[in]    pixg 8 bpp, variable map</param>
''' <param name="target"> \param[in]    target typ. 128 for threshold</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixApplyVariableGrayMap")> _
Friend Shared Function pixApplyVariableGrayMap(pixs as IntPTR, pixg as IntPTR, target as Integer) as IntPTR
End Function

' SRC\adaptmap.c (2185, 1)
' pixGlobalNormRGB()
' pixGlobalNormRGB(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  * (1) The value of pixd determines if the results are written to a
'''  *  new pix (use NULL), in-place to pixs (use pixs), or to some
'''  *  other existing pix.
'''  * (2) This does a global normalization of an image where the
'''  *  r,g,b color components are not balanced.  Thus, white in pixs is
'''  *  represented by a set of r,g,b values that are not all 255.
'''  * (3) The input values (rval, gval, bval) should be chosen to
'''  *  represent the gray color (mapval, mapval, mapval) in src.
'''  *  Thus, this function will map (rval, gval, bval) to that gray color.
'''  * (4) Typically, mapval = 255, so that (rval, gval, bval)
'''  *  corresponds to the white point of src.  In that case, these
'''  *  parameters should be chosen so that few pixels have higher values.
'''  * (5) In all cases, we do a linear TRC separately on each of the
'''  *  components, saturating at 255.
'''  * (6) If the input pix is 8 bpp without a colormap, you can get
'''  *  this functionality with mapval = 255 by calling:
'''  *   pixGammaTRC(pixd, pixs, 1.0, 0, bgval);
'''  *  where bgval is the value you want to be mapped to 255.
'''  *  Or more generally, if you want bgval to be mapped to mapval:
'''  *   pixGammaTRC(pixd, pixs, 1.0, 0, 255 * bgval / mapval);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp rgb or colormapped, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd [optional] null, existing or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb, or colormapped</param>
''' <param name="rval"> \param[in]    rval, gval, bval pixel values in pixs that are</param>
''' <param name="gval"> \param[in]    mapval use 255 for mapping to white</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGlobalNormRGB")> _
Friend Shared Function pixGlobalNormRGB(pixd as IntPTR, pixs as IntPTR, rval as Integer, gval as Integer, bval as Integer, mapval as Integer) as IntPTR
End Function

' SRC\adaptmap.c (2294, 1)
' pixGlobalNormNoSatRGB()
' pixGlobalNormNoSatRGB(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  * (1) This is a version of pixGlobalNormRGB(), where the output
'''  *  intensity is scaled back so that a controlled fraction of
'''  *  pixel components is allowed to saturate.  See comments in
'''  *  pixGlobalNormRGB().
'''  * (2) The value of pixd determines if the results are written to a
'''  *  new pix (use NULL), in-place to pixs (use pixs), or to some
'''  *  other existing pix.
'''  * (3) This does a global normalization of an image where the
'''  *  r,g,b color components are not balanced.  Thus, white in pixs is
'''  *  represented by a set of r,g,b values that are not all 255.
'''  * (4) The input values (rval, gval, bval) can be chosen to be the
'''  *  color that, after normalization, becomes white background.
'''  *  For images that are mostly background, the closer these values
'''  *  are to the median component values, the closer the resulting
'''  *  background will be to gray, becoming white at the brightest places.
'''  * (5) The mapval used in pixGlobalNormRGB() is computed here to
'''  *  avoid saturation of any component in the image (save for a
'''  *  fraction of the pixels given by the input rank value).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp rgb, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd [optional] null, existing or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="rval"> \param[in]    rval, gval, bval pixel values in pixs that are</param>
''' <param name="gval"> \param[in]    factor subsampling factor; integer >= 1</param>
''' <param name="bval"> \param[in]    rank between 0.0 and 1.0; typ. use a value near 1.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGlobalNormNoSatRGB")> _
Friend Shared Function pixGlobalNormNoSatRGB(pixd as IntPTR, pixs as IntPTR, rval as Integer, gval as Integer, bval as Integer, factor as Integer, rank as single) as IntPTR
End Function

' SRC\adaptmap.c (2394, 1)
' pixThresholdSpreadNorm()
' pixThresholdSpreadNorm(PIX *, l_int32, l_int32, l_int32, l_int32, l_float32, l_int32, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The basis of this approach is the use of seed spreading
'''  * on a (possibly) sparse set of estimates for the local threshold.
'''  * The resulting dense estimates are smoothed by convolution
'''  * and used to either threshold the input image or normalize it
'''  * with a local transformation that linearly maps the pixels so
'''  * that the local threshold estimate becomes constant over the
'''  * resulting image.  This approach is one of several that
'''  * have been suggested (and implemented) by Ray Smith.
'''  *   (2) You can use either the Sobel or TwoSided edge filters.
'''  * The results appear to be similar, using typical values
'''  * of edgethresh in the rang 10-20.
'''  *   (3) To skip the trc enhancement, use gamma = 1.0, minval = 0
'''  * and maxval = 255.
'''  *   (4) For the normalized image pixd, each pixel is linearly mapped
'''  * in such a way that the local threshold is equal to targetthresh.
'''  *   (5) The full width and height of the convolution kernel
'''  * are (2 * smoothx + 1) and (2 * smoothy + 1).
'''  *   (6) This function can be used with the pixtiling utility if the
'''  * images are too large.  See pixOtsuAdaptiveThreshold() for
'''  * an example of this.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; not colormapped</param>
''' <param name="filtertype"> \param[in]    filtertype L_SOBEL_EDGE or L_TWO_SIDED_EDGE;</param>
''' <param name="edgethresh"> \param[in]    edgethresh threshold on magnitude of edge filter; typ 10-20</param>
''' <param name="smoothx"> \param[in]    smoothx, smoothy half-width of convolution kernel applied to</param>
''' <param name="smoothy"> \param[in]    gamma gamma correction; typ. about 0.7</param>
''' <param name="gamma"> \param[in]    minval  input value that gives 0 for output; typ. -25</param>
''' <param name="minval"> \param[in]    maxval  input value that gives 255 for output; typ. 255</param>
''' <param name="maxval"> \param[in]    targetthresh target threshold for normalization</param>
''' <param name="targetthresh"> \param[out]   ppixth [optional] computed local threshold value</param>
''' <param name="ppixth"> \param[out]   ppixb [optional] thresholded normalized image</param>
''' <param name="ppixb"> \param[out]   ppixd [optional] normalized image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixThresholdSpreadNorm")> _
Friend Shared Function pixThresholdSpreadNorm(pixs as IntPTR, filtertype as Integer, edgethresh as Integer, smoothx as Integer, smoothy as Integer, gamma as single, minval as Integer, maxval as Integer, targetthresh as Integer, ppixth as Object, ppixb as Object, ppixd as Object) as Integer
End Function

' SRC\adaptmap.c (2500, 1)
' pixBackgroundNormFlex()
' pixBackgroundNormFlex(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does adaptation flexibly to a quickly varying background.
'''  * For that reason, all input parameters should be small.
'''  *   (2) sx and sy give the tile size; they should be in [5 - 7].
'''  *   (3) The full width and height of the convolution kernel
'''  * are (2 * smoothx + 1) and (2 * smoothy + 1).  They
'''  * should be in [1 - 2].
'''  *   (4) Basin filling is used to fill the large fg regions.  The
'''  * parameter %delta measures the height that the black
'''  * background is raised from the local minima.  By raising
'''  * the background, it is possible to threshold the large
'''  * fg regions to foreground.  If %delta is too large,
'''  * bg regions will be lifted, causing thickening of
'''  * the fg regions.  Use 0 to skip.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, background-normalized), or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; not colormapped</param>
''' <param name="sx"> \param[in]    sx, sy desired tile dimensions; actual size may vary; use</param>
''' <param name="sy"> \param[in]    smoothx, smoothy half-width of convolution kernel applied to</param>
''' <param name="smoothx"> \param[in]    delta difference parameter in basin filling; use 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBackgroundNormFlex")> _
Friend Shared Function pixBackgroundNormFlex(pixs as IntPTR, sx as Integer, sy as Integer, smoothx as Integer, smoothy as Integer, delta as Integer) as IntPTR
End Function

' SRC\adaptmap.c (2595, 1)
' pixContrastNorm()
' pixContrastNorm(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function adaptively attempts to expand the contrast
'''  * to the full dynamic range in each tile.  If the contrast in
'''  * a tile is smaller than %mindiff, it uses the min and max
'''  * pixel values from neighboring tiles.  It also can use
'''  * convolution to smooth the min and max values from
'''  * neighboring tiles.  After all that processing, it is
'''  * possible that the actual pixel values in the tile are outside
'''  * the computed [min ... max] range for local contrast
'''  * normalization.  Such pixels are taken to be at either 0
'''  * (if below the min) or 255 (if above the max).
'''  *   (2) pixd can be equal to pixs (in-place operation) or
'''  * null (makes a new pixd).
'''  *   (3) sx and sy give the tile size; they are typically at least 20.
'''  *   (4) mindiff is used to eliminate results for tiles where it is
'''  * likely that either fg or bg is missing.  A value around 50
'''  * or more is reasonable.
'''  *   (5) The full width and height of the convolution kernel
'''  * are (2 * smoothx + 1) and (2 * smoothy + 1).  Some smoothing
'''  * is typically useful, and we limit the smoothing half-widths
'''  * to the range from 0 to 8.
'''  *   (6) A linear TRC (gamma = 1.0) is applied to increase the contrast
'''  * in each tile.  The result can subsequently be globally corrected,
'''  * by applying pixGammaTRC() with arbitrary values of gamma
'''  * and the 0 and 255 points of the mapping.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd [optional] 8 bpp; null or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; not colormapped</param>
''' <param name="sx"> \param[in]    sx, sy tile dimensions</param>
''' <param name="sy"> \param[in]    mindiff minimum difference to accept as valid</param>
''' <param name="mindiff"> \param[in]    smoothx, smoothy half-width of convolution kernel applied to</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixContrastNorm")> _
Friend Shared Function pixContrastNorm(pixd as IntPTR, pixs as IntPTR, sx as Integer, sy as Integer, mindiff as Integer, smoothx as Integer, smoothy as Integer) as IntPTR
End Function

' SRC\adaptmap.c (2655, 1)
' pixMinMaxTiles()
' pixMinMaxTiles(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This computes filtered and smoothed values for the min and
'''  * max pixel values in each tile of the image.
'''  *   (2) See pixContrastNorm() for usage.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; not colormapped</param>
''' <param name="sx"> \param[in]    sx, sy tile dimensions</param>
''' <param name="sy"> \param[in]    mindiff minimum difference to accept as valid</param>
''' <param name="mindiff"> \param[in]    smoothx, smoothy half-width of convolution kernel applied to</param>
''' <param name="smoothx"> \param[out]   ppixmin tiled minima</param>
''' <param name="smoothy"> \param[out]   ppixmax tiled maxima</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMinMaxTiles")> _
Friend Shared Function pixMinMaxTiles(pixs as IntPTR, sx as Integer, sy as Integer, mindiff as Integer, smoothx as Integer, smoothy as Integer, ppixmin as Object, ppixmax as Object) as Integer
End Function

' SRC\adaptmap.c (2746, 1)
' pixSetLowContrast()
' pixSetLowContrast(PIX *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This compares corresponding pixels in pixs1 and pixs2.
'''  * When they differ by less than %mindiff, set the pixel
'''  * values to 0 in each.  Each pixel typically represents a tile
'''  * in a larger image, and a very small difference between
'''  * the min and max in the tile indicates that the min and max
'''  * values are not to be trusted.
'''  *   (2) If contrast (pixel difference) detection is expected to fail,
'''  * caller should check return value.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 if no pixel diffs are large enough, or on error</returns>
''' <param name="pixs1"> \param[in]    pixs1 8 bpp</param>
''' <param name="pixs2"> \param[in]    pixs2 8 bpp</param>
''' <param name="mindiff"> \param[in]    mindiff minimum difference to accept as valid</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetLowContrast")> _
Friend Shared Function pixSetLowContrast(pixs1 as IntPTR, pixs2 as IntPTR, mindiff as Integer) as Integer
End Function

' SRC\adaptmap.c (2829, 1)
' pixLinearTRCTiled()
' pixLinearTRCTiled(PIX *, PIX *, l_int32, l_int32, PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pixd can be equal to pixs (in-place operation) or
'''  * null (makes a new pixd).
'''  *   (2) sx and sy give the tile size; they are typically at least 20.
'''  *   (3) pixmin and pixmax are generated by pixMinMaxTiles()
'''  *   (4) For each tile, this does a linear expansion of the dynamic
'''  * range so that the min value in the tile becomes 0 and the
'''  * max value in the tile becomes 255.
'''  *   (5) The LUTs that do the mapping are generated as needed
'''  * and stored for reuse in an integer array within the ptr array iaa[].
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd [optional] 8 bpp</param>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not colormapped</param>
''' <param name="sx"> \param[in]    sx, sy tile dimensions</param>
''' <param name="sy"> \param[in]    pixmin pix of min values in tiles</param>
''' <param name="pixmin"> \param[in]    pixmax pix of max values in tiles</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixLinearTRCTiled")> _
Friend Shared Function pixLinearTRCTiled(pixd as IntPTR, pixs as IntPTR, sx as Integer, sy as Integer, pixmin as IntPTR, pixmax as IntPTR) as IntPTR
End Function

#End Region
#Region "SRC\affine.c"
' SRC\affine.c (280, 1)
' pixAffineSampledPta()
' pixAffineSampledPta(PIX *, PTA *, PTA *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Brings in either black or white pixels from the boundary.
'''  *   (2) Retains colormap, which you can do for a sampled transform..
'''  *   (3) The 3 points must not be collinear.
'''  *   (4) The order of the 3 points is arbitrary; however, to compare
'''  * with the sequential transform they must be in these locations
'''  * and in this order: origin, x-axis, y-axis.
'''  *   (5) For 1 bpp images, this has much better quality results
'''  * than pixAffineSequential(), particularly for text.
'''  * It is about 3x slower, but does not require additional
'''  * border pixels.  The poor quality of pixAffineSequential()
'''  * is due to repeated quantized transforms.  It is strongly
'''  * recommended that pixAffineSampled() be used for 1 bpp images.
'''  *   (6) For 8 or 32 bpp, much better quality is obtained by the
'''  * somewhat slower pixAffinePta().  See that function
'''  * for relative timings between sampled and interpolated.
'''  *   (7) To repeat, use of the sequential transform,
'''  * pixAffineSequential(), for any images, is discouraged.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths</param>
''' <param name="ptad"> \param[in]    ptad  3 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  3 pts of initial coordinate space</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAffineSampledPta")> _
Friend Shared Function pixAffineSampledPta(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, incolor as Integer) as IntPTR
End Function

' SRC\affine.c (330, 1)
' pixAffineSampled()
' pixAffineSampled(PIX *, l_float32 *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Brings in either black or white pixels from the boundary.
'''  *   (2) Retains colormap, which you can do for a sampled transform..
'''  *   (3) For 8 or 32 bpp, much better quality is obtained by the
'''  * somewhat slower pixAffine().  See that function
'''  * for relative timings between sampled and interpolated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths</param>
''' <param name="vc"> \param[in]    vc  vector of 6 coefficients for affine transformation</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAffineSampled")> _
Friend Shared Function pixAffineSampled(pixs as IntPTR, vc as single, incolor as Integer) as IntPTR
End Function

' SRC\affine.c (423, 1)
' pixAffinePta()
' pixAffinePta(PIX *, PTA *, PTA *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Brings in either black or white pixels from the boundary
'''  *   (2) Removes any existing colormap, if necessary, before transforming
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths; colormap ok</param>
''' <param name="ptad"> \param[in]    ptad  3 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  3 pts of initial coordinate space</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAffinePta")> _
Friend Shared Function pixAffinePta(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, incolor as Integer) as IntPTR
End Function

' SRC\affine.c (493, 1)
' pixAffine()
' pixAffine(PIX *, l_float32 *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Brings in either black or white pixels from the boundary
'''  *   (2) Removes any existing colormap, if necessary, before transforming
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths; colormap ok</param>
''' <param name="vc"> \param[in]    vc  vector of 6 coefficients for affine transformation</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAffine")> _
Friend Shared Function pixAffine(pixs as IntPTR, vc as single, incolor as Integer) as IntPTR
End Function

' SRC\affine.c (549, 1)
' pixAffinePtaColor()
' pixAffinePtaColor(PIX *, PTA *, PTA *, l_uint32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="ptad"> \param[in]    ptad  3 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  3 pts of initial coordinate space</param>
''' <param name="colorval"> \param[in]    colorval e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAffinePtaColor")> _
Friend Shared Function pixAffinePtaColor(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, colorval as UInteger) as IntPTR
End Function

' SRC\affine.c (590, 1)
' pixAffineColor()
' pixAffineColor(PIX *, l_float32 *, l_uint32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="vc"> \param[in]    vc  vector of 6 coefficients for affine transformation</param>
''' <param name="colorval"> \param[in]    colorval e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAffineColor")> _
Friend Shared Function pixAffineColor(pixs as IntPTR, vc as single, colorval as UInteger) as IntPTR
End Function

' SRC\affine.c (652, 1)
' pixAffinePtaGray()
' pixAffinePtaGray(PIX *, PTA *, PTA *, l_uint8) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="ptad"> \param[in]    ptad  3 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  3 pts of initial coordinate space</param>
''' <param name="grayval"> \param[in]    grayval 0 to bring in BLACK, 255 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAffinePtaGray")> _
Friend Shared Function pixAffinePtaGray(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, grayval as Byte) as IntPTR
End Function

' SRC\affine.c (694, 1)
' pixAffineGray()
' pixAffineGray(PIX *, l_float32 *, l_uint8) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="vc"> \param[in]    vc  vector of 6 coefficients for affine transformation</param>
''' <param name="grayval"> \param[in]    grayval 0 to bring in BLACK, 255 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAffineGray")> _
Friend Shared Function pixAffineGray(pixs as IntPTR, vc as single, grayval as Byte) as IntPTR
End Function

' SRC\affine.c (782, 1)
' pixAffinePtaWithAlpha()
' pixAffinePtaWithAlpha(PIX *, PTA *, PTA *, PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The alpha channel is transformed separately from pixs,
'''  * and aligns with it, being fully transparent outside the
'''  * boundary of the transformed pixs.  For pixels that are fully
'''  * transparent, a blending function like pixBlendWithGrayMask()
'''  * will give zero weight to corresponding pixels in pixs.
'''  *   (2) If pixg is NULL, it is generated as an alpha layer that is
'''  * partially opaque, using %fract.  Otherwise, it is cropped
'''  * to pixs if required and %fract is ignored.  The alpha channel
'''  * in pixs is never used.
'''  *   (3) Colormaps are removed.
'''  *   (4) When pixs is transformed, it doesn't matter what color is brought
'''  * in because the alpha channel will be transparent (0) there.
'''  *   (5) To avoid losing source pixels in the destination, it may be
'''  * necessary to add a border to the source pix before doing
'''  * the affine transformation.  This can be any non-negative number.
'''  *   (6) The input %ptad and %ptas are in a coordinate space before
'''  * the border is added.  Internally, we compensate for this
'''  * before doing the affine transform on the image after the border
'''  * is added.
'''  *   (7) The default setting for the border values in the alpha channel
'''  * is 0 (transparent) for the outermost ring of pixels and
'''  * (0.5 * fract * 255) for the second ring.  When blended over
'''  * a second image, this
'''  * (a) shrinks the visible image to make a clean overlap edge
'''  *  with an image below, and
'''  * (b) softens the edges by weakening the aliasing there.
'''  * Use l_setAlphaMaskBorder() to change these values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="ptad"> \param[in]    ptad  3 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  3 pts of initial coordinate space</param>
''' <param name="pixg"> \param[in]    pixg [optional] 8 bpp, can be null</param>
''' <param name="fract"> \param[in]    fract between 0.0 and 1.0, with 0.0 fully transparent</param>
''' <param name="border"> \param[in]    border of pixels added to capture transformed source pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAffinePtaWithAlpha")> _
Friend Shared Function pixAffinePtaWithAlpha(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, pixg as IntPTR, fract as single, border as Integer) as IntPTR
End Function

' SRC\affine.c (931, 1)
' getAffineXformCoeffs()
' getAffineXformCoeffs(PTA *, PTA *, l_float32 **) as l_ok
''' <summary>
''' *  We have a set of six equations, describing the affine
'''  *  transformation that takes 3 points ptas into 3 other
'''  *  points ptad.  These equations are:
'''  *
'''  * x1' = c[0]*x1 + c[1]*y1 + c[2]
'''  * y1' = c[3]*x1 + c[4]*y1 + c[5]
'''  * x2' = c[0]*x2 + c[1]*y2 + c[2]
'''  * y2' = c[3]*x2 + c[4]*y2 + c[5]
'''  * x3' = c[0]*x3 + c[1]*y3 + c[2]
'''  * y3' = c[3]*x3 + c[4]*y3 + c[5]
'''  *
'''  *  This can be represented as
'''  *
'''  * AC = B
'''  *
'''  *  where B and C are column vectors
'''  *
'''  * B = [ x1' y1' x2' y2' x3' y3' ]
'''  * C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] ]
'''  *
'''  *  and A is the 6x6 matrix
'''  *
'''  * x1   y1   1   0 0 0
'''  *  0 0   0   x1   y1   1
'''  * x2   y2   1   0 0 0
'''  *  0 0   0   x2   y2   1
'''  * x3   y3   1   0 0 0
'''  *  0 0   0   x3   y3   1
'''  *
'''  *  These six equations are solved here for the coefficients C.
'''  *
'''  *  These six coefficients can then be used to find the dest
'''  *  point x',y') corresponding to any src point (x,y, according
'''  *  to the equations
'''  *
'''  *  x' = c[0]x + c[1]y + c[2]
'''  *  y' = c[3]x + c[4]y + c[5]
'''  *
'''  *  that are implemented in affineXformPt.
'''  *
'''  *  !!!!!!!!!!!!!!!!!!   Very important   !!!!!!!!!!!!!!!!!!!!!!
'''  *
'''  *  When the affine transform is composed from a set of simple
'''  *  operations such as translation, scaling and rotation,
'''  *  it is built in a form to convert from the un-transformed src
'''  *  point to the transformed dest point.  However, when an
'''  *  affine transform is used on images, it is used in an inverted
'''  *  way: it converts from the transformed dest point to the
'''  *  un-transformed src point.  So, for example, if you transform
'''  *  a boxa using transform A, to transform an image in the same
'''  *  way you must use the inverse of A.
'''  *
'''  *  For example, if you transform a boxa with a 3x3 affine matrix
'''  *  'mat', the analogous image transformation must use 'matinv':
'''  * \code
'''  *  boxad = boxaAffineTransform(boxas, mat);
'''  *  affineInvertXform(mat, &matinv);
'''  *  pixd = pixAffine(pixs, matinv, L_BRING_IN_WHITE);
'''  * \endcode
'''  *  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="ptas"> \param[in]    ptas  source 3 points; unprimed</param>
''' <param name="ptad"> \param[in]    ptad  transformed 3 points; primed</param>
''' <param name="pvc"> \param[out]   pvc   vector of coefficients of transform</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getAffineXformCoeffs")> _
Friend Shared Function getAffineXformCoeffs(ptas as IntPTR, ptad as IntPTR, pvc as Object) as Integer
End Function

' SRC\affine.c (1024, 1)
' affineInvertXform()
' affineInvertXform(l_float32 *, l_float32 **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The 6 affine transform coefficients are the first
'''  * two rows of a 3x3 matrix where the last row has
'''  * only a 1 in the third column.  We invert this
'''  * using gaussjordan(), and select the first 2 rows
'''  * as the coefficients of the inverse affine transform.
'''  *   (2) Alternatively, we can find the inverse transform
'''  * coefficients by inverting the 2x2 submatrix,
'''  * and treating the top 2 coefficients in the 3rd column as
'''  * a RHS vector for that 2x2 submatrix.  Then the
'''  * 6 inverted transform coefficients are composed of
'''  * the inverted 2x2 submatrix and the negative of the
'''  * transformed RHS vector.  Why is this so?  We have
'''  * Y = AX + R  (2 equations in 6 unknowns)
'''  * Then
'''  * X = A'Y - A'R
'''  * Gauss-jordan solves
'''  * AF = R
'''  * and puts the solution for F, which is A'R,
'''  * into the input R vector.
'''  *
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="vc"> \param[in]    vc vector of 6 coefficients</param>
''' <param name="pvci"> \param[out]   pvci inverted transform</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="affineInvertXform")> _
Friend Shared Function affineInvertXform(vc as single, pvci as Object) as Integer
End Function

' SRC\affine.c (1107, 1)
' affineXformSampledPt()
' affineXformSampledPt(l_float32 *, l_int32, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds the nearest pixel coordinates of the transformed point.
'''  *   (2) It does not check ptrs for returned data!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="vc"> \param[in]    vc vector of 6 coefficients</param>
''' <param name="x"> \param[in]    x, y  initial point</param>
''' <param name="y"> \param[out]   pxp, pyp   transformed point</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="affineXformSampledPt")> _
Friend Shared Function affineXformSampledPt(vc as single, x as Integer, y as Integer, pxp as Integer, pyp as Integer) as Integer
End Function

' SRC\affine.c (1139, 1)
' affineXformPt()
' affineXformPt(l_float32 *, l_int32, l_int32, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This computes the floating point location of the transformed point.
'''  *   (2) It does not check ptrs for returned data!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="vc"> \param[in]    vc vector of 6 coefficients</param>
''' <param name="x"> \param[in]    x, y  initial point</param>
''' <param name="y"> \param[out]   pxp, pyp   transformed point</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="affineXformPt")> _
Friend Shared Function affineXformPt(vc as single, x as Integer, y as Integer, pxp as single, pyp as single) as Integer
End Function

' SRC\affine.c (1180, 1)
' linearInterpolatePixelColor()
' linearInterpolatePixelColor(l_uint32 *, l_int32, l_int32, l_int32, l_float32, l_float32, l_uint32, l_uint32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a standard linear interpolation function.  It is
'''  * equivalent to area weighting on each component, and
'''  * avoids "jaggies" when rendering sharp edges.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="datas"> \param[in]    datas ptr to beginning of image data</param>
''' <param name="wpls"> \param[in]    wpls 32-bit word/line for this data array</param>
''' <param name="w"> \param[in]    w, h of image</param>
''' <param name="h"> \param[in]    x, y floating pt location for evaluation</param>
''' <param name="x"> \param[in]    colorval color brought in from the outside when the</param>
''' <param name="y"> \param[out]   pval interpolated color value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="linearInterpolatePixelColor")> _
Friend Shared Function linearInterpolatePixelColor(datas as UInteger, wpls as Integer, w as Integer, h as Integer, x as single, y as single, colorval as UInteger, pval as UInteger) as Integer
End Function

' SRC\affine.c (1267, 1)
' linearInterpolatePixelGray()
' linearInterpolatePixelGray(l_uint32 *, l_int32, l_int32, l_int32, l_float32, l_float32, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a standard linear interpolation function.  It is
'''  * equivalent to area weighting on each component, and
'''  * avoids "jaggies" when rendering sharp edges.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="datas"> \param[in]    datas ptr to beginning of image data</param>
''' <param name="wpls"> \param[in]    wpls 32-bit word/line for this data array</param>
''' <param name="w"> \param[in]    w, h of image</param>
''' <param name="h"> \param[in]    x, y floating pt location for evaluation</param>
''' <param name="x"> \param[in]    grayval color brought in from the outside when the</param>
''' <param name="y"> \param[out]   pval interpolated gray value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="linearInterpolatePixelGray")> _
Friend Shared Function linearInterpolatePixelGray(datas as UInteger, wpls as Integer, w as Integer, h as Integer, x as single, y as single, grayval as Integer, pval as Integer) as Integer
End Function

' SRC\affine.c (1346, 1)
' gaussjordan()
' gaussjordan(l_float32 **, l_float32 *, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) There are two side-effects:
'''  * * The matrix a is transformed to its inverse A
'''  * * The rhs vector b is transformed to the solution x
'''  *   of the linear equation ax = b
'''  *   (2) The inverse A can then be used to solve the same equation with
'''  * different rhs vectors c by multiplication: x = Ac
'''  *   (3) Adapted from "Numerical Recipes in C, Second Edition", 1992,
'''  * pp. 36-41 (gauss-jordan elimination)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if ok, 1 on error</returns>
''' <param name="a"> \param[in]    a  n x n matrix</param>
''' <param name="b"> \param[in]    b  n x 1 right-hand side column vector</param>
''' <param name="n"> \param[in]    n  dimension</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gaussjordan")> _
Friend Shared Function gaussjordan(a as Object, b as single, n as Integer) as Integer
End Function

' SRC\affine.c (1470, 1)
' pixAffineSequential()
' pixAffineSequential(PIX *, PTA *, PTA *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The 3 pts must not be collinear.
'''  *   (2) The 3 pts must be given in this order:
'''  *  ~ origin
'''  *  ~ a location along the x-axis
'''  *  ~ a location along the y-axis.
'''  *   (3) You must guess how much border must be added so that no
'''  * pixels are lost in the transformations from src to
'''  * dest coordinate space.  (This can be calculated but it
'''  * is a lot of work!)  For coordinate spaces that are nearly
'''  * at right angles, on a 300 ppi scanned page, the addition
'''  * of 1000 pixels on each side is usually sufficient.
'''  *   (4) This is here for pedagogical reasons.  It is about 3x faster
'''  * on 1 bpp images than pixAffineSampled(), but the results
'''  * on text are much inferior.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="ptad"> \param[in]    ptad  3 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  3 pts of initial coordinate space</param>
''' <param name="bw"> \param[in]    bw    pixels of additional border width during computation</param>
''' <param name="bh"> \param[in]    bh    pixels of additional border height during computation</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAffineSequential")> _
Friend Shared Function pixAffineSequential(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, bw as Integer, bh as Integer) as IntPTR
End Function

#End Region
#Region "SRC\affinecompose.c"
' SRC\affinecompose.c (90, 1)
' createMatrix2dTranslate()
' createMatrix2dTranslate(l_float32, l_float32) as l_float32 *
''' <summary>
''' * Notes:
'''  *   (1) The translation is equivalent to:
'''  * v' = Av
'''  * where v and v' are 1x3 column vectors in the form
'''  * v = [x, y, 1]^ ^ denotes transpose
'''  * and the affine translation matrix is
'''  * A = [ 1   0   tx
'''  *    0   1   ty
'''  *    0   0 1  ]
'''  *
'''  *   (2) We consider translation as with respect to a fixed origin.
'''  * In a clipping operation, the origin moves and the points
'''  * are fixed, and you use (-tx, -ty) where (tx, ty) is the
'''  * translation vector of the origin.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  3x3 transform matrix, or NULL on error</returns>
''' <param name="transx"> \param[in]    transx  x component of translation wrt. the origin</param>
''' <param name="transy"> \param[in]    transy  y component of translation wrt. the origin</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="createMatrix2dTranslate")> _
Friend Shared Function createMatrix2dTranslate(transx as single, transy as single) as String
End Function

' SRC\affinecompose.c (130, 1)
' createMatrix2dScale()
' createMatrix2dScale(l_float32, l_float32) as l_float32 *
''' <summary>
''' * Notes:
'''  *   (1) The scaling is equivalent to:
'''  * v' = Av
'''  *   where v and v' are 1x3 column vectors in the form
'''  *  v = [x, y, 1]^ ^ denotes transpose
'''  *   and the affine scaling matrix is
'''  * A = [ sx  0 0
'''  *    0   sy   0
'''  *    0   0 1  ]
'''  *
'''  *   (2) We consider scaling as with respect to a fixed origin.
'''  * In other words, the origin is the only point that doesn't
'''  * move in the scaling transform.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  3x3 transform matrix, or NULL on error</returns>
''' <param name="scalex"> \param[in]    scalex  horizontal scale factor</param>
''' <param name="scaley"> \param[in]    scaley  vertical scale factor</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="createMatrix2dScale")> _
Friend Shared Function createMatrix2dScale(scalex as single, scaley as single) as String
End Function

' SRC\affinecompose.c (182, 1)
' createMatrix2dRotate()
' createMatrix2dRotate(l_float32, l_float32, l_float32) as l_float32 *
''' <summary>
''' * Notes:
'''  *   (1) The rotation is equivalent to:
'''  * v' = Av
'''  * where v and v' are 1x3 column vectors in the form
'''  * v = [x, y, 1]^ ^ denotes transpose
'''  * and the affine rotation matrix is
'''  * A = [ cosa   -sina xc*1-cosa + yc*sina
'''  *    sina cosa yc*1-cosa - xc*sina
'''  *   0 0  1   ]
'''  *
'''  * If the rotation is about the origin, xc, yc) = (0, 0 and
'''  * this simplifies to
'''  * A = [ cosa   -sina 0
'''  *    sina cosa 0
'''  *   0 0  1 ]
'''  *
'''  * These relations follow from the following equations, which
'''  * you can convince yourself are correct as follows.  Draw a
'''  * circle centered on xc,yc) and passing through (x,y), with
'''  * (x',y') on the arc at an angle 'a' clockwise from (x,y).
'''  *  [ Hint: cosa + b = cosa * cosb - sina * sinb
'''  *    sina + b = sina * cosb + cosa * sinb ]
'''  *
'''  *   x' - xc =  x - xc) * cosa - (y - yc * sina
'''  *   y' - yc =  x - xc) * sina + (y - yc * cosa
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  3x3 transform matrix, or NULL on error</returns>
''' <param name="xc"> \param[in]    xc, yc  location of center of rotation</param>
''' <param name="yc"> \param[in]    angle  rotation in radians; clockwise is positive</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="createMatrix2dRotate")> _
Friend Shared Function createMatrix2dRotate(xc as single, yc as single, angle as single) as String
End Function

' SRC\affinecompose.c (223, 1)
' ptaTranslate()
' ptaTranslate(PTA *, l_float32, l_float32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) See createMatrix2dTranslate() for details of transform.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad  translated points, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas for initial points</param>
''' <param name="transx"> \param[in]    transx  x component of translation wrt. the origin</param>
''' <param name="transy"> \param[in]    transy  y component of translation wrt. the origin</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaTranslate")> _
Friend Shared Function ptaTranslate(ptas as IntPTR, transx as single, transy as single) as IntPTR
End Function

' SRC\affinecompose.c (262, 1)
' ptaScale()
' ptaScale(PTA *, l_float32, l_float32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) See createMatrix2dScale() for details of transform.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="ptas"> \param[in]    ptas for initial points</param>
''' <param name="scalex"> \param[in]    scalex  horizontal scale factor</param>
''' <param name="scaley"> \param[in]    scaley  vertical scale factor</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaScale")> _
Friend Shared Function ptaScale(ptas as IntPTR, scalex as single, scaley as single) as IntPTR
End Function

' SRC\affinecompose.c (313, 1)
' ptaRotate()
' ptaRotate(PTA *, l_float32, l_float32, l_float32) as PTA *
''' <summary>
''' * Notes;
'''  *   (1) See createMatrix2dScale() for details of transform.
'''  *   (2) This transform can be thought of as composed of the
'''  * sum of two parts:
'''  *  a) an (x,y)-dependent rotation about the origin:
'''  *  xr = x * cosa - y * sina
'''  *  yr = x * sina + y * cosa
'''  *  b) an (x,y)-independent translation that depends on the
'''  *  rotation center and the angle:
'''  *  xt = xc - xc * cosa + yc * sina
'''  *  yt = yc - xc * sina - yc * cosa
'''  * The translation part (xt,yt) is equal to the difference
'''  * between the center (xc,yc) and the location of the
'''  * center after it is rotated about the origin.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="ptas"> \param[in]    ptas for initial points</param>
''' <param name="xc"> \param[in]    xc, yc  location of center of rotation</param>
''' <param name="yc"> \param[in]    angle  rotation in radians; clockwise is positive</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaRotate")> _
Friend Shared Function ptaRotate(ptas as IntPTR, xc as single, yc as single, angle as single) as IntPTR
End Function

' SRC\affinecompose.c (358, 1)
' boxaTranslate()
' boxaTranslate(BOXA *, l_float32, l_float32) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad  translated boxas, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="transx"> \param[in]    transx  x component of translation wrt. the origin</param>
''' <param name="transy"> \param[in]    transy  y component of translation wrt. the origin</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaTranslate")> _
Friend Shared Function boxaTranslate(boxas as IntPTR, transx as single, transy as single) as IntPTR
End Function

' SRC\affinecompose.c (391, 1)
' boxaScale()
' boxaScale(BOXA *, l_float32, l_float32) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad  scaled boxas, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="scalex"> \param[in]    scalex  horizontal scale factor</param>
''' <param name="scaley"> \param[in]    scaley  vertical scale factor</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaScale")> _
Friend Shared Function boxaScale(boxas as IntPTR, scalex as single, scaley as single) as IntPTR
End Function

' SRC\affinecompose.c (424, 1)
' boxaRotate()
' boxaRotate(BOXA *, l_float32, l_float32, l_float32) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad  scaled boxas, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="xc"> \param[in]    xc, yc  location of center of rotation</param>
''' <param name="yc"> \param[in]    angle  rotation in radians; clockwise is positive</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaRotate")> _
Friend Shared Function boxaRotate(boxas as IntPTR, xc as single, yc as single, angle as single) as IntPTR
End Function

' SRC\affinecompose.c (457, 1)
' ptaAffineTransform()
' ptaAffineTransform(PTA *, l_float32 *) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad  transformed points, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas for initial points</param>
''' <param name="mat"> \param[in]    mat  3x3 transform matrix; canonical form</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaAffineTransform")> _
Friend Shared Function ptaAffineTransform(ptas as IntPTR, mat as single) as IntPTR
End Function

' SRC\affinecompose.c (493, 1)
' boxaAffineTransform()
' boxaAffineTransform(BOXA *, l_float32 *) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad  transformed boxas, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="mat"> \param[in]    mat  3x3 transform matrix; canonical form</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaAffineTransform")> _
Friend Shared Function boxaAffineTransform(boxas as IntPTR, mat as single) as IntPTR
End Function

' SRC\affinecompose.c (528, 1)
' l_productMatVec()
' l_productMatVec(l_float32 *, l_float32 *, l_float32 *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="mat"> \param[in]    mat  square matrix, as a 1-dimensional %size^2 array</param>
''' <param name="vecs"> \param[in]    vecs input column vector of length %size</param>
''' <param name="vecd"> \param[in]    vecd result column vector</param>
''' <param name="size"> \param[in]    size matrix is %size x %size; vectors are length %size</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_productMatVec")> _
Friend Shared Function l_productMatVec(mat as single, vecs as single, vecd as single, size as Integer) as Integer
End Function

' SRC\affinecompose.c (564, 1)
' l_productMat2()
' l_productMat2(l_float32 *, l_float32 *, l_float32 *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="mat1"> \param[in]    mat1  square matrix, as a 1-dimensional size^2 array</param>
''' <param name="mat2"> \param[in]    mat2  square matrix, as a 1-dimensional size^2 array</param>
''' <param name="matd"> \param[in]    matd  square matrix; product stored here</param>
''' <param name="size"> \param[in]    size of matrices</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_productMat2")> _
Friend Shared Function l_productMat2(mat1 as single, mat2 as single, matd as single, size as Integer) as Integer
End Function

' SRC\affinecompose.c (603, 1)
' l_productMat3()
' l_productMat3(l_float32 *, l_float32 *, l_float32 *, l_float32 *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="mat1"> \param[in]    mat1  square matrix, as a 1-dimensional size^2 array</param>
''' <param name="mat2"> \param[in]    mat2  square matrix, as a 1-dimensional size^2 array</param>
''' <param name="mat3"> \param[in]    mat3  square matrix, as a 1-dimensional size^2 array</param>
''' <param name="matd"> \param[in]    matd  square matrix; product stored here</param>
''' <param name="size"> \param[in]    size  of matrices</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_productMat3")> _
Friend Shared Function l_productMat3(mat1 as single, mat2 as single, mat3 as single, matd as single, size as Integer) as Integer
End Function

' SRC\affinecompose.c (644, 1)
' l_productMat4()
' l_productMat4(l_float32 *, l_float32 *, l_float32 *, l_float32 *, l_float32 *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="mat1"> \param[in]    mat1  square matrix, as a 1-dimensional size^2 array</param>
''' <param name="mat2"> \param[in]    mat2  square matrix, as a 1-dimensional size^2 array</param>
''' <param name="mat3"> \param[in]    mat3  square matrix, as a 1-dimensional size^2 array</param>
''' <param name="mat4"> \param[in]    mat4  square matrix, as a 1-dimensional size^2 array</param>
''' <param name="matd"> \param[in]    matd  square matrix; product stored here</param>
''' <param name="size"> \param[in]    size  of matrices</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_productMat4")> _
Friend Shared Function l_productMat4(mat1 as single, mat2 as single, mat3 as single, mat4 as single, matd as single, size as Integer) as Integer
End Function

#End Region
#Region "SRC\arrayaccess.c"
' SRC\arrayaccess.c (74, 1)
' l_getDataBit()
' l_getDataBit(void *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  val of the nth 1-bit pixel.</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_getDataBit")> _
Friend Shared Function l_getDataBit(line as Object, n as Integer) as Integer
End Function

' SRC\arrayaccess.c (91, 1)
' l_setDataBit()
' l_setDataBit(void *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_setDataBit")> _
Friend Shared Function l_setDataBit(line as Object, n as Integer) as Boolean ' Org. Void
End Function

' SRC\arrayaccess.c (108, 1)
' l_clearDataBit()
' l_clearDataBit(void *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_clearDataBit")> _
Friend Shared Function l_clearDataBit(line as Object, n as Integer) as Boolean ' Org. Void
End Function

' SRC\arrayaccess.c (134, 1)
' l_setDataBitVal()
' l_setDataBitVal(void *, l_int32, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) This is an accessor for a 1 bpp pix.
'''  *   (2) It is actually a little slower than using:
'''  *   if (val == 0)
'''  * l_ClearDataBit(line, n);
'''  *   else
'''  * l_SetDataBit(line, n);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
''' <param name="val"> \param[in]    val   val to be inserted: 0 or 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_setDataBitVal")> _
Friend Shared Function l_setDataBitVal(line as Object, n as Integer, val as Integer) as Boolean ' Org. Void
End Function

' SRC\arrayaccess.c (155, 1)
' l_getDataDibit()
' l_getDataDibit(void *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  val of the nth 2-bit pixel.</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_getDataDibit")> _
Friend Shared Function l_getDataDibit(line as Object, n as Integer) as Integer
End Function

' SRC\arrayaccess.c (171, 1)
' l_setDataDibit()
' l_setDataDibit(void *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
''' <param name="val"> \param[in]    val   val to be inserted: 0 - 3</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_setDataDibit")> _
Friend Shared Function l_setDataDibit(line as Object, n as Integer, val as Integer) as Boolean ' Org. Void
End Function

' SRC\arrayaccess.c (194, 1)
' l_clearDataDibit()
' l_clearDataDibit(void *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_clearDataDibit")> _
Friend Shared Function l_clearDataDibit(line as Object, n as Integer) as Boolean ' Org. Void
End Function

' SRC\arrayaccess.c (209, 1)
' l_getDataQbit()
' l_getDataQbit(void *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  val of the nth 4-bit pixel.</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_getDataQbit")> _
Friend Shared Function l_getDataQbit(line as Object, n as Integer) as Integer
End Function

' SRC\arrayaccess.c (225, 1)
' l_setDataQbit()
' l_setDataQbit(void *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
''' <param name="val"> \param[in]    val   val to be inserted: 0 - 0xf</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_setDataQbit")> _
Friend Shared Function l_setDataQbit(line as Object, n as Integer, val as Integer) as Boolean ' Org. Void
End Function

' SRC\arrayaccess.c (248, 1)
' l_clearDataQbit()
' l_clearDataQbit(void *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_clearDataQbit")> _
Friend Shared Function l_clearDataQbit(line as Object, n as Integer) as Boolean ' Org. Void
End Function

' SRC\arrayaccess.c (263, 1)
' l_getDataByte()
' l_getDataByte(void *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  value of the n-th byte pixel</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_getDataByte")> _
Friend Shared Function l_getDataByte(line as Object, n as Integer) as Integer
End Function

' SRC\arrayaccess.c (283, 1)
' l_setDataByte()
' l_setDataByte(void *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
''' <param name="val"> \param[in]    val   val to be inserted: 0 - 0xff</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_setDataByte")> _
Friend Shared Function l_setDataByte(line as Object, n as Integer, val as Integer) as Boolean ' Org. Void
End Function

' SRC\arrayaccess.c (303, 1)
' l_getDataTwoBytes()
' l_getDataTwoBytes(void *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  value of the n-th 2-byte pixel</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_getDataTwoBytes")> _
Friend Shared Function l_getDataTwoBytes(line as Object, n as Integer) as Integer
End Function

' SRC\arrayaccess.c (323, 1)
' l_setDataTwoBytes()
' l_setDataTwoBytes(void *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
''' <param name="val"> \param[in]    val   val to be inserted: 0 - 0xffff</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_setDataTwoBytes")> _
Friend Shared Function l_setDataTwoBytes(line as Object, n as Integer, val as Integer) as Boolean ' Org. Void
End Function

' SRC\arrayaccess.c (343, 1)
' l_getDataFourBytes()
' l_getDataFourBytes(void *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  value of the n-th 4-byte pixel</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_getDataFourBytes")> _
Friend Shared Function l_getDataFourBytes(line as Object, n as Integer) as Integer
End Function

' SRC\arrayaccess.c (359, 1)
' l_setDataFourBytes()
' l_setDataFourBytes(void *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="line"> \param[in]    line  ptr to beginning of data line</param>
''' <param name="n"> \param[in]    n     pixel index</param>
''' <param name="val"> \param[in]    val   val to be inserted: 0 - 0xffffffff</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_setDataFourBytes")> _
Friend Shared Function l_setDataFourBytes(line as Object, n as Integer, val as Integer) as Boolean ' Org. Void
End Function

#End Region
#Region "SRC\bardecode.c"
' SRC\bardecode.c (67, 16)
' barcodeFindFormat()
' barcodeFindFormat(char *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  format for barcode, or L_BF_UNKNOWN if not recognized</returns>
''' <param name="barstr"> \param[in]    barstr of barcode widths, in set {1,2,3,4}</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="barcodeFindFormat")> _
Friend Shared Function barcodeFindFormat(barstr as Object) as Integer
End Function

' SRC\bardecode.c (68, 16)
' barcodeVerifyFormat()
' barcodeVerifyFormat(char *, l_int32, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) If valid == 1, the barcode is of the given format in the
'''  * forward order; if valid == 2, it is backwards.
'''  *   (2) If the barcode needs to be reversed to read it, and &reverse
'''  * is provided, a 1 is put into %reverse.
'''  *   (3) Add to this as more formats are supported.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="barstr"> \param[in]    barstr of barcode widths, in set {1,2,3,4}</param>
''' <param name="format"> \param[in]    format L_BF_CODEI2OF5, L_BF_CODE93, ...</param>
''' <param name="pvalid"> \param[out]   pvalid 0 if not valid, 1 and 2 if valid</param>
''' <param name="preverse"> \param[out]   preverse [optional] 1 if reversed; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="barcodeVerifyFormat")> _
Friend Shared Function barcodeVerifyFormat(barstr as Object, format as Integer, pvalid as Integer, preverse as Integer) as Integer
End Function

' SRC\bardecode.c (70, 14)
' barcodeDecode2of5()
' barcodeDecode2of5(char *, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) Ref: http://en.wikipedia.org/wiki/Two-out-of-five_code (Note:
'''  *  the codes given here are wrong!)
'''  *   http://morovia.com/education/symbology/code25.asp
'''  *   (2) This is a very low density encoding for the 10 digits.
'''  * Each digit is encoded with 5 black bars, of which 2 are wide
'''  * and 3 are narrow.  No information is carried in the spaces
'''  * between the bars, which are all equal in width, represented by
'''  * a "1" in our encoding.
'''  *   (3) The mapping from the sequence of five bar widths to the
'''  * digit is identical to the mapping used by the interleaved
'''  * 2 of 5 code.  The start code is 21211, representing two
'''  * wide bars and a narrow bar, and the interleaved "1" spaces
'''  * are explicit.  The stop code is 21112.  For all codes
'''  * (including start and stop), the trailing space "1" is
'''  * implicit -- there is no reason to represent it in the
'''  * Code2of5[] array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data string of digits, or NULL if none found or on error</returns>
''' <param name="barstr"> \param[in]    barstr of widths, in set {1, 2}</param>
''' <param name="debugflag"> \param[in]    debugflag</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="barcodeDecode2of5")> _
Friend Shared Function barcodeDecode2of5(barstr as Object, debugflag as Integer) as String
End Function

' SRC\bardecode.c (71, 14)
' barcodeDecodeI2of5()
' barcodeDecodeI2of5(char *, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) Ref: http://en.wikipedia.org/wiki/Interleaved_2_of_5
'''  *   (2) This always encodes an even number of digits.
'''  * The start code is 1111; the stop code is 211.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data string of digits, or NULL if none found or on error</returns>
''' <param name="barstr"> \param[in]    barstr of widths, in set {1, 2}</param>
''' <param name="debugflag"> \param[in]    debugflag</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="barcodeDecodeI2of5")> _
Friend Shared Function barcodeDecodeI2of5(barstr as Object, debugflag as Integer) as String
End Function

' SRC\bardecode.c (72, 14)
' barcodeDecode93()
' barcodeDecode93(char *, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) Ref:  http://en.wikipedia.org/wiki/Code93
'''  * http://morovia.com/education/symbology/code93.asp
'''  *   (2) Each symbol has 3 black and 3 white bars.
'''  * The start and stop codes are 111141; the stop code then is
'''  * terminated with a final (1) bar.
'''  *   (3) The last two codes are check codes.  We are checking them
'''  * for correctness, and issuing a warning on failure.  Should
'''  * probably not return any data on failure.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data string of digits, or NULL if none found or on error</returns>
''' <param name="barstr"> \param[in]    barstr of widths, in set {1, 2, 3, 4}</param>
''' <param name="debugflag"> \param[in]    debugflag</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="barcodeDecode93")> _
Friend Shared Function barcodeDecode93(barstr as Object, debugflag as Integer) as String
End Function

' SRC\bardecode.c (73, 14)
' barcodeDecode39()
' barcodeDecode39(char *, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) Ref:  http://en.wikipedia.org/wiki/Code39
'''  * http://morovia.com/education/symbology/code39.asp
'''  *   (2) Each symbol has 5 black and 4 white bars.
'''  * The start and stop codes are 121121211 (the asterisk)
'''  *   (3) This decoder was contributed by Roger Hyde.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data string of digits, or NULL if none found or on error</returns>
''' <param name="barstr"> \param[in]    barstr of widths, in set {1, 2}</param>
''' <param name="debugflag"> \param[in]    debugflag</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="barcodeDecode39")> _
Friend Shared Function barcodeDecode39(barstr as Object, debugflag as Integer) as String
End Function

' SRC\bardecode.c (74, 14)
' barcodeDecodeCodabar()
' barcodeDecodeCodabar(char *, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) Ref:  http://en.wikipedia.org/wiki/Codabar
'''  * http://morovia.com/education/symbology/codabar.asp
'''  *   (2) Each symbol has 4 black and 3 white bars.  They represent the
'''  * 10 digits, and optionally 6 other characters.  The start and
'''  * stop codes can be any of four (typically denoted A,B,C,D).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data string of digits, or NULL if none found or on error</returns>
''' <param name="barstr"> \param[in]    barstr of widths, in set {1, 2}</param>
''' <param name="debugflag"> \param[in]    debugflag</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="barcodeDecodeCodabar")> _
Friend Shared Function barcodeDecodeCodabar(barstr as Object, debugflag as Integer) as String
End Function

' SRC\bardecode.c (75, 14)
' barcodeDecodeUpca()
' barcodeDecodeUpca(char *, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) Ref:  http://en.wikipedia.org/wiki/UniversalProductCode
'''  * http://morovia.com/education/symbology/upc-a.asp
'''  *   (2) Each symbol has 2 black and 2 white bars, and encodes a digit.
'''  * The start and stop codes are 111 and 111.  There are a total of
'''  * 30 black bars, encoding 12 digits in two sets of 6, with
'''  * 2 black bars separating the sets.
'''  *   (3) The last digit is a check digit.  We check for correctness, and
'''  * issue a warning on failure.  Should probably not return any
'''  * data on failure.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data string of digits, or NULL if none found or on error</returns>
''' <param name="barstr"> \param[in]    barstr of widths, in set {1, 2, 3, 4}</param>
''' <param name="debugflag"> \param[in]    debugflag</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="barcodeDecodeUpca")> _
Friend Shared Function barcodeDecodeUpca(barstr as Object, debugflag as Integer) as String
End Function

' SRC\bardecode.c (76, 14)
' barcodeDecodeEan13()
' barcodeDecodeEan13(char *, l_int32, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) Ref:  http://en.wikipedia.org/wiki/UniversalProductCode
'''  * http://morovia.com/education/symbology/ean-13.asp
'''  *   (2) The encoding is essentially the same as UPC-A, except
'''  * there are 13 digits in total, of which 12 are encoded
'''  * by bars (as with UPC-A) and the 13th is a leading digit
'''  * that determines the encoding of the next 6 digits,
'''  * selecting each digit from one of two tables.
'''  * encoded in the bars (as with UPC-A).  If the first digit
'''  * is 0, the encoding is identical to UPC-A.
'''  *   (3) As with UPC-A, the last digit is a check digit.
'''  *   (4) For now, we assume the first digit is input to this function.
'''  * Eventually, we will read it by pattern matching.
'''  *
'''  * TODO: fix this for multiple tables, depending on the value of %first
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data string of digits, or NULL if none found or on error</returns>
''' <param name="barstr"> \param[in]    barstr of widths, in set {1, 2, 3, 4}</param>
''' <param name="first"> \param[in]    first first digit: 0 - 9</param>
''' <param name="debugflag"> \param[in]    debugflag</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="barcodeDecodeEan13")> _
Friend Shared Function barcodeDecodeEan13(barstr as Object, first as Integer, debugflag as Integer) as String
End Function

' SRC\bardecode.c (96, 1)
' barcodeDispatchDecoder()
' barcodeDispatchDecoder(char *, l_int32, l_int32) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data string of decoded barcode data, or NULL on error</returns>
''' <param name="barstr"> \param[in]    barstr string of integers in set {1,2,3,4} of bar widths</param>
''' <param name="format"> \param[in]    format L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...</param>
''' <param name="debugflag"> \param[in]    debugflag use 1 to generate debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="barcodeDispatchDecoder")> _
Friend Shared Function barcodeDispatchDecoder(barstr as Object, format as Integer, debugflag as Integer) as String
End Function

' SRC\bardecode.c (173, 1)
' barcodeFormatIsSupported()
' barcodeFormatIsSupported(l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if format is one of those supported; 0 otherwise</returns>
''' <param name="format"> \param[in]    format</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="barcodeFormatIsSupported")> _
Friend Shared Function barcodeFormatIsSupported(format as Integer) as Integer
End Function

#End Region
#Region "SRC\baseline.c"
' SRC\baseline.c (113, 1)
' pixFindBaselines()
' pixFindBaselines(PIX *, PTA **, PIXA *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) Input binary image must have text lines already aligned
'''  * horizontally.  This can be done by either rotating the
'''  * image with pixDeskew(), or, if a projective transform
'''  * is required, by doing pixDeskewLocal() first.
'''  *   (2) Input null for &pta if you don't want this returned.
'''  * The pta will come in pairs of points (left and right end
'''  * of each baseline).
'''  *   (3) Caution: this will not work properly on text with multiple
'''  * columns, where the lines are not aligned between columns.
'''  * If there are multiple columns, they should be extracted
'''  * separately before finding the baselines.
'''  *   (4) This function constructs different types of output
'''  * for baselines; namely, a set of raster line values and
'''  * a set of end points of each baseline.
'''  *   (5) This function was designed to handle short and long text lines
'''  * without using dangerous thresholds on the peak heights.  It does
'''  * this by combining the differential signal with a morphological
'''  * analysis of the locations of the text lines.  One can also
'''  * combine this data to normalize the peak heights, by weighting
'''  * the differential signal in the region of each baseline
'''  * by the inverse of the width of the text line found there.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of baseline y values, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     1 bpp, 300 ppi</param>
''' <param name="ppta"> \param[out]   ppta     [optional] pairs of pts corresponding to</param>
''' <param name="pixadb"> \param[in]    pixadb   for debug output; use NULL to skip</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindBaselines")> _
Friend Shared Function pixFindBaselines(pixs as IntPTR, ppta as Object, pixadb as IntPTR) as IntPTR
End Function

' SRC\baseline.c (320, 1)
' pixDeskewLocal()
' pixDeskewLocal(PIX *, l_int32, l_int32, l_int32, l_float32, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function allows deskew of a page whose skew changes
'''  * approximately linearly with vertical position.  It uses
'''  * a projective transform that in effect does a differential
'''  * shear about the LHS of the page, and makes all text lines
'''  * horizontal.
'''  *   (2) The origin of the keystoning can be either a cheap document
'''  * feeder that rotates the page as it is passed through, or a
'''  * camera image taken from either the left or right side
'''  * of the vertical.
'''  *   (3) The image transformation is a projective warping,
'''  * not a rotation.  Apart from this function, the text lines
'''  * must be properly aligned vertically with respect to each
'''  * other.  This can be done by pre-processing the page; e.g.,
'''  * by rotating or horizontally shearing it.
'''  * Typically, this can be achieved by vertically aligning
'''  * the page edge.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs        1 bpp</param>
''' <param name="nslices"> \param[in]    nslices     the number of horizontal overlapping slices;</param>
''' <param name="redsweep"> \param[in]    redsweep    sweep reduction factor: 1, 2, 4 or 8;</param>
''' <param name="redsearch"> \param[in]    redsearch   search reduction factor: 1, 2, 4 or 8, and</param>
''' <param name="sweeprange"> \param[in]    sweeprange  half the full range, assumed about 0; in degrees;</param>
''' <param name="sweepdelta"> \param[in]    sweepdelta  angle increment of sweep; in degrees;</param>
''' <param name="minbsdelta"> \param[in]    minbsdelta  min binary search increment angle; in degrees;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDeskewLocal")> _
Friend Shared Function pixDeskewLocal(pixs as IntPTR, nslices as Integer, redsweep as Integer, redsearch as Integer, sweeprange as single, sweepdelta as single, minbsdelta as single) as IntPTR
End Function

' SRC\baseline.c (388, 1)
' pixGetLocalSkewTransform()
' pixGetLocalSkewTransform(PIX *, l_int32, l_int32, l_int32, l_float32, l_float32, l_float32, PTA **, PTA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This generates two pairs of points in the src, each pair
'''  * corresponding to a pair of points that would lie along
'''  * the same raster line in a transformed (dewarped) image.
'''  *   (2) The sets of 4 src and 4 dest points returned by this function
'''  * can then be used, in a projective or bilinear transform,
'''  * to remove keystoning in the src.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="nslices"> \param[in]    nslices  the number of horizontal overlapping slices; must</param>
''' <param name="redsweep"> \param[in]    redsweep sweep reduction factor: 1, 2, 4 or 8;</param>
''' <param name="redsearch"> \param[in]    redsearch search reduction factor: 1, 2, 4 or 8, and</param>
''' <param name="sweeprange"> \param[in]    sweeprange half the full range, assumed about 0; in degrees;</param>
''' <param name="sweepdelta"> \param[in]    sweepdelta angle increment of sweep; in degrees;</param>
''' <param name="minbsdelta"> \param[in]    minbsdelta min binary search increment angle; in degrees;</param>
''' <param name="pptas"> \param[out]   pptas  4 points in the source</param>
''' <param name="pptad"> \param[out]   pptad  the corresponding 4 pts in the dest</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetLocalSkewTransform")> _
Friend Shared Function pixGetLocalSkewTransform(pixs as IntPTR, nslices as Integer, redsweep as Integer, redsearch as Integer, sweeprange as single, sweepdelta as single, minbsdelta as single, pptas as Object, pptad as Object) as Integer
End Function

' SRC\baseline.c (506, 1)
' pixGetLocalSkewAngles()
' pixGetLocalSkewAngles(PIX *, l_int32, l_int32, l_int32, l_float32, l_float32, l_float32, l_float32 *, l_float32 *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The local skew is measured in a set of overlapping strips.
'''  * We then do a least square linear fit parameters to get
'''  * the slope and intercept parameters a and b in
'''  *  skew-angle = a * y + b  (degrees)
'''  * for the local skew as a function of raster line y.
'''  * This is then used to make naskew, which can be interpreted
'''  * as the computed skew angle (in degrees) at the left edge
'''  * of each raster line.
'''  *   (2) naskew can then be used to find the baselines of text, because
'''  * each text line has a baseline that should intersect
'''  * the left edge of the image with the angle given by this
'''  * array, evaluated at the raster line of intersection.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  naskew, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs         1 bpp</param>
''' <param name="nslices"> \param[in]    nslices      the number of horizontal overlapping slices; must</param>
''' <param name="redsweep"> \param[in]    redsweep     sweep reduction factor: 1, 2, 4 or 8;</param>
''' <param name="redsearch"> \param[in]    redsearch    search reduction factor: 1, 2, 4 or 8, and not</param>
''' <param name="sweeprange"> \param[in]    sweeprange   half the full range, assumed about 0; in degrees;</param>
''' <param name="sweepdelta"> \param[in]    sweepdelta   angle increment of sweep; in degrees;</param>
''' <param name="minbsdelta"> \param[in]    minbsdelta   min binary search increment angle; in degrees;</param>
''' <param name="pa"> \param[out]   pa [optional] slope of skew as fctn of y</param>
''' <param name="pb"> \param[out]   pb [optional] intercept at y=0 of skew as fctn of y</param>
''' <param name="debug"> \param[in]    debug   1 for generating plot of skew angle vs. y; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetLocalSkewAngles")> _
Friend Shared Function pixGetLocalSkewAngles(pixs as IntPTR, nslices as Integer, redsweep as Integer, redsearch as Integer, sweeprange as single, sweepdelta as single, minbsdelta as single, pa as single, pb as single, debug as Integer) as IntPTR
End Function

#End Region
#Region "SRC\bbuffer.c"
' SRC\bbuffer.c (124, 1)
' bbufferCreate()
' bbufferCreate(const l_uint8 *, l_int32) as L_BBUFFER *
''' <summary>
''' * Notes:
'''  *   (1) If a buffer address is given, you should read all the data in.
'''  *   (2) Allocates a bbuffer with associated byte array of
'''  * the given size.  If a buffer address is given,
'''  * it then reads the number of bytes into the byte array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  bbuffer, or NULL on error</returns>
''' <param name="indata"> \param[in]    indata address in memory [optional]</param>
''' <param name="nalloc"> \param[in]    nalloc size of byte array to be alloc'd 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bbufferCreate")> _
Friend Shared Function bbufferCreate(indata as Byte, nalloc as Integer) as IntPTR
End Function

' SRC\bbuffer.c (167, 1)
' bbufferDestroy()
' bbufferDestroy(L_BBUFFER **) as void
''' <summary>
''' * Notes:
'''  *   (1) Destroys the byte array in the bbuffer and then the bbuffer;
'''  * then nulls the contents of the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pbb"> \param[in,out]   pbb  buffer to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bbufferDestroy")> _
Friend Shared Function bbufferDestroy(pbb as Object) as Boolean ' Org. Void
End Function

' SRC\bbuffer.c (203, 1)
' bbufferDestroyAndSaveData()
' bbufferDestroyAndSaveData(L_BBUFFER **, size_t *) as l_uint8 *
''' <summary>
''' * Notes:
'''  *   (1) Copies data to newly allocated array; then destroys the bbuffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  barray newly allocated array of data</returns>
''' <param name="pbb"> \param[in,out]   pbb buffer to be nulled</param>
''' <param name="pnbytes"> \param[out]      pnbytes  number of bytes saved in array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bbufferDestroyAndSaveData")> _
Friend Shared Function bbufferDestroyAndSaveData(pbb as Object, pnbytes as ULong) as String
End Function

' SRC\bbuffer.c (262, 1)
' bbufferRead()
' bbufferRead(L_BBUFFER *, l_uint8 *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For a read after write, first remove the written
'''  * bytes by shifting the unwritten bytes in the array,
'''  * then check if there is enough room to add the new bytes.
'''  * If not, realloc with bbufferExpandArray(), resulting
'''  * in a second writing of the unwritten bytes.  While less
'''  * efficient, this is simpler than making a special case
'''  * of reallocNew().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="bb"> \param[in]    bb       bbuffer</param>
''' <param name="src"> \param[in]    src      source memory buffer from which bytes are read</param>
''' <param name="nbytes"> \param[in]    nbytes   bytes to be read</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bbufferRead")> _
Friend Shared Function bbufferRead(bb as IntPTR, src as Byte, nbytes as Integer) as Integer
End Function

' SRC\bbuffer.c (308, 1)
' bbufferReadStream()
' bbufferReadStream(L_BBUFFER *, FILE *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="bb"> \param[in]    bb       bbuffer</param>
''' <param name="fp"> \param[in]    fp       source stream from which bytes are read</param>
''' <param name="nbytes"> \param[in]    nbytes   bytes to be read</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bbufferReadStream")> _
Friend Shared Function bbufferReadStream(bb as IntPTR, fp as Object, nbytes as Integer) as Integer
End Function

' SRC\bbuffer.c (359, 1)
' bbufferExtendArray()
' bbufferExtendArray(L_BBUFFER *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) reallocNew() copies all bb->nalloc bytes, even though
'''  * only bb->n are data.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="bb"> \param[in]    bb      bbuffer</param>
''' <param name="nbytes"> \param[in]    nbytes  number of bytes to extend array size</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bbufferExtendArray")> _
Friend Shared Function bbufferExtendArray(bb as IntPTR, nbytes as Integer) as Integer
End Function

' SRC\bbuffer.c (390, 1)
' bbufferWrite()
' bbufferWrite(L_BBUFFER *, l_uint8 *, size_t, size_t *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="bb"> \param[in]    bb       bbuffer</param>
''' <param name="dest"> \param[in]    dest     dest memory buffer to which bytes are written</param>
''' <param name="nbytes"> \param[in]    nbytes   bytes requested to be written</param>
''' <param name="pnout"> \param[out]   pnout    bytes actually written</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bbufferWrite")> _
Friend Shared Function bbufferWrite(bb as IntPTR, dest as Byte, nbytes as ULong, pnout as ULong) as Integer
End Function

' SRC\bbuffer.c (442, 1)
' bbufferWriteStream()
' bbufferWriteStream(L_BBUFFER *, FILE *, size_t, size_t *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="bb"> \param[in]    bb       bbuffer</param>
''' <param name="fp"> \param[in]    fp       dest stream to which bytes are written</param>
''' <param name="nbytes"> \param[in]    nbytes   bytes requested to be written</param>
''' <param name="pnout"> \param[out]   pnout    bytes actually written</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bbufferWriteStream")> _
Friend Shared Function bbufferWriteStream(bb as IntPTR, fp as Object, nbytes as ULong, pnout as ULong) as Integer
End Function

#End Region
#Region "SRC\bilateral.c"
' SRC\bilateral.c (80, 21)
' bilateralCreate()
' bilateralCreate(PIX *, l_float32, l_float32, l_int32, l_int32) as L_BILATERAL *
''' <summary>
''' * Notes:
'''  *   (1) This initializes a bilateral filtering operation, generating all
'''  * the data required.  It takes most of the time in the bilateral
'''  * filtering operation.
'''  *   (2) See bilateral.h for details of the algorithm.
'''  *   (3) See pixBilateral() for constraints on input parameters, which
'''  * are not checked here.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  bil, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp gray, no colormap</param>
''' <param name="spatial_stdev"> \param[in]    spatial_stdev  of gaussian kernel; in pixels, > 0.5</param>
''' <param name="range_stdev"> \param[in]    range_stdev  of gaussian range kernel; > 5.0; typ. 50.0</param>
''' <param name="ncomps"> \param[in]    ncomps number of intermediate sums J(k,x); in [4 ... 30]</param>
''' <param name="reduction"> \param[in]    reduction  1, 2 or 4</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bilateralCreate")> _
Friend Shared Function bilateralCreate(pixs as IntPTR, spatial_stdev as single, range_stdev as single, ncomps as Integer, reduction as Integer) as IntPTR
End Function

' SRC\bilateral.c (83, 13)
' bilateralApply()
' bilateralApply(L_BILATERAL *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="bil"> \param[in]    bil</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bilateralApply")> _
Friend Shared Function bilateralApply(bil as IntPTR) as IntPTR
End Function

' SRC\bilateral.c (84, 13)
' bilateralDestroy()
' bilateralDestroy(L_BILATERAL **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="pbil"> \param[in,out]   pbil will be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bilateralDestroy")> _
Friend Shared Function bilateralDestroy(pbil as Object) as Boolean ' Org. Void
End Function

' SRC\bilateral.c (150, 1)
' pixBilateral()
' pixBilateral(PIX *, l_float32, l_float32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This performs a relatively fast, separable bilateral
'''  * filtering operation.  The time is proportional to ncomps
'''  * and varies inversely approximately as the cube of the
'''  * reduction factor.  See bilateral.h for algorithm details.
'''  *   (2) We impose minimum values for range_stdev and ncomps to
'''  * avoid nasty artifacts when either are too small.  We also
'''  * impose a constraint on their product:
'''  *   ncomps * range_stdev >= 100.
'''  * So for values of range_stdev >= 25, ncomps can be as small as 4.
'''  * Here is a qualitative, intuitive explanation for this constraint.
'''  * Call the difference in k values between the J(k) == 'delta', where
'''  *  'delta' ~ 200 / ncomps
'''  * Then this constraint is roughly equivalent to the condition:
'''  *  'delta'  2 * range_stdev
'''  * Note that at an intensity difference of (2 * range_stdev), the
'''  * range part of the kernel reduces the effect by the factor 0.14.
'''  * This constraint requires that we have a sufficient number of
'''  * PCBs (i.e, a small enough 'delta'), so that for any value of
'''  * image intensity I, there exists a k (and a PCB, J(k), such that
'''  *  |I - k|  range_stdev
'''  * Any fewer PCBs and we don't have enough to support this condition.
'''  *   (3) The upper limit of 30 on ncomps is imposed because the
'''  * gain in accuracy is not worth the extra computation.
'''  *   (4) The size of the gaussian kernel is twice the spatial_stdev
'''  * on each side of the origin.  The minimum value of
'''  * spatial_stdev, 0.5, is required to have a finite sized
'''  * spatial kernel.  In practice, a much larger value is used.
'''  *   (5) Computation of the intermediate images goes inversely
'''  * as the cube of the reduction factor.  If you can use a
'''  * reduction of 2 or 4, it is well-advised.
'''  *   (6) The range kernel is defined over the absolute value of pixel
'''  * grayscale differences, and hence must have size 256 x 1.
'''  * Values in the array represent the multiplying weight
'''  * depending on the absolute gray value difference between
'''  * the source pixel and the neighboring pixel, and should
'''  * be monotonically decreasing.
'''  *   (7) Interesting observation.  Run this on prog/fish24.jpg, with
'''  * range_stdev = 60, ncomps = 6, and spatial_dev = {10, 30, 50}.
'''  * As spatial_dev gets larger, we get the counter-intuitive
'''  * result that the body of the red fish becomes less blurry.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd bilateral filtered image, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp gray or 32 bpp rgb, no colormap</param>
''' <param name="spatial_stdev"> \param[in]    spatial_stdev  of gaussian kernel; in pixels, > 0.5</param>
''' <param name="range_stdev"> \param[in]    range_stdev  of gaussian range kernel; > 5.0; typ. 50.0</param>
''' <param name="ncomps"> \param[in]    ncomps number of intermediate sums J(k,x); in [4 ... 30]</param>
''' <param name="reduction"> \param[in]    reduction  1, 2 or 4</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBilateral")> _
Friend Shared Function pixBilateral(pixs as IntPTR, spatial_stdev as single, range_stdev as single, ncomps as Integer, reduction as Integer) as IntPTR
End Function

' SRC\bilateral.c (220, 1)
' pixBilateralGray()
' pixBilateralGray(PIX *, l_float32, l_float32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixBilateral() for constraints on the input parameters.
'''  *   (2) See pixBilateral() for algorithm details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp bilateral filtered image, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp gray</param>
''' <param name="spatial_stdev"> \param[in]    spatial_stdev  of gaussian kernel; in pixels, > 0.5</param>
''' <param name="range_stdev"> \param[in]    range_stdev  of gaussian range kernel; > 5.0; typ. 50.0</param>
''' <param name="ncomps"> \param[in]    ncomps number of intermediate sums J(k,x); in [4 ... 30]</param>
''' <param name="reduction"> \param[in]    reduction  1, 2 or 4</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBilateralGray")> _
Friend Shared Function pixBilateralGray(pixs as IntPTR, spatial_stdev as single, range_stdev as single, ncomps as Integer, reduction as Integer) as IntPTR
End Function

' SRC\bilateral.c (580, 1)
' pixBilateralExact()
' pixBilateralExact(PIX *, L_KERNEL *, L_KERNEL *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The spatial_kel is a conventional smoothing kernel, typically a
'''  * 2-d Gaussian kernel or other block kernel.  It can be either
'''  * normalized or not, but must be everywhere positive.
'''  *   (2) The range_kel is defined over the absolute value of pixel
'''  * grayscale differences, and hence must have size 256 x 1.
'''  * Values in the array represent the multiplying weight for each
'''  * gray value difference between the target pixel and center of the
'''  * kernel, and should be monotonically decreasing.
'''  *   (3) If range_kel == NULL, a constant weight is applied regardless
'''  * of the range value difference.  This degenerates to a regular
'''  * pixConvolve() with a normalized kernel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp bilateral filtered image</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp gray or 32 bpp rgb</param>
''' <param name="spatial_kel"> \param[in]    spatial_kel  gaussian kernel</param>
''' <param name="range_kel"> \param[in]    range_kel [optional] 256 x 1, monotonically decreasing</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBilateralExact")> _
Friend Shared Function pixBilateralExact(pixs as IntPTR, spatial_kel as IntPTR, range_kel as IntPTR) as IntPTR
End Function

' SRC\bilateral.c (634, 1)
' pixBilateralGrayExact()
' pixBilateralGrayExact(PIX *, L_KERNEL *, L_KERNEL *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixBilateralExact().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp bilateral filtered image</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp gray</param>
''' <param name="spatial_kel"> \param[in]    spatial_kel  gaussian kernel</param>
''' <param name="range_kel"> \param[in]    range_kel [optional] 256 x 1, monotonically decreasing</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBilateralGrayExact")> _
Friend Shared Function pixBilateralGrayExact(pixs as IntPTR, spatial_kel as IntPTR, range_kel as IntPTR) as IntPTR
End Function

' SRC\bilateral.c (735, 1)
' pixBlockBilateralExact()
' pixBlockBilateralExact(PIX *, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixBilateralExact().  This provides an interface using
'''  * the standard deviations of the spatial and range filters.
'''  *   (2) The convolution window halfwidth is 2 * spatial_stdev,
'''  * and the square filter size is 4 * spatial_stdev + 1.
'''  * The kernel captures 95% of total energy.  This is compensated
'''  * by normalization.
'''  *   (3) The range_stdev is analogous to spatial_halfwidth in the
'''  * grayscale domain [0...255], and determines how much damping of the
'''  * smoothing operation is applied across edges.  The larger this
'''  * value is, the smaller the damping.  The smaller the value, the
'''  * more edge details are preserved.  These approximations are useful
'''  * for deciding the appropriate cutoff.
'''  *  kernel[1 * stdev] ~= 0.6  * kernel[0]
'''  *  kernel[2 * stdev] ~= 0.14 * kernel[0]
'''  *  kernel[3 * stdev] ~= 0.01 * kernel[0]
'''  * If range_stdev is infinite there is no damping, and this
'''  * becomes a conventional gaussian smoothing.
'''  * This value does not affect the run time.
'''  *   (4) If range_stdev is negative or zero, the range kernel is
'''  * ignored and this degenerates to a straight gaussian convolution.
'''  *   (5) This is very slow for large spatial filters.  The time
'''  * on a 3GHz pentium is roughly
'''  * T = 1.2 * 10^-8 * (A * sh^2)  sec
'''  * where A = # of pixels, sh = spatial halfwidth of filter.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp or 32 bpp bilateral filtered image</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp gray or 32 bpp rgb</param>
''' <param name="spatial_stdev"> \param[in]    spatial_stdev > 0.0</param>
''' <param name="range_stdev"> \param[in]    range_stdev > 0.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlockBilateralExact")> _
Friend Shared Function pixBlockBilateralExact(pixs as IntPTR, spatial_stdev as single, range_stdev as single) as IntPTR
End Function

' SRC\bilateral.c (787, 1)
' makeRangeKernel()
' makeRangeKernel(l_float32) as L_KERNEL *
''' <summary>
''' * Notes:
'''  *   (1) Creates a one-sided Gaussian kernel with the given
'''  * standard deviation.  At grayscale difference of one stdev,
'''  * the kernel falls to 0.6, and to 0.01 at three stdev.
'''  *   (2) A typical input number might be 20.  Then pixels whose
'''  * value differs by 60 from the center pixel have their
'''  * weight in the convolution reduced by a factor of about 0.01.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  kel, or NULL on error</returns>
''' <param name="range_stdev"> \param[in]    range_stdev > 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeRangeKernel")> _
Friend Shared Function makeRangeKernel(range_stdev as single) as IntPTR
End Function

#End Region
#Region "SRC\bilinear.c"
' SRC\bilinear.c (143, 1)
' pixBilinearSampledPta()
' pixBilinearSampledPta(PIX *, PTA *, PTA *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Brings in either black or white pixels from the boundary.
'''  *   (2) Retains colormap, which you can do for a sampled transform..
'''  *   (3) No 3 of the 4 points may be collinear.
'''  *   (4) For 8 and 32 bpp pix, better quality is obtained by the
'''  * somewhat slower pixBilinearPta().  See that
'''  * function for relative timings between sampled and interpolated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths</param>
''' <param name="ptad"> \param[in]    ptad  4 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  4 pts of initial coordinate space</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBilinearSampledPta")> _
Friend Shared Function pixBilinearSampledPta(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, incolor as Integer) as IntPTR
End Function

' SRC\bilinear.c (193, 1)
' pixBilinearSampled()
' pixBilinearSampled(PIX *, l_float32 *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Brings in either black or white pixels from the boundary.
'''  *   (2) Retains colormap, which you can do for a sampled transform..
'''  *   (3) For 8 or 32 bpp, much better quality is obtained by the
'''  * somewhat slower pixBilinear().  See that function
'''  * for relative timings between sampled and interpolated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths</param>
''' <param name="vc"> \param[in]    vc  vector of 8 coefficients for bilinear transformation</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBilinearSampled")> _
Friend Shared Function pixBilinearSampled(pixs as IntPTR, vc as single, incolor as Integer) as IntPTR
End Function

' SRC\bilinear.c (286, 1)
' pixBilinearPta()
' pixBilinearPta(PIX *, PTA *, PTA *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Brings in either black or white pixels from the boundary
'''  *   (2) Removes any existing colormap, if necessary, before transforming
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths; colormap ok</param>
''' <param name="ptad"> \param[in]    ptad  4 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  4 pts of initial coordinate space</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBilinearPta")> _
Friend Shared Function pixBilinearPta(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, incolor as Integer) as IntPTR
End Function

' SRC\bilinear.c (356, 1)
' pixBilinear()
' pixBilinear(PIX *, l_float32 *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Brings in either black or white pixels from the boundary
'''  *   (2) Removes any existing colormap, if necessary, before transforming
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths; colormap ok</param>
''' <param name="vc"> \param[in]    vc  vector of 8 coefficients for bilinear transformation</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBilinear")> _
Friend Shared Function pixBilinear(pixs as IntPTR, vc as single, incolor as Integer) as IntPTR
End Function

' SRC\bilinear.c (412, 1)
' pixBilinearPtaColor()
' pixBilinearPtaColor(PIX *, PTA *, PTA *, l_uint32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="ptad"> \param[in]    ptad  4 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  4 pts of initial coordinate space</param>
''' <param name="colorval"> \param[in]    colorval e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBilinearPtaColor")> _
Friend Shared Function pixBilinearPtaColor(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, colorval as UInteger) as IntPTR
End Function

' SRC\bilinear.c (453, 1)
' pixBilinearColor()
' pixBilinearColor(PIX *, l_float32 *, l_uint32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="vc"> \param[in]    vc  vector of 8 coefficients for bilinear transformation</param>
''' <param name="colorval"> \param[in]    colorval e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBilinearColor")> _
Friend Shared Function pixBilinearColor(pixs as IntPTR, vc as single, colorval as UInteger) as IntPTR
End Function

' SRC\bilinear.c (515, 1)
' pixBilinearPtaGray()
' pixBilinearPtaGray(PIX *, PTA *, PTA *, l_uint8) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="ptad"> \param[in]    ptad  4 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  4 pts of initial coordinate space</param>
''' <param name="grayval"> \param[in]    grayval 0 to bring in BLACK, 255 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBilinearPtaGray")> _
Friend Shared Function pixBilinearPtaGray(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, grayval as Byte) as IntPTR
End Function

' SRC\bilinear.c (556, 1)
' pixBilinearGray()
' pixBilinearGray(PIX *, l_float32 *, l_uint8) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="vc"> \param[in]    vc  vector of 8 coefficients for bilinear transformation</param>
''' <param name="grayval"> \param[in]    grayval 0 to bring in BLACK, 255 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBilinearGray")> _
Friend Shared Function pixBilinearGray(pixs as IntPTR, vc as single, grayval as Byte) as IntPTR
End Function

' SRC\bilinear.c (644, 1)
' pixBilinearPtaWithAlpha()
' pixBilinearPtaWithAlpha(PIX *, PTA *, PTA *, PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The alpha channel is transformed separately from pixs,
'''  * and aligns with it, being fully transparent outside the
'''  * boundary of the transformed pixs.  For pixels that are fully
'''  * transparent, a blending function like pixBlendWithGrayMask()
'''  * will give zero weight to corresponding pixels in pixs.
'''  *   (2) If pixg is NULL, it is generated as an alpha layer that is
'''  * partially opaque, using %fract.  Otherwise, it is cropped
'''  * to pixs if required and %fract is ignored.  The alpha channel
'''  * in pixs is never used.
'''  *   (3) Colormaps are removed.
'''  *   (4) When pixs is transformed, it doesn't matter what color is brought
'''  * in because the alpha channel will be transparent (0) there.
'''  *   (5) To avoid losing source pixels in the destination, it may be
'''  * necessary to add a border to the source pix before doing
'''  * the bilinear transformation.  This can be any non-negative number.
'''  *   (6) The input %ptad and %ptas are in a coordinate space before
'''  * the border is added.  Internally, we compensate for this
'''  * before doing the bilinear transform on the image after
'''  * the border is added.
'''  *   (7) The default setting for the border values in the alpha channel
'''  * is 0 (transparent) for the outermost ring of pixels and
'''  * (0.5 * fract * 255) for the second ring.  When blended over
'''  * a second image, this
'''  * (a) shrinks the visible image to make a clean overlap edge
'''  *  with an image below, and
'''  * (b) softens the edges by weakening the aliasing there.
'''  * Use l_setAlphaMaskBorder() to change these values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="ptad"> \param[in]    ptad  4 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  4 pts of initial coordinate space</param>
''' <param name="pixg"> \param[in]    pixg [optional] 8 bpp, can be null</param>
''' <param name="fract"> \param[in]    fract between 0.0 and 1.0, with 0.0 fully transparent</param>
''' <param name="border"> \param[in]    border of pixels added to capture transformed source pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBilinearPtaWithAlpha")> _
Friend Shared Function pixBilinearPtaWithAlpha(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, pixg as IntPTR, fract as single, border as Integer) as IntPTR
End Function

' SRC\bilinear.c (776, 1)
' getBilinearXformCoeffs()
' getBilinearXformCoeffs(PTA *, PTA *, l_float32 **) as l_ok
''' <summary>
''' * We have a set of 8 equations, describing the bilinear
'''  * transformation that takes 4 points ptas into 4 other
'''  * points ptad.  These equations are:
'''  *
'''  * x1' = c[0]*x1 + c[1]*y1 + c[2]*x1*y1 + c[3]
'''  * y1' = c[4]*x1 + c[5]*y1 + c[6]*x1*y1 + c[7]
'''  * x2' = c[0]*x2 + c[1]*y2 + c[2]*x2*y2 + c[3]
'''  * y2' = c[4]*x2 + c[5]*y2 + c[6]*x2*y2 + c[7]
'''  * x3' = c[0]*x3 + c[1]*y3 + c[2]*x3*y3 + c[3]
'''  * y3' = c[4]*x3 + c[5]*y3 + c[6]*x3*y3 + c[7]
'''  * x4' = c[0]*x4 + c[1]*y4 + c[2]*x4*y4 + c[3]
'''  * y4' = c[4]*x4 + c[5]*y4 + c[6]*x4*y4 + c[7]
'''  *
'''  * This can be represented as
'''  *
'''  *  AC = B
'''  *
'''  * where B and C are column vectors
'''  *
'''  *   B = [ x1' y1' x2' y2' x3' y3' x4' y4' ]
'''  *   C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] c[7] ]
'''  *
'''  * and A is the 8x8 matrix
'''  *
'''  * x1   y1   x1*y1   1   0 0   0  0
'''  *  0 0  0  0   x1   y1   x1*y1   1
'''  * x2   y2   x2*y2   1   0 0   0  0
'''  *  0 0  0  0   x2   y2   x2*y2   1
'''  * x3   y3   x3*y3   1   0 0   0  0
'''  *  0 0  0  0   x3   y3   x3*y3   1
'''  * x4   y4   x4*y4   1   0 0   0  0
'''  *  0 0  0  0   x4   y4   x4*y4   1
'''  *
'''  * These eight equations are solved here for the coefficients C.
'''  *
'''  * These eight coefficients can then be used to find the mapping
'''  * x,y) --> (x',y':
'''  *
'''  *  x' = c[0]x + c[1]y + c[2]xy + c[3]
'''  *  y' = c[4]x + c[5]y + c[6]xy + c[7]
'''  *
'''  * that are implemented in bilinearXformSampledPt and
'''  * bilinearXFormPt.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="ptas"> \param[in]    ptas  source 4 points; unprimed</param>
''' <param name="ptad"> \param[in]    ptad  transformed 4 points; primed</param>
''' <param name="pvc"> \param[out]   pvc   vector of coefficients of transform</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getBilinearXformCoeffs")> _
Friend Shared Function getBilinearXformCoeffs(ptas as IntPTR, ptad as IntPTR, pvc as Object) as Integer
End Function

' SRC\bilinear.c (869, 1)
' bilinearXformSampledPt()
' bilinearXformSampledPt(l_float32 *, l_int32, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds the nearest pixel coordinates of the transformed point.
'''  *   (2) It does not check ptrs for returned data!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="vc"> \param[in]    vc vector of 8 coefficients</param>
''' <param name="x"> \param[in]    x, y  initial point</param>
''' <param name="y"> \param[out]   pxp, pyp   transformed point</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bilinearXformSampledPt")> _
Friend Shared Function bilinearXformSampledPt(vc as single, x as Integer, y as Integer, pxp as Integer, pyp as Integer) as Integer
End Function

' SRC\bilinear.c (902, 1)
' bilinearXformPt()
' bilinearXformPt(l_float32 *, l_int32, l_int32, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This computes the floating point location of the transformed point.
'''  *   (2) It does not check ptrs for returned data!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="vc"> \param[in]    vc vector of 8 coefficients</param>
''' <param name="x"> \param[in]    x, y  initial point</param>
''' <param name="y"> \param[out]   pxp, pyp   transformed point</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bilinearXformPt")> _
Friend Shared Function bilinearXformPt(vc as single, x as Integer, y as Integer, pxp as single, pyp as single) as Integer
End Function

#End Region
#Region "SRC\binarize.c"
' SRC\binarize.c (140, 1)
' pixOtsuAdaptiveThreshold()
' pixOtsuAdaptiveThreshold(PIX *, l_int32, l_int32, l_int32, l_int32, l_float32, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The Otsu method finds a single global threshold for an image.
'''  * This function allows a locally adapted threshold to be
'''  * found for each tile into which the image is broken up.
'''  *   (2) The array of threshold values, one for each tile, constitutes
'''  * a highly downscaled image.  This array is optionally
'''  * smoothed using a convolution.  The full width and height of the
'''  * convolution kernel are (2 * %smoothx + 1) and (2 * %smoothy + 1).
'''  *   (3) The minimum tile dimension allowed is 16.  If such small
'''  * tiles are used, it is recommended to use smoothing, because
'''  * without smoothing, each small tile determines the splitting
'''  * threshold independently.  A tile that is entirely in the
'''  * image bg will then hallucinate fg, resulting in a very noisy
'''  * binarization.  The smoothing should be large enough that no
'''  * tile is only influenced by one type (fg or bg) of pixels,
'''  * because it will force a split of its pixels.
'''  *   (4) To get a single global threshold for the entire image, use
'''  * input values of %sx and %sy that are larger than the image.
'''  * For this situation, the smoothing parameters are ignored.
'''  *   (5) The threshold values partition the image pixels into two classes:
'''  * one whose values are less than the threshold and another
'''  * whose values are greater than or equal to the threshold.
'''  * This is the same use of 'threshold' as in pixThresholdToBinary().
'''  *   (6) The scorefract is the fraction of the maximum Otsu score, which
'''  * is used to determine the range over which the histogram minimum
'''  * is searched.  See numaSplitDistribution() for details on the
'''  * underlying method of choosing a threshold.
'''  *   (7) This uses enables a modified version of the Otsu criterion for
'''  * splitting the distribution of pixels in each tile into a
'''  * fg and bg part.  The modification consists of searching for
'''  * a minimum in the histogram over a range of pixel values where
'''  * the Otsu score is within a defined fraction, %scorefract,
'''  * of the max score.  To get the original Otsu algorithm, set
'''  * %scorefract == 0.
'''  *   (8) N.B. This method is NOT recommended for images with weak text
'''  * and significant background noise, such as bleedthrough, because
'''  * of the problem noted in (3) above for tiling.  Use Sauvola.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="sx"> \param[in]    sx, sy desired tile dimensions; actual size may vary</param>
''' <param name="sy"> \param[in]    smoothx, smoothy half-width of convolution kernel applied to</param>
''' <param name="smoothx"> \param[in]    scorefract fraction of the max Otsu score; typ. 0.1;</param>
''' <param name="smoothy"> \param[out]   ppixth [optional] array of threshold values</param>
''' <param name="scorefract"> \param[out]   ppixd [optional] thresholded input pixs, based on</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOtsuAdaptiveThreshold")> _
Friend Shared Function pixOtsuAdaptiveThreshold(pixs as IntPTR, sx as Integer, sy as Integer, smoothx as Integer, smoothy as Integer, scorefract as single, ppixth as Object, ppixd as Object) as Integer
End Function

' SRC\binarize.c (256, 1)
' pixOtsuThreshOnBackgroundNorm()
' pixOtsuThreshOnBackgroundNorm(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_float32, l_int32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does background normalization followed by Otsu
'''  * thresholding.  Otsu binarization attempts to split the
'''  * image into two roughly equal sets of pixels, and it does
'''  * a very poor job when there are large amounts of dark
'''  * background.  By doing a background normalization first,
'''  * to get the background near 255, we remove this problem.
'''  * Then we use a modified Otsu to estimate the best global
'''  * threshold on the normalized image.
'''  *   (2) See pixBackgroundNorm() for meaning and typical values
'''  * of input parameters.  For a start, you can try:
'''  *   sx, sy = 10, 15
'''  *   thresh = 100
'''  *   mincount = 50
'''  *   bgval = 255
'''  *   smoothx, smoothy = 2
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp thresholded image, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; not colormapped</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null</param>
''' <param name="sx"> \param[in]    sx, sy tile size in pixels</param>
''' <param name="sy"> \param[in]    thresh threshold for determining foreground</param>
''' <param name="thresh"> \param[in]    mincount min threshold on counts in a tile</param>
''' <param name="mincount"> \param[in]    bgval target bg val; typ. > 128</param>
''' <param name="bgval"> \param[in]    smoothx half-width of block convolution kernel width</param>
''' <param name="smoothx"> \param[in]    smoothy half-width of block convolution kernel height</param>
''' <param name="smoothy"> \param[in]    scorefract fraction of the max Otsu score; typ. 0.1</param>
''' <param name="scorefract"> \param[out]   pthresh [optional] threshold value that was</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOtsuThreshOnBackgroundNorm")> _
Friend Shared Function pixOtsuThreshOnBackgroundNorm(pixs as IntPTR, pixim as IntPTR, sx as Integer, sy as Integer, thresh as Integer, mincount as Integer, bgval as Integer, smoothx as Integer, smoothy as Integer, scorefract as single, pthresh as Integer) as IntPTR
End Function

' SRC\binarize.c (354, 1)
' pixMaskedThreshOnBackgroundNorm()
' pixMaskedThreshOnBackgroundNorm(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_float32, l_int32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This begins with a standard background normalization.
'''  * Additionally, there is a flexible background norm, that
'''  * will adapt to a rapidly varying background, and this
'''  * puts white pixels in the background near regions with
'''  * significant foreground.  The white pixels are turned into
'''  * a 1 bpp selection mask by binarization followed by dilation.
'''  * Otsu thresholding is performed on the input image to get an
'''  * estimate of the threshold in the non-mask regions.
'''  * The background normalized image is thresholded with two
'''  * different values, and the result is combined using
'''  * the selection mask.
'''  *   (2) Note that the numbers 255 (for bgval target) and 190 (for
'''  * thresholding on pixn) are tied together, and explicitly
'''  * defined in this function.
'''  *   (3) See pixBackgroundNorm() for meaning and typical values
'''  * of input parameters.  For a start, you can try:
'''  *   sx, sy = 10, 15
'''  *   thresh = 100
'''  *   mincount = 50
'''  *   smoothx, smoothy = 2
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp thresholded image, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; not colormapped</param>
''' <param name="pixim"> \param[in]    pixim [optional] 1 bpp 'image' mask; can be null</param>
''' <param name="sx"> \param[in]    sx, sy tile size in pixels</param>
''' <param name="sy"> \param[in]    thresh threshold for determining foreground</param>
''' <param name="thresh"> \param[in]    mincount min threshold on counts in a tile</param>
''' <param name="mincount"> \param[in]    smoothx half-width of block convolution kernel width</param>
''' <param name="smoothx"> \param[in]    smoothy half-width of block convolution kernel height</param>
''' <param name="smoothy"> \param[in]    scorefract fraction of the max Otsu score; typ. ~ 0.1</param>
''' <param name="scorefract"> \param[out]   pthresh [optional] threshold value that was</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMaskedThreshOnBackgroundNorm")> _
Friend Shared Function pixMaskedThreshOnBackgroundNorm(pixs as IntPTR, pixim as IntPTR, sx as Integer, sy as Integer, thresh as Integer, mincount as Integer, smoothx as Integer, smoothy as Integer, scorefract as single, pthresh as Integer) as IntPTR
End Function

' SRC\binarize.c (467, 1)
' pixSauvolaBinarizeTiled()
' pixSauvolaBinarizeTiled(PIX *, l_int32, l_float32, l_int32, l_int32, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The window width and height are 2 * %whsize + 1.  The minimum
'''  * value for %whsize is 2; typically it is >= 7..
'''  *   (2) For nx == ny == 1, this defaults to pixSauvolaBinarize().
'''  *   (3) Why a tiled version?
'''  * (a) Because the mean value accumulator is a uint32, overflow
'''  *  can occur for an image with more than 16M pixels.
'''  * (b) The mean value accumulator array for 16M pixels is 64 MB.
'''  *  The mean square accumulator array for 16M pixels is 128 MB.
'''  *  Using tiles reduces the size of these arrays.
'''  * (c) Each tile can be processed independently, in parallel,
'''  *  on a multicore processor.
'''  *   (4) The Sauvola threshold is determined from the formula:
'''  *  t = m * (1 - k * (1 - s / 128))
'''  * See pixSauvolaBinarize() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale, not colormapped</param>
''' <param name="whsize"> \param[in]    whsize window half-width for measuring local statistics</param>
''' <param name="factor"> \param[in]    factor factor for reducing threshold due to variance; >= 0</param>
''' <param name="nx"> \param[in]    nx, ny subdivision into tiles; >= 1</param>
''' <param name="ny"> \param[out]   ppixth [optional] Sauvola threshold values</param>
''' <param name="ppixth"> \param[out]   ppixd [optional] thresholded image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSauvolaBinarizeTiled")> _
Friend Shared Function pixSauvolaBinarizeTiled(pixs as IntPTR, whsize as Integer, factor as single, nx as Integer, ny as Integer, ppixth as Object, ppixd as Object) as Integer
End Function

' SRC\binarize.c (594, 1)
' pixSauvolaBinarize()
' pixSauvolaBinarize(PIX *, l_int32, l_float32, l_int32, PIX **, PIX **, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The window width and height are 2 * %whsize + 1.  The minimum
'''  * value for %whsize is 2; typically it is >= 7..
'''  *   (2) The local statistics, measured over the window, are the
'''  * average and standard deviation.
'''  *   (3) The measurements of the mean and standard deviation are
'''  * performed inside a border of (%whsize + 1) pixels.  If pixs does
'''  * not have these added border pixels, use %addborder = 1 to add
'''  * it here; otherwise use %addborder = 0.
'''  *   (4) The Sauvola threshold is determined from the formula:
'''  *   t = m * (1 - k * (1 - s / 128))
'''  * where:
'''  *   t = local threshold
'''  *   m = local mean
'''  *   k = %factor (>= 0)   [ typ. 0.35 ]
'''  *   s = local standard deviation, which is maximized at
'''  * 127.5 when half the samples are 0 and half are 255.
'''  *   (5) The basic idea of Niblack and Sauvola binarization is that
'''  * the local threshold should be less than the median value,
'''  * and the larger the variance, the closer to the median
'''  * it should be chosen.  Typical values for k are between
'''  * 0.2 and 0.5.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; not colormapped</param>
''' <param name="whsize"> \param[in]    whsize window half-width for measuring local statistics</param>
''' <param name="factor"> \param[in]    factor factor for reducing threshold due to variance; >= 0</param>
''' <param name="addborder"> \param[in]    addborder 1 to add border of width (%whsize + 1) on all sides</param>
''' <param name="ppixm"> \param[out]   ppixm [optional] local mean values</param>
''' <param name="ppixsd"> \param[out]   ppixsd [optional] local standard deviation values</param>
''' <param name="ppixth"> \param[out]   ppixth [optional] threshold values</param>
''' <param name="ppixd"> \param[out]   ppixd [optional] thresholded image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSauvolaBinarize")> _
Friend Shared Function pixSauvolaBinarize(pixs as IntPTR, whsize as Integer, factor as single, addborder as Integer, ppixm as Object, ppixsd as Object, ppixth as Object, ppixd as Object) as Integer
End Function

' SRC\binarize.c (704, 1)
' pixSauvolaGetThreshold()
' pixSauvolaGetThreshold(PIX *, PIX *, l_float32, PIX **) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The Sauvola threshold is determined from the formula:
'''  *   t = m * (1 - k * (1 - s / 128))
'''  * where:
'''  *   t = local threshold
'''  *   m = local mean
'''  *   k = %factor (>= 0)   [ typ. 0.35 ]
'''  *   s = local standard deviation, which is maximized at
'''  * 127.5 when half the samples are 0 and half are 255.
'''  *   (2) See pixSauvolaBinarize() for other details.
'''  *   (3) Important definitions and relations for computing averages:
'''  *   v == pixel value
'''  *   E(p) == expected value of p == average of p over some pixel set
'''  *   S(v) == square of v == v * v
'''  *   mv == E(v) == expected pixel value == mean value
'''  *   ms == E(S(v)) == expected square of pixel values
'''  *   == mean square value
'''  *   var == variance == expected square of deviation from mean
'''  * == E(S(v - mv)) = E(S(v) - 2 * S(v * mv) + S(mv))
'''  *  = E(S(v)) - S(mv)
'''  *  = ms - mv * mv
'''  *   s == standard deviation = sqrt(var)
'''  * So for evaluating the standard deviation in the Sauvola
'''  * threshold, we take
'''  *   s = sqrt(ms - mv * mv)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, sauvola threshold values, or NULL on error</returns>
''' <param name="pixm"> \param[in]    pixm 8 bpp grayscale; not colormapped</param>
''' <param name="pixms"> \param[in]    pixms 32 bpp</param>
''' <param name="factor"> \param[in]    factor factor for reducing threshold due to variance; >= 0</param>
''' <param name="ppixsd"> \param[out]   ppixsd [optional] local standard deviation</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSauvolaGetThreshold")> _
Friend Shared Function pixSauvolaGetThreshold(pixm as IntPTR, pixms as IntPTR, factor as single, ppixsd as Object) as IntPTR
End Function

' SRC\binarize.c (787, 1)
' pixApplyLocalThreshold()
' pixApplyLocalThreshold(PIX *, PIX *, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, thresholded image, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; not colormapped</param>
''' <param name="pixth"> \param[in]    pixth 8 bpp array of local thresholds</param>
''' <param name="redfactor"> \param[in]    redfactor  ...</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixApplyLocalThreshold")> _
Friend Shared Function pixApplyLocalThreshold(pixs as IntPTR, pixth as IntPTR, redfactor as Integer) as IntPTR
End Function

' SRC\binarize.c (886, 1)
' pixThresholdByConnComp()
' pixThresholdByConnComp(PIX *, PIX *, l_int32, l_int32, l_int32, l_float32, l_float32, l_int32 *, PIX **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds a global threshold based on connected components.
'''  * Although slow, it is reasonable to use it in a situation where
'''  * (a) the background in the image is relatively uniform, and
'''  * (b) the result will be fed to an OCR program that accepts 1 bpp
'''  *  images and works best with easily segmented characters.
'''  * The reason for (b) is that this selects a threshold with a
'''  * minimum number of both broken characters and merged characters.
'''  *   (2) If the pix has color, it is converted to gray using the
'''  * max component.
'''  *   (3) Input 0 to use default values for any of these inputs:
'''  * %start, %end, %incr, %thresh48, %threshdiff.
'''  *   (4) This approach can be understood as follows.  When the
'''  * binarization threshold is varied, the numbers of c.c. identify
'''  * four regimes:
'''  * (a) For low thresholds, text is broken into small pieces, and
'''  *  the number of c.c. is large, with the 4 c.c. significantly
'''  *  exceeding the 8 c.c.
'''  * (b) As the threshold rises toward the optimum value, the text
'''  *  characters coalesce and there is very little difference
'''  *  between the numbers of 4 and 8 c.c, which both go
'''  *  through a minimum.
'''  * (c) Above this, the image background gets noisy because some
'''  *  pixels are(thresholded to foreground, and the numbers
'''  *  of c.c. quickly increase, with the 4 c.c. significantly
'''  *  larger than the 8 c.c.
'''  * (d) At even higher thresholds, the image background noise
'''  *  coalesces as it becomes mostly foreground, and the
'''  *  number of c.c. drops quickly.
'''  *   (5) If there is no global threshold that distinguishes foreground
'''  * text from background (e.g., weak text over a background that
'''  * has significant variation and/or bleedthrough), this returns 1,
'''  * which the caller should check.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if no threshold is found</returns>
''' <param name="pixs"> \param[in]    pixs depth > 1, colormap OK</param>
''' <param name="pixm"> \param[in]    pixm [optional] 1 bpp mask giving region to ignore by setting</param>
''' <param name="start"> \param[in]    start, end, incr binarization threshold levels to test</param>
''' <param name="_end_"> \param[in]    thresh48 threshold on normalized difference between the</param>
''' <param name="incr"> \param[in]    threshdiff threshold on normalized difference between the</param>
''' <param name="thresh48"> \param[out]   pglobthresh [optional] best global threshold; 0</param>
''' <param name="threshdiff"> \param[out]   ppixd [optional] image thresholded to binary, or</param>
''' <param name="pglobthresh"> \param[in]    debugflag 1 for plotted results</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixThresholdByConnComp")> _
Friend Shared Function pixThresholdByConnComp(pixs as IntPTR, pixm as IntPTR, start as Integer, _end_ as Integer, incr as Integer, thresh48 as single, threshdiff as single, pglobthresh as Integer, ppixd as Object, debugflag as Integer) as Integer
End Function

#End Region
#Region "SRC\binexpand.c"
' SRC\binexpand.c (48, 19)
' 
' makeExpandTab2x() as l_uint16 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeExpandTab2x")> _
Friend Shared Function makeExpandTab2x() as String
End Function

' SRC\binexpand.c (49, 19)
' 
' makeExpandTab4x() as l_uint32 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeExpandTab4x")> _
Friend Shared Function makeExpandTab4x() as String
End Function

' SRC\binexpand.c (50, 19)
' 
' makeExpandTab8x() as l_uint32 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeExpandTab8x")> _
Friend Shared Function makeExpandTab8x() as String
End Function

' SRC\binexpand.c (67, 1)
' pixExpandBinaryReplicate()
' pixExpandBinaryReplicate(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd scaled up, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="xfact"> \param[in]    xfact  integer scale factor for horiz. replicative expansion</param>
''' <param name="yfact"> \param[in]    yfact  integer scale factor for vertical replicative expansion</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExpandBinaryReplicate")> _
Friend Shared Function pixExpandBinaryReplicate(pixs as IntPTR, xfact as Integer, yfact as Integer) as IntPTR
End Function

' SRC\binexpand.c (132, 1)
' pixExpandBinaryPower2()
' pixExpandBinaryPower2(PIX *, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd expanded 1 bpp by replication, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="factor"> \param[in]    factor expansion factor: 1, 2, 4, 8, 16</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExpandBinaryPower2")> _
Friend Shared Function pixExpandBinaryPower2(pixs as IntPTR, factor as Integer) as IntPTR
End Function

#End Region
#Region "SRC\binreduce.c"
' SRC\binreduce.c (71, 1)
' pixReduceBinary2()
' pixReduceBinary2(PIX *, l_uint8 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) After folding, the data is in bytes 0 and 2 of the word,
'''  * and the bits in each byte are in the following order
'''  * (with 0 being the leftmost originating pair and 7 being
'''  * the rightmost originating pair):
'''  *   0 4 1 5 2 6 3 7
'''  * These need to be permuted to
'''  *   0 1 2 3 4 5 6 7
'''  * which is done with an 8-bit table generated by makeSubsampleTab2x().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 2x subsampled, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="intab"> \param[in]    intab [optional]; if null, a table is made here</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReduceBinary2")> _
Friend Shared Function pixReduceBinary2(pixs as IntPTR, intab as Byte) as IntPTR
End Function

' SRC\binreduce.c (148, 1)
' pixReduceRankBinaryCascade()
' pixReduceRankBinaryCascade(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This performs up to four cascaded 2x rank reductions.
'''  *   (2) Use level = 0 to truncate the cascade.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="level1"> \param[in]    level1 threshold, in the set {0, 1, 2, 3, 4}</param>
''' <param name="level2"> \param[in]    level2 threshold, in the set {0, 1, 2, 3, 4}</param>
''' <param name="level3"> \param[in]    level3 threshold, in the set {0, 1, 2, 3, 4}</param>
''' <param name="level4"> \param[in]    level4 threshold, in the set {0, 1, 2, 3, 4}</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReduceRankBinaryCascade")> _
Friend Shared Function pixReduceRankBinaryCascade(pixs as IntPTR, level1 as Integer, level2 as Integer, level3 as Integer, level4 as Integer) as IntPTR
End Function

' SRC\binreduce.c (223, 1)
' pixReduceRankBinary2()
' pixReduceRankBinary2(PIX *, l_int32, l_uint8 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pixd is downscaled by 2x from pixs.
'''  *   (2) The rank threshold specifies the minimum number of ON
'''  * pixels in each 2x2 region of pixs that are required to
'''  * set the corresponding pixel ON in pixd.
'''  *   (3) Rank filtering is done to the UL corner of each 2x2 pixel block,
'''  * using only logical operations.  Then these pixels are chosen
'''  * in the 2x subsampling process, subsampled, as described
'''  * above in pixReduceBinary2().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, 2x rank threshold reduced, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="level"> \param[in]    level rank threshold: 1, 2, 3, 4</param>
''' <param name="intab"> \param[in]    intab [optional]; if null, a table is made here</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReduceRankBinary2")> _
Friend Shared Function pixReduceRankBinary2(pixs as IntPTR, level as Integer, intab as Byte) as IntPTR
End Function

' SRC\binreduce.c (384, 1)
' Permutation table for 2x rank binary reduction
' makeSubsampleTab2x() as l_uint8 *
''' <summary>
''' *  This table permutes the bits in a byte, from
'''  *   0 4 1 5 2 6 3 7
'''  *  to
'''  *   0 1 2 3 4 5 6 7
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return tab table of 256 permutations, or NULL on error</returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeSubsampleTab2x")> _
Friend Shared Function makeSubsampleTab2x() as String
End Function

#End Region
#Region "SRC\blend.c"
' SRC\blend.c (150, 16)
' 
' blendComponents(l_int32, l_int32, l_float32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="blendComponents")> _
Friend Shared Function blendComponents(a as Integer, b as Integer, fract as single) as Integer
End Function

' SRC\blend.c (151, 16)
' 
' blendHardLightComponents(l_int32, l_int32, l_float32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="blendHardLightComponents")> _
Friend Shared Function blendHardLightComponents(a as Integer, b as Integer, fract as single) as Integer
End Function

' SRC\blend.c (174, 1)
' pixBlend()
' pixBlend(PIX *, PIX *, l_int32, l_int32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a simple top-level interface.  For more flexibility,
'''  * call directly into pixBlendMask(), etc.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd blended image, or NULL on error</returns>
''' <param name="pixs1"> \param[in]    pixs1 blendee</param>
''' <param name="pixs2"> \param[in]    pixs2 blender; typ. smaller</param>
''' <param name="x"> \param[in]    x,y  origin [UL corner] of pixs2 relative to</param>
''' <param name="y"> \param[in]    fract blending fraction</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlend")> _
Friend Shared Function pixBlend(pixs1 as IntPTR, pixs2 as IntPTR, x as Integer, y as Integer, fract as single) as IntPTR
End Function

' SRC\blend.c (262, 1)
' pixBlendMask()
' pixBlendMask(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
'''  *   (2) If pixs1 has a colormap, it is removed.
'''  *   (3) For inplace operation (pixs1 not cmapped), call it this way:
'''  *   pixBlendMask(pixs1, pixs1, pixs2, ...)
'''  *   (4) For generating a new pixd:
'''  *   pixd = pixBlendMask(NULL, pixs1, pixs2, ...)
'''  *   (5) Only call in-place if pixs1 does not have a colormap.
'''  *   (6) Invalid %fract defaults to 0.5 with a warning.
'''  * Invalid %type defaults to L_BLEND_WITH_INVERSE with a warning.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd if OK; NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; either NULL or equal to pixs1 for in-place</param>
''' <param name="pixs1"> \param[in]    pixs1 blendee, depth > 1</param>
''' <param name="pixs2"> \param[in]    pixs2 blender, 1 bpp; typ. smaller in size than pixs1</param>
''' <param name="x"> \param[in]    x,y  origin [UL corner] of pixs2 relative to</param>
''' <param name="y"> \param[in]    fract blending fraction</param>
''' <param name="fract"> \param[in]    type L_BLEND_WITH_INVERSE, L_BLEND_TO_WHITE, L_BLEND_TO_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlendMask")> _
Friend Shared Function pixBlendMask(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR, x as Integer, y as Integer, fract as single, type as Integer) as IntPTR
End Function

' SRC\blend.c (489, 1)
' pixBlendGray()
' pixBlendGray(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32, l_int32, l_int32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For inplace operation (pixs1 not cmapped), call it this way:
'''  *   pixBlendGray(pixs1, pixs1, pixs2, ...)
'''  *   (2) For generating a new pixd:
'''  *   pixd = pixBlendGray(NULL, pixs1, pixs2, ...)
'''  *   (3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
'''  *   (4) If pixs1 has a colormap, it is removed; otherwise, if pixs1
'''  * has depth  8, it is unpacked to generate a 8 bpp pix.
'''  *   (5) If transparent = 0, the blending fraction (fract) is
'''  * applied equally to all pixels.
'''  *   (6) If transparent = 1, all pixels of value transpix (typically
'''  * either 0 or 0xff) in pixs2 are transparent in the blend.
'''  *   (7) After processing pixs1, it is either 8 bpp or 32 bpp:
'''  * ~ if 8 bpp, the fraction of pixs2 is mixed with pixs1.
'''  * ~ if 32 bpp, each component of pixs1 is mixed with
'''  *   the same fraction of pixs2.
'''  *   (8) For L_BLEND_GRAY_WITH_INVERSE, the white values of the blendee
'''  * (cval == 255 in the code below) result in a delta of 0.
'''  * Thus, these pixels are intrinsically transparent!
'''  * The "pivot" value of the src, at which no blending occurs, is
'''  * 128.  Compare with the adaptive pivot in pixBlendGrayAdapt().
'''  *   (9) Invalid %fract defaults to 0.5 with a warning.
'''  * Invalid %type defaults to L_BLEND_GRAY with a warning.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd if OK; pixs1 on error</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; either NULL or equal to pixs1 for in-place</param>
''' <param name="pixs1"> \param[in]    pixs1 blendee, depth > 1</param>
''' <param name="pixs2"> \param[in]    pixs2 blender, any depth; typ. smaller in size than pixs1</param>
''' <param name="x"> \param[in]    x,y  origin [UL corner] of pixs2 relative to</param>
''' <param name="y"> \param[in]    fract blending fraction</param>
''' <param name="fract"> \param[in]    type L_BLEND_GRAY, L_BLEND_GRAY_WITH_INVERSE</param>
''' <param name="type"> \param[in]    transparent 1 to use transparency; 0 otherwise</param>
''' <param name="transparent"> \param[in]    transpix pixel grayval in pixs2 that is to be transparent</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlendGray")> _
Friend Shared Function pixBlendGray(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR, x as Integer, y as Integer, fract as single, type as Integer, transparent as Integer, transpix as UInteger) as IntPTR
End Function

' SRC\blend.c (688, 1)
' pixBlendGrayInverse()
' pixBlendGrayInverse(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For inplace operation (pixs1 not cmapped), call it this way:
'''  *   pixBlendGrayInverse(pixs1, pixs1, pixs2, ...)
'''  *   (2) For generating a new pixd:
'''  *   pixd = pixBlendGrayInverse(NULL, pixs1, pixs2, ...)
'''  *   (3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
'''  *   (4) If pixs1 has a colormap, it is removed; otherwise if pixs1
'''  * has depth  8, it is unpacked to generate a 8 bpp pix.
'''  *   (5) This is a no-nonsense blender.  It changes the src1 pixel except
'''  * when the src1 pixel is midlevel gray.  Use fract == 1 for the most
'''  * aggressive blending, where, if the gray pixel in pixs2 is 0,
'''  * we get a complete inversion of the color of the src pixel in pixs1.
'''  *   (6) The basic logic is that each component transforms by:
'''   d  -->  c * d + (1 - c ) * (f * (1 - d) + d * (1 - f))
'''  * where c is the blender pixel from pixs2,
'''  * f is %fract,
'''  * c and d are normalized to [0...1]
'''  * This has the property that for f == 0 (no blend) or c == 1 (white):
'''  *   d  -->  d
'''  * For c == 0 (black) we get maximum inversion:
'''  *   d  -->  f * (1 - d) + d * (1 - f)   [inversion by fraction f]
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd if OK; pixs1 on error</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; either NULL or equal to pixs1 for in-place</param>
''' <param name="pixs1"> \param[in]    pixs1 blendee, depth > 1</param>
''' <param name="pixs2"> \param[in]    pixs2 blender, any depth; typ. smaller in size than pixs1</param>
''' <param name="x"> \param[in]    x,y  origin [UL corner] of pixs2 relative to</param>
''' <param name="y"> \param[in]    fract blending fraction</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlendGrayInverse")> _
Friend Shared Function pixBlendGrayInverse(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR, x as Integer, y as Integer, fract as single) as IntPTR
End Function

' SRC\blend.c (820, 1)
' pixBlendColor()
' pixBlendColor(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32, l_int32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For inplace operation (pixs1 must be 32 bpp), call it this way:
'''  *   pixBlendColor(pixs1, pixs1, pixs2, ...)
'''  *   (2) For generating a new pixd:
'''  *   pixd = pixBlendColor(NULL, pixs1, pixs2, ...)
'''  *   (3) If pixs2 is not 32 bpp rgb, it is converted.
'''  *   (4) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
'''  *   (5) If pixs1 has a colormap, it is removed to generate a 32 bpp pix.
'''  *   (6) If pixs1 has depth  32, it is unpacked to generate a 32 bpp pix.
'''  *   (7) If transparent = 0, the blending fraction (fract) is
'''  * applied equally to all pixels.
'''  *   (8) If transparent = 1, all pixels of value transpix (typically
'''  * either 0 or 0xffffff00) in pixs2 are transparent in the blend.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; either NULL or equal to pixs1 for in-place</param>
''' <param name="pixs1"> \param[in]    pixs1 blendee; depth > 1</param>
''' <param name="pixs2"> \param[in]    pixs2 blender, any depth;; typ. smaller in size than pixs1</param>
''' <param name="x"> \param[in]    x,y  origin [UL corner] of pixs2 relative to</param>
''' <param name="y"> \param[in]    fract blending fraction</param>
''' <param name="fract"> \param[in]    transparent 1 to use transparency; 0 otherwise</param>
''' <param name="transparent"> \param[in]    transpix pixel color in pixs2 that is to be transparent</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlendColor")> _
Friend Shared Function pixBlendColor(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR, x as Integer, y as Integer, fract as single, transparent as Integer, transpix as UInteger) as IntPTR
End Function

' SRC\blend.c (932, 1)
' 
' pixBlendColorByChannel(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32, l_float32, l_float32, l_int32, l_uint32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlendColorByChannel")> _
Friend Shared Function pixBlendColorByChannel(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR, x as Integer, y as Integer, rfract as single, gfract as single, bfract as single, transparent as Integer, transpix as UInteger) as IntPTR
End Function

' SRC\blend.c (1061, 1)
' pixBlendGrayAdapt()
' pixBlendGrayAdapt(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For inplace operation (pixs1 not cmapped), call it this way:
'''  *   pixBlendGrayAdapt(pixs1, pixs1, pixs2, ...)
'''  * For generating a new pixd:
'''  *   pixd = pixBlendGrayAdapt(NULL, pixs1, pixs2, ...)
'''  *   (2) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
'''  *   (3) If pixs1 has a colormap, it is removed.
'''  *   (4) If pixs1 has depth  8, it is unpacked to generate a 8 bpp pix.
'''  *   (5) This does a blend with inverse.  Whereas in pixGlendGray(), the
'''  * zero blend point is where the blendee pixel is 128, here
'''  * the zero blend point is found adaptively, with respect to the
'''  * median of the blendee region.  If the median is  128,
'''  * the zero blend point is found from
'''  *  median + shift.
'''  * Otherwise, if the median >= 128, the zero blend point is
'''  *  median - shift.
'''  * The purpose of shifting the zero blend point away from the
'''  * median is to prevent a situation in pixBlendGray() where
'''  * the median is 128 and the blender is not visible.
'''  * The default value of shift is 64.
'''  *   (6) After processing pixs1, it is either 8 bpp or 32 bpp:
'''  * ~ if 8 bpp, the fraction of pixs2 is mixed with pixs1.
'''  * ~ if 32 bpp, each component of pixs1 is mixed with
'''  *   the same fraction of pixs2.
'''  *   (7) The darker the blender, the more it mixes with the blendee.
'''  * A blender value of 0 has maximum mixing; a value of 255
'''  * has no mixing and hence is transparent.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd if OK; pixs1 on error</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; either NULL or equal to pixs1 for in-place</param>
''' <param name="pixs1"> \param[in]    pixs1 blendee, depth > 1</param>
''' <param name="pixs2"> \param[in]    pixs2 blender, any depth; typ. smaller in size than pixs1</param>
''' <param name="x"> \param[in]    x,y  origin [UL corner] of pixs2 relative to</param>
''' <param name="y"> \param[in]    fract blending fraction</param>
''' <param name="fract"> \param[in]    shift >= 0 but <= 128: shift of zero blend value from</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlendGrayAdapt")> _
Friend Shared Function pixBlendGrayAdapt(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR, x as Integer, y as Integer, fract as single, shift as Integer) as IntPTR
End Function

' SRC\blend.c (1235, 1)
' pixFadeWithGray()
' pixFadeWithGray(PIX *, PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function combines two pix aligned to the UL corner; they
'''  * need not be the same size.
'''  *   (2) Each pixel in pixb is multiplied by 'factor' divided by 255, and
'''  * clipped to the range [0 ... 1].  This gives the fade fraction
'''  * to be applied to pixs.  Fade either to white (L_BLEND_TO_WHITE)
'''  * or to black (L_BLEND_TO_BLACK).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs colormapped or 8 bpp or 32 bpp</param>
''' <param name="pixb"> \param[in]    pixb 8 bpp blender</param>
''' <param name="factor"> \param[in]    factor multiplicative factor to apply to blender value</param>
''' <param name="type"> \param[in]    type L_BLEND_TO_WHITE, L_BLEND_TO_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFadeWithGray")> _
Friend Shared Function pixFadeWithGray(pixs as IntPTR, pixb as IntPTR, factor as single, type as Integer) as IntPTR
End Function

' SRC\blend.c (1349, 1)
' 
' pixBlendHardLight(PIX *, PIX *, PIX *, l_int32, l_int32, l_float32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlendHardLight")> _
Friend Shared Function pixBlendHardLight(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR, x as Integer, y as Integer, fract as single) as IntPTR
End Function

' SRC\blend.c (1555, 1)
' pixBlendCmap()
' pixBlendCmap(PIX *, PIX *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function combines two colormaps, and replaces the pixels
'''  * in pixs that have a specified color value with those in pixb.
'''  *   (2) sindex must be in the existing colormap; otherwise an
'''  * error is returned.  In use, sindex will typically be the index
'''  * for white (255, 255, 255).
'''  *   (3) Blender colors that already exist in the colormap are used;
'''  * others are added.  If any blender colors cannot be
'''  * stored in the colormap, an error is returned.
'''  *   (4) In the implementation, a mapping is generated from each
'''  * original blender colormap index to the corresponding index
'''  * in the expanded colormap for pixs.  Then for each pixel in
'''  * pixs with value sindex, and which is covered by a blender pixel,
'''  * the new index corresponding to the blender pixel is substituted
'''  * for sindex.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 2, 4 or 8 bpp, with colormap</param>
''' <param name="pixb"> \param[in]    pixb colormapped blender</param>
''' <param name="x"> \param[in]    x, y UL corner of blender relative to pixs</param>
''' <param name="y"> \param[in]    sindex colormap index of pixels in pixs to be changed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlendCmap")> _
Friend Shared Function pixBlendCmap(pixs as IntPTR, pixb as IntPTR, x as Integer, y as Integer, sindex as Integer) as Integer
End Function

' SRC\blend.c (1692, 1)
' pixBlendWithGrayMask()
' pixBlendWithGrayMask(PIX *, PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The result is 8 bpp grayscale if both pixs1 and pixs2 are
'''  * 8 bpp gray.  Otherwise, the result is 32 bpp rgb.
'''  *   (2) pixg is an 8 bpp transparency image, where 0 is transparent
'''  * and 255 is opaque.  It determines the transparency of pixs2
'''  * when applied over pixs1.  It can be null if pixs2 is rgba,
'''  * in which case we use the alpha component of pixs2.
'''  *   (3) If pixg exists, it need not be the same size as pixs2.
'''  * However, we assume their UL corners are aligned with each other,
'''  * and placed at the location (x, y) in pixs1.
'''  *   (4) The pixels in pixd are a combination of those in pixs1
'''  * and pixs2, where the amount from pixs2 is proportional to
'''  * the value of the pixel (p) in pixg, and the amount from pixs1
'''  * is proportional to (255 - p).  Thus pixg is a transparency
'''  * image (usually called an alpha blender) where each pixel
'''  * can be associated with a pixel in pixs2, and determines
'''  * the amount of the pixs2 pixel in the final result.
'''  * For example, if pixg is all 0, pixs2 is transparent and
'''  * the result in pixd is simply pixs1.
'''  *   (5) A typical use is for the pixs2/pixg combination to be
'''  * a small watermark that is applied to pixs1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd blended image, or NULL on error</returns>
''' <param name="pixs1"> \param[in]    pixs1 8 bpp gray, rgb, rgba or colormapped</param>
''' <param name="pixs2"> \param[in]    pixs2 8 bpp gray, rgb, rgba or colormapped</param>
''' <param name="pixg"> \param[in]    pixg [optional] 8 bpp gray, for transparency of pixs2;</param>
''' <param name="x"> \param[in]    x, y UL corner of pixs2 and pixg with respect to pixs1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlendWithGrayMask")> _
Friend Shared Function pixBlendWithGrayMask(pixs1 as IntPTR, pixs2 as IntPTR, pixg as IntPTR, x as Integer, y as Integer) as IntPTR
End Function

' SRC\blend.c (1846, 1)
' pixBlendBackgroundToColor()
' pixBlendBackgroundToColor(PIX *, PIX *, BOX *, l_uint32, l_float32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This in effect replaces light background pixels in pixs
'''  * by the input color.  It does it by alpha blending so that
'''  * there are no visible artifacts from hard cutoffs.
'''  *   (2) If pixd == pixs, this is done in-place.
'''  *   (3) If box == NULL, this is performed on all of pixs.
'''  *   (4) The alpha component for blending is derived from pixs,
'''  * by converting to grayscale and enhancing with a TRC.
'''  *   (5) The last three arguments specify the TRC operation.
'''  * Suggested values are: %gamma = 0.3, %minval = 50, %maxval = 200.
'''  * To skip the TRC, use %gamma == 1, %minval = 0, %maxval = 255.
'''  * See pixGammaTRC() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd can be NULL or pixs</param>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="box"> \param[in]    box region for blending; can be NULL)</param>
''' <param name="color"> \param[in]    color 32 bit color in 0xrrggbb00 format</param>
''' <param name="gamma"> \param[in]    gamma, minval, maxval args for grayscale TRC mapping</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlendBackgroundToColor")> _
Friend Shared Function pixBlendBackgroundToColor(pixd as IntPTR, pixs as IntPTR, box as IntPTR, color as UInteger, gamma as single, minval as Integer, maxval as Integer) as IntPTR
End Function

' SRC\blend.c (1926, 1)
' pixMultiplyByColor()
' pixMultiplyByColor(PIX *, PIX *, BOX *, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This filters all pixels in the specified region by
'''  * multiplying each component by the input color.
'''  * This leaves black invariant and transforms white to the
'''  * input color.
'''  *   (2) If pixd == pixs, this is done in-place.
'''  *   (3) If box == NULL, this is performed on all of pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd can be NULL or pixs</param>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="box"> \param[in]    box region for filtering; can be NULL)</param>
''' <param name="color"> \param[in]    color 32 bit color in 0xrrggbb00 format</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMultiplyByColor")> _
Friend Shared Function pixMultiplyByColor(pixd as IntPTR, pixs as IntPTR, box as IntPTR, color as UInteger) as IntPTR
End Function

' SRC\blend.c (2004, 1)
' pixAlphaBlendUniform()
' pixAlphaBlendUniform(PIX *, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a convenience function that renders 32 bpp RGBA images
'''  * (with an alpha channel) over a uniform background of
'''  * value %color.  To render over a white background,
'''  * use %color = 0xffffff00.  The result is an RGB image.
'''  *   (2) If pixs does not have an alpha channel, it returns a clone
'''  * of pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp rgb: pixs blended over uniform color %color,</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgba, with alpha</param>
''' <param name="color"> \param[in]    color 32 bit color in 0xrrggbb00 format</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAlphaBlendUniform")> _
Friend Shared Function pixAlphaBlendUniform(pixs as IntPTR, color as UInteger) as IntPTR
End Function

' SRC\blend.c (2057, 1)
' pixAddAlphaToBlend()
' pixAddAlphaToBlend(PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a simple alpha layer generator, where typically white has
'''  * maximum transparency and black has minimum.
'''  *   (2) If %invert == 1, generate the same alpha layer but invert
'''  * the input image photometrically.  This is useful for blending
'''  * over dark images, where you want dark regions in pixs, such
'''  * as text, to be lighter in the blended image.
'''  *   (3) The fade %fract gives the minimum transparency (i.e.,
'''  * maximum opacity).  A small fraction is useful for adding
'''  * a watermark to an image.
'''  *   (4) If pixs has a colormap, it is removed to rgb.
'''  *   (5) If pixs already has an alpha layer, it is overwritten.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp with alpha, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth</param>
''' <param name="fract"> \param[in]    fract fade fraction in the alpha component</param>
''' <param name="invert"> \param[in]    invert 1 to photometrically invert pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddAlphaToBlend")> _
Friend Shared Function pixAddAlphaToBlend(pixs as IntPTR, fract as single, invert as Integer) as IntPTR
End Function

' SRC\blend.c (2116, 1)
' pixSetAlphaOverWhite()
' pixSetAlphaOverWhite(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The generated alpha component is transparent over white
'''  * (background) pixels in pixs, and quickly grades to opaque
'''  * away from the transparent parts.  This is a cheap and
'''  * dirty alpha generator.  The 2 pixel gradation is useful
'''  * to blur the boundary between the transparent region
'''  * (that will render entirely from a backing image) and
'''  * the remainder which renders from pixs.
'''  *   (2) All alpha component bits in pixs are overwritten.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd new pix with meaningful alpha component,</returns>
''' <param name="pixs"> \param[in]    pixs colormapped or 32 bpp rgb; no alpha</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetAlphaOverWhite")> _
Friend Shared Function pixSetAlphaOverWhite(pixs as IntPTR) as IntPTR
End Function

' SRC\blend.c (2178, 1)
' pixLinearEdgeFade()
' pixLinearEdgeFade(PIX *, l_int32, l_int32, l_float32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) In-place operation.
'''  *   (2) Maximum fading fraction %maxfade occurs at the edge of the image,
'''  * and the fraction goes to 0 at the fractional distance %distfract
'''  * from the edge.  %maxfade must be in [0, 1].
'''  *   (3) %distrfact must be in [0, 1], and typically it would be = 0.5.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs      8 or 32 bpp; no colormap</param>
''' <param name="dir"> \param[in]    dir       L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
''' <param name="fadeto"> \param[in]    fadeto    L_BLEND_TO_WHITE, L_BLEND_TO_BLACK</param>
''' <param name="distfract"> \param[in]    distfract fraction of width or height over which fading occurs</param>
''' <param name="maxfade"> \param[in]    maxfade   fraction of fading at the edge, <= 1.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixLinearEdgeFade")> _
Friend Shared Function pixLinearEdgeFade(pixs as IntPTR, dir as Integer, fadeto as Integer, distfract as single, maxfade as single) as Integer
End Function

#End Region
#Region "SRC\bmf.c"
' SRC\bmf.c (81, 14)
' pixaGenerateFontFromFile()
' pixaGenerateFontFromFile(const char *, l_int32, l_int32 *, l_int32 *, l_int32 *) as PIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa of font bitmaps for 95 characters, or NULL on error</returns>
''' <param name="dir"> \param[in]    dir directory holding image of character set</param>
''' <param name="fontsize"> \param[in]    fontsize 4, 6, 8, ... , 20, in pts at 300 ppi</param>
''' <param name="pbl0"> \param[out]   pbl0 baseline of row 1</param>
''' <param name="pbl1"> \param[out]   pbl1 baseline of row 2</param>
''' <param name="pbl2"> \param[out]   pbl2 baseline of row 3</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGenerateFontFromFile")> _
Friend Shared Function pixaGenerateFontFromFile(dir as String, fontsize as Integer, pbl0 as Integer, pbl1 as Integer, pbl2 as Integer) as IntPTR
End Function

' SRC\bmf.c (84, 14)
' pixaGenerateFontFromString()
' pixaGenerateFontFromString(l_int32, l_int32 *, l_int32 *, l_int32 *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) See pixaGenerateFontFromFile() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa of font bitmaps for 95 characters, or NULL on error</returns>
''' <param name="fontsize"> \param[in]    fontsize 4, 6, 8, ... , 20, in pts at 300 ppi</param>
''' <param name="pbl0"> \param[out]   pbl0 baseline of row 1</param>
''' <param name="pbl1"> \param[out]   pbl1 baseline of row 2</param>
''' <param name="pbl2"> \param[out]   pbl2 baseline of row 3</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGenerateFontFromString")> _
Friend Shared Function pixaGenerateFontFromString(fontsize as Integer, pbl0 as Integer, pbl1 as Integer, pbl2 as Integer) as IntPTR
End Function

' SRC\bmf.c (86, 14)
' pixaGenerateFont()
' pixaGenerateFont(PIX *, l_int32, l_int32 *, l_int32 *, l_int32 *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This does all the work.  See pixaGenerateFontFromFile()
'''  * for an overview.
'''  *   (2) The pix is for one of the 9 fonts.  %fontsize is only
'''  * used here for debugging.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa of font bitmaps for 95 characters, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs of 95 characters in 3 rows</param>
''' <param name="fontsize"> \param[in]    fontsize 4, 6, 8, ... , 20, in pts at 300 ppi</param>
''' <param name="pbl0"> \param[out]   pbl0 baseline of row 1</param>
''' <param name="pbl1"> \param[out]   pbl1 baseline of row 2</param>
''' <param name="pbl2"> \param[out]   pbl2 baseline of row 3</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGenerateFont")> _
Friend Shared Function pixaGenerateFont(pixs as IntPTR, fontsize as Integer, pbl0 as Integer, pbl1 as Integer, pbl2 as Integer) as IntPTR
End Function

' SRC\bmf.c (88, 16)
' pixGetTextBaseline()
' pixGetTextBaseline(PIX *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Method: find the largest difference in pixel sums from one
'''  * raster line to the next one below it.  The baseline is the
'''  * upper raster line for the pair of raster lines that
'''  * maximizes this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, one textline character set</param>
''' <param name="tab8"> \param[in]    tab8 [optional] pixel sum table</param>
''' <param name="py"> \param[out]   py   baseline value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetTextBaseline")> _
Friend Shared Function pixGetTextBaseline(pixs as IntPTR, tab8 as Integer, py as Integer) as Integer
End Function

' SRC\bmf.c (89, 16)
' bmfMakeAsciiTables
' bmfMakeAsciiTables(L_BMF *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This makes three tables, each of size 128, as follows:
'''  * ~ fonttab is a table containing the index of the Pix
'''  *   that corresponds to each input ascii character;
'''  *   it maps (ascii-index) --> Pixa index
'''  * ~ baselinetab is a table containing the baseline offset
'''  *   for the Pix that corresponds to each input ascii character;
'''  *   it maps (ascii-index) --> baseline offset
'''  * ~ widthtab is a table containing the character width in
'''  *   pixels for the Pix that corresponds to that character;
'''  *   it maps (ascii-index) --> bitmap width
'''  *  (2) This also computes
'''  * ~ lineheight (sum of maximum character extensions above and
'''  *   below the baseline)
'''  * ~ kernwidth (spacing between characters within a word)
'''  * ~ spacewidth (space between words)
'''  * ~ vertlinesep (extra vertical spacing between textlines)
'''  *  (3) The baselines apply as follows:
'''  * baseline1   (ascii 32 - 57), ascii 92
'''  * baseline2   (ascii 58 - 91)
'''  * baseline3   (ascii 93 - 126)
'''  *  (4) The only array in bmf that is not ascii-based is the
'''  *   array of bitmaps in the pixa, which starts at ascii 32.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="bmf"> \param[in]    bmf</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bmfMakeAsciiTables")> _
Friend Shared Function bmfMakeAsciiTables(bmf as IntPTR) as Integer
End Function

' SRC\bmf.c (114, 1)
' bmfCreate()
' bmfCreate(const char *, l_int32) as L_BMF *
''' <summary>
''' * Notes:
'''  *   (1) If %dir == null, this generates the font bitmaps from a
'''  * compiled string.
'''  *   (2) Otherwise, this tries to read a pre-computed pixa file with the
'''  * 95 ascii chars in it.  If the file is not found, it then
'''  * attempts to generate the pixa and associated baseline
'''  * data from a tiff image containing all the characters.  If
'''  * that fails, it uses the compiled string.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  bmf holding the bitmap font and associated information</returns>
''' <param name="dir"> \param[in]    dir [optional] directory holding pixa of character set</param>
''' <param name="fontsize"> \param[in]    fontsize 4, 6, 8, ... , 20</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bmfCreate")> _
Friend Shared Function bmfCreate(dir as String, fontsize as Integer) as IntPTR
End Function

' SRC\bmf.c (166, 1)
' bmfDestroy()
' bmfDestroy(L_BMF **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pbmf"> \param[in,out]   pbmf set to null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bmfDestroy")> _
Friend Shared Function bmfDestroy(pbmf as Object) as Boolean ' Org. Void
End Function

' SRC\bmf.c (202, 1)
' bmfGetPix()
' bmfGetPix(L_BMF *, char) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix clone of pix in bmf, or NULL on error</returns>
''' <param name="bmf"> \param[in]    bmf</param>
''' <param name="chr"> \param[in]    chr should be one of the 95 supported printable bitmaps</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bmfGetPix")> _
Friend Shared Function bmfGetPix(bmf as IntPTR, chr as Object) as IntPTR
End Function

' SRC\bmf.c (237, 1)
' bmfGetWidth()
' bmfGetWidth(L_BMF *, char, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="bmf"> \param[in]    bmf</param>
''' <param name="chr"> \param[in]    chr should be one of the 95 supported bitmaps</param>
''' <param name="pw"> \param[out]   pw character width; -1 if not printable</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bmfGetWidth")> _
Friend Shared Function bmfGetWidth(bmf as IntPTR, chr as Object, pw as Integer) as Integer
End Function

' SRC\bmf.c (276, 1)
' bmfGetBaseline()
' bmfGetBaseline(L_BMF *, char, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="bmf"> \param[in]    bmf</param>
''' <param name="chr"> \param[in]    chr should be one of the 95 supported bitmaps</param>
''' <param name="pbaseline"> \param[out]   pbaseline  distance below UL corner of bitmap char</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bmfGetBaseline")> _
Friend Shared Function bmfGetBaseline(bmf as IntPTR, chr as Object, pbaseline as Integer) as Integer
End Function

' SRC\bmf.c (322, 1)
' pixaGetFont()
' pixaGetFont(const char *, l_int32, l_int32 *, l_int32 *, l_int32 *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This reads a pre-computed pixa file with the 95 ascii chars.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa of font bitmaps for 95 characters, or NULL on error</returns>
''' <param name="dir"> \param[in]    dir directory holding pixa of character set</param>
''' <param name="fontsize"> \param[in]    fontsize 4, 6, 8, ... , 20</param>
''' <param name="pbl0"> \param[out]   pbl0 baseline of row 1</param>
''' <param name="pbl1"> \param[out]   pbl1 baseline of row 2</param>
''' <param name="pbl2"> \param[out]   pbl2 baseline of row 3</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGetFont")> _
Friend Shared Function pixaGetFont(dir as String, fontsize as Integer, pbl0 as Integer, pbl1 as Integer, pbl2 as Integer) as IntPTR
End Function

' SRC\bmf.c (372, 1)
' pixaSaveFont()
' pixaSaveFont(const char *, const char *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This saves a font of a particular size.
'''  *   (2) If %dir == null, this generates the font bitmaps from a
'''  * compiled string.
'''  *   (3) prog/genfonts calls this function for each of the
'''  * nine font sizes, to generate all the font pixa files.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="indir"> \param[in]    indir [optional] directory holding image of character set</param>
''' <param name="outdir"> \param[in]    outdir directory into which the output pixa file</param>
''' <param name="fontsize"> \param[in]    fontsize in pts, at 300 ppi</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSaveFont")> _
Friend Shared Function pixaSaveFont(indir as String, outdir as String, fontsize as Integer) as Integer
End Function

#End Region
#Region "SRC\bmpio.c"
' SRC\bmpio.c (89, 1)
' pixReadStreamBmp()
' pixReadStreamBmp(FILE *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Here are references on the bmp file format:
'''  * http://en.wikipedia.org/wiki/BMP_file_format
'''  * http://www.fortunecity.com/skyscraper/windows/364/bmpffrmt.html
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream opened for read</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadStreamBmp")> _
Friend Shared Function pixReadStreamBmp(fp as Object) as IntPTR
End Function

' SRC\bmpio.c (119, 1)
' pixReadMemBmp()
' pixReadMemBmp(const l_uint8 *, size_t) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="cdata"> \param[in]    cdata    bmp data</param>
''' <param name="size"> \param[in]    size     number of bytes of bmp-formatted data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadMemBmp")> _
Friend Shared Function pixReadMemBmp(cdata as Byte, size as ULong) as IntPTR
End Function

' SRC\bmpio.c (351, 1)
' pixWriteStreamBmp()
' pixWriteStreamBmp(FILE *, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp     file stream</param>
''' <param name="pix"> \param[in]    pix    all depths</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamBmp")> _
Friend Shared Function pixWriteStreamBmp(fp as Object, pix as IntPTR) as Integer
End Function

' SRC\bmpio.c (396, 1)
' pixWriteMemBmp()
' pixWriteMemBmp(l_uint8 **, size_t *, PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) 2 bpp bmp files are not valid in the spec, and are
'''  * written as 8 bpp.
'''  *   (2) pix with depth = 8 bpp are written with a colormap.
'''  * 16 bpp gray and 32 bpp rgb pix are written without a colormap.
'''  *   (3) The transparency component in an rgb pix is ignored.
'''  * All 32 bpp pix have the bmp alpha component set to 255 (opaque).
'''  *   (4) The bmp colormap entries, RGBA_QUAD, are the same as
'''  * the ones used for colormaps in leptonica.  This allows
'''  * a simple memcpy for bmp output.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pfdata"> \param[out]   pfdata   data of bmp formatted image</param>
''' <param name="pfsize"> \param[out]   pfsize    size of returned data</param>
''' <param name="pixs"> \param[in]    pixs      1, 2, 4, 8, 16, 32 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMemBmp")> _
Friend Shared Function pixWriteMemBmp(pfdata as Object, pfsize as ULong, pixs as IntPTR) as Integer
End Function

#End Region
#Region "SRC\bootnumgen1.c"
' SRC\bootnumgen1.c (290, 1)
' l_bootnum_gen1()
' l_bootnum_gen1() as PIXA *
''' <summary>
''' * Call this way:
'''  *   PIXA  *pixa = l_bootnum_gen1();   (C)
'''  *   Pixa  *pixa = l_bootnum_gen1();   (C++)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   pixa  of labeled digits</returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_bootnum_gen1")> _
Friend Shared Function l_bootnum_gen1() as IntPTR
End Function

#End Region
#Region "SRC\bootnumgen2.c"
' SRC\bootnumgen2.c (273, 1)
' l_bootnum_gen2()
' l_bootnum_gen2() as PIXA *
''' <summary>
''' * Call this way:
'''  *   PIXA  *pixa = l_bootnum_gen2();   (C)
'''  *   Pixa  *pixa = l_bootnum_gen2();   (C++)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   pixa  of labeled digits</returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_bootnum_gen2")> _
Friend Shared Function l_bootnum_gen2() as IntPTR
End Function

#End Region
#Region "SRC\bootnumgen3.c"
' SRC\bootnumgen3.c (349, 1)
' l_bootnum_gen3()
' l_bootnum_gen3() as PIXA *
''' <summary>
''' * Call this way:
'''  *   PIXA  *pixa = l_bootnum_gen3();   (C)
'''  *   Pixa  *pixa = l_bootnum_gen3();   (C++)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   pixa  of labeled digits</returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_bootnum_gen3")> _
Friend Shared Function l_bootnum_gen3() as IntPTR
End Function

#End Region
#Region "SRC\boxbasic.c"
' SRC\boxbasic.c (165, 1)
' boxCreate()
' boxCreate(l_int32, l_int32, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This clips the box to the +quad.  If no part of the
'''  * box is in the +quad, this returns NULL.
'''  *   (2) We allow you to make a box with w = 0 and/or h = 0.
'''  * This does not represent a valid region, but it is useful
'''  * as a placeholder in a boxa for which the index of the
'''  * box in the boxa is important.  This is an atypical
'''  * situation; usually you want to put only valid boxes with
'''  * nonzero width and height in a boxa.  If you have a boxa
'''  * with invalid boxes, the accessor boxaGetValidBox()
'''  * will return NULL on each invalid box.
'''  *   (3) If you want to create only valid boxes, use boxCreateValid(),
'''  * which returns NULL if either w or h is 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box, or NULL on error</returns>
''' <param name="x"> \param[in]    x, y, w, h</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxCreate")> _
Friend Shared Function boxCreate(x as Integer, y as Integer, w as Integer, h as Integer) as IntPTR
End Function

' SRC\boxbasic.c (210, 1)
' boxCreateValid()
' boxCreateValid(l_int32, l_int32, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This returns NULL if either w = 0 or h = 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box, or NULL on error</returns>
''' <param name="x"> \param[in]    x, y, w, h</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxCreateValid")> _
Friend Shared Function boxCreateValid(x as Integer, y as Integer, w as Integer, h as Integer) as IntPTR
End Function

' SRC\boxbasic.c (230, 1)
' boxCopy()
' boxCopy(BOX *) as BOX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  copy of box, or NULL on error</returns>
''' <param name="box"> \param[in]    box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxCopy")> _
Friend Shared Function boxCopy(box as IntPTR) as IntPTR
End Function

' SRC\boxbasic.c (252, 1)
' boxClone()
' boxClone(BOX *) as BOX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to same box, or NULL on error</returns>
''' <param name="box"> \param[in]    box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxClone")> _
Friend Shared Function boxClone(box as IntPTR) as IntPTR
End Function

' SRC\boxbasic.c (278, 1)
' boxDestroy()
' boxDestroy(BOX **) as void
''' <summary>
''' * Notes:
'''  *   (1) Decrements the ref count and, if 0, destroys the box.
'''  *   (2) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pbox"> \param[in,out]   pbox will be set to null before returning</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxDestroy")> _
Friend Shared Function boxDestroy(pbox as Object) as Boolean ' Org. Void
End Function

' SRC\boxbasic.c (310, 1)
' boxGetGeometry()
' boxGetGeometry(BOX *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="px"> \param[out]   px, py, pw, ph [optional]  each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxGetGeometry")> _
Friend Shared Function boxGetGeometry(box as IntPTR, px as Integer, py as Integer, pw as Integer, ph as Integer) as Integer
End Function

' SRC\boxbasic.c (340, 1)
' boxSetGeometry()
' boxSetGeometry(BOX *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="x"> \param[in]    x, y, w, h  [optional]  use -1 to leave unchanged</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxSetGeometry")> _
Friend Shared Function boxSetGeometry(box as IntPTR, x as Integer, y as Integer, w as Integer, h as Integer) as Integer
End Function

' SRC\boxbasic.c (371, 1)
' boxGetSideLocations()
' boxGetSideLocations(BOX *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) All returned values are within the box.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="pl"> \param[out]   pl, pt, pr, pb [optional]  each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxGetSideLocations")> _
Friend Shared Function boxGetSideLocations(box as IntPTR, pl as Integer, pr as Integer, pt as Integer, pb as Integer) as Integer
End Function

' SRC\boxbasic.c (405, 1)
' boxSetSideLocations()
' boxSetSideLocations(BOX *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="l"> \param[in]    l, r, t, b  [optional] use -1 to leave unchanged</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxSetSideLocations")> _
Friend Shared Function boxSetSideLocations(box as IntPTR, l as Integer, r as Integer, t as Integer, b as Integer) as Integer
End Function

' SRC\boxbasic.c (432, 1)
' Return the current reference count of %box
' boxGetRefcount(BOX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return   refcount</returns>
''' <param name="box"> \param[in]     box ptr to Box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxGetRefcount")> _
Friend Shared Function boxGetRefcount(box as IntPTR) as Integer
End Function

' SRC\boxbasic.c (449, 1)
' Adjust the current references count of %box by %delta
' boxChangeRefcount(BOX *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="box"> \param[in]     box ptr to box</param>
''' <param name="delta"> \param[in]     delta adjustment, usually -1 or 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxChangeRefcount")> _
Friend Shared Function boxChangeRefcount(box as IntPTR, delta as Integer) as Integer
End Function

' SRC\boxbasic.c (470, 1)
' boxIsValid()
' boxIsValid(BOX *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="pvalid"> \param[out]   pvalid 1 if valid; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxIsValid")> _
Friend Shared Function boxIsValid(box as IntPTR, pvalid as Integer) as Integer
End Function

' SRC\boxbasic.c (497, 1)
' boxaCreate()
' boxaCreate(l_int32) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="n"> \param[in]    n  initial number of ptrs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaCreate")> _
Friend Shared Function boxaCreate(n as Integer) as IntPTR
End Function

' SRC\boxbasic.c (532, 1)
' boxaCopy()
' boxaCopy(BOXA *, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) See pix.h for description of the copyflag.
'''  *   (2) The copy-clone makes a new boxa that holds clones of each box.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  new boxa, or NULL on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="copyflag"> \param[in]    copyflag L_COPY, L_CLONE, L_COPY_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaCopy")> _
Friend Shared Function boxaCopy(boxa as IntPTR, copyflag as Integer) as IntPTR
End Function

' SRC\boxbasic.c (578, 1)
' boxaDestroy()
' boxaDestroy(BOXA **) as void
''' <summary>
''' * Notes:
'''  *   (1) Decrements the ref count and, if 0, destroys the boxa.
'''  *   (2) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pboxa"> \param[in,out]   pboxa will be set to null before returning</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaDestroy")> _
Friend Shared Function boxaDestroy(pboxa as Object) as Boolean ' Org. Void
End Function

' SRC\boxbasic.c (616, 1)
' boxaAddBox()
' boxaAddBox(BOXA *, BOX *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="box"> \param[in]    box  to be added</param>
''' <param name="copyflag"> \param[in]    copyflag L_INSERT, L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaAddBox")> _
Friend Shared Function boxaAddBox(boxa as IntPTR, box as IntPTR, copyflag as Integer) as Integer
End Function

' SRC\boxbasic.c (663, 1)
' boxaExtendArray()
' boxaExtendArray(BOXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Reallocs with doubled size of ptr array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaExtendArray")> _
Friend Shared Function boxaExtendArray(boxa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (687, 1)
' boxaExtendArrayToSize()
' boxaExtendArrayToSize(BOXA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If necessary, reallocs new boxa ptr array to %size.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="size"> \param[in]    size new size of boxa array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaExtendArrayToSize")> _
Friend Shared Function boxaExtendArrayToSize(boxa as IntPTR, size as Integer) as Integer
End Function

' SRC\boxbasic.c (716, 1)
' boxaGetCount()
' boxaGetCount(BOXA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count of all boxes; 0 if no boxes or on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetCount")> _
Friend Shared Function boxaGetCount(boxa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (733, 1)
' boxaGetValidCount()
' boxaGetValidCount(BOXA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count of valid boxes; 0 if no valid boxes or on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetValidCount")> _
Friend Shared Function boxaGetValidCount(boxa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (761, 1)
' boxaGetBox()
' boxaGetBox(BOXA *, l_int32, l_int32) as BOX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box, or NULL on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="index"> \param[in]    index  to the index-th box</param>
''' <param name="accessflag"> \param[in]    accessflag  L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetBox")> _
Friend Shared Function boxaGetBox(boxa as IntPTR, index as Integer, accessflag as Integer) as IntPTR
End Function

' SRC\boxbasic.c (800, 1)
' boxaGetValidBox()
' boxaGetValidBox(BOXA *, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This returns NULL for an invalid box in a boxa.
'''  * For a box to be valid, both the width and height must be > 0.
'''  *   (2) We allow invalid boxes, with w = 0 or h = 0, as placeholders
'''  * in boxa for which the index of the box in the boxa is important.
'''  * This is an atypical situation; usually you want to put only
'''  * valid boxes in a boxa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box, or NULL if box is not valid or on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="index"> \param[in]    index  to the index-th box</param>
''' <param name="accessflag"> \param[in]    accessflag  L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetValidBox")> _
Friend Shared Function boxaGetValidBox(boxa as IntPTR, index as Integer, accessflag as Integer) as IntPTR
End Function

' SRC\boxbasic.c (828, 1)
' boxaFindInvalidBoxes()
' boxaFindInvalidBoxes(BOXA *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na   numa of invalid boxes; NULL if there are none or on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaFindInvalidBoxes")> _
Friend Shared Function boxaFindInvalidBoxes(boxa as IntPTR) as IntPTR
End Function

' SRC\boxbasic.c (861, 1)
' boxaGetBoxGeometry()
' boxaGetBoxGeometry(BOXA *, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="index"> \param[in]    index  to the index-th box</param>
''' <param name="px"> \param[out]   px, py, pw, ph [optional]  each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetBoxGeometry")> _
Friend Shared Function boxaGetBoxGeometry(boxa as IntPTR, index as Integer, px as Integer, py as Integer, pw as Integer, ph as Integer) as Integer
End Function

' SRC\boxbasic.c (897, 1)
' boxaIsFull()
' boxaIsFull(BOXA *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="pfull"> \param[out]   pfull 1 if boxa is full</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaIsFull")> _
Friend Shared Function boxaIsFull(boxa as IntPTR, pfull as Integer) as Integer
End Function

' SRC\boxbasic.c (943, 1)
' boxaReplaceBox()
' boxaReplaceBox(BOXA *, l_int32, BOX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) In-place replacement of one box.
'''  *   (2) The previous box at that location, if any, is destroyed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="index"> \param[in]    index  to the index-th box</param>
''' <param name="box"> \param[in]    box insert to replace existing one</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaReplaceBox")> _
Friend Shared Function boxaReplaceBox(boxa as IntPTR, index as Integer, box as IntPTR) as Integer
End Function

' SRC\boxbasic.c (981, 1)
' boxaInsertBox()
' boxaInsertBox(BOXA *, l_int32, BOX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This shifts box[i] --> box[i + 1] for all i >= index,
'''  * and then inserts box as box[index].
'''  *   (2) To insert at the beginning of the array, set index = 0.
'''  *   (3) To append to the array, it's easier to use boxaAddBox().
'''  *   (4) This should not be used repeatedly to insert into large arrays,
'''  * because the function is O(n).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="index"> \param[in]    index location in boxa to insert new value</param>
''' <param name="box"> \param[in]    box new box to be inserted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaInsertBox")> _
Friend Shared Function boxaInsertBox(boxa as IntPTR, index as Integer, box as IntPTR) as Integer
End Function

' SRC\boxbasic.c (1026, 1)
' boxaRemoveBox()
' boxaRemoveBox(BOXA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This removes box[index] and then shifts
'''  * box[i] --> box[i - 1] for all i > index.
'''  *   (2) It should not be used repeatedly to remove boxes from
'''  * large arrays, because the function is O(n).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="index"> \param[in]    index of box to be removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaRemoveBox")> _
Friend Shared Function boxaRemoveBox(boxa as IntPTR, index as Integer) as Integer
End Function

' SRC\boxbasic.c (1068, 1)
' boxaRemoveBoxAndSave()
' boxaRemoveBoxAndSave(BOXA *, l_int32, BOX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This removes box[index] and then shifts
'''  * box[i] --> box[i - 1] for all i > index.
'''  *   (2) It should not be used repeatedly to remove boxes from
'''  * large arrays, because the function is O(n).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="index"> \param[in]    index of box to be removed</param>
''' <param name="pbox"> \param[out]   pbox [optional] removed box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaRemoveBoxAndSave")> _
Friend Shared Function boxaRemoveBoxAndSave(boxa as IntPTR, index as Integer, pbox as Object) as Integer
End Function

' SRC\boxbasic.c (1110, 1)
' boxaSaveValid()
' boxaSaveValid(BOXA *, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This makes a copy/clone of each valid box.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad if OK, NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="copyflag"> \param[in]    copyflag L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSaveValid")> _
Friend Shared Function boxaSaveValid(boxas as IntPTR, copyflag as Integer) as IntPTR
End Function

' SRC\boxbasic.c (1174, 1)
' boxaInitFull()
' boxaInitFull(BOXA *, BOX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This initializes a boxa by filling up the entire box ptr array
'''  * with copies of %box.  If %box == NULL, use a placeholder box
'''  * of zero size.  Any existing boxes are destroyed.
'''  * After this opepration, the number of boxes is equal to
'''  * the number of allocated ptrs.
'''  *   (2) Note that we use boxaReplaceBox() instead of boxaInsertBox().
'''  * They both have the same effect when inserting into a NULL ptr
'''  * in the boxa ptr array:
'''  *   (3) Example usage.  This function is useful to prepare for a
'''  * random insertion (or replacement) of boxes into a boxa.
'''  * To randomly insert boxes into a boxa, up to some index "max":
'''  * Boxa *boxa = boxaCreate(max);
'''  * boxaInitFull(boxa, NULL);
'''  * If you want placeholder boxes of non-zero size:
'''  * Boxa *boxa = boxaCreate(max);
'''  * Box *box = boxCreate(...);
'''  * boxaInitFull(boxa, box);
'''  * boxDestroy(&box);
'''  * If we have an existing boxa with a smaller ptr array, it can
'''  * be reused for up to max boxes:
'''  * boxaExtendArrayToSize(boxa, max);
'''  * boxaInitFull(boxa, NULL);
'''  * The initialization allows the boxa to always be properly
'''  * filled, even if all the boxes are not later replaced.
'''  * If you want to know which boxes have been replaced,
'''  * and you initialized with invalid zero-sized boxes,
'''  * use boxaGetValidBox() to return NULL for the invalid boxes.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa typically empty</param>
''' <param name="box"> \param[in]    box [optional] to be replicated into the entire ptr array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaInitFull")> _
Friend Shared Function boxaInitFull(boxa as IntPTR, box as IntPTR) as Integer
End Function

' SRC\boxbasic.c (1211, 1)
' boxaClear()
' boxaClear(BOXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This destroys all boxes in the boxa, setting the ptrs
'''  * to null.  The number of allocated boxes, n, is set to 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaClear")> _
Friend Shared Function boxaClear(boxa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (1238, 1)
' boxaaCreate()
' boxaaCreate(l_int32) as BOXAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  baa, or NULL on error</returns>
''' <param name="n"> \param[in]    n size of boxa ptr array to be alloc'd; 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaCreate")> _
Friend Shared Function boxaaCreate(n as Integer) as IntPTR
End Function

' SRC\boxbasic.c (1273, 1)
' boxaaCopy()
' boxaaCopy(BOXAA *, l_int32) as BOXAA *
''' <summary>
''' * Notes:
'''  *   (1) L_COPY makes a copy of each boxa in baas.
'''  * L_CLONE makes a clone of each boxa in baas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  baad new boxaa, composed of copies or clones of the boxa</returns>
''' <param name="baas"> \param[in]    baas input boxaa to be copied</param>
''' <param name="copyflag"> \param[in]    copyflag L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaCopy")> _
Friend Shared Function boxaaCopy(baas as IntPTR, copyflag as Integer) as IntPTR
End Function

' SRC\boxbasic.c (1304, 1)
' boxaaDestroy()
' boxaaDestroy(BOXAA **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="pbaa"> \param[in,out]   pbaa will be set to null before returning</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaDestroy")> _
Friend Shared Function boxaaDestroy(pbaa as Object) as Boolean ' Org. Void
End Function

' SRC\boxbasic.c (1342, 1)
' boxaaAddBoxa()
' boxaaAddBoxa(BOXAA *, BOXA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="ba"> \param[in]    ba     to be added</param>
''' <param name="copyflag"> \param[in]    copyflag  L_INSERT, L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaAddBoxa")> _
Friend Shared Function boxaaAddBoxa(baa as IntPTR, ba as IntPTR, copyflag as Integer) as Integer
End Function

' SRC\boxbasic.c (1379, 1)
' boxaaExtendArray()
' boxaaExtendArray(BOXAA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="baa"> \param[in]    baa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaExtendArray")> _
Friend Shared Function boxaaExtendArray(baa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (1410, 1)
' boxaaExtendArrayToSize()
' boxaaExtendArrayToSize(BOXAA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If necessary, reallocs the boxa ptr array to %size.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="size"> \param[in]    size new size of boxa array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaExtendArrayToSize")> _
Friend Shared Function boxaaExtendArrayToSize(baa as IntPTR, size as Integer) as Integer
End Function

' SRC\boxbasic.c (1439, 1)
' boxaaGetCount()
' boxaaGetCount(BOXAA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count number of boxa, or 0 if no boxa or on error</returns>
''' <param name="baa"> \param[in]    baa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaGetCount")> _
Friend Shared Function boxaaGetCount(baa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (1456, 1)
' boxaaGetBoxCount()
' boxaaGetBoxCount(BOXAA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count number of boxes, or 0 if no boxes or on error</returns>
''' <param name="baa"> \param[in]    baa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaGetBoxCount")> _
Friend Shared Function boxaaGetBoxCount(baa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (1486, 1)
' boxaaGetBoxa()
' boxaaGetBoxa(BOXAA *, l_int32, l_int32) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="index"> \param[in]    index  to the index-th boxa</param>
''' <param name="accessflag"> \param[in]    accessflag   L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaGetBoxa")> _
Friend Shared Function boxaaGetBoxa(baa as IntPTR, index as Integer, accessflag as Integer) as IntPTR
End Function

' SRC\boxbasic.c (1516, 1)
' boxaaGetBox()
' boxaaGetBox(BOXAA *, l_int32, l_int32, l_int32) as BOX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box, or NULL on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="iboxa"> \param[in]    iboxa  index into the boxa array in the boxaa</param>
''' <param name="ibox"> \param[in]    ibox  index into the box array in the boxa</param>
''' <param name="accessflag"> \param[in]    accessflag   L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaGetBox")> _
Friend Shared Function boxaaGetBox(baa as IntPTR, iboxa as Integer, ibox as Integer, accessflag as Integer) as IntPTR
End Function

' SRC\boxbasic.c (1568, 1)
' boxaaInitFull()
' boxaaInitFull(BOXAA *, BOXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This initializes a boxaa by filling up the entire boxa ptr array
'''  * with copies of %boxa.  Any existing boxa are destroyed.
'''  * After this operation, the number of boxa is equal to
'''  * the number of allocated ptrs.
'''  *   (2) Note that we use boxaaReplaceBox() instead of boxaInsertBox().
'''  * They both have the same effect when inserting into a NULL ptr
'''  * in the boxa ptr array
'''  *   (3) Example usage.  This function is useful to prepare for a
'''  * random insertion (or replacement) of boxa into a boxaa.
'''  * To randomly insert boxa into a boxaa, up to some index "max":
'''  * Boxaa *baa = boxaaCreate(max);
'''  *   // initialize the boxa
'''  * Boxa *boxa = boxaCreate(...);
'''  * ...  [optionally fix with boxes]
'''  * boxaaInitFull(baa, boxa);
'''  * A typical use is to initialize the array with empty boxa,
'''  * and to replace only a subset that must be aligned with
'''  * something else, such as a pixa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="baa"> \param[in]    baa typically empty</param>
''' <param name="boxa"> \param[in]    boxa to be replicated into the entire ptr array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaInitFull")> _
Friend Shared Function boxaaInitFull(baa as IntPTR, boxa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (1608, 1)
' boxaaExtendWithInit()
' boxaaExtendWithInit(BOXAA *, l_int32, BOXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This should be used on an existing boxaa that has been
'''  * fully loaded with boxa.  It then extends the boxaa,
'''  * loading all the additional ptrs with copies of boxa.
'''  * Typically, boxa will be empty.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="maxindex"> \param[in]    maxindex</param>
''' <param name="boxa"> \param[in]    boxa to be replicated into the extended ptr array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaExtendWithInit")> _
Friend Shared Function boxaaExtendWithInit(baa as IntPTR, maxindex as Integer, boxa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (1649, 1)
' boxaaReplaceBoxa()
' boxaaReplaceBoxa(BOXAA *, l_int32, BOXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Any existing boxa is destroyed, and the input one
'''  * is inserted in its place.
'''  *   (2) If the index is invalid, return 1 (error)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="index"> \param[in]    index  to the index-th boxa</param>
''' <param name="boxa"> \param[in]    boxa insert and replace any existing one</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaReplaceBoxa")> _
Friend Shared Function boxaaReplaceBoxa(baa as IntPTR, index as Integer, boxa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (1690, 1)
' boxaaInsertBoxa()
' boxaaInsertBoxa(BOXAA *, l_int32, BOXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This shifts boxa[i] --> boxa[i + 1] for all i >= index,
'''  * and then inserts boxa as boxa[index].
'''  *   (2) To insert at the beginning of the array, set index = 0.
'''  *   (3) To append to the array, it's easier to use boxaaAddBoxa().
'''  *   (4) This should not be used repeatedly to insert into large arrays,
'''  * because the function is O(n).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="index"> \param[in]    index location in boxaa to insert new boxa</param>
''' <param name="boxa"> \param[in]    boxa new boxa to be inserted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaInsertBoxa")> _
Friend Shared Function boxaaInsertBoxa(baa as IntPTR, index as Integer, boxa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (1736, 1)
' boxaaRemoveBoxa()
' boxaaRemoveBoxa(BOXAA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This removes boxa[index] and then shifts
'''  * boxa[i] --> boxa[i - 1] for all i > index.
'''  *   (2) The removed boxaa is destroyed.
'''  *   (2) This should not be used repeatedly on large arrays,
'''  * because the function is O(n).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="index"> \param[in]    index  of the boxa to be removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaRemoveBoxa")> _
Friend Shared Function boxaaRemoveBoxa(baa as IntPTR, index as Integer) as Integer
End Function

' SRC\boxbasic.c (1776, 1)
' boxaaAddBox()
' boxaaAddBox(BOXAA *, l_int32, BOX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Adds to an existing boxa only.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="index"> \param[in]    index of boxa with boxaa</param>
''' <param name="box"> \param[in]    box to be added</param>
''' <param name="accessflag"> \param[in]    accessflag L_INSERT, L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaAddBox")> _
Friend Shared Function boxaaAddBox(baa as IntPTR, index as Integer, box as IntPTR, accessflag as Integer) as Integer
End Function

' SRC\boxbasic.c (1824, 1)
' boxaaReadFromFiles()
' boxaaReadFromFiles(const char *, const char *, l_int32, l_int32) as BOXAA *
''' <summary>
''' * Notes:
'''  *   (1) The files must be serialized boxa files (e.g., *.ba).
'''  * If some files cannot be read, warnings are issued.
'''  *   (2) Use %substr to filter filenames in the directory.  If
'''  * %substr == NULL, this takes all files.
'''  *   (3) After filtering, use %first and %nfiles to select
'''  * a contiguous set of files, that have been lexically
'''  * sorted in increasing order.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  baa, or NULL on error or if no boxa files are found.</returns>
''' <param name="dirname"> \param[in]    dirname directory</param>
''' <param name="substr"> \param[in]    substr [optional] substring filter on filenames; can be NULL</param>
''' <param name="first"> \param[in]    first 0-based</param>
''' <param name="nfiles"> \param[in]    nfiles use 0 for everything from %first to the end</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaReadFromFiles")> _
Friend Shared Function boxaaReadFromFiles(dirname as String, substr as String, first as Integer, nfiles as Integer) as IntPTR
End Function

' SRC\boxbasic.c (1868, 1)
' boxaaRead()
' boxaaRead(const char *) as BOXAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxaa, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaRead")> _
Friend Shared Function boxaaRead(filename as String) as IntPTR
End Function

' SRC\boxbasic.c (1895, 1)
' boxaaReadStream()
' boxaaReadStream(FILE *) as BOXAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxaa, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaReadStream")> _
Friend Shared Function boxaaReadStream(fp as Object) as IntPTR
End Function

' SRC\boxbasic.c (1940, 1)
' boxaaReadMem()
' boxaaReadMem(const l_uint8 *, size_t) as BOXAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  baa, or NULL on error</returns>
''' <param name="data"> \param[in]    data  serialization of boxaa; in ascii</param>
''' <param name="size"> \param[in]    size  of data in bytes; can use strlen to get it</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaReadMem")> _
Friend Shared Function boxaaReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\boxbasic.c (1968, 1)
' boxaaWrite()
' boxaaWrite(const char *, BOXAA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="baa"> \param[in]    baa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaWrite")> _
Friend Shared Function boxaaWrite(filename as String, baa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (1999, 1)
' boxaaWriteStream()
' boxaaWriteStream(FILE *, BOXAA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]   fp file stream</param>
''' <param name="baa"> \param[in]   baa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaWriteStream")> _
Friend Shared Function boxaaWriteStream(fp as Object, baa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (2046, 1)
' boxaaWriteMem()
' boxaaWriteMem(l_uint8 **, size_t *, BOXAA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a boxaa in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata  data of serialized boxaa; ascii</param>
''' <param name="psize"> \param[out]   psize  size of returned data</param>
''' <param name="baa"> \param[in]    baa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaWriteMem")> _
Friend Shared Function boxaaWriteMem(pdata as Object, psize as ULong, baa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (2096, 1)
' boxaRead()
' boxaRead(const char *) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaRead")> _
Friend Shared Function boxaRead(filename as String) as IntPTR
End Function

' SRC\boxbasic.c (2123, 1)
' boxaReadStream()
' boxaReadStream(FILE *) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaReadStream")> _
Friend Shared Function boxaReadStream(fp as Object) as IntPTR
End Function

' SRC\boxbasic.c (2166, 1)
' boxaReadMem()
' boxaReadMem(const l_uint8 *, size_t) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="data"> \param[in]    data  serialization of boxa; in ascii</param>
''' <param name="size"> \param[in]    size  of data in bytes; can use strlen to get it</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaReadMem")> _
Friend Shared Function boxaReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\boxbasic.c (2203, 1)
' boxaWriteDebug()
' boxaWriteDebug(const char *, BOXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Debug version, intended for use in the library when writing
'''  * to files in a temp directory with names that are compiled in.
'''  * This is used instead of boxaWrite() for all such library calls.
'''  *   (2) The global variable LeptDebugOK defaults to 0, and can be set
'''  * or cleared by the function setLeptDebugOK().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="boxa"> \param[in]    boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaWriteDebug")> _
Friend Shared Function boxaWriteDebug(filename as String, boxa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (2225, 1)
' boxaWrite()
' boxaWrite(const char *, BOXA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="boxa"> \param[in]    boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaWrite")> _
Friend Shared Function boxaWrite(filename as String, boxa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (2257, 1)
' boxaWriteStream()
' boxaWriteStream(FILE *, BOXA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]   fp file stream</param>
''' <param name="boxa"> \param[in]   boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaWriteStream")> _
Friend Shared Function boxaWriteStream(fp as Object, boxa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (2298, 1)
' boxaWriteMem()
' boxaWriteMem(l_uint8 **, size_t *, BOXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a boxa in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of serialized boxa; ascii</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="boxa"> \param[in]    boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaWriteMem")> _
Friend Shared Function boxaWriteMem(pdata as Object, psize as ULong, boxa as IntPTR) as Integer
End Function

' SRC\boxbasic.c (2355, 1)
' boxPrintStreamInfo()
' boxPrintStreamInfo(FILE *, BOX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This outputs debug info.  Use serialization functions to
'''  * write to file if you want to read the data back.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="box"> \param[in]    box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxPrintStreamInfo")> _
Friend Shared Function boxPrintStreamInfo(fp as Object, box as IntPTR) as Integer
End Function

#End Region
#Region "SRC\boxfunc1.c"
' SRC\boxfunc1.c (81, 16)
' boxHasOverlapInXorY()
' boxHasOverlapInXorY(l_int32, l_int32, l_int32, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Like boxGetDistanceInXorY(), this is used for overlaps both in
'''  * x (which projected vertically) and in y (projected horizontally)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if no overlap; 1 if any overlap</returns>
''' <param name="c1"> \param[in]    c1   left or top coordinate of box1</param>
''' <param name="s1"> \param[in]    s1   width or height of box1</param>
''' <param name="c2"> \param[in]    c2   left or top coordinate of box2</param>
''' <param name="s2"> \param[in]    s2   width or height of box2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxHasOverlapInXorY")> _
Friend Shared Function boxHasOverlapInXorY(c1 as Integer, s1 as Integer, c2 as Integer, s2 as Integer) as Integer
End Function

' SRC\boxfunc1.c (83, 16)
' boxGetDistanceInXorY()
' boxGetDistanceInXorY(l_int32, l_int32, l_int32, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  distance between them (if < 0, box2 overlaps box1 in the</returns>
''' <param name="c1"> \param[in]    c1   left or top coordinate of box1</param>
''' <param name="s1"> \param[in]    s1   width or height of box1</param>
''' <param name="c2"> \param[in]    c2   left or top coordinate of box2</param>
''' <param name="s2"> \param[in]    s2   width or height of box2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxGetDistanceInXorY")> _
Friend Shared Function boxGetDistanceInXorY(c1 as Integer, s1 as Integer, c2 as Integer, s2 as Integer) as Integer
End Function

' SRC\boxfunc1.c (99, 1)
' boxContains()
' boxContains(BOX *, BOX *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="box1"> \param[in]    box1, box2</param>
''' <param name="box2"> \param[out]   presult 1 if box2 is entirely contained within</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxContains")> _
Friend Shared Function boxContains(box1 as IntPTR, box2 as IntPTR, presult as Integer) as Integer
End Function

' SRC\boxfunc1.c (130, 1)
' boxIntersects()
' boxIntersects(BOX *, BOX *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="box1"> \param[in]    box1, box2</param>
''' <param name="box2"> \param[out]   presult 1 if any part of box2 is contained</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxIntersects")> _
Friend Shared Function boxIntersects(box1 as IntPTR, box2 as IntPTR, presult as Integer) as Integer
End Function

' SRC\boxfunc1.c (172, 1)
' boxaContainedInBox()
' boxaContainedInBox(BOXA *, BOX *) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) All boxes in boxa that are entirely outside box are removed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad boxa with all boxes in boxas that are</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="box"> \param[in]    box for containment</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaContainedInBox")> _
Friend Shared Function boxaContainedInBox(boxas as IntPTR, box as IntPTR) as IntPTR
End Function

' SRC\boxfunc1.c (210, 1)
' boxaContainedInBoxCount()
' boxaContainedInBoxCount(BOXA *, BOX *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="box"> \param[in]    box      for selecting contained boxes in %boxa</param>
''' <param name="pcount"> \param[out]   pcount   number of boxes intersecting the box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaContainedInBoxCount")> _
Friend Shared Function boxaContainedInBoxCount(boxa as IntPTR, box as IntPTR, pcount as Integer) as Integer
End Function

' SRC\boxfunc1.c (249, 1)
' boxaContainedInBoxa()
' boxaContainedInBoxa(BOXA *, BOXA *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa1"> \param[in]     boxa1, boxa2</param>
''' <param name="boxa2"> \param[out]    pcontained    1 if every box in boxa2 is contained in</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaContainedInBoxa")> _
Friend Shared Function boxaContainedInBoxa(boxa1 as IntPTR, boxa2 as IntPTR, pcontained as Integer) as Integer
End Function

' SRC\boxfunc1.c (302, 1)
' boxaIntersectsBox()
' boxaIntersectsBox(BOXA *, BOX *) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) All boxes in boxa that intersect with box (i.e., are completely
'''  * or partially contained in box) are retained.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad boxa with all boxes in boxas that intersect box,</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="box"> \param[in]    box for intersecting</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaIntersectsBox")> _
Friend Shared Function boxaIntersectsBox(boxas as IntPTR, box as IntPTR) as IntPTR
End Function

' SRC\boxfunc1.c (340, 1)
' boxaIntersectsBoxCount()
' boxaIntersectsBoxCount(BOXA *, BOX *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="box"> \param[in]    box      for selecting intersecting boxes in %boxa</param>
''' <param name="pcount"> \param[out]   pcount   number of boxes intersecting the box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaIntersectsBoxCount")> _
Friend Shared Function boxaIntersectsBoxCount(boxa as IntPTR, box as IntPTR, pcount as Integer) as Integer
End Function

' SRC\boxfunc1.c (385, 1)
' boxaClipToBox()
' boxaClipToBox(BOXA *, BOX *) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) All boxes in boxa not intersecting with box are removed, and
'''  * the remaining boxes are clipped to box.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad boxa with boxes in boxas clipped to box,</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="box"> \param[in]    box for clipping</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaClipToBox")> _
Friend Shared Function boxaClipToBox(boxas as IntPTR, box as IntPTR) as IntPTR
End Function

' SRC\boxfunc1.c (442, 1)
' boxaCombineOverlaps()
' boxaCombineOverlaps(BOXA *, PIXA *) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) If there are no overlapping boxes, it simply returns a copy
'''  * of %boxas.
'''  *   (2) Input an empty %pixadb, using pixaCreate(0), for debug output.
'''  * The output gives 2 visualizations of the boxes per iteration;
'''  * boxes in red before, and added boxes in green after. Note that
'''  * all pixels in the red boxes are contained in the green ones.
'''  *   (3) The alternative method of painting each rectangle and finding
'''  * the 4-connected components gives a different result in
'''  * general, because two non-overlapping (but touching)
'''  * rectangles, when rendered, are 4-connected and will be joined.
'''  *   (4) A bad case computationally is to have n boxes, none of which
'''  * overlap.  Then you have one iteration with O(n^2) compares.
'''  * This is still faster than painting each rectangle and finding
'''  * the bounding boxes of the connected components, even for
'''  * thousands of rectangles.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad where each set of boxes in boxas that overlap are</returns>
''' <param name="boxas"> \param[in]       boxas</param>
''' <param name="pixadb"> \param[in,out]   pixadb     debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaCombineOverlaps")> _
Friend Shared Function boxaCombineOverlaps(boxas as IntPTR, pixadb as IntPTR) as IntPTR
End Function

' SRC\boxfunc1.c (536, 1)
' boxaCombineOverlapsInPair()
' boxaCombineOverlapsInPair(BOXA *, BOXA *, BOXA **, BOXA **, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) One of three things happens to each box in %boxa1 and %boxa2:
'''  *  * it gets absorbed into a larger box that it overlaps with
'''  *  * it absorbs a smaller (by area) box that it overlaps with
'''  * and gets larger, using the bounding region of the 2 boxes
'''  *  * it is unchanged (including absorbing smaller boxes that
'''  * are contained within it).
'''  *   (2) If all the boxes from one of the input boxa are absorbed, this
'''  * returns an empty boxa.
'''  *   (3) Input an empty %pixadb, using pixaCreate(0), for debug output
'''  *   (4) This is useful if different operations are to be carried out
'''  * on possibly overlapping rectangular regions, and it is desired
'''  * to have only one operation on any rectangular region.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxas1"> \param[in]       boxas1     input boxa1</param>
''' <param name="boxas2"> \param[in]       boxas2     input boxa2</param>
''' <param name="pboxad1"> \param[out]      pboxad1    output boxa1</param>
''' <param name="pboxad2"> \param[out]      pboxad2    output boxa2</param>
''' <param name="pixadb"> \param[in,out]   pixadb     debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaCombineOverlapsInPair")> _
Friend Shared Function boxaCombineOverlapsInPair(boxas1 as IntPTR, boxas2 as IntPTR, pboxad1 as Object, pboxad2 as Object, pixadb as IntPTR) as Integer
End Function

' SRC\boxfunc1.c (674, 1)
' boxOverlapRegion()
' boxOverlapRegion(BOX *, BOX *) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This is the geometric intersection of the two rectangles.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box of overlap region between input boxes,</returns>
''' <param name="box1"> \param[in]    box1, box2 two boxes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxOverlapRegion")> _
Friend Shared Function boxOverlapRegion(box1 as IntPTR, box2 as IntPTR) as IntPTR
End Function

' SRC\boxfunc1.c (716, 1)
' boxBoundingRegion()
' boxBoundingRegion(BOX *, BOX *) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This is the geometric union of the two rectangles.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box of bounding region containing the input boxes,</returns>
''' <param name="box1"> \param[in]    box1, box2 two boxes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxBoundingRegion")> _
Friend Shared Function boxBoundingRegion(box1 as IntPTR, box2 as IntPTR) as IntPTR
End Function

' SRC\boxfunc1.c (756, 1)
' boxOverlapFraction()
' boxOverlapFraction(BOX *, BOX *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The result depends on the order of the input boxes,
'''  * because the overlap is taken as a fraction of box2.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="box1"> \param[in]    box1, box2 two boxes</param>
''' <param name="box2"> \param[out]   pfract the fraction of box2 overlapped by box1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxOverlapFraction")> _
Friend Shared Function boxOverlapFraction(box1 as IntPTR, box2 as IntPTR, pfract as single) as Integer
End Function

' SRC\boxfunc1.c (792, 1)
' boxOverlapArea()
' boxOverlapArea(BOX *, BOX *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="box1"> \param[in]    box1, box2 two boxes</param>
''' <param name="box2"> \param[out]   parea the number of pixels in the overlap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxOverlapArea")> _
Friend Shared Function boxOverlapArea(box1 as IntPTR, box2 as IntPTR, parea as Integer) as Integer
End Function

' SRC\boxfunc1.c (853, 1)
' boxaHandleOverlaps()
' boxaHandleOverlaps(BOXA *, l_int32, l_int32, l_float32, l_float32, NUMA **) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) For all n(n-1)/2 box pairings, if two boxes overlap, either:
'''  * (a) op == L_COMBINE: get the bounding region for the two,
'''  *  replace the larger with the bounding region, and remove
'''  *  the smaller of the two, or
'''  * (b) op == L_REMOVE_SMALL: just remove the smaller.
'''  *   (2) If boxas is 2D sorted, range can be small, but if it is
'''  * not spatially sorted, range should be large to allow all
'''  * pairwise comparisons to be made.
'''  *   (3) The %min_overlap parameter allows ignoring small overlaps.
'''  * If %min_overlap == 1.0, only boxes fully contained in larger
'''  * boxes can be considered for removal; if %min_overlap == 0.0,
'''  * this constraint is ignored.
'''  *   (4) The %max_ratio parameter allows ignoring overlaps between
'''  * boxes that are not too different in size.  If %max_ratio == 0.0,
'''  * no boxes can be removed; if %max_ratio == 1.0, this constraint
'''  * is ignored.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad, or NULL on error.</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="op"> \param[in]    op L_COMBINE, L_REMOVE_SMALL</param>
''' <param name="range"> \param[in]    range > 0, forward distance over which overlaps are checked</param>
''' <param name="min_overlap"> \param[in]    min_overlap minimum fraction of smaller box required for</param>
''' <param name="max_ratio"> \param[in]    max_ratio maximum fraction of small/large areas for</param>
''' <param name="pnamap"> \param[out]   pnamap [optional] combining map</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaHandleOverlaps")> _
Friend Shared Function boxaHandleOverlaps(boxas as IntPTR, op as Integer, range as Integer, min_overlap as single, max_ratio as single, pnamap as Object) as IntPTR
End Function

' SRC\boxfunc1.c (973, 1)
' boxSeparationDistance()
' boxSeparationDistance(BOX *, BOX *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This measures horizontal and vertical separation of the
'''  * two boxes.  If the boxes are touching but have no pixels
'''  * in common, the separation is 0.  If the boxes overlap by
'''  * a distance d, the returned separation is -d.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="box1"> \param[in]    box1, box2 two boxes, in any order</param>
''' <param name="box2"> \param[out]   ph_sep [optional] horizontal separation</param>
''' <param name="ph_sep"> \param[out]   pv_sep [optional] vertical separation</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxSeparationDistance")> _
Friend Shared Function boxSeparationDistance(box1 as IntPTR, box2 as IntPTR, ph_sep as Integer, pv_sep as Integer) as Integer
End Function

' SRC\boxfunc1.c (1029, 1)
' boxCompareSize()
' boxCompareSize(BOX *, BOX *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) We're re-using the SORT enum for these comparisons.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   0 if OK, 1 on error</returns>
''' <param name="box1"> \param[in]    box1, box2</param>
''' <param name="box2"> \param[in]    type     L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT,</param>
''' <param name="type"> \param[out]   prel   1 if box1 > box2, 0 if the same, -1 if box1 < box2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxCompareSize")> _
Friend Shared Function boxCompareSize(box1 as IntPTR, box2 as IntPTR, type as Integer, prel as Integer) as Integer
End Function

' SRC\boxfunc1.c (1080, 1)
' boxContainsPt()
' boxContainsPt(BOX *, l_float32, l_float32, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="x"> \param[in]    x, y a point</param>
''' <param name="y"> \param[out]   pcontains 1 if box contains point; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxContainsPt")> _
Friend Shared Function boxContainsPt(box as IntPTR, x as single, y as single, pcontains as Integer) as Integer
End Function

' SRC\boxfunc1.c (1115, 1)
' boxaGetNearestToPt()
' boxaGetNearestToPt(BOXA *, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) Uses euclidean distance between centroid and point.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box with centroid closest to the given point [x,y],</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="x"> \param[in]    x, y  point</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetNearestToPt")> _
Friend Shared Function boxaGetNearestToPt(boxa as IntPTR, x as Integer, y as Integer) as IntPTR
End Function

' SRC\boxfunc1.c (1167, 1)
' boxaGetNearestToLine()
' boxaGetNearestToLine(BOXA *, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) For a horizontal line at some value y, get the minimum of the
'''  * distance |yc - y| from the box centroid yc value to y;
'''  * likewise minimize |xc - x| for a vertical line at x.
'''  *   (2) Input y  0, x >= 0 to indicate a vertical line at x, and
'''  * x  0, y >= 0 for a horizontal line at y.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box with centroid closest to the given line,</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="x"> \param[in]    x, y   (y = -1 for vertical line; x = -1 for horiz line)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetNearestToLine")> _
Friend Shared Function boxaGetNearestToLine(boxa as IntPTR, x as Integer, y as Integer) as IntPTR
End Function

' SRC\boxfunc1.c (1224, 1)
' boxaFindNearestBoxes()
' boxaFindNearestBoxes(BOXA *, l_int32, l_int32, NUMAA **, NUMAA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See boxaGetNearestByDirection() for usage of %dist_select
'''  * and %range.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa         either unsorted, or 2D sorted in LR/TB scan order</param>
''' <param name="dist_select"> \param[in]    dist_select  L_NON_NEGATIVE, L_ALL</param>
''' <param name="range"> \param[in]    range        search distance from box i; use 0 to search</param>
''' <param name="pnaaindex"> \param[out]   pnaaindex    for each box in %boxa, contains a numa of 4</param>
''' <param name="pnaadist"> \param[out]   pnaadist   for each box in %boxa, this contains a numa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaFindNearestBoxes")> _
Friend Shared Function boxaFindNearestBoxes(boxa as IntPTR, dist_select as Integer, range as Integer, pnaaindex as Object, pnaadist as Object) as Integer
End Function

' SRC\boxfunc1.c (1305, 1)
' boxaGetNearestByDirection()
' boxaGetNearestByDirection(BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For efficiency, use a LR/TD sorted %boxa, which can be
'''  * made by flattening a 2D sorted boxaa.  In that case,
'''  * %range can be some positive integer like 50.
'''  *   (2) If boxes overlap, the distance will be  0.  Use %dist_select
'''  * to determine if these should count or not.  If L_ALL, then
'''  * one box will match as the nearest to another in 2 or more
'''  * directions.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa         either unsorted, or 2D sorted in LR/TB scan order</param>
''' <param name="i"> \param[in]    i            box we test against</param>
''' <param name="dir"> \param[in]    dir          direction to look: L_FROM_LEFT, L_FROM_RIGHT,</param>
''' <param name="dist_select"> \param[in]    dist_select  L_NON_NEGATIVE, L_ALL</param>
''' <param name="range"> \param[in]    range        search distance from box i; use 0 to search</param>
''' <param name="pindex"> \param[out]   pindex       index in boxa of nearest box with overlapping</param>
''' <param name="pdist"> \param[out]   pdist        distance of the nearest box in the indicated</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetNearestByDirection")> _
Friend Shared Function boxaGetNearestByDirection(boxa as IntPTR, i as Integer, dir as Integer, dist_select as Integer, range as Integer, pindex as Integer, pdist as Integer) as Integer
End Function

' SRC\boxfunc1.c (1444, 1)
' boxGetCenter()
' boxGetCenter(BOX *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="pcx"> \param[out]   pcx, pcy location of center of box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxGetCenter")> _
Friend Shared Function boxGetCenter(box as IntPTR, pcx as single, pcy as single) as Integer
End Function

' SRC\boxfunc1.c (1485, 1)
' boxIntersectByLine()
' boxIntersectByLine(BOX *, l_int32, l_int32, l_float32, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If the intersection is at only one point (a corner), the
'''  * coordinates are returned in (x1, y1).
'''  *   (2) Represent a vertical line by one with a large but finite slope.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="x"> \param[in]    x, y point that line goes through</param>
''' <param name="y"> \param[in]    slope of line</param>
''' <param name="slope"> \param[out]   px1, py1 1st point of intersection with box</param>
''' <param name="px1"> \param[out]   px2, py2 2nd point of intersection with box</param>
''' <param name="py1"> \param[out]   pn number of points of intersection</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxIntersectByLine")> _
Friend Shared Function boxIntersectByLine(box as IntPTR, x as Integer, y as Integer, slope as single, px1 as Integer, py1 as Integer, px2 as Integer, py2 as Integer, pn as Integer) as Integer
End Function

' SRC\boxfunc1.c (1587, 1)
' boxClipToRectangle()
' boxClipToRectangle(BOX *, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This can be used to clip a rectangle to an image.
'''  * The clipping rectangle is assumed to have a UL corner at (0, 0),
'''  * and a LR corner at (wi - 1, hi - 1).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  part of box within given rectangle, or NULL on error</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="wi"> \param[in]    wi, hi rectangle representing image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxClipToRectangle")> _
Friend Shared Function boxClipToRectangle(box as IntPTR, wi as Integer, hi as Integer) as IntPTR
End Function

' SRC\boxfunc1.c (1644, 1)
' boxClipToRectangleParams()
' boxClipToRectangleParams(BOX *, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The return value should be checked.  If it is 1, the
'''  * returned parameter values are bogus.
'''  *   (2) This simplifies the selection of pixel locations within
'''  * a given rectangle:
'''  * for (i = ystart; i  yend; i++ {
'''  *  ...
'''  *  for (j = xstart; j  xend; j++ {
'''  *   ....
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="box"> \param[in]    box [optional] requested box; can be null</param>
''' <param name="w"> \param[in]    w, h clipping box size; typ. the size of an image</param>
''' <param name="h"> \param[out]   pxstart start x coordinate</param>
''' <param name="pxstart"> \param[out]   pystart start y coordinate</param>
''' <param name="pystart"> \param[out]   pxend one pixel beyond clipping box</param>
''' <param name="pxend"> \param[out]   pyend one pixel beyond clipping box</param>
''' <param name="pyend"> \param[out]   pbw [optional] clipped width</param>
''' <param name="pbw"> \param[out]   pbh [optional] clipped height</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxClipToRectangleParams")> _
Friend Shared Function boxClipToRectangleParams(box as IntPTR, w as Integer, h as Integer, pxstart as Integer, pystart as Integer, pxend as Integer, pyend as Integer, pbw as Integer, pbh as Integer) as Integer
End Function

' SRC\boxfunc1.c (1706, 1)
' boxRelocateOneSide()
' boxRelocateOneSide(BOX *, BOX *, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) Set boxd == NULL to get new box; boxd == boxs for in-place;
'''  * or otherwise to resize existing boxd.
'''  *   (2) For usage, suggest one of these:
'''  *   boxd = boxRelocateOneSide(NULL, boxs, ...);   // new
'''  *   boxRelocateOneSide(boxs, boxs, ...); // in-place
'''  *   boxRelocateOneSide(boxd, boxs, ...); // other
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxd, or NULL on error or if the computed boxd has</returns>
''' <param name="boxd"> \param[in]    boxd [optional]; this can be null, equal to boxs,</param>
''' <param name="boxs"> \param[in]    boxs starting box; to have one side relocated</param>
''' <param name="loc"> \param[in]    loc new location of the side that is changing</param>
''' <param name="sideflag"> \param[in]    sideflag L_FROM_LEFT, etc., indicating the side that moves</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxRelocateOneSide")> _
Friend Shared Function boxRelocateOneSide(boxd as IntPTR, boxs as IntPTR, loc as Integer, sideflag as Integer) as IntPTR
End Function

' SRC\boxfunc1.c (1750, 1)
' boxaAdjustSides()
' boxaAdjustSides(BOXA *, l_int32, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) New box dimensions are cropped at left and top to x >= 0 and y >= 0.
'''  *   (2) If the width or height of a box goes to 0, we generate a box with
'''  * w == 1 and h == 1, as a placeholder.
'''  *   (3) See boxAdjustSides().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="delleft"> \param[in]    delleft, delright, deltop, delbot   changes in location of</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaAdjustSides")> _
Friend Shared Function boxaAdjustSides(boxas as IntPTR, delleft as Integer, delright as Integer, deltop as Integer, delbot as Integer) as IntPTR
End Function

' SRC\boxfunc1.c (1807, 1)
' boxAdjustSides()
' boxAdjustSides(BOX *, BOX *, l_int32, l_int32, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) Set boxd == NULL to get new box; boxd == boxs for in-place;
'''  * or otherwise to resize existing boxd.
'''  *   (2) For usage, suggest one of these:
'''  *   boxd = boxAdjustSides(NULL, boxs, ...);   // new
'''  *   boxAdjustSides(boxs, boxs, ...); // in-place
'''  *   boxAdjustSides(boxd, boxs, ...); // other
'''  *   (3) New box dimensions are cropped at left and top to x >= 0 and y >= 0.
'''  *   (4) For example, to expand in-place by 20 pixels on each side, use
'''  * boxAdjustSides(box, box, -20, 20, -20, 20);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxd, or NULL on error or if the computed boxd has</returns>
''' <param name="boxd"> \param[in]    boxd  [optional]; this can be null, equal to boxs,</param>
''' <param name="boxs"> \param[in]    boxs  starting box; to have sides adjusted</param>
''' <param name="delleft"> \param[in]    delleft, delright, deltop, delbot changes in location of</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxAdjustSides")> _
Friend Shared Function boxAdjustSides(boxd as IntPTR, boxs as IntPTR, delleft as Integer, delright as Integer, deltop as Integer, delbot as Integer) as IntPTR
End Function

' SRC\boxfunc1.c (1859, 1)
' boxaSetSide()
' boxaSetSide(BOXA *, BOXA *, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) Sets the given side of each box.  Use boxad == NULL for a new
'''  * boxa, and boxad == boxas for in-place.
'''  *   (2) Use one of these:
'''  *   boxad = boxaSetSide(NULL, boxas, ...);   // new
'''  *   boxaSetSide(boxas, boxas, ...);  // in-place
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad, or NULL on error</returns>
''' <param name="boxad"> \param[in]    boxad use NULL to get a new one; same as boxas for in-place</param>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="side"> \param[in]    side L_SET_LEFT, L_SET_RIGHT, L_SET_TOP, L_SET_BOT</param>
''' <param name="val"> \param[in]    val location to set for given side, for each box</param>
''' <param name="thresh"> \param[in]    thresh min abs difference to cause resetting to %val</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSetSide")> _
Friend Shared Function boxaSetSide(boxad as IntPTR, boxas as IntPTR, side as Integer, val as Integer, thresh as Integer) as IntPTR
End Function

' SRC\boxfunc1.c (1932, 1)
' boxaAdjustWidthToTarget()
' boxaAdjustWidthToTarget(BOXA *, BOXA *, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) Conditionally adjusts the width of each box, by moving
'''  * the indicated edges (left and/or right) if the width differs
'''  * by %thresh or more from %target.
'''  *   (2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.
'''  * Use one of these:
'''  *   boxad = boxaAdjustWidthToTarget(NULL, boxas, ...);   // new
'''  *   boxaAdjustWidthToTarget(boxas, boxas, ...);  // in-place
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad, or NULL on error</returns>
''' <param name="boxad"> \param[in]    boxad use NULL to get a new one; same as boxas for in-place</param>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="sides"> \param[in]    sides L_ADJUST_LEFT, L_ADJUST_RIGHT, L_ADJUST_LEFT_AND_RIGHT</param>
''' <param name="target"> \param[in]    target target width if differs by more than thresh</param>
''' <param name="thresh"> \param[in]    thresh min abs difference in width to cause adjustment</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaAdjustWidthToTarget")> _
Friend Shared Function boxaAdjustWidthToTarget(boxad as IntPTR, boxas as IntPTR, sides as Integer, target as Integer, thresh as Integer) as IntPTR
End Function

' SRC\boxfunc1.c (1999, 1)
' boxaAdjustHeightToTarget()
' boxaAdjustHeightToTarget(BOXA *, BOXA *, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) Conditionally adjusts the height of each box, by moving
'''  * the indicated edges (top and/or bot) if the height differs
'''  * by %thresh or more from %target.
'''  *   (2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.
'''  * Use one of these:
'''  *   boxad = boxaAdjustHeightToTarget(NULL, boxas, ...);   // new
'''  *   boxaAdjustHeightToTarget(boxas, boxas, ...);  // in-place
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad, or NULL on error</returns>
''' <param name="boxad"> \param[in]    boxad use NULL to get a new one</param>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="sides"> \param[in]    sides L_ADJUST_TOP, L_ADJUST_BOT, L_ADJUST_TOP_AND_BOT</param>
''' <param name="target"> \param[in]    target target height if differs by more than thresh</param>
''' <param name="thresh"> \param[in]    thresh min abs difference in height to cause adjustment</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaAdjustHeightToTarget")> _
Friend Shared Function boxaAdjustHeightToTarget(boxad as IntPTR, boxas as IntPTR, sides as Integer, target as Integer, thresh as Integer) as IntPTR
End Function

' SRC\boxfunc1.c (2057, 1)
' boxEqual()
' boxEqual(BOX *, BOX *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="box1"> \param[in]    box1</param>
''' <param name="box2"> \param[in]    box2</param>
''' <param name="psame"> \param[out]   psame 1 if equal; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxEqual")> _
Friend Shared Function boxEqual(box1 as IntPTR, box2 as IntPTR, psame as Integer) as Integer
End Function

' SRC\boxfunc1.c (2104, 1)
' boxaEqual()
' boxaEqual(BOXA *, BOXA *, l_int32, NUMA **, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The two boxa are the "same" if they contain the same
'''  * boxes and each box is within %maxdist of its counterpart
'''  * in their positions within the boxa.  This allows for
'''  * small rearrangements.  Use 0 for maxdist if the boxa
'''  * must be identical.
'''  *   (2) This applies only to geometry and ordering; refcounts
'''  * are not considered.
'''  *   (3) %maxdist allows some latitude in the ordering of the boxes.
'''  * For the boxa to be the "same", corresponding boxes must
'''  * be within %maxdist of each other.  Note that for large
'''  * %maxdist, we should use a hash function for efficiency.
'''  *   (4) naindex[i] gives the position of the box in boxa2 that
'''  * corresponds to box i in boxa1.  It is only returned if the
'''  * boxa are equal.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa1"> \param[in]    boxa1</param>
''' <param name="boxa2"> \param[in]    boxa2</param>
''' <param name="maxdist"> \param[in]    maxdist</param>
''' <param name="pnaindex"> \param[out]   pnaindex [optional] index array of correspondences</param>
''' <param name="psame"> \param[out]   psame (1 if equal; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaEqual")> _
Friend Shared Function boxaEqual(boxa1 as IntPTR, boxa2 as IntPTR, maxdist as Integer, pnaindex as Object, psame as Integer) as Integer
End Function

' SRC\boxfunc1.c (2183, 1)
' boxSimilar()
' boxSimilar(BOX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The values of leftdiff (etc) are the maximum allowed deviations
'''  * between the locations of the left (etc) sides.  If any side
'''  * pairs differ by more than this amount, the boxes are not similar.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="box1"> \param[in]    box1</param>
''' <param name="box2"> \param[in]    box2</param>
''' <param name="leftdiff"> \param[in]    leftdiff, rightdiff, topdiff, botdiff</param>
''' <param name="rightdiff"> \param[out]   psimilar 1 if similar; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxSimilar")> _
Friend Shared Function boxSimilar(box1 as IntPTR, box2 as IntPTR, leftdiff as Integer, rightdiff as Integer, topdiff as Integer, botdiff as Integer, psimilar as Integer) as Integer
End Function

' SRC\boxfunc1.c (2238, 1)
' boxaSimilar()
' boxaSimilar(BOXA *, BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32 *, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See boxSimilar() for parameter usage.
'''  *   (2) Corresponding boxes are taken in order in the two boxa.
'''  *   (3) %nasim is an indicator array with a (0/1) for each box pair.
'''  *   (4) With %nasim or debug == 1, boxes continue to be tested
'''  * after failure.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa1"> \param[in]    boxa1</param>
''' <param name="boxa2"> \param[in]    boxa2</param>
''' <param name="leftdiff"> \param[in]    leftdiff, rightdiff, topdiff, botdiff</param>
''' <param name="rightdiff"> \param[in]    debug output details of non-similar boxes</param>
''' <param name="topdiff"> \param[out]   psimilar 1 if similar; 0 otherwise</param>
''' <param name="botdiff"> \param[out]   pnasim [optional] na containing 1 if similar; else 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSimilar")> _
Friend Shared Function boxaSimilar(boxa1 as IntPTR, boxa2 as IntPTR, leftdiff as Integer, rightdiff as Integer, topdiff as Integer, botdiff as Integer, debug as Integer, psimilar as Integer, pnasim as Object) as Integer
End Function

' SRC\boxfunc1.c (2312, 1)
' boxaJoin()
' boxaJoin(BOXA *, BOXA *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This appends a clone of each indicated box in boxas to boxad
'''  *   (2) istart  0 is taken to mean 'read from the start' (istart = 0)
'''  *   (3) iend  0 means 'read to the end'
'''  *   (4) if boxas == NULL or has no boxes, this is a no-op.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxad"> \param[in]    boxad  dest boxa; add to this one</param>
''' <param name="boxas"> \param[in]    boxas  source boxa; add from this one</param>
''' <param name="istart"> \param[in]    istart  starting index in boxas</param>
''' <param name="iend"> \param[in]    iend  ending index in boxas; use -1 to cat all</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaJoin")> _
Friend Shared Function boxaJoin(boxad as IntPTR, boxas as IntPTR, istart as Integer, iend as Integer) as Integer
End Function

' SRC\boxfunc1.c (2361, 1)
' boxaaJoin()
' boxaaJoin(BOXAA *, BOXAA *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This appends a clone of each indicated boxa in baas to baad
'''  *   (2) istart  0 is taken to mean 'read from the start' (istart = 0)
'''  *   (3) iend  0 means 'read to the end'
'''  *   (4) if baas == NULL, this is a no-op.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="baad"> \param[in]    baad  dest boxaa; add to this one</param>
''' <param name="baas"> \param[in]    baas  source boxaa; add from this one</param>
''' <param name="istart"> \param[in]    istart  starting index in baas</param>
''' <param name="iend"> \param[in]    iend  ending index in baas; use -1 to cat all</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaJoin")> _
Friend Shared Function boxaaJoin(baad as IntPTR, baas as IntPTR, istart as Integer, iend as Integer) as Integer
End Function

' SRC\boxfunc1.c (2411, 1)
' boxaSplitEvenOdd()
' boxaSplitEvenOdd(BOXA *, l_int32, BOXA **, BOXA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If %fillflag == 1, boxae has copies of the even boxes
'''  * in their original location, and nvalid boxes are placed
'''  * in the odd array locations.  And v.v.
'''  *   (2) If %fillflag == 0, boxae has only copies of the even boxes.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="fillflag"> \param[in]    fillflag 1 to put invalid boxes in place; 0 to omit</param>
''' <param name="pboxae"> \param[out]   pboxae, pboxao save even and odd boxes in their</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSplitEvenOdd")> _
Friend Shared Function boxaSplitEvenOdd(boxa as IntPTR, fillflag as Integer, pboxae as Object, pboxao as Object) as Integer
End Function

' SRC\boxfunc1.c (2475, 1)
' boxaMergeEvenOdd()
' boxaMergeEvenOdd(BOXA *, BOXA *, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This is essentially the inverse of boxaSplitEvenOdd().
'''  * Typically, boxae and boxao were generated by boxaSplitEvenOdd(),
'''  * and the value of %fillflag needs to be the same in both calls.
'''  *   (2) If %fillflag == 1, both boxae and boxao are of the same size;
'''  * otherwise boxae may have one more box than boxao.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad merged, or NULL on error</returns>
''' <param name="boxae"> \param[in]    boxae boxes to go in even positions in merged boxa</param>
''' <param name="boxao"> \param[in]    boxao boxes to go in odd positions in merged boxa</param>
''' <param name="fillflag"> \param[in]    fillflag 1 if there are invalid boxes in placeholders</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaMergeEvenOdd")> _
Friend Shared Function boxaMergeEvenOdd(boxae as IntPTR, boxao as IntPTR, fillflag as Integer) as IntPTR
End Function

#End Region
#Region "SRC\boxfunc2.c"
' SRC\boxfunc2.c (91, 1)
' boxaTransform()
' boxaTransform(BOXA *, l_int32, l_int32, l_float32, l_float32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This is a very simple function that first shifts, then scales.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="shiftx"> \param[in]    shiftx, shifty</param>
''' <param name="shifty"> \param[in]    scalex, scaley</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaTransform")> _
Friend Shared Function boxaTransform(boxas as IntPTR, shiftx as Integer, shifty as Integer, scalex as single, scaley as single) as IntPTR
End Function

' SRC\boxfunc2.c (137, 1)
' boxTransform()
' boxTransform(BOX *, l_int32, l_int32, l_float32, l_float32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This is a very simple function that first shifts, then scales.
'''  *   (2) If the box is invalid, a new invalid box is returned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxd, or NULL on error</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="shiftx"> \param[in]    shiftx, shifty</param>
''' <param name="shifty"> \param[in]    scalex, scaley</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxTransform")> _
Friend Shared Function boxTransform(box as IntPTR, shiftx as Integer, shifty as Integer, scalex as single, scaley as single) as IntPTR
End Function

' SRC\boxfunc2.c (192, 1)
' boxaTransformOrdered()
' boxaTransformOrdered(BOXA *, l_int32, l_int32, l_float32, l_float32, l_int32, l_int32, l_float32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This allows a sequence of linear transforms on each box.
'''  * the transforms are from the affine set, composed of
'''  * shift, scaling and rotation, and the order of the
'''  * transforms is specified.
'''  *   (2) Although these operations appear to be on an infinite
'''  * 2D plane, in practice the region of interest is clipped
'''  * to a finite image.  The center of rotation is usually taken
'''  * with respect to the image (either the UL corner or the
'''  * center).  A translation can have two very different effects:
'''  *   (a) Moves the boxes across the fixed image region.
'''  *   (b) Moves the image origin, causing a change in the image
'''  * region and an opposite effective translation of the boxes.
'''  * This function should only be used for (a), where the image
'''  * region is fixed on translation.  If the image region is
'''  * changed by the translation, use instead the functions
'''  * in affinecompose.c, where the image region and rotation
'''  * center can be computed from the actual clipping due to
'''  * translation of the image origin.
'''  *   (3) See boxTransformOrdered() for usage and implementation details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxd, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="shiftx"> \param[in]    shiftx, shifty</param>
''' <param name="shifty"> \param[in]    scalex, scaley</param>
''' <param name="scalex"> \param[in]    xcen, ycen center of rotation</param>
''' <param name="scaley"> \param[in]    angle in radians; clockwise is positive</param>
''' <param name="xcen"> \param[in]    order one of 6 combinations: L_TR_SC_RO, ...</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaTransformOrdered")> _
Friend Shared Function boxaTransformOrdered(boxas as IntPTR, shiftx as Integer, shifty as Integer, scalex as single, scaley as single, xcen as Integer, ycen as Integer, angle as single, order as Integer) as IntPTR
End Function

' SRC\boxfunc2.c (280, 1)
' boxTransformOrdered()
' boxTransformOrdered(BOX *, l_int32, l_int32, l_float32, l_float32, l_int32, l_int32, l_float32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This allows a sequence of linear transforms, composed of
'''  * shift, scaling and rotation, where the order of the
'''  * transforms is specified.
'''  *   (2) The rotation is taken about a point specified by (xcen, ycen).
'''  * Let the components of the vector from the center of rotation
'''  * to the box center be (xdif, ydif):
'''  *   xdif = (bx + 0.5 * bw) - xcen
'''  *   ydif = (by + 0.5 * bh) - ycen
'''  * Then the box center after rotation has new components:
'''  *   bxcen = xcen + xdif * cosa + ydif * sina
'''  *   bycen = ycen + ydif * cosa - xdif * sina
'''  * where cosa and sina are the cos and sin of the angle,
'''  * and the enclosing box for the rotated box has size:
'''  *   rw = |bw * cosa| + |bh * sina|
'''  *   rh = |bh * cosa| + |bw * sina|
'''  * where bw and bh are the unrotated width and height.
'''  * Then the box UL corner (rx, ry) is
'''  *   rx = bxcen - 0.5 * rw
'''  *   ry = bycen - 0.5 * rh
'''  *   (3) The center of rotation specified by args %xcen and %ycen
'''  * is the point BEFORE any translation or scaling.  If the
'''  * rotation is not the first operation, this function finds
'''  * the actual center at the time of rotation.  It does this
'''  * by making the following assumptions:
'''  * (1) Any scaling is with respect to the UL corner, so
'''  *  that the center location scales accordingly.
'''  * (2) A translation does not affect the center of
'''  *  the image; it just moves the boxes.
'''  * We always use assumption (1).  However, assumption (2)
'''  * will be incorrect if the apparent translation is due
'''  * to a clipping operation that, in effect, moves the
'''  * origin of the image.  In that case, you should NOT use
'''  * these simple functions.  Instead, use the functions
'''  * in affinecompose.c, where the rotation center can be
'''  * computed from the actual clipping due to translation
'''  * of the image origin.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxd, or NULL on error</returns>
''' <param name="boxs"> \param[in]    boxs</param>
''' <param name="shiftx"> \param[in]    shiftx, shifty</param>
''' <param name="shifty"> \param[in]    scalex, scaley</param>
''' <param name="scalex"> \param[in]    xcen, ycen center of rotation</param>
''' <param name="scaley"> \param[in]    angle in radians; clockwise is positive</param>
''' <param name="xcen"> \param[in]    order one of 6 combinations: L_TR_SC_RO, ...</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxTransformOrdered")> _
Friend Shared Function boxTransformOrdered(boxs as IntPTR, shiftx as Integer, shifty as Integer, scalex as single, scaley as single, xcen as Integer, ycen as Integer, angle as single, order as Integer) as IntPTR
End Function

' SRC\boxfunc2.c (454, 1)
' boxaRotateOrth()
' boxaRotateOrth(BOXA *, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) See boxRotateOrth() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="w"> \param[in]    w, h of image in which the boxa is embedded</param>
''' <param name="h"> \param[in]    rotation 0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaRotateOrth")> _
Friend Shared Function boxaRotateOrth(boxas as IntPTR, w as Integer, h as Integer, rotation as Integer) as IntPTR
End Function

' SRC\boxfunc2.c (506, 1)
' boxRotateOrth()
' boxRotateOrth(BOX *, l_int32, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) Rotate the image with the embedded box by the specified amount.
'''  *   (2) After rotation, the rotated box is always measured with
'''  * respect to the UL corner of the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxd, or NULL on error</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="w"> \param[in]    w, h of image in which the box is embedded</param>
''' <param name="h"> \param[in]    rotation 0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxRotateOrth")> _
Friend Shared Function boxRotateOrth(box as IntPTR, w as Integer, h as Integer, rotation as Integer) as IntPTR
End Function

' SRC\boxfunc2.c (560, 1)
' boxaSort()
' boxaSort(BOXA *, l_int32, l_int32, NUMA **) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) An empty boxa returns a copy, with a warning.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad sorted version of boxas, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="sorttype"> \param[in]    sorttype L_SORT_BY_X, L_SORT_BY_Y,</param>
''' <param name="sortorder"> \param[in]    sortorder  L_SORT_INCREASING, L_SORT_DECREASING</param>
''' <param name="pnaindex"> \param[out]   pnaindex [optional] index of sorted order into</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSort")> _
Friend Shared Function boxaSort(boxas as IntPTR, sorttype as Integer, sortorder as Integer, pnaindex as Object) as IntPTR
End Function

' SRC\boxfunc2.c (684, 1)
' boxaBinSort()
' boxaBinSort(BOXA *, l_int32, l_int32, NUMA **) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) For a large number of boxes (say, greater than 1000), this
'''  * O(n) binsort is much faster than the O(nlogn) shellsort.
'''  * For 5000 components, this is over 20x faster than boxaSort().
'''  *   (2) Consequently, boxaSort() calls this function if it will
'''  * likely go much faster.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad sorted version of boxas, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="sorttype"> \param[in]    sorttype L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH,</param>
''' <param name="sortorder"> \param[in]    sortorder  L_SORT_INCREASING, L_SORT_DECREASING</param>
''' <param name="pnaindex"> \param[out]   pnaindex [optional] index of sorted order into</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaBinSort")> _
Friend Shared Function boxaBinSort(boxas as IntPTR, sorttype as Integer, sortorder as Integer, pnaindex as Object) as IntPTR
End Function

' SRC\boxfunc2.c (761, 1)
' boxaSortByIndex()
' boxaSortByIndex(BOXA *, NUMA *) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad sorted, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="naindex"> \param[in]    naindex na that maps from the new boxa to the input boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSortByIndex")> _
Friend Shared Function boxaSortByIndex(boxas as IntPTR, naindex as IntPTR) as IntPTR
End Function

' SRC\boxfunc2.c (837, 1)
' boxaSort2d()
' boxaSort2d(BOXA *, NUMAA **, l_int32, l_int32, l_int32) as BOXAA *
''' <summary>
''' * Notes:
'''  *   (1) The final result is a sort where the 'fast scan' direction is
'''  * left to right, and the 'slow scan' direction is from top
'''  * to bottom.  Each boxa in the baa represents a sorted set
'''  * of boxes from left to right.
'''  *   (2) Three passes are used to aggregate the boxas, which can correspond
'''  * to characters or words in a line of text.  In pass 1, only
'''  * taller components, which correspond to xheight or larger,
'''  * are permitted to start a new boxa.  In pass 2, the remaining
'''  * vertically-challenged components are allowed to join an
'''  * existing boxa or start a new one.  In pass 3, boxa whose extent
'''  * is overlapping are joined.  After that, the boxes in each
'''  * boxa are sorted horizontally, and finally the boxa are
'''  * sorted vertically.
'''  *   (3) If delta1  0, the first pass allows aggregation when
'''  * boxes in the same boxa do not overlap vertically.
'''  * The distance by which they can miss and still be aggregated
'''  * is the absolute value |delta1|.   Similar for delta2 on
'''  * the second pass.
'''  *   (4) On the first pass, any component of height less than minh1
'''  * cannot start a new boxa; it's put aside for later insertion.
'''  *   (5) On the second pass, any small component that doesn't align
'''  * with an existing boxa can start a new one.
'''  *   (6) This can be used to identify lines of text from
'''  * character or word bounding boxes.
'''  *   (7) Typical values for the input parameters on 300 ppi text are:
'''  *  delta1 ~ 0
'''  *  delta2 ~ 0
'''  *  minh1 ~ 5
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  baa 2d sorted version of boxa, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="pnaad"> \param[out]   pnaad [optional] numaa with sorted indices</param>
''' <param name="delta1"> \param[in]    delta1 min overlap that permits aggregation of a box</param>
''' <param name="delta2"> \param[in]    delta2 min overlap that permits aggregation of a box</param>
''' <param name="minh1"> \param[in]    minh1 components less than this height either join an</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSort2d")> _
Friend Shared Function boxaSort2d(boxas as IntPTR, pnaad as Object, delta1 as Integer, delta2 as Integer, minh1 as Integer) as IntPTR
End Function

' SRC\boxfunc2.c (1024, 1)
' boxaSort2dByIndex()
' boxaSort2dByIndex(BOXA *, NUMAA *) as BOXAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  baa sorted boxaa, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="naa"> \param[in]    naa numaa that maps from the new baa to the input boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSort2dByIndex")> _
Friend Shared Function boxaSort2dByIndex(boxas as IntPTR, naa as IntPTR) as IntPTR
End Function

' SRC\boxfunc2.c (1093, 1)
' boxaExtractAsNuma()
' boxaExtractAsNuma(BOXA *, NUMA **, NUMA **, NUMA **, NUMA **, NUMA **, NUMA **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If you are counting or sorting values, such as determining
'''  * rank order, you must remove invalid boxes.
'''  *   (2) If you are parametrizing the values, or doing an evaluation
'''  * where the position in the boxa sequence is important, you
'''  * must replace the invalid boxes with valid ones before
'''  * doing the extraction. This is easily done with boxaFillSequence().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="pnal"> \param[out]   pnal [optional] array of left locations</param>
''' <param name="pnat"> \param[out]   pnat [optional] array of top locations</param>
''' <param name="pnar"> \param[out]   pnar [optional] array of right locations</param>
''' <param name="pnab"> \param[out]   pnab [optional] array of bottom locations</param>
''' <param name="pnaw"> \param[out]   pnaw [optional] array of widths</param>
''' <param name="pnah"> \param[out]   pnah [optional] array of heights</param>
''' <param name="keepinvalid"> \param[in]    keepinvalid 1 to keep invalid boxes; 0 to remove them</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaExtractAsNuma")> _
Friend Shared Function boxaExtractAsNuma(boxa as IntPTR, pnal as Object, pnat as Object, pnar as Object, pnab as Object, pnaw as Object, pnah as Object, keepinvalid as Integer) as Integer
End Function

' SRC\boxfunc2.c (1170, 1)
' boxaExtractAsPta()
' boxaExtractAsPta(BOXA *, PTA **, PTA **, PTA **, PTA **, PTA **, PTA **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For most applications, such as counting, sorting, fitting
'''  * to some parametrized form, plotting or filtering in general,
'''  * you should remove the invalid boxes.  Each pta saves the
'''  * box index in the x array, so replacing invalid boxes by
'''  * filling with boxaFillSequence(), which is required for
'''  * boxaExtractAsNuma(), is not necessary.
'''  *   (2) If invalid boxes are retained, each one will result in
'''  * entries (typically 0) in all selected output pta.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="pptal"> \param[out]   pptal [optional] array of left locations vs. index</param>
''' <param name="pptat"> \param[out]   pptat [optional] array of top locations vs. index</param>
''' <param name="pptar"> \param[out]   pptar [optional] array of right locations vs. index</param>
''' <param name="pptab"> \param[out]   pptab [optional] array of bottom locations vs. index</param>
''' <param name="pptaw"> \param[out]   pptaw [optional] array of widths vs. index</param>
''' <param name="pptah"> \param[out]   pptah [optional] array of heights vs. index</param>
''' <param name="keepinvalid"> \param[in]    keepinvalid 1 to keep invalid boxes; 0 to remove them</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaExtractAsPta")> _
Friend Shared Function boxaExtractAsPta(boxa as IntPTR, pptal as Object, pptat as Object, pptar as Object, pptab as Object, pptaw as Object, pptah as Object, keepinvalid as Integer) as Integer
End Function

' SRC\boxfunc2.c (1251, 1)
' boxaGetRankVals()
' boxaGetRankVals(BOXA *, l_float32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function does not assume that all boxes in the boxa are valid
'''  *   (2) The four box parameters are sorted independently.
'''  * For rank order, the width and height are sorted in increasing
'''  * order.  But what does it mean to sort x and y in "rank order"?
'''  * If the boxes are of comparable size and somewhat
'''  * aligned (e.g., from multiple images), it makes some sense
'''  * to give a "rank order" for x and y by sorting them in
'''  * decreasing order.  But in general, the interpretation of a rank
'''  * order on x and y is highly application dependent.  In summary:
'''  * ~ x and y are sorted in decreasing order
'''  * ~ w and h are sorted in increasing order
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if the boxa is empty or has no valid boxes</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="fract"> \param[in]    fract use 0.0 for smallest, 1.0 for largest width and height</param>
''' <param name="px"> \param[out]   px  [optional] rank value of x</param>
''' <param name="py"> \param[out]   py  [optional] rank value of y</param>
''' <param name="pw"> \param[out]   pw  [optional] rank value of width</param>
''' <param name="ph"> \param[out]   ph  [optional] rank value of height</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetRankVals")> _
Friend Shared Function boxaGetRankVals(boxa as IntPTR, fract as single, px as Integer, py as Integer, pw as Integer, ph as Integer) as Integer
End Function

' SRC\boxfunc2.c (1317, 1)
' boxaGetMedianVals()
' boxaGetMedianVals(BOXA *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See boxaGetRankVals()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if the boxa is empty or has no valid boxes</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="px"> \param[out]   px  [optional] median value of x</param>
''' <param name="py"> \param[out]   py  [optional] median value of y</param>
''' <param name="pw"> \param[out]   pw  [optional] median value of width</param>
''' <param name="ph"> \param[out]   ph  [optional] median value of height</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetMedianVals")> _
Friend Shared Function boxaGetMedianVals(boxa as IntPTR, px as Integer, py as Integer, pw as Integer, ph as Integer) as Integer
End Function

' SRC\boxfunc2.c (1343, 1)
' boxaGetAverageSize()
' boxaGetAverageSize(BOXA *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if the boxa is empty</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="pw"> \param[out]   pw  [optional] average width</param>
''' <param name="ph"> \param[out]   ph  [optional] average height</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetAverageSize")> _
Friend Shared Function boxaGetAverageSize(boxa as IntPTR, pw as single, ph as single) as Integer
End Function

' SRC\boxfunc2.c (1398, 1)
' boxaaGetExtent()
' boxaaGetExtent(BOXAA *, l_int32 *, l_int32 *, BOX **, BOXA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The returned w and h are the minimum size image
'''  * that would contain all boxes untranslated.
'''  *   (2) Each box in the returned boxa is the minimum box required to
'''  * hold all the boxes in the respective boxa of baa.
'''  *   (3) If there are no valid boxes in a boxa, the box corresponding
'''  * to its extent has all fields set to 0 (an invalid box).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="pw"> \param[out]   pw  [optional] width</param>
''' <param name="ph"> \param[out]   ph  [optional] height</param>
''' <param name="pbox"> \param[out]   pbox [optional]  minimum box containing all boxa</param>
''' <param name="pboxa"> \param[out]   pboxa [optional]  boxa containing all boxes in each</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaGetExtent")> _
Friend Shared Function boxaaGetExtent(baa as IntPTR, pw as Integer, ph as Integer, pbox as Object, pboxa as Object) as Integer
End Function

' SRC\boxfunc2.c (1478, 1)
' boxaaFlattenToBoxa()
' boxaaFlattenToBoxa(BOXAA *, NUMA **, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This 'flattens' the baa to a boxa, taking the boxes in
'''  * order in the first boxa, then the second, etc.
'''  *   (2) If a boxa is empty, we generate an invalid, placeholder box
'''  * of zero size.  This is useful when converting from a baa
'''  * where each boxa has either 0 or 1 boxes, and it is necessary
'''  * to maintain a 1:1 correspondence between the initial
'''  * boxa array and the resulting box array.
'''  *   (3) If &naindex is defined, we generate a Numa that gives, for
'''  * each box in the baa, the index of the boxa to which it belongs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="pnaindex"> \param[out]   pnaindex  [optional] the boxa index in the baa</param>
''' <param name="copyflag"> \param[in]    copyflag  L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaFlattenToBoxa")> _
Friend Shared Function boxaaFlattenToBoxa(baa as IntPTR, pnaindex as Object, copyflag as Integer) as IntPTR
End Function

' SRC\boxfunc2.c (1544, 1)
' boxaaFlattenAligned()
' boxaaFlattenAligned(BOXAA *, l_int32, BOX *, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This 'flattens' the baa to a boxa, taking the first %num
'''  * boxes from each boxa.
'''  *   (2) In each boxa, if there are less than %num boxes, we preserve
'''  * the alignment between the input baa and the output boxa
'''  * by inserting one or more fillerbox(es) or, if %fillerbox == NULL,
'''  * one or more invalid placeholder boxes.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="num"> \param[in]    num number extracted from each</param>
''' <param name="fillerbox"> \param[in]    fillerbox [optional] that fills if necessary</param>
''' <param name="copyflag"> \param[in]    copyflag  L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaFlattenAligned")> _
Friend Shared Function boxaaFlattenAligned(baa as IntPTR, num as Integer, fillerbox as IntPTR, copyflag as Integer) as IntPTR
End Function

' SRC\boxfunc2.c (1602, 1)
' boxaEncapsulateAligned()
' boxaEncapsulateAligned(BOXA *, l_int32, l_int32) as BOXAA *
''' <summary>
''' * Notes:
'''  *   (1) This puts %num boxes from the input %boxa into each of a
'''  * set of boxa within an output baa.
'''  *   (2) This assumes that the boxes in %boxa are in sets of %num each.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  baa, or NULL on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="num"> \param[in]    num number put into each boxa in the baa</param>
''' <param name="copyflag"> \param[in]    copyflag  L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaEncapsulateAligned")> _
Friend Shared Function boxaEncapsulateAligned(boxa as IntPTR, num as Integer, copyflag as Integer) as IntPTR
End Function

' SRC\boxfunc2.c (1656, 1)
' boxaaTranspose()
' boxaaTranspose(BOXAA *) as BOXAA *
''' <summary>
''' * Notes:
'''  *   (1) If you think of a boxaa as a 2D array of boxes that is accessed
'''  * row major, then each row is represented by one of the boxa.
'''  * This function creates a new boxaa related to the input boxaa
'''  * as a column major traversal of the input boxaa.
'''  *   (2) For example, if %baas has 2 boxa, each with 10 boxes, then
'''  * %baad will have 10 boxa, each with 2 boxes.
'''  *   (3) Require for this transpose operation that each boxa in
'''  * %baas has the same number of boxes.  This operation is useful
'''  * when the i-th boxes in each boxa are meaningfully related.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  baad, or NULL on error</returns>
''' <param name="baas"> \param[in]    baas</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaTranspose")> _
Friend Shared Function boxaaTranspose(baas as IntPTR) as IntPTR
End Function

' SRC\boxfunc2.c (1715, 1)
' boxaaAlignBox()
' boxaaAlignBox(BOXAA *, BOX *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is not greedy.  It finds the boxa whose vertical
'''  * extent has the closest overlap with the input box.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="box"> \param[in]    box to be aligned with the bext boxa in the baa, if possible</param>
''' <param name="delta"> \param[in]    delta amount by which consecutive components can miss</param>
''' <param name="pindex"> \param[out]   pindex index of boxa with best overlap, or if none match,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaAlignBox")> _
Friend Shared Function boxaaAlignBox(baa as IntPTR, box as IntPTR, delta as Integer, pindex as Integer) as Integer
End Function

#End Region
#Region "SRC\boxfunc3.c"
' SRC\boxfunc3.c (65, 16)
' pixSearchForRectangle()
' pixSearchForRectangle(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32, BOXA *, NUMA *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) See pixSplitComponentIntoBoxa() for an explanation of the algorithm.
'''  * This does the sweep from a single side.  For each iteration
'''  * in pixSplitComponentIntoBoxa(), this will be called 4 times,
'''  * for %sideflag = {0, 1, 2, 3}.
'''  *   (2) If a valid rectangle is not found, add a score of 0 and
'''  * input a minimum box.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="boxs"> \param[in]    boxs current region to investigate</param>
''' <param name="minsum"> \param[in]    minsum  minimum pixels to trigger propagation</param>
''' <param name="skipdist"> \param[in]    skipdist distance before computing sum for propagation</param>
''' <param name="delta"> \param[in]    delta difference required to stop propagation</param>
''' <param name="maxbg"> \param[in]    maxbg maximum number of allowed bg pixels in ref scan</param>
''' <param name="sideflag"> \param[in]    sideflag side to search from</param>
''' <param name="boxat"> \param[in]    boxat add result of rectangular region found here</param>
''' <param name="nascore"> \param[in]    nascore add score for this rectangle here</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSearchForRectangle")> _
Friend Shared Function pixSearchForRectangle(pixs as IntPTR, boxs as IntPTR, minsum as Integer, skipdist as Integer, delta as Integer, maxbg as Integer, sideflag as Integer, boxat as IntPTR, nascore as IntPTR) as Integer
End Function

' SRC\boxfunc3.c (94, 1)
' pixMaskConnComp()
' pixMaskConnComp(PIX *, l_int32, BOXA **) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This generates a mask image with ON pixels over the
'''  * b.b. of the c.c. in pixs.  If there are no ON pixels in pixs,
'''  * pixd will also have no ON pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp mask over the c.c., or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
''' <param name="pboxa"> \param[out]   pboxa [optional] bounding boxes of c.c.</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMaskConnComp")> _
Friend Shared Function pixMaskConnComp(pixs as IntPTR, connectivity as Integer, pboxa as Object) as IntPTR
End Function

' SRC\boxfunc3.c (148, 1)
' pixMaskBoxa()
' pixMaskBoxa(PIX *, PIX *, BOXA *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This can be used with:
'''  *  pixd = NULL  (makes a new pixd)
'''  *  pixd = pixs  (in-place)
'''  *   (2) If pixd == NULL, this first makes a copy of pixs, and then
'''  * bit-twiddles over the boxes.  Otherwise, it operates directly
'''  * on pixs.
'''  *   (3) This simple function is typically used with 1 bpp images.
'''  * It uses the 1-image rasterop function, rasteropUniLow(),
'''  * to set, clear or flip the pixels in pixd.
'''  *   (4) If you want to generate a 1 bpp mask of ON pixels from the boxes
'''  * in a Boxa, in a pix of size (w,h):
'''  *  pix = pixCreate(w, h, 1);
'''  *  pixMaskBoxa(pix, pix, boxa, L_SET_PIXELS);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with masking op over the boxes, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd [optional] may be NULL</param>
''' <param name="pixs"> \param[in]    pixs any depth; not cmapped</param>
''' <param name="boxa"> \param[in]    boxa of boxes, to paint</param>
''' <param name="op"> \param[in]    op L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMaskBoxa")> _
Friend Shared Function pixMaskBoxa(pixd as IntPTR, pixs as IntPTR, boxa as IntPTR, op as Integer) as IntPTR
End Function

' SRC\boxfunc3.c (217, 1)
' pixPaintBoxa()
' pixPaintBoxa(PIX *, BOXA *, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp
'''  * and the boxa is painted using a colormap; otherwise,
'''  * it is converted to 32 bpp rgb.
'''  *   (2) There are several ways to display a box on an image:
'''  *   * Paint it as a solid color
'''  *   * Draw the outline
'''  *   * Blend the outline or region with the existing image
'''  * We provide painting and drawing here; blending is in blend.c.
'''  * When painting or drawing, the result can be either a
'''  * cmapped image or an rgb image.  The dest will be cmapped
'''  * if the src is either 1 bpp or has a cmap that is not full.
'''  * To force RGB output, use pixConvertTo8(pixs, FALSE)
'''  * before calling any of these paint and draw functions.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with painted boxes, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth, can be cmapped</param>
''' <param name="boxa"> \param[in]    boxa of boxes, to paint</param>
''' <param name="val"> \param[in]    val rgba color to paint</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixPaintBoxa")> _
Friend Shared Function pixPaintBoxa(pixs as IntPTR, boxa as IntPTR, val as UInteger) as IntPTR
End Function

' SRC\boxfunc3.c (283, 1)
' pixSetBlackOrWhiteBoxa()
' pixSetBlackOrWhiteBoxa(PIX *, BOXA *, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with boxes filled with white or black, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth, can be cmapped</param>
''' <param name="boxa"> \param[in]    boxa [optional] of boxes, to clear or set</param>
''' <param name="op"> \param[in]    op L_SET_BLACK, L_SET_WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetBlackOrWhiteBoxa")> _
Friend Shared Function pixSetBlackOrWhiteBoxa(pixs as IntPTR, boxa as IntPTR, op as Integer) as IntPTR
End Function

' SRC\boxfunc3.c (364, 1)
' pixPaintBoxaRandom()
' pixPaintBoxaRandom(PIX *, BOXA *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixs is 1 bpp, we paint the boxa using a colormap;
'''  * otherwise, we convert to 32 bpp.
'''  *   (2) We use up to 254 different colors for painting the regions.
'''  *   (3) If boxes overlap, the later ones paint over earlier ones.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with painted boxes, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth, can be cmapped</param>
''' <param name="boxa"> \param[in]    boxa of boxes, to paint</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixPaintBoxaRandom")> _
Friend Shared Function pixPaintBoxaRandom(pixs as IntPTR, boxa as IntPTR) as IntPTR
End Function

' SRC\boxfunc3.c (435, 1)
' pixBlendBoxaRandom()
' pixBlendBoxaRandom(PIX *, BOXA *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pixs is converted to 32 bpp.
'''  *   (2) This differs from pixPaintBoxaRandom(), in that the
'''  * colors here are blended with the color of pixs.
'''  *   (3) We use up to 254 different colors for painting the regions.
'''  *   (4) If boxes overlap, the final color depends only on the last
'''  * rect that is used.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp, with blend/painted boxes, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth; can be cmapped</param>
''' <param name="boxa"> \param[in]    boxa of boxes, to blend/paint</param>
''' <param name="fract"> \param[in]    fract of box color to use</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlendBoxaRandom")> _
Friend Shared Function pixBlendBoxaRandom(pixs as IntPTR, boxa as IntPTR, fract as single) as IntPTR
End Function

' SRC\boxfunc3.c (496, 1)
' pixDrawBoxa()
' pixDrawBoxa(PIX *, BOXA *, l_int32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp
'''  * and the boxa is drawn using a colormap; otherwise,
'''  * it is converted to 32 bpp rgb.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with outlines of boxes added, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth; can be cmapped</param>
''' <param name="boxa"> \param[in]    boxa of boxes, to draw</param>
''' <param name="width"> \param[in]    width of lines</param>
''' <param name="val"> \param[in]    val rgba color to draw</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDrawBoxa")> _
Friend Shared Function pixDrawBoxa(pixs as IntPTR, boxa as IntPTR, width as Integer, val as UInteger) as IntPTR
End Function

' SRC\boxfunc3.c (560, 1)
' pixDrawBoxaRandom()
' pixDrawBoxaRandom(PIX *, BOXA *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixs is 1 bpp, we draw the boxa using a colormap;
'''  * otherwise, we convert to 32 bpp.
'''  *   (2) We use up to 254 different colors for drawing the boxes.
'''  *   (3) If boxes overlap, the later ones draw over earlier ones.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with box outlines drawn, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth, can be cmapped</param>
''' <param name="boxa"> \param[in]    boxa of boxes, to draw</param>
''' <param name="width"> \param[in]    width thickness of line</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDrawBoxaRandom")> _
Friend Shared Function pixDrawBoxaRandom(pixs as IntPTR, boxa as IntPTR, width as Integer) as IntPTR
End Function

' SRC\boxfunc3.c (634, 1)
' boxaaDisplay()
' boxaaDisplay(PIX *, BOXAA *, l_int32, l_int32, l_uint32, l_uint32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If %pixs exists, this renders the boxes over an 8 bpp version
'''  * of it.  Otherwise, it renders the boxes over an empty image
'''  * with a white background.
'''  *   (2) If %pixs exists, the dimensions of %pixd are the same,
'''  * and input values of %w and %h are ignored.
'''  * If %pixs is NULL, the dimensions of %pixd are determined by
'''  *   - %w and %h if both are > 0, or
'''  *   - the minimum size required using all boxes in %baa.
'''  *
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     [optional] 1 bpp</param>
''' <param name="baa"> \param[in]    baa      boxaa, typically from a 2d sort</param>
''' <param name="linewba"> \param[in]    linewba  line width to display outline of each boxa</param>
''' <param name="linewb"> \param[in]    linewb   line width to display outline of each box</param>
''' <param name="colorba"> \param[in]    colorba  color to display boxa</param>
''' <param name="colorb"> \param[in]    colorb   color to display box</param>
''' <param name="w"> \param[in]    w    width of outupt pix; use 0 if determined by %pixs or %baa</param>
''' <param name="h"> \param[in]    h    height of outupt pix; use 0 if determined by %pixs or %baa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaDisplay")> _
Friend Shared Function boxaaDisplay(pixs as IntPTR, baa as IntPTR, linewba as Integer, linewb as Integer, colorba as UInteger, colorb as UInteger, w as Integer, h as Integer) as IntPTR
End Function

' SRC\boxfunc3.c (716, 1)
' pixaDisplayBoxaa()
' pixaDisplayBoxaa(PIXA *, BOXAA *, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) All pix in %pixas that are not rgb are converted to rgb.
'''  *   (2) Each boxa in %baa contains boxes that will be drawn on
'''  * the corresponding pix in %pixas.
'''  *   (3) The color of the boxes drawn on each pix are selected with
'''  * %colorflag:
'''  *   * For red, green or blue: use L_DRAW_RED, etc.
'''  *   * For sequential r, g, b: use L_DRAW_RGB
'''  *   * For random colors: use L_DRAW_RANDOM
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa with box outlines drawn on each pix, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas any depth, can be cmapped</param>
''' <param name="baa"> \param[in]    baa  boxes to draw on input pixa</param>
''' <param name="colorflag"> \param[in]    colorflag  (L_DRAW_RED, L_DRAW_GREEN, etc)</param>
''' <param name="width"> \param[in]    width thickness of lines</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplayBoxaa")> _
Friend Shared Function pixaDisplayBoxaa(pixas as IntPTR, baa as IntPTR, colorflag as Integer, width as Integer) as IntPTR
End Function

' SRC\boxfunc3.c (835, 1)
' pixSplitIntoBoxa()
' pixSplitIntoBoxa(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This generates a boxa of rectangles that covers
'''  * the fg of a mask.  For each 8-connected component in pixs,
'''  * it does a greedy partitioning, choosing the largest
'''  * rectangle found from each of the four directions at each iter.
'''  * See pixSplitComponentIntoBoxa() for details.
'''  *   (2) The input parameters give some flexibility for boundary
'''  * noise.  The resulting set of rectangles may cover some
'''  * bg pixels.
'''  *   (3) This should be used when there are a small number of
'''  * mask components, each of which has sides that are close
'''  * to horizontal and vertical.  The input parameters %delta
'''  * and %maxbg determine whether or not holes in the mask are covered.
'''  *   (4) The parameter %maxcomps gives the maximum number of allowed
'''  * rectangles extracted from any single connected component.
'''  * Use 0 if no limit is to be applied.
'''  *   (5) The flag %remainder specifies whether we take a final bounding
'''  * box for anything left after the maximum number of allowed
'''  * rectangle is extracted.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa of rectangles covering the fg of pixs, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="minsum"> \param[in]    minsum  minimum pixels to trigger propagation</param>
''' <param name="skipdist"> \param[in]    skipdist distance before computing sum for propagation</param>
''' <param name="delta"> \param[in]    delta difference required to stop propagation</param>
''' <param name="maxbg"> \param[in]    maxbg maximum number of allowed bg pixels in ref scan</param>
''' <param name="maxcomps"> \param[in]    maxcomps use 0 for unlimited number of subdivided components</param>
''' <param name="remainder"> \param[in]    remainder set to 1 to get b.b. of remaining stuff</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSplitIntoBoxa")> _
Friend Shared Function pixSplitIntoBoxa(pixs as IntPTR, minsum as Integer, skipdist as Integer, delta as Integer, maxbg as Integer, maxcomps as Integer, remainder as Integer) as IntPTR
End Function

' SRC\boxfunc3.c (944, 1)
' pixSplitComponentIntoBoxa()
' pixSplitComponentIntoBoxa(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This generates a boxa of rectangles that covers
'''  * the fg of a mask.  It does so by a greedy partitioning of
'''  * the mask, choosing the largest rectangle found from
'''  * each of the four directions at each step.
'''  *   (2) The input parameters give some flexibility for boundary
'''  * noise.  The resulting set of rectangles must cover all
'''  * the fg pixels and, in addition, may cover some bg pixels.
'''  * Using small input parameters on a noiseless mask (i.e., one
'''  * that has only large vertical and horizontal edges) will
'''  * result in a proper covering of only the fg pixels of the mask.
'''  *   (3) The input is assumed to be a single connected component, that
'''  * may have holes.  From each side, sweep inward, counting
'''  * the pixels.  If the count becomes greater than %minsum,
'''  * and we have moved forward a further amount %skipdist,
'''  * record that count ('countref'), but don't accept if the scan
'''  * contains more than %maxbg bg pixels.  Continue the scan
'''  * until we reach a count that differs from countref by at
'''  * least %delta, at which point the propagation stops.  The box
'''  * swept out gets a score, which is the sum of fg pixels
'''  * minus a penalty.  The penalty is the number of bg pixels
'''  * in the box.  This is done from all four sides, and the
'''  * side with the largest score is saved as a rectangle.
'''  * The process repeats until there is either no rectangle
'''  * left, or there is one that can't be captured from any
'''  * direction.  For the latter case, we simply accept the
'''  * last rectangle.
'''  *   (4) The input box is only used to specify the location of
'''  * the UL corner of pix, with respect to an origin that
'''  * typically represents the UL corner of an underlying image,
'''  * of which pix is one component.  If %box is null,
'''  * the UL corner is taken to be (0, 0).
'''  *   (5) The parameter %maxcomps gives the maximum number of allowed
'''  * rectangles extracted from any single connected component.
'''  * Use 0 if no limit is to be applied.
'''  *   (6) The flag %remainder specifies whether we take a final bounding
'''  * box for anything left after the maximum number of allowed
'''  * rectangle is extracted.
'''  *   (7) So if %maxcomps > 0, it specifies that we want no more than
'''  * the first %maxcomps rectangles that satisfy the input
'''  * criteria.  After this, we can get a final rectangle that
'''  * bounds everything left over by setting %remainder == 1.
'''  * If %remainder == 0, we only get rectangles that satisfy
'''  * the input criteria.
'''  *   (8) It should be noted that the removal of rectangles can
'''  * break the original c.c. into several c.c.
'''  *   (9) Summing up:
'''  *   * If %maxcomp == 0, the splitting proceeds as far as possible.
'''  *   * If %maxcomp > 0, the splitting stops when %maxcomps are
'''  * found, or earlier if no more components can be selected.
'''  *   * If %remainder == 1 and components remain that cannot be
'''  * selected, they are returned as a single final rectangle;
'''  * otherwise, they are ignored.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa of rectangles covering the fg of pix, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix 1 bpp</param>
''' <param name="box"> \param[in]    box [optional] location of pix w/rt an origin</param>
''' <param name="minsum"> \param[in]    minsum  minimum pixels to trigger propagation</param>
''' <param name="skipdist"> \param[in]    skipdist distance before computing sum for propagation</param>
''' <param name="delta"> \param[in]    delta difference required to stop propagation</param>
''' <param name="maxbg"> \param[in]    maxbg maximum number of allowed bg pixels in ref scan</param>
''' <param name="maxcomps"> \param[in]    maxcomps use 0 for unlimited number of subdivided components</param>
''' <param name="remainder"> \param[in]    remainder set to 1 to get b.b. of remaining stuff</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSplitComponentIntoBoxa")> _
Friend Shared Function pixSplitComponentIntoBoxa(pix as IntPTR, box as IntPTR, minsum as Integer, skipdist as Integer, delta as Integer, maxbg as Integer, maxcomps as Integer, remainder as Integer) as IntPTR
End Function

' SRC\boxfunc3.c (1308, 1)
' makeMosaicStrips()
' makeMosaicStrips(l_int32, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) For example, this can be used to generate a pixa of
'''  * vertical strips of width 10 from an image, using:
'''  * pixGetDimensions(pix, &w, &h, NULL);
'''  * boxa = makeMosaicStrips(w, h, L_SCAN_HORIZONTAL, 10);
'''  * pixa = pixClipRectangles(pix, boxa);
'''  * All strips except the last will be the same width.  The
'''  * last strip will have width w % 10.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="w"> \param[in]    w, h</param>
''' <param name="h"> \param[in]    direction L_SCAN_HORIZONTAL or L_SCAN_VERTICAL</param>
''' <param name="direction"> \param[in]    size of strips in the scan direction</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeMosaicStrips")> _
Friend Shared Function makeMosaicStrips(w as Integer, h as Integer, direction as Integer, size as Integer) as IntPTR
End Function

' SRC\boxfunc3.c (1388, 1)
' boxaCompareRegions()
' boxaCompareRegions(BOXA *, BOXA *, l_int32, l_int32 *, l_float32 *, l_float32 *, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This takes 2 boxa, removes all boxes smaller than a given area,
'''  * and compares the remaining boxes between the boxa.
'''  *   (2) The area threshold is introduced to help remove noise from
'''  * small components.  Any box with a smaller value of w * h
'''  * will be removed from consideration.
'''  *   (3) The xor difference is the most stringent test, requiring alignment
'''  * of the corresponding boxes.  It is also more computationally
'''  * intensive and is optionally returned.  Alignment is to the
'''  * UL corner of each region containing all boxes, as given by
'''  * boxaGetExtent().
'''  *   (4) Both fractional differences are with respect to the total
'''  * area in the two boxa.  They range from 0.0 to 1.0.
'''  * A perfect match has value 0.0.  If both boxa are empty,
'''  * we return 0.0; if one is empty we return 1.0.
'''  *   (5) An example input might be the rectangular regions of a
'''  * segmentation mask for text or images from two pages.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa1"> \param[in]    boxa1, boxa2</param>
''' <param name="boxa2"> \param[in]    areathresh minimum area of boxes to be considered</param>
''' <param name="areathresh"> \param[out]   pnsame  true if same number of boxes</param>
''' <param name="pnsame"> \param[out]   pdiffarea fractional difference in total area</param>
''' <param name="pdiffarea"> \param[out]   pdiffxor [optional] fractional difference</param>
''' <param name="pdiffxor"> \param[out]   ppixdb [optional] debug pix showing two boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaCompareRegions")> _
Friend Shared Function boxaCompareRegions(boxa1 as IntPTR, boxa2 as IntPTR, areathresh as Integer, pnsame as Integer, pdiffarea as single, pdiffxor as single, ppixdb as Object) as Integer
End Function

' SRC\boxfunc3.c (1532, 1)
' pixSelectLargeULComp()
' pixSelectLargeULComp(PIX *, l_float32, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This selects a box near the top (first) and left (second)
'''  * of the image, from the set of all boxes that have
'''  * area >= %areaslop * (area of biggest box),
'''  * where %areaslop is some fraction; say ~ 0.9.
'''  *   (2) For all boxes satisfying the above condition, select
'''  * the left-most box that is within %yslop (say, 20) pixels
'''  * of the box nearest the top.
'''  *   (3) This can be used to reliably select a specific one of
'''  * the largest regions in an image, for applications where
'''  * there are expected to be small variations in region size
'''  * and location.
'''  *   (4) See boxSelectLargeULBox() for implementation details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="areaslop"> \param[in]    areaslop fraction near but less than 1.0</param>
''' <param name="yslop"> \param[in]    yslop number of pixels in y direction</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSelectLargeULComp")> _
Friend Shared Function pixSelectLargeULComp(pixs as IntPTR, areaslop as single, yslop as Integer, connectivity as Integer) as IntPTR
End Function

' SRC\boxfunc3.c (1573, 1)
' boxaSelectLargeULBox()
' boxaSelectLargeULBox(BOXA *, l_float32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) See usage notes in pixSelectLargeULComp().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas 1 bpp</param>
''' <param name="areaslop"> \param[in]    areaslop fraction near but less than 1.0</param>
''' <param name="yslop"> \param[in]    yslop number of pixels in y direction</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSelectLargeULBox")> _
Friend Shared Function boxaSelectLargeULBox(boxas as IntPTR, areaslop as single, yslop as Integer) as IntPTR
End Function

#End Region
#Region "SRC\boxfunc4.c"
' SRC\boxfunc4.c (86, 16)
' boxaTestEvenOddHeight()
' boxaTestEvenOddHeight(BOXA *, BOXA *, l_int32, l_float32 *, l_float32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This compares differences in the y location and height of
'''  * adjacent boxes, in each of the input boxa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa1"> \param[in]    boxa1, boxa2</param>
''' <param name="boxa2"> \param[in]    start 0 if pairing (0,1), etc; 1 if pairing (1,2), etc</param>
''' <param name="start"> \param[out]   pdel1 root mean of (dely^2 + delh^2 for boxa1</param>
''' <param name="pdel1"> \param[out]   pdel2 root mean of (dely^2 + delh^2 for boxa2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaTestEvenOddHeight")> _
Friend Shared Function boxaTestEvenOddHeight(boxa1 as IntPTR, boxa2 as IntPTR, start as Integer, pdel1 as single, pdel2 as single) as Integer
End Function

' SRC\boxfunc4.c (88, 16)
' boxaFillAll()
' boxaFillAll(BOXA *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This static function replaces every invalid box with the
'''  * nearest valid box.  If there are no valid boxes, it
'''  * issues a warning.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaFillAll")> _
Friend Shared Function boxaFillAll(boxa as IntPTR) as Integer
End Function

' SRC\boxfunc4.c (111, 1)
' boxaSelectRange()
' boxaSelectRange(BOXA *, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) The copyflag specifies what we do with each box from boxas.
'''  * Specifically, L_CLONE inserts a clone into boxad of each
'''  * selected box from boxas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="first"> \param[in]    first use 0 to select from the beginning</param>
''' <param name="last"> \param[in]    last use 0 to select to the end</param>
''' <param name="copyflag"> \param[in]    copyflag L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSelectRange")> _
Friend Shared Function boxaSelectRange(boxas as IntPTR, first as Integer, last as Integer, copyflag as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (164, 1)
' boxaaSelectRange()
' boxaaSelectRange(BOXAA *, l_int32, l_int32, l_int32) as BOXAA *
''' <summary>
''' * Notes:
'''  *   (1) The copyflag specifies what we do with each boxa from baas.
'''  * Specifically, L_CLONE inserts a clone into baad of each
'''  * selected boxa from baas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  baad, or NULL on error</returns>
''' <param name="baas"> \param[in]    baas</param>
''' <param name="first"> \param[in]    first use 0 to select from the beginning</param>
''' <param name="last"> \param[in]    last use 0 to select to the end</param>
''' <param name="copyflag"> \param[in]    copyflag L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaSelectRange")> _
Friend Shared Function boxaaSelectRange(baas as IntPTR, first as Integer, last as Integer, copyflag as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (227, 1)
' boxaSelectBySize()
' boxaSelectBySize(BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32 *) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) The args specify constraints on the size of the
'''  * components that are kept.
'''  *   (2) Uses box copies in the new boxa.
'''  *   (3) If the selection type is L_SELECT_WIDTH, the input
'''  * height is ignored, and v.v.
'''  *   (4) To keep small components, use relation = L_SELECT_IF_LT or
'''  * L_SELECT_IF_LTE.
'''  * To keep large components, use relation = L_SELECT_IF_GT or
'''  * L_SELECT_IF_GTE.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad filtered set, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="width"> \param[in]    width, height threshold dimensions</param>
''' <param name="height"> \param[in]    type L_SELECT_WIDTH, L_SELECT_HEIGHT,</param>
''' <param name="type"> \param[in]    relation L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
''' <param name="relation"> \param[out]   pchanged [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSelectBySize")> _
Friend Shared Function boxaSelectBySize(boxas as IntPTR, width as Integer, height as Integer, type as Integer, relation as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (290, 1)
' boxaMakeSizeIndicator()
' boxaMakeSizeIndicator(BOXA *, l_int32, l_int32, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The args specify constraints on the size of the
'''  * components that are kept.
'''  *   (2) If the selection type is L_SELECT_WIDTH, the input
'''  * height is ignored, and v.v.
'''  *   (3) To keep small components, use relation = L_SELECT_IF_LT or
'''  * L_SELECT_IF_LTE.
'''  * To keep large components, use relation = L_SELECT_IF_GT or
'''  * L_SELECT_IF_GTE.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na indicator array, or NULL on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="width"> \param[in]    width, height threshold dimensions</param>
''' <param name="height"> \param[in]    type L_SELECT_WIDTH, L_SELECT_HEIGHT,</param>
''' <param name="type"> \param[in]    relation L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaMakeSizeIndicator")> _
Friend Shared Function boxaMakeSizeIndicator(boxa as IntPTR, width as Integer, height as Integer, type as Integer, relation as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (377, 1)
' boxaSelectByArea()
' boxaSelectByArea(BOXA *, l_int32, l_int32, l_int32 *) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) Uses box copies in the new boxa.
'''  *   (2) To keep small components, use relation = L_SELECT_IF_LT or
'''  * L_SELECT_IF_LTE.
'''  * To keep large components, use relation = L_SELECT_IF_GT or
'''  * L_SELECT_IF_GTE.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad filtered set, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="area"> \param[in]    area threshold value of width  height</param>
''' <param name="relation"> \param[in]    relation L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
''' <param name="pchanged"> \param[out]   pchanged [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSelectByArea")> _
Friend Shared Function boxaSelectByArea(boxas as IntPTR, area as Integer, relation as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (427, 1)
' boxaMakeAreaIndicator()
' boxaMakeAreaIndicator(BOXA *, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) To keep small components, use relation = L_SELECT_IF_LT or
'''  * L_SELECT_IF_LTE.
'''  * To keep large components, use relation = L_SELECT_IF_GT or
'''  * L_SELECT_IF_GTE.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na indicator array, or NULL on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="area"> \param[in]    area threshold value of width  height</param>
''' <param name="relation"> \param[in]    relation L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaMakeAreaIndicator")> _
Friend Shared Function boxaMakeAreaIndicator(boxa as IntPTR, area as Integer, relation as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (481, 1)
' boxaSelectByWHRatio()
' boxaSelectByWHRatio(BOXA *, l_float32, l_int32, l_int32 *) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) Uses box copies in the new boxa.
'''  *   (2) To keep narrow components, use relation = L_SELECT_IF_LT or
'''  * L_SELECT_IF_LTE.
'''  * To keep wide components, use relation = L_SELECT_IF_GT or
'''  * L_SELECT_IF_GTE.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad filtered set, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="ratio"> \param[in]    ratio    width/height threshold value</param>
''' <param name="relation"> \param[in]    relation L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
''' <param name="pchanged"> \param[out]   pchanged [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSelectByWHRatio")> _
Friend Shared Function boxaSelectByWHRatio(boxas as IntPTR, ratio as single, relation as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (531, 1)
' boxaMakeWHRatioIndicator()
' boxaMakeWHRatioIndicator(BOXA *, l_float32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) To keep narrow components, use relation = L_SELECT_IF_LT or
'''  * L_SELECT_IF_LTE.
'''  * To keep wide components, use relation = L_SELECT_IF_GT or
'''  * L_SELECT_IF_GTE.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na indicator array, or NULL on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="ratio"> \param[in]    ratio    width/height threshold value</param>
''' <param name="relation"> \param[in]    relation L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaMakeWHRatioIndicator")> _
Friend Shared Function boxaMakeWHRatioIndicator(boxa as IntPTR, ratio as single, relation as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (583, 1)
' boxaSelectWithIndicator()
' boxaSelectWithIndicator(BOXA *, NUMA *, l_int32 *) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) Returns a copy of the boxa if no components are removed.
'''  *   (2) Uses box copies in the new boxa.
'''  *   (3) The indicator numa has values 0 (ignore) and 1 (accept).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="na"> \param[in]    na indicator numa</param>
''' <param name="pchanged"> \param[out]   pchanged [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSelectWithIndicator")> _
Friend Shared Function boxaSelectWithIndicator(boxas as IntPTR, na as IntPTR, pchanged as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (641, 1)
' boxaPermutePseudorandom()
' boxaPermutePseudorandom(BOXA *) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This does a pseudorandom in-place permutation of the boxes.
'''  *   (2) The result is guaranteed not to have any boxes in their
'''  * original position, but it is not very random.  If you
'''  * need randomness, use boxaPermuteRandom().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad with boxes permuted, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas input boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaPermutePseudorandom")> _
Friend Shared Function boxaPermutePseudorandom(boxas as IntPTR) as IntPTR
End Function

' SRC\boxfunc4.c (682, 1)
' boxaPermuteRandom()
' boxaPermuteRandom(BOXA *, BOXA *) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) If boxad is null, make a copy of boxas and permute the copy.
'''  * Otherwise, boxad must be equal to boxas, and the operation
'''  * is done in-place.
'''  *   (2) If boxas is empty, return an empty boxad.
'''  *   (3) This does a random in-place permutation of the boxes,
'''  * by swapping each box in turn with a random box.  The
'''  * result is almost guaranteed not to have any boxes in their
'''  * original position.
'''  *   (4) MSVC rand() has MAX_RAND = 2^15 - 1, so it will not do
'''  * a proper permutation is the number of boxes exceeds this.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad with boxes permuted, or NULL on error</returns>
''' <param name="boxad"> \param[in]    boxad [optional]   can be null or equal to boxas</param>
''' <param name="boxas"> \param[in]    boxas              input boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaPermuteRandom")> _
Friend Shared Function boxaPermuteRandom(boxad as IntPTR, boxas as IntPTR) as IntPTR
End Function

' SRC\boxfunc4.c (719, 1)
' boxaSwapBoxes()
' boxaSwapBoxes(BOXA *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="i"> \param[in]    i, j two indices of boxes, that are to be swapped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSwapBoxes")> _
Friend Shared Function boxaSwapBoxes(boxa as IntPTR, i as Integer, j as Integer) as Integer
End Function

' SRC\boxfunc4.c (763, 1)
' boxaConvertToPta()
' boxaConvertToPta(BOXA *, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) If ncorners == 2, we select the UL and LR corners.
'''  * Otherwise we save all 4 corners in this order: UL, UR, LL, LR.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta with %ncorners points for each box in the boxa,</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="ncorners"> \param[in]    ncorners 2 or 4 for the representation of each box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaConvertToPta")> _
Friend Shared Function boxaConvertToPta(boxa as IntPTR, ncorners as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (808, 1)
' ptaConvertToBoxa()
' ptaConvertToBoxa(PTA *, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) For 2 corners, the order of the 2 points is UL, LR.
'''  * For 4 corners, the order of points is UL, UR, LL, LR.
'''  *   (2) Each derived box is the minimum size containing all corners.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa with one box for each 2 or 4 points in the pta,</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="ncorners"> \param[in]    ncorners 2 or 4 for the representation of each box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaConvertToBoxa")> _
Friend Shared Function ptaConvertToBoxa(pta as IntPTR, ncorners as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (863, 1)
' boxConvertToPta()
' boxConvertToPta(BOX *, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) If ncorners == 2, we select the UL and LR corners.
'''  * Otherwise we save all 4 corners in this order: UL, UR, LL, LR.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta with %ncorners points, or NULL on error</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="ncorners"> \param[in]    ncorners 2 or 4 for the representation of the box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxConvertToPta")> _
Friend Shared Function boxConvertToPta(box as IntPTR, ncorners as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (905, 1)
' ptaConvertToBox()
' ptaConvertToBox(PTA *) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) For 2 corners, the order of the 2 points is UL, LR.
'''  * For 4 corners, the order of points is UL, UR, LL, LR.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box minimum containing all points in the pta, or NULL on error</returns>
''' <param name="pta"> \param[in]    pta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaConvertToBox")> _
Friend Shared Function ptaConvertToBox(pta as IntPTR) as IntPTR
End Function

' SRC\boxfunc4.c (967, 1)
' boxaSmoothSequenceLS()
' boxaSmoothSequenceLS(BOXA *, l_float32, l_int32, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This returns a modified version of %boxas by constructing
'''  * for each input box a box that has been linear least square fit
'''  * (LSF) to the entire set.  The linear fitting is done to each of
'''  * the box sides independently, after outliers are rejected,
'''  * and it is computed separately for sequences of even and
'''  * odd boxes.  Once the linear LSF box is found, the output box
'''  * (in %boxad) is constructed from the input box and the LSF
'''  * box, depending on %subflag.  See boxaModifyWithBoxa() for
'''  * details on the use of %subflag and %maxdiff.
'''  *   (2) This is useful if, in both the even and odd sets, the box
'''  * edges vary roughly linearly with its index in the set.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad fitted boxa, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas source boxa</param>
''' <param name="factor"> \param[in]    factor reject outliers with widths and heights deviating</param>
''' <param name="subflag"> \param[in]    subflag L_USE_MINSIZE, L_USE_MAXSIZE,</param>
''' <param name="maxdiff"> \param[in]    maxdiff parameter used with L_SUB_ON_LOC_DIFF,</param>
''' <param name="extrapixels"> \param[in]    extrapixels  pixels added on all sides (or subtracted</param>
''' <param name="debug"> \param[in]    debug 1 for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSmoothSequenceLS")> _
Friend Shared Function boxaSmoothSequenceLS(boxas as IntPTR, factor as single, subflag as Integer, maxdiff as Integer, extrapixels as Integer, debug as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (1073, 1)
' boxaSmoothSequenceMedian()
' boxaSmoothSequenceMedian(BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) The target width of the sliding window is 2 * %halfwin + 1.
'''  * If necessary, this will be reduced by boxaWindowedMedian().
'''  *   (2) This returns a modified version of %boxas by constructing
'''  * for each input box a box that has been smoothed with windowed
'''  * median filtering.  The filtering is done to each of the
'''  * box sides independently, and it is computed separately for
'''  * sequences of even and odd boxes.  The output %boxad is
'''  * constructed from the input boxa and the filtered boxa,
'''  * depending on %subflag.  See boxaModifyWithBoxa() for
'''  * details on the use of %subflag, %maxdiff and %extrapixels.
'''  *   (3) This is useful for removing noise separately in the even
'''  * and odd sets, where the box edge locations can have
'''  * discontinuities but otherwise vary roughly linearly within
'''  * intervals of size %halfwin or larger.
'''  *   (4) If you don't need to handle even and odd sets separately,
'''  * just do this:
'''  *  boxam = boxaWindowedMedian(boxas, halfwin, debug);
'''  *  boxad = boxaModifyWithBoxa(boxas, boxam, subflag, maxdiff,
'''  *     extrapixels);
'''  *  boxaDestroy(&boxam);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad fitted boxa, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas source boxa</param>
''' <param name="halfwin"> \param[in]    halfwin half-width of sliding window; used to find median</param>
''' <param name="subflag"> \param[in]    subflag L_USE_MINSIZE, L_USE_MAXSIZE,</param>
''' <param name="maxdiff"> \param[in]    maxdiff parameter used with L_SUB_ON_LOC_DIFF,</param>
''' <param name="extrapixels"> \param[in]    extrapixels  pixels added on all sides (or subtracted</param>
''' <param name="debug"> \param[in]    debug 1 for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSmoothSequenceMedian")> _
Friend Shared Function boxaSmoothSequenceMedian(boxas as IntPTR, halfwin as Integer, subflag as Integer, maxdiff as Integer, extrapixels as Integer, debug as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (1179, 1)
' boxaLinearFit()
' boxaLinearFit(BOXA *, l_float32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This finds a set of boxes (boxad) where each edge of each box is
'''  * a linear least square fit (LSF) to the edges of the
'''  * input set of boxes (boxas).  Before fitting, outliers in
'''  * the boxes in boxas are removed (see below).
'''  *   (2) This is useful when each of the box edges in boxas are expected
'''  * to vary linearly with box index in the set.  These could
'''  * be, for example, noisy measurements of similar regions
'''  * on successive scanned pages.
'''  *   (3) Method: there are 2 steps:
'''  * (a) Find and remove outliers, separately based on the deviation
'''  *  from the median of the width and height of the box.
'''  *  Use %factor to specify tolerance to outliers; use a very
'''  *  large value of %factor to avoid rejecting any box sides
'''  *  in the linear LSF.
'''  * (b) On the remaining boxes, do a linear LSF independently
'''  *  for each of the four sides.
'''  *   (4) Invalid input boxes are not used in computation of the LSF.
'''  *   (5) The returned boxad can then be used in boxaModifyWithBoxa()
'''  * to selectively change the boxes in boxas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad fitted boxa, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas source boxa</param>
''' <param name="factor"> \param[in]    factor reject outliers with widths and heights deviating</param>
''' <param name="debug"> \param[in]    debug 1 for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaLinearFit")> _
Friend Shared Function boxaLinearFit(boxas as IntPTR, factor as single, debug as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (1331, 1)
' boxaWindowedMedian()
' boxaWindowedMedian(BOXA *, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This finds a set of boxes (boxad) where each edge of each box is
'''  * a windowed median smoothed value to the edges of the
'''  * input set of boxes (boxas).
'''  *   (2) Invalid input boxes are filled from nearby ones.
'''  *   (3) The returned boxad can then be used in boxaModifyWithBoxa()
'''  * to selectively change the boxes in the source boxa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad smoothed boxa, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas source boxa</param>
''' <param name="halfwin"> \param[in]    halfwin half width of window over which the median is found</param>
''' <param name="debug"> \param[in]    debug 1 for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaWindowedMedian")> _
Friend Shared Function boxaWindowedMedian(boxas as IntPTR, halfwin as Integer, debug as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (1469, 1)
' boxaModifyWithBoxa()
' boxaModifyWithBoxa(BOXA *, BOXA *, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This takes two input boxa (boxas, boxam) and constructs boxad,
'''  * where each box in boxad is generated from the corresponding
'''  * boxes in boxas and boxam.  The rule for constructing each
'''  * output box depends on %subflag and %maxdiff.  Let boxs be
'''  * a box from %boxas and boxm be a box from %boxam.
'''  * * If %subflag == L_USE_MINSIZE: the output box is the intersection
'''  *   of the two input boxes.
'''  * * If %subflag == L_USE_MAXSIZE: the output box is the union of the
'''  *   two input boxes; i.e., the minimum bounding rectangle for the
'''  *   two input boxes.
'''  * * If %subflag == L_SUB_ON_LOC_DIFF: each side of the output box
'''  *   is found separately from the corresponding side of boxs and boxm.
'''  *   Use the boxm side, expanded by %extrapixels, if greater than
'''  *   %maxdiff pixels from the boxs side.
'''  * * If %subflag == L_SUB_ON_SIZE_DIFF: the sides of the output box
'''  *   are determined in pairs from the width and height of boxs
'''  *   and boxm.  If the boxm width differs by more than %maxdiff
'''  *   pixels from boxs, use the boxm left and right sides,
'''  *   expanded by %extrapixels.  Ditto for the height difference.
'''  * For the last two flags, each side of the output box is found
'''  * separately from the corresponding side of boxs and boxm,
'''  * according to these rules, where "smaller"("bigger") mean in a
'''  * direction that decreases(increases) the size of the output box:
'''  * * If %subflag == L_USE_CAPPED_MIN: use the Min of boxm
'''  *   with the Max of (boxs, boxm +- %maxdiff), where the sign
'''  *   is adjusted to make the box smaller (e.g., use "+" on left side).
'''  * * If %subflag == L_USE_CAPPED_MAX: use the Max of boxm
'''  *   with the Min of (boxs, boxm +- %maxdiff), where the sign
'''  *   is adjusted to make the box bigger (e.g., use "-" on left side).
'''  * Use of the last 2 flags is further explained in (3) and (4).
'''  *   (2) boxas and boxam must be the same size.  If boxam == NULL,
'''  * this returns a copy of boxas with a warning.
'''  *   (3) If %subflag == L_SUB_ON_LOC_DIFF, use boxm for each side
'''  * where the corresponding sides differ by more than %maxdiff.
'''  * Two extreme cases:
'''  * (a) set %maxdiff == 0 to use only values from boxam in boxad.
'''  * (b) set %maxdiff == 10000 to ignore all values from boxam;
'''  *  then boxad will be the same as boxas.
'''  *   (4) If %subflag == L_USE_CAPPED_MAX: use boxm if boxs is smaller;
'''  * use boxs if boxs is bigger than boxm by an amount up to %maxdiff;
'''  * and use boxm +- %maxdiff (the 'capped' value) if boxs is
'''  * bigger than boxm by an amount larger than %maxdiff.
'''  * Similarly, with interchange of Min/Max and sign of %maxdiff,
'''  * for %subflag == L_USE_CAPPED_MIN.
'''  *   (5) If either of corresponding boxes in boxas and boxam is invalid,
'''  * an invalid box is copied to the result.
'''  *   (6) Typical input for boxam may be the output of boxaLinearFit().
'''  * where outliers have been removed and each side is LS fit to a line.
'''  *   (7) Unlike boxaAdjustWidthToTarget() and boxaAdjustHeightToTarget(),
'''  * this uses two boxes and does not specify target dimensions.
'''  * Additional constraints on the size of each box can be enforced
'''  * by following this operation with boxaConstrainSize(), taking
'''  * boxad as input.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad result after adjusting boxes in boxas, or NULL</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="boxam"> \param[in]    boxam boxa with boxes used to modify those in boxas</param>
''' <param name="subflag"> \param[in]    subflag L_USE_MINSIZE, L_USE_MAXSIZE,</param>
''' <param name="maxdiff"> \param[in]    maxdiff parameter used with L_SUB_ON_LOC_DIFF,</param>
''' <param name="extrapixels"> \param[in]    extrapixels  pixels added on all sides (or subtracted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaModifyWithBoxa")> _
Friend Shared Function boxaModifyWithBoxa(boxas as IntPTR, boxam as IntPTR, subflag as Integer, maxdiff as Integer, extrapixels as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (1585, 1)
' boxaConstrainSize()
' boxaConstrainSize(BOXA *, l_int32, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) Forces either width or height (or both) of every box in
'''  * the boxa to a specified size, by moving the indicated sides.
'''  *   (2) Not all input boxes need to be valid.  Median values will be
'''  * used with invalid boxes.
'''  *   (3) Typical input might be the output of boxaLinearFit(),
'''  * where each side has been fit.
'''  *   (4) Unlike boxaAdjustWidthToTarget() and boxaAdjustHeightToTarget(),
'''  * this is not dependent on a difference threshold to change the size.
'''  *   (5) On error, a message is issued and a copy of the input boxa
'''  * is returned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad adjusted so all boxes are the same size</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="width"> \param[in]    width force width of all boxes to this size;</param>
''' <param name="widthflag"> \param[in]    widthflag L_ADJUST_SKIP, L_ADJUST_LEFT, L_ADJUST_RIGHT,</param>
''' <param name="height"> \param[in]    height force height of all boxes to this size;</param>
''' <param name="heightflag"> \param[in]    heightflag L_ADJUST_SKIP, L_ADJUST_TOP, L_ADJUST_BOT,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaConstrainSize")> _
Friend Shared Function boxaConstrainSize(boxas as IntPTR, width as Integer, widthflag as Integer, height as Integer, heightflag as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (1694, 1)
' boxaReconcileEvenOddHeight()
' boxaReconcileEvenOddHeight(BOXA *, l_int32, l_int32, l_int32, l_float32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) The basic idea is to reconcile differences in box height
'''  * in the even and odd boxes, by moving the top and/or bottom
'''  * edges in the even and odd boxes.  Choose the edge or edges
'''  * to be moved, whether to adjust the boxes with the min
'''  * or the max of the medians, and the threshold on the median
'''  * difference between even and odd box heights for the operations
'''  * to take place.  The same threshold is also used to
'''  * determine if each individual box edge is to be adjusted.
'''  *   (2) Boxes are conditionally reset with either the same top (y)
'''  * value or the same bottom value, or both.  The value is
'''  * determined by the greater or lesser of the medians of the
'''  * even and odd boxes, with the choice depending on the value
'''  * of %op, which selects for either min or max median height.
'''  * If the median difference between even and odd boxes is
'''  * greater than %dely, then any individual box edge that differs
'''  * from the selected median by more than %dely is set to
'''  * the selected median times a factor typically near 1.0.
'''  *   (3) Note that if selecting for minimum height, you will choose
'''  * the largest y-value for the top and the smallest y-value for
'''  * the bottom of the box.
'''  *   (4) Typical input might be the output of boxaSmoothSequence(),
'''  * where even and odd boxa have been independently regulated.
'''  *   (5) Require at least 3 valid even boxes and 3 valid odd boxes.
'''  * Median values will be used for invalid boxes.
'''  *   (6) If the median height is not representative of the boxes
'''  * in %boxas, this can make things much worse.  In that case,
'''  * ignore the value of %op, and force pairwise equality of the
'''  * heights, with pairwise maximal vertical extension.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad adjusted, or a copy of boxas on error</returns>
''' <param name="boxas"> \param[in]    boxas containing at least 3 valid boxes in even and odd</param>
''' <param name="sides"> \param[in]    sides L_ADJUST_TOP, L_ADJUST_BOT, L_ADJUST_TOP_AND_BOT</param>
''' <param name="delh"> \param[in]    delh threshold on median height difference</param>
''' <param name="op"> \param[in]    op L_ADJUST_CHOOSE_MIN, L_ADJUST_CHOOSE_MAX</param>
''' <param name="factor"> \param[in]    factor > 0.0, typically near 1.0</param>
''' <param name="start"> \param[in]    start 0 if pairing (0,1), etc; 1 if pairing (1,2), etc</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaReconcileEvenOddHeight")> _
Friend Shared Function boxaReconcileEvenOddHeight(boxas as IntPTR, sides as Integer, delh as Integer, op as Integer, factor as single, start as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (1875, 1)
' boxaReconcilePairWidth()
' boxaReconcilePairWidth(BOXA *, l_int32, l_int32, l_float32, NUMA *) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This reconciles differences in the width of adjacent boxes,
'''  * by moving one side of one of the boxes in each pair.
'''  * If the widths in the pair differ by more than some
'''  * threshold, move either the left side for even boxes or
'''  * the right side for odd boxes, depending on if we're choosing
'''  * the min or max.  If choosing min, the width of the max is
'''  * set to factor * (width of min).  If choosing max, the width
'''  * of the min is set to factor * (width of max).
'''  *   (2) If %na exists, it is an indicator array corresponding to the
'''  * boxes in %boxas.  If %na != NULL, only boxes with an
'''  * indicator value of 1 are allowed to adjust; otherwise,
'''  * all boxes can adjust.
'''  *   (3) Typical input might be the output of boxaSmoothSequence(),
'''  * where even and odd boxa have been independently regulated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad adjusted, or a copy of boxas on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="delw"> \param[in]    delw threshold on adjacent width difference</param>
''' <param name="op"> \param[in]    op L_ADJUST_CHOOSE_MIN, L_ADJUST_CHOOSE_MAX</param>
''' <param name="factor"> \param[in]    factor > 0.0, typically near 1.0</param>
''' <param name="na"> \param[in]    na [optional] indicator array allowing change</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaReconcilePairWidth")> _
Friend Shared Function boxaReconcilePairWidth(boxas as IntPTR, delw as Integer, op as Integer, factor as single, na as IntPTR) as IntPTR
End Function

' SRC\boxfunc4.c (1980, 1)
' boxaPlotSides()
' boxaPlotSides(BOXA *, const char *, NUMA **, NUMA **, NUMA **, NUMA **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This debugging function shows the progression of the four
'''  * sides in the boxa.  There must be at least 2 boxes.
'''  *   (2) If there are invalid boxes (e.g., if only even or odd
'''  * indices have valid boxes), this will fill them with the
'''  * nearest valid box before plotting.
'''  *   (3) The plotfiles are put in /tmp/lept/plots/, and are named
'''  * either with %plotname or, if NULL, a default name.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa source boxa</param>
''' <param name="plotname"> \param[in]    plotname [optional], can be NULL</param>
''' <param name="pnal"> \param[out]   pnal [optional] na of left sides</param>
''' <param name="pnat"> \param[out]   pnat [optional] na of top sides</param>
''' <param name="pnar"> \param[out]   pnar [optional] na of right sides</param>
''' <param name="pnab"> \param[out]   pnab [optional] na of bottom sides</param>
''' <param name="ppixd"> \param[out]   ppixd [optional] pix of the output plot</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaPlotSides")> _
Friend Shared Function boxaPlotSides(boxa as IntPTR, plotname as String, pnal as Object, pnat as Object, pnar as Object, pnab as Object, ppixd as Object) as Integer
End Function

' SRC\boxfunc4.c (2092, 1)
' boxaPlotSizes()
' boxaPlotSizes(BOXA *, const char *, NUMA **, NUMA **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This debugging function shows the progression of box width
'''  * and height in the boxa.  There must be at least 2 boxes.
'''  *   (2) If there are invalid boxes (e.g., if only even or odd
'''  * indices have valid boxes), this will fill them with the
'''  * nearest valid box before plotting.
'''  *   (3) The plotfiles are put in /tmp/lept/plots/, and are named
'''  * either with %plotname or, if NULL, a default name.  Make sure
'''  * that %plotname is a string with no whitespace characters.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa source boxa</param>
''' <param name="plotname"> \param[in]    plotname [optional], can be NULL</param>
''' <param name="pnaw"> \param[out]   pnaw [optional] na of widths</param>
''' <param name="pnah"> \param[out]   pnah [optional] na of heights</param>
''' <param name="ppixd"> \param[out]   ppixd [optional] pix of the output plot</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaPlotSizes")> _
Friend Shared Function boxaPlotSizes(boxa as IntPTR, plotname as String, pnaw as Object, pnah as Object, ppixd as Object) as Integer
End Function

' SRC\boxfunc4.c (2180, 1)
' boxaFillSequence()
' boxaFillSequence(BOXA *, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This simple function replaces invalid boxes with a copy of
'''  * the nearest valid box, selected from either the entire
'''  * sequence (L_USE_ALL_BOXES) or from the boxes with the
'''  * same parity (L_USE_SAME_PARITY_BOXES).  It returns a new boxa.
'''  *   (2) This is useful if you expect boxes in the sequence to
'''  * vary slowly with index.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad filled boxa, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas with at least 3 boxes</param>
''' <param name="useflag"> \param[in]    useflag L_USE_ALL_BOXES, L_USE_SAME_PARITY_BOXES</param>
''' <param name="debug"> \param[in]    debug 1 for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaFillSequence")> _
Friend Shared Function boxaFillSequence(boxas as IntPTR, useflag as Integer, debug as Integer) as IntPTR
End Function

' SRC\boxfunc4.c (2322, 1)
' boxaSizeVariation()
' boxaSizeVariation(BOXA *, l_int32, l_float32 *, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This gives several measures of the smoothness of either the
'''  * width or height of a sequence of boxes.
'''  *   (2) Statistics can be found separately for even and odd boxes.
'''  * Additionally, the average pair-wise difference between
'''  * adjacent even and odd boxes can be returned.
'''  *   (3) The use case is bounding boxes for scanned page images,
'''  * where ideally the sizes should have little variance.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa           at least 4 boxes</param>
''' <param name="type"> \param[in]    type           L_SELECT_WIDTH, L_SELECT_HEIGHT</param>
''' <param name="pdel_evenodd"> \param[out]   pdel_evenodd   [optional] average absolute value of</param>
''' <param name="prms_even"> \param[out]   prms_even      [optional] rms deviation of even boxes</param>
''' <param name="prms_odd"> \param[out]   prms_odd       [optional] rms deviation of odd boxes</param>
''' <param name="prms_all"> \param[out]   prms_all       [optional] rms deviation of all boxes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSizeVariation")> _
Friend Shared Function boxaSizeVariation(boxa as IntPTR, type as Integer, pdel_evenodd as single, prms_even as single, prms_odd as single, prms_all as single) as Integer
End Function

' SRC\boxfunc4.c (2419, 1)
' boxaGetExtent()
' boxaGetExtent(BOXA *, l_int32 *, l_int32 *, BOX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The returned w and h are the minimum size image
'''  * that would contain all boxes untranslated.
'''  *   (2) If there are no valid boxes, returned w and h are 0 and
'''  * all parameters in the returned box are 0.  This
'''  * is not an error, because an empty boxa is valid and
'''  * boxaGetExtent() is required for serialization.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="pw"> \param[out]   pw  [optional] width</param>
''' <param name="ph"> \param[out]   ph  [optional] height</param>
''' <param name="pbox"> \param[out]   pbox [optional]  minimum box containing all boxes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetExtent")> _
Friend Shared Function boxaGetExtent(boxa as IntPTR, pw as Integer, ph as Integer, pbox as Object) as Integer
End Function

' SRC\boxfunc4.c (2485, 1)
' boxaGetCoverage()
' boxaGetCoverage(BOXA *, l_int32, l_int32, l_int32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The boxes in boxa are clipped to the input rectangle.
'''  *   (2) * When %exactflag == 1, we generate a 1 bpp pix of size
'''  *   wc x hc, paint all the boxes black, and count the fg pixels.
'''  *   This can take 1 msec on a large page with many boxes.
'''  * * When %exactflag == 0, we clip each box to the wc x hc region
'''  *   and sum the resulting areas.  This is faster.
'''  * * The results are the same when none of the boxes overlap
'''  *   within the wc x hc region.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="wc"> \param[in]    wc, hc dimensions of overall clipping rectangle with UL</param>
''' <param name="hc"> \param[in]    exactflag 1 for guaranteeing an exact result; 0 for getting</param>
''' <param name="exactflag"> \param[out]   pfract sum of box area as fraction of w  h</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetCoverage")> _
Friend Shared Function boxaGetCoverage(boxa as IntPTR, wc as Integer, hc as Integer, exactflag as Integer, pfract as single) as Integer
End Function

' SRC\boxfunc4.c (2544, 1)
' boxaaSizeRange()
' boxaaSizeRange(BOXAA *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="baa"> \param[in]    baa</param>
''' <param name="pminw"> \param[out]   pminw, pminh, pmaxw, pmaxh [optional] range of</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaSizeRange")> _
Friend Shared Function boxaaSizeRange(baa as IntPTR, pminw as Integer, pminh as Integer, pmaxw as Integer, pmaxh as Integer) as Integer
End Function

' SRC\boxfunc4.c (2598, 1)
' boxaSizeRange()
' boxaSizeRange(BOXA *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="pminw"> \param[out]   pminw, pminh, pmaxw, pmaxh [optional] range of</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSizeRange")> _
Friend Shared Function boxaSizeRange(boxa as IntPTR, pminw as Integer, pminh as Integer, pmaxw as Integer, pmaxh as Integer) as Integer
End Function

' SRC\boxfunc4.c (2649, 1)
' boxaLocationRange()
' boxaLocationRange(BOXA *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="pminx"> \param[out]   pminx, pminy, pmaxx, pmaxy [optional] range of</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaLocationRange")> _
Friend Shared Function boxaLocationRange(boxa as IntPTR, pminx as Integer, pminy as Integer, pmaxx as Integer, pmaxy as Integer) as Integer
End Function

' SRC\boxfunc4.c (2700, 1)
' boxaGetSizes()
' boxaGetSizes(BOXA *, NUMA **, NUMA **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="pnaw"> \param[out]   pnaw, pnah [optional] widths and heights of valid boxes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetSizes")> _
Friend Shared Function boxaGetSizes(boxa as IntPTR, pnaw as Object, pnah as Object) as Integer
End Function

' SRC\boxfunc4.c (2746, 1)
' boxaGetArea()
' boxaGetArea(BOXA *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Measures the total area of the boxes, without regard to overlaps.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="parea"> \param[out]   parea total area of all boxes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetArea")> _
Friend Shared Function boxaGetArea(boxa as IntPTR, parea as Integer) as Integer
End Function

' SRC\boxfunc4.c (2794, 1)
' boxaDisplayTiled()
' boxaDisplayTiled(BOXA *, PIXA *, l_int32, l_int32, l_float32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Displays each box separately in a tiled 32 bpp image.
'''  *   (2) If pixa is defined, it must have the same count as the boxa,
'''  * and it will be a background over with each box is rendered.
'''  * If pixa is not defined, the boxes will be rendered over
'''  * blank images of identical size.
'''  *   (3) See pixaDisplayTiledInRows() for other parameters.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd of tiled images of boxes, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas</param>
''' <param name="pixa"> \param[in]    pixa [optional] background for each box</param>
''' <param name="maxwidth"> \param[in]    maxwidth of output image</param>
''' <param name="linewidth"> \param[in]    linewidth width of box outlines, before scaling</param>
''' <param name="scalefactor"> \param[in]    scalefactor applied to every box; use 1.0 for no scaling</param>
''' <param name="background"> \param[in]    background 0 for white, 1 for black; this is the color</param>
''' <param name="spacing"> \param[in]    spacing  between images, and on outside</param>
''' <param name="border"> \param[in]    border width of black border added to each image;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaDisplayTiled")> _
Friend Shared Function boxaDisplayTiled(boxas as IntPTR, pixa as IntPTR, maxwidth as Integer, linewidth as Integer, scalefactor as single, background as Integer, spacing as Integer, border as Integer) as IntPTR
End Function

#End Region
#Region "SRC\bytearray.c"
' SRC\bytearray.c (74, 16)
' l_byteaExtendArrayToSize()
' l_byteaExtendArrayToSize(L_BYTEA *, size_t) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="ba"> \param[in]    ba</param>
''' <param name="size"> \param[in]    size new size of lba data array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaExtendArrayToSize")> _
Friend Shared Function l_byteaExtendArrayToSize(ba as IntPTR, size as ULong) as Integer
End Function

' SRC\bytearray.c (93, 1)
' l_byteaCreate()
' l_byteaCreate(size_t) as L_BYTEA *
''' <summary>
''' * Notes:
'''  *   (1) The allocated array is n + 1 bytes.  This allows room
'''  * for null termination.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  l_bytea, or NULL on error</returns>
''' <param name="nbytes"> \param[in]    nbytes determines initial size of data array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaCreate")> _
Friend Shared Function l_byteaCreate(nbytes as ULong) as IntPTR
End Function

' SRC\bytearray.c (122, 1)
' l_byteaInitFromMem()
' l_byteaInitFromMem(const l_uint8 *, size_t) as L_BYTEA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  l_bytea, or NULL on error</returns>
''' <param name="data"> \param[in]    data to be copied to the array</param>
''' <param name="size"> \param[in]    size amount of data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaInitFromMem")> _
Friend Shared Function l_byteaInitFromMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\bytearray.c (149, 1)
' l_byteaInitFromFile()
' l_byteaInitFromFile(const char *) as L_BYTEA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  l_bytea, or NULL on error</returns>
''' <param name="fname"> \param[in]    fname</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaInitFromFile")> _
Friend Shared Function l_byteaInitFromFile(fname as String) as IntPTR
End Function

' SRC\bytearray.c (176, 1)
' l_byteaInitFromStream()
' l_byteaInitFromStream(FILE *) as L_BYTEA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  l_bytea, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaInitFromStream")> _
Friend Shared Function l_byteaInitFromStream(fp as Object) as IntPTR
End Function

' SRC\bytearray.c (213, 1)
' l_byteaCopy()
' l_byteaCopy(L_BYTEA *, l_int32) as L_BYTEA *
''' <summary>
''' * Notes:
'''  *   (1) If cloning, up the refcount and return a ptr to %bas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  clone or copy of bas, or NULL on error</returns>
''' <param name="bas"> \param[in]    bas  source lba</param>
''' <param name="copyflag"> \param[in]    copyflag L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaCopy")> _
Friend Shared Function l_byteaCopy(bas as IntPTR, copyflag as Integer) as IntPTR
End Function

' SRC\bytearray.c (245, 1)
' l_byteaDestroy()
' l_byteaDestroy(L_BYTEA **) as void
''' <summary>
''' * Notes:
'''  *   (1) Decrements the ref count and, if 0, destroys the lba.
'''  *   (2) Always nulls the input ptr.
'''  *   (3) If the data has been previously removed, the lba will
'''  * have been nulled, so this will do nothing.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pba"> \param[in,out]   pba will be set to null before returning</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaDestroy")> _
Friend Shared Function l_byteaDestroy(pba as Object) as Boolean ' Org. Void
End Function

' SRC\bytearray.c (281, 1)
' l_byteaGetSize()
' l_byteaGetSize(L_BYTEA *) as size_t
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  size of stored byte array, or 0 on error</returns>
''' <param name="ba"> \param[in]    ba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaGetSize")> _
Friend Shared Function l_byteaGetSize(ba as IntPTR) as ULong
End Function

' SRC\bytearray.c (304, 1)
' l_byteaGetData()
' l_byteaGetData(L_BYTEA *, size_t *) as l_uint8 *
''' <summary>
''' * Notes:
'''  *   (1) The returned ptr is owned by %ba.  Do not free it!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to existing data array, or NULL on error</returns>
''' <param name="ba"> \param[in]    ba</param>
''' <param name="psize"> \param[out]   psize size of data in lba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaGetData")> _
Friend Shared Function l_byteaGetData(ba as IntPTR, psize as ULong) as String
End Function

' SRC\bytearray.c (333, 1)
' l_byteaCopyData()
' l_byteaCopyData(L_BYTEA *, size_t *) as l_uint8 *
''' <summary>
''' * Notes:
'''  *   (1) The returned data is owned by the caller.  The input %ba
'''  * still owns the original data array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  copy of data in use in the data array, or NULL on error.</returns>
''' <param name="ba"> \param[in]    ba</param>
''' <param name="psize"> \param[out]   psize size of data in lba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaCopyData")> _
Friend Shared Function l_byteaCopyData(ba as IntPTR, psize as ULong) as String
End Function

' SRC\bytearray.c (363, 1)
' l_byteaAppendData()
' l_byteaAppendData(L_BYTEA *, const l_uint8 *, size_t) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ba"> \param[in]    ba</param>
''' <param name="newdata"> \param[in]    newdata byte array to be appended</param>
''' <param name="newbytes"> \param[in]    newbytes size of data array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaAppendData")> _
Friend Shared Function l_byteaAppendData(ba as IntPTR, newdata as Byte, newbytes as ULong) as Integer
End Function

' SRC\bytearray.c (396, 1)
' l_byteaAppendString()
' l_byteaAppendString(L_BYTEA *, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ba"> \param[in]    ba</param>
''' <param name="str"> \param[in]    str null-terminated string to be appended</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaAppendString")> _
Friend Shared Function l_byteaAppendString(ba as IntPTR, str as String) as Integer
End Function

' SRC\bytearray.c (465, 1)
' l_byteaJoin()
' l_byteaJoin(L_BYTEA *, L_BYTEA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) It is a no-op, not an error, for %ba2 to be null.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ba1"> \param[in]       ba1</param>
''' <param name="pba2"> \param[in,out]   pba2 data array is added to the one in ba1, and</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaJoin")> _
Friend Shared Function l_byteaJoin(ba1 as IntPTR, pba2 as Object) as Integer
End Function

' SRC\bytearray.c (497, 1)
' l_byteaSplit()
' l_byteaSplit(L_BYTEA *, size_t, L_BYTEA **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ba1"> \param[in]    ba1 lba to split; array bytes nulled beyond the split loc</param>
''' <param name="splitloc"> \param[in]    splitloc location in ba1 to split; ba2 begins there</param>
''' <param name="pba2"> \param[out]   pba2 with data starting at splitloc</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaSplit")> _
Friend Shared Function l_byteaSplit(ba1 as IntPTR, splitloc as ULong, pba2 as Object) as Integer
End Function

' SRC\bytearray.c (540, 1)
' l_byteaFindEachSequence()
' l_byteaFindEachSequence(L_BYTEA *, const l_uint8 *, size_t, L_DNA **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ba"> \param[in]    ba</param>
''' <param name="sequence"> \param[in]    sequence subarray of bytes to find in data</param>
''' <param name="seqlen"> \param[in]    seqlen length of sequence, in bytes</param>
''' <param name="pda"> \param[out]   pda byte positions of each occurrence of %sequence</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaFindEachSequence")> _
Friend Shared Function l_byteaFindEachSequence(ba as IntPTR, sequence as Byte, seqlen as ULong, pda as Object) as Integer
End Function

' SRC\bytearray.c (578, 1)
' l_byteaWrite()
' l_byteaWrite(const char *, L_BYTEA *, size_t, size_t) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fname"> \param[in]    fname output file</param>
''' <param name="ba"> \param[in]    ba</param>
''' <param name="startloc"> \param[in]    startloc first byte to output</param>
''' <param name="endloc"> \param[in]    endloc last byte to output; use 0 to write to the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaWrite")> _
Friend Shared Function l_byteaWrite(fname as String, ba as IntPTR, startloc as ULong, endloc as ULong) as Integer
End Function

' SRC\bytearray.c (612, 1)
' l_byteaWriteStream()
' l_byteaWriteStream(FILE *, L_BYTEA *, size_t, size_t) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream opened for binary write</param>
''' <param name="ba"> \param[in]    ba</param>
''' <param name="startloc"> \param[in]    startloc first byte to output</param>
''' <param name="endloc"> \param[in]    endloc last byte to output; use 0 to write to the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_byteaWriteStream")> _
Friend Shared Function l_byteaWriteStream(fp as Object, ba as IntPTR, startloc as ULong, endloc as ULong) as Integer
End Function

#End Region
#Region "SRC\ccbord.c"
' SRC\ccbord.c (281, 16)
' ccbaExtendArray()
' ccbaExtendArray(CCBORDA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="ccba"> \param[in]    ccba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaExtendArray")> _
Friend Shared Function ccbaExtendArray(ccba as IntPTR) as Integer
End Function

' SRC\ccbord.c (299, 1)
' ccbaCreate()
' ccbaCreate(PIX *, l_int32) as CCBORDA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ccba, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  binary image; can be null</param>
''' <param name="n"> \param[in]    n  initial number of ptrs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaCreate")> _
Friend Shared Function ccbaCreate(pixs as IntPTR, n as Integer) as IntPTR
End Function

' SRC\ccbord.c (332, 1)
' ccbaDestroy()
' ccbaDestroy(CCBORDA **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pccba"> \param[in,out]   pccba  to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaDestroy")> _
Friend Shared Function ccbaDestroy(pccba as Object) as Boolean ' Org. Void
End Function

' SRC\ccbord.c (364, 1)
' ccbCreate()
' ccbCreate(PIX *) as CCBORD *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ccb or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbCreate")> _
Friend Shared Function ccbCreate(pixs as IntPTR) as IntPTR
End Function

' SRC\ccbord.c (404, 1)
' ccbDestroy()
' ccbDestroy(CCBORD **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pccb"> \param[in,out]   pccb to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbDestroy")> _
Friend Shared Function ccbDestroy(pccb as Object) as Boolean ' Org. Void
End Function

' SRC\ccbord.c (454, 1)
' ccbaAddCcb()
' ccbaAddCcb(CCBORDA *, CCBORD *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="ccba"> \param[in]    ccba</param>
''' <param name="ccb"> \param[in]    ccb to be added by insertion</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaAddCcb")> _
Friend Shared Function ccbaAddCcb(ccba as IntPTR, ccb as IntPTR) as Integer
End Function

' SRC\ccbord.c (510, 1)
' ccbaGetCount()
' ccbaGetCount(CCBORDA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, with 0 on error</returns>
''' <param name="ccba"> \param[in]    ccba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaGetCount")> _
Friend Shared Function ccbaGetCount(ccba as IntPTR) as Integer
End Function

' SRC\ccbord.c (535, 1)
' ccbaGetCcb()
' ccbaGetCcb(CCBORDA *, l_int32) as CCBORD *
''' <summary>
''' * Notes:
'''  *   (1) This returns a clone of the ccb; it must be destroyed
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ccb, or NULL on error</returns>
''' <param name="ccba"> \param[in]    ccba</param>
''' <param name="index"> \param[in]    index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaGetCcb")> _
Friend Shared Function ccbaGetCcb(ccba as IntPTR, index as Integer) as IntPTR
End Function

' SRC\ccbord.c (564, 1)
' pixGetAllCCBorders()
' pixGetAllCCBorders(PIX *) as CCBORDA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ccborda, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetAllCCBorders")> _
Friend Shared Function pixGetAllCCBorders(pixs as IntPTR) as IntPTR
End Function

' SRC\ccbord.c (650, 1)
' pixGetCCBorders()
' pixGetCCBorders(PIX *, BOX *) as CCBORD *
''' <summary>
''' * Notes:
'''  *   (1) We are finding the exterior and interior borders
'''  * of an 8-connected component.   This should be used
'''  * on a pix that has exactly one 8-connected component.
'''  *   (2) Typically, pixs is a c.c. in some larger pix.  The
'''  * input box gives its location in global coordinates.
'''  * This box is saved, as well as the boxes for the
'''  * borders of any holes within the c.c., but the latter
'''  * are given in relative coords within the c.c.
'''  *   (3) The calculations for the exterior border are done
'''  * on a pix with a 1-pixel
'''  * added border, but the saved pixel coordinates
'''  * are the correct (relative) ones for the input pix
'''  * (without a 1-pixel border)
'''  *   (4) For the definition of the three tables -- xpostab[], ypostab[]
'''  * and qpostab[] -- see above where they are defined.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ccbord, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, one 8-connected component</param>
''' <param name="box"> \param[in]    box  xul, yul, width, height in global coords</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetCCBorders")> _
Friend Shared Function pixGetCCBorders(pixs as IntPTR, box as IntPTR) as IntPTR
End Function

' SRC\ccbord.c (761, 1)
' pixGetOuterBordersPtaa()
' pixGetOuterBordersPtaa(PIX *) as PTAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptaa of outer borders, in global coords, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetOuterBordersPtaa")> _
Friend Shared Function pixGetOuterBordersPtaa(pixs as IntPTR) as IntPTR
End Function

' SRC\ccbord.c (821, 1)
' pixGetOuterBorderPta()
' pixGetOuterBorderPta(PIX *, BOX *) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) We are finding the exterior border of a single 8-connected
'''  * component.
'''  *   (2) If box is NULL, the outline returned is in the local coords
'''  * of the input pix.  Otherwise, box is assumed to give the
'''  * location of the pix in global coordinates, and the returned
'''  * pta will be in those global coordinates.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta of outer border, in global coords, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, one 8-connected component</param>
''' <param name="box"> \param[in]    box  [optional] of pixs, in global coordinates</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetOuterBorderPta")> _
Friend Shared Function pixGetOuterBorderPta(pixs as IntPTR, box as IntPTR) as IntPTR
End Function

' SRC\ccbord.c (894, 1)
' pixGetOuterBorder()
' pixGetOuterBorder(CCBORD *, PIX *, BOX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) the border is saved in relative coordinates within
'''  * the c.c. (pixs).  Because the calculation is done
'''  * in pixb with added 1 pixel border, we must subtract
'''  * 1 from each pixel value before storing it.
'''  *   (2) the stopping condition is that after the first pixel is
'''  * returned to, the next pixel is the second pixel.  Having
'''  * these 2 pixels recur in sequence proves the path is closed,
'''  * and we do not store the second pixel again.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ccb"> \param[in]    ccb  unfilled</param>
''' <param name="pixs"> \param[in]    pixs for the component at hand</param>
''' <param name="box"> \param[in]    box  for the component, in global coords</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetOuterBorder")> _
Friend Shared Function pixGetOuterBorder(ccb as IntPTR, pixs as IntPTR, box as IntPTR) as Integer
End Function

' SRC\ccbord.c (982, 1)
' pixGetHoleBorder()
' pixGetHoleBorder(CCBORD *, PIX *, BOX *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) we trace out hole border on pixs without addition
'''  * of single pixel added border to pixs
'''  *   (2) therefore all coordinates are relative within the c.c. (pixs)
'''  *   (3) same position tables and stopping condition as for
'''  * exterior borders
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ccb"> \param[in]    ccb  the exterior border is already made</param>
''' <param name="pixs"> \param[in]    pixs for the connected component at hand</param>
''' <param name="box"> \param[in]    box  for the specific hole border, in relative</param>
''' <param name="xs"> \param[in]    xs, ys   first pixel on hole border, relative to c.c.</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetHoleBorder")> _
Friend Shared Function pixGetHoleBorder(ccb as IntPTR, pixs as IntPTR, box as IntPTR, xs as Integer, ys as Integer) as Integer
End Function

' SRC\ccbord.c (1064, 1)
' findNextBorderPixel()
' findNextBorderPixel(l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) qpos increases clockwise from 0 to 7, with 0 at
'''  * location with Q to left of P:   Q P
'''  *   (2) this is a low-level function that does not check input
'''  * parameters.  All calling functions should check them.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if next pixel found; 1 otherwise</returns>
''' <param name="w"> \param[in]       w, h, data, wpl</param>
''' <param name="h"> \param[in]       px, py      current P</param>
''' <param name="data"> \param[in,out]   pqpos       input current Q; new Q</param>
''' <param name="wpl"> \param[out]      pnpx, pnpy  new P</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="findNextBorderPixel")> _
Friend Shared Function findNextBorderPixel(w as Integer, h as Integer, data as UInteger, wpl as Integer, px as Integer, py as Integer, pqpos as Integer, pnpx as Integer, pnpy as Integer) as Integer
End Function

' SRC\ccbord.c (1115, 1)
' locateOutsideSeedPixel()
' locateOutsideSeedPixel(l_int32, l_int32, l_int32, l_int32, l_int32 *, l_int32 *) as void
''' <summary>
''' * Notes:
'''  *   (1) the first and second pixels must be 8-adjacent,
'''  * so |dx| = 1 and |dy| = 1 and both dx and dy
'''  * cannot be 0.  There are 8 possible cases.
'''  *   (2) the seed pixel is OUTSIDE the foreground of the c.c.
'''  *   (3) these rules are for the situation where the INSIDE
'''  * of the c.c. is on the right as you follow the border:
'''  * cw for an exterior border and ccw for a hole border.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="fpx"> \param[in]   fpx, fpy    location of first pixel</param>
''' <param name="fpy"> \param[in]   spx, spy    location of second pixel</param>
''' <param name="spx"> \param[out]  pxs, pys    seed pixel to be returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="locateOutsideSeedPixel")> _
Friend Shared Function locateOutsideSeedPixel(fpx as Integer, fpy as Integer, spx as Integer, spy as Integer, pxs as Integer, pys as Integer) as Boolean ' Org. Void
End Function

' SRC\ccbord.c (1160, 1)
' ccbaGenerateGlobalLocs()
' ccbaGenerateGlobalLocs(CCBORDA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ccba"> \param[in]    ccba with local chain ptaa of borders computed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaGenerateGlobalLocs")> _
Friend Shared Function ccbaGenerateGlobalLocs(ccba as IntPTR) as Integer
End Function

' SRC\ccbord.c (1231, 1)
' ccbaGenerateStepChains()
' ccbaGenerateStepChains(CCBORDA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This uses the pixel locs in the local ptaa,
'''  * which are all relative to each c.c., to find
'''  * the step directions for successive pixels in
'''  * the chain, and stores them in the step numaa.
'''  *   (2) To get the step direction, use
'''  *  1   2   3
'''  *  0   P   4
'''  *  7   6   5
'''  * where P is the previous pixel at (px, py).  The step direction
'''  * is the number (from 0 through 7) for each relative location
'''  * of the current pixel at (cx, cy).  It is easily found by
'''  * indexing into a 2-d 3x3 array (dirtab).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ccba"> \param[in]    ccba with local chain ptaa of borders computed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaGenerateStepChains")> _
Friend Shared Function ccbaGenerateStepChains(ccba as IntPTR) as Integer
End Function

' SRC\ccbord.c (1305, 1)
' ccbaStepChainsToPixCoords()
' ccbaStepChainsToPixCoords(CCBORDA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This uses the step chain data in each ccb to determine
'''  * the pixel locations, either global or local,
'''  * and stores them in the appropriate ptaa,
'''  * either global or local.  For the latter, the
'''  * pixel locations are relative to the c.c.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ccba"> \param[in]    ccba with step chains numaa of borders</param>
''' <param name="coordtype"> \param[in]    coordtype  CCB_GLOBAL_COORDS or CCB_LOCAL_COORDS</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaStepChainsToPixCoords")> _
Friend Shared Function ccbaStepChainsToPixCoords(ccba as IntPTR, coordtype as Integer) as Integer
End Function

' SRC\ccbord.c (1405, 1)
' ccbaGenerateSPGlobalLocs()
' ccbaGenerateSPGlobalLocs(CCBORDA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This calculates the splocal rep if not yet made.
'''  *   (2) It uses the local pixel values in splocal, the single
'''  * path pta, which are all relative to each c.c., to find
'''  * the corresponding global pixel locations, and stores
'''  * them in the spglobal pta.
'''  *   (3) This lists only the turning points: it both makes a
'''  * valid svg file and is typically about half the size
'''  * when all border points are listed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ccba"> \param[in]    ccba</param>
''' <param name="ptsflag"> \param[in]    ptsflag  CCB_SAVE_ALL_PTS or CCB_SAVE_TURNING_PTS</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaGenerateSPGlobalLocs")> _
Friend Shared Function ccbaGenerateSPGlobalLocs(ccba as IntPTR, ptsflag as Integer) as Integer
End Function

' SRC\ccbord.c (1522, 1)
' ccbaGenerateSinglePath()
' ccbaGenerateSinglePath(CCBORDA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Generates a single border in local pixel coordinates.
'''  * For each c.c., if there is just an outer border, copy it.
'''  * If there are also hole borders, for each hole border,
'''  * determine the smallest horizontal or vertical
'''  * distance from the border to the outside of the c.c.,
'''  * and find a path through the c.c. for this cut.
'''  * We do this in a way that guarantees a pixel from the
'''  * hole border is the starting point of the path, and
'''  * we must verify that the path intersects the outer
'''  * border (if it intersects it, then it ends on it).
'''  * One can imagine pathological cases, but they may not
'''  * occur in images of text characters and un-textured
'''  * line graphics.
'''  *   (2) Once it is verified that the path through the c.c.
'''  * intersects both the hole and outer borders, we
'''  * generate the full single path for all borders in the
'''  * c.c.  Starting at the start point on the outer
'''  * border, when we hit a line on a cut, we take
'''  * the cut, do the hold border, and return on the cut
'''  * to the outer border.  We compose a pta of the
'''  * outer border pts that are on cut paths, and for
'''  * every point on the outer border (as we go around),
'''  * we check against this pta.  When we find a matching
'''  * point in the pta, we do its cut path and hole border.
'''  * The single path is saved in the ccb.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ccba"> \param[in]    ccba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaGenerateSinglePath")> _
Friend Shared Function ccbaGenerateSinglePath(ccba as IntPTR) as Integer
End Function

' SRC\ccbord.c (1680, 1)
' getCutPathForHole()
' getCutPathForHole(PIX *, PTA *, BOX *, l_int32 *, l_int32 *) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) If we don't find a path, we return a pta with no pts
'''  * in it and len = 0.
'''  *   (2) The goal is to get a reasonably short path between the
'''  * inner and outer borders, that goes entirely within the fg of
'''  * the pix.  This function is cheap-and-dirty, may fail for some
'''  * holes in complex topologies such as those you might find in a
'''  * moderately dark scanned halftone.  If it fails to find a
'''  * path to any particular hole, it gives a warning, and because
'''  * that hole path is not included, the hole will not be rendered.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta of pts on cut path from the hole border</returns>
''' <param name="pix"> \param[in]    pix  of c.c.</param>
''' <param name="pta"> \param[in]    pta  of outer border</param>
''' <param name="boxinner"> \param[in]    boxinner b.b. of hole path</param>
''' <param name="pdir"> \param[out]   pdir  direction (0-3), returned; only needed for debug</param>
''' <param name="plen"> \param[out]   plen  length of path, returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getCutPathForHole")> _
Friend Shared Function getCutPathForHole(pix as IntPTR, pta as IntPTR, boxinner as IntPTR, pdir as Integer, plen as Integer) as IntPTR
End Function

' SRC\ccbord.c (1828, 1)
' ccbaDisplayBorder()
' ccbaDisplayBorder(CCBORDA *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Uses global ptaa, which gives each border pixel in
'''  * global coordinates, and must be computed in advance
'''  * by calling ccbaGenerateGlobalLocs().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix of border pixels, or NULL on error</returns>
''' <param name="ccba"> \param[in]    ccba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaDisplayBorder")> _
Friend Shared Function ccbaDisplayBorder(ccba as IntPTR) as IntPTR
End Function

' SRC\ccbord.c (1881, 1)
' ccbaDisplaySPBorder()
' ccbaDisplaySPBorder(CCBORDA *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Uses spglobal pta, which gives each border pixel in
'''  * global coordinates, one path per c.c., and must
'''  * be computed in advance by calling ccbaGenerateSPGlobalLocs().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix of border pixels, or NULL on error</returns>
''' <param name="ccba"> \param[in]    ccba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaDisplaySPBorder")> _
Friend Shared Function ccbaDisplaySPBorder(ccba as IntPTR) as IntPTR
End Function

' SRC\ccbord.c (1971, 1)
' ccbaDisplayImage1()
' ccbaDisplayImage1(CCBORDA *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Uses local ptaa, which gives each border pixel in
'''  * local coordinates, so the actual pixel positions must
'''  * be computed using all offsets.
'''  *   (2) For the holes, use coordinates relative to the c.c.
'''  *   (3) This is slower than Method 2.
'''  *   (4) This uses topological properties (Method 1) to do scan
'''  * conversion to raster
'''  *
'''  *  This algorithm deserves some commentary.
'''  *
'''  *  I first tried the following:
'''  * ~ outer borders: 4-fill from outside, stopping at the
'''  *   border, using pixFillClosedBorders()
'''  * ~ inner borders: 4-fill from outside, stopping again
'''  *   at the border, XOR with the border, and invert
'''  *   to get the hole.  This did not work, because if
'''  *   you have a hole border that looks like:
'''  *
'''  * x x x x x x
'''  * x x
'''  * x   x x x   x
'''  *   x x o x   x
'''  *    x  x
'''  *    x  x
'''  *   x x x
'''  *
'''  *   if you 4-fill from the outside, the pixel 'o' will
'''  *   not be filled!  XORing with the border leaves it OFF.
'''  *   Inverting then gives a single bad ON pixel that is not
'''  *   actually part of the hole.
'''  *
'''  *  So what you must do instead is 4-fill the holes from inside.
'''  *  You can do this from a seedfill, using a pix with the hole
'''  *  border as the filling mask.  But you need to start with a
'''  *  pixel inside the hole.  How is this determined?  The best
'''  *  way is from the contour.  We have a right-hand shoulder
'''  *  rule for inside (i.e., the filled region).   Take the
'''  *  first 2 pixels of the hole border, and compute dx and dy
'''  *  (second coord minus first coord:  dx = sx - fx, dy = sy - fy).
'''  *  There are 8 possibilities, depending on the values of dx and
'''  *  dy (which can each be -1, 0, and +1, but not both 0).
'''  *  These 8 cases can be broken into 4; see the simple algorithm below.
'''  *  Once you have an interior seed pixel, you fill from the seed,
'''  *  clipping with the hole border pix by filling into its invert.
'''  *
'''  *  You then successively XOR these interior filled components, in any order.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix of image, or NULL on error</returns>
''' <param name="ccba"> \param[in]    ccba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaDisplayImage1")> _
Friend Shared Function ccbaDisplayImage1(ccba as IntPTR) as IntPTR
End Function

' SRC\ccbord.c (2097, 1)
' ccbaDisplayImage2()
' ccbaDisplayImage2(CCBORDA *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Uses local chain ptaa, which gives each border pixel in
'''  * local coordinates, so the actual pixel positions must
'''  * be computed using all offsets.
'''  *   (2) Treats exterior and hole borders on equivalent
'''  * footing, and does all calculations on a pix
'''  * that spans the c.c. with a 1 pixel added boundary.
'''  *   (3) This uses topological properties (Method 2) to do scan
'''  * conversion to raster
'''  *   (4) The algorithm is described at the top of this file (Method 2).
'''  * It is preferred to Method 1 because it is between 1.2x and 2x
'''  * faster than Method 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix of image, or NULL on error</returns>
''' <param name="ccba"> \param[in]   ccba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaDisplayImage2")> _
Friend Shared Function ccbaDisplayImage2(ccba as IntPTR) as IntPTR
End Function

' SRC\ccbord.c (2195, 1)
' ccbaWrite()
' ccbaWrite(const char *, CCBORDA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="ccba"> \param[in]    ccba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaWrite")> _
Friend Shared Function ccbaWrite(filename as String, ccba as IntPTR) as Integer
End Function

' SRC\ccbord.c (2247, 1)
' ccbaWriteStream()
' ccbaWriteStream(FILE *, CCBORDA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="ccba"> \param[in]    ccba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaWriteStream")> _
Friend Shared Function ccbaWriteStream(fp as Object, ccba as IntPTR) as Integer
End Function

' SRC\ccbord.c (2348, 1)
' ccbaRead()
' ccbaRead(const char *) as CCBORDA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ccba, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaRead")> _
Friend Shared Function ccbaRead(filename as String) as IntPTR
End Function

' SRC\ccbord.c (2394, 1)
' ccbaReadStream()
' ccbaReadStream(FILE *) as CCBORDA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return   ccba, or NULL on error</returns>
''' <param name="fp"> \param[in]     fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaReadStream")> _
Friend Shared Function ccbaReadStream(fp as Object) as IntPTR
End Function

' SRC\ccbord.c (2515, 1)
' ccbaWriteSVG()
' ccbaWriteSVG(const char *, CCBORDA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="ccba"> \param[in]    ccba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaWriteSVG")> _
Friend Shared Function ccbaWriteSVG(filename as String, ccba as IntPTR) as Integer
End Function

' SRC\ccbord.c (2546, 1)
' ccbaWriteSVGString()
' ccbaWriteSVGString(const char *, CCBORDA *) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  string in svg-formatted, that can be written to file,</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="ccba"> \param[in]    ccba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ccbaWriteSVGString")> _
Friend Shared Function ccbaWriteSVGString(filename as String, ccba as IntPTR) as String
End Function

#End Region
#Region "SRC\ccthin.c"
' SRC\ccthin.c (68, 1)
' pixaThinConnected()
' pixaThinConnected(PIXA *, l_int32, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) See notes in pixThinConnected().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixds, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas  of 1 bpp pix</param>
''' <param name="type"> \param[in]    type L_THIN_FG, L_THIN_BG</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
''' <param name="maxiters"> \param[in]    maxiters max number of iters allowed; use 0 to iterate</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaThinConnected")> _
Friend Shared Function pixaThinConnected(pixas as IntPTR, type as Integer, connectivity as Integer, maxiters as Integer) as IntPTR
End Function

' SRC\ccthin.c (158, 1)
' pixThinConnected()
' pixThinConnected(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See "Connectivity-preserving morphological image transformations,"
'''  * Dan S. Bloomberg, in SPIE Visual Communications and Image
'''  * Processing, Conference 1606, pp. 320-334, November 1991,
'''  * Boston, MA.   A web version is available at
'''  *  http://www.leptonica.com/papers/conn.pdf
'''  *   (2) This is a simple interface for two of the best iterative
'''  * morphological thinning algorithms, for 4-c.c and 8-c.c.
'''  * Each iteration uses a mixture of parallel operations
'''  * (using several different 3x3 Sels) and serial operations.
'''  * Specifically, each thinning iteration consists of
'''  * four sequential thinnings from each of four directions.
'''  * Each of these thinnings is a parallel composite
'''  * operation, where the union of a set of HMTs are set
'''  * subtracted from the input.  For 4-cc thinning, we
'''  * use 3 HMTs in parallel, and for 8-cc thinning we use 4 HMTs.
'''  *   (3) A "good" thinning algorithm is one that generates a skeleton
'''  * that is near the medial axis and has neither pruned
'''  * real branches nor left extra dendritic branches.
'''  *   (4) Duality between operations on fg and bg require switching
'''  * the connectivity.  To thin the foreground, which is the usual
'''  * situation, use type == L_THIN_FG.  Thickening the foreground
'''  * is equivalent to thinning the background (type == L_THIN_BG),
'''  * where the alternate connectivity gets preserved.
'''  * For example, to thicken the fg with 2 rounds of iterations
'''  * using 4-c.c., thin the bg using Sels that preserve 8-connectivity:
'''  * Pix *pix = pixThinConnected(pixs, L_THIN_BG, 8, 2);
'''  *   (5) This makes and destroys the sela set each time. It's not a large
'''  * overhead, but if you are calling this thousands of times on
'''  * very small images, you can avoid the overhead; e.g.
'''  * Sela *sela = selaMakeThinSets(1, 0);  // for 4-c.c.
'''  * Pix *pix = pixThinConnectedBySet(pixs, L_THIN_FG, sela, 0);
'''  * using set 1 for 4-c.c. and set 5 for 8-c.c operations.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="type"> \param[in]    type L_THIN_FG, L_THIN_BG</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
''' <param name="maxiters"> \param[in]    maxiters max number of iters allowed; use 0 to iterate</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixThinConnected")> _
Friend Shared Function pixThinConnected(pixs as IntPTR, type as Integer, connectivity as Integer, maxiters as Integer) as IntPTR
End Function

' SRC\ccthin.c (220, 1)
' pixThinConnectedBySet()
' pixThinConnectedBySet(PIX *, l_int32, SELA *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See notes in pixThinConnected().
'''  *   (2) This takes a sela representing one of 11 sets of HMT Sels.
'''  * The HMTs from this set are run in parallel and the result
'''  * is OR'd before being subtracted from the source.  For each
'''  * iteration, this "parallel" thin is performed four times
'''  * sequentially, for sels rotated by 90 degrees in all four
'''  * directions.
'''  *   (3) The "parallel" and "sequential" nomenclature is standard
'''  * in digital filtering.  Here, "parallel" operations work on the
'''  * same source (pixd), and accumulate the results in a temp
'''  * image before actually applying them to the source (in this
'''  * case, using an in-place subtraction).  "Sequential" operations
'''  * operate directly on the source (pixd) to produce the result
'''  * (in this case, with four sequential thinning operations, one
'''  * from each of four directions).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="type"> \param[in]    type L_THIN_FG, L_THIN_BG</param>
''' <param name="sela"> \param[in]    sela of Sels for parallel composite HMTs</param>
''' <param name="maxiters"> \param[in]    maxiters max number of iters allowed; use 0 to iterate</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixThinConnectedBySet")> _
Friend Shared Function pixThinConnectedBySet(pixs as IntPTR, type as Integer, sela as IntPTR, maxiters as Integer) as IntPTR
End Function

' SRC\ccthin.c (341, 1)
' selaMakeThinSets()
' selaMakeThinSets(l_int32, l_int32) as SELA *
''' <summary>
''' * Notes:
'''  *   (1) These are specific sets of HMTs to be used in parallel for
'''  * for thinning from each of four directions.
'''  *   (2) The sets are indexed as follows:
'''  * For thinning (e.g., run to completion):
'''  *  index = 1  sel_4_1, sel_4_2, sel_4_3
'''  *  index = 2  sel_4_1, sel_4_5, sel_4_6
'''  *  index = 3  sel_4_1, sel_4_7, sel_4_7_rot
'''  *  index = 4  sel_48_1, sel_48_1_rot, sel_48_2
'''  *  index = 5  sel_8_2, sel_8_3, sel_8_5, sel_8_6
'''  *  index = 6  sel_8_2, sel_8_3, sel_48_2
'''  *  index = 7  sel_8_1, sel_8_5, sel_8_6
'''  *  index = 8  sel_8_2, sel_8_3, sel_8_8, sel_8_9
'''  *  index = 9  sel_8_5, sel_8_6, sel_8_7, sel_8_7_rot
'''  * For thickening (e.g., just a few iterations):
'''  *  index = 10 sel_4_2, sel_4_3
'''  *  index = 11 sel_8_4
'''  *   (3) For a very smooth skeleton, use set 1 for 4 connected and
'''  * set 5 for 8 connected thins.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela, or NULL on error</returns>
''' <param name="index"> \param[in]    index  into specific sets</param>
''' <param name="debug"> \param[in]    debug  1 to output display of sela</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaMakeThinSets")> _
Friend Shared Function selaMakeThinSets(index as Integer, debug as Integer) as IntPTR
End Function

#End Region
#Region "SRC\classapp.c"
' SRC\classapp.c (60, 16)
' 
' testLineAlignmentX(NUMA *, NUMA *, l_int32, l_int32, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="testLineAlignmentX")> _
Friend Shared Function testLineAlignmentX(na1 as IntPTR, na2 as IntPTR, shiftx as Integer, delx as Integer, nperline as Integer) as Integer
End Function

' SRC\classapp.c (62, 16)
' 
' countAlignedMatches(NUMA *, NUMA *, NUMA *, NUMA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32 *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="countAlignedMatches")> _
Friend Shared Function countAlignedMatches(nai1 as IntPTR, nai2 as IntPTR, nasx as IntPTR, nasy as IntPTR, n1 as Integer, n2 as Integer, delx as Integer, dely as Integer, nreq as Integer, psame as Integer, debugflag as Integer) as Integer
End Function

' SRC\classapp.c (67, 13)
' 
' printRowIndices(l_int32 *, l_int32, l_int32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="printRowIndices")> _
Friend Shared Function printRowIndices(index1 as Integer, n1 as Integer, index2 as Integer, n2 as Integer) as Boolean ' Org. Void
End Function

' SRC\classapp.c (96, 1)
' jbCorrelation()
' jbCorrelation(const char *, l_float32, l_float32, l_int32, const char *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The images must be 1 bpp.  If they are not, you can convert
'''  * them using convertFilesTo1bpp().
'''  *   (2) See prog/jbcorrelation for generating more output (e.g.,
'''  * for debugging)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dirin"> \param[in]    dirin directory of input images</param>
''' <param name="thresh"> \param[in]    thresh typically ~0.8</param>
''' <param name="weight"> \param[in]    weight typically ~0.6</param>
''' <param name="components"> \param[in]    components JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
''' <param name="rootname"> \param[in]    rootname for output files</param>
''' <param name="firstpage"> \param[in]    firstpage 0-based</param>
''' <param name="npages"> \param[in]    npages use 0 for all pages in dirin</param>
''' <param name="renderflag"> \param[in]    renderflag 1 to render from templates; 0 to skip</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbCorrelation")> _
Friend Shared Function jbCorrelation(dirin as String, thresh as single, weight as single, components as Integer, rootname as String, firstpage as Integer, npages as Integer, renderflag as Integer) as Integer
End Function

' SRC\classapp.c (178, 1)
' jbRankHaus()
' jbRankHaus(const char *, l_int32, l_float32, l_int32, const char *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See prog/jbrankhaus for generating more output (e.g.,
'''  * for debugging)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dirin"> \param[in]    dirin directory of input images</param>
''' <param name="size"> \param[in]    size of Sel used for dilation; typ. 2</param>
''' <param name="rank"> \param[in]    rank rank value of match; typ. 0.97</param>
''' <param name="components"> \param[in]    components JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
''' <param name="rootname"> \param[in]    rootname for output files</param>
''' <param name="firstpage"> \param[in]    firstpage 0-based</param>
''' <param name="npages"> \param[in]    npages use 0 for all pages in dirin</param>
''' <param name="renderflag"> \param[in]    renderflag 1 to render from templates; 0 to skip</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbRankHaus")> _
Friend Shared Function jbRankHaus(dirin as String, size as Integer, rank as single, components as Integer, rootname as String, firstpage as Integer, npages as Integer, renderflag as Integer) as Integer
End Function

' SRC\classapp.c (266, 1)
' jbWordsInTextlines()
' jbWordsInTextlines(const char *, l_int32, l_int32, l_int32, l_float32, l_float32, NUMA **, l_int32, l_int32) as JBCLASSER *
''' <summary>
''' * Notes:
'''  *   (1) This is a high-level function.  See prog/jbwords for example
'''  * of usage.
'''  *   (2) Typically, use input of 75 - 150 ppi for finding words.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  classer for the set of pages</returns>
''' <param name="dirin"> \param[in]    dirin directory of input pages</param>
''' <param name="reduction"> \param[in]    reduction 1 for full res; 2 for half-res</param>
''' <param name="maxwidth"> \param[in]    maxwidth of word mask components, to be kept</param>
''' <param name="maxheight"> \param[in]    maxheight of word mask components, to be kept</param>
''' <param name="thresh"> \param[in]    thresh on correlation; 0.80 is reasonable</param>
''' <param name="weight"> \param[in]    weight for handling thick text; 0.6 is reasonable</param>
''' <param name="pnatl"> \param[out]   pnatl numa with textline index for each component</param>
''' <param name="firstpage"> \param[in]    firstpage 0-based</param>
''' <param name="npages"> \param[in]    npages use 0 for all pages in dirin</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbWordsInTextlines")> _
Friend Shared Function jbWordsInTextlines(dirin as String, reduction as Integer, maxwidth as Integer, maxheight as Integer, thresh as single, weight as single, pnatl as Object, firstpage as Integer, npages as Integer) as IntPTR
End Function

' SRC\classapp.c (378, 1)
' pixGetWordsInTextlines()
' pixGetWordsInTextlines(PIX *, l_int32, l_int32, l_int32, l_int32, BOXA **, PIXA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The input should be at a resolution of between 75 and 150 ppi.
'''  *   (2) The four size constraints on saved components are all
'''  * scaled by %reduction.
'''  *   (3) The result are word images (and their b.b.), extracted in
'''  * textline order, at either full res or 2x reduction,
'''  * and with a numa giving the textline index for each word.
'''  *   (4) The pixa and boxa interfaces should make this type of
'''  * application simple to put together.  The steps are:
'''  *  ~ generate first estimate of word masks
'''  *  ~ get b.b. of these, and remove the small and big ones
'''  *  ~ extract pixa of the word images, using the b.b.
'''  *  ~ sort actual word images in textline order (2d)
'''  *  ~ flatten them to a pixa (1d), saving the textline index
'''  * for each pix
'''  *   (5) In an actual application, it may be desirable to pre-filter
'''  * the input image to remove large components, to extract
'''  * single columns of text, and to deskew them.  For example,
'''  * to remove both large components and small noisy components
'''  * that can interfere with the statistics used to estimate
'''  * parameters for segmenting by words, but still retain text lines,
'''  * the following image preprocessing can be done:
'''  * Pix *pixt = pixMorphSequence(pixs, "c40.1", 0);
'''  * Pix *pixf = pixSelectBySize(pixt, 0, 60, 8,
'''  *    L_SELECT_HEIGHT, L_SELECT_IF_LT, NULL);
'''  * pixAnd(pixf, pixf, pixs);  // the filtered image
'''  * The closing turns text lines into long blobs, but does not
'''  * significantly increase their height.  But if there are many
'''  * small connected components in a dense texture, this is likely
'''  * to generate tall components that will be eliminated in pixf.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, typ. 75 - 150 ppi</param>
''' <param name="minwidth"> \param[in]    minwidth, minheight of saved components; smaller are discarded</param>
''' <param name="minheight"> \param[in]    maxwidth, maxheight of saved components; larger are discarded</param>
''' <param name="maxwidth"> \param[out]   pboxad word boxes sorted in textline line order</param>
''' <param name="maxheight"> \param[out]   ppixad word images sorted in textline line order</param>
''' <param name="pboxad"> \param[out]   pnai index of textline for each word</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetWordsInTextlines")> _
Friend Shared Function pixGetWordsInTextlines(pixs as IntPTR, minwidth as Integer, minheight as Integer, maxwidth as Integer, maxheight as Integer, pboxad as Object, ppixad as Object, pnai as Object) as Integer
End Function

' SRC\classapp.c (453, 1)
' pixGetWordBoxesInTextlines()
' pixGetWordBoxesInTextlines(PIX *, l_int32, l_int32, l_int32, l_int32, BOXA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The input should be at a resolution of between 75 and 150 ppi.
'''  *   (2) This is a special version of pixGetWordsInTextlines(), that
'''  * just finds the word boxes in line order, with a numa
'''  * giving the textline index for each word.
'''  * See pixGetWordsInTextlines() for more details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, typ. 300 ppi</param>
''' <param name="minwidth"> \param[in]    minwidth, minheight of saved components; smaller are discarded</param>
''' <param name="minheight"> \param[in]    maxwidth, maxheight of saved components; larger are discarded</param>
''' <param name="maxwidth"> \param[out]   pboxad word boxes sorted in textline line order</param>
''' <param name="maxheight"> \param[out]   pnai [optional] index of textline for each word</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetWordBoxesInTextlines")> _
Friend Shared Function pixGetWordBoxesInTextlines(pixs as IntPTR, minwidth as Integer, minheight as Integer, maxwidth as Integer, maxheight as Integer, pboxad as Object, pnai as Object) as Integer
End Function

' SRC\classapp.c (515, 1)
' boxaExtractSortedPattern()
' boxaExtractSortedPattern(BOXA *, NUMA *) as NUMAA *
''' <summary>
''' * Notes:
'''  *   (1) The input is expected to come from pixGetWordBoxesInTextlines().
'''  *   (2) Each numa in the output consists of an average y coordinate
'''  * of the first box in the textline, followed by pairs of
'''  * x coordinates representing the left and right edges of each
'''  * of the boxes in the textline.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  naa NUMAA, where each numa represents one textline,</returns>
''' <param name="boxa"> \param[in]    boxa typ. of word bounding boxes, in textline order</param>
''' <param name="na"> \param[in]    na   index of textline for each box in boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaExtractSortedPattern")> _
Friend Shared Function boxaExtractSortedPattern(boxa as IntPTR, na as IntPTR) as IntPTR
End Function

' SRC\classapp.c (603, 1)
' numaaCompareImagesByBoxes()
' numaaCompareImagesByBoxes(NUMAA *, NUMAA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32 *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Each input numaa describes a set of sorted bounding boxes
'''  * (sorted by textline and, within each textline, from
'''  * left to right) in the images from which they are derived.
'''  * See boxaExtractSortedPattern() for a description of the data
'''  * format in each of the input numaa.
'''  *   (2) This function does an alignment between the input
'''  * descriptions of bounding boxes for two images. The
'''  * input parameter %nperline specifies the number of boxes
'''  * to consider in each line when testing for a match, and
'''  * %nreq is the required number of lines that must be well-aligned
'''  * to get a match.
'''  *   (3) Testing by alignment has 3 steps:
'''  * (a) Generating the location of word bounding boxes from the
'''  *  images (prior to calling this function).
'''  * (b) Listing all possible pairs of aligned rows, based on
'''  *  tolerances in horizontal and vertical positions of
'''  *  the boxes.  Specifically, all pairs of rows are enumerated
'''  *  whose first %nperline boxes can be brought into close
'''  *  alignment, based on the delx parameter for boxes in the
'''  *  line and within the overall the %maxshiftx and %maxshifty
'''  *  constraints.
'''  * (c) Each pair, starting with the first, is used to search
'''  *  for a set of %nreq - 1 other pairs that can all be aligned
'''  *  with a difference in global translation of not more
'''  *  than (%delx, %dely).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="naa1"> \param[in]    naa1 for image 1, formatted by boxaExtractSortedPattern()</param>
''' <param name="naa2"> \param[in]    naa2 ditto; for image 2</param>
''' <param name="nperline"> \param[in]    nperline number of box regions to be used in each textline</param>
''' <param name="nreq"> \param[in]    nreq number of complete row matches required</param>
''' <param name="maxshiftx"> \param[in]    maxshiftx max allowed x shift between two patterns, in pixels</param>
''' <param name="maxshifty"> \param[in]    maxshifty max allowed y shift between two patterns, in pixels</param>
''' <param name="delx"> \param[in]    delx max allowed difference in x data, after alignment</param>
''' <param name="dely"> \param[in]    dely max allowed difference in y data, after alignment</param>
''' <param name="psame"> \param[out]   psame 1 if %nreq row matches are found; 0 otherwise</param>
''' <param name="debugflag"> \param[in]    debugflag 1 for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaCompareImagesByBoxes")> _
Friend Shared Function numaaCompareImagesByBoxes(naa1 as IntPTR, naa2 as IntPTR, nperline as Integer, nreq as Integer, maxshiftx as Integer, maxshifty as Integer, delx as Integer, dely as Integer, psame as Integer, debugflag as Integer) as Integer
End Function

#End Region
#Region "SRC\colorcontent.c"
' SRC\colorcontent.c (179, 1)
' pixColorContent()
' pixColorContent(PIX *, l_int32, l_int32, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This returns the color content in each component, which is
'''  * a measure of the deviation from gray, and is defined
'''  * as the difference between the component and the average of
'''  * the other two components.  See the discussion at the
'''  * top of this file.
'''  *   (2) The three numbers (rwhite, gwhite and bwhite) can be thought
'''  * of as the values in the image corresponding to white.
'''  * They are used to compensate for an unbalanced color white point.
'''  * They must either be all 0 or all non-zero.  To turn this
'''  * off, set them all to 0.
'''  *   (3) If the maximum component after white point correction,
'''  * max(r,g,b), is less than mingray, all color components
'''  * for that pixel are set to zero.
'''  * Use mingray = 0 to turn off this filtering of dark pixels.
'''  *   (4) Therefore, use 0 for all four input parameters if the color
'''  * magnitude is to be calculated without either white balance
'''  * correction or dark filtering.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp rgb or 8 bpp colormapped</param>
''' <param name="rwhite"> \param[in]    rwhite, gwhite, bwhite color value associated with white point</param>
''' <param name="gwhite"> \param[in]    mingray min gray value for which color is measured</param>
''' <param name="bwhite"> \param[out]   ppixr [optional] 8 bpp red 'content'</param>
''' <param name="mingray"> \param[out]   ppixg [optional] 8 bpp green 'content'</param>
''' <param name="ppixr"> \param[out]   ppixb [optional] 8 bpp blue 'content'</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorContent")> _
Friend Shared Function pixColorContent(pixs as IntPTR, rwhite as Integer, gwhite as Integer, bwhite as Integer, mingray as Integer, ppixr as Object, ppixg as Object, ppixb as Object) as Integer
End Function

' SRC\colorcontent.c (363, 1)
' pixColorMagnitude()
' pixColorMagnitude(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For an RGB image, a gray pixel is one where all three components
'''  * are equal.  We define the amount of color in an RGB pixel as
'''  * a function depending on the absolute value of the differences
'''  * between the three color components.  Consider the two largest
'''  * of these differences.  The pixel component in common to these
'''  * two differences is the color farthest from the other two.
'''  * The color magnitude in an RGB pixel can be taken as one
'''  * of these three definitions:
'''  *   (a) The average of these two differences.  This is the
'''  * average distance from the two components that are
'''  * nearest to each other to the third component.
'''  *   (b) The minimum value of these two differences.  This is
'''  * the intermediate value of the three distances between
'''  * component values.  Stated otherwise, it is the
'''  * maximum over all components of the minimum distance
'''  * from that component to the other two components.
'''  *   (c) The maximum difference between component values.
'''  *   (2) As an example, suppose that R and G are the closest in
'''  * magnitude.  Then the color is determined as either:
'''  *   (a) The average distance of B from these two:
'''  *    (|B - R| + |B - G|) / 2
'''  *   (b) The minimum distance of B from these two:
'''  *    min(|B - R|, |B - G|).
'''  *   (c) The maximum distance of B from these two:
'''  *    max(|B - R|, |B - G|)
'''  *   (3) The three methods for choosing the color magnitude from
'''  * the components are selected with these flags:
'''  *   (a) L_MAX_DIFF_FROM_AVERAGE_2
'''  *   (b) L_MAX_MIN_DIFF_FROM_2
'''  *   (c) L_MAX_DIFF
'''  *   (4) The three numbers (rwhite, gwhite and bwhite) can be thought
'''  * of as the values in the image corresponding to white.
'''  * They are used to compensate for an unbalanced color white point.
'''  * They must either be all 0 or all non-zero.  To turn this
'''  * off, set them all to 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, amount of color in each source pixel,</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp rgb or 8 bpp colormapped</param>
''' <param name="rwhite"> \param[in]    rwhite, gwhite, bwhite color value associated with white point</param>
''' <param name="gwhite"> \param[in]    type chooses the method for calculating the color magnitude:</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorMagnitude")> _
Friend Shared Function pixColorMagnitude(pixs as IntPTR, rwhite as Integer, gwhite as Integer, bwhite as Integer, type as Integer) as IntPTR
End Function

' SRC\colorcontent.c (502, 1)
' pixMaskOverColorPixels()
' pixMaskOverColorPixels(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The generated mask identifies each pixel as either color or
'''  * non-color.  For a pixel to be color, it must satisfy two
'''  * constraints:
'''  *   (a) The max difference between the r,g and b components must
'''  * equal or exceed a threshold %threshdiff.
'''  *   (b) It must be at least %mindist (in an 8-connected way)
'''  * from the nearest non-color pixel.
'''  *   (2) The distance constraint (b) is only applied if %mindist > 1.
'''  * For example, if %mindist == 2, the color pixels identified
'''  * by (a) are eroded by a 3x3 Sel.  In general, the Sel size
'''  * for erosion is 2 * (%mindist - 1) + 1.
'''  * Why have this constraint?  In scanned images that are
'''  * essentially gray, color artifacts are typically introduced
'''  * in transition regions near sharp edges that go from dark
'''  * to light, so this allows these transition regions to be removed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, mask over color pixels, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp rgb or 8 bpp colormapped</param>
''' <param name="threshdiff"> \param[in]    threshdiff threshold for minimum of the max difference</param>
''' <param name="mindist"> \param[in]    mindist minimum allowed distance from nearest non-color pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMaskOverColorPixels")> _
Friend Shared Function pixMaskOverColorPixels(pixs as IntPTR, threshdiff as Integer, mindist as Integer) as IntPTR
End Function

' SRC\colorcontent.c (569, 1)
' pixMaskOverColorRange()
' pixMaskOverColorRange(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, mask over color pixels, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp rgb or 8 bpp colormapped</param>
''' <param name="rmin"> \param[in]    rmin, rmax min and max allowed values for red component</param>
''' <param name="rmax"> \param[in]    gmin, gmax</param>
''' <param name="gmin"> \param[in]    bmin, bmax</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMaskOverColorRange")> _
Friend Shared Function pixMaskOverColorRange(pixs as IntPTR, rmin as Integer, rmax as Integer, gmin as Integer, gmax as Integer, bmin as Integer, bmax as Integer) as IntPTR
End Function

' SRC\colorcontent.c (678, 1)
' pixColorFraction()
' pixColorFraction(PIX *, l_int32, l_int32, l_int32, l_int32, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function is asking the question: to what extent does the
'''  * image appear to have color?   The amount of color a pixel
'''  * appears to have depends on both the deviation of the
'''  * individual components from their average and on the average
'''  * intensity itself.  For example, the color will be much more
'''  * obvious with a small deviation from white than the same
'''  * deviation from black.
'''  *   (2) Any pixel that meets these three tests is considered a
'''  * colorful pixel:
'''  *   (a) the lightest component must equal or exceed %darkthresh
'''  *   (b) the darkest component must not exceed %lightthresh
'''  *   (c) the max difference between components must equal or
'''  * exceed %diffthresh.
'''  *   (3) The dark pixels are removed from consideration because
'''  * they don't appear to have color.
'''  *   (4) The very lightest pixels are removed because if an image
'''  * has a lot of "white", the color fraction will be artificially
'''  * low, even if all the other pixels are colorful.
'''  *   (5) If pixfract is very small, there are few pixels that are neither
'''  * black nor white.  If colorfract is very small, the pixels
'''  * that are neither black nor white have very little color
'''  * content.  The product 'pixfract * colorfract' gives the
'''  * fraction of pixels with significant color content.
'''  *   (6) One use of this function is as a preprocessing step for median
'''  * cut quantization (colorquant2.c), which does a very poor job
'''  * splitting the color space into rectangular volume elements when
'''  * all the pixels are near the diagonal of the color cube.  For
'''  * octree quantization of an image with only gray values, the
'''  * 2^(level) octcubes on the diagonal are the only ones
'''  * that can be occupied.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp rgb</param>
''' <param name="darkthresh"> \param[in]    darkthresh threshold near black; if the lightest component</param>
''' <param name="lightthresh"> \param[in]    lightthresh threshold near white; if the darkest component</param>
''' <param name="diffthresh"> \param[in]    diffthresh thresh for the maximum difference between</param>
''' <param name="factor"> \param[in]    factor subsampling factor</param>
''' <param name="ppixfract"> \param[out]   ppixfract fraction of pixels in intermediate</param>
''' <param name="pcolorfract"> \param[out]   pcolorfract fraction of pixels that meet the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorFraction")> _
Friend Shared Function pixColorFraction(pixs as IntPTR, darkthresh as Integer, lightthresh as Integer, diffthresh as Integer, factor as Integer, ppixfract as single, pcolorfract as single) as Integer
End Function

' SRC\colorcontent.c (805, 1)
' pixFindColorRegions()
' pixFindColorRegions(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_float32, l_float32 *, PIX **, PIX **, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function tries to determine if there is a significant
'''  * color or darker region on a scanned page image, where part
'''  * of the image is background that is either white or reddish.
'''  * This also allows extraction of regions of colored pixels that
'''  * have a smaller red component than blue or green components.
'''  *   (2) If %pixm exists, pixels under its fg are combined with
'''  * dark pixels to make a mask of pixels not to be considered
'''  * as color candidates.
'''  *   (3) There are four thresholds.
'''  * * %lightthresh: compute the average value of each rgb pixel,
'''  *   and make 10 buckets by value.  If the lightest bucket gray
'''  *   value is below %lightthresh, the image is not considered
'''  *   to have a light bg, and this returns 0.0 for %colorfract.
'''  * * %darkthresh: ignore pixels darker than this (typ. fg text).
'''  *   We make a 1 bpp mask of these pixels, and then dilate it to
'''  *   remove all vestiges of fg from their vicinity.
'''  * * %mindiff: consider pixels with either (b - r) or (g - r)
'''  *   being at least this value, as having color.
'''  * * %colordiff: consider pixels where the (max - min) difference
'''  *   of the pixel components exceeds this value, as having color.
'''  *   (4) All components of color pixels that are touching the image
'''  * border are removed.  Additionally, all pixels within some
'''  * normalized distance %edgefract from the image border can
'''  * be removed.  This insures that dark pixels near the edge
'''  * of the image are not included.
'''  *   (5) This returns in %pcolorfract the fraction of pixels that have
'''  * color and are not in the set consisting of an OR between
'''  * %pixm and the dilated dark pixel mask.
'''  *   (6) No masks are returned unless light color pixels are found.
'''  * If colorfract > 0.0 and %pcolormask1 is defined, this returns
'''  * a 1 bpp mask with fg pixels over the color background.
'''  * This mask may have some holes in it.
'''  *   (7) If colorfract > 0.0 and %pcolormask2 is defined, this returns
'''  * a version of colormask1 where small holes have been filled.
'''  *   (8) To generate a boxa of rectangular regions from the overlap
'''  * of components in the filtered mask:
'''  * boxa1 = pixConnCompBB(colormask2, 8);
'''  * boxa2 = boxaCombineOverlaps(boxa1, NULL);
'''  * This is done here in debug mode.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs        32 bpp rgb</param>
''' <param name="pixm"> \param[in]    pixm        [optional] 1 bpp mask image</param>
''' <param name="factor"> \param[in]    factor      subsample factor; integer >= 1</param>
''' <param name="lightthresh"> \param[in]    lightthresh threshold for component average in lightest</param>
''' <param name="darkthresh"> \param[in]    darkthresh  threshold to eliminate dark pixels (e.g., text)</param>
''' <param name="mindiff"> \param[in]    mindiff     minimum difference (b - r) and (g - r), used to</param>
''' <param name="colordiff"> \param[in]    colordiff   minimum difference in (max - min) component to</param>
''' <param name="edgefract"> \param[in]    edgefract   fraction of image half-width and half-height</param>
''' <param name="pcolorfract"> \param[out]   pcolorfract fraction of 'color' pixels found</param>
''' <param name="pcolormask1"> \param[out]   pcolormask1 [optional] mask over background color, if any</param>
''' <param name="pcolormask2"> \param[out]   pcolormask2 [optional] filtered mask over background color</param>
''' <param name="pixadb"> \param[out]   pixadb      [optional] debug intermediate results</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindColorRegions")> _
Friend Shared Function pixFindColorRegions(pixs as IntPTR, pixm as IntPTR, factor as Integer, lightthresh as Integer, darkthresh as Integer, mindiff as Integer, colordiff as Integer, edgefract as single, pcolorfract as single, pcolormask1 as Object, pcolormask2 as Object, pixadb as IntPTR) as Integer
End Function

' SRC\colorcontent.c (1022, 1)
' pixNumSignificantGrayColors()
' pixNumSignificantGrayColors(PIX *, l_int32, l_int32, l_float32, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function is asking the question: how many perceptually
'''  * significant gray color levels is in this pix?
'''  * A color level must meet 3 criteria to be significant:
'''  *   ~ it can't be too close to black
'''  *   ~ it can't be too close to white
'''  *   ~ it must have at least some minimum fractional population
'''  *   (2) Use -1 for default values for darkthresh, lightthresh and minfract.
'''  *   (3) Choose default of darkthresh = 20, because variations in very
'''  * dark pixels are not visually significant.
'''  *   (4) Choose default of lightthresh = 236, because document images
'''  * that have been jpeg'd typically have near-white pixels in the
'''  * 8x8 jpeg blocks, and these should not be counted.  It is desirable
'''  * to obtain a clean image by quantizing this noise away.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs  8 bpp gray</param>
''' <param name="darkthresh"> \param[in]    darkthresh dark threshold for minimum intensity to be</param>
''' <param name="lightthresh"> \param[in]    lightthresh threshold near white, for maximum intensity</param>
''' <param name="minfract"> \param[in]    minfract minimum fraction of all pixels to include a level</param>
''' <param name="factor"> \param[in]    factor subsample factor; integer >= 1</param>
''' <param name="pncolors"> \param[out]   pncolors number of significant colors; 0 on error</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixNumSignificantGrayColors")> _
Friend Shared Function pixNumSignificantGrayColors(pixs as IntPTR, darkthresh as Integer, lightthresh as Integer, minfract as single, factor as Integer, pncolors as Integer) as Integer
End Function

' SRC\colorcontent.c (1145, 1)
' pixColorsForQuantization()
' pixColorsForQuantization(PIX *, l_int32, l_int32 *, l_int32 *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function finds a measure of the number of colors that are
'''  * found in low-gradient regions of an image.  By its
'''  * magnitude relative to some threshold (not specified in
'''  * this function), it gives a good indication of whether
'''  * quantization will generate posterization.   This number
'''  * is larger for images with regions of slowly varying
'''  * intensity (if 8 bpp) or color (if rgb). Such images, if
'''  * quantized, may require dithering to avoid posterization,
'''  * and lossless compression is then expected to be poor.
'''  *   (2) If pixs has a colormap, the number of colors returned is
'''  * the number in the colormap.
'''  *   (3) It is recommended that document images be reduced to a width
'''  * of 800 pixels before applying this function.  Then it can
'''  * be expected that color detection will be fairly accurate
'''  * and the number of colors will reflect both the content and
'''  * the type of compression to be used.  For less than 15 colors,
'''  * there is unlikely to be a halftone image, and lossless
'''  * quantization should give both a good visual result and
'''  * better compression.
'''  *   (4) When using the default threshold on the gradient (15),
'''  * images (both gray and rgb) where ncolors is greater than
'''  * about 15 will compress poorly with either lossless
'''  * compression or dithered quantization, and they may be
'''  * posterized with non-dithered quantization.
'''  *   (5) For grayscale images, or images without significant color,
'''  * this returns the number of significant gray levels in
'''  * the low-gradient regions.  The actual number of gray levels
'''  * can be large due to jpeg compression noise in the background.
'''  *   (6) Similarly, for color images, the actual number of different
'''  * (r,g,b) colors in the low-gradient regions (rather than the
'''  * number of occupied level 4 octcubes) can be quite large, e.g.,
'''  * due to jpeg compression noise, even for regions that appear
'''  * to be of a single color.  By quantizing to level 4 octcubes,
'''  * most of these superfluous colors are removed from the counting.
'''  *   (7) The image is tested for color.  If there is very little color,
'''  * it is thresholded to gray and the number of gray levels in
'''  * the low gradient regions is found.  If the image has color,
'''  * the number of occupied level 4 octcubes is found.
'''  *   (8) The number of colors in the low-gradient regions increases
'''  * monotonically with the threshold %thresh on the edge gradient.
'''  *   (9) Background: grayscale and color quantization is often useful
'''  * to achieve highly compressed images with little visible
'''  * distortion.  However, gray or color washes (regions of
'''  * low gradient) can defeat this approach to high compression.
'''  * How can one determine if an image is expected to compress
'''  * well using gray or color quantization?  We use the fact that
'''  *   * gray washes, when quantized with less than 50 intensities,
'''  *  have posterization (visible boundaries between regions
'''  *  of uniform 'color') and poor lossless compression
'''  *   * color washes, when quantized with level 4 octcubes,
'''  *  typically result in both posterization and the occupancy
'''  *  of many level 4 octcubes.
'''  * Images can have colors either intrinsically or as jpeg
'''  * compression artifacts.  This function reduces but does not
'''  * completely eliminate measurement of jpeg quantization noise
'''  * in the white background of grayscale or color images.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp gray or 32 bpp rgb; with or without colormap</param>
''' <param name="thresh"> \param[in]    thresh binary threshold on edge gradient; 0 for default</param>
''' <param name="pncolors"> \param[out]   pncolors the number of colors found</param>
''' <param name="piscolor"> \param[out]   piscolor [optional] 1 if significant color is found;</param>
''' <param name="debug"> \param[in]    debug 1 to output masked image that is tested for colors;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorsForQuantization")> _
Friend Shared Function pixColorsForQuantization(pixs as IntPTR, thresh as Integer, pncolors as Integer, piscolor as Integer, debug as Integer) as Integer
End Function

' SRC\colorcontent.c (1287, 1)
' pixNumColors()
' pixNumColors(PIX *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This returns the actual number of colors found in the image,
'''  * even if there is a colormap.  If %factor == 1 and the
'''  * number of colors differs from the number of entries
'''  * in the colormap, a warning is issued.
'''  *   (2) Use %factor == 1 to find the actual number of colors.
'''  * Use %factor > 1 to quickly find the approximate number of colors.
'''  *   (3) For d = 2, 4 or 8 bpp grayscale, this returns the number
'''  * of colors found in the image in 'ncolors'.
'''  *   (4) For d = 32 bpp (rgb), if the number of colors is
'''  * greater than 256, this returns 0 in 'ncolors'.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="pixs"> \param[in]    pixs 2, 4, 8, 32 bpp</param>
''' <param name="factor"> \param[in]    factor subsampling factor; integer</param>
''' <param name="pncolors"> \param[out]   pncolors the number of colors found, or 0 if</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixNumColors")> _
Friend Shared Function pixNumColors(pixs as IntPTR, factor as Integer, pncolors as Integer) as Integer
End Function

' SRC\colorcontent.c (1395, 1)
' pixGetMostPopulatedColors()
' pixGetMostPopulatedColors(PIX *, l_int32, l_int32, l_int32, l_uint32 **, PIXCMAP **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds the %ncolors most populated cubes in rgb colorspace,
'''  * where the cube size depends on %sigbits as
'''  *   cube side = (256 >> sigbits)
'''  *   (2) The rgb color components are found at the center of the cube.
'''  *   (3) The output array of colors can be displayed using
'''  *   pixDisplayColorArray(array, ncolors, ...);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="sigbits"> \param[in]    sigbits 2-6, significant bits retained in the quantizer</param>
''' <param name="factor"> \param[in]    factor subsampling factor; use 1 for no subsampling</param>
''' <param name="ncolors"> \param[in]    ncolors the number of most populated colors to select</param>
''' <param name="parray"> \param[out]   parray [optional] array of colors, each as 0xrrggbb00</param>
''' <param name="pcmap"> \param[out]   pcmap [optional] colormap of the colors</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetMostPopulatedColors")> _
Friend Shared Function pixGetMostPopulatedColors(pixs as IntPTR, sigbits as Integer, factor as Integer, ncolors as Integer, parray as Object, pcmap as Object) as Integer
End Function

' SRC\colorcontent.c (1470, 1)
' pixSimpleColorQuantize()
' pixSimpleColorQuantize(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If you want to do color quantization for real, use octcube
'''  * or modified median cut.  This function shows that it is
'''  * easy to make a simple quantizer based solely on the population
'''  * in cells of a given size in rgb color space.
'''  *   (2) The %ncolors most populated cells at the %sigbits level form
'''  * the colormap for quantizing, and this uses octcube indexing
'''  * under the covers to assign each pixel to the nearest color.
'''  *   (3) %sigbits is restricted to 2, 3 and 4.  At the low end, the
'''  * color discrimination is very crude; at the upper end, a set of
'''  * similar colors can dominate the result.  Interesting results
'''  * are generally found for %sigbits = 3 and ncolors ~ 20.
'''  *   (4) See also pixColorSegment() for a method of quantizing the
'''  * colors to generate regions of similar color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp cmapped or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="sigbits"> \param[in]    sigbits 2-4, significant bits retained in the quantizer</param>
''' <param name="factor"> \param[in]    factor subsampling factor; use 1 for no subsampling</param>
''' <param name="ncolors"> \param[in]    ncolors the number of most populated colors to select</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSimpleColorQuantize")> _
Friend Shared Function pixSimpleColorQuantize(pixs as IntPTR, sigbits as Integer, factor as Integer, ncolors as Integer) as IntPTR
End Function

' SRC\colorcontent.c (1516, 1)
' pixGetRGBHistogram()
' pixGetRGBHistogram(PIX *, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This uses a simple, fast method of indexing into an rgb image.
'''  *   (2) The output is a 1D histogram of count vs. rgb-index, which
'''  * uses red sigbits as the most significant and blue as the least.
'''  *   (3) This function produces the same result as pixMedianCutHisto().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa histogram of colors, indexed by RGB</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="sigbits"> \param[in]    sigbits 2-6, significant bits retained in the quantizer</param>
''' <param name="factor"> \param[in]    factor subsampling factor; use 1 for no subsampling</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRGBHistogram")> _
Friend Shared Function pixGetRGBHistogram(pixs as IntPTR, sigbits as Integer, factor as Integer) as IntPTR
End Function

' SRC\colorcontent.c (1584, 1)
' makeRGBIndexTables()
' makeRGBIndexTables(l_uint32 **, l_uint32 **, l_uint32 **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) These tables are used to map from rgb sample values to
'''  * an rgb index, using
'''  * rgbindex = rtab[rval] | gtab[gval] | btab[bval]
'''  * where, e.g., if sigbits = 3, the index is a 9 bit integer:
'''  * r7 r6 r5 g7 g6 g5 b7 b6 b5
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="prtab"> \param[out]   prtab, pgtab, pbtab 256-entry index tables</param>
''' <param name="pgtab"> \param[in]    sigbits 2-6, significant bits retained in the quantizer</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeRGBIndexTables")> _
Friend Shared Function makeRGBIndexTables(prtab as Object, pgtab as Object, pbtab as Object, sigbits as Integer) as Integer
End Function

' SRC\colorcontent.c (1674, 1)
' getRGBFromIndex()
' getRGBFromIndex(l_uint32, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The %index is expressed in bits, based on the the
'''  * %sigbits of the r, g and b components, as
'''  * r7 r6 ... g7 g6 ... b7 b6 ...
'''  *   (2) The computed rgb values are in the center of the quantized cube.
'''  * The extra bit that is OR'd accomplishes this.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="index"> \param[in]    index rgbindex</param>
''' <param name="sigbits"> \param[in]    sigbits 2-6, significant bits retained in the quantizer</param>
''' <param name="prval"> \param[out]   prval, pgval, pbval rgb values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getRGBFromIndex")> _
Friend Shared Function getRGBFromIndex(index as UInteger, sigbits as Integer, prval as Integer, pgval as Integer, pbval as Integer) as Integer
End Function

' SRC\colorcontent.c (1757, 1)
' pixHasHighlightRed()
' pixHasHighlightRed(PIX *, l_int32, l_float32, l_float32, l_int32 *, l_float32 *, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Pixels are identified as red if they satisfy two conditions:
'''  * (a) The components satisfy (R-B)/B > %fthresh   (red or dark fg)
'''  * (b) The red component satisfied R > 128  (red or light bg)
'''  * Masks are generated for (a) and (b), and the intersection
'''  * gives the pixels that are red but not either light bg or
'''  * dark fg.
'''  *   (2) A typical value for fract = 0.0001, which gives sensitivity
'''  * to an image where a small fraction of the pixels are printed
'''  * in red.
'''  *   (3) A typical value for fthresh = 2.5.  Higher values give less
'''  * sensitivity to red, and fewer false positives.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp rgb</param>
''' <param name="factor"> \param[in]    factor subsampling; an integer >= 1; use 1 for all pixels</param>
''' <param name="fract"> \param[in]    fract threshold fraction of all image pixels</param>
''' <param name="fthresh"> \param[in]    fthresh threshold on a function of the components; typ. ~2.5</param>
''' <param name="phasred"> \param[out]   phasred 1 if red pixels are above threshold</param>
''' <param name="pratio"> \param[out]   pratio [optional] normalized fraction of threshold</param>
''' <param name="ppixdb"> \param[out]   ppixdb [optional] seed pixel mask</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixHasHighlightRed")> _
Friend Shared Function pixHasHighlightRed(pixs as IntPTR, factor as Integer, fract as single, fthresh as single, phasred as Integer, pratio as single, ppixdb as Object) as Integer
End Function

#End Region
#Region "SRC\coloring.c"
' SRC\coloring.c (126, 1)
' pixColorGrayRegions()
' pixColorGrayRegions(PIX *, BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This generates a new image, where some of the pixels in each
'''  * box in the boxa are colorized.  See pixColorGray() for usage
'''  * with %type and %thresh.  Note that %thresh is only used for
'''  * rgb; it is ignored for colormapped images.
'''  *   (2) If the input image is colormapped, the new image will be 8 bpp
'''  * colormapped if possible; otherwise, it will be converted
'''  * to 32 bpp rgb.  Only pixels that are strictly gray will be
'''  * colorized.
'''  *   (3) If the input image is not colormapped, it is converted to rgb.
'''  * A "gray" value for a pixel is determined by averaging the
'''  * components, and the output rgb value is determined from this.
'''  *   (4) This can be used in conjunction with pixHasHighlightRed() to
'''  * add highlight color to a grayscale image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 2, 4 or 8 bpp gray, rgb, or colormapped</param>
''' <param name="boxa"> \param[in]    boxa of regions in which to apply color</param>
''' <param name="type"> \param[in]    type L_PAINT_LIGHT, L_PAINT_DARK</param>
''' <param name="thresh"> \param[in]    thresh average value below/above which pixel is unchanged</param>
''' <param name="rval"> \param[in]    rval, gval, bval new color to paint</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorGrayRegions")> _
Friend Shared Function pixColorGrayRegions(pixs as IntPTR, boxa as IntPTR, type as Integer, thresh as Integer, rval as Integer, gval as Integer, bval as Integer) as IntPTR
End Function

' SRC\coloring.c (227, 1)
' pixColorGray()
' pixColorGray(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place operation; pixs is modified.
'''  * If pixs is colormapped, the operation will add colors to the
'''  * colormap.  Otherwise, pixs will be converted to 32 bpp rgb if
'''  * it is initially 8 bpp gray.
'''  *   (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
'''  * preserving antialiasing.
'''  * If type == L_PAINT_DARK, it colorizes non-white pixels,
'''  * preserving antialiasing.
'''  *   (3) If box is NULL, applies function to the entire image; otherwise,
'''  * clips the operation to the intersection of the box and pix.
'''  *   (4) If colormapped, calls pixColorGrayCmap(), which applies the
'''  * coloring algorithm only to pixels that are strictly gray.
'''  *   (5) For RGB, determines a "gray" value by averaging; then uses this
'''  * value, plus the input rgb target, to generate the output
'''  * pixel values.
'''  *   (6) thresh is only used for rgb; it is ignored for colormapped pix.
'''  * If type == L_PAINT_LIGHT, use thresh = 0 if all pixels are to
'''  * be colored (black pixels will be unaltered).
'''  * In situations where there are a lot of black pixels,
'''  * setting thresh > 0 will make the function considerably
'''  * more efficient without affecting the final result.
'''  * If type == L_PAINT_DARK, use thresh = 255 if all pixels
'''  * are to be colored (white pixels will be unaltered).
'''  * In situations where there are a lot of white pixels,
'''  * setting thresh  255 will make the function considerably
'''  * more efficient without affecting the final result.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp gray, rgb or colormapped image</param>
''' <param name="box"> \param[in]    box [optional] region in which to apply color; can be NULL</param>
''' <param name="type"> \param[in]    type L_PAINT_LIGHT, L_PAINT_DARK</param>
''' <param name="thresh"> \param[in]    thresh average value below/above which pixel is unchanged</param>
''' <param name="rval"> \param[in]    rval, gval, bval new color to paint</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorGray")> _
Friend Shared Function pixColorGray(pixs as IntPTR, box as IntPTR, type as Integer, thresh as Integer, rval as Integer, gval as Integer, bval as Integer) as Integer
End Function

' SRC\coloring.c (353, 1)
' pixColorGrayMasked()
' pixColorGrayMasked(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This generates a new image, where some of the pixels under
'''  * FG in the mask are colorized.
'''  *   (2) See pixColorGray() for usage with %type and %thresh.  Note
'''  * that %thresh is only used for rgb; it is ignored for
'''  * colormapped images.  In most cases, the mask will be over
'''  * the darker parts and %type == L_PAINT_DARK.
'''  *   (3) If pixs is colormapped this calls pixColorMaskedCmap(),
'''  * which adds colors to the colormap for pixd; it only adds
'''  * colors corresponding to strictly gray colors in the colormap.
'''  * Otherwise, if pixs is 8 bpp gray, pixd will be 32 bpp rgb.
'''  *   (4) If pixs is 32 bpp rgb, for each pixel a "gray" value is
'''  * found by averaging.  This average is then used with the
'''  * input rgb target to generate the output pixel values.
'''  *   (5) This can be used in conjunction with pixHasHighlightRed() to
'''  * add highlight color to a grayscale image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd colorized, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp gray, rgb or colormapped image</param>
''' <param name="pixm"> \param[in]    pixm 1 bpp mask, through which to apply color</param>
''' <param name="type"> \param[in]    type L_PAINT_LIGHT, L_PAINT_DARK</param>
''' <param name="thresh"> \param[in]    thresh average value below/above which pixel is unchanged</param>
''' <param name="rval"> \param[in]    rval, gval, bval new color to paint</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorGrayMasked")> _
Friend Shared Function pixColorGrayMasked(pixs as IntPTR, pixm as IntPTR, type as Integer, thresh as Integer, rval as Integer, gval as Integer, bval as Integer) as IntPTR
End Function

' SRC\coloring.c (478, 1)
' pixSnapColor()
' pixSnapColor(PIX *, PIX *, l_uint32, l_uint32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For inplace operation, call it this way:
'''  *  pixSnapColor(pixs, pixs, ... )
'''  *   (2) For generating a new pixd:
'''  *  pixd = pixSnapColor(NULL, pixs, ...)
'''  *   (3) If pixs has a colormap, it is handled by pixSnapColorCmap().
'''  *   (4) All pixels within 'diff' of 'srcval', componentwise,
'''  * will be changed to 'dstval'.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with all pixels within diff of pixval set to pixval,</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; either NULL or equal to pixs for in-place</param>
''' <param name="pixs"> \param[in]    pixs colormapped or 8 bpp gray or 32 bpp rgb</param>
''' <param name="srcval"> \param[in]    srcval color center to be selected for change: 0xrrggbb00</param>
''' <param name="dstval"> \param[in]    dstval target color for pixels: 0xrrggbb00</param>
''' <param name="diff"> \param[in]    diff max absolute difference, applied to all components</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSnapColor")> _
Friend Shared Function pixSnapColor(pixd as IntPTR, pixs as IntPTR, srcval as UInteger, dstval as UInteger, diff as Integer) as IntPTR
End Function

' SRC\coloring.c (565, 1)
' pixSnapColorCmap()
' pixSnapColorCmap(PIX *, PIX *, l_uint32, l_uint32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For inplace operation, call it this way:
'''  *  pixSnapCcmap(pixs, pixs, ... )
'''  *   (2) For generating a new pixd:
'''  *  pixd = pixSnapCmap(NULL, pixs, ...)
'''  *   (3) pixs must have a colormap.
'''  *   (4) All colors within 'diff' of 'srcval', componentwise,
'''  * will be changed to 'dstval'.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with all pixels within diff of srcval set to dstval,</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; either NULL or equal to pixs for in-place</param>
''' <param name="pixs"> \param[in]    pixs colormapped</param>
''' <param name="srcval"> \param[in]    srcval color center to be selected for change: 0xrrggbb00</param>
''' <param name="dstval"> \param[in]    dstval target color for pixels: 0xrrggbb00</param>
''' <param name="diff"> \param[in]    diff max absolute difference, applied to all components</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSnapColorCmap")> _
Friend Shared Function pixSnapColorCmap(pixd as IntPTR, pixs as IntPTR, srcval as UInteger, dstval as UInteger, diff as Integer) as IntPTR
End Function

' SRC\coloring.c (681, 1)
' pixLinearMapToTargetColor()
' pixLinearMapToTargetColor(PIX *, PIX *, l_uint32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For each component (r, b, g) separately, this does a piecewise
'''  * linear mapping of the colors in pixs to colors in pixd.
'''  * If rs and rd are the red src and dest components in %srcval and
'''  * %dstval, then the range [0 ... rs] in pixs is mapped to
'''  * [0 ... rd] in pixd.  Likewise, the range [rs ... 255] in pixs
'''  * is mapped to [rd ... 255] in pixd.  And similarly for green
'''  * and blue.
'''  *   (2) The mapping will in general change the hue of the pixels.
'''  * However, if the src and dst targets are related by
'''  * a transformation given by pixelFractionalShift(), the hue
'''  * is invariant.
'''  *   (3) For inplace operation, call it this way:
'''  *   pixLinearMapToTargetColor(pixs, pixs, ... )
'''  *   (4) For generating a new pixd:
'''  *   pixd = pixLinearMapToTargetColor(NULL, pixs, ...)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with all pixels mapped based on the srcval/destval</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; either NULL or equal to pixs for in-place</param>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="srcval"> \param[in]    srcval source color: 0xrrggbb00</param>
''' <param name="dstval"> \param[in]    dstval target color: 0xrrggbb00</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixLinearMapToTargetColor")> _
Friend Shared Function pixLinearMapToTargetColor(pixd as IntPTR, pixs as IntPTR, srcval as UInteger, dstval as UInteger) as IntPTR
End Function

' SRC\coloring.c (778, 1)
' pixelLinearMapToTargetColor()
' pixelLinearMapToTargetColor(l_uint32, l_uint32, l_uint32, l_uint32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does this does a piecewise linear mapping of each
'''  * component of %scolor to %dcolor, based on the relation
'''  * between the components of %srcmap and %dstmap.  It is the
'''  * same transformation, performed on a single color, as mapped
'''  * on every pixel in a pix by pixLinearMapToTargetColor().
'''  *   (2) For each component, if the sval is larger than the smap,
'''  * the dval will be pushed up from dmap towards white.
'''  * Otherwise, dval will be pushed down from dmap towards black.
'''  * This is because you can visualize the transformation as
'''  * a linear stretching where smap moves to dmap, and everything
'''  * else follows linearly with 0 and 255 fixed.
'''  *   (3) The mapping will in general change the hue of %scolor.
'''  * However, if the %srcmap and %dstmap targets are related by
'''  * a transformation given by pixelFractionalShift(), the hue
'''  * will be invariant.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="scolor"> \param[in]    scolor rgb source color: 0xrrggbb00</param>
''' <param name="srcmap"> \param[in]    srcmap source mapping color: 0xrrggbb00</param>
''' <param name="dstmap"> \param[in]    dstmap target mapping color: 0xrrggbb00</param>
''' <param name="pdcolor"> \param[out]   pdcolor rgb dest color: 0xrrggbb00</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixelLinearMapToTargetColor")> _
Friend Shared Function pixelLinearMapToTargetColor(scolor as UInteger, srcmap as UInteger, dstmap as UInteger, pdcolor as UInteger) as Integer
End Function

' SRC\coloring.c (863, 1)
' pixShiftByComponent()
' pixShiftByComponent(PIX *, PIX *, l_uint32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For each component (r, b, g) separately, this does a linear
'''  * mapping of the colors in pixs to colors in pixd.
'''  * Let rs and rd be the red src and dest components in %srcval and
'''  * %dstval, and rval is the red component of the src pixel.
'''  * Then for all pixels in pixs, the mapping for the red
'''  * component from pixs to pixd is:
'''  * if (rd = rs)   (shift toward black)
'''  *  rval --> (rd/rs) * rval
'''  * if (rd > rs) (shift toward white)
'''  * (255 - rval) --> ((255 - rs)/(255 - rd)) * (255 - rval)
'''  * Thus if rd = rs, the red component of all pixels is
'''  * mapped by the same fraction toward white, and if rd > rs,
'''  * they are mapped by the same fraction toward black.
'''  * This is essentially a different linear TRC (gamma = 1)
'''  * for each component.  The source and target color inputs are
'''  * just used to generate the three fractions.
'''  *   (2) Note that this mapping differs from that in
'''  * pixLinearMapToTargetColor(), which maps rs --> rd and does
'''  * a piecewise stretching in between.
'''  *   (3) For inplace operation, call it this way:
'''  *   pixFractionalShiftByComponent(pixs, pixs, ... )
'''  *   (4) For generating a new pixd:
'''  *   pixd = pixLinearMapToTargetColor(NULL, pixs, ...)
'''  *   (5) A simple application is to color a grayscale image.
'''  * A light background can be colored using srcval = 0xffffff00
'''  * and picking a target background color for dstval.
'''  * A dark foreground can be colored by using srcval = 0x0
'''  * and choosing a target foreground color for dstval.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with all pixels mapped based on the srcval/destval</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; either NULL or equal to pixs for in-place</param>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="srcval"> \param[in]    srcval source color: 0xrrggbb00</param>
''' <param name="dstval"> \param[in]    dstval target color: 0xrrggbb00</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixShiftByComponent")> _
Friend Shared Function pixShiftByComponent(pixd as IntPTR, pixs as IntPTR, srcval as UInteger, dstval as UInteger) as IntPTR
End Function

' SRC\coloring.c (964, 1)
' pixelShiftByComponent()
' pixelShiftByComponent(l_int32, l_int32, l_int32, l_uint32, l_uint32, l_uint32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a linear transformation that gives the same result
'''  * on a single pixel as pixShiftByComponent() gives
'''  * on a pix.  Each component is handled separately.  If
'''  * the dest component is larger than the src, then the
'''  * component is pushed toward 255 by the same fraction as
'''  * the src --> dest shift.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
''' <param name="gval"> \param[in]    srcval source color: 0xrrggbb00</param>
''' <param name="bval"> \param[in]    dstval target color: 0xrrggbb00</param>
''' <param name="srcval"> \param[out]   ppixel rgb value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixelShiftByComponent")> _
Friend Shared Function pixelShiftByComponent(rval as Integer, gval as Integer, bval as Integer, srcval as UInteger, dstval as UInteger, ppixel as UInteger) as Integer
End Function

' SRC\coloring.c (1023, 1)
' pixelFractionalShift()
' pixelFractionalShift(l_int32, l_int32, l_int32, l_float32, l_uint32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This transformation leaves the hue invariant, while changing
'''  * the saturation and intensity.  It can be used for that
'''  * purpose in pixLinearMapToTargetColor().
'''  *   (2) %fraction is in the range [-1 .... +1].  If %fraction  0,
'''  * saturation is increased and brightness is reduced.  The
'''  * opposite results if %fraction > 0.  If %fraction == -1,
'''  * the resulting pixel is black; %fraction == 1 results in white.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
''' <param name="gval"> \param[in]    fraction negative toward black; positive toward white</param>
''' <param name="bval"> \param[out]   ppixel rgb value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixelFractionalShift")> _
Friend Shared Function pixelFractionalShift(rval as Integer, gval as Integer, bval as Integer, fraction as single, ppixel as UInteger) as Integer
End Function

#End Region
#Region "SRC\colormap.c"
' SRC\colormap.c (110, 1)
' pixcmapCreate()
' pixcmapCreate(l_int32) as PIXCMAP *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmap, or NULL on error</returns>
''' <param name="depth"> \param[in]    depth bpp, of pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapCreate")> _
Friend Shared Function pixcmapCreate(depth as Integer) as IntPTR
End Function

' SRC\colormap.c (157, 1)
' pixcmapCreateRandom()
' pixcmapCreateRandom(l_int32, l_int32, l_int32) as PIXCMAP *
''' <summary>
''' * Notes:
'''  *   (1) This sets up a colormap with random colors,
'''  * where the first color is optionally black, the last color
'''  * is optionally white, and the remaining colors are
'''  * chosen randomly.
'''  *   (2) The number of randomly chosen colors is:
'''  *   2^(depth) - haswhite - hasblack
'''  *   (3) Because rand() is seeded, it might disrupt otherwise
'''  * deterministic results if also used elsewhere in a program.
'''  *   (4) rand() is not threadsafe, and will generate garbage if run
'''  * on multiple threads at once -- though garbage is generally
'''  * what you want from a random number generator!
'''  *   (5) Modern rand()s have equal randomness in low and high order
'''  * bits, but older ones don't.  Here, we're just using rand()
'''  * to choose colors for output.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmap, or NULL on error</returns>
''' <param name="depth"> \param[in]    depth bpp, of pix; 2, 4 or 8</param>
''' <param name="hasblack"> \param[in]    hasblack 1 if the first color is black; 0 if no black</param>
''' <param name="haswhite"> \param[in]    haswhite 1 if the last color is white; 0 if no white</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapCreateRandom")> _
Friend Shared Function pixcmapCreateRandom(depth as Integer, hasblack as Integer, haswhite as Integer) as IntPTR
End Function

' SRC\colormap.c (203, 1)
' pixcmapCreateLinear()
' pixcmapCreateLinear(l_int32, l_int32) as PIXCMAP *
''' <summary>
''' * Notes:
'''  *   (1) Colormap has equally spaced gray color values
'''  * from black (0, 0, 0) to white (255, 255, 255).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmap, or NULL on error</returns>
''' <param name="d"> \param[in]    d depth of pix for this colormap; 1, 2, 4 or 8</param>
''' <param name="nlevels"> \param[in]    nlevels valid in range [2, 2^d]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapCreateLinear")> _
Friend Shared Function pixcmapCreateLinear(d as Integer, nlevels as Integer) as IntPTR
End Function

' SRC\colormap.c (233, 1)
' pixcmapCopy()
' pixcmapCopy(PIXCMAP *) as PIXCMAP *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmapd, or NULL on error</returns>
''' <param name="cmaps"> \param[in]    cmaps</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapCopy")> _
Friend Shared Function pixcmapCopy(cmaps as IntPTR) as IntPTR
End Function

' SRC\colormap.c (263, 1)
' pixcmapDestroy()
' pixcmapDestroy(PIXCMAP **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pcmap"> \param[in,out]   pcmap set to null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapDestroy")> _
Friend Shared Function pixcmapDestroy(pcmap as Object) as Boolean ' Org. Void
End Function

' SRC\colormap.c (299, 1)
' pixcmapAddColor()
' pixcmapAddColor(PIXCMAP *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This always adds the color if there is room.
'''  *   (2) The alpha component is 255 (opaque)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="rval"> \param[in]    rval, gval, bval colormap entry to be added; each number</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapAddColor")> _
Friend Shared Function pixcmapAddColor(cmap as IntPTR, rval as Integer, gval as Integer, bval as Integer) as Integer
End Function

' SRC\colormap.c (337, 1)
' pixcmapAddRGBA()
' pixcmapAddRGBA(PIXCMAP *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This always adds the color if there is room.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="rval"> \param[in]    rval, gval, bval, aval colormap entry to be added;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapAddRGBA")> _
Friend Shared Function pixcmapAddRGBA(cmap as IntPTR, rval as Integer, gval as Integer, bval as Integer, aval as Integer) as Integer
End Function

' SRC\colormap.c (381, 1)
' pixcmapAddNewColor()
' pixcmapAddNewColor(PIXCMAP *, l_int32, l_int32, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This only adds color if not already there.
'''  *   (2) The alpha component is 255 (opaque)
'''  *   (3) This returns the index of the new (or existing) color.
'''  *   (4) Returns 2 with a warning if unable to add this color;
'''  * the caller should check the return value.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error; 2 if unable to add color</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="rval"> \param[in]    rval, gval, bval colormap entry to be added; each number</param>
''' <param name="gval"> \param[out]   pindex index of color</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapAddNewColor")> _
Friend Shared Function pixcmapAddNewColor(cmap as IntPTR, rval as Integer, gval as Integer, bval as Integer, pindex as Integer) as Integer
End Function

' SRC\colormap.c (430, 1)
' pixcmapAddNearestColor()
' pixcmapAddNearestColor(PIXCMAP *, l_int32, l_int32, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This only adds color if not already there.
'''  *   (2) The alpha component is 255 (opaque)
'''  *   (3) If it's not in the colormap and there is no room to add
'''  * another color, this returns the index of the nearest color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="rval"> \param[in]    rval, gval, bval colormap entry to be added; each number</param>
''' <param name="gval"> \param[out]   pindex index of color</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapAddNearestColor")> _
Friend Shared Function pixcmapAddNearestColor(cmap as IntPTR, rval as Integer, gval as Integer, bval as Integer, pindex as Integer) as Integer
End Function

' SRC\colormap.c (477, 1)
' pixcmapUsableColor()
' pixcmapUsableColor(PIXCMAP *, l_int32, l_int32, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This checks if the color already exists or if there is
'''  * room to add it.  It makes no change in the colormap.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="rval"> \param[in]    rval, gval, bval colormap entry to be added; each number</param>
''' <param name="gval"> \param[out]   pusable 1 if usable; 0 if not</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapUsableColor")> _
Friend Shared Function pixcmapUsableColor(cmap as IntPTR, rval as Integer, gval as Integer, bval as Integer, pusable as Integer) as Integer
End Function

' SRC\colormap.c (524, 1)
' pixcmapAddBlackOrWhite()
' pixcmapAddBlackOrWhite(PIXCMAP *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This only adds color if not already there.
'''  *   (2) The alpha component is 255 (opaque)
'''  *   (3) This sets index to the requested color.
'''  *   (4) If there is no room in the colormap, returns the index
'''  * of the closest color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="color"> \param[in]    color 0 for black, 1 for white</param>
''' <param name="pindex"> \param[out]   pindex [optional] index of color; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapAddBlackOrWhite")> _
Friend Shared Function pixcmapAddBlackOrWhite(cmap as IntPTR, color as Integer, pindex as Integer) as Integer
End Function

' SRC\colormap.c (563, 1)
' pixcmapSetBlackAndWhite()
' pixcmapSetBlackAndWhite(PIXCMAP *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="setblack"> \param[in]    setblack 0 for no operation; 1 to set darkest color to black</param>
''' <param name="setwhite"> \param[in]    setwhite 0 for no operation; 1 to set lightest color to white</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapSetBlackAndWhite")> _
Friend Shared Function pixcmapSetBlackAndWhite(cmap as IntPTR, setblack as Integer, setwhite as Integer) as Integer
End Function

' SRC\colormap.c (593, 1)
' pixcmapGetCount()
' pixcmapGetCount(PIXCMAP *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetCount")> _
Friend Shared Function pixcmapGetCount(cmap as IntPTR) as Integer
End Function

' SRC\colormap.c (610, 1)
' pixcmapGetFreeCount()
' pixcmapGetFreeCount(PIXCMAP *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  free entries, or 0 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetFreeCount")> _
Friend Shared Function pixcmapGetFreeCount(cmap as IntPTR) as Integer
End Function

' SRC\colormap.c (627, 1)
' pixcmapGetDepth()
' pixcmapGetDepth(PIXCMAP *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  depth, or 0 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetDepth")> _
Friend Shared Function pixcmapGetDepth(cmap as IntPTR) as Integer
End Function

' SRC\colormap.c (650, 1)
' pixcmapGetMinDepth()
' pixcmapGetMinDepth(PIXCMAP *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) On error, &mindepth is returned as 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="pmindepth"> \param[out]   pmindepth minimum depth to support the colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetMinDepth")> _
Friend Shared Function pixcmapGetMinDepth(cmap as IntPTR, pmindepth as Integer) as Integer
End Function

' SRC\colormap.c (686, 1)
' pixcmapClear()
' pixcmapClear(PIXCMAP *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This removes the colors by setting the count to 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapClear")> _
Friend Shared Function pixcmapClear(cmap as IntPTR) as Integer
End Function

' SRC\colormap.c (709, 1)
' pixcmapGetColor()
' pixcmapGetColor(PIXCMAP *, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 if not accessible caller should check</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="index"> \param[in]    index</param>
''' <param name="prval"> \param[out]   prval, pgval, pbval each color value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetColor")> _
Friend Shared Function pixcmapGetColor(cmap as IntPTR, index as Integer, prval as Integer, pgval as Integer, pbval as Integer) as Integer
End Function

' SRC\colormap.c (749, 1)
' pixcmapGetColor32()
' pixcmapGetColor32(PIXCMAP *, l_int32, l_uint32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The returned alpha channel value is 255.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 if not accessible caller should check</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="index"> \param[in]    index</param>
''' <param name="pval32"> \param[out]   pval32 32-bit rgb color value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetColor32")> _
Friend Shared Function pixcmapGetColor32(cmap as IntPTR, index as Integer, pval32 as UInteger) as Integer
End Function

' SRC\colormap.c (777, 1)
' pixcmapGetRGBA()
' pixcmapGetRGBA(PIXCMAP *, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 if not accessible caller should check</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="index"> \param[in]    index</param>
''' <param name="prval"> \param[out]   prval, pgval, pbval, paval each color value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetRGBA")> _
Friend Shared Function pixcmapGetRGBA(cmap as IntPTR, index as Integer, prval as Integer, pgval as Integer, pbval as Integer, paval as Integer) as Integer
End Function

' SRC\colormap.c (815, 1)
' pixcmapGetRGBA32()
' pixcmapGetRGBA32(PIXCMAP *, l_int32, l_uint32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 if not accessible caller should check</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="index"> \param[in]    index</param>
''' <param name="pval32"> \param[out]   pval32 32-bit rgba color value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetRGBA32")> _
Friend Shared Function pixcmapGetRGBA32(cmap as IntPTR, index as Integer, pval32 as UInteger) as Integer
End Function

' SRC\colormap.c (851, 1)
' pixcmapResetColor()
' pixcmapResetColor(PIXCMAP *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This resets sets the color of an entry that has already
'''  * been set and included in the count of colors.
'''  *   (2) The alpha component is 255 (opaque)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 if not accessible caller should check</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="index"> \param[in]    index</param>
''' <param name="rval"> \param[in]    rval, gval, bval colormap entry to be reset; each number</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapResetColor")> _
Friend Shared Function pixcmapResetColor(cmap as IntPTR, index as Integer, rval as Integer, gval as Integer, bval as Integer) as Integer
End Function

' SRC\colormap.c (892, 1)
' pixcmapSetAlpha()
' pixcmapSetAlpha(PIXCMAP *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This modifies the transparency of one entry in a colormap.
'''  * The alpha component by default is 255 (opaque).
'''  * This is used when extracting the colormap from a PNG file
'''  * without decoding the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="index"> \param[in]    index</param>
''' <param name="aval"> \param[in]    aval in range [0, ... 255]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapSetAlpha")> _
Friend Shared Function pixcmapSetAlpha(cmap as IntPTR, index as Integer, aval as Integer) as Integer
End Function

' SRC\colormap.c (921, 1)
' pixcmapGetIndex()
' pixcmapGetIndex(PIXCMAP *, l_int32, l_int32, l_int32, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if found, 1 if not found caller must check</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="rval"> \param[in]    rval, gval, bval colormap colors to search for; each number</param>
''' <param name="gval"> \param[out]   pindex found index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetIndex")> _
Friend Shared Function pixcmapGetIndex(cmap as IntPTR, rval as Integer, gval as Integer, bval as Integer, pindex as Integer) as Integer
End Function

' SRC\colormap.c (960, 1)
' pixcmapHasColor()
' pixcmapHasColor(PIXCMAP *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="pcolor"> \param[out]   pcolor TRUE if cmap has color; FALSE otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapHasColor")> _
Friend Shared Function pixcmapHasColor(cmap as IntPTR, pcolor as Integer) as Integer
End Function

' SRC\colormap.c (999, 1)
' pixcmapIsOpaque()
' pixcmapIsOpaque(PIXCMAP *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="popaque"> \param[out]   popaque TRUE if fully opaque: all entries are 255</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapIsOpaque")> _
Friend Shared Function pixcmapIsOpaque(cmap as IntPTR, popaque as Integer) as Integer
End Function

' SRC\colormap.c (1034, 1)
' pixcmapIsBlackAndWhite()
' pixcmapIsBlackAndWhite(PIXCMAP *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="pblackwhite"> \param[out]   pblackwhite TRUE if the cmap has only two colors:</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapIsBlackAndWhite")> _
Friend Shared Function pixcmapIsBlackAndWhite(cmap as IntPTR, pblackwhite as Integer) as Integer
End Function

' SRC\colormap.c (1075, 1)
' pixcmapCountGrayColors()
' pixcmapCountGrayColors(PIXCMAP *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This counts the unique gray colors, including black and white.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="pngray"> \param[out]   pngray number of gray colors</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapCountGrayColors")> _
Friend Shared Function pixcmapCountGrayColors(cmap as IntPTR, pngray as Integer) as Integer
End Function

' SRC\colormap.c (1116, 1)
' pixcmapGetRankIntensity()
' pixcmapGetRankIntensity(PIXCMAP *, l_float32, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="rankval"> \param[in]    rankval 0.0 for darkest, 1.0 for lightest color</param>
''' <param name="pindex"> \param[out]   pindex the index into the colormap that</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetRankIntensity")> _
Friend Shared Function pixcmapGetRankIntensity(cmap as IntPTR, rankval as single, pindex as Integer) as Integer
End Function

' SRC\colormap.c (1167, 1)
' pixcmapGetNearestIndex()
' pixcmapGetNearestIndex(PIXCMAP *, l_int32, l_int32, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Returns the index of the exact color if possible, otherwise the
'''  * index of the color closest to the target color.
'''  *   (2) Nearest color is that which is the least sum-of-squares distance
'''  * from the target color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error caller must check</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="rval"> \param[in]    rval, gval, bval colormap colors to search for; each number</param>
''' <param name="gval"> \param[out]   pindex the index of the nearest color</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetNearestIndex")> _
Friend Shared Function pixcmapGetNearestIndex(cmap as IntPTR, rval as Integer, gval as Integer, bval as Integer, pindex as Integer) as Integer
End Function

' SRC\colormap.c (1225, 1)
' pixcmapGetNearestGrayIndex()
' pixcmapGetNearestGrayIndex(PIXCMAP *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This should be used on gray colormaps.  It uses only the
'''  * green value of the colormap.
'''  *   (2) Returns the index of the exact color if possible, otherwise the
'''  * index of the color closest to the target color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error caller must check</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="val"> \param[in]    val gray value to search for; in range [0, ... 255]</param>
''' <param name="pindex"> \param[out]   pindex the index of the nearest color</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetNearestGrayIndex")> _
Friend Shared Function pixcmapGetNearestGrayIndex(cmap as IntPTR, val as Integer, pindex as Integer) as Integer
End Function

' SRC\colormap.c (1278, 1)
' pixcmapGetDistanceToColor()
' pixcmapGetDistanceToColor(PIXCMAP *, l_int32, l_int32, l_int32, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Returns the L2 distance (squared) between the color at index i
'''  * and the target color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="index"> \param[in]    index</param>
''' <param name="rval"> \param[in]    rval, gval, bval target color</param>
''' <param name="gval"> \param[out]   pdist the distance from the cmap entry to target</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetDistanceToColor")> _
Friend Shared Function pixcmapGetDistanceToColor(cmap as IntPTR, index as Integer, rval as Integer, gval as Integer, bval as Integer, pdist as Integer) as Integer
End Function

' SRC\colormap.c (1334, 1)
' pixcmapGetRangeValues()
' pixcmapGetRangeValues(PIXCMAP *, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Returns, for selected components (or the average), the
'''  * the extreme values (min and/or max) and their indices
'''  * that are found in the cmap.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="_select_"> \param[in]    select L_SELECT_RED, L_SELECT_GREEN, L_SELECT_BLUE or</param>
''' <param name="pminval"> \param[out]   pminval [optional] minimum value of component</param>
''' <param name="pmaxval"> \param[out]   pmaxval [optional] maximum value of component</param>
''' <param name="pminindex"> \param[out]   pminindex [optional] index of minimum value</param>
''' <param name="pmaxindex"> \param[out]   pmaxindex [optional] index of maximum value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGetRangeValues")> _
Friend Shared Function pixcmapGetRangeValues(cmap as IntPTR, _select_ as Integer, pminval as Integer, pmaxval as Integer, pminindex as Integer, pmaxindex as Integer) as Integer
End Function

' SRC\colormap.c (1430, 1)
' pixcmapGrayToColor()
' pixcmapGrayToColor(l_uint32) as PIXCMAP *
''' <summary>
''' * Notes:
'''  *   (1) This creates a colormap that maps from gray to
'''  * a specific color.  In the mapping, each component
'''  * is faded to white, depending on the gray value.
'''  *   (2) In use, this is simply attached to a grayscale pix
'''  * to give it the input color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmap, or NULL on error</returns>
''' <param name="color"> \param[in]    color</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGrayToColor")> _
Friend Shared Function pixcmapGrayToColor(color as UInteger) as IntPTR
End Function

' SRC\colormap.c (1462, 1)
' pixcmapColorToGray()
' pixcmapColorToGray(PIXCMAP *, l_float32, l_float32, l_float32) as PIXCMAP *
''' <summary>
''' * Notes:
'''  *   (1) This creates a gray colormap from an arbitrary colormap.
'''  *   (2) In use, attach the output gray colormap to the pix
'''  * (or a copy of it) that provided the input colormap.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmap gray, or NULL on error</returns>
''' <param name="cmaps"> \param[in]    cmaps</param>
''' <param name="rwt"> \param[in]    rwt, gwt, bwt  non-negative; these should add to 1.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapColorToGray")> _
Friend Shared Function pixcmapColorToGray(cmaps as IntPTR, rwt as single, gwt as single, bwt as single) as IntPTR
End Function

' SRC\colormap.c (1518, 1)
' pixcmapConvertTo4()
' pixcmapConvertTo4(PIXCMAP *) as PIXCMAP *
''' <summary>
''' * Notes:
'''  *   (1) This converts a 2 bpp colormap to 4 bpp.  The colors
'''  * are the same; the output colormap entry array has size 16.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmapd   (4 bpp)</returns>
''' <param name="cmaps"> \param[in]    cmaps   colormap for 2 bpp pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapConvertTo4")> _
Friend Shared Function pixcmapConvertTo4(cmaps as IntPTR) as IntPTR
End Function

' SRC\colormap.c (1553, 1)
' pixcmapConvertTo8()
' pixcmapConvertTo8(PIXCMAP *) as PIXCMAP *
''' <summary>
''' * Notes:
'''  *   (1) This converts a 2 bpp or 4 bpp colormap to 8 bpp.  The colors
'''  * are the same; the output colormap entry array has size 256.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmapd   (8 bpp)</returns>
''' <param name="cmaps"> \param[in]    cmaps   colormap for 2 bpp or 4 bpp pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapConvertTo8")> _
Friend Shared Function pixcmapConvertTo8(cmaps as IntPTR) as IntPTR
End Function

' SRC\colormap.c (1587, 1)
' pixcmapRead()
' pixcmapRead(const char *) as PIXCMAP *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmap, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapRead")> _
Friend Shared Function pixcmapRead(filename as String) as IntPTR
End Function

' SRC\colormap.c (1614, 1)
' pixcmapReadStream()
' pixcmapReadStream(FILE *) as PIXCMAP *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmap, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapReadStream")> _
Friend Shared Function pixcmapReadStream(fp as Object) as IntPTR
End Function

' SRC\colormap.c (1655, 1)
' pixcmapReadMem()
' pixcmapReadMem(const l_uint8 *, size_t) as PIXCMAP *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmap, or NULL on error</returns>
''' <param name="data"> \param[in]    data  serialization of pixcmap; in ascii</param>
''' <param name="size"> \param[in]    size  of data in bytes; can use strlen to get it</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapReadMem")> _
Friend Shared Function pixcmapReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\colormap.c (1683, 1)
' pixcmapWrite()
' pixcmapWrite(const char *, PIXCMAP *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="cmap"> \param[in]    cmap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapWrite")> _
Friend Shared Function pixcmapWrite(filename as String, cmap as IntPTR) as Integer
End Function

' SRC\colormap.c (1715, 1)
' pixcmapWriteStream()
' pixcmapWriteStream(FILE *, PIXCMAP *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="cmap">   \param[in]    cmap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapWriteStream")> _
Friend Shared Function pixcmapWriteStream(fp as Object, cmap as IntPTR) as Integer
End Function

' SRC\colormap.c (1761, 1)
' pixcmapWriteMem()
' pixcmapWriteMem(l_uint8 **, size_t *, PIXCMAP *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a pixcmap in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of serialized pixcmap; ascii</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="cmap"> \param[in]    cmap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapWriteMem")> _
Friend Shared Function pixcmapWriteMem(pdata as Object, psize as ULong, cmap as IntPTR) as Integer
End Function

' SRC\colormap.c (1813, 1)
' pixcmapToArrays()
' pixcmapToArrays(PIXCMAP *, l_int32 **, l_int32 **, l_int32 **, l_int32 **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap colormap</param>
''' <param name="prmap"> \param[out]   prmap, pgmap, pbmap  colormap arrays</param>
''' <param name="pgmap"> \param[out]   pamap [optional] alpha array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapToArrays")> _
Friend Shared Function pixcmapToArrays(cmap as IntPTR, prmap as Object, pgmap as Object, pbmap as Object, pamap as Object) as Integer
End Function

' SRC\colormap.c (1867, 1)
' pixcmapToRGBTable()
' pixcmapToRGBTable(PIXCMAP *, l_uint32 **, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap colormap</param>
''' <param name="ptab"> \param[out]   ptab table of rgba values for the colormap</param>
''' <param name="pncolors"> \param[out]   pncolors [optional] size of table</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapToRGBTable")> _
Friend Shared Function pixcmapToRGBTable(cmap as IntPTR, ptab as Object, pncolors as Integer) as Integer
End Function

' SRC\colormap.c (1912, 1)
' pixcmapSerializeToMemory()
' pixcmapSerializeToMemory(PIXCMAP *, l_int32, l_int32 *, l_uint8 **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) When serializing to store in a pdf, use %cpc = 3.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap colormap</param>
''' <param name="cpc"> \param[in]    cpc components/color: 3 for rgb, 4 for rgba</param>
''' <param name="pncolors"> \param[out]   pncolors number of colors in table</param>
''' <param name="pdata"> \param[out]   pdata binary string, cpc bytes per color</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapSerializeToMemory")> _
Friend Shared Function pixcmapSerializeToMemory(cmap as IntPTR, cpc as Integer, pncolors as Integer, pdata as Object) as Integer
End Function

' SRC\colormap.c (1960, 1)
' pixcmapDeserializeFromMemory()
' pixcmapDeserializeFromMemory(l_uint8 *, l_int32, l_int32) as PIXCMAP *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmap, or NULL on error</returns>
''' <param name="data"> \param[in]    data binary string, 3 or 4 bytes per color</param>
''' <param name="cpc"> \param[in]    cpc components/color: 3 for rgb, 4 for rgba</param>
''' <param name="ncolors"> \param[in]    ncolors</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapDeserializeFromMemory")> _
Friend Shared Function pixcmapDeserializeFromMemory(data as Byte, cpc as Integer, ncolors as Integer) as IntPTR
End Function

' SRC\colormap.c (2021, 1)
' pixcmapConvertToHex()
' pixcmapConvertToHex(l_uint8 *, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) The number of bytes in %data is 3 * ncolors.
'''  *   (2) Output is in form:
'''  *  r0g0b0 r1g1b1 ... rngnbn >
'''  * where r0, g0, b0 ... are each 2 bytes of hex ascii
'''  *   (3) This is used in pdf files to express the colormap as an
'''  * array in ascii (human-readable) format.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  hexdata bracketed, space-separated ascii hex string,</returns>
''' <param name="data"> \param[in]    data  binary serialized data</param>
''' <param name="ncolors"> \param[in]    ncolors in colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapConvertToHex")> _
Friend Shared Function pixcmapConvertToHex(data as Byte, ncolors as Integer) as String
End Function

' SRC\colormap.c (2079, 1)
' pixcmapGammaTRC()
' pixcmapGammaTRC(PIXCMAP *, l_float32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place transform
'''  *   (2) See pixGammaTRC() and numaGammaTRC() in enhance.c
'''  * for description and use of transform
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap colormap</param>
''' <param name="gamma"> \param[in]    gamma gamma correction; must be > 0.0</param>
''' <param name="minval"> \param[in]    minval  input value that gives 0 for output; can be < 0</param>
''' <param name="maxval"> \param[in]    maxval  input value that gives 255 for output; can be > 255</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGammaTRC")> _
Friend Shared Function pixcmapGammaTRC(cmap as IntPTR, gamma as single, minval as Integer, maxval as Integer) as Integer
End Function

' SRC\colormap.c (2134, 1)
' pixcmapContrastTRC()
' pixcmapContrastTRC(PIXCMAP *, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place transform
'''  *   (2) See pixContrastTRC() and numaContrastTRC() in enhance.c
'''  * for description and use of transform
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap colormap</param>
''' <param name="factor"> \param[in]    factor generally between 0.0 [no enhancement]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapContrastTRC")> _
Friend Shared Function pixcmapContrastTRC(cmap as IntPTR, factor as single) as Integer
End Function

' SRC\colormap.c (2186, 1)
' pixcmapShiftIntensity()
' pixcmapShiftIntensity(PIXCMAP *, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place transform
'''  *   (2) It does a proportional shift of the intensity for each color.
'''  *   (3) If fraction  0.0, it moves all colors towards (0,0,0).
'''  * This darkens the image.
'''  * If fraction > 0.0, it moves all colors towards (255,255,255)
'''  * This fades the image.
'''  *   (4) The equivalent transform can be accomplished with pixcmapGammaTRC(),
'''  * but it is considerably more difficult (see numaGammaTRC()).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap colormap</param>
''' <param name="fraction"> \param[in]    fraction between -1.0 and +1.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapShiftIntensity")> _
Friend Shared Function pixcmapShiftIntensity(cmap as IntPTR, fraction as single) as Integer
End Function

' SRC\colormap.c (2236, 1)
' pixcmapShiftByComponent()
' pixcmapShiftByComponent(PIXCMAP *, l_uint32, l_uint32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place transform
'''  *   (2) It implements pixelShiftByComponent() for each color.
'''  * The mapping is specified by srcval and dstval.
'''  *   (3) If a component decreases, the component in the colormap
'''  * decreases by the same ratio.  Likewise for increasing, except
'''  * all ratios are taken with respect to the distance from 255.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap colormap</param>
''' <param name="srcval"> \param[in]    srcval source color: 0xrrggbb00</param>
''' <param name="dstval"> \param[in]    dstval target color: 0xrrggbb00</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapShiftByComponent")> _
Friend Shared Function pixcmapShiftByComponent(cmap as IntPTR, srcval as UInteger, dstval as UInteger) as Integer
End Function

#End Region
#Region "SRC\colormorph.c"
' SRC\colormorph.c (66, 1)
' pixColorMorph()
' pixColorMorph(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does the morph operation on each component separately,
'''  * and recombines the result.
'''  *   (2) Sel is a brick with all elements being hits.
'''  *   (3) If hsize = vsize = 1, just returns a copy.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="type"> \param[in]    type  L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN,</param>
''' <param name="hsize"> \param[in]    hsize  of Sel; must be odd; origin implicitly in center</param>
''' <param name="vsize"> \param[in]    vsize  ditto</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorMorph")> _
Friend Shared Function pixColorMorph(pixs as IntPTR, type as Integer, hsize as Integer, vsize as Integer) as IntPTR
End Function

#End Region
#Region "SRC\colorquant1.c"
' SRC\colorquant1.c (232, 16)
' octreeFindColorCell()
' octreeFindColorCell(l_int32, CQCELL ***, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) As this is in inner loop, we don't check input pointers!
'''  *   (2) This traverses from the root (well, actually from level 2,
'''  * because the level 2 cubes are the largest CTE cubes),
'''  * and finds the index number of the cell and the color values,
'''  * which can be used either directly or in a (Floyd-Steinberg)
'''  * error-diffusion dithering algorithm.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="octindex"> \param[in]    octindex</param>
''' <param name="cqcaa"> \param[in]    cqcaa</param>
''' <param name="pindex"> \param[out]   pindex   index of CTE; returned to set pixel value</param>
''' <param name="prval"> \param[out]   prval    of CTE</param>
''' <param name="pgval"> \param[out]   pgval    of CTE</param>
''' <param name="pbval"> \param[out]   pbval    of CTE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="octreeFindColorCell")> _
Friend Shared Function octreeFindColorCell(octindex as Integer, cqcaa as Object, pindex as Integer, prval as Integer, pgval as Integer, pbval as Integer) as Integer
End Function

' SRC\colorquant1.c (237, 18)
' octreeGenerateAndPrune()
' octreeGenerateAndPrune(PIX *, l_int32, l_int32, PIXCMAP **) as CQCELL ***
''' <summary>
''' * Notes:
'''  *   (1) The number of colors in the cmap may differ from the number
'''  * of colors requested, but it will not be larger than 256
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  octree, colormap and number of colors used, or NULL</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="colors"> \param[in]    colors number of colors to use between 128 and 256</param>
''' <param name="reservedcolors"> \param[in]    reservedcolors number of reserved colors</param>
''' <param name="pcmap"> \param[out]   pcmap  made and returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="octreeGenerateAndPrune")> _
Friend Shared Function octreeGenerateAndPrune(pixs as IntPTR, colors as Integer, reservedcolors as Integer, pcmap as Object) as String
End Function

' SRC\colorquant1.c (240, 13)
' pixOctreeQuantizePixels()
' pixOctreeQuantizePixels(PIX *, CQCELL ***, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This routine doesn't need to use the CTEs (colormap
'''  * table entries) because the color indices are embedded
'''  * in the octree.  Thus, the calling program must make
'''  * and attach the colormap to pixd after it is returned.
'''  *   (2) Dithering is performed in integers, effectively rounding
'''  * to 1/8 sample increment.  The data in the integer buffers is
'''  * 64 times the sample values.  The 'dif' is 8 times the
'''  * sample values, and this spread, multiplied by 8, to the
'''  * integer buffers.  Because the dif is truncated to an
'''  * integer, the dither is accurate to 1/8 of a sample increment,
'''  * or 1/2048 of the color range.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="cqcaa"> \param[in]    cqcaa octree in array format</param>
''' <param name="ditherflag"> \param[in]    ditherflag 1 for dithering, 0 for no dithering</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOctreeQuantizePixels")> _
Friend Shared Function pixOctreeQuantizePixels(pixs as IntPTR, cqcaa as Object, ditherflag as Integer) as IntPTR
End Function

' SRC\colorquant1.c (242, 18)
' cqcellTreeCreate()
' cqcellTreeCreate() as CQCELL ***
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cqcell array tree</returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="cqcellTreeCreate")> _
Friend Shared Function cqcellTreeCreate() as String
End Function

' SRC\colorquant1.c (243, 13)
' cqcellTreeDestroy()
' cqcellTreeDestroy(CQCELL ****) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="pcqcaa"> \param[in,out]   pcqcaa to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="cqcellTreeDestroy")> _
Friend Shared Function cqcellTreeDestroy(pcqcaa as Object) as Boolean ' Org. Void
End Function

' SRC\colorquant1.c (246, 13)
' getRGBFromOctcube()
' getRGBFromOctcube(l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *) as void
''' <summary>
''' * Notes:
'''  *   (1) We can consider all octcube indices to represent a
'''  * specific point in color space: namely, the location
'''  * of the 'upper-left' corner of the cube, where indices
'''  * increase down and to the right.  The upper left corner
'''  * of the color space is then 00000....
'''  *   (2) The 'rgbindex' is a 24-bit representation of the location,
'''  * in octcube notation, at the center of the octcube.
'''  * To get to the center of an octcube, you choose the 111
'''  * octcube at the next lower level.
'''  *   (3) For example, if the octcube index = 110101 (binary),
'''  * which is a level 2 expression, then the rgbindex
'''  * is the 24-bit representation of 110101111 (at level 3);
'''  * namely, 000110101111000000000000.  The number is padded
'''  * with 3 leading 0s (because the representation uses
'''  * only 21 bits) and 12 trailing 0s (the default for
'''  * levels 4-7, which are contained within each of the level3
'''  * octcubes.  Then the rgb values for the center of the
'''  * octcube are: rval = 11100000, gval = 10100000, bval = 01100000
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="cubeindex"> \param[in]    cubeindex octcube index</param>
''' <param name="level"> \param[in]    level at which index is expressed</param>
''' <param name="prval"> \param[out]   prval  r val of this cube</param>
''' <param name="pgval"> \param[out]   pgval  g val of this cube</param>
''' <param name="pbval"> \param[out]   pbval  b val of this cube</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getRGBFromOctcube")> _
Friend Shared Function getRGBFromOctcube(cubeindex as Integer, level as Integer, prval as Integer, pgval as Integer, pbval as Integer) as Boolean ' Org. Void
End Function

' SRC\colorquant1.c (248, 16)
' getOctcubeIndices()
' getOctcubeIndices(l_int32, l_int32, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *  for CQ_NLEVELS = 6, the full RGB index is in the form:
'''  *  index = (0[13] 0 r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3 r2 g2 b2)
'''  *  for CQ_NLEVELS = 5, the full RGB index is in the form:
'''  *  index = (0[16] 0 r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3)
'''  *  for CQ_NLEVELS = 4, the full RGB index is in the form:
'''  *  index = (0[19] 0 r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4)
'''  *
'''  *  The base index is the index of the octcube at the level given,
'''  *  whereas the sub index is the index at the next level down.
'''  *
'''  *  For level 0: base index = 0
'''  *   sub index is the 3 bit number (r7 g7 b7)
'''  *  For level 1: base index = (r7 g7 b7)
'''  *   sub index = (r7 g7 b7 r6 g6 b6)
'''  *  For level 2: base index = (r7 g7 b7 r6 g6 b6)
'''  *   sub index = (r7 g7 b7 r6 g6 b6 r5 g5 b5)
'''  *  For level 3: base index = (r7 g7 b7 r6 g6 b6 r5 g5 b5)
'''  *   sub index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4)
'''  *  For level 4: base index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4)
'''  *   sub index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3)
'''  *  For level 5: base index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3)
'''  *   sub index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3
'''  *    r2 g2 b2)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="rgbindex"> \param[in]    rgbindex</param>
''' <param name="level"> \param[in]    level octree level 0, 1, 2, 3, 4, 5</param>
''' <param name="pbindex"> \param[out]   pbindex base index index at the octree level</param>
''' <param name="psindex"> \param[out]   psindex sub index index at the next lower level</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getOctcubeIndices")> _
Friend Shared Function getOctcubeIndices(rgbindex as Integer, level as Integer, pbindex as Integer, psindex as Integer) as Integer
End Function

' SRC\colorquant1.c (250, 16)
' octcubeGetCount()
' octcubeGetCount(l_int32, l_int32 *) as l_int32
''' <summary>
''' *  level:   1  2  3  4  5  6
'''  *  size: 8 64 512  4098  32784   262272
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   0 if OK, 1 on error.  Caller must check!</returns>
''' <param name="level"> \param[in]    level valid values are in [1,...6]; there are 2^level</param>
''' <param name="psize"> \param[out]   psize 2^(3  level) cubes in the entire rgb cube</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="octcubeGetCount")> _
Friend Shared Function octcubeGetCount(level as Integer, psize as Integer) as Integer
End Function

' SRC\colorquant1.c (253, 16)
' pixDitherOctindexWithCmap()
' pixDitherOctindexWithCmap(PIX *, PIX *, l_uint32 *, l_uint32 *, l_uint32 *, l_int32 *, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This performs dithering to generate the colormap indices
'''  * in pixd.  The colormap has been calculated, along with
'''  * four input LUTs that together give the inverse colormapping
'''  * from RGB to colormap index.
'''  *   (2) For pixOctreeQuantByPopulation(), %indexmap maps from the
'''  * standard octindex to colormap index (after subtracting 1).
'''  * The basic pixel-level function, without dithering, is:
'''  * extractRGBValues(lines[j], &rval, &gval, &bval);
'''  * octindex = rtab[rval] | gtab[gval] | btab[bval];
'''  * SET_DATA_BYTE(lined, j, indexmap[octindex] - 1);
'''  *   (3) This can be used in any situation where the general
'''  * prescription for finding the colormap index from the rgb
'''  * value is precisely this:
'''  * cmapindex = indexmap[rtab[rval] | gtab[gval] | btab[bval]] - 1
'''  * For example, in pixFixedOctcubeQuant256(), we don't use
'''  * standard octcube indexing, the rtab (etc) LUTs map directly
'''  * to the colormap index, and %indexmap just compensates for
'''  * the 1-off indexing assumed to be in that table.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="pixd"> \param[in]    pixd 8 bpp cmapped</param>
''' <param name="rtab"> \param[in]    rtab, gtab, btab tables from rval to octindex</param>
''' <param name="gtab"> \param[in]    indexmap array mapping octindex to cmap index</param>
''' <param name="btab"> \param[in]    difcap max allowed dither transfer; use 0 for infinite cap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDitherOctindexWithCmap")> _
Friend Shared Function pixDitherOctindexWithCmap(pixs as IntPTR, pixd as IntPTR, rtab as UInteger, gtab as UInteger, btab as UInteger, carray as Integer, difcap as Integer) as Integer
End Function

' SRC\colorquant1.c (258, 13)
' pixOctcubeQuantFromCmapLUT()
' pixOctcubeQuantFromCmapLUT(PIX *, PIXCMAP *, l_int32, l_int32 *, l_uint32 *, l_uint32 *, l_uint32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See the notes in the higher-level function
'''  * pixOctcubeQuantFromCmap().  The octcube level for
'''  * the generated octree is specified there, along with
'''  * the distance metric for determining the closest
'''  * color in the colormap to each octcube.
'''  *   (2) If the colormap, level and metric information have already
'''  * been used to construct the set of mapping tables,
'''  * this low-level function can be used directly (i.e.,
'''  * independently of pixOctcubeQuantFromCmap()) to build
'''  * a colormapped pix that uses the specified colormap.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd  2, 4 or 8 bpp, colormapped, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp rgb</param>
''' <param name="cmap"> \param[in]    cmap  to quantize to; insert copy into dest pix</param>
''' <param name="mindepth"> \param[in]    mindepth minimum depth of pixd: can be 2, 4 or 8 bpp</param>
''' <param name="cmaptab"> \param[in]    cmaptab  table mapping from octindex to colormap index</param>
''' <param name="rtab"> \param[in]    rtab, gtab, btab tables mapping from RGB to octindex</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOctcubeQuantFromCmapLUT")> _
Friend Shared Function pixOctcubeQuantFromCmapLUT(pixs as IntPTR, cmap as IntPTR, mindepth as Integer, cmaptab as Integer, rtab as UInteger, gtab as UInteger, btab as UInteger) as IntPTR
End Function

' SRC\colorquant1.c (535, 1)
' pixOctreeColorQuant()
' pixOctreeColorQuant(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' *  I found one description in the literature of octree color
'''  *  quantization, using progressive truncation of the octree,
'''  *  by M. Gervautz and W. Purgathofer in Graphics Gems, pp.
'''  *  287-293, ed. A. Glassner, Academic Press, 1990.
'''  *  Rather than setting up a fixed partitioning of the color
'''  *  space ab initio, as we do here, they allow the octree to be
'''  *  progressively truncated as new pixels are added.  They
'''  *  need to set up some data structures that are traversed
'''  *  with the addition of each 24 bit pixel, in order to decide
'''  *  either 1) in which cluster (sub-branch of the octree to put
'''  *  the pixel, or 2 whether to truncate the octree further
'''  *  to place the pixel in an existing cluster, or 3 which
'''  *  two existing clusters should be merged so that the pixel
'''  *  can be left to start a truncated leaf of the octree.  Such dynamic
'''  *  truncation is considerably more complicated, and Gervautz et
'''  *  al. did not explain how they did it in anywhere near the
'''  *  detail required to check their implementation.
'''  *
'''  *  The simple method in pixFixedOctcubeQuant256 is very
'''  *  fast, and with dithering the results are good, but you
'''  *  can do better if the color clusters are selected adaptively
'''  *  from the image.  We want a method that makes much better
'''  *  use of color samples in regions of color space with high
'''  *  pixel density, while also fairly representing small numbers
'''  *  of color pixels in low density regions.  Such adaptation
'''  *  requires two passes through the image: the first for generating
'''  *  the pruned tree of color cubes and the second for computing the index
'''  *  into the color table for each pixel.
'''  *
'''  *  A relatively simple adaptive method is pixOctreeQuantByPopulation.
'''  *  That function first determines if the image has very few colors,
'''  *  and, if so, quantizes to those colors.  If there are more than
'''  *  256 colors, it generates a histogram of octcube leaf occupancy
'''  *  at level 4, chooses the 192 most populated such leaves as
'''  *  the first 192 colors, and sets the remaining 64 colors to the
'''  *  residual average pixel values in each of the 64 level 2 octcubes.
'''  *  This is a bit faster than pixOctreeColorQuant, and does very
'''  *  well without dithering, but for most images with dithering it
'''  *  is clearly inferior.
'''  *
'''  *  We now describe pixOctreeColorQuant.  The first pass is done
'''  *  on a subsampled image, because we do not need to use all the
'''  *  pixels in the image to generate the tree.  Subsampling
'''  *  down to 0.25 1/16 of the pixels makes the program run
'''  *  about 1.3 times faster.
'''  *
'''  *  Instead of dividing the color space into 256 equal-sized
'''  *  regions, we initially divide it into 2^12 or 2^15 or 2^18
'''  *  equal-sized octcubes.  Suppose we choose to use 2^18 octcubes.
'''  *  This gives us 6 octree levels.  We then prune back,
'''  *  starting from level 6.  For every cube at level 6, there
'''  *  are 8 cubes at level 5.  Call the operation of putting a
'''  *  cube aside as a color table entry CTE a "saving."
'''  *  We use a in general level-dependent threshold, and save
'''  *  those level 6 cubes that are above threshold.
'''  *  The rest are combined into the containing level 5 cube.
'''  *  If between 1 and 7 level 6 cubes within a level 5
'''  *  cube have been saved by thresholding, then the remaining
'''  *  level 6 cubes in that level 5 cube are automatically
'''  *  saved as well, without applying a threshold.  This greatly
'''  *  simplifies both the description of the CTEs and the later
'''  *  classification of each pixel as belonging to a CTE.
'''  *  This procedure is iterated through every cube, starting at
'''  *  level 5, and then 4, 3, and 2, successively.  The result is that
'''  *  each CTE contains the entirety of a set of from 1 to 7 cubes
'''  *  from a given level that all belong to a single cube at the
'''  *  level above.   We classify the CTEs in terms of the
'''  *  condition in which they are made as either being "threshold"
'''  *  or "residual."  They are "threshold" CTEs if no subcubes
'''  *  are CTEs that is, they contain every pixel within the cube
'''  *  and the number of pixels exceeds the threshold for making
'''  *  a CTE.  They are "residual" CTEs if at least one but not more
'''  *  than 7 of the subcubes have already been determined to be CTEs;
'''  *  this happens automatically -- no threshold is applied.
'''  *  If all 8 subcubes are determined to be CTEs, the cube is
'''  *  marked as having all pixels accounted for 'bleaf' = 1 but
'''  *  is not saved as a CTE.
'''  *
'''  *  We stop the pruning at level 2, at which there are 64
'''  *  sub-cubes.  Any pixels not already claimed in a CTE are
'''  *  put in these cubes.
'''  *
'''  *  As the cubes are saved as color samples in the color table,
'''  *  the number of remaining pixels P and the number of
'''  *  remaining colors in the color table N are recomputed,
'''  *  along with the average number of pixels P/N ppc to go in
'''  *  each of the remaining colors.  This running average number is
'''  *  used to set the threshold at the current level.
'''  *
'''  *  Because we are going to very small cubes at levels 6 or 5,
'''  *  and will dither the colors for errors, it is not necessary
'''  *  to compute the color center of each cluster; we can simply
'''  *  use the center of the cube.  This gives us a minimax error
'''  *  condition: the maximum error is half the width of the
'''  *  level 2 cubes -- 32 color values out of 256 -- for each color
'''  *  sample.  In practice, most of the pixels will be very much
'''  *  closer to the center of their cells.  And with dithering,
'''  *  the average pixel color in a small region will be closer still.
'''  *  Thus with the octree quantizer, we are able to capture
'''  *  regions of high color pdf probability density function in small
'''  *  but accurate CTEs, and to have only a small number of pixels
'''  *  that end up a significant distance with a guaranteed maximum
'''  *  from their true color.
'''  *
'''  *  How should the threshold factor vary?  Threshold factors
'''  *  are required for levels 2, 3, 4 and 5 in the pruning stage.
'''  *  The threshold for level 5 is actually applied to cubes at
'''  *  level 6, etc.  From various experiments, it appears that
'''  *  the results do not vary appreciably for threshold values near 1.0.
'''  *  If you want more colors in smaller cubes, the threshold
'''  *  factors can be set lower than 1.0 for cubes at levels 4 and 5.
'''  *  However, if the factor is set much lower than 1.0 for
'''  *  levels 2 and 3, we can easily run out of colors.
'''  *  We put aside 64 colors in the calculation of the threshold
'''  *  values, because we must have 64 color centers at level 2,
'''  *  that will have very few pixels in most of them.
'''  *  If we reduce the factor for level 5 to 0.4, this will
'''  *  generate many level 6 CTEs, and consequently
'''  *  many residual cells will be formed up from those leaves,
'''  *  resulting in the possibility of running out of colors.
'''  *  Remember, the residual CTEs are mandatory, and are formed
'''  *  without using the threshold, regardless of the number of
'''  *  pixels that are absorbed.
'''  *
'''  *  The implementation logically has four parts:
'''  *
'''  * 1 accumulation into small, fixed cells
'''  * 2 pruning back into selected CTE cubes
'''  * 3 organizing the CTEs for fast search to find
'''  *  the CTE to which any image pixel belongs
'''  * 4 doing a second scan to code the image pixels by CTE
'''  *
'''  *  Step 1 is straightforward; we use 2^15 cells.
'''  *
'''  *  We've already discussed how the pruning step 2 will be performed.
'''  *
'''  *  Steps 3) and (4 are related, in that the organization
'''  *  used by step 3 determines how the search actually
'''  *  takes place for each pixel in step 4.
'''  *
'''  *  There are many ways to do step 3.  Let's explore a few.
'''  *
'''  *  a The simplest is to order the cubes from highest occupancy
'''  *   to lowest, and traverse the list looking for the deepest
'''  *   match.  To make this more efficient, so that we know when
'''  *   to stop looking, any cube that has separate CTE subcubes
'''  *   would be marked as such, so that we know when we hit a
'''  *   true leaf.
'''  *
'''  *  b Alternatively, we can order the cubes by highest
'''  *   occupancy separately each level, and work upward,
'''  *   starting at level 5, so that when we find a match we
'''  *   know that it will be correct.
'''  *
'''  *  c Another approach would be to order the cubes by
'''  *   "address" and use a hash table to find the cube
'''  *   corresponding to a pixel color.  I don't know how to
'''  *   do this with a variable length address, as each CTE
'''  *   will have 3*n bits, where n is the level.
'''  *
'''  *  d Another approach entirely is to put the CTE cubes into
'''  *   a tree, in such a way that starting from the root, and
'''  *   using 3 bits of address at a time, the correct branch of
'''  *   each octree can be taken until a leaf is found.  Because
'''  *   a given cube can be both a leaf and also have branches
'''  *   going to sub-cubes, the search stops only when no
'''  *   marked subcubes have addresses that match the given pixel.
'''  *
'''  *   In the tree method, we can start with a dense infrastructure,
'''  *   and place the leaves corresponding to the N colors
'''  *   in the tree, or we can grow from the root only those
'''  *   branches that end directly on leaves.
'''  *
'''  *  What we do here is to take approach d, and implement the tree
'''  *  "virtually", as a set of arrays, one array for each level
'''  *  of the tree.   Initially we start at level 5, an array with
'''  *  2^15 cubes, each with 8 subcubes.  We then build nodes at
'''  *  levels closer to the root; at level 4 there are 2^12 nodes
'''  *  each with 8 subcubes; etc.  Using these arrays has
'''  *  several advantages:
'''  *
'''  *  ~  We don't need to keep track of links between cubes
'''  *  and subcubes, because we can use the canonical
'''  *  addressing on the cell arrays directly to determine
'''  *  which nodes are parent cubes and which are sub-cubes.
'''  *
'''  *  ~  We can prune directly on this tree
'''  *
'''  *  ~  We can navigate the pruned tree quickly to classify
'''  *  each pixel in the image.
'''  *
'''  *  Canonical addressing guarantees that the i-th node at level k
'''  *  has 8 subnodes given by the 8*i ... 8*i+7 nodes at level k+1.
'''  *
'''  *  The pruning step works as follows.  We go from the lowest
'''  *  level up.  At each level, the threshold is found from the
'''  *  product of a factor near 1.0 and the ratio of unmarked pixels
'''  *  to remaining colors minus the 64.  We march through
'''  *  the space, sequentially considering a cube and its 8 subcubes.
'''  *  We first check those subcubes that are not already
'''  *  marked as CTE to see if any are above threshold, and if so,
'''  *  generate a CTE and mark them as such.
'''  *  We then determine if any of the subcubes have been marked.
'''  *  If so, and there are subcubes that are not marked,
'''  *  we generate a CTE for the cube from the remaining unmarked
'''  *  subcubes; this is mandatory and does not depend on how many
'''  *  pixels are in the set of subcubes.  If none of the subcubes
'''  *  are marked, we aggregate their pixels into the cube
'''  *  containing them, but do not mark it as a CTE; that
'''  *  will be determined when iterating through the next level up.
'''  *
'''  *  When all the pixels in a cube are accounted for in one or more
'''  *  colors, we set the boolean 'bleaf' to true.  This is the
'''  *  flag used to mark the cubes in the pruning step.  If a cube
'''  *  is marked, and all 8 subcubes are marked, then it is not
'''  *  itself given a CTE because all pixels have already been
'''  *  accounted for.
'''  *
'''  *  Note that the pruning of the tree and labelling of the CTEs
'''  *  step 2 accomplishes step 3 implicitly, because the marked
'''  *  and pruned tree is ready for use in labelling each pixel
'''  *  in step 4.  We now, for every pixel in the image, traverse
'''  *  the tree from the root, looking for the lowest cube that is a leaf.
'''  *  At each level we have a cube and subcube.  If we reach a subcube
'''  *  leaf that is marked 0, we know that the color is stored in the
'''  *  cube above, and we've found the CTE.  Otherwise, the subcube
'''  *  leaf is marked 1.  If we're at the last level, we've reached
'''  *  the final leaf and must use it.  Otherwise, continue the
'''  *  process at the next level down.
'''  *
'''  *  For robustness, efficiency and high quality output, we do the following:
'''  *
'''  *  (1) Measure the color content of the image.  If there is very little
'''  *   color, quantize in grayscale.
'''  *  (2) For efficiency, build the octree with a subsampled image if the
'''  *   image is larger than some threshold size.
'''  *  (3) Reserve an extra set of colors to prevent running out of colors
'''  *   when pruning the octree; specifically, during the assignment
'''  *   of those level 2 cells out of the 64 that have unassigned
'''  *   pixels.  The problem of running out is more likely to happen
'''  *   with small images, because the estimation we use for the
'''  *   number of pixels available is not accurate.
'''  *  (4) In the unlikely event that we run out of colors, the dithered
'''  *   image can be very poor.  As this would only happen with very
'''  *   small images, and dithering is not particularly noticeable with
'''  *   such images, turn it off.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp; 24-bit color</param>
''' <param name="colors"> \param[in]    colors  in colormap; some number in range [128 ... 256];</param>
''' <param name="ditherflag"> \param[in]    ditherflag  1 to dither, 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOctreeColorQuant")> _
Friend Shared Function pixOctreeColorQuant(pixs as IntPTR, colors as Integer, ditherflag as Integer) as IntPTR
End Function

' SRC\colorquant1.c (601, 1)
' pixOctreeColorQuantGeneral()
' pixOctreeColorQuantGeneral(PIX *, l_int32, l_int32, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The parameters %validthresh and %colorthresh are used to
'''  * determine if color quantization should be used on an image,
'''  * or whether, instead, it should be quantized in grayscale.
'''  * If the image has very few non-white and non-black pixels, or
'''  * if those pixels that are non-white and non-black are all
'''  * very close to either white or black, it is usually better
'''  * to treat the color as accidental and to quantize the image
'''  * to gray only.  These parameters are useful if you know
'''  * something a priori about the image.  Perhaps you know that
'''  * there is only a very small fraction of color pixels, but they're
'''  * important to preserve; then you want to use a smaller value for
'''  * these parameters.  To disable conversion to gray and force
'''  * color quantization, use %validthresh = 0.0 and %colorthresh = 0.0.
'''  *   (2) See pixOctreeColorQuant() for algorithmic and implementation
'''  * details.  This function has a more general interface.
'''  *   (3) See pixColorFraction() for computing the fraction of pixels
'''  * that are neither white nor black, and the fraction of those
'''  * pixels that have little color.  From the documentation there:
'''  * If pixfract is very small, there are few pixels that are
'''  * neither black nor white.  If colorfract is very small,
'''  * the pixels that are neither black nor white have very
'''  * little color content.  The product 'pixfract * colorfract'
'''  * gives the fraction of pixels with significant color content.
'''  * We test against the product %validthresh * %colorthresh
'''  * to find color in images that have either very few
'''  * intermediate gray pixels or that have many such gray pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bit with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp; 24-bit color</param>
''' <param name="colors"> \param[in]    colors  in colormap; some number in range [128 ... 240];</param>
''' <param name="ditherflag"> \param[in]    ditherflag  1 to dither, 0 otherwise</param>
''' <param name="validthresh"> \param[in]    validthresh minimum fraction of pixels neither near white</param>
''' <param name="colorthresh"> \param[in]    colorthresh minimum fraction of pixels with color that are</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOctreeColorQuantGeneral")> _
Friend Shared Function pixOctreeColorQuantGeneral(pixs as IntPTR, colors as Integer, ditherflag as Integer, validthresh as single, colorthresh as single) as IntPTR
End Function

' SRC\colorquant1.c (1361, 1)
' makeRGBToIndexTables()
' makeRGBToIndexTables(l_uint32 **, l_uint32 **, l_uint32 **, l_int32) as l_ok
''' <summary>
''' *  Set up tables.  e.g., for cqlevels = 5, we need an integer 0  i  2^15:
'''  *   rtab = 0  i7  0   0  i6  0   0  i5  0   0   i4  0   0   i3  0   0
'''  *   gtab = 0  0   i7  0   0  i6  0   0  i5  0   0   i4  0   0   i3  0
'''  *   btab = 0  0   0   i7  0  0   i6  0  0   i5  0   0   i4  0   0   i3
'''  *
'''  *  The tables are then used to map from rbg --> index as follows:
'''  *   index = 0  r7  g7  b7  r6  g6  b6  r5  g5  b5  r4  g4  b4  r3  g3  b3
'''  *
'''  * e.g., for cqlevels = 4, we map to
'''  *   index = 0  0   0   0   r7  g7  b7  r6  g6  b6  r5  g5  b5  r4  g4  b4
'''  *
'''  *  This may look a bit strange.  The notation 'r7' means the MSBit of
'''  *  the r value which has 8 bits, going down from r7 to r0.
'''  *  Keep in mind that r7 is actually the r component bit for level 1 of
'''  *  the octtree.  Level 1 is composed of 8 octcubes, represented by
'''  *  the bits r7 g7 b7, which divide the entire color space into
'''  *  8 cubes.  At level 2, each of these 8 octcubes is further divided into
'''  *  8 cubes, each labeled by the second most significant bits r6 g6 b6
'''  *  of the rgb color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="prtab"> \param[out]   prtab, pgtab, pbtab  tables</param>
''' <param name="pgtab"> \param[in]    cqlevels can be 1, 2, 3, 4, 5 or 6</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeRGBToIndexTables")> _
Friend Shared Function makeRGBToIndexTables(prtab as Object, pgtab as Object, pbtab as Object, cqlevels as Integer) as Integer
End Function

' SRC\colorquant1.c (1470, 1)
' getOctcubeIndexFromRGB()
' getOctcubeIndexFromRGB(l_int32, l_int32, l_int32, l_uint32 *, l_uint32 *, l_uint32 *, l_uint32 *) as void
''' <summary>
''' * Notes:
'''  *   No error checking!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
''' <param name="gval"> \param[in]    rtab, gtab, btab  generated with makeRGBToIndexTables()</param>
''' <param name="bval"> \param[out]   pindex found index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getOctcubeIndexFromRGB")> _
Friend Shared Function getOctcubeIndexFromRGB(rval as Integer, gval as Integer, bval as Integer, rtab as UInteger, gtab as UInteger, btab as UInteger, pindex as UInteger) as Boolean ' Org. Void
End Function

' SRC\colorquant1.c (1701, 1)
' pixOctreeQuantByPopulation()
' pixOctreeQuantByPopulation(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This color quantization method works very well without
'''  * dithering, using octcubes at two different levels:
'''  *   (a) the input %level, which is either 3 or 4
'''  *   (b) level 2 (64 octcubes to cover the entire color space)
'''  *   (2) For best results, using %level = 4 is recommended.
'''  * Why do we provide an option for using level 3?  Because
'''  * there are 512 octcubes at level 3, and for many images
'''  * not more than 256 are filled.  As a result, on some images
'''  * a very accurate quantized representation is possible using
'''  * %level = 3.
'''  *   (3) This first breaks up the color space into octcubes at the
'''  * input %level, and computes, for each octcube, the average
'''  * value of the pixels that are in it.
'''  *   (4) Then there are two possible situations:
'''  *   (a) If there are not more than 256 populated octcubes,
'''  * it returns a cmapped pix with those values assigned.
'''  *   (b) Otherwise, it selects 192 octcubes containing the largest
'''  * number of pixels and quantizes pixels within those octcubes
'''  * to their average.  Then, to handle the residual pixels
'''  * that are not in those 192 octcubes, it generates a
'''  * level 2 octree consisting of 64 octcubes, and within
'''  * each octcube it quantizes the residual pixels to their
'''  * average within each of those level 2 octcubes.
'''  *   (5) Unpopulated level 2 octcubes are represented in the colormap
'''  * by their centers.  This, of course, has no effect unless
'''  * dithering is used for the output image.
'''  *   (6) The depth of pixd is the minimum required to support the
'''  * number of colors found at %level; namely, 2, 4 or 8.
'''  *   (7) This function works particularly well on images such as maps,
'''  * where there are a relatively small number of well-populated
'''  * colors, but due to antialiasing and compression artifacts
'''  * there may be a large number of different colors.  This will
'''  * pull out and represent accurately the highly populated colors,
'''  * while still making a reasonable approximation for the others.
'''  *   (8) The highest level of octcubes allowed is 4.  Use of higher
'''  * levels typically results in having a small fraction of
'''  * pixels in the most populated 192 octcubes.  As a result,
'''  * most of the pixels are represented at level 2, which is
'''  * not sufficiently accurate.
'''  *   (9) Dithering shows artifacts on some images.  If you plan to
'''  * dither, pixOctreeColorQuant() and pixFixedOctcubeQuant256()
'''  * usually give better results.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd quantized to octcubes or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="level"> \param[in]    level significant bits for each of RGB; valid for {3,4},</param>
''' <param name="ditherflag"> \param[in]    ditherflag  1 to dither, 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOctreeQuantByPopulation")> _
Friend Shared Function pixOctreeQuantByPopulation(pixs as IntPTR, level as Integer, ditherflag as Integer) as IntPTR
End Function

' SRC\colorquant1.c (2263, 1)
' pixOctreeQuantNumColors()
' pixOctreeQuantNumColors(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' *  pixOctreeColorQuant is very flexible in terms of the relative
'''  *  depth of different cubes of the octree.   By contrast, this function,
'''  *  pixOctreeQuantNumColors is also adaptive, but it supports octcube
'''  *  leaves at only two depths: a smaller depth that guarantees
'''  *  full coverage of the color space and octcubes at one level
'''  *  deeper for more accurate colors.  Its main virutes are simplicity
'''  *  and speed, which are both derived from the natural indexing of
'''  *  the octcubes from the RGB values.
'''  *
'''  *  Before describing pixOctreeQuantNumColors, consider an even simpler
'''  *  approach for 4 bpp with either 8 or 16 colors.  With 8 colors,
'''  *  you simply go to level 1 octcubes and use the average color
'''  *  found in each cube.  For 16 colors, you find which of the three
'''  *  colors has the largest variance at the second level, and use two
'''  *  indices for that color.  The result is quite poor, because 1 some
'''  *  of the cubes are nearly empty and 2 you don't get much color
'''  *  differentiation for the extra 8 colors.  Trust me, this method may
'''  *  be simple, but it isn't worth anything.
'''  *
'''  *  In pixOctreeQuantNumColors, we generate colormapped images at
'''  *  either 4 bpp or 8 bpp.  For 4 bpp, we have a minimum of 8 colors
'''  *  for the level 1 octcubes, plus up to 8 additional colors that
'''  *  are determined from the level 2 popularity.  If the number of colors
'''  *  is between 8 and 16, the output is a 4 bpp image.  If the number of
'''  *  colors is greater than 16, the output is a 8 bpp image.
'''  *
'''  *  We use a priority queue, implemented with a heap, to select the
'''  *  requisite number of most populated octcubes at the deepest level
'''  *  level 2 for 64 or fewer colors; level 3 for more than 64 colors.
'''  *  These are combined with one color for each octcube one level above,
'''  *  which is used to span the color space of octcubes that were not
'''  *  included at the deeper level.
'''  *
'''  *  If the deepest level is 2, we combine the popular level 2 octcubes
'''  *  out of a total of 64 with the 8 level 1 octcubes.  If the deepest
'''  *  level is 3, we combine the popular level 3 octcubes out of a
'''  *  total 512 with the 64 level 2 octcubes that span the color space.
'''  *  In the latter case, we require a minimum of 64 colors for the level 2
'''  *  octcubes, plus up to 192 additional colors determined from level 3
'''  *  popularity.
'''  *
'''  *  The parameter 'maxlevel' is the deepest octcube level that is used.
'''  *  The implementation also uses two LUTs, which are employed in
'''  *  two successive traversals of the dest image.  The first maps
'''  *  from the src octindex at 'maxlevel' to the color table index,
'''  *  which is the value that is stored in the 4 or 8 bpp dest pixel.
'''  *  The second LUT maps from that colormap value in the dest to a
'''  *  new colormap value for a minimum sized colormap, stored back in
'''  *  the dest.  It is used to remove any color map entries that
'''  *  correspond to color space regions that have no pixels in the
'''  *  source image.  These regions can be either from the higher level
'''  *  e.g., level 1 for 4 bpp, or from octcubes at 'maxlevel' that
'''  *  are unoccupied.  This remapping results in the minimum number
'''  *  of colors used according to the constraints induced by the
'''  *  input 'maxcolors'.  We also compute the average R, G and B color
'''  *  values in each region of the color space represented by a
'''  *  colormap entry, and store them in the colormap.
'''  *
'''  *  The maximum number of colors is input, which determines the
'''  *  following properties of the dest image and octcube regions used:
'''  *
'''  *  Number of colors   dest image depth   maxlevel
'''  *  ----------------   ----------------   --------
'''  * 8 to 16   4 bpp   2
'''  * 17 to 64  8 bpp   2
'''  * 65 to 256 8 bpp   3
'''  *
'''  *  It may turn out that the number of extra colors, beyond the
'''  *  minimum 8 and 64 for maxlevel 2 and 3, respectively, is larger
'''  *  than the actual number of occupied cubes at these levels
'''  *  In that case, all the pixels are contained in this
'''  *  subset of cubes at maxlevel, and no colormap colors are needed
'''  *  to represent the remainder pixels one level above.  Thus, for
'''  *  example, in use one often finds that the pixels in an image
'''  *  occupy less than 192 octcubes at level 3, so they can be represented
'''  *  by a colormap for octcubes at level 3 only.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 4 or 8 bpp, colormapped, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="maxcolors"> \param[in]    maxcolors 8 to 256; the actual number of colors used</param>
''' <param name="subsample"> \param[in]    subsample factor for computing color distribution;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOctreeQuantNumColors")> _
Friend Shared Function pixOctreeQuantNumColors(pixs as IntPTR, maxcolors as Integer, subsample as Integer) as IntPTR
End Function

' SRC\colorquant1.c (2587, 1)
' pixOctcubeQuantMixedWithGray()
' pixOctcubeQuantMixedWithGray(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Generates a colormapped image, where the colormap table values
'''  * have two components: octcube values representing pixels with
'''  * color content, and grayscale values for the rest.
'''  *   (2) The threshold (delta) is the maximum allowable difference of
'''  * the max abs value of | r - g |, | r - b | and | g - b |.
'''  *   (3) The octcube values are the averages of all pixels that are
'''  * found in the octcube, and that are far enough from gray to
'''  * be considered color.  This can roughly be visualized as all
'''  * the points in the rgb color cube that are not within a "cylinder"
'''  * of diameter approximately 'delta' along the main diagonal.
'''  *   (4) We want to guarantee full coverage of the rgb color space; thus,
'''  * if the output depth is 4, the octlevel is 1 (2 x 2 x 2 = 8 cubes)
'''  * and if the output depth is 8, the octlevel is 2 (4 x 4 x 4
'''  * = 64 cubes).
'''  *   (5) Consequently, we have the following constraint on the number
'''  * of allowed gray levels: for 4 bpp, 8; for 8 bpp, 192.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd     quantized to octcube and gray levels or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs        32 bpp rgb</param>
''' <param name="depth"> \param[in]    depth       of output pix</param>
''' <param name="graylevels"> \param[in]    graylevels  graylevels (must be > 1)</param>
''' <param name="delta"> \param[in]    delta       threshold for deciding if a pix is color or gray</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOctcubeQuantMixedWithGray")> _
Friend Shared Function pixOctcubeQuantMixedWithGray(pixs as IntPTR, depth as Integer, graylevels as Integer, delta as Integer) as IntPTR
End Function

' SRC\colorquant1.c (2806, 1)
' pixFixedOctcubeQuant256()
' pixFixedOctcubeQuant256(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *  This simple 1-pass color quantization works by breaking the
'''  *  color space into 256 pieces, with 3 bits quantized for each of
'''  *  red and green, and 2 bits quantized for blue.  We shortchange
'''  *  blue because the eye is least sensitive to blue.  This
'''  *  division of the color space is into two levels of octrees,
'''  *  followed by a further division by 4 not 8, where both
'''  *  blue octrees have been combined in the third level.
'''  *
'''  *  The color map is generated from the 256 color centers by
'''  *  taking the representative color to be the center of the
'''  *  cell volume.  This gives a maximum error in the red and
'''  *  green values of 16 levels, and a maximum error in the
'''  *  blue sample of 32 levels.
'''  *
'''  *  Each pixel in the 24-bit color image is placed in its containing
'''  *  cell, given by the relevant MSbits of the red, green and blue
'''  *  samples.  An error-diffusion dithering is performed on each
'''  *  color sample to give the appearance of good average local color.
'''  *  Dithering is required; without it, the contouring and visible
'''  *  color errors are very bad.
'''  *
'''  *  I originally implemented this algorithm in two passes,
'''  *  where the first pass was used to compute the weighted average
'''  *  of each sample in each pre-allocated region of color space.
'''  *  The idea was to use these centroids in the dithering algorithm
'''  *  of the second pass, to reduce the average error that was
'''  *  being dithered.  However, with dithering, there is
'''  *  virtually no difference, so there is no reason to make the
'''  *  first pass.  Consequently, this 1-pass version just assigns
'''  *  the pixels to the centers of the pre-allocated cells.
'''  *  We use dithering to spread the difference between the sample
'''  *  value and the location of the center of the cell.  For speed
'''  *  and simplicity, we use integer dithering and propagate only
'''  *  to the right, down, and diagonally down-right, with ratios
'''  *  3/8, 3/8 and 1/4, respectively.  The results should be nearly
'''  *  as good, and a bit faster, with propagation only to the right
'''  *  and down.
'''  *
'''  *  The algorithm is very fast, because there is no search,
'''  *  only fast generation of the cell index for each pixel.
'''  *  We use a simple mapping from the three 8 bit rgb samples
'''  *  to the 8 bit cell index; namely, r7 r6 r5 g7 g6 g5 b7 b6.
'''  *  This is not in an octcube format, but it doesn't matter.
'''  *  There are no storage requirements.  We could keep a
'''  *  running average of the center of each sample in each
'''  *  cluster, rather than using the center of the cell, but
'''  *  this is just extra work, esp. with dithering.
'''  *
'''  *  This method gives surprisingly good results with dithering.
'''  *  However, without dithering, the loss of color accuracy is
'''  *  evident in regions that are very light or that have subtle
'''  *  blending of colors.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bit with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp; 24-bit color</param>
''' <param name="ditherflag"> \param[in]    ditherflag  1 for dithering; 0 for no dithering</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFixedOctcubeQuant256")> _
Friend Shared Function pixFixedOctcubeQuant256(pixs as IntPTR, ditherflag as Integer) as IntPTR
End Function

' SRC\colorquant1.c (2940, 1)
' pixFewColorsOctcubeQuant1()
' pixFewColorsOctcubeQuant1(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Generates a colormapped image, where the colormap table values
'''  * are the averages of all pixels that are found in the octcube.
'''  *   (2) This fails if there are more than 256 colors (i.e., more
'''  * than 256 occupied octcubes).
'''  *   (3) Often level 3 (512 octcubes) will succeed because not more
'''  * than half of them are occupied with 1 or more pixels.
'''  *   (4) The depth of the result, which is either 2, 4 or 8 bpp,
'''  * is the minimum required to hold the number of colors that
'''  * are found.
'''  *   (5) This can be useful for quantizing orthographically generated
'''  * images such as color maps, where there may be more than 256 colors
'''  * because of aliasing or jpeg artifacts on text or lines, but
'''  * there are a relatively small number of solid colors.  Then,
'''  * use with level = 3 can often generate a compact and accurate
'''  * representation of the original RGB image.  For this purpose,
'''  * it is better than pixFewColorsOctcubeQuant2(), because it
'''  * uses the average value of pixels in the octcube rather
'''  * than the first found pixel.  It is also simpler to use,
'''  * because it generates the histogram internally.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd quantized to octcube or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="level"> \param[in]    level significant bits for each of RGB; valid in [1...6]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFewColorsOctcubeQuant1")> _
Friend Shared Function pixFewColorsOctcubeQuant1(pixs as IntPTR, level as Integer) as IntPTR
End Function

' SRC\colorquant1.c (3110, 1)
' pixFewColorsOctcubeQuant2()
' pixFewColorsOctcubeQuant2(PIX *, l_int32, NUMA *, l_int32, l_int32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Generates a colormapped image, where the colormap table values
'''  * are the averages of all pixels that are found in the octcube.
'''  *   (2) This fails if there are more than 256 colors (i.e., more
'''  * than 256 occupied octcubes).
'''  *   (3) Often level 3 (512 octcubes) will succeed because not more
'''  * than half of them are occupied with 1 or more pixels.
'''  *   (4) For an image with not more than 256 colors, it is unlikely
'''  * that two pixels of different color will fall in the same
'''  * octcube at level = 4.   However it is possible, and this
'''  * function optionally returns %nerrors, the number of pixels
'''  * where, because more than one color is in the same octcube,
'''  * the pixel color is not exactly reproduced in the colormap.
'''  * The colormap for an occupied leaf of the octree contains
'''  * the color of the first pixel encountered in that octcube.
'''  *   (5) This differs from pixFewColorsOctcubeQuant1(), which also
'''  * requires not more than 256 occupied leaves, but represents
'''  * the color of each leaf by an average over the pixels in
'''  * that leaf.  This also requires precomputing the histogram
'''  * of occupied octree leaves, which is generated using
'''  * pixOctcubeHistogram().
'''  *   (6) This is used in pixConvertRGBToColormap() for images that
'''  * are determined, by their histogram, to have relatively few
'''  * colors.  This typically happens with orthographically
'''  * produced images (as oppopsed to natural images), where
'''  * it is expected that most of the pixels within a leaf
'''  * octcube have exactly the same color, and quantization to
'''  * that color is lossless.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="level"> \param[in]    level of octcube indexing, for histogram: 3, 4, 5, 6</param>
''' <param name="na"> \param[in]    na histogram of pixel occupation in octree leaves at</param>
''' <param name="ncolors"> \param[in]    ncolors number of occupied octree leaves at given level</param>
''' <param name="pnerrors"> \param[out]   pnerrors [optional] num of pixels not exactly</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFewColorsOctcubeQuant2")> _
Friend Shared Function pixFewColorsOctcubeQuant2(pixs as IntPTR, level as Integer, na as IntPTR, ncolors as Integer, pnerrors as Integer) as IntPTR
End Function

' SRC\colorquant1.c (3299, 1)
' pixFewColorsOctcubeQuantMixed()
' pixFewColorsOctcubeQuantMixed(PIX *, l_int32, l_int32, l_int32, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) First runs pixFewColorsOctcubeQuant1().  If this succeeds,
'''  * it separates the color from gray(ish) entries in the cmap,
'''  * and re-quantizes the gray pixels.  The result has some pixels
'''  * in color and others in gray.
'''  *   (2) This fails if there are more than 256 colors (i.e., more
'''  * than 256 occupied octcubes in the color quantization).
'''  *   (3) Level 3 (512 octcubes) will usually succeed because not more
'''  * than half of them are occupied with 1 or more pixels.
'''  *   (4) This uses the criterion from pixColorFraction() for deciding
'''  * if a colormap entry is color; namely, if the color components
'''  * are not too close to either black or white, and the maximum
'''  * difference between component values equals or exceeds a threshold.
'''  *   (5) For quantizing the gray pixels, it uses a histogram-based
'''  * method where input parameters determining the buckets are
'''  * the minimum population fraction and the maximum allowed size.
'''  *   (6) Recommended input parameters are:
'''  *  %level:  3 or 4  (3 is default)
'''  *  %darkthresh:  20
'''  *  %lightthresh: 244
'''  *  %diffthresh: 20
'''  *  %minfract: 0.05
'''  *  %maxspan: 15
'''  * These numbers are intended to be conservative (somewhat over-
'''  * sensitive) in color detection,  It's usually better to pay
'''  * extra with octcube quantization of a grayscale image than
'''  * to use grayscale quantization on an image that has some
'''  * actual color.  Input 0 on any of these to get the default.
'''  *   (7) This can be useful for quantizing orthographically generated
'''  * images such as color maps, where there may be more than 256 colors
'''  * because of aliasing or jpeg artifacts on text or lines, but
'''  * there are a relatively small number of solid colors.  It usually
'''  * gives results that are better than pixOctcubeQuantMixedWithGray(),
'''  * both in size and appearance.  But it is a bit slower.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, quantized to octcube for pixels that are</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="level"> \param[in]    level significant octcube bits for each of RGB;</param>
''' <param name="darkthresh"> \param[in]    darkthresh threshold near black; if the lightest component</param>
''' <param name="lightthresh"> \param[in]    lightthresh threshold near white; if the darkest component</param>
''' <param name="diffthresh"> \param[in]    diffthresh thresh for the max difference between component</param>
''' <param name="minfract"> \param[in]    minfract min fraction of pixels for gray histo bin;</param>
''' <param name="maxspan"> \param[in]    maxspan max size of gray histo bin; use 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFewColorsOctcubeQuantMixed")> _
Friend Shared Function pixFewColorsOctcubeQuantMixed(pixs as IntPTR, level as Integer, darkthresh as Integer, lightthresh as Integer, diffthresh as Integer, minfract as single, maxspan as Integer) as IntPTR
End Function

' SRC\colorquant1.c (3417, 1)
' pixFixedOctcubeQuantGenRGB()
' pixFixedOctcubeQuantGenRGB(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Unlike the other color quantization functions, this one
'''  * generates an rgb image.
'''  *   (2) The pixel values are quantized to the center of each octcube
'''  * (at the specified level) containing the pixel.  They are
'''  * not quantized to the average of the pixels in that octcube.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd rgb; quantized to octcube centers, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="level"> \param[in]    level significant bits for each of r,g,b</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFixedOctcubeQuantGenRGB")> _
Friend Shared Function pixFixedOctcubeQuantGenRGB(pixs as IntPTR, level as Integer) as IntPTR
End Function

' SRC\colorquant1.c (3490, 1)
' pixQuantFromCmap()
' pixQuantFromCmap(PIX *, PIXCMAP *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a top-level wrapper for quantizing either grayscale
'''  * or rgb images to a specified colormap.
'''  *   (2) The actual output depth is constrained by %mindepth and
'''  * by the number of colors in %cmap.
'''  *   (3) For grayscale, %level and %metric are ignored.
'''  *   (4) If the cmap has color and pixs is grayscale, the color is
'''  * removed from the cmap before quantizing pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd  2, 4 or 8 bpp, colormapped, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  8 bpp grayscale without cmap, or 32 bpp rgb</param>
''' <param name="cmap"> \param[in]    cmap  to quantize to; insert copy into dest pix</param>
''' <param name="mindepth"> \param[in]    mindepth minimum depth of pixd: can be 2, 4 or 8 bpp</param>
''' <param name="level"> \param[in]    level of octcube used for finding nearest color in cmap</param>
''' <param name="metric"> \param[in]    metric L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixQuantFromCmap")> _
Friend Shared Function pixQuantFromCmap(pixs as IntPTR, cmap as IntPTR, mindepth as Integer, level as Integer, metric as Integer) as IntPTR
End Function

' SRC\colorquant1.c (3579, 1)
' pixOctcubeQuantFromCmap()
' pixOctcubeQuantFromCmap(PIX *, PIXCMAP *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) In typical use, we are doing an operation, such as
'''  * interpolative scaling, on a colormapped pix, where it is
'''  * necessary to remove the colormap before the operation.
'''  * We then want to re-quantize the RGB result using the same
'''  * colormap.
'''  *   (2) The level is used to divide the color space into octcubes.
'''  * Each input pixel is, in effect, placed at the center of an
'''  * octcube at the given level, and it is mapped into the
'''  * exact color (given in the colormap) that is the closest
'''  * to that location.  We need to know that distance, for each color
'''  * in the colormap.  The higher the level of the octtree, the smaller
'''  * the octcubes in the color space, and hence the more accurately
'''  * we can determine the closest color in the colormap; however,
'''  * the size of the LUT, which is the total number of octcubes,
'''  * increases by a factor of 8 for each increase of 1 level.
'''  * The time required to acquire a level 4 mapping table, which has
'''  * about 4K entries, is less than 1 msec, so that is the
'''  * recommended minimum size to be used.  At that size, the
'''  * octcubes have their centers 16 units apart in each (r,g,b)
'''  * direction.  If two colors are in the same octcube, the one
'''  * closest to the center will always be chosen.  The maximum
'''  * error for any component occurs when the correct color is
'''  * at a cube corner and there is an incorrect color just inside
'''  * the cube next to the opposite corner, giving an error of
'''  * 14 units (out of 256) for each component.   Using a level 5
'''  * mapping table reduces the maximum error to 6 units.
'''  *   (3) Typically you should use the Euclidean metric, because the
'''  * resulting voronoi cells (which are generated using the actual
'''  * colormap values as seeds) are convex for Euclidean distance
'''  * but not for Manhattan distance.  In terms of the octcubes,
'''  * convexity of the voronoi cells means that if the 8 corners
'''  * of any cube (of which the octcubes are special cases)
'''  * are all within a cell, then every point in the cube will
'''  * lie within the cell.
'''  *   (4) The depth of the output pixd is equal to the maximum of
'''  * (a) %mindepth and (b) the minimum (2, 4 or 8 bpp) necessary
'''  * to hold the indices in the colormap.
'''  *   (5) We build a mapping table from octcube to colormap index so
'''  * that this function can run in a time (otherwise) independent
'''  * of the number of colors in the colormap.  This avoids a
'''  * brute-force search for the closest colormap color to each
'''  * pixel in the image.
'''  *   (6) This is similar to the function pixAssignToNearestColor()
'''  * used for color segmentation.
'''  *   (7) Except for very small images or when using level > 4,
'''  * it takes very little time to generate the tables,
'''  * compared to the generation of the colormapped dest pix,
'''  * so one would not typically use the low-level version.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd  2, 4 or 8 bpp, colormapped, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp rgb</param>
''' <param name="cmap"> \param[in]    cmap  to quantize to; insert copy into dest pix</param>
''' <param name="mindepth"> \param[in]    mindepth minimum depth of pixd: can be 2, 4 or 8 bpp</param>
''' <param name="level"> \param[in]    level of octcube used for finding nearest color in cmap</param>
''' <param name="metric"> \param[in]    metric L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOctcubeQuantFromCmap")> _
Friend Shared Function pixOctcubeQuantFromCmap(pixs as IntPTR, cmap as IntPTR, mindepth as Integer, level as Integer, metric as Integer) as IntPTR
End Function

' SRC\colorquant1.c (3729, 1)
' pixOctcubeHistogram()
' pixOctcubeHistogram(PIX *, l_int32, l_int32 *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) Input NULL for &ncolors to prevent computation and return value.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa histogram of color pixels, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="level"> \param[in]    level significant bits for each of RGB; valid in [1...6]</param>
''' <param name="pncolors"> \param[out]   pncolors [optional] number of occupied cubes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOctcubeHistogram")> _
Friend Shared Function pixOctcubeHistogram(pixs as IntPTR, level as Integer, pncolors as Integer) as IntPTR
End Function

' SRC\colorquant1.c (3852, 1)
' pixcmapToOctcubeLUT()
' pixcmapToOctcubeLUT(PIXCMAP *, l_int32, l_int32) as l_int32 *
''' <summary>
''' * Notes:
'''  *   (1) This function is used to quickly find the colormap color
'''  * that is closest to any rgb color.  It is used to assign
'''  * rgb colors to an existing colormap.  It can be very expensive
'''  * to search through the entire colormap for the closest color
'''  * to each pixel.  Instead, we first set up this table, which is
'''  * populated by the colormap index nearest to each octcube
'''  * color.  Then we go through the image; for each pixel,
'''  * do two table lookups: first to generate the octcube index
'''  * from rgb and second to use this table to read out the
'''  * colormap index.
'''  *   (2) Do a slight modification for white and black.  For level = 4,
'''  * each octcube size is 16.  The center of the whitest octcube
'''  * is at (248, 248, 248), which is closer to 242 than 255.
'''  * Consequently, any gray color between 242 and 254 will
'''  * be selected, even if white (255, 255, 255) exists.  This is
'''  * typically not optimal, because the original color was
'''  * likely white.  Therefore, if white exists in the colormap,
'''  * use it for any rgb color that falls into the most white octcube.
'''  * Do the similar thing for black.
'''  *   (3) Here are the actual function calls for quantizing to a
'''  * specified colormap:
'''  *   ~ first make the tables that map from rgb --> octcube index
'''  *   makeRGBToIndexTables()
'''  *   ~ then for each pixel:
'''  * * use the tables to get the octcube index
'''  *   getOctcubeIndexFromRGB()
'''  * * use this table to get the nearest color in the colormap
'''  *   cmap_index = tab[index]
'''  *   (4) Distance can be either manhattan or euclidean.
'''  *   (5) In typical use, level = 4 gives reasonable results, and
'''  * level = 5 is slightly better.  When this function is used
'''  * for color segmentation, there are typically a small number
'''  * of colors and the number of levels can be small (e.g., level = 3).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  tab[23  level]</returns>
''' <param name="cmap"> \param[in]    cmap</param>
''' <param name="level"> \param[in]    level significant bits for each of RGB; valid in [1...6]</param>
''' <param name="metric"> \param[in]    metric L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapToOctcubeLUT")> _
Friend Shared Function pixcmapToOctcubeLUT(cmap as IntPTR, level as Integer, metric as Integer) as String
End Function

' SRC\colorquant1.c (3938, 1)
' pixRemoveUnusedColors()
' pixRemoveUnusedColors(PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place operation.
'''  *   (2) If the image doesn't have a colormap, returns without error.
'''  *   (3) Unusued colors are removed from the colormap, and the
'''  * image pixels are re-numbered.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs  colormapped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRemoveUnusedColors")> _
Friend Shared Function pixRemoveUnusedColors(pixs as IntPTR) as Integer
End Function

' SRC\colorquant1.c (4084, 1)
' pixNumberOccupiedOctcubes()
' pixNumberOccupiedOctcubes(PIX *, l_int32, l_int32, l_float32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Exactly one of (%mincount, %minfract) must be -1, so, e.g.,
'''  * if %mincount == -1, then we use %minfract.
'''  *   (2) If all occupied octcubes are to count, set %mincount == 1.
'''  * Setting %minfract == 0.0 is taken to mean the same thing.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix 32 bpp</param>
''' <param name="level"> \param[in]    level of octcube</param>
''' <param name="mincount"> \param[in]    mincount minimum num pixels in an octcube to be counted;</param>
''' <param name="minfract"> \param[in]    minfract minimum fract of pixels in an octcube to be</param>
''' <param name="pncolors"> \param[out]   pncolors number of occupied octcubes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixNumberOccupiedOctcubes")> _
Friend Shared Function pixNumberOccupiedOctcubes(pix as IntPTR, level as Integer, mincount as Integer, minfract as single, pncolors as Integer) as Integer
End Function

#End Region
#Region "SRC\colorquant2.c"
' SRC\colorquant2.c (193, 17)
' pixcmapGenerateFromHisto()
' pixcmapGenerateFromHisto(PIX *, l_int32, l_int32 *, l_int32, l_int32) as PIXCMAP *
''' <summary>
''' * Notes:
'''  *   (1) This is used when the number of colors in the histo
'''  * is not greater than maxcolors.
'''  *   (2) As a side-effect, the histo becomes an inverse colormap,
'''  * labeling the cmap indices for each existing color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp; rgb color</param>
''' <param name="depth"> \param[in]    depth of colormap</param>
''' <param name="histo"> \param[in]    histo</param>
''' <param name="histosize"> \param[in]    histosize</param>
''' <param name="sigbits"> \param[in]    sigbits</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGenerateFromHisto")> _
Friend Shared Function pixcmapGenerateFromHisto(pixs as IntPTR, depth as Integer, histo as Integer, histosize as Integer, sigbits as Integer) as IntPTR
End Function

' SRC\colorquant2.c (196, 13)
' pixQuantizeWithColormap()
' pixQuantizeWithColormap(PIX *, l_int32, l_int32, PIXCMAP *, l_int32 *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The indexmap is a LUT that takes the rgb indices of the
'''  * pixel and returns the index into the colormap.
'''  *   (2) If ditherflag is 1, %outdepth is ignored and the output
'''  * depth is set to 8.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd quantized to colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp; rgb color</param>
''' <param name="ditherflag"> \param[in]    ditherflag 1 for dither; 0 for no dither</param>
''' <param name="outdepth"> \param[in]    outdepth depth of the returned pixd</param>
''' <param name="cmap"> \param[in]    cmap     colormap</param>
''' <param name="indexmap"> \param[in]    indexmap lookup table</param>
''' <param name="mapsize"> \param[in]    mapsize  size of the lookup table</param>
''' <param name="sigbits"> \param[in]    sigbits  significant bits in output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixQuantizeWithColormap")> _
Friend Shared Function pixQuantizeWithColormap(pixs as IntPTR, ditherflag as Integer, outdepth as Integer, cmap as IntPTR, indexmap as Integer, mapsize as Integer, sigbits as Integer) as IntPTR
End Function

' SRC\colorquant2.c (200, 13)
' getColorIndexMedianCut()
' getColorIndexMedianCut(l_uint32, l_int32, l_uint32, l_int32, l_int32 *) as void
''' <summary>
''' * Notes:
'''  *   (1) This is used on each pixel in the source image.  No checking
'''  * is done on input values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pixel"> \param[in]    pixel 32 bit rgb</param>
''' <param name="rshift"> \param[in]    rshift of component: 8 - sigbits</param>
''' <param name="mask"> \param[in]    mask over sigbits</param>
''' <param name="sigbits"> \param[in]    sigbits</param>
''' <param name="pindex"> \param[out]   pindex rgb index value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getColorIndexMedianCut")> _
Friend Shared Function getColorIndexMedianCut(pixel as UInteger, rshift as Integer, mask as UInteger, sigbits as Integer, pindex as Integer) as Boolean ' Org. Void
End Function

' SRC\colorquant2.c (203, 17)
' pixGetColorRegion()
' pixGetColorRegion(PIX *, l_int32, l_int32) as L_BOX3D *
''' <summary>
''' * Notes:
'''  *   (1) Computes the minimum 3D box in color space enclosing all
'''  * pixels in the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  vbox minimum 3D box in color space enclosing all pixels,</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp; rgb color</param>
''' <param name="sigbits"> \param[in]    sigbits valid: 5, 6</param>
''' <param name="subsample"> \param[in]    subsample integer > 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetColorRegion")> _
Friend Shared Function pixGetColorRegion(pixs as IntPTR, sigbits as Integer, subsample as Integer) as IntPTR
End Function

' SRC\colorquant2.c (205, 16)
' medianCutApply()
' medianCutApply(l_int32 *, l_int32, L_BOX3D *, L_BOX3D **, L_BOX3D **) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="histo"> \param[in]    histo  array; in rgb colorspace</param>
''' <param name="sigbits"> \param[in]    sigbits</param>
''' <param name="vbox"> \param[in]    vbox input 3D box</param>
''' <param name="pvbox1"> \param[out]   pvbox1, pvbox2 vbox split in two parts</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="medianCutApply")> _
Friend Shared Function medianCutApply(histo as Integer, sigbits as Integer, vbox as IntPTR, pvbox1 as Object, pvbox2 as Object) as Integer
End Function

' SRC\colorquant2.c (208, 17)
' pixcmapGenerateFromMedianCuts()
' pixcmapGenerateFromMedianCuts(L_HEAP *, l_int32 *, l_int32) as PIXCMAP *
''' <summary>
''' * Notes:
'''  *   (1) Each vbox in the heap represents a color in the colormap.
'''  *   (2) As a side-effect, the histo becomes an inverse colormap,
'''  * where the part of the array correpsonding to each vbox
'''  * is labeled with the cmap index for that vbox.  Then
'''  * for each rgb pixel, the colormap index is found directly
'''  * by mapping the rgb value to the histo array index.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmap, or NULL on error</returns>
''' <param name="lh"> \param[in]    lh priority queue of pointers to vboxes</param>
''' <param name="histo"> \param[in]    histo</param>
''' <param name="sigbits"> \param[in]    sigbits valid: 5 or 6</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapGenerateFromMedianCuts")> _
Friend Shared Function pixcmapGenerateFromMedianCuts(lh as IntPTR, histo as Integer, sigbits as Integer) as IntPTR
End Function

' SRC\colorquant2.c (210, 16)
' vboxGetAverageColor()
' vboxGetAverageColor(L_BOX3D *, l_int32 *, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) The vbox represents one color in the colormap.
'''  *   (2) If index >= 0, as a side-effect, all array elements in
'''  * the histo corresponding to the vbox are labeled with this
'''  * cmap index for that vbox.  Otherwise, the histo array
'''  * is not changed.
'''  *   (3) The vbox is quantized in sigbits.  So the actual 8-bit color
'''  * components are found by multiplying the quantized value
'''  * by either 4 or 8.  We must add 0.5 to the quantized index
'''  * before multiplying to get the approximate 8-bit color in
'''  * the center of the vbox; otherwise we get values on
'''  * the lower corner.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cmap, or NULL on error</returns>
''' <param name="vbox"> \param[in]    vbox 3d region of color space for one quantized color</param>
''' <param name="histo"> \param[in]    histo</param>
''' <param name="sigbits"> \param[in]    sigbits valid: 5 or 6</param>
''' <param name="index"> \param[in]    index if >= 0, assign to all colors in histo in this vbox</param>
''' <param name="prval"> \param[out]   prval, pgval, pbval average color</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="vboxGetAverageColor")> _
Friend Shared Function vboxGetAverageColor(vbox as IntPTR, histo as Integer, sigbits as Integer, index as Integer, prval as Integer, pgval as Integer, pbval as Integer) as Integer
End Function

' SRC\colorquant2.c (214, 16)
' vboxGetCount()
' vboxGetCount(L_BOX3D *, l_int32 *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  number of image pixels in this region, or 0 on error</returns>
''' <param name="vbox"> \param[in]    vbox 3d region of color space for one quantized color</param>
''' <param name="histo"> \param[in]    histo</param>
''' <param name="sigbits"> \param[in]    sigbits valid: 5 or 6</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="vboxGetCount")> _
Friend Shared Function vboxGetCount(vbox as IntPTR, histo as Integer, sigbits as Integer) as Integer
End Function

' SRC\colorquant2.c (215, 16)
' vboxGetVolume()
' vboxGetVolume(L_BOX3D *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  quantized volume of vbox, or 0 on error</returns>
''' <param name="vbox"> \param[in]    vbox 3d region of color space for one quantized color</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="vboxGetVolume")> _
Friend Shared Function vboxGetVolume(vbox as IntPTR) as Integer
End Function

' SRC\colorquant2.c (216, 17)
' box3dCreate()
' box3dCreate(l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as L_BOX3D *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  vbox</returns>
''' <param name="r1"> \param[in]    r1, r2, g1, g2, b1, b2 initial values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="box3dCreate")> _
Friend Shared Function box3dCreate(r1 as Integer, r2 as Integer, g1 as Integer, g2 as Integer, b1 as Integer, b2 as Integer) as IntPTR
End Function

' SRC\colorquant2.c (218, 17)
' box3dCopy()
' box3dCopy(L_BOX3D *) as L_BOX3D *
''' <summary>
''' * Notes:
'''  *   Don't copy the sortparam.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  vboxc copy of vbox</returns>
''' <param name="vbox"> \param[in]    vbox</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="box3dCopy")> _
Friend Shared Function box3dCopy(vbox as IntPTR) as IntPTR
End Function

' SRC\colorquant2.c (257, 1)
' pixMedianCutQuant()
' pixMedianCutQuant(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Simple interface.  See pixMedianCutQuantGeneral() for
'''  * use of defaulted parameters.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bit with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp; rgb color</param>
''' <param name="ditherflag"> \param[in]    ditherflag 1 for dither; 0 for no dither</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMedianCutQuant")> _
Friend Shared Function pixMedianCutQuant(pixs as IntPTR, ditherflag as Integer) as IntPTR
End Function

' SRC\colorquant2.c (308, 1)
' pixMedianCutQuantGeneral()
' pixMedianCutQuantGeneral(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) %maxcolors must be in the range [2 ... 256].
'''  *   (2) Use %outdepth = 0 to have the output depth computed as the
'''  * minimum required to hold the actual colors found, given
'''  * the %maxcolors constraint.
'''  *   (3) Use %outdepth = 1, 2, 4 or 8 to specify the output depth.
'''  * In that case, %maxcolors must not exceed 2^(outdepth).
'''  *   (4) If there are fewer quantized colors in the image than %maxcolors,
'''  * the colormap is simply generated from those colors.
'''  *   (5) %maxsub is the maximum allowed subsampling to be used in the
'''  * computation of the color histogram and region of occupied
'''  * color space.  The subsampling is chosen internally for
'''  * efficiency, based on the image size, but this parameter
'''  * limits it.  Use %maxsub = 0 for the internal default, which is the
'''  * maximum allowed subsampling.  Use %maxsub = 1 to prevent
'''  * subsampling.  In general use %maxsub >= 1 to specify the
'''  * maximum subsampling to be allowed, where the actual subsampling
'''  * will be the minimum of this value and the internally
'''  * determined default value.
'''  *   (6) If the image appears gray because either most of the pixels
'''  * are gray or most of the pixels are essentially black or white,
'''  * the image is trivially quantized with a grayscale colormap.  The
'''  * reason is that median cut divides the color space into rectangular
'''  * regions, and it does a very poor job if all the pixels are
'''  * near the diagonal of the color space cube.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bit with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp; rgb color</param>
''' <param name="ditherflag"> \param[in]    ditherflag 1 for dither; 0 for no dither</param>
''' <param name="outdepth"> \param[in]    outdepth output depth; valid: 0, 1, 2, 4, 8</param>
''' <param name="maxcolors"> \param[in]    maxcolors between 2 and 256</param>
''' <param name="sigbits"> \param[in]    sigbits valid: 5 or 6; use 0 for default</param>
''' <param name="maxsub"> \param[in]    maxsub max subsampling, integer; use 0 for default;</param>
''' <param name="checkbw"> \param[in]    checkbw 1 to check if color content is very small,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMedianCutQuantGeneral")> _
Friend Shared Function pixMedianCutQuantGeneral(pixs as IntPTR, ditherflag as Integer, outdepth as Integer, maxcolors as Integer, sigbits as Integer, maxsub as Integer, checkbw as Integer) as IntPTR
End Function

' SRC\colorquant2.c (579, 1)
' pixMedianCutQuantMixed()
' pixMedianCutQuantMixed(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) ncolor + ngray must not exceed 255.
'''  *   (2) The method makes use of pixMedianCutQuantGeneral() with
'''  * minimal addition.
'''  * (a) Preprocess the image, setting all pixels with little color
'''  *  to black, and populating an auxiliary 8 bpp image with the
'''  *  expected colormap values corresponding to the set of
'''  *  quantized gray values.
'''  * (b) Color quantize the altered input image to n + 1 colors.
'''  * (c) Augment the colormap with the gray indices, and
'''  *  substitute the gray quantized values from the auxiliary
'''  *  image for those in the color quantized output that had
'''  *  been quantized as black.
'''  *   (3) Median cut color quantization is relatively poor for grayscale
'''  * images with many colors, when compared to octcube quantization.
'''  * Thus, for images with both gray and color, it is important
'''  * to quantize the gray pixels by another method.  Here, we
'''  * are conservative in detecting color, preferring to use
'''  * a few extra bits to encode colorful pixels that push them
'''  * to gray.  This is particularly reasonable with this function,
'''  * because it handles the gray and color pixels separately,
'''  * using median cut color quantization for the color pixels
'''  * and equal-bin grayscale quantization for the non-color pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp cmapped, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp; rgb color</param>
''' <param name="ncolor"> \param[in]    ncolor maximum number of colors assigned to pixels with</param>
''' <param name="ngray"> \param[in]    ngray number of gray colors to be used; must be >= 2</param>
''' <param name="darkthresh"> \param[in]    darkthresh threshold near black; if the lightest component</param>
''' <param name="lightthresh"> \param[in]    lightthresh threshold near white; if the darkest component</param>
''' <param name="diffthresh"> \param[in]    diffthresh thresh for the max difference between component</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMedianCutQuantMixed")> _
Friend Shared Function pixMedianCutQuantMixed(pixs as IntPTR, ncolor as Integer, ngray as Integer, darkthresh as Integer, lightthresh as Integer, diffthresh as Integer) as IntPTR
End Function

' SRC\colorquant2.c (754, 1)
' pixFewColorsMedianCutQuantMixed()
' pixFewColorsMedianCutQuantMixed(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is the "few colors" version of pixMedianCutQuantMixed().
'''  * It fails (returns NULL) if it finds more than maxncolors, but
'''  * otherwise it gives the same result.
'''  *   (2) Recommended input parameters are:
'''  *  %maxncolors:  20
'''  *  %darkthresh:  20
'''  *  %lightthresh: 244
'''  *  %diffthresh:  15  (any higher can miss colors differing
'''  *   slightly from gray)
'''  *   (3) Both ncolor and ngray should be at least equal to maxncolors.
'''  * If they're not, they are automatically increased, and a
'''  * warning is given.
'''  *   (4) If very little color content is found, the input is
'''  * converted to gray and quantized in equal intervals.
'''  *   (5) This can be useful for quantizing orthographically generated
'''  * images such as color maps, where there may be more than 256 colors
'''  * because of aliasing or jpeg artifacts on text or lines, but
'''  * there are a relatively small number of solid colors.
'''  *   (6) Example of usage:
'''  * // Try to quantize, using default values for mixed med cut
'''  * Pix *pixq = pixFewColorsMedianCutQuantMixed(pixs, 100, 20,
'''  *  0, 0, 0, 0);
'''  * if (!pixq)  // too many colors; don't quantize
'''  *  pixq = pixClone(pixs);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, median cut quantized for pixels that are</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="ncolor"> \param[in]    ncolor number of colors to be assigned to pixels with</param>
''' <param name="ngray"> \param[in]    ngray number of gray colors to be used; must be >= 2</param>
''' <param name="maxncolors"> \param[in]    maxncolors maximum number of colors to be returned</param>
''' <param name="darkthresh"> \param[in]    darkthresh threshold near black; if the lightest component</param>
''' <param name="lightthresh"> \param[in]    lightthresh threshold near white; if the darkest component</param>
''' <param name="diffthresh"> \param[in]    diffthresh thresh for the max difference between component</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFewColorsMedianCutQuantMixed")> _
Friend Shared Function pixFewColorsMedianCutQuantMixed(pixs as IntPTR, ncolor as Integer, ngray as Integer, maxncolors as Integer, darkthresh as Integer, lightthresh as Integer, diffthresh as Integer) as IntPTR
End Function

' SRC\colorquant2.c (826, 1)
' pixMedianCutHisto()
' pixMedianCutHisto(PIX *, l_int32, l_int32) as l_int32 *
''' <summary>
''' * Notes:
'''  *   (1) Array is indexed by (3 * sigbits) bits.  The array size
'''  * is 2^(3 * sigbits).
'''  *   (2) Indexing into the array from rgb uses red sigbits as
'''  * most significant and blue as least.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  histo 1-d array, giving the number of pixels in</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp; rgb color</param>
''' <param name="sigbits"> \param[in]    sigbits valid: 5 or 6</param>
''' <param name="subsample"> \param[in]    subsample integer > 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMedianCutHisto")> _
Friend Shared Function pixMedianCutHisto(pixs as IntPTR, sigbits as Integer, subsample as Integer) as String
End Function

#End Region
#Region "SRC\colorseg.c"
' SRC\colorseg.c (57, 16)
' pixColorSegmentTryCluster()
' pixColorSegmentTryCluster(PIX *, PIX *, l_int32, l_int32, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   This function should only be called from pixColorSegCluster()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixd"> \param[in]    pixd</param>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="maxdist"> \param[in]    maxdist</param>
''' <param name="maxcolors"> \param[in]    maxcolors</param>
''' <param name="debugflag"> \param[in]    debugflag  1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorSegmentTryCluster")> _
Friend Shared Function pixColorSegmentTryCluster(pixd as IntPTR, pixs as IntPTR, maxdist as Integer, maxcolors as Integer, debugflag as Integer) as Integer
End Function

' SRC\colorseg.c (129, 1)
' pixColorSegment()
' pixColorSegment(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' *  Color segmentation proceeds in four phases:
'''  *
'''  *  Phase 1:  pixColorSegmentCluster()
'''  *  The image is traversed in raster order.  Each pixel either
'''  *  becomes the representative for a new cluster or is assigned to an
'''  *  existing cluster.  Assignment is greedy.  The data is stored in
'''  *  a colormapped image.  Three auxiliary arrays are used to hold
'''  *  the colors of the representative pixels, for fast lookup.
'''  *  The average color in each cluster is computed.
'''  *
'''  *  Phase 2.  pixAssignToNearestColor()
'''  *  A second non-greedy clustering pass is performed, where each pixel
'''  *  is assigned to the nearest cluster average.  We also keep track
'''  *  of how many pixels are assigned to each cluster.
'''  *
'''  *  Phase 3.  pixColorSegmentClean()
'''  *  For each cluster, starting with the largest, do a morphological
'''  *  closing to eliminate small components within larger ones.
'''  *
'''  *  Phase 4.  pixColorSegmentRemoveColors()
'''  *  Eliminate all colors except the most populated 'finalcolors'.
'''  *  Then remove unused colors from the colormap, and reassign those
'''  *  pixels to the nearest remaining cluster, using the original pixel values.
'''  *
'''  * Notes:
'''  *   (1) The goal is to generate a small number of colors.
'''  * Typically this would be specified by 'finalcolors',
'''  * a number that would be somewhere between 3 and 6.
'''  * The parameter 'maxcolors' specifies the maximum number of
'''  * colors generated in the first phase.  This should be
'''  * larger than finalcolors, perhaps twice as large.
'''  * If more than 'maxcolors' are generated in the first phase
'''  * using the input 'maxdist', the distance is repeatedly
'''  * increased by a multiplicative factor until the condition
'''  * is satisfied.  The implicit relation between 'maxdist'
'''  * and 'maxcolors' is thus adjusted programmatically.
'''  *   (2) As a very rough guideline, given a target value of 'finalcolors',
'''  * here are approximate values of 'maxdist' and 'maxcolors'
'''  * to start with:
'''  *
'''  *   finalcolors maxcolors maxdist
'''  *   ----------- --------- -------
'''  *    3 6 100
'''  *    4 8  90
'''  *    5   10  75
'''  *    6   12  60
'''  *
'''  * For a given number of finalcolors, if you use too many
'''  * maxcolors, the result will be noisy.  If you use too few,
'''  * the result will be a relatively poor assignment of colors.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bit with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp; 24-bit color</param>
''' <param name="maxdist"> \param[in]    maxdist max euclidean dist to existing cluster</param>
''' <param name="maxcolors"> \param[in]    maxcolors max number of colors allowed in first pass</param>
''' <param name="selsize"> \param[in]    selsize linear size of sel for closing to remove noise</param>
''' <param name="finalcolors"> \param[in]    finalcolors max number of final colors allowed after 4th pass</param>
''' <param name="debugflag"> \param[in]    debugflag  1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorSegment")> _
Friend Shared Function pixColorSegment(pixs as IntPTR, maxdist as Integer, maxcolors as Integer, selsize as Integer, finalcolors as Integer, debugflag as Integer) as IntPTR
End Function

' SRC\colorseg.c (200, 1)
' pixColorSegmentCluster()
' pixColorSegmentCluster(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is phase 1.  See description in pixColorSegment().
'''  *   (2) Greedy unsupervised classification.  If the limit 'maxcolors'
'''  * is exceeded, the computation is repeated with a larger
'''  * allowed cluster size.
'''  *   (3) On each successive iteration, 'maxdist' is increased by a
'''  * constant factor.  See comments in pixColorSegment() for
'''  * a guideline on parameter selection.
'''  * Note that the diagonal of the 8-bit rgb color cube is about
'''  * 440, so for 'maxdist' = 440, you are guaranteed to get 1 color!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bit with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp; 24-bit color</param>
''' <param name="maxdist"> \param[in]    maxdist max euclidean dist to existing cluster</param>
''' <param name="maxcolors"> \param[in]    maxcolors max number of colors allowed in first pass</param>
''' <param name="debugflag"> \param[in]    debugflag  1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorSegmentCluster")> _
Friend Shared Function pixColorSegmentCluster(pixs as IntPTR, maxdist as Integer, maxcolors as Integer, debugflag as Integer) as IntPTR
End Function

' SRC\colorseg.c (412, 1)
' pixAssignToNearestColor()
' pixAssignToNearestColor(PIX *, PIX *, PIX *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is used in phase 2 of color segmentation, where pixs
'''  * is the original input image to pixColorSegment(), and
'''  * pixd is the colormapped image returned from
'''  * pixColorSegmentCluster().  It is also used, with a mask,
'''  * in phase 4.
'''  *   (2) This is an in-place operation.
'''  *   (3) The colormap in pixd is unchanged.
'''  *   (4) pixs and pixd must be the same size (w, h).
'''  *   (5) The selection mask pixm can be null.  If it exists, it must
'''  * be the same size as pixs and pixd, and only pixels
'''  * corresponding to fg in pixm are assigned.  Set to
'''  * NULL if all pixels in pixd are to be assigned.
'''  *   (6) The countarray can be null.  If it exists, it is pre-allocated
'''  * and of a size at least equal to the size of the colormap in pixd.
'''  *   (7) This does a best-fit (non-greedy) assignment of pixels to
'''  * existing clusters.  Specifically, it assigns each pixel
'''  * in pixd to the color index in the pixd colormap that has a
'''  * color closest to the corresponding rgb pixel in pixs.
'''  *   (8) 'level' is the octcube level used to quickly find the nearest
'''  * color in the colormap for each pixel.  For color segmentation,
'''  * this parameter is set to LEVEL_IN_OCTCUBE.
'''  *   (9) We build a mapping table from octcube to colormap index so
'''  * that this function can run in a time (otherwise) independent
'''  * of the number of colors in the colormap.  This avoids a
'''  * brute-force search for the closest colormap color to each
'''  * pixel in the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixd"> \param[in]    pixd  8 bpp, colormapped</param>
''' <param name="pixs"> \param[in]    pixs  32 bpp; 24-bit color</param>
''' <param name="pixm"> \param[in]    pixm  [optional] 1 bpp</param>
''' <param name="level"> \param[in]    level of octcube used for finding nearest color in cmap</param>
''' <param name="countarray"> \param[in]    countarray [optional] ptr to array, in which we can store</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAssignToNearestColor")> _
Friend Shared Function pixAssignToNearestColor(pixd as IntPTR, pixs as IntPTR, pixm as IntPTR, level as Integer, countarray as Integer) as Integer
End Function

' SRC\colorseg.c (512, 1)
' pixColorSegmentClean()
' pixColorSegmentClean(PIX *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This operation is in-place.
'''  *   (2) This is phase 3 of color segmentation.  It is the first
'''  * part of a two-step noise removal process.  Colors with a
'''  * large population are closed first; this operation absorbs
'''  * small sets of intercolated pixels of a different color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs  8 bpp, colormapped</param>
''' <param name="selsize"> \param[in]    selsize for closing</param>
''' <param name="countarray"> \param[in]    countarray ptr to array containing the number of pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorSegmentClean")> _
Friend Shared Function pixColorSegmentClean(pixs as IntPTR, selsize as Integer, countarray as Integer) as Integer
End Function

' SRC\colorseg.c (584, 1)
' pixColorSegmentRemoveColors()
' pixColorSegmentRemoveColors(PIX *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This operation is in-place.
'''  *   (2) This is phase 4 of color segmentation, and the second part
'''  * of the 2-step noise removal.  Only 'finalcolors' different
'''  * colors are retained, with colors with smaller populations
'''  * being replaced by the nearest color of the remaining colors.
'''  * For highest accuracy, for pixels that are being replaced,
'''  * we find the nearest colormap color  to the original rgb color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixd"> \param[in]    pixd  8 bpp, colormapped</param>
''' <param name="pixs"> \param[in]    pixs  32 bpp rgb, with initial pixel values</param>
''' <param name="finalcolors"> \param[in]    finalcolors max number of colors to retain</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorSegmentRemoveColors")> _
Friend Shared Function pixColorSegmentRemoveColors(pixd as IntPTR, pixs as IntPTR, finalcolors as Integer) as Integer
End Function

#End Region
#Region "SRC\colorspace.c"
' SRC\colorspace.c (92, 18)
' 
' lab_forward(l_float32) as l_float32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lab_forward")> _
Friend Shared Function lab_forward(v as single) as single
End Function

' SRC\colorspace.c (93, 18)
' 
' lab_reverse(l_float32) as l_float32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lab_reverse")> _
Friend Shared Function lab_reverse(v as single) as single
End Function

' SRC\colorspace.c (134, 1)
' pixConvertRGBToHSV()
' pixConvertRGBToHSV(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
'''  *   (2) The definition of our HSV space is given in convertRGBToHSV().
'''  *   (3) The h, s and v values are stored in the same places as
'''  * the r, g and b values, respectively.  Here, they are explicitly
'''  * placed in the 3 MS bytes in the pixel.
'''  *   (4) Normalizing to 1 and considering the r,g,b components,
'''  * a simple way to understand the HSV space is:
'''  *  ~ v = max(r,g,b)
'''  *  ~ s = (max - min) / max
'''  *  ~ h ~ (mid - min) / (max - min)  [apart from signs and constants]
'''  *   (5) Normalizing to 1, some properties of the HSV space are:
'''  *  ~ For gray values (r = g = b) along the continuum between
'''  * black and white:
'''  * s = 0  (becoming undefined as you approach black)
'''  * h is undefined everywhere
'''  *  ~ Where one component is saturated and the others are zero:
'''  * v = 1
'''  * s = 1
'''  * h = 0 (r = max), 1/3 (g = max), 2/3 (b = max)
'''  *  ~ Where two components are saturated and the other is zero:
'''  * v = 1
'''  * s = 1
'''  * h = 1/2 (if r = 0), 5/6 (if g = 0), 1/6 (if b = 0)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd can be NULL; if not NULL, must == pixs</param>
''' <param name="pixs"> \param[in]    pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToHSV")> _
Friend Shared Function pixConvertRGBToHSV(pixd as IntPTR, pixs as IntPTR) as IntPTR
End Function

' SRC\colorspace.c (198, 1)
' pixConvertHSVToRGB()
' pixConvertHSVToRGB(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
'''  *   (2) The user takes responsibility for making sure that pixs is
'''  * in our HSV space.  The definition of our HSV space is given
'''  * in convertRGBToHSV().
'''  *   (3) The h, s and v values are stored in the same places as
'''  * the r, g and b values, respectively.  Here, they are explicitly
'''  * placed in the 3 MS bytes in the pixel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd can be NULL; if not NULL, must == pixs</param>
''' <param name="pixs"> \param[in]    pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertHSVToRGB")> _
Friend Shared Function pixConvertHSVToRGB(pixd as IntPTR, pixs as IntPTR) as IntPTR
End Function

' SRC\colorspace.c (273, 1)
' convertRGBToHSV()
' convertRGBToHSV(l_int32, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The range of returned values is:
'''  *   h [0 ... 239]
'''  *   s [0 ... 255]
'''  *   v [0 ... 255]
'''  *   (2) If r = g = b, the pixel is gray (s = 0), and we define h = 0.
'''  *   (3) h wraps around, so that h = 0 and h = 240 are equivalent
'''  * in hue space.
'''  *   (4) h has the following correspondence to color:
'''  *   h = 0   magenta
'''  *   h = 40  red
'''  *   h = 80  yellow
'''  *   h = 120 green
'''  *   h = 160 cyan
'''  *   h = 200 blue
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="rval"> \param[in]    rval, gval, bval RGB input</param>
''' <param name="gval"> \param[out]   phval, psval, pvval HSV values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertRGBToHSV")> _
Friend Shared Function convertRGBToHSV(rval as Integer, gval as Integer, bval as Integer, phval as Integer, psval as Integer, pvval as Integer) as Integer
End Function

' SRC\colorspace.c (335, 1)
' convertHSVToRGB()
' convertHSVToRGB(l_int32, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See convertRGBToHSV() for valid input range of HSV values
'''  * and their interpretation in color space.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="hval"> \param[in]    hval, sval, vval</param>
''' <param name="sval"> \param[out]   prval, pgval, pbval RGB values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertHSVToRGB")> _
Friend Shared Function convertHSVToRGB(hval as Integer, sval as Integer, vval as Integer, prval as Integer, pgval as Integer, pbval as Integer) as Integer
End Function

' SRC\colorspace.c (424, 1)
' pixcmapConvertRGBToHSV()
' pixcmapConvertRGBToHSV(PIXCMAP *) as l_ok
''' <summary>
''' * Notes:
'''  *   ~ in-place transform
'''  *   ~ See convertRGBToHSV() for def'n of HSV space.
'''  *   ~ replaces: r --> h, g --> s, b --> v
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapConvertRGBToHSV")> _
Friend Shared Function pixcmapConvertRGBToHSV(cmap as IntPTR) as Integer
End Function

' SRC\colorspace.c (457, 1)
' pixcmapConvertHSVToRGB()
' pixcmapConvertHSVToRGB(PIXCMAP *) as l_ok
''' <summary>
''' * Notes:
'''  *   ~ in-place transform
'''  *   ~ See convertRGBToHSV() for def'n of HSV space.
'''  *   ~ replaces: h --> r, s --> g, v --> b
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapConvertHSVToRGB")> _
Friend Shared Function pixcmapConvertHSVToRGB(cmap as IntPTR) as Integer
End Function

' SRC\colorspace.c (492, 1)
' pixConvertRGBToHue()
' pixConvertRGBToHue(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The conversion to HSV hue is in-lined here.
'''  *   (2) If there is a colormap, it is removed.
'''  *   (3) If you just want the hue component, this does it
'''  * at about 10 Mpixels/sec/GHz, which is about
'''  * 2x faster than using pixConvertRGBToHSV()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp hue of HSV, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp RGB or 8 bpp with colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToHue")> _
Friend Shared Function pixConvertRGBToHue(pixs as IntPTR) as IntPTR
End Function

' SRC\colorspace.c (568, 1)
' pixConvertRGBToSaturation()
' pixConvertRGBToSaturation(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The conversion to HSV sat is in-lined here.
'''  *   (2) If there is a colormap, it is removed.
'''  *   (3) If you just want the saturation component, this does it
'''  * at about 12 Mpixels/sec/GHz.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp sat of HSV, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp RGB or 8 bpp with colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToSaturation")> _
Friend Shared Function pixConvertRGBToSaturation(pixs as IntPTR) as IntPTR
End Function

' SRC\colorspace.c (633, 1)
' pixConvertRGBToValue()
' pixConvertRGBToValue(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The conversion to HSV sat is in-lined here.
'''  *   (2) If there is a colormap, it is removed.
'''  *   (3) If you just want the value component, this does it
'''  * at about 35 Mpixels/sec/GHz.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp max component intensity of HSV, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp RGB or 8 bpp with colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToValue")> _
Friend Shared Function pixConvertRGBToValue(pixs as IntPTR) as IntPTR
End Function

' SRC\colorspace.c (702, 1)
' pixMakeRangeMaskHS()
' pixMakeRangeMaskHS(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The pixels are selected based on the specified ranges of
'''  * hue and saturation.  For selection or exclusion, the pixel
'''  * HS component values must be within both ranges.  Care must
'''  * be taken in finding the hue range because of wrap-around.
'''  *   (2) Use %regionflag == L_INCLUDE_REGION to take only those
'''  * pixels within the rectangular region specified in HS space.
'''  * Use %regionflag == L_EXCLUDE_REGION to take all pixels except
'''  * those within the rectangular region specified in HS space.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp mask over selected pixels, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp rgb</param>
''' <param name="huecenter"> \param[in]    huecenter center value of hue range</param>
''' <param name="huehw"> \param[in]    huehw half-width of hue range</param>
''' <param name="satcenter"> \param[in]    satcenter center value of saturation range</param>
''' <param name="sathw"> \param[in]    sathw half-width of saturation range</param>
''' <param name="regionflag"> \param[in]    regionflag L_INCLUDE_REGION, L_EXCLUDE_REGION</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMakeRangeMaskHS")> _
Friend Shared Function pixMakeRangeMaskHS(pixs as IntPTR, huecenter as Integer, huehw as Integer, satcenter as Integer, sathw as Integer, regionflag as Integer) as IntPTR
End Function

' SRC\colorspace.c (801, 1)
' pixMakeRangeMaskHV()
' pixMakeRangeMaskHV(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The pixels are selected based on the specified ranges of
'''  * hue and max intensity values.  For selection or exclusion,
'''  * the pixel HV component values must be within both ranges.
'''  * Care must be taken in finding the hue range because of wrap-around.
'''  *   (2) Use %regionflag == L_INCLUDE_REGION to take only those
'''  * pixels within the rectangular region specified in HV space.
'''  * Use %regionflag == L_EXCLUDE_REGION to take all pixels except
'''  * those within the rectangular region specified in HV space.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp mask over selected pixels, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp rgb</param>
''' <param name="huecenter"> \param[in]    huecenter center value of hue range</param>
''' <param name="huehw"> \param[in]    huehw half-width of hue range</param>
''' <param name="valcenter"> \param[in]    valcenter center value of max intensity range</param>
''' <param name="valhw"> \param[in]    valhw half-width of max intensity range</param>
''' <param name="regionflag"> \param[in]    regionflag L_INCLUDE_REGION, L_EXCLUDE_REGION</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMakeRangeMaskHV")> _
Friend Shared Function pixMakeRangeMaskHV(pixs as IntPTR, huecenter as Integer, huehw as Integer, valcenter as Integer, valhw as Integer, regionflag as Integer) as IntPTR
End Function

' SRC\colorspace.c (899, 1)
' pixMakeRangeMaskSV()
' pixMakeRangeMaskSV(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The pixels are selected based on the specified ranges of
'''  * saturation and max intensity (val).  For selection or
'''  * exclusion, the pixel SV component values must be within both ranges.
'''  *   (2) Use %regionflag == L_INCLUDE_REGION to take only those
'''  * pixels within the rectangular region specified in SV space.
'''  * Use %regionflag == L_EXCLUDE_REGION to take all pixels except
'''  * those within the rectangular region specified in SV space.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp mask over selected pixels, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp rgb</param>
''' <param name="satcenter"> \param[in]    satcenter center value of saturation range</param>
''' <param name="sathw"> \param[in]    sathw half-width of saturation range</param>
''' <param name="valcenter"> \param[in]    valcenter center value of max intensity range</param>
''' <param name="valhw"> \param[in]    valhw half-width of max intensity range</param>
''' <param name="regionflag"> \param[in]    regionflag L_INCLUDE_REGION, L_EXCLUDE_REGION</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMakeRangeMaskSV")> _
Friend Shared Function pixMakeRangeMaskSV(pixs as IntPTR, satcenter as Integer, sathw as Integer, valcenter as Integer, valhw as Integer, regionflag as Integer) as IntPTR
End Function

' SRC\colorspace.c (988, 1)
' pixMakeHistoHS()
' pixMakeHistoHS(PIX *, l_int32, NUMA **, NUMA **) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pixs is a 32 bpp image in HSV colorspace; hue is in the "red"
'''  * byte, saturation is in the "green" byte.
'''  *   (2) In pixd, hue is displayed vertically; saturation horizontally.
'''  * The dimensions of pixd are w = 256, h = 240, and the depth
'''  * is 32 bpp.  The value at each point is simply the number
'''  * of pixels found at that value of hue and saturation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp histogram in hue and saturation, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  HSV colorspace</param>
''' <param name="factor"> \param[in]    factor subsampling factor; integer</param>
''' <param name="pnahue"> \param[out]   pnahue [optional] hue histogram</param>
''' <param name="pnasat"> \param[out]   pnasat [optional] saturation histogram</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMakeHistoHS")> _
Friend Shared Function pixMakeHistoHS(pixs as IntPTR, factor as Integer, pnahue as Object, pnasat as Object) as IntPTR
End Function

' SRC\colorspace.c (1079, 1)
' pixMakeHistoHV()
' pixMakeHistoHV(PIX *, l_int32, NUMA **, NUMA **) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pixs is a 32 bpp image in HSV colorspace; hue is in the "red"
'''  * byte, max intensity ("value") is in the "blue" byte.
'''  *   (2) In pixd, hue is displayed vertically; intensity horizontally.
'''  * The dimensions of pixd are w = 256, h = 240, and the depth
'''  * is 32 bpp.  The value at each point is simply the number
'''  * of pixels found at that value of hue and intensity.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp histogram in hue and value, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  HSV colorspace</param>
''' <param name="factor"> \param[in]    factor subsampling factor; integer</param>
''' <param name="pnahue"> \param[out]   pnahue [optional] hue histogram</param>
''' <param name="pnaval"> \param[out]   pnaval [optional] max intensity (value) histogram</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMakeHistoHV")> _
Friend Shared Function pixMakeHistoHV(pixs as IntPTR, factor as Integer, pnahue as Object, pnaval as Object) as IntPTR
End Function

' SRC\colorspace.c (1162, 1)
' pixMakeHistoSV()
' pixMakeHistoSV(PIX *, l_int32, NUMA **, NUMA **) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pixs is a 32 bpp image in HSV colorspace; sat is in the "green"
'''  * byte, max intensity ("value") is in the "blue" byte.
'''  *   (2) In pixd, sat is displayed vertically; intensity horizontally.
'''  * The dimensions of pixd are w = 256, h = 256, and the depth
'''  * is 32 bpp.  The value at each point is simply the number
'''  * of pixels found at that value of saturation and intensity.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp histogram in sat and value, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  HSV colorspace</param>
''' <param name="factor"> \param[in]    factor subsampling factor; integer</param>
''' <param name="pnasat"> \param[out]   pnasat [optional] sat histogram</param>
''' <param name="pnaval"> \param[out]   pnaval [optional] max intensity (value) histogram</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMakeHistoSV")> _
Friend Shared Function pixMakeHistoSV(pixs as IntPTR, factor as Integer, pnasat as Object, pnaval as Object) as IntPTR
End Function

' SRC\colorspace.c (1253, 1)
' pixFindHistoPeaksHSV()
' pixFindHistoPeaksHSV(PIX *, l_int32, l_int32, l_int32, l_int32, l_float32, PTA **, NUMA **, PIXA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) pixs is a 32 bpp histogram in a pair of HSV colorspace.  It
'''  * should be thought of as a single sample with 32 bps (bits/sample).
'''  *   (2) After each peak is found, the peak is erased with a window
'''  * that is centered on the peak and scaled from the sliding
'''  * window by %erasefactor.  Typically, %erasefactor is chosen
'''  * to be > 1.0.
'''  *   (3) Data for a maximum of %npeaks is returned in %pta and %natot.
'''  *   (4) For debugging, after the pixa is returned, display with:
'''  * pixd = pixaDisplayTiledInRows(pixa, 32, 1000, 1.0, 0, 30, 2);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp; HS, HV or SV histogram; not changed</param>
''' <param name="type"> \param[in]    type L_HS_HISTO, L_HV_HISTO or L_SV_HISTO</param>
''' <param name="width"> \param[in]    width half width of sliding window</param>
''' <param name="height"> \param[in]    height half height of sliding window</param>
''' <param name="npeaks"> \param[in]    npeaks number of peaks to look for</param>
''' <param name="erasefactor"> \param[in]    erasefactor ratio of erase window size to sliding window size</param>
''' <param name="ppta"> \param[out]   ppta locations of max for each integrated peak area</param>
''' <param name="pnatot"> \param[out]   pnatot integrated peak areas</param>
''' <param name="ppixa"> \param[out]   ppixa [optional] pixa for debugging; NULL to skip</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindHistoPeaksHSV")> _
Friend Shared Function pixFindHistoPeaksHSV(pixs as IntPTR, type as Integer, width as Integer, height as Integer, npeaks as Integer, erasefactor as single, ppta as Object, pnatot as Object, ppixa as Object) as Integer
End Function

' SRC\colorspace.c (1378, 1)
' displayHSVColorRange()
' displayHSVColorRange(l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The total number of color samplings in each of the hue
'''  * and saturation directions is 2 * nsamp + 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp set of color squares over input range,</returns>
''' <param name="hval"> \param[in]    hval hue center value; in range [0 ... 240]</param>
''' <param name="sval"> \param[in]    sval saturation center value; in range [0 ... 255]</param>
''' <param name="vval"> \param[in]    vval max intensity value; in range [0 ... 255]</param>
''' <param name="huehw"> \param[in]    huehw half-width of hue range; > 0</param>
''' <param name="sathw"> \param[in]    sathw half-width of saturation range; > 0</param>
''' <param name="nsamp"> \param[in]    nsamp number of samplings in each half-width in hue and sat</param>
''' <param name="factor"> \param[in]    factor linear size of each color square, in pixels; > 3</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="displayHSVColorRange")> _
Friend Shared Function displayHSVColorRange(hval as Integer, sval as Integer, vval as Integer, huehw as Integer, sathw as Integer, nsamp as Integer, factor as Integer) as IntPTR
End Function

' SRC\colorspace.c (1454, 1)
' pixConvertRGBToYUV()
' pixConvertRGBToYUV(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
'''  *   (2) The Y, U and V values are stored in the same places as
'''  * the r, g and b values, respectively.  Here, they are explicitly
'''  * placed in the 3 MS bytes in the pixel.
'''  *   (3) Normalizing to 1 and considering the r,g,b components,
'''  * a simple way to understand the YUV space is:
'''  *  ~ Y = weighted sum of (r,g,b)
'''  *  ~ U = weighted difference between Y and B
'''  *  ~ V = weighted difference between Y and R
'''  *   (4) Following video conventions, Y, U and V are in the range:
'''  * Y: [16, 235]
'''  * U: [16, 240]
'''  * V: [16, 240]
'''  *   (5) For the coefficients in the transform matrices, see eq. 4 in
'''  * "Frequently Asked Questions about Color" by Charles Poynton,
'''  * //http://user.engineering.uiowa.edu/~aip/Misc/ColorFAQ.html
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd can be NULL; if not NULL, must == pixs</param>
''' <param name="pixs"> \param[in]    pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToYUV")> _
Friend Shared Function pixConvertRGBToYUV(pixd as IntPTR, pixs as IntPTR) as IntPTR
End Function

' SRC\colorspace.c (1517, 1)
' pixConvertYUVToRGB()
' pixConvertYUVToRGB(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
'''  *   (2) The user takes responsibility for making sure that pixs is
'''  * in YUV space.
'''  *   (3) The Y, U and V values are stored in the same places as
'''  * the r, g and b values, respectively.  Here, they are explicitly
'''  * placed in the 3 MS bytes in the pixel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd can be NULL; if not NULL, must == pixs</param>
''' <param name="pixs"> \param[in]    pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertYUVToRGB")> _
Friend Shared Function pixConvertYUVToRGB(pixd as IntPTR, pixs as IntPTR) as IntPTR
End Function

' SRC\colorspace.c (1582, 1)
' convertRGBToYUV()
' convertRGBToYUV(l_int32, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The range of returned values is:
'''  *   Y [16 ... 235]
'''  *   U [16 ... 240]
'''  *   V [16 ... 240]
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="rval"> \param[in]    rval, gval, bval RGB input</param>
''' <param name="gval"> \param[out]   pyval, puval, pvval YUV values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertRGBToYUV")> _
Friend Shared Function convertRGBToYUV(rval as Integer, gval as Integer, bval as Integer, pyval as Integer, puval as Integer, pvval as Integer) as Integer
End Function

' SRC\colorspace.c (1630, 1)
' convertYUVToRGB()
' convertYUVToRGB(l_int32, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The range of valid input values is:
'''  *   Y [16 ... 235]
'''  *   U [16 ... 240]
'''  *   V [16 ... 240]
'''  *   (2) Conversion of RGB --> YUV --> RGB leaves the image unchanged.
'''  *   (3) The YUV gamut is larger than the RBG gamut; many YUV values
'''  * will result in an invalid RGB value.  We clip individual
'''  * r,g,b components to the range [0, 255], and do not test input.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="yval"> \param[in]    yval, uval, vval</param>
''' <param name="uval"> \param[out]   prval, pgval, pbval RGB values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertYUVToRGB")> _
Friend Shared Function convertYUVToRGB(yval as Integer, uval as Integer, vval as Integer, prval as Integer, pgval as Integer, pbval as Integer) as Integer
End Function

' SRC\colorspace.c (1678, 1)
' pixcmapConvertRGBToYUV()
' pixcmapConvertRGBToYUV(PIXCMAP *) as l_ok
''' <summary>
''' * Notes:
'''  *   ~ in-place transform
'''  *   ~ See convertRGBToYUV() for def'n of YUV space.
'''  *   ~ replaces: r --> y, g --> u, b --> v
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapConvertRGBToYUV")> _
Friend Shared Function pixcmapConvertRGBToYUV(cmap as IntPTR) as Integer
End Function

' SRC\colorspace.c (1711, 1)
' pixcmapConvertYUVToRGB()
' pixcmapConvertYUVToRGB(PIXCMAP *) as l_ok
''' <summary>
''' * Notes:
'''  *   ~ in-place transform
'''  *   ~ See convertRGBToYUV() for def'n of YUV space.
'''  *   ~ replaces: y --> r, u --> g, v --> b
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="cmap"> \param[in]    cmap colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcmapConvertYUVToRGB")> _
Friend Shared Function pixcmapConvertYUVToRGB(cmap as IntPTR) as Integer
End Function

' SRC\colorspace.c (1762, 1)
' pixConvertRGBToXYZ()
' pixConvertRGBToXYZ(PIX *) as FPIXA *
''' <summary>
''' * Notes:
'''  *   (1) The [x,y,z] values are stored as float values in three fpix
'''  * that are returned in a fpixa.
'''  *   (2) The XYZ color space was defined in 1931 as a reference model that
'''  * simulates human color perception.  When Y is taken as luminance,
'''  * the values of X and Z constitute a color plane representing
'''  * all the hues that can be perceived.  This gamut of colors
'''  * is larger than the gamuts that can be displayed or printed.
'''  * For example, although all rgb values map to XYZ, the converse
'''  * is not true.
'''  *   (3) The value of the coefficients depends on the illuminant.  We use
'''  * coefficients for converting sRGB under D65 (the spectrum from
'''  * a 6500 degree K black body; an approximation to daylight color).
'''  * See, e.g.,
'''  * http://www.cs.rit.edu/~ncs/color/t_convert.html
'''  * For more general information on color transforms, see:
'''  * http://www.brucelindbloom.com/
'''  * http://user.engineering.uiowa.edu/~aip/Misc/ColorFAQ.html
'''  * http://en.wikipedia.org/wiki/CIE_1931_color_space
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixa xyz</returns>
''' <param name="pixs"> \param[in]    pixs rgb</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToXYZ")> _
Friend Shared Function pixConvertRGBToXYZ(pixs as IntPTR) as IntPTR
End Function

' SRC\colorspace.c (1821, 1)
' fpixaConvertXYZToRGB()
' fpixaConvertXYZToRGB(FPIXA *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The xyz image is stored in three fpix.
'''  *   (2) For values of xyz that are out of gamut for rgb, the rgb
'''  * components are set to the closest valid color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd rgb</returns>
''' <param name="fpixa"> \param[in]    fpixa three fpix: x,y,z</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaConvertXYZToRGB")> _
Friend Shared Function fpixaConvertXYZToRGB(fpixa as IntPTR) as IntPTR
End Function

' SRC\colorspace.c (1879, 1)
' convertRGBToXYZ()
' convertRGBToXYZ(l_int32, l_int32, l_int32, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) These conversions are for illuminant D65 acting on linear sRGB
'''  * values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="rval"> \param[in]    rval, gval, bval rgb input</param>
''' <param name="gval"> \param[out]   pfxval, pfyval, pfzval xyz values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertRGBToXYZ")> _
Friend Shared Function convertRGBToXYZ(rval as Integer, gval as Integer, bval as Integer, pfxval as single, pfyval as single, pfzval as single) as Integer
End Function

' SRC\colorspace.c (1921, 1)
' convertXYZToRGB()
' convertXYZToRGB(l_float32, l_float32, l_float32, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For values of xyz that are out of gamut for rgb, at least
'''  * one of the r, g or b components will be either less than 0
'''  * or greater than 255.  For that situation:
'''  *   * if blackout == 0, the individual component(s) that are out
'''  *  of gamut will be set to 0 or 255, respectively.
'''  *   * if blackout == 1, the output color will be set to black
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fxval"> \param[in]    fxval, fyval, fzval</param>
''' <param name="fyval"> \param[in]    blackout 0 to output nearest color if out of gamut;</param>
''' <param name="fzval"> \param[out]   prval, pgval, pbval rgb values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertXYZToRGB")> _
Friend Shared Function convertXYZToRGB(fxval as single, fyval as single, fzval as single, blackout as Integer, prval as Integer, pgval as Integer, pbval as Integer) as Integer
End Function

' SRC\colorspace.c (1982, 1)
' fpixaConvertXYZToLAB()
' fpixaConvertXYZToLAB(FPIXA *) as FPIXA *
''' <summary>
''' * Notes:
'''  *   (1) The input [x,y,z] and output [l,a,b] values are stored as
'''  * float values, each set in three fpix.
'''  *   (2) The CIE LAB color space was invented in 1976, as an
'''  * absolute reference for specifying colors that we can
'''  * perceive, independently of the rendering device.  It was
'''  * invented to align color display and print images.
'''  * For information, see:
'''  * http://www.brucelindbloom.com/
'''  * http://en.wikipedia.org/wiki/Lab_color_space
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixa lab</returns>
''' <param name="fpixas"> \param[in]    fpixas xyz</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaConvertXYZToLAB")> _
Friend Shared Function fpixaConvertXYZToLAB(fpixas as IntPTR) as IntPTR
End Function

' SRC\colorspace.c (2048, 1)
' fpixaConvertLABToXYZ()
' fpixaConvertLABToXYZ(FPIXA *) as FPIXA *
''' <summary>
''' * Notes:
'''  *   (1) The input [l,a,b] and output [x,y,z] values are stored as
'''  * float values, each set in three fpix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixa xyz</returns>
''' <param name="fpixas"> \param[in]    fpixas lab</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaConvertLABToXYZ")> _
Friend Shared Function fpixaConvertLABToXYZ(fpixas as IntPTR) as IntPTR
End Function

' SRC\colorspace.c (2109, 1)
' convertXYZToLAB()
' convertXYZToLAB(l_float32, l_float32, l_float32, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="xval"> \param[in]    xval, yval, zval xyz input</param>
''' <param name="yval"> \param[out]   plval, paval, pbval lab values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertXYZToLAB")> _
Friend Shared Function convertXYZToLAB(xval as single, yval as single, zval as single, plval as single, paval as single, pbval as single) as Integer
End Function

' SRC\colorspace.c (2149, 1)
' convertLABToXYZ()
' convertLABToXYZ(l_float32, l_float32, l_float32, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="lval"> \param[in]    lval, aval, bval</param>
''' <param name="aval"> \param[out]   pxval, pyval, pzval xyz values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertLABToXYZ")> _
Friend Shared Function convertLABToXYZ(lval as single, aval as single, bval as single, pxval as single, pyval as single, pzval as single) as Integer
End Function

' SRC\colorspace.c (2243, 1)
' pixConvertRGBToLAB()
' pixConvertRGBToLAB(PIX *) as FPIXA *
''' <summary>
''' * Notes:
'''  *   (1) The [l,a,b] values are stored as float values in three fpix
'''  * that are returned in a fpixa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixa lab</returns>
''' <param name="pixs"> \param[in]    pixs rgb</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToLAB")> _
Friend Shared Function pixConvertRGBToLAB(pixs as IntPTR) as IntPTR
End Function

' SRC\colorspace.c (2300, 1)
' fpixaConvertLABToRGB()
' fpixaConvertLABToRGB(FPIXA *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The lab image is stored in three fpix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd rgb</returns>
''' <param name="fpixa"> \param[in]    fpixa three fpix: l,a,b</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaConvertLABToRGB")> _
Friend Shared Function fpixaConvertLABToRGB(fpixa as IntPTR) as IntPTR
End Function

' SRC\colorspace.c (2358, 1)
' convertRGBToLAB()
' convertRGBToLAB(l_int32, l_int32, l_int32, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) These conversions are for illuminant D65 acting on linear sRGB
'''  * values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="rval"> \param[in]    rval, gval, bval rgb input</param>
''' <param name="gval"> \param[out]   pflval, pfaval, pfbval lab values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertRGBToLAB")> _
Friend Shared Function convertRGBToLAB(rval as Integer, gval as Integer, bval as Integer, pflval as single, pfaval as single, pfbval as single) as Integer
End Function

' SRC\colorspace.c (2395, 1)
' convertLABToRGB()
' convertLABToRGB(l_float32, l_float32, l_float32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For values of lab that are out of gamut for rgb, the rgb
'''  * components are set to the closest valid color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="flval"> \param[in]    flval, faval, fbval</param>
''' <param name="faval"> \param[out]   prval, pgval, pbval rgb values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertLABToRGB")> _
Friend Shared Function convertLABToRGB(flval as single, faval as single, fbval as single, prval as Integer, pgval as Integer, pbval as Integer) as Integer
End Function

#End Region
#Region "SRC\compare.c"
' SRC\compare.c (111, 16)
' pixCompareTilesByHisto()
' pixCompareTilesByHisto(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_float32 *, PIXA *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This static function is only called from pixCompareGrayByHisto().
'''  * The input images have been converted to 8 bpp if necessary,
'''  * aligned and cropped.
'''  *   (2) The input pixadebug is null unless debug output is requested.
'''  *   (3) See pixCompareGrayByHisto() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1, pix2     8 bpp</param>
''' <param name="pix2"> \param[in]    maxgray        max value to keep in histo; 255 to keep all</param>
''' <param name="maxgray"> \param[in]    factor         subsampling factor; >= 1</param>
''' <param name="factor"> \param[in]    nx, ny         number of subregions to use for histograms</param>
''' <param name="nx"> \param[out]   pscore         similarity score of histograms</param>
''' <param name="ny"> \param[in]    pixadebug      [optional] use only for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCompareTilesByHisto")> _
Friend Shared Function pixCompareTilesByHisto(pix1 as IntPTR, pix2 as IntPTR, maxgray as Integer, factor as Integer, nx as Integer, ny as Integer, pscore as single, pixadebug as IntPTR) as Integer
End Function

' SRC\compare.c (150, 1)
' pixEqual()
' pixEqual(PIX *, PIX *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Equality is defined as having the same pixel values for
'''  * each respective image pixel.
'''  *   (2) This works on two pix of any depth.  If one or both pix
'''  * have a colormap, the depths can be different and the
'''  * two pix can still be equal.
'''  *   (3) This ignores the alpha component for 32 bpp images.
'''  *   (4) If both pix have colormaps and the depths are equal,
'''  * use the pixEqualWithCmap() function, which does a fast
'''  * comparison if the colormaps are identical and a relatively
'''  * slow comparison otherwise.
'''  *   (5) In all other cases, any existing colormaps must first be
'''  * removed before doing pixel comparison.  After the colormaps
'''  * are removed, the resulting two images must have the same depth.
'''  * The "lowest common denominator" is RGB, but this is only
'''  * chosen when necessary, or when both have colormaps but
'''  * different depths.
'''  *   (6) For images without colormaps that are not 32 bpp, all bits
'''  * in the image part of the data array must be identical.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1</param>
''' <param name="pix2"> \param[in]    pix2</param>
''' <param name="psame"> \param[out]   psame  1 if same; 0 if different</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixEqual")> _
Friend Shared Function pixEqual(pix1 as IntPTR, pix2 as IntPTR, psame as Integer) as Integer
End Function

' SRC\compare.c (176, 1)
' pixEqualWithAlpha()
' pixEqualWithAlpha(PIX *, PIX *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See notes in pixEqual().
'''  *   (2) This is more general than pixEqual(), in that for 32 bpp
'''  * RGBA images, where spp = 4, you can optionally include
'''  * the alpha component in the comparison.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1</param>
''' <param name="pix2"> \param[in]    pix2</param>
''' <param name="use_alpha"> \param[in]    use_alpha   1 to compare alpha in RGBA; 0 to ignore</param>
''' <param name="psame"> \param[out]   psame       1 if same; 0 if different</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixEqualWithAlpha")> _
Friend Shared Function pixEqualWithAlpha(pix1 as IntPTR, pix2 as IntPTR, use_alpha as Integer, psame as Integer) as Integer
End Function

' SRC\compare.c (378, 1)
' pixEqualWithCmap()
' pixEqualWithCmap(PIX *, PIX *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This returns same = TRUE if the images have identical content.
'''  *   (2) Both pix must have a colormap, and be of equal size and depth.
'''  * If these conditions are not satisfied, it is not an error;
'''  * the returned result is same = FALSE.
'''  *   (3) We then check whether the colormaps are the same; if so,
'''  * the comparison proceeds 32 bits at a time.
'''  *   (4) If the colormaps are different, the comparison is done by
'''  * slow brute force.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1</param>
''' <param name="pix2"> \param[in]    pix2</param>
''' <param name="psame"> \param[out]   psame</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixEqualWithCmap")> _
Friend Shared Function pixEqualWithCmap(pix1 as IntPTR, pix2 as IntPTR, psame as Integer) as Integer
End Function

' SRC\compare.c (474, 1)
' cmapEqual()
' cmapEqual(PIXCMAP *, PIXCMAP *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This returns %same = TRUE if the colormaps have identical entries.
'''  *   (2) If %ncomps == 4, the alpha components of the colormaps are also
'''  * compared.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cmap1"> \param[in]    cmap1</param>
''' <param name="cmap2"> \param[in]    cmap2</param>
''' <param name="ncomps"> \param[in]    ncomps  3 for RGB, 4 for RGBA</param>
''' <param name="psame"> \param[out]   psame</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="cmapEqual")> _
Friend Shared Function cmapEqual(cmap1 as IntPTR, cmap2 as IntPTR, ncomps as Integer, psame as Integer) as Integer
End Function

' SRC\compare.c (532, 1)
' pixUsesCmapColor()
' pixUsesCmapColor(PIX *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This returns color = TRUE if three things are obtained:
'''  * (a) the pix has a colormap
'''  * (b) the colormap has at least one color entry
'''  * (c) a color entry is actually used
'''  *   (2) It is used in pixEqual() for comparing two images, in a
'''  * situation where it is required to know if the colormap
'''  * has color entries that are actually used in the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     any depth, colormap</param>
''' <param name="pcolor"> \param[out]   pcolor   TRUE if color found</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixUsesCmapColor")> _
Friend Shared Function pixUsesCmapColor(pixs as IntPTR, pcolor as Integer) as Integer
End Function

' SRC\compare.c (598, 1)
' pixCorrelationBinary()
' pixCorrelationBinary(PIX *, PIX *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The correlation is a number between 0.0 and 1.0,
'''  * based on foreground similarity:
'''  *   (|1 AND 2|)**2
'''  *   correlation =  --------------
'''  *  |1| * |2|
'''  * where |x| is the count of foreground pixels in image x.
'''  * If the images are identical, this is 1.0.
'''  * If they have no fg pixels in common, this is 0.0.
'''  * If one or both images have no fg pixels, the correlation is 0.0.
'''  *   (2) Typically the two images are of equal size, but this
'''  * is not enforced.  Instead, the UL corners are aligned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1    1 bpp</param>
''' <param name="pix2"> \param[in]    pix2    1 bpp</param>
''' <param name="pval"> \param[out]   pval    correlation</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCorrelationBinary")> _
Friend Shared Function pixCorrelationBinary(pix1 as IntPTR, pix2 as IntPTR, pval as single) as Integer
End Function

' SRC\compare.c (656, 1)
' pixDisplayDiffBinary()
' pixDisplayDiffBinary(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This gives a color representation of the difference between
'''  * pix1 and pix2.  The color difference depends on the order.
'''  * The pixels in pixd have 4 colors:
'''  *  * unchanged:  black (on), white (off)
'''  *  * on in pix1, off in pix2: red
'''  *  * on in pix2, off in pix1: green
'''  *   (2) This aligns the UL corners of pix1 and pix2, and crops
'''  * to the overlapping pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 4 bpp cmapped, or NULL on error</returns>
''' <param name="pix1"> \param[in]    pix1    1 bpp</param>
''' <param name="pix2"> \param[in]    pix2    1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDisplayDiffBinary")> _
Friend Shared Function pixDisplayDiffBinary(pix1 as IntPTR, pix2 as IntPTR) as IntPTR
End Function

' SRC\compare.c (712, 1)
' pixCompareBinary()
' pixCompareBinary(PIX *, PIX *, l_int32, l_float32 *, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The two images are aligned at the UL corner, and do not
'''  * need to be the same size.
'''  *   (2) If using L_COMPARE_SUBTRACT, pix2 is subtracted from pix1.
'''  *   (3) The total number of pixels is determined by pix1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1       1 bpp</param>
''' <param name="pix2"> \param[in]    pix2       1 bpp</param>
''' <param name="comptype"> \param[in]    comptype   L_COMPARE_XOR, L_COMPARE_SUBTRACT</param>
''' <param name="pfract"> \param[out]   pfract     fraction of pixels that are different</param>
''' <param name="ppixdiff"> \param[out]   ppixdiff   [optional] pix of difference</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCompareBinary")> _
Friend Shared Function pixCompareBinary(pix1 as IntPTR, pix2 as IntPTR, comptype as Integer, pfract as single, ppixdiff as Object) as Integer
End Function

' SRC\compare.c (788, 1)
' pixCompareGrayOrRGB()
' pixCompareGrayOrRGB(PIX *, PIX *, l_int32, l_int32, l_int32 *, l_float32 *, l_float32 *, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The two images are aligned at the UL corner, and do not
'''  * need to be the same size.  If they are not the same size,
'''  * the comparison will be made over overlapping pixels.
'''  *   (2) If there is a colormap, it is removed and the result
'''  * is either gray or RGB depending on the colormap.
'''  *   (3) If RGB, each component is compared separately.
'''  *   (4) If type is L_COMPARE_ABS_DIFF, pix2 is subtracted from pix1
'''  * and the absolute value is taken.
'''  *   (5) If type is L_COMPARE_SUBTRACT, pix2 is subtracted from pix1
'''  * and the result is clipped to 0.
'''  *   (6) The plot output types are specified in gplot.h.
'''  * Use 0 if no difference plot is to be made.
'''  *   (7) If the images are pixelwise identical, no difference
'''  * plot is made, even if requested.  The result (TRUE or FALSE)
'''  * is optionally returned in the parameter 'same'.
'''  *   (8) The average difference (either subtracting or absolute value)
'''  * is optionally returned in the parameter 'diff'.
'''  *   (9) The RMS difference is optionally returned in the
'''  * parameter 'rmsdiff'.  For RGB, we return the average of
'''  * the RMS differences for each of the components.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1      8 or 16 bpp gray, 32 bpp rgb, or colormapped</param>
''' <param name="pix2"> \param[in]    pix2      8 or 16 bpp gray, 32 bpp rgb, or colormapped</param>
''' <param name="comptype"> \param[in]    comptype  L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF</param>
''' <param name="plottype"> \param[in]    plottype  gplot plot output type, or 0 for no plot</param>
''' <param name="psame"> \param[out]   psame     [optional] 1 if pixel values are identical</param>
''' <param name="pdiff"> \param[out]   pdiff     [optional] average difference</param>
''' <param name="prmsdiff"> \param[out]   prmsdiff  [optional] rms of difference</param>
''' <param name="ppixdiff"> \param[out]   ppixdiff  [optional] pix of difference</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCompareGrayOrRGB")> _
Friend Shared Function pixCompareGrayOrRGB(pix1 as IntPTR, pix2 as IntPTR, comptype as Integer, plottype as Integer, psame as Integer, pdiff as single, prmsdiff as single, ppixdiff as Object) as Integer
End Function

' SRC\compare.c (859, 1)
' pixCompareGray()
' pixCompareGray(PIX *, PIX *, l_int32, l_int32, l_int32 *, l_float32 *, l_float32 *, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See pixCompareGrayOrRGB() for details.
'''  *   (2) Use pixCompareGrayOrRGB() if the input pix are colormapped.
'''  *   (3) Note: setting %plottype > 0 can result in writing named
'''  * output files.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1       8 or 16 bpp, not cmapped</param>
''' <param name="pix2"> \param[in]    pix2       8 or 16 bpp, not cmapped</param>
''' <param name="comptype"> \param[in]    comptype   L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF</param>
''' <param name="plottype"> \param[in]    plottype   gplot plot output type, or 0 for no plot</param>
''' <param name="psame"> \param[out]   psame      [optional] 1 if pixel values are identical</param>
''' <param name="pdiff"> \param[out]   pdiff      [optional] average difference</param>
''' <param name="prmsdiff"> \param[out]   prmsdiff   [optional] rms of difference</param>
''' <param name="ppixdiff"> \param[out]   ppixdiff   [optional] pix of difference</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCompareGray")> _
Friend Shared Function pixCompareGray(pix1 as IntPTR, pix2 as IntPTR, comptype as Integer, plottype as Integer, psame as Integer, pdiff as single, prmsdiff as single, ppixdiff as Object) as Integer
End Function

' SRC\compare.c (968, 1)
' pixCompareRGB()
' pixCompareRGB(PIX *, PIX *, l_int32, l_int32, l_int32 *, l_float32 *, l_float32 *, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See pixCompareGrayOrRGB() for details.
'''  *   (2) Note: setting %plottype > 0 can result in writing named
'''  * output files.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1       32 bpp rgb</param>
''' <param name="pix2"> \param[in]    pix2       32 bpp rgb</param>
''' <param name="comptype"> \param[in]    comptype   L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF</param>
''' <param name="plottype"> \param[in]    plottype   gplot plot output type, or 0 for no plot</param>
''' <param name="psame"> \param[out]   psame      [optional] 1 if pixel values are identical</param>
''' <param name="pdiff"> \param[out]   pdiff      [optional] average difference</param>
''' <param name="prmsdiff"> \param[out]   prmsdiff   [optional] rms of difference</param>
''' <param name="ppixdiff"> \param[out]   ppixdiff   [optional] pix of difference</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCompareRGB")> _
Friend Shared Function pixCompareRGB(pix1 as IntPTR, pix2 as IntPTR, comptype as Integer, plottype as Integer, psame as Integer, pdiff as single, prmsdiff as single, ppixdiff as Object) as Integer
End Function

' SRC\compare.c (1124, 1)
' pixCompareTiled()
' pixCompareTiled(PIX *, PIX *, l_int32, l_int32, l_int32, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) With L_MEAN_ABSVAL, we compute for each tile the
'''  * average abs value of the pixel component difference between
'''  * the two (aligned) images.  With L_ROOT_MEAN_SQUARE, we
'''  * compute instead the rms difference over all components.
'''  *   (2) The two input pix must be the same depth.  Comparison is made
'''  * using UL corner alignment.
'''  *   (3) For 32 bpp, the distance between corresponding tiles
'''  * is found by averaging the measured difference over all three
'''  * components of each pixel in the tile.
'''  *   (4) The result, pixdiff, contains one pixel for each source tile.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1       8 bpp or 32 bpp rgb</param>
''' <param name="pix2"> \param[in]    pix2       8 bpp 32 bpp rgb</param>
''' <param name="sx"> \param[in]    sx, sy     tile size; must be > 1 in each dimension</param>
''' <param name="sy"> \param[in]    type       L_MEAN_ABSVAL or L_ROOT_MEAN_SQUARE</param>
''' <param name="type"> \param[out]   ppixdiff   pix of difference</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCompareTiled")> _
Friend Shared Function pixCompareTiled(pix1 as IntPTR, pix2 as IntPTR, sx as Integer, sy as Integer, type as Integer, ppixdiff as Object) as Integer
End Function

' SRC\compare.c (1218, 1)
' pixCompareRankDifference()
' pixCompareRankDifference(PIX *, PIX *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This answers the question: if the pixel values in each
'''  * component are compared by absolute difference, for
'''  * any value of difference, what is the fraction of
'''  * pixel pairs that have a difference of this magnitude
'''  * or greater.  For a difference of 0, the fraction is 1.0.
'''  * In this sense, it is a mapping from pixel difference to
'''  * rank order of difference.
'''  *   (2) The two images are aligned at the UL corner, and do not
'''  * need to be the same size.  If they are not the same size,
'''  * the comparison will be made over overlapping pixels.
'''  *   (3) If there is a colormap, it is removed and the result
'''  * is either gray or RGB depending on the colormap.
'''  *   (4) If RGB, pixel differences for each component are aggregated
'''  * into a single histogram.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  narank      numa of rank difference, or NULL on error</returns>
''' <param name="pix1"> \param[in]    pix1      8 bpp gray or 32 bpp rgb, or colormapped</param>
''' <param name="pix2"> \param[in]    pix2      8 bpp gray or 32 bpp rgb, or colormapped</param>
''' <param name="factor"> \param[in]    factor    subsampling factor; use 0 or 1 for no subsampling</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCompareRankDifference")> _
Friend Shared Function pixCompareRankDifference(pix1 as IntPTR, pix2 as IntPTR, factor as Integer) as IntPTR
End Function

' SRC\compare.c (1303, 1)
' pixTestForSimilarity()
' pixTestForSimilarity(PIX *, PIX *, l_int32, l_int32, l_float32, l_float32, l_int32 *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This takes 2 pix that are the same size and determines using
'''  * 3 input parameters if they are "similar".  The first parameter
'''  * %mindiff establishes a criterion of pixel-to-pixel similarity:
'''  * two pixels are not similar if their difference in value is
'''  * at least mindiff.  Then %maxfract and %maxave are thresholds
'''  * on the number and distribution of dissimilar pixels
'''  * allowed for the two pix to be similar.   If the pix are
'''  * to be similar, neither threshold can be exceeded.
'''  *   (2) In setting the %maxfract and %maxave thresholds, you have
'''  * these options:
'''  *   (a) Base the comparison only on %maxfract.  Then set
'''  * %maxave = 0.0 or 256.0.  (If 0, we always ignore it.)
'''  *   (b) Base the comparison only on %maxave.  Then set
'''  * %maxfract = 1.0.
'''  *   (c) Base the comparison on both thresholds.
'''  *   (3) Example of values that can be expected at mindiff = 15 when
'''  * comparing lossless png encoding with jpeg encoding, q=75:
'''  * (smoothish bg) fractdiff = 0.01, avediff = 2.5
'''  * (natural scene)   fractdiff = 0.13, avediff = 3.5
'''  * To identify these images as 'similar', select maxfract
'''  * and maxave to be upper bounds of what you expect.
'''  *   (4) See pixGetDifferenceStats() for a discussion of why we subtract
'''  * mindiff from the computed average diff of the nonsimilar pixels
'''  * to get the 'avediff' returned by that function.
'''  *   (5) If there is a colormap, it is removed and the result
'''  * is either gray or RGB depending on the colormap.
'''  *   (6) If RGB, the maximum difference between pixel components is
'''  * saved in the histogram.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1         8 bpp gray or 32 bpp rgb, or colormapped</param>
''' <param name="pix2"> \param[in]    pix2         8 bpp gray or 32 bpp rgb, or colormapped</param>
''' <param name="factor"> \param[in]    factor       subsampling factor; use 0 or 1 for no subsampling</param>
''' <param name="mindiff"> \param[in]    mindiff      minimum pixel difference to be counted; > 0</param>
''' <param name="maxfract"> \param[in]    maxfract     maximum fraction of pixels allowed to have</param>
''' <param name="maxave"> \param[in]    maxave       maximum average difference of pixels allowed for</param>
''' <param name="psimilar"> \param[out]   psimilar     1 if similar, 0 otherwise</param>
''' <param name="details"> \param[in]    details      use 1 to give normalized histogram and other data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTestForSimilarity")> _
Friend Shared Function pixTestForSimilarity(pix1 as IntPTR, pix2 as IntPTR, factor as Integer, mindiff as Integer, maxfract as single, maxave as single, psimilar as Integer, details as Integer) as Integer
End Function

' SRC\compare.c (1382, 1)
' pixGetDifferenceStats()
' pixGetDifferenceStats(PIX *, PIX *, l_int32, l_int32, l_float32 *, l_float32 *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This takes a threshold %mindiff and describes the difference
'''  * between two images in terms of two numbers:
'''  *   (a) the fraction of pixels, %fractdiff, whose difference
'''  * equals or exceeds the threshold %mindiff, and
'''  *   (b) the average value %avediff of the difference in pixel value
'''  * for the pixels in the set given by (a), after you subtract
'''  * %mindiff.  The reason for subtracting %mindiff is that
'''  * you then get a useful measure for the rate of falloff
'''  * of the distribution for larger differences.  For example,
'''  * if %mindiff = 10 and you find that %avediff = 2.5, it
'''  * says that of the pixels with diff > 10, the average of
'''  * their diffs is just mindiff + 2.5 = 12.5.  This is a
'''  * fast falloff in the histogram with increasing difference.
'''  *   (2) The two images are aligned at the UL corner, and do not
'''  * need to be the same size.  If they are not the same size,
'''  * the comparison will be made over overlapping pixels.
'''  *   (3) If there is a colormap, it is removed and the result
'''  * is either gray or RGB depending on the colormap.
'''  *   (4) If RGB, the maximum difference between pixel components is
'''  * saved in the histogram.
'''  *   (5) Set %details == 1 to see the difference histogram and get
'''  * an output that shows for each value of %mindiff, what are the
'''  * minimum values required for fractdiff and avediff in order
'''  * that the two pix will be considered similar.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1        8 bpp gray or 32 bpp rgb, or colormapped</param>
''' <param name="pix2"> \param[in]    pix2        8 bpp gray or 32 bpp rgb, or colormapped</param>
''' <param name="factor"> \param[in]    factor      subsampling factor; use 0 or 1 for no subsampling</param>
''' <param name="mindiff"> \param[in]    mindiff     minimum pixel difference to be counted; > 0</param>
''' <param name="pfractdiff"> \param[out]   pfractdiff  fraction of pixels with diff greater than or</param>
''' <param name="pavediff"> \param[out]   pavediff    average difference of pixels with diff greater</param>
''' <param name="details"> \param[in]    details     use 1 to give normalized histogram and other data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetDifferenceStats")> _
Friend Shared Function pixGetDifferenceStats(pix1 as IntPTR, pix2 as IntPTR, factor as Integer, mindiff as Integer, pfractdiff as single, pavediff as single, details as Integer) as Integer
End Function

' SRC\compare.c (1484, 1)
' pixGetDifferenceHistogram()
' pixGetDifferenceHistogram(PIX *, PIX *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The two images are aligned at the UL corner, and do not
'''  * need to be the same size.  If they are not the same size,
'''  * the comparison will be made over overlapping pixels.
'''  *   (2) If there is a colormap, it is removed and the result
'''  * is either gray or RGB depending on the colormap.
'''  *   (3) If RGB, the maximum difference between pixel components is
'''  * saved in the histogram.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na     Numa of histogram of differences, or NULL on error</returns>
''' <param name="pix1"> \param[in]    pix1      8 bpp gray or 32 bpp rgb, or colormapped</param>
''' <param name="pix2"> \param[in]    pix2      8 bpp gray or 32 bpp rgb, or colormapped</param>
''' <param name="factor"> \param[in]    factor    subsampling factor; use 0 or 1 for no subsampling</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetDifferenceHistogram")> _
Friend Shared Function pixGetDifferenceHistogram(pix1 as IntPTR, pix2 as IntPTR, factor as Integer) as IntPTR
End Function

' SRC\compare.c (1615, 1)
' pixGetPerceptualDiff()
' pixGetPerceptualDiff(PIX *, PIX *, l_int32, l_int32, l_int32, l_float32 *, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This takes 2 pix and determines, using 2 input parameters:
'''  *  * %dilation specifies the amount of grayscale or color
'''  * dilation to apply to the images, to compensate for
'''  * a small amount of misregistration.  A typical number might
'''  * be 5, which uses a 5x5 Sel.  Grayscale dilation expands
'''  * lighter pixels into darker pixel regions.
'''  *  * %mindiff determines the threshold on the difference in
'''  * pixel values to be counted -- two pixels are not similar
'''  * if their difference in value is at least %mindiff.  For
'''  * color pixels, we use the maximum component difference.
'''  *   (2) The pixelwise comparison is always done with the UL corners
'''  * aligned.  The sizes of pix1 and pix2 need not be the same,
'''  * although in practice it can be useful to scale to the same size.
'''  *   (3) If there is a colormap, it is removed and the result
'''  * is either gray or RGB depending on the colormap.
'''  *   (4) Two optional diff images can be retrieved (typ. for debugging):
'''  *  pixdiff1: the gray or color difference
'''  *  pixdiff2: thresholded to 1 bpp for pixels exceeding %mindiff
'''  *   (5) The returned value of fract can be compared to some threshold,
'''  * which is application dependent.
'''  *   (6) This method is in analogy to the two-sided hausdorff transform,
'''  * except here it is for d > 1.  For d == 1 (see pixRankHaustest()),
'''  * we verify that when one pix1 is dilated, it covers at least a
'''  * given fraction of the pixels in pix2, and v.v.; in that
'''  * case, the two pix are sufficiently similar.  Here, we
'''  * do an analogous thing: subtract the dilated pix1 from pix2 to
'''  * get a 1-sided hausdorff-like transform.  Then do it the
'''  * other way.  Take the component-wise max of the two results,
'''  * and threshold to get the fraction of pixels with a difference
'''  * below the threshold.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs1"> \param[in]    pixs1       8 bpp gray or 32 bpp rgb, or colormapped</param>
''' <param name="pixs2"> \param[in]    pixs2       8 bpp gray or 32 bpp rgb, or colormapped</param>
''' <param name="sampling"> \param[in]    sampling    subsampling factor; use 0 or 1 for no subsampling</param>
''' <param name="dilation"> \param[in]    dilation    size of grayscale or color Sel; odd</param>
''' <param name="mindiff"> \param[in]    mindiff     minimum pixel difference to be counted; > 0</param>
''' <param name="pfract"> \param[out]   pfract      fraction of pixels with diff greater than mindiff</param>
''' <param name="ppixdiff1"> \param[out]   ppixdiff1   [optional] showing difference (gray or color)</param>
''' <param name="ppixdiff2"> \param[out]   ppixdiff2   [optional] showing pixels of sufficient diff</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetPerceptualDiff")> _
Friend Shared Function pixGetPerceptualDiff(pixs1 as IntPTR, pixs2 as IntPTR, sampling as Integer, dilation as Integer, mindiff as Integer, pfract as single, ppixdiff1 as Object, ppixdiff2 as Object) as Integer
End Function

' SRC\compare.c (1778, 1)
' pixGetPSNR()
' pixGetPSNR(PIX *, PIX *, l_int32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This computes the power S/N ratio, in dB, for the difference
'''  * between two images.  By convention, the power S/N
'''  * for a grayscale image is ('log' == log base 10,
'''  * and 'ln == log base e):
'''  *   PSNR = 10 * log((255/MSE)^2)
'''  *  = 4.3429 * ln((255/MSE)^2)
'''  *  = -4.3429 * ln((MSE/255)^2)
'''  * where MSE is the mean squared error.
'''  * Here are some examples:
'''  * MSE PSNR
'''  * --- ----
'''  * 10  28.1
'''  * 3   38.6
'''  * 1   48.1
'''  * 0.1 68.1
'''  *   (2) If pix1 and pix2 have the same pixel values, the MSE = 0.0
'''  * and the PSNR is infinity.  For that case, this returns
'''  * PSNR = 1000, which corresponds to the very small MSE of
'''  * about 10^(-48).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1, pix2     8 or 32 bpp; no colormap</param>
''' <param name="pix2"> \param[in]    factor         sampling factor; >= 1</param>
''' <param name="factor"> \param[out]   ppsnr          power signal/noise ratio difference</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetPSNR")> _
Friend Shared Function pixGetPSNR(pix1 as IntPTR, pix2 as IntPTR, factor as Integer, ppsnr as single) as Integer
End Function

' SRC\compare.c (1893, 1)
' pixaComparePhotoRegionsByHisto()
' pixaComparePhotoRegionsByHisto(PIXA *, l_float32, l_float32, l_int32, l_int32, l_int32, l_float32, NUMA **, l_float32 **, PIX **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function takes a pixa of cropped photo images and
'''  * compares each one to the others for similarity.
'''  * Each image is first tested to see if it is a photo that can
'''  * be compared by tiled histograms.  If so, it is padded to put
'''  * the centroid in the center of the image, and the histograms
'''  * are generated.  The final step of comparing each histogram
'''  * with all the others is very fast.
'''  *   (2) An initial filter gives %score = 0 if the ratio of widths
'''  * and heights (smallest / largest) does not exceed a
'''  * threshold %minratio.  If set at 1.0, both images must be
'''  * exactly the same size.  A typical value for %minratio is 0.9.
'''  *   (3) The comparison score between two images is a value in [0.0 .. 1.0].
'''  * If the comparison score >= %simthresh, the images are placed in
'''  * the same similarity class.  Default value for %simthresh is 0.25.
'''  *   (4) An array %nai of similarity class indices for pix in the
'''  * input pixa is returned.
'''  *   (5) There are two debugging options:
'''  * * An optional 2D matrix of scores is returned as a 1D array.
'''  *   A visualization of this is written to a temp file.
'''  * * An optional pix showing the similarity classes can be
'''  *   returned.  Text in each input pix is reproduced.
'''  *   (6) See the notes in pixComparePhotoRegionsByHisto() for details
'''  * on the implementation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa        any depth; colormap OK</param>
''' <param name="minratio"> \param[in]    minratio    requiring sizes be compatible; < 1.0</param>
''' <param name="textthresh"> \param[in]    textthresh  threshold for text/photo; use 0 for default</param>
''' <param name="factor"> \param[in]    factor      subsampling; >= 1</param>
''' <param name="nx"> \param[in]    nx, ny      num subregions to use for histograms; e.g. 3x3</param>
''' <param name="ny"> \param[in]    simthresh   threshold for similarity; use 0 for default</param>
''' <param name="simthresh"> \param[out]   pnai array  giving similarity class indices</param>
''' <param name="pnai"> \param[out]   pscores     [optional] score matrix as 1-D array of size N^2</param>
''' <param name="pscores"> \param[out]   ppixd       [optional] pix of similarity classes</param>
''' <param name="ppixd"> \param[in]    debug       1 to output histograms; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaComparePhotoRegionsByHisto")> _
Friend Shared Function pixaComparePhotoRegionsByHisto(pixa as IntPTR, minratio as single, textthresh as single, factor as Integer, nx as Integer, ny as Integer, simthresh as single, pnai as Object, pscores as Object, ppixd as Object, debug as Integer) as Integer
End Function

' SRC\compare.c (2104, 1)
' pixComparePhotoRegionsByHisto()
' pixComparePhotoRegionsByHisto(PIX *, PIX *, BOX *, BOX *, l_float32, l_int32, l_int32, l_int32, l_float32 *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function compares two grayscale photo regions.  If a
'''  * box is given, the region is clipped; otherwise assume
'''  * the entire images are photo regions.  This is done with a
'''  * set of (nx * ny) spatially aligned histograms, which are
'''  * aligned using the centroid of the inverse image.
'''  *   (2) An initial filter gives %score = 0 if the ratio of widths
'''  * and heights (smallest / largest) does not exceed a
'''  * threshold %minratio.  This must be between 0.5 and 1.0.
'''  * If set at 1.0, both images must be exactly the same size.
'''  * A typical value for %minratio is 0.9.
'''  *   (3) Because this function should not be used on text or
'''  * line graphics, which can give false positive results
'''  * (i.e., high scores for different images), filter the images
'''  * using pixGenPhotoHistos(), which returns tiled histograms
'''  * only if an image is not text and comparison is expected
'''  * to work with histograms.  If either image fails the test,
'''  * the comparison returns a score of 0.0.
'''  *   (4) The white value counts in the histograms are removed; they
'''  * are typically pixels that were padded to achieve alignment.
'''  *   (5) For an efficient representation of the histogram, normalize
'''  * using a multiplicative factor so that the number in the
'''  * maximum bucket is 255.  It then takes 256 bytes to store.
'''  *   (6) When comparing the histograms of two regions, use the
'''  * Earth Mover distance (EMD), with the histograms normalized
'''  * so that the sum over bins is the same.  Further normalize
'''  * by dividing by 255, so that the result is in [0.0 ... 1.0].
'''  *   (7) Get a similarity score S = 1.0 - k * D, where
'''  *   k is a constant, say in the range 5-10
'''  *   D = normalized EMD
'''  * and for multiple tiles, take the Min(S) to be the final score.
'''  * Using aligned tiles gives protection against accidental
'''  * similarity of the overall grayscale histograms.
'''  * A small number of aligned tiles works well.
'''  *   (8) With debug on, you get a pdf that shows, for each tile,
'''  * the images, histograms and score.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1, pix2    any depth; colormap OK</param>
''' <param name="pix2"> \param[in]    box1, box2    [optional] photo regions from each; can be null</param>
''' <param name="box1"> \param[in]    minratio      requiring sizes be compatible; < 1.0</param>
''' <param name="box2"> \param[in]    factor        subsampling factor; >= 1</param>
''' <param name="minratio"> \param[in]    nx, ny        num subregions to use for histograms; e.g. 3x3</param>
''' <param name="factor"> \param[out]   pscore        similarity score of histograms</param>
''' <param name="nx"> \param[in]    debugflag     1 for debug output; 0 for no debugging</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixComparePhotoRegionsByHisto")> _
Friend Shared Function pixComparePhotoRegionsByHisto(pix1 as IntPTR, pix2 as IntPTR, box1 as IntPTR, box2 as IntPTR, minratio as single, factor as Integer, nx as Integer, ny as Integer, pscore as single, debugflag as Integer) as Integer
End Function

' SRC\compare.c (2214, 1)
' pixGenPhotoHistos()
' pixGenPhotoHistos(PIX *, BOX *, l_int32, l_float32, l_int32, l_int32, NUMAA **, l_int32 *, l_int32 *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This crops and converts to 8 bpp if necessary.  It adds a
'''  * minimal white boundary such that the centroid of the
'''  * photo-inverted image is in the center. This allows
'''  * automatic alignment with histograms of other image regions.
'''  *   (2) The white value in the histogram is removed, because of
'''  * the padding.
'''  *   (3) Use 0 for conservative default (1.3) for thresh.
'''  *   (4) For an efficient representation of the histogram, normalize
'''  * using a multiplicative factor so that the number in the
'''  * maximum bucket is 255.  It then takes 256 bytes to store.
'''  *   (5) With %debugindex > 0, this makes a pdf that shows, for each tile,
'''  * the images and histograms.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs      depth > 1 bpp; colormap OK</param>
''' <param name="box"> \param[in]    box       [optional] region to be selected; can be null</param>
''' <param name="factor"> \param[in]    factor    subsampling; >= 1</param>
''' <param name="thresh"> \param[in]    thresh    threshold for photo/text; use 0 for default</param>
''' <param name="nx"> \param[in]    nx, ny    number of subregions to use for histograms; e.g. 3x3</param>
''' <param name="ny"> \param[out]   pnaa      nx  ny 256-entry gray histograms</param>
''' <param name="pnaa"> \param[out]   pw        width of image used to make histograms</param>
''' <param name="pw"> \param[out]   ph        height of image used to make histograms</param>
''' <param name="ph"> \param[in]    debugindex  0 for no debugging; positive integer otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenPhotoHistos")> _
Friend Shared Function pixGenPhotoHistos(pixs as IntPTR, box as IntPTR, factor as Integer, thresh as single, nx as Integer, ny as Integer, pnaa as Object, pw as Integer, ph as Integer, debugindex as Integer) as Integer
End Function

' SRC\compare.c (2326, 1)
' pixPadToCenterCentroid()
' pixPadToCenterCentroid(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This add minimum white padding to an 8 bpp pix, such that
'''  * the centroid of the photometric inverse is in the center of
'''  * the resulting image.  Thus in computing the centroid,
'''  * black pixels have weight 255, and white pixels have weight 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd padded with white pixels, or NULL on error.</returns>
''' <param name="pixs"> \param[in]    pixs     any depth, colormap OK</param>
''' <param name="factor"> \param[in]    factor   subsampling for centroid; >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixPadToCenterCentroid")> _
Friend Shared Function pixPadToCenterCentroid(pixs as IntPTR, factor as Integer) as IntPTR
End Function

' SRC\compare.c (2380, 1)
' pixCentroid8()
' pixCentroid8(PIX *, l_int32, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This first does a photometric inversion (black = 255, white = 0).
'''  * It then finds the centroid of the result.  The inversion is
'''  * done because white is usually background, so the centroid
'''  * is computed based on the "foreground" gray pixels, and the
'''  * darker the pixel, the more weight it is given.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs    8 bpp</param>
''' <param name="factor"> \param[in]    factor  subsampling factor; >= 1</param>
''' <param name="pcx"> \param[out]   pcx     x value of centroid</param>
''' <param name="pcy"> \param[out]   pcy     y value of centroid</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCentroid8")> _
Friend Shared Function pixCentroid8(pixs as IntPTR, factor as Integer, pcx as single, pcy as single) as Integer
End Function

' SRC\compare.c (2458, 1)
' pixDecideIfPhotoImage()
' pixDecideIfPhotoImage(PIX *, l_int32, l_int32, l_int32, l_float32, NUMAA **, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The input image must be 8 bpp (no colormap), and padded with
'''  * white pixels so the centroid of photo-inverted pixels is at
'''  * the center of the image.
'''  *   (2) If the pix is not almost certainly a photoimage, the returned
'''  * histograms (%naa) are null.
'''  *   (3) If histograms are generated, the white (255) count is set
'''  * to 0.  This removes all pixels values above 230, including
'''  * white padding from the centroid matching operation, from
'''  * consideration.  The resulting histograms are then normalized
'''  * so the maximum count is 255.
'''  *   (4) Default for %thresh is 1.3; this seems sufficiently conservative.
'''  *   (5) Use %pixadebug == NULL unless debug output is requested.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix         8 bpp, centroid in center</param>
''' <param name="factor"> \param[in]    factor      subsampling for histograms; >= 1</param>
''' <param name="nx"> \param[in]    nx, ny      number of subregions to use for histograms</param>
''' <param name="ny"> \param[in]    thresh      threshold for photo/text; use 0 for default</param>
''' <param name="thresh"> \param[out]   pnaa        array of normalized histograms</param>
''' <param name="pnaa"> \param[in]    pixadebug   [optional] use only for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDecideIfPhotoImage")> _
Friend Shared Function pixDecideIfPhotoImage(pix as IntPTR, factor as Integer, nx as Integer, ny as Integer, thresh as single, pnaa as Object, pixadebug as IntPTR) as Integer
End Function

' SRC\compare.c (2590, 1)
' compareTilesByHisto()
' compareTilesByHisto(NUMAA *, NUMAA *, l_float32, l_int32, l_int32, l_int32, l_int32, l_float32 *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) naa1 and naa2 must be generated using pixGenPhotoHistos(),
'''  * using the same tile sizes.
'''  *   (2) The image dimensions must be similar.  The score is 0.0
'''  * if the ratio of widths and heights (smallest / largest)
'''  * exceeds a threshold %minratio, which must be between
'''  * 0.5 and 1.0.  If set at 1.0, both images must be exactly
'''  * the same size.  A typical value for %minratio is 0.9.
'''  *   (2) The input pixadebug is null unless debug output is requested.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="naa1"> \param[in]    naa1, naa2      each is a set of 256 entry histograms</param>
''' <param name="naa2"> \param[in]    minratio        requiring image sizes be compatible; < 1.0</param>
''' <param name="minratio"> \param[in]    w1, h1, w2, h2  image sizes from which histograms were made</param>
''' <param name="w1"> \param[out]   pscore          similarity score of histograms</param>
''' <param name="h1"> \param[in]    pixadebug       [optional] use only for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="compareTilesByHisto")> _
Friend Shared Function compareTilesByHisto(naa1 as IntPTR, naa2 as IntPTR, minratio as single, w1 as Integer, h1 as Integer, w2 as Integer, h2 as Integer, pscore as single, pixadebug as IntPTR) as Integer
End Function

' SRC\compare.c (2758, 1)
' pixCompareGrayByHisto()
' pixCompareGrayByHisto(PIX *, PIX *, BOX *, BOX *, l_float32, l_int32, l_int32, l_int32, l_int32, l_float32 *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function compares two grayscale photo regions.  It can
'''  * do it with a single histogram from each region, or with a
'''  * set of (nx * ny) spatially aligned histograms.  For both
'''  * cases, align the regions using the centroid of the inverse
'''  * image, and crop to the smallest of the two.
'''  *   (2) An initial filter gives %score = 0 if the ratio of widths
'''  * and heights (smallest / largest) does not exceed a
'''  * threshold %minratio.  This must be between 0.5 and 1.0.
'''  * If set at 1.0, both images must be exactly the same size.
'''  * A typical value for %minratio is 0.9.
'''  *   (3) The lightest values in the histogram can be disregarded.
'''  * Set %maxgray to the lightest value to be kept.  For example,
'''  * to eliminate white (255), set %maxgray = 254.  %maxgray must
'''  * be >= 200.
'''  *   (4) For an efficient representation of the histogram, normalize
'''  * using a multiplicative factor so that the number in the
'''  * maximum bucket is 255.  It then takes 256 bytes to store.
'''  *   (5) When comparing the histograms of two regions:
'''  * ~ Use %maxgray = 254 to ignore the white pixels, the number
'''  *   of which may be sensitive to the crop region if the pixels
'''  *   outside that region are white.
'''  * ~ Use the Earth Mover distance (EMD), with the histograms
'''  *   normalized so that the sum over bins is the same.
'''  *   Further normalize by dividing by 255, so that the result
'''  *   is in [0.0 ... 1.0].
'''  *   (6) Get a similarity score S = 1.0 - k * D, where
'''  *   k is a constant, say in the range 5-10
'''  *   D = normalized EMD
'''  * and for multiple tiles, take the Min(S) to be the final score.
'''  * Using aligned tiles gives protection against accidental
'''  * similarity of the overall grayscale histograms.
'''  * A small number of aligned tiles works well.
'''  *   (7) With debug on, you get a pdf that shows, for each tile,
'''  * the images, histograms and score.
'''  *   (8) When to use:
'''  * (a) Because this function should not be used on text or
'''  *  line graphics, which can give false positive results
'''  *  (i.e., high scores for different images), the input
'''  *  images should be filtered.
'''  * (b) To filter, first use pixDecideIfText().  If that function
'''  *  says the image is text, do not use it.  If the function
'''  *  says it is not text, it still may be line graphics, and
'''  *  in that case, use:
'''  *  pixGetGrayHistogramTiled()
'''  *  grayInterHistogramStats()
'''  *  to determine whether it is photo or line graphics.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1, pix2  any depth; colormap OK</param>
''' <param name="pix2"> \param[in]    box1, box2  [optional] region selected from each; can be null</param>
''' <param name="box1"> \param[in]    minratio    requiring sizes be compatible; < 1.0</param>
''' <param name="box2"> \param[in]    maxgray     max value to keep in histo; >= 200, 255 to keep all</param>
''' <param name="minratio"> \param[in]    factor      subsampling factor; >= 1</param>
''' <param name="maxgray"> \param[in]    nx, ny      num subregions to use for histograms; e.g. 3x3</param>
''' <param name="factor"> \param[out]   pscore      similarity score of histograms</param>
''' <param name="nx"> \param[in]    debugflag   1 for debug output; 0 for no debugging</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCompareGrayByHisto")> _
Friend Shared Function pixCompareGrayByHisto(pix1 as IntPTR, pix2 as IntPTR, box1 as IntPTR, box2 as IntPTR, minratio as single, maxgray as Integer, factor as Integer, nx as Integer, ny as Integer, pscore as single, debugflag as Integer) as Integer
End Function

' SRC\compare.c (3011, 1)
' pixCropAlignedToCentroid()
' pixCropAlignedToCentroid(PIX *, PIX *, l_int32, BOX **, BOX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds the maximum crop boxes for two 8 bpp images when
'''  * their centroids of their photometric inverses are aligned.
'''  * Black pixels have weight 255; white pixels have weight 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1, pix2   any depth; colormap OK</param>
''' <param name="pix2"> \param[in]    factor       subsampling; >= 1</param>
''' <param name="factor"> \param[out]   pbox1        crop box for pix1</param>
''' <param name="pbox1"> \param[out]   pbox2        crop box for pix2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCropAlignedToCentroid")> _
Friend Shared Function pixCropAlignedToCentroid(pix1 as IntPTR, pix2 as IntPTR, factor as Integer, pbox1 as Object, pbox2 as Object) as Integer
End Function

' SRC\compare.c (3086, 1)
' l_compressGrayHistograms()
' l_compressGrayHistograms(NUMAA *, l_int32, l_int32, size_t *) as l_uint8 *
''' <summary>
''' * Notes:
'''  *   (1) This first writes w and h to the byte array as 4 byte ints.
'''  *   (2) Then it normalizes each histogram to a max value of 255,
'''  * and saves each value as a byte.  If there are
'''  * N histograms, the output bytearray has 8 + 256 * N bytes.
'''  *   (3) Further compression of the array with zlib yields only about
'''  * a 25% decrease in size, so we don't bother.  If size reduction
'''  * were important, a lossy transform using a 1-dimensional DCT
'''  * would be effective, because we don't care about the fine
'''  * details of these histograms.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="naa"> \param[in]    naa     set of 256-entry histograms</param>
''' <param name="w"> \param[in]    w, h    size of image</param>
''' <param name="h"> \param[out]   psize   size of byte array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_compressGrayHistograms")> _
Friend Shared Function l_compressGrayHistograms(naa as IntPTR, w as Integer, h as Integer, psize as ULong) as String
End Function

' SRC\compare.c (3154, 1)
' l_uncompressGrayHistograms()
' l_uncompressGrayHistograms(l_uint8 *, size_t, l_int32 *, l_int32 *) as NUMAA *
''' <summary>
''' * Notes:
'''  *   (1) The first 8 bytes are read as two 32-bit ints.
'''  *   (2) Then this constructs a numaa representing some number of
'''  * gray histograms that are normalized such that the max value
'''  * in each histogram is 255.  The data is stored as a byte
'''  * array, with 256 bytes holding the data for each histogram.
'''  * Each gray histogram was computed from a tile of a grayscale image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numaa     representing N histograms, each with 256 bins,</returns>
''' <param name="bytea"> \param[in]    bytea    byte array of size 8 + 256  N, N an integer</param>
''' <param name="size"> \param[in]    size     size of byte array</param>
''' <param name="pw"> \param[out]   pw       width of the image that generated the histograms</param>
''' <param name="ph"> \param[out]   ph       height of the image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_uncompressGrayHistograms")> _
Friend Shared Function l_uncompressGrayHistograms(bytea as Byte, size as ULong, pw as Integer, ph as Integer) as IntPTR
End Function

' SRC\compare.c (3223, 1)
' pixCompareWithTranslation()
' pixCompareWithTranslation(PIX *, PIX *, l_int32, l_int32 *, l_int32 *, l_float32 *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does a coarse-to-fine search for best translational
'''  * alignment of two images, measured by a scoring function
'''  * that is the correlation between the fg pixels.
'''  *   (2) The threshold is used if the images aren't 1 bpp.
'''  *   (3) With debug on, you get a pdf that shows, as a grayscale
'''  * image, the score as a function of shift from the initial
'''  * estimate, for each of the four levels.  The shift is 0 at
'''  * the center of the image.
'''  *   (4) With debug on, you also get a pdf that shows the
'''  * difference at the best alignment between the two images,
'''  * at each of the four levels.  The red and green pixels
'''  * show locations where one image has a fg pixel and the
'''  * other doesn't.  The black pixels are where both images
'''  * have fg pixels, and white pixels are where neither image
'''  * has fg pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1, pix2    any depth; colormap OK</param>
''' <param name="pix2"> \param[in]    thresh        threshold for converting to 1 bpp</param>
''' <param name="thresh"> \param[out]   pdelx         x translation on pix2 to align with pix1</param>
''' <param name="pdelx"> \param[out]   pdely         y translation on pix2 to align with pix1</param>
''' <param name="pdely"> \param[out]   pscore        correlation score at best alignment</param>
''' <param name="pscore"> \param[in]    debugflag     1 for debug output; 0 for no debugging</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCompareWithTranslation")> _
Friend Shared Function pixCompareWithTranslation(pix1 as IntPTR, pix2 as IntPTR, thresh as Integer, pdelx as Integer, pdely as Integer, pscore as single, debugflag as Integer) as Integer
End Function

' SRC\compare.c (3377, 1)
' pixBestCorrelation()
' pixBestCorrelation(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *, l_float32 *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This maximizes the correlation score between two 1 bpp images,
'''  * by starting with an estimate of the alignment
'''  * (%etransx, %etransy) and computing the correlation around this.
'''  * It optionally returns the shift (%delx, %dely) that maximizes
'''  * the correlation score when pix2 is shifted by this amount
'''  * relative to pix1.
'''  *   (2) Get the centroids of pix1 and pix2, using pixCentroid(),
'''  * to compute (%etransx, %etransy).  Get the areas using
'''  * pixCountPixels().
'''  *   (3) The centroid of pix2 is shifted with respect to the centroid
'''  * of pix1 by all values between -maxshiftx and maxshiftx,
'''  * and likewise for the y shifts.  Therefore, the number of
'''  * correlations computed is:
'''  *   (2 * maxshiftx + 1) * (2 * maxshifty + 1)
'''  * Consequently, if pix1 and pix2 are large, you should do this
'''  * in a coarse-to-fine sequence.  See the use of this function
'''  * in pixCompareWithTranslation().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1      1 bpp</param>
''' <param name="pix2"> \param[in]    pix2      1 bpp</param>
''' <param name="area1"> \param[in]    area1     number of on pixels in pix1</param>
''' <param name="area2"> \param[in]    area2     number of on pixels in pix2</param>
''' <param name="etransx"> \param[in]    etransx   estimated x translation of pix2 to align with pix1</param>
''' <param name="etransy"> \param[in]    etransy   estimated y translation of pix2 to align with pix1</param>
''' <param name="maxshift"> \param[in]    maxshift  max x and y shift of pix2, around the estimated</param>
''' <param name="tab8"> \param[in]    tab8      [optional] sum tab for ON pixels in byte; can be NULL</param>
''' <param name="pdelx"> \param[out]   pdelx     [optional] best x shift of pix2 relative to pix1</param>
''' <param name="pdely"> \param[out]   pdely     [optional] best y shift of pix2 relative to pix1</param>
''' <param name="pscore"> \param[out]   pscore    [optional] maximum score found; can be NULL</param>
''' <param name="debugflag"> \param[in]    debugflag   <= 0 to skip; positive to generate output.</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBestCorrelation")> _
Friend Shared Function pixBestCorrelation(pix1 as IntPTR, pix2 as IntPTR, area1 as Integer, area2 as Integer, etransx as Integer, etransy as Integer, maxshift as Integer, tab8 as Integer, pdelx as Integer, pdely as Integer, pscore as single, debugflag as Integer) as Integer
End Function

#End Region
#Region "SRC\conncomp.c"
' SRC\conncomp.c (110, 13)
' pushFillsegBB()
' pushFillsegBB(L_STACK *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as void
''' <summary>
''' * Notes:
'''  *   (1) This adds a line segment to the stack, and returns its size.
'''  *   (2) The auxiliary stack is used as a storage area to recycle
'''  * fillsegs that are no longer in use.  We only calloc new
'''  * fillsegs if the auxiliary stack is empty.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="stack"> \param[in]    stack</param>
''' <param name="xleft"> \param[in]    xleft, xright</param>
''' <param name="xright"> \param[in]    y</param>
''' <param name="y"> \param[in]    dy</param>
''' <param name="dy"> \param[in]    ymax</param>
''' <param name="ymax"> \param[out]   pminx minimum x</param>
''' <param name="pminx"> \param[out]   pmaxx maximum x</param>
''' <param name="pmaxx"> \param[out]   pminy minimum y</param>
''' <param name="pminy"> \param[out]   pmaxy maximum y</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pushFillsegBB")> _
Friend Shared Function pushFillsegBB(stack as IntPTR, xleft as Integer, xright as Integer, y as Integer, dy as Integer, ymax as Integer, pminx as Integer, pmaxx as Integer, pminy as Integer, pmaxy as Integer) as Boolean ' Org. Void
End Function

' SRC\conncomp.c (114, 13)
' pushFillseg()
' pushFillseg(L_STACK *, l_int32, l_int32, l_int32, l_int32, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) This adds a line segment to the stack.
'''  *   (2) The auxiliary stack is used as a storage area to recycle
'''  * fillsegs that are no longer in use.  We only calloc new
'''  * fillsegs if the auxiliary stack is empty.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="stack"> \param[in]    stack</param>
''' <param name="xleft"> \param[in]    xleft, xright</param>
''' <param name="xright"> \param[in]    y</param>
''' <param name="y"> \param[in]    dy</param>
''' <param name="dy"> \param[in]    ymax</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pushFillseg")> _
Friend Shared Function pushFillseg(stack as IntPTR, xleft as Integer, xright as Integer, y as Integer, dy as Integer, ymax as Integer) as Boolean ' Org. Void
End Function

' SRC\conncomp.c (116, 13)
' popFillseg()
' popFillseg(L_STACK *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as void
''' <summary>
''' * Notes:
'''  *   (1) This removes a line segment from the stack, and returns its size.
'''  *   (2) The surplussed fillseg is placed on the auxiliary stack
'''  * for future use.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="stack"> \param[in]    stack</param>
''' <param name="pxleft"> \param[out]   pxleft left x</param>
''' <param name="pxright"> \param[out]   pxright right x</param>
''' <param name="py"> \param[out]   py y coordinate</param>
''' <param name="pdy"> \param[out]   pdy delta y</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="popFillseg")> _
Friend Shared Function popFillseg(stack as IntPTR, pxleft as Integer, pxright as Integer, py as Integer, pdy as Integer) as Boolean ' Org. Void
End Function

' SRC\conncomp.c (144, 1)
' pixConnComp()
' pixConnComp(PIX *, PIXA **, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This is the top-level call for getting bounding boxes or
'''  * a pixa of the components, and it can be used instead
'''  * of either pixConnCompBB() or pixConnCompPixa(), rsp.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="ppixa"> \param[out]   ppixa   [optional] pixa of each c.c.</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConnComp")> _
Friend Shared Function pixConnComp(pixs as IntPTR, ppixa as Object, connectivity as Integer) as IntPTR
End Function

' SRC\conncomp.c (190, 1)
' pixConnCompPixa()
' pixConnCompPixa(PIX *, PIXA **, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This finds bounding boxes of 4- or 8-connected components
'''  * in a binary image, and saves images of each c.c
'''  * in a pixa array.
'''  *   (2) It sets up 2 temporary pix, and for each c.c. that is
'''  * located in raster order, it erases the c.c. from one pix,
'''  * then uses the b.b. to extract the c.c. from the two pix using
'''  * an XOR, and finally erases the c.c. from the second pix.
'''  *   (3) A clone of the returned boxa (where all boxes in the array
'''  * are clones) is inserted into the pixa.
'''  *   (4) If the input is valid, this always returns a boxa and a pixa.
'''  * If pixs is empty, the boxa and pixa will be empty.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="ppixa"> \param[out]   ppixa pixa of each c.c.</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConnCompPixa")> _
Friend Shared Function pixConnCompPixa(pixs as IntPTR, ppixa as Object, connectivity as Integer) as IntPTR
End Function

' SRC\conncomp.c (304, 1)
' pixConnCompBB()
' pixConnCompBB(PIX *, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *  (1) Finds bounding boxes of 4- or 8-connected components
'''  *   in a binary image.
'''  *  (2) This works on a copy of the input pix.  The c.c. are located
'''  *   in raster order and erased one at a time.  In the process,
'''  *   the b.b. is computed and saved.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConnCompBB")> _
Friend Shared Function pixConnCompBB(pixs as IntPTR, connectivity as Integer) as IntPTR
End Function

' SRC\conncomp.c (387, 1)
' pixCountConnComp()
' pixCountConnComp(PIX *, l_int32, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
''' <param name="pcount"> \param[out]   pcount</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCountConnComp")> _
Friend Shared Function pixCountConnComp(pixs as IntPTR, connectivity as Integer, pcount as Integer) as Integer
End Function

' SRC\conncomp.c (449, 1)
' nextOnPixelInRaster()
' nextOnPixelInRaster(PIX *, l_int32, l_int32, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if a pixel is found; 0 otherwise or on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="xstart"> \param[in]    xstart, ystart  starting point for search</param>
''' <param name="ystart"> \param[out]   px, py  coord value of next ON pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="nextOnPixelInRaster")> _
Friend Shared Function nextOnPixelInRaster(pixs as IntPTR, xstart as Integer, ystart as Integer, px as Integer, py as Integer) as Integer
End Function

' SRC\conncomp.c (483, 1)
' nextOnPixelInRasterLow()
' nextOnPixelInRasterLow(l_uint32 *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if a pixel is found; 0 otherwise or on error</returns>
''' <param name="data"> \param[in]    data pix data</param>
''' <param name="w"> \param[in]    w, h width and height</param>
''' <param name="h"> \param[in]    wpl  words per line</param>
''' <param name="wpl"> \param[in]    xstart, ystart  starting point for search</param>
''' <param name="xstart"> \param[out]   px, py  coord value of next ON pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="nextOnPixelInRasterLow")> _
Friend Shared Function nextOnPixelInRasterLow(data as UInteger, w as Integer, h as Integer, wpl as Integer, xstart as Integer, ystart as Integer, px as Integer, py as Integer) as Integer
End Function

' SRC\conncomp.c (560, 1)
' pixSeedfillBB()
' pixSeedfillBB(PIX *, L_STACK *, l_int32, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This is the high-level interface to Paul Heckbert's
'''  * stack-based seedfill algorithm.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="stack"> \param[in]    stack for holding fillsegs</param>
''' <param name="x"> \param[in]    x,y   location of seed pixel</param>
''' <param name="y"> \param[in]    connectivity  4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfillBB")> _
Friend Shared Function pixSeedfillBB(pixs as IntPTR, stack as IntPTR, x as Integer, y as Integer, connectivity as Integer) as IntPTR
End Function

' SRC\conncomp.c (623, 1)
' pixSeedfill4BB()
' pixSeedfill4BB(PIX *, L_STACK *, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.
'''  *   (2) This operates on the input 1 bpp pix to remove the fg seed
'''  * pixel, at (x,y), and all pixels that are 4-connected to it.
'''  * The seed pixel at (x,y) must initially be ON.
'''  *   (3) Returns the bounding box of the erased 4-cc component.
'''  *   (4) Reference: see Paul Heckbert's stack-based seed fill algorithm
'''  * in "Graphic Gems", ed. Andrew Glassner, Academic
'''  * Press, 1990.  The algorithm description is given
'''  * on pp. 275-277; working C code is on pp. 721-722.)
'''  * The code here follows Heckbert's exactly, except
'''  * we use function calls instead of macros for
'''  * pushing data on and popping data off the stack.
'''  * This makes sense to do because Heckbert's fixed-size
'''  * stack with macros is dangerous: images exist that
'''  * will overrun the stack and crash.   The stack utility
'''  * here grows dynamically as needed, and the fillseg
'''  * structures that are not in use are stored in another
'''  * stack for reuse.  It should be noted that the
'''  * overhead in the function calls (vs. macros) is negligible.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box or NULL on error.</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="stack"> \param[in]    stack for holding fillsegs</param>
''' <param name="x"> \param[in]    x,y   location of seed pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfill4BB")> _
Friend Shared Function pixSeedfill4BB(pixs as IntPTR, stack as IntPTR, x as Integer, y as Integer) as IntPTR
End Function

' SRC\conncomp.c (738, 1)
' pixSeedfill8BB()
' pixSeedfill8BB(PIX *, L_STACK *, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.
'''  *   (2) This operates on the input 1 bpp pix to remove the fg seed
'''  * pixel, at (x,y), and all pixels that are 8-connected to it.
'''  * The seed pixel at (x,y) must initially be ON.
'''  *   (3) Returns the bounding box of the erased 8-cc component.
'''  *   (4) Reference: see Paul Heckbert's stack-based seed fill algorithm
'''  * in "Graphic Gems", ed. Andrew Glassner, Academic
'''  * Press, 1990.  The algorithm description is given
'''  * on pp. 275-277; working C code is on pp. 721-722.)
'''  * The code here follows Heckbert's closely, except
'''  * the leak checks are changed for 8 connectivity.
'''  * See comments on pixSeedfill4BB() for more details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box or NULL on error.</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="stack"> \param[in]    stack for holding fillsegs</param>
''' <param name="x"> \param[in]    x,y   location of seed pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfill8BB")> _
Friend Shared Function pixSeedfill8BB(pixs as IntPTR, stack as IntPTR, x as Integer, y as Integer) as IntPTR
End Function

' SRC\conncomp.c (844, 1)
' pixSeedfill()
' pixSeedfill(PIX *, L_STACK *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This removes the component from pixs with a fg pixel at (x,y).
'''  *   (2) See pixSeedfill4() and pixSeedfill8() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="stack"> \param[in]    stack for holding fillsegs</param>
''' <param name="x"> \param[in]    x,y   location of seed pixel</param>
''' <param name="y"> \param[in]    connectivity  4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfill")> _
Friend Shared Function pixSeedfill(pixs as IntPTR, stack as IntPTR, x as Integer, y as Integer, connectivity as Integer) as Integer
End Function

' SRC\conncomp.c (888, 1)
' pixSeedfill4()
' pixSeedfill4(PIX *, L_STACK *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.
'''  *   (2) This operates on the input 1 bpp pix to remove the fg seed
'''  * pixel, at (x,y), and all pixels that are 4-connected to it.
'''  * The seed pixel at (x,y) must initially be ON.
'''  *   (3) Reference: see pixSeedFill4BB()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="stack"> \param[in]    stack for holding fillsegs</param>
''' <param name="x"> \param[in]    x,y   location of seed pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfill4")> _
Friend Shared Function pixSeedfill4(pixs as IntPTR, stack as IntPTR, x as Integer, y as Integer) as Integer
End Function

' SRC\conncomp.c (982, 1)
' pixSeedfill8()
' pixSeedfill8(PIX *, L_STACK *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.
'''  *   (2) This operates on the input 1 bpp pix to remove the fg seed
'''  * pixel, at (x,y), and all pixels that are 8-connected to it.
'''  * The seed pixel at (x,y) must initially be ON.
'''  *   (3) Reference: see pixSeedFill8BB()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="stack"> \param[in]    stack for holding fillsegs</param>
''' <param name="x"> \param[in]    x,y   location of seed pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfill8")> _
Friend Shared Function pixSeedfill8(pixs as IntPTR, stack as IntPTR, x as Integer, y as Integer) as Integer
End Function

#End Region
#Region "SRC\convertfiles.c"
' SRC\convertfiles.c (67, 1)
' convertFilesTo1bpp()
' convertFilesTo1bpp(const char *, const char *, l_int32, l_int32, l_int32, l_int32, const char *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Images are sorted lexicographically, and the names in the
'''  * output directory are retained except for the extension.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dirin"> \param[in]    dirin</param>
''' <param name="substr"> \param[in]    substr [optional] substring filter on filenames; can be NULL</param>
''' <param name="upscaling"> \param[in]    upscaling 1, 2 or 4; only for input color or grayscale</param>
''' <param name="thresh"> \param[in]    thresh  global threshold for binarization; use 0 for default</param>
''' <param name="firstpage"> \param[in]    firstpage</param>
''' <param name="npages"> \param[in]    npages use 0 to do all from %firstpage to the end</param>
''' <param name="dirout"> \param[in]    dirout</param>
''' <param name="outformat"> \param[in]    outformat IFF_PNG, IFF_TIFF_G4</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertFilesTo1bpp")> _
Friend Shared Function convertFilesTo1bpp(dirin as String, substr as String, upscaling as Integer, thresh as Integer, firstpage as Integer, npages as Integer, dirout as String, outformat as Integer) as Integer
End Function

#End Region
#Region "SRC\convolve.c"
' SRC\convolve.c (97, 13)
' blockconvLow()
' blockconvLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) The full width and height of the convolution kernel
'''  * are (2 * wc + 1) and (2 * hc + 1).
'''  *   (2) The lack of symmetry between the handling of the
'''  * first (hc + 1) lines and the last (hc) lines,
'''  * and similarly with the columns, is due to fact that
'''  * for the pixel at (x,y), the accumulator values are
'''  * taken at (x + wc, y + hc), (x - wc - 1, y + hc),
'''  * (x + wc, y - hc - 1) and (x - wc - 1, y - hc - 1).
'''  *   (3) We compute sums, normalized as if there were no reduced
'''  * area at the boundary.  This under-estimates the value
'''  * of the boundary pixels, so we multiply them by another
'''  * normalization factor that is greater than 1.
'''  *   (4) This second normalization is done first for the first
'''  * hc + 1 lines; then for the last hc lines; and finally
'''  * for the first wc + 1 and last wc columns in the intermediate
'''  * lines.
'''  *   (5) The caller should verify that wc  w and hc  h.
'''  * Under those conditions, illegal reads and writes can occur.
'''  *   (6) Implementation note: to get the same results in the interior
'''  * between this function and pixConvolve(), it is necessary to
'''  * add 0.5 for roundoff in the main loop that runs over all pixels.
'''  * However, if we do that and have white (255) pixels near the
'''  * image boundary, some overflow occurs for pixels very close
'''  * to the boundary.  We can't fix this by subtracting from the
'''  * normalized values for the boundary pixels, because this results
'''  * in underflow if the boundary pixels are black (0).  Empirically,
'''  * adding 0.25 (instead of 0.5) before truncating in the main
'''  * loop will not cause overflow, but this gives some
'''  * off-by-1-level errors in interior pixel values.  So we add
'''  * 0.5 for roundoff in the main loop, and for pixels within a
'''  * half filter width of the boundary, use a L_MIN of the
'''  * computed value and 255 to avoid overflow during normalization.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="data"> \param[in]    data   data of input image, to be convolved</param>
''' <param name="w"> \param[in]    w, h, wpl</param>
''' <param name="h"> \param[in]    dataa    data of 32 bpp accumulator</param>
''' <param name="wpl"> \param[in]    wpla     accumulator</param>
''' <param name="dataa"> \param[in]    wc      convolution "half-width"</param>
''' <param name="wpla"> \param[in]    hc      convolution "half-height"</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="blockconvLow")> _
Friend Shared Function blockconvLow(data as UInteger, w as Integer, h as Integer, wpl as Integer, dataa as UInteger, wpla as Integer, wc as Integer, hc as Integer) as Boolean ' Org. Void
End Function

' SRC\convolve.c (100, 13)
' 
' blockconvAccumLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="blockconvAccumLow")> _
Friend Shared Function blockconvAccumLow(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, d as Integer, wpls as Integer) as Boolean ' Org. Void
End Function

' SRC\convolve.c (103, 13)
' blocksumLow()
' blocksumLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) The full width and height of the convolution kernel
'''  * are (2 * wc + 1) and (2 * hc + 1).
'''  *   (2) The lack of symmetry between the handling of the
'''  * first (hc + 1) lines and the last (hc) lines,
'''  * and similarly with the columns, is due to fact that
'''  * for the pixel at (x,y), the accumulator values are
'''  * taken at (x + wc, y + hc), (x - wc - 1, y + hc),
'''  * (x + wc, y - hc - 1) and (x - wc - 1, y - hc - 1).
'''  *   (3) Compute sums of ON pixels within the block filter size,
'''  * normalized between 0 and 255, as if there were no reduced
'''  * area at the boundary.  This under-estimates the value
'''  * of the boundary pixels, so we multiply them by another
'''  * normalization factor that is greater than 1.
'''  *   (4) This second normalization is done first for the first
'''  * hc + 1 lines; then for the last hc lines; and finally
'''  * for the first wc + 1 and last wc columns in the intermediate
'''  * lines.
'''  *   (5) Required constraints are: wc  w and hc  h.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="datad"> \param[in]    datad  of 8 bpp dest</param>
''' <param name="w"> \param[in]    w, h, wpl  of 8 bpp dest</param>
''' <param name="h"> \param[in]    dataa of 32 bpp accum</param>
''' <param name="wpl"> \param[in]    wpla  of 32 bpp accum</param>
''' <param name="dataa"> \param[in]    wc, hc  convolution "half-width" and "half-height"</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="blocksumLow")> _
Friend Shared Function blocksumLow(datad as UInteger, w as Integer, h as Integer, wpl as Integer, dataa as UInteger, wpla as Integer, wc as Integer, hc as Integer) as Boolean ' Org. Void
End Function

' SRC\convolve.c (127, 1)
' pixBlockconv()
' pixBlockconv(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The full width and height of the convolution kernel
'''  * are (2 * wc + 1) and (2 * hc + 1)
'''  *   (2) Returns a copy if both wc and hc are 0
'''  *   (3) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
'''  * where (w,h) are the dimensions of pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix 8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
''' <param name="wc"> \param[in]    wc, hc   half width/height of convolution kernel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlockconv")> _
Friend Shared Function pixBlockconv(pix as IntPTR, wc as Integer, hc as Integer) as IntPTR
End Function

' SRC\convolve.c (210, 1)
' pixBlockconvGray()
' pixBlockconvGray(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If accum pix is null, make one and destroy it before
'''  * returning; otherwise, just use the input accum pix.
'''  *   (2) The full width and height of the convolution kernel
'''  * are (2 * wc + 1) and (2 * hc + 1).
'''  *   (3) Returns a copy if both wc and hc are 0.
'''  *   (4) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
'''  * where (w,h) are the dimensions of pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     8 bpp</param>
''' <param name="pixacc"> \param[in]    pixacc   pix 32 bpp; can be null</param>
''' <param name="wc"> \param[in]    wc, hc   half width/height of convolution kernel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlockconvGray")> _
Friend Shared Function pixBlockconvGray(pixs as IntPTR, pixacc as IntPTR, wc as Integer, hc as Integer) as IntPTR
End Function

' SRC\convolve.c (455, 1)
' pixBlockconvAccum()
' pixBlockconvAccum(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The general recursion relation is
'''  *   a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)
'''  * For the first line, this reduces to the special case
'''  *   a(i,j) = v(i,j) + a(i, j-1)
'''  * For the first column, the special case is
'''  *   a(i,j) = v(i,j) + a(i-1, j)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  accum pix 32 bpp, or NULL on error.</returns>
''' <param name="pixs"> \param[in]    pixs 1, 8 or 32 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlockconvAccum")> _
Friend Shared Function pixBlockconvAccum(pixs as IntPTR) as IntPTR
End Function

' SRC\convolve.c (636, 1)
' pixBlockconvGrayUnnormalized()
' pixBlockconvGrayUnnormalized(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The full width and height of the convolution kernel
'''  * are (2 * wc + 1) and (2 * hc + 1).
'''  *   (2) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
'''  * where (w,h) are the dimensions of pixs.
'''  *   (3) Returns a copy if both wc and hc are 0.
'''  *   (3) Adds mirrored border to avoid treating the boundary pixels
'''  * specially.  Note that we add wc + 1 pixels to the left
'''  * and wc to the right.  The added width is 2 * wc + 1 pixels,
'''  * and the particular choice simplifies the indexing in the loop.
'''  * Likewise, add hc + 1 pixels to the top and hc to the bottom.
'''  *   (4) To get the normalized result, divide by the area of the
'''  * convolution kernel: (2 * wc + 1) * (2 * hc + 1)
'''  * Specifically, do this:
'''  *   pixc = pixBlockconvGrayUnnormalized(pixs, wc, hc);
'''  *   fract = 1. / ((2 * wc + 1) * (2 * hc + 1));
'''  *   pixMultConstantGray(pixc, fract);
'''  *   pixd = pixGetRGBComponent(pixc, L_ALPHA_CHANNEL);
'''  *   (5) Unlike pixBlockconvGray(), this always computes the accumulation
'''  * pix because its size is tied to wc and hc.
'''  *   (6) Compare this implementation with pixBlockconvGray(), where
'''  * most of the code in blockconvLow() is special casing for
'''  * efficiently handling the boundary.  Here, the use of
'''  * mirrored borders and destination indexing makes the
'''  * implementation very simple.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix 32 bpp; containing the convolution without normalizing</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="wc"> \param[in]    wc, hc   half width/height of convolution kernel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlockconvGrayUnnormalized")> _
Friend Shared Function pixBlockconvGrayUnnormalized(pixs as IntPTR, wc as Integer, hc as Integer) as IntPTR
End Function

' SRC\convolve.c (727, 1)
' pixBlockconvTiled()
' pixBlockconvTiled(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The full width and height of the convolution kernel
'''  * are (2 * wc + 1) and (2 * hc + 1)
'''  *   (2) Returns a copy if both wc and hc are 0
'''  *   (3) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
'''  * where (w,h) are the dimensions of pixs.
'''  *   (4) For nx == ny == 1, this defaults to pixBlockconv(), which
'''  * is typically about twice as fast, and gives nearly
'''  * identical results as pixBlockconvGrayTile().
'''  *   (5) If the tiles are too small, nx and/or ny are reduced
'''  * a minimum amount so that the tiles are expanded to the
'''  * smallest workable size in the problematic direction(s).
'''  *   (6) Why a tiled version?  Three reasons:
'''  * (a) Because the accumulator is a uint32, overflow can occur
'''  *  for an image with more than 16M pixels.
'''  * (b) The accumulator array for 16M pixels is 64 MB; using
'''  *  tiles reduces the size of this array.
'''  * (c) Each tile can be processed independently, in parallel,
'''  *  on a multicore processor.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix 8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
''' <param name="wc"> \param[in]    wc, hc   half width/height of convolution kernel</param>
''' <param name="hc"> \param[in]    nx, ny  subdivision into tiles</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlockconvTiled")> _
Friend Shared Function pixBlockconvTiled(pix as IntPTR, wc as Integer, hc as Integer, nx as Integer, ny as Integer) as IntPTR
End Function

' SRC\convolve.c (853, 1)
' pixBlockconvGrayTile()
' pixBlockconvGrayTile(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The full width and height of the convolution kernel
'''  * are (2 * wc + 1) and (2 * hc + 1)
'''  *   (2) Assumes that the input pixs is padded with (wc + 1) pixels on
'''  * left and right, and with (hc + 1) pixels on top and bottom.
'''  * The returned pix has these stripped off; they are only used
'''  * for computation.
'''  *   (3) Returns a copy if both wc and hc are 0
'''  *   (4) Require that w > 2 * wc + 1 and h > 2 * hc + 1,
'''  * where (w,h) are the dimensions of pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp gray</param>
''' <param name="pixacc"> \param[in]    pixacc 32 bpp accum pix</param>
''' <param name="wc"> \param[in]    wc, hc   half width/height of convolution kernel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlockconvGrayTile")> _
Friend Shared Function pixBlockconvGrayTile(pixs as IntPTR, pixacc as IntPTR, wc as Integer, hc as Integer) as IntPTR
End Function

' SRC\convolve.c (980, 1)
' pixWindowedStats()
' pixWindowedStats(PIX *, l_int32, l_int32, l_int32, PIX **, PIX **, FPIX **, FPIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a high-level convenience function for calculating
'''  * any or all of these derived images.
'''  *   (2) If %hasborder = 0, a border is added and the result is
'''  * computed over all pixels in pixs.  Otherwise, no border is
'''  * added and the border pixels are removed from the output images.
'''  *   (3) These statistical measures over the pixels in the
'''  * rectangular window are:
'''  *   ~ average value: p>  (pixm)
'''  *   ~ average squared value: p*p> (pixms)
'''  *   ~ variance: (p - p>)*(p - p>)> = p*p> - p>*p>  (pixv)
'''  *   ~ square-root of variance: (pixrv)
'''  * where the brackets  .. > indicate that the average value is
'''  * to be taken over the window.
'''  *   (4) Note that the variance is just the mean square difference from
'''  * the mean value; and the square root of the variance is the
'''  * root mean square difference from the mean, sometimes also
'''  * called the 'standard deviation'.
'''  *   (5) The added border, along with the use of an accumulator array,
'''  * allows computation without special treatment of pixels near
'''  * the image boundary, and runs in a time that is independent
'''  * of the size of the convolution kernel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale</param>
''' <param name="wc"> \param[in]    wc, hc   half width/height of convolution kernel</param>
''' <param name="hc"> \param[in]    hasborder use 1 if it already has (wc + 1 border pixels</param>
''' <param name="hasborder"> \param[out]   ppixm [optional] 8 bpp mean value in window</param>
''' <param name="ppixm"> \param[out]   ppixms [optional] 32 bpp mean square value in window</param>
''' <param name="ppixms"> \param[out]   pfpixv [optional] float variance in window</param>
''' <param name="pfpixv"> \param[out]   pfpixrv [optional] float rms deviation from the mean</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWindowedStats")> _
Friend Shared Function pixWindowedStats(pixs as IntPTR, wc as Integer, hc as Integer, hasborder as Integer, ppixm as Object, ppixms as Object, pfpixv as Object, pfpixrv as Object) as Integer
End Function

' SRC\convolve.c (1065, 1)
' pixWindowedMean()
' pixWindowedMean(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The input and output depths are the same.
'''  *   (2) A set of border pixels of width (wc + 1) on left and right,
'''  * and of height (hc + 1) on top and bottom, must be on the
'''  * pix before the accumulator is found.  The output pixd
'''  * (after convolution) has this border removed.
'''  * If %hasborder = 0, the required border is added.
'''  *   (3) Typically, %normflag == 1.  However, if you want the sum
'''  * within the window, rather than a normalized convolution,
'''  * use %normflag == 0.
'''  *   (4) This builds a block accumulator pix, uses it here, and
'''  * destroys it.
'''  *   (5) The added border, along with the use of an accumulator array,
'''  * allows computation without special treatment of pixels near
'''  * the image boundary, and runs in a time that is independent
'''  * of the size of the convolution kernel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 or 32 bpp, average over kernel window</returns>
''' <param name="pixs"> \param[in]    pixs      8 or 32 bpp grayscale</param>
''' <param name="wc"> \param[in]    wc, hc    half width/height of convolution kernel</param>
''' <param name="hc"> \param[in]    hasborder use 1 if it already has (wc + 1 border pixels</param>
''' <param name="hasborder"> \param[in]    normflag  1 for normalization to get average in window;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWindowedMean")> _
Friend Shared Function pixWindowedMean(pixs as IntPTR, wc as Integer, hc as Integer, hasborder as Integer, normflag as Integer) as IntPTR
End Function

' SRC\convolve.c (1182, 1)
' pixWindowedMeanSquare()
' pixWindowedMeanSquare(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) A set of border pixels of width (wc + 1) on left and right,
'''  * and of height (hc + 1) on top and bottom, must be on the
'''  * pix before the accumulator is found.  The output pixd
'''  * (after convolution) has this border removed.
'''  * If %hasborder = 0, the required border is added.
'''  *   (2) The advantage is that we are unaffected by the boundary, and
'''  * it is not necessary to treat pixels within %wc and %hc of the
'''  * border differently.  This is because processing for pixd
'''  * only takes place for pixels in pixs for which the
'''  * kernel is entirely contained in pixs.
'''  *   (3) Why do we have an added border of width (%wc + 1) and
'''  * height (%hc + 1), when we only need %wc and %hc pixels
'''  * to satisfy this condition?  Answer: the accumulators
'''  * are asymmetric, requiring an extra row and column of
'''  * pixels at top and left to work accurately.
'''  *   (4) The added border, along with the use of an accumulator array,
'''  * allows computation without special treatment of pixels near
'''  * the image boundary, and runs in a time that is independent
'''  * of the size of the convolution kernel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp, average over rectangular window of</returns>
''' <param name="pixs"> \param[in]    pixs      8 bpp grayscale</param>
''' <param name="wc"> \param[in]    wc, hc    half width/height of convolution kernel</param>
''' <param name="hc"> \param[in]    hasborder use 1 if it already has (wc + 1 border pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWindowedMeanSquare")> _
Friend Shared Function pixWindowedMeanSquare(pixs as IntPTR, wc as Integer, hc as Integer, hasborder as Integer) as IntPTR
End Function

' SRC\convolve.c (1280, 1)
' pixWindowedVariance()
' pixWindowedVariance(PIX *, PIX *, FPIX **, FPIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The mean and mean square values are precomputed, using
'''  * pixWindowedMean() and pixWindowedMeanSquare().
'''  *   (2) Either or both of the variance and square-root of variance
'''  * are returned as an fpix, where the variance is the
'''  * average over the window of the mean square difference of
'''  * the pixel value from the mean:
'''  * (p - p>)*(p - p>)> = p*p> - p>*p>
'''  *   (3) To visualize the results:
'''  *   ~ for both, use fpixDisplayMaxDynamicRange().
'''  *   ~ for rms deviation, simply convert the output fpix to pix,
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixm"> \param[in]    pixm mean over window; 8 or 32 bpp grayscale</param>
''' <param name="pixms"> \param[in]    pixms mean square over window; 32 bpp</param>
''' <param name="pfpixv"> \param[out]   pfpixv [optional] float variance -- the ms deviation</param>
''' <param name="pfpixrv"> \param[out]   pfpixrv [optional] float rms deviation from the mean</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWindowedVariance")> _
Friend Shared Function pixWindowedVariance(pixm as IntPTR, pixms as IntPTR, pfpixv as Object, pfpixrv as Object) as Integer
End Function

' SRC\convolve.c (1369, 1)
' pixMeanSquareAccum()
' pixMeanSquareAccum(PIX *) as DPIX *
''' <summary>
''' * Notes:
'''  *   (1) Similar to pixBlockconvAccum(), this computes the
'''  * sum of the squares of the pixel values in such a way
'''  * that the value at (i,j) is the sum of all squares in
'''  * the rectangle from the origin to (i,j).
'''  *   (2) The general recursion relation (v are squared pixel values) is
'''  *   a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)
'''  * For the first line, this reduces to the special case
'''  *   a(i,j) = v(i,j) + a(i, j-1)
'''  * For the first column, the special case is
'''  *   a(i,j) = v(i,j) + a(i-1, j)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dpix 64 bit array, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMeanSquareAccum")> _
Friend Shared Function pixMeanSquareAccum(pixs as IntPTR) as IntPTR
End Function

' SRC\convolve.c (1450, 1)
' pixBlockrank()
' pixBlockrank(PIX *, PIX *, l_int32, l_int32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The full width and height of the convolution kernel
'''  * are (2 * wc + 1) and (2 * hc + 1)
'''  *   (2) This returns a pixd where each pixel is a 1 if the
'''  * neighborhood (2 * wc + 1) x (2 * hc + 1)) pixels
'''  * contains the rank fraction of 1 pixels.  Otherwise,
'''  * the returned pixel is 0.  Note that the special case
'''  * of rank = 0.0 is always satisfied, so the returned
'''  * pixd has all pixels with value 1.
'''  *   (3) If accum pix is null, make one, use it, and destroy it
'''  * before returning; otherwise, just use the input accum pix
'''  *   (4) If both wc and hc are 0, returns a copy unless rank == 0.0,
'''  * in which case this returns an all-ones image.
'''  *   (5) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
'''  * where (w,h) are the dimensions of pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp</returns>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
''' <param name="pixacc"> \param[in]    pixacc  pix [optional] 32 bpp</param>
''' <param name="wc"> \param[in]    wc, hc  half width/height of block sum/rank kernel</param>
''' <param name="hc"> \param[in]    rank    between 0.0 and 1.0; 0.5 is median filter</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlockrank")> _
Friend Shared Function pixBlockrank(pixs as IntPTR, pixacc as IntPTR, wc as Integer, hc as Integer, rank as single) as IntPTR
End Function

' SRC\convolve.c (1532, 1)
' pixBlocksum()
' pixBlocksum(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If accum pix is null, make one and destroy it before
'''  * returning; otherwise, just use the input accum pix
'''  *   (2) The full width and height of the convolution kernel
'''  * are (2 * wc + 1) and (2 * hc + 1)
'''  *   (3) Use of wc = hc = 1, followed by pixInvert() on the
'''  * 8 bpp result, gives a nice anti-aliased, and somewhat
'''  * darkened, result on text.
'''  *   (4) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
'''  * where (w,h) are the dimensions of pixs.
'''  *   (5) Returns in each dest pixel the sum of all src pixels
'''  * that are within a block of size of the kernel, centered
'''  * on the dest pixel.  This sum is the number of src ON
'''  * pixels in the block at each location, normalized to 255
'''  * for a block containing all ON pixels.  For pixels near
'''  * the boundary, where the block is not entirely contained
'''  * within the image, we then multiply by a second normalization
'''  * factor that is greater than one, so that all results
'''  * are normalized by the number of participating pixels
'''  * within the block.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp</returns>
''' <param name="pixs"> \param[in]    pixs     1 bpp</param>
''' <param name="pixacc"> \param[in]    pixacc   pix [optional] 32 bpp</param>
''' <param name="wc"> \param[in]    wc, hc   half width/height of block sum/rank kernel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlocksum")> _
Friend Shared Function pixBlocksum(pixs as IntPTR, pixacc as IntPTR, wc as Integer, hc as Integer) as IntPTR
End Function

' SRC\convolve.c (1772, 1)
' pixCensusTransform()
' pixCensusTransform(PIX *, l_int32, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The Census transform was invented by Ramin Zabih and John Woodfill
'''  * ("Non-parametric local transforms for computing visual
'''  * correspondence", Third European Conference on Computer Vision,
'''  * Stockholm, Sweden, May 1994); see publications at
'''  * http://www.cs.cornell.edu/~rdz/index.htm
'''  * This compares each pixel against the average of its neighbors,
'''  * in a square of odd dimension centered on the pixel.
'''  * If the pixel is greater than the average of its neighbors,
'''  * the output pixel value is 1; otherwise it is 0.
'''  *   (2) This can be used as an encoding for an image that is
'''  * fairly robust against slow illumination changes, with
'''  * applications in image comparison and mosaicing.
'''  *   (3) The size of the convolution kernel is (2 * halfsize + 1)
'''  * on a side.  The halfsize parameter must be >= 1.
'''  *   (4) If accum pix is null, make one, use it, and destroy it
'''  * before returning; otherwise, just use the input accum pix
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp</returns>
''' <param name="pixs"> \param[in]    pixs     8 bpp</param>
''' <param name="halfsize"> \param[in]    halfsize of square over which neighbors are averaged</param>
''' <param name="pixacc"> \param[in]    pixacc   pix [optional] 32 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCensusTransform")> _
Friend Shared Function pixCensusTransform(pixs as IntPTR, halfsize as Integer, pixacc as IntPTR) as IntPTR
End Function

' SRC\convolve.c (1872, 1)
' pixConvolve()
' pixConvolve(PIX *, L_KERNEL *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This gives a convolution with an arbitrary kernel.
'''  *   (2) The input pixs must have only one sample/pixel.
'''  * To do a convolution on an RGB image, use pixConvolveRGB().
'''  *   (3) The parameter %outdepth determines the depth of the result.
'''  * If the kernel is normalized to unit sum, the output values
'''  * can never exceed 255, so an output depth of 8 bpp is sufficient.
'''  * If the kernel is not normalized, it may be necessary to use
'''  * 16 or 32 bpp output to avoid overflow.
'''  *   (4) If normflag == 1, the result is normalized by scaling all
'''  * kernel values for a unit sum.  If the sum of kernel values
'''  * is very close to zero, the kernel can not be normalized and
'''  * the convolution will not be performed.  A warning is issued.
'''  *   (5) The kernel values can be positive or negative, but the
'''  * result for the convolution can only be stored as a positive
'''  * number.  Consequently, if it goes negative, the choices are
'''  * to clip to 0 or take the absolute value.  We're choosing
'''  * to take the absolute value.  (Another possibility would be
'''  * to output a second unsigned image for the negative values.)
'''  * If you want to get a clipped result, or to keep the negative
'''  * values in the result, use fpixConvolve(), with the
'''  * converters in fpix2.c between pix and fpix.
'''  *   (6) This uses a mirrored border to avoid special casing on
'''  * the boundaries.
'''  *   (7) To get a subsampled output, call l_setConvolveSampling().
'''  * The time to make a subsampled output is reduced by the
'''  * product of the sampling factors.
'''  *   (8) The function is slow, running at about 12 machine cycles for
'''  * each pixel-op in the convolution.  For example, with a 3 GHz
'''  * cpu, a 1 Mpixel grayscale image, and a kernel with
'''  * (sx * sy) = 25 elements, the convolution takes about 100 msec.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8, 16 or 32 bpp</returns>
''' <param name="pixs"> \param[in]    pixs      8, 16, 32 bpp; no colormap</param>
''' <param name="kel"> \param[in]    kel       kernel</param>
''' <param name="outdepth"> \param[in]    outdepth  of pixd: 8, 16 or 32</param>
''' <param name="normflag"> \param[in]    normflag  1 to normalize kernel to unit sum; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvolve")> _
Friend Shared Function pixConvolve(pixs as IntPTR, kel as IntPTR, outdepth as Integer, normflag as Integer) as IntPTR
End Function

' SRC\convolve.c (2002, 1)
' pixConvolveSep()
' pixConvolveSep(PIX *, L_KERNEL *, L_KERNEL *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does a convolution with a separable kernel that is
'''  * is a sequence of convolutions in x and y.  The two
'''  * one-dimensional kernel components must be input separately;
'''  * the full kernel is the product of these components.
'''  * The support for the full kernel is thus a rectangular region.
'''  *   (2) The input pixs must have only one sample/pixel.
'''  * To do a convolution on an RGB image, use pixConvolveSepRGB().
'''  *   (3) The parameter %outdepth determines the depth of the result.
'''  * If the kernel is normalized to unit sum, the output values
'''  * can never exceed 255, so an output depth of 8 bpp is sufficient.
'''  * If the kernel is not normalized, it may be necessary to use
'''  * 16 or 32 bpp output to avoid overflow.
'''  *   (2) The %normflag parameter is used as in pixConvolve().
'''  *   (4) The kernel values can be positive or negative, but the
'''  * result for the convolution can only be stored as a positive
'''  * number.  Consequently, if it goes negative, the choices are
'''  * to clip to 0 or take the absolute value.  We're choosing
'''  * the former for now.  Another possibility would be to output
'''  * a second unsigned image for the negative values.
'''  *   (5) Warning: if you use l_setConvolveSampling() to get a
'''  * subsampled output, and the sampling factor is larger than
'''  * the kernel half-width, it is faster to use the non-separable
'''  * version pixConvolve().  This is because the first convolution
'''  * here must be done on every raster line, regardless of the
'''  * vertical sampling factor.  If the sampling factor is smaller
'''  * than kernel half-width, it's faster to use the separable
'''  * convolution.
'''  *   (6) This uses mirrored borders to avoid special casing on
'''  * the boundaries.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8, 16 or 32 bpp</returns>
''' <param name="pixs"> \param[in]    pixs 8, 16, 32 bpp; no colormap</param>
''' <param name="kelx"> \param[in]    kelx x-dependent kernel</param>
''' <param name="kely"> \param[in]    kely y-dependent kernel</param>
''' <param name="outdepth"> \param[in]    outdepth of pixd: 8, 16 or 32</param>
''' <param name="normflag"> \param[in]    normflag 1 to normalize kernel to unit sum; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvolveSep")> _
Friend Shared Function pixConvolveSep(pixs as IntPTR, kelx as IntPTR, kely as IntPTR, outdepth as Integer, normflag as Integer) as IntPTR
End Function

' SRC\convolve.c (2074, 1)
' pixConvolveRGB()
' pixConvolveRGB(PIX *, L_KERNEL *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This gives a convolution on an RGB image using an
'''  * arbitrary kernel (which we normalize to keep each
'''  * component within the range [0 ... 255].
'''  *   (2) The input pixs must be RGB.
'''  *   (3) The kernel values can be positive or negative, but the
'''  * result for the convolution can only be stored as a positive
'''  * number.  Consequently, if it goes negative, we clip the
'''  * result to 0.
'''  *   (4) To get a subsampled output, call l_setConvolveSampling().
'''  * The time to make a subsampled output is reduced by the
'''  * product of the sampling factors.
'''  *   (5) This uses a mirrored border to avoid special casing on
'''  * the boundaries.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp rgb</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="kel"> \param[in]    kel  kernel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvolveRGB")> _
Friend Shared Function pixConvolveRGB(pixs as IntPTR, kel as IntPTR) as IntPTR
End Function

' SRC\convolve.c (2133, 1)
' pixConvolveRGBSep()
' pixConvolveRGBSep(PIX *, L_KERNEL *, L_KERNEL *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does a convolution on an RGB image using a separable
'''  * kernel that is a sequence of convolutions in x and y.  The two
'''  * one-dimensional kernel components must be input separately;
'''  * the full kernel is the product of these components.
'''  * The support for the full kernel is thus a rectangular region.
'''  *   (2) The kernel values can be positive or negative, but the
'''  * result for the convolution can only be stored as a positive
'''  * number.  Consequently, if it goes negative, we clip the
'''  * result to 0.
'''  *   (3) To get a subsampled output, call l_setConvolveSampling().
'''  * The time to make a subsampled output is reduced by the
'''  * product of the sampling factors.
'''  *   (4) This uses a mirrored border to avoid special casing on
'''  * the boundaries.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp rgb</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="kelx"> \param[in]    kelx x-dependent kernel</param>
''' <param name="kely"> \param[in]    kely y-dependent kernel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvolveRGBSep")> _
Friend Shared Function pixConvolveRGBSep(pixs as IntPTR, kelx as IntPTR, kely as IntPTR) as IntPTR
End Function

' SRC\convolve.c (2195, 1)
' fpixConvolve()
' fpixConvolve(FPIX *, L_KERNEL *, l_int32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) This gives a float convolution with an arbitrary kernel.
'''  *   (2) If normflag == 1, the result is normalized by scaling all
'''  * kernel values for a unit sum.  If the sum of kernel values
'''  * is very close to zero, the kernel can not be normalized and
'''  * the convolution will not be performed.  A warning is issued.
'''  *   (3) With the FPix, there are no issues about negative
'''  * array or kernel values.  The convolution is performed
'''  * with single precision arithmetic.
'''  *   (4) To get a subsampled output, call l_setConvolveSampling().
'''  * The time to make a subsampled output is reduced by the
'''  * product of the sampling factors.
'''  *   (5) This uses a mirrored border to avoid special casing on
'''  * the boundaries.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd 32 bit float array</returns>
''' <param name="fpixs"> \param[in]    fpixs    32 bit float array</param>
''' <param name="kel"> \param[in]    kel      kernel</param>
''' <param name="normflag"> \param[in]    normflag 1 to normalize kernel to unit sum; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixConvolve")> _
Friend Shared Function fpixConvolve(fpixs as IntPTR, kel as IntPTR, normflag as Integer) as IntPTR
End Function

' SRC\convolve.c (2289, 1)
' fpixConvolveSep()
' fpixConvolveSep(FPIX *, L_KERNEL *, L_KERNEL *, l_int32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) This does a convolution with a separable kernel that is
'''  * is a sequence of convolutions in x and y.  The two
'''  * one-dimensional kernel components must be input separately;
'''  * the full kernel is the product of these components.
'''  * The support for the full kernel is thus a rectangular region.
'''  *   (2) The normflag parameter is used as in fpixConvolve().
'''  *   (3) Warning: if you use l_setConvolveSampling() to get a
'''  * subsampled output, and the sampling factor is larger than
'''  * the kernel half-width, it is faster to use the non-separable
'''  * version pixConvolve().  This is because the first convolution
'''  * here must be done on every raster line, regardless of the
'''  * vertical sampling factor.  If the sampling factor is smaller
'''  * than kernel half-width, it's faster to use the separable
'''  * convolution.
'''  *   (4) This uses mirrored borders to avoid special casing on
'''  * the boundaries.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd 32 bit float array</returns>
''' <param name="fpixs"> \param[in]    fpixs 32 bit float array</param>
''' <param name="kelx"> \param[in]    kelx x-dependent kernel</param>
''' <param name="kely"> \param[in]    kely y-dependent kernel</param>
''' <param name="normflag"> \param[in]    normflag 1 to normalize kernel to unit sum; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixConvolveSep")> _
Friend Shared Function fpixConvolveSep(fpixs as IntPTR, kelx as IntPTR, kely as IntPTR, normflag as Integer) as IntPTR
End Function

' SRC\convolve.c (2367, 1)
' pixConvolveWithBias()
' pixConvolveWithBias(PIX *, L_KERNEL *, L_KERNEL *, l_int32, l_int32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does a convolution with either a single kernel or
'''  * a pair of separable kernels, and automatically applies whatever
'''  * bias (shift) is required so that the resulting pixel values
'''  * are non-negative.
'''  *   (2) The kernel is always normalized.  If there are no negative
'''  * values in the kernel, a standard normalized convolution is
'''  * performed, with 8 bpp output.  If the sum of kernel values is
'''  * very close to zero, the kernel can not be normalized and
'''  * the convolution will not be performed.  An error message results.
'''  *   (3) If there are negative values in the kernel, the pix is
'''  * converted to an fpix, the convolution is done on the fpix, and
'''  * a bias (shift) may need to be applied.
'''  *   (4) If force8 == TRUE and the range of values after the convolution
'''  * is > 255, the output values will be scaled to fit in [0 ... 255].
'''  * If force8 == FALSE, the output will be either 8 or 16 bpp,
'''  * to accommodate the dynamic range of output values without scaling.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 or 16 bpp</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp; no colormap</param>
''' <param name="kel1"> \param[in]    kel1</param>
''' <param name="kel2"> \param[in]    kel2  can be null; use if separable</param>
''' <param name="force8"> \param[in]    force8 if 1, force output to 8 bpp; otherwise, determine</param>
''' <param name="pbias"> \param[out]   pbias applied bias</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvolveWithBias")> _
Friend Shared Function pixConvolveWithBias(pixs as IntPTR, kel1 as IntPTR, kel2 as IntPTR, force8 as Integer, pbias as Integer) as IntPTR
End Function

' SRC\convolve.c (2457, 1)
' l_setConvolveSampling()
' l_setConvolveSampling(l_int32, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) This sets the x and y output subsampling factors for generic pix
'''  * and fpix convolution.  The default values are 1 (no subsampling).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="xfact"> \param[in]    xfact, yfact integer >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_setConvolveSampling")> _
Friend Shared Function l_setConvolveSampling(xfact as Integer, yfact as Integer) as Boolean ' Org. Void
End Function

' SRC\convolve.c (2484, 1)
' pixAddGaussianNoise()
' pixAddGaussianNoise(PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This adds noise to each pixel, taken from a normal
'''  * distribution with zero mean and specified standard deviation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 or 32 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp gray or 32 bpp rgb; no colormap</param>
''' <param name="stdev"> \param[in]    stdev of noise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddGaussianNoise")> _
Friend Shared Function pixAddGaussianNoise(pixs as IntPTR, stdev as single) as IntPTR
End Function

' SRC\convolve.c (2547, 1)
' gaussDistribSampling()
' gaussDistribSampling() as l_float32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gaussDistribSampling")> _
Friend Shared Function gaussDistribSampling() as single
End Function

#End Region
#Region "SRC\correlscore.c"
' SRC\correlscore.c (125, 1)
' pixCorrelationScore()
' pixCorrelationScore(PIX *, PIX *, l_int32, l_int32, l_float32, l_float32, l_int32, l_int32, l_int32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *  We check first that the two pix are roughly the same size.
'''  *  For jbclass (jbig2) applications at roughly 300 ppi, maxdiffw and
'''  *  maxdiffh should be at least 2.
'''  *
'''  *  Only if they meet that criterion do we compare the bitmaps.
'''  *  The centroid difference is used to align the two images to the
'''  *  nearest integer for the correlation.
'''  *
'''  *  The correlation score is the ratio of the square of the number of
'''  *  pixels in the AND of the two bitmaps to the product of the number
'''  *  of ON pixels in each.  Denote the number of ON pixels in pix1
'''  *  by |1|, the number in pix2 by |2|, and the number in the AND
'''  *  of pix1 and pix2 by |1 & 2|.  The correlation score is then
'''  *  (|1 & 2|)**2 / (|1|*|2|).
'''  *
'''  *  This score is compared with an input threshold, which can
'''  *  be modified depending on the weight of the template.
'''  *  The modified threshold is
'''  *  thresh + (1.0 - thresh) * weight * R
'''  *  where
'''  *  weight is a fixed input factor between 0.0 and 1.0
'''  *  R = |2| / area(2)
'''  *  and area(2) is the total number of pixels in 2 (i.e., width x height).
'''  *
'''  *  To understand why a weight factor is useful, consider what happens
'''  *  with thick, sans-serif characters that look similar and have a value
'''  *  of R near 1.  Different characters can have a high correlation value,
'''  *  and the classifier will make incorrect substitutions.  The weight
'''  *  factor raises the threshold for these characters.
'''  *
'''  *  Yet another approach to reduce such substitutions is to run the classifier
'''  *  in a non-greedy way, matching to the template with the highest
'''  *  score, not the first template with a score satisfying the matching
'''  *  constraint.  However, this is not particularly effective.
'''  *
'''  *  The implementation here gives the same result as in
'''  *  pixCorrelationScoreSimple(), where a temporary Pix is made to hold
'''  *  the AND and implementation uses rasterop:
'''  *   pixt = pixCreateTemplate(pix1);
'''  *   pixRasterop(pixt, idelx, idely, wt, ht, PIX_SRC, pix2, 0, 0);
'''  *   pixRasterop(pixt, 0, 0, wi, hi, PIX_SRC & PIX_DST, pix1, 0, 0);
'''  *   pixCountPixels(pixt, &count, tab);
'''  *   pixDestroy(&pixt);
'''  *  However, here it is done in a streaming fashion, counting as it goes,
'''  *  and touching memory exactly once, giving a 3-4x speedup over the
'''  *  simple implementation.  This very fast correlation matcher was
'''  *  contributed by William Rucklidge.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1   test pix, 1 bpp</param>
''' <param name="pix2"> \param[in]    pix2   exemplar pix, 1 bpp</param>
''' <param name="area1"> \param[in]    area1  number of on pixels in pix1</param>
''' <param name="area2"> \param[in]    area2  number of on pixels in pix2</param>
''' <param name="delx"> \param[in]    delx   x comp of centroid difference</param>
''' <param name="dely"> \param[in]    dely   y comp of centroid difference</param>
''' <param name="maxdiffw"> \param[in]    maxdiffw max width difference of pix1 and pix2</param>
''' <param name="maxdiffh"> \param[in]    maxdiffh max height difference of pix1 and pix2</param>
''' <param name="tab"> \param[in]    tab    sum tab for byte</param>
''' <param name="pscore"> \param[out]   pscore correlation score</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCorrelationScore")> _
Friend Shared Function pixCorrelationScore(pix1 as IntPTR, pix2 as IntPTR, area1 as Integer, area2 as Integer, delx as single, dely as single, maxdiffw as Integer, maxdiffh as Integer, tab as Integer, pscore as single) as Integer
End Function

' SRC\correlscore.c (423, 1)
' pixCorrelationScoreThresholded()
' pixCorrelationScoreThresholded(PIX *, PIX *, l_int32, l_int32, l_float32, l_float32, l_int32, l_int32, l_int32 *, l_int32 *, l_float32) as l_int32
''' <summary>
''' * Notes:
'''  *  We check first that the two pix are roughly the same size.
'''  *  Only if they meet that criterion do we compare the bitmaps.
'''  *  The centroid difference is used to align the two images to the
'''  *  nearest integer for the correlation.
'''  *
'''  *  The correlation score is the ratio of the square of the number of
'''  *  pixels in the AND of the two bitmaps to the product of the number
'''  *  of ON pixels in each.  Denote the number of ON pixels in pix1
'''  *  by |1|, the number in pix2 by |2|, and the number in the AND
'''  *  of pix1 and pix2 by |1 & 2|.  The correlation score is then
'''  *  (|1 & 2|)**2 / (|1|*|2|).
'''  *
'''  *  This score is compared with an input threshold, which can
'''  *  be modified depending on the weight of the template.
'''  *  The modified threshold is
'''  *  thresh + (1.0 - thresh) * weight * R
'''  *  where
'''  *  weight is a fixed input factor between 0.0 and 1.0
'''  *  R = |2| / area(2)
'''  *  and area(2) is the total number of pixels in 2 (i.e., width x height).
'''  *
'''  *  To understand why a weight factor is useful, consider what happens
'''  *  with thick, sans-serif characters that look similar and have a value
'''  *  of R near 1.  Different characters can have a high correlation value,
'''  *  and the classifier will make incorrect substitutions.  The weight
'''  *  factor raises the threshold for these characters.
'''  *
'''  *  Yet another approach to reduce such substitutions is to run the classifier
'''  *  in a non-greedy way, matching to the template with the highest
'''  *  score, not the first template with a score satisfying the matching
'''  *  constraint.  However, this is not particularly effective.
'''  *
'''  *  This very fast correlation matcher was contributed by William Rucklidge.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  whether the correlation score is >= score_threshold</returns>
''' <param name="pix1"> \param[in]    pix1   test pix, 1 bpp</param>
''' <param name="pix2"> \param[in]    pix2   exemplar pix, 1 bpp</param>
''' <param name="area1"> \param[in]    area1  number of on pixels in pix1</param>
''' <param name="area2"> \param[in]    area2  number of on pixels in pix2</param>
''' <param name="delx"> \param[in]    delx   x comp of centroid difference</param>
''' <param name="dely"> \param[in]    dely   y comp of centroid difference</param>
''' <param name="maxdiffw"> \param[in]    maxdiffw max width difference of pix1 and pix2</param>
''' <param name="maxdiffh"> \param[in]    maxdiffh max height difference of pix1 and pix2</param>
''' <param name="tab"> \param[in]    tab    sum tab for byte</param>
''' <param name="downcount"> \param[in]    downcount count of 1 pixels below each row of pix1</param>
''' <param name="score_threshold"> \param[in]    score_threshold</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCorrelationScoreThresholded")> _
Friend Shared Function pixCorrelationScoreThresholded(pix1 as IntPTR, pix2 as IntPTR, area1 as Integer, area2 as Integer, delx as single, dely as single, maxdiffw as Integer, maxdiffh as Integer, tab as Integer, downcount as Integer, score_threshold as single) as Integer
End Function

' SRC\correlscore.c (732, 1)
' pixCorrelationScoreSimple()
' pixCorrelationScoreSimple(PIX *, PIX *, l_int32, l_int32, l_float32, l_float32, l_int32, l_int32, l_int32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This calculates exactly the same value as pixCorrelationScore().
'''  * It is 2-3x slower, but much simpler to understand.
'''  *   (2) The returned correlation score is 0.0 if the width or height
'''  * exceed %maxdiffw or %maxdiffh.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1   test pix, 1 bpp</param>
''' <param name="pix2"> \param[in]    pix2   exemplar pix, 1 bpp</param>
''' <param name="area1"> \param[in]    area1  number of on pixels in pix1</param>
''' <param name="area2"> \param[in]    area2  number of on pixels in pix2</param>
''' <param name="delx"> \param[in]    delx   x comp of centroid difference</param>
''' <param name="dely"> \param[in]    dely   y comp of centroid difference</param>
''' <param name="maxdiffw"> \param[in]    maxdiffw max width difference of pix1 and pix2</param>
''' <param name="maxdiffh"> \param[in]    maxdiffh max height difference of pix1 and pix2</param>
''' <param name="tab"> \param[in]    tab    sum tab for byte</param>
''' <param name="pscore"> \param[out]   pscore correlation score, in range [0.0 ... 1.0]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCorrelationScoreSimple")> _
Friend Shared Function pixCorrelationScoreSimple(pix1 as IntPTR, pix2 as IntPTR, area1 as Integer, area2 as Integer, delx as single, dely as single, maxdiffw as Integer, maxdiffh as Integer, tab as Integer, pscore as single) as Integer
End Function

' SRC\correlscore.c (835, 1)
' pixCorrelationScoreShifted()
' pixCorrelationScoreShifted(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds the correlation between two 1 bpp images,
'''  * when pix2 is shifted by (delx, dely) with respect
'''  * to each other.
'''  *   (2) This is implemented by starting with a copy of pix1 and
'''  * ANDing its pixels with those of a shifted pix2.
'''  *   (3) Get the pixel counts for area1 and area2 using piCountPixels().
'''  *   (4) A good estimate for a shift that would maximize the correlation
'''  * is to align the centroids (cx1, cy1; cx2, cy2), giving the
'''  * relative translations etransx and etransy:
'''  * etransx = cx1 - cx2
'''  * etransy = cy1 - cy2
'''  * Typically delx is chosen to be near etransx; ditto for dely.
'''  * This function is used in pixBestCorrelation(), where the
'''  * translations delx and dely are varied to find the best alignment.
'''  *   (5) We do not check the sizes of pix1 and pix2, because they should
'''  * be comparable.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1   1 bpp</param>
''' <param name="pix2"> \param[in]    pix2   1 bpp</param>
''' <param name="area1"> \param[in]    area1  number of on pixels in pix1</param>
''' <param name="area2"> \param[in]    area2  number of on pixels in pix2</param>
''' <param name="delx"> \param[in]    delx x translation of pix2 relative to pix1</param>
''' <param name="dely"> \param[in]    dely y translation of pix2 relative to pix1</param>
''' <param name="tab"> \param[in]    tab    sum tab for byte</param>
''' <param name="pscore"> \param[out]   pscore correlation score</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCorrelationScoreShifted")> _
Friend Shared Function pixCorrelationScoreShifted(pix1 as IntPTR, pix2 as IntPTR, area1 as Integer, area2 as Integer, delx as Integer, dely as Integer, tab as Integer, pscore as single) as Integer
End Function

#End Region
#Region "SRC\dewarp1.c"
' SRC\dewarp1.c (405, 16)
' dewarpaExtendArraysToSize()
' dewarpaExtendArraysToSize(L_DEWARPA *, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) If necessary, reallocs main and cache dewarpa ptr arrays to %size.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="size"> \param[in]    size new size of dewarpa array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaExtendArraysToSize")> _
Friend Shared Function dewarpaExtendArraysToSize(dewa as IntPTR, size as Integer) as Integer
End Function

' SRC\dewarp1.c (446, 1)
' dewarpCreate()
' dewarpCreate(PIX *, l_int32) as L_DEWARP *
''' <summary>
''' * Notes:
'''  *   (1) The input pixs is either full resolution or 2x reduced.
'''  *   (2) The page number is typically 0-based.  If scanned from a book,
'''  * the even pages are usually on the left.  Disparity arrays
'''  * built for even pages should only be applied to even pages.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dew or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs 1 bpp</param>
''' <param name="pageno"> \param[in]   pageno page number</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpCreate")> _
Friend Shared Function dewarpCreate(pixs as IntPTR, pageno as Integer) as IntPTR
End Function

' SRC\dewarp1.c (486, 1)
' dewarpCreateRef()
' dewarpCreateRef(l_int32, l_int32) as L_DEWARP *
''' <summary>
''' * Notes:
'''  *   (1) This specifies which dewarp struct should be used for
'''  * the given page.  It is placed in dewarpa for pages
'''  * for which no model can be built.
'''  *   (2) This page and the reference page have the same parity and
'''  * the reference page is the closest page with a disparity model
'''  * to this page.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dew or NULL on error</returns>
''' <param name="pageno"> \param[in]    pageno this page number</param>
''' <param name="refpage"> \param[in]    refpage page number of dewarp disparity arrays to be used</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpCreateRef")> _
Friend Shared Function dewarpCreateRef(pageno as Integer, refpage as Integer) as IntPTR
End Function

' SRC\dewarp1.c (509, 1)
' dewarpDestroy()
' dewarpDestroy(L_DEWARP **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pdew"> \param[in,out]   pdew will be set to null before returning</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpDestroy")> _
Friend Shared Function dewarpDestroy(pdew as Object) as Boolean ' Org. Void
End Function

' SRC\dewarp1.c (572, 1)
' dewarpaCreate()
' dewarpaCreate(l_int32, l_int32, l_int32, l_int32, l_int32) as L_DEWARPA *
''' <summary>
''' * Notes:
'''  *   (1) The sampling, minlines and maxdist parameters will be
'''  * applied to all images.
'''  *   (2) The sampling factor is used for generating the disparity arrays
'''  * from the input image.  For 2x reduced input, use a sampling
'''  * factor that is half the sampling you want on the full resolution
'''  * images.
'''  *   (3) Use %redfactor = 1 for full resolution; 2 for 2x reduction.
'''  * All input images must be at one of these two resolutions.
'''  *   (4) %minlines is the minimum number of nearly full-length lines
'''  * required to generate a vertical disparity array.  The default
'''  * number is 15.  Use a smaller number to accept a questionable
'''  * array, but not smaller than 4.
'''  *   (5) When a model can't be built for a page, it looks up to %maxdist
'''  * in either direction for a valid model with the same page parity.
'''  * Use -1 for the default value of %maxdist; use 0 to avoid using
'''  * a ref model.
'''  *   (6) The ptr array is expanded as necessary to accommodate page images.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dewa or NULL on error</returns>
''' <param name="nptrs"> \param[in]   nptrs number of dewarp page ptrs; typically the number of pages</param>
''' <param name="sampling"> \param[in]   sampling use 0 for default value; the minimum allowed is 8</param>
''' <param name="redfactor"> \param[in]   redfactor of input images: 1 is full resolution; 2 is 2x reduced</param>
''' <param name="minlines"> \param[in]   minlines minimum number of lines to accept; use 0 for default</param>
''' <param name="maxdist"> \param[in]   maxdist for locating reference disparity; use -1 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaCreate")> _
Friend Shared Function dewarpaCreate(nptrs as Integer, sampling as Integer, redfactor as Integer, minlines as Integer, maxdist as Integer) as IntPTR
End Function

' SRC\dewarp1.c (661, 1)
' dewarpaCreateFromPixacomp()
' dewarpaCreateFromPixacomp(PIXAC *, l_int32, l_int32, l_int32, l_int32) as L_DEWARPA *
''' <summary>
''' * Notes:
'''  *   (1) The returned dewa has disparity arrays calculated and
'''  * is ready for serialization or for use in dewarping.
'''  *   (2) The sampling, minlines and maxdist parameters are
'''  * applied to all images.  See notes in dewarpaCreate() for details.
'''  *   (3) The pixac is full.  Placeholders, if any, are w=h=d=1 images,
'''  * and the real input images are 1 bpp at full resolution.
'''  * They are assumed to be cropped to the actual page regions,
'''  * and may be arbitrarily sparse in the array.
'''  *   (4) The output dewarpa is indexed by the page number.
'''  * The offset in the pixac gives the mapping between the
'''  * array index in the pixac and the page number.
'''  *   (5) This adds the ref page models.
'''  *   (6) This can be used to make models for any desired set of pages.
'''  * The direct models are only made for pages with images in
'''  * the pixacomp; the ref models are made for pages of the
'''  * same parity within %maxdist of the nearest direct model.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dewa or NULL on error</returns>
''' <param name="pixac"> \param[in]   pixac pixacomp of G4, 1 bpp images; with 1x1x1 placeholders</param>
''' <param name="useboth"> \param[in]   useboth 0 for only vert disparity; 1 for both vert and horiz</param>
''' <param name="sampling"> \param[in]   sampling use -1 or 0 for default value; otherwise minimum of 5</param>
''' <param name="minlines"> \param[in]   minlines minimum number of lines to accept; e.g., 10</param>
''' <param name="maxdist"> \param[in]   maxdist for locating reference disparity; use -1 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaCreateFromPixacomp")> _
Friend Shared Function dewarpaCreateFromPixacomp(pixac as IntPTR, useboth as Integer, sampling as Integer, minlines as Integer, maxdist as Integer) as IntPTR
End Function

' SRC\dewarp1.c (722, 1)
' dewarpaDestroy()
' dewarpaDestroy(L_DEWARPA **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pdewa"> \param[in,out]   pdewa will be set to null before returning</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaDestroy")> _
Friend Shared Function dewarpaDestroy(pdewa as Object) as Boolean ' Org. Void
End Function

' SRC\dewarp1.c (762, 1)
' dewarpaDestroyDewarp()
' dewarpaDestroyDewarp(L_DEWARPA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="pageno"> \param[in]    pageno of dew to be destroyed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaDestroyDewarp")> _
Friend Shared Function dewarpaDestroyDewarp(dewa as IntPTR, pageno as Integer) as Integer
End Function

' SRC\dewarp1.c (805, 1)
' dewarpaInsertDewarp()
' dewarpaInsertDewarp(L_DEWARPA *, L_DEWARP *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This inserts the dewarp into the array, which now owns it.
'''  * It also keeps track of the largest page number stored.
'''  * It must be done before the disparity model is built.
'''  *   (2) Note that this differs from the usual method of filling out
'''  * arrays in leptonica, where the arrays are compact and
'''  * new elements are typically added to the end.  Here,
'''  * the dewarp can be added anywhere, even beyond the initial
'''  * allocation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="dew"> \param[in]    dew  to be added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaInsertDewarp")> _
Friend Shared Function dewarpaInsertDewarp(dewa as IntPTR, dew as IntPTR) as Integer
End Function

' SRC\dewarp1.c (902, 1)
' dewarpaGetDewarp()
' dewarpaGetDewarp(L_DEWARPA *, l_int32) as L_DEWARP *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dew handle; still owned by dewa, or NULL on error</returns>
''' <param name="dewa"> \param[in]    dewa populated with dewarp structs for pages</param>
''' <param name="index"> \param[in]    index into dewa: this is the pageno</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaGetDewarp")> _
Friend Shared Function dewarpaGetDewarp(dewa as IntPTR, index as Integer) as IntPTR
End Function

' SRC\dewarp1.c (966, 1)
' dewarpaSetCurvatures()
' dewarpaSetCurvatures(L_DEWARPA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Approximating the line by a quadratic, the coefficient
'''  * of the quadratic term is the curvature, and distance
'''  * units are in pixels (of course).  The curvature is very
'''  * small, so we multiply by 10^6 and express the constraints
'''  * on the model curvatures in micro-units.
'''  *   (2) This sets five curvature thresholds and a slope threshold:
'''  * * the maximum absolute value of the vertical disparity
'''  *   line curvatures
'''  * * the minimum absolute value of the largest difference in
'''  *   vertical disparity line curvatures (Use a value of 0
'''  *   to accept all models.)
'''  * * the maximum absolute value of the largest difference in
'''  *   vertical disparity line curvatures
'''  * * the maximum absolute value of the left and right edge
'''  *   curvature for the horizontal disparity
'''  * * the maximum absolute value of the difference between
'''  *   left and right edge curvature for the horizontal disparity
'''  * all in micro-units, for dewarping to take place.
'''  * Use -1 for default values.
'''  *   (3) An image with a line curvature less than about 0.00001
'''  * has fairly straight textlines.  This is 10 micro-units.
'''  *   (4) For example, if %max_linecurv == 100, this would prevent dewarping
'''  * if any of the lines has a curvature exceeding 100 micro-units.
'''  * A model having maximum line curvature larger than about 150
'''  * micro-units should probably not be used.
'''  *   (5) A model having a left or right edge curvature larger than
'''  * about 100 micro-units should probably not be used.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="max_linecurv"> \param[in]    max_linecurv -1 for default</param>
''' <param name="min_diff_linecurv"> \param[in]    min_diff_linecurv -1 for default; 0 to accept all models</param>
''' <param name="max_diff_linecurv"> \param[in]    max_diff_linecurv -1 for default</param>
''' <param name="max_edgecurv"> \param[in]    max_edgecurv -1 for default</param>
''' <param name="max_diff_edgecurv"> \param[in]    max_diff_edgecurv -1 for default</param>
''' <param name="max_edgeslope"> \param[in]    max_edgeslope -1 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaSetCurvatures")> _
Friend Shared Function dewarpaSetCurvatures(dewa as IntPTR, max_linecurv as Integer, min_diff_linecurv as Integer, max_diff_linecurv as Integer, max_edgecurv as Integer, max_diff_edgecurv as Integer, max_edgeslope as Integer) as Integer
End Function

' SRC\dewarp1.c (1030, 1)
' dewarpaUseBothArrays()
' dewarpaUseBothArrays(L_DEWARPA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This sets the useboth field.  If set, this will attempt
'''  * to apply both vertical and horizontal disparity arrays.
'''  * Note that a model with only a vertical disparity array will
'''  * always be valid.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="useboth"> \param[in]    useboth   0 for false, 1 for true</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaUseBothArrays")> _
Friend Shared Function dewarpaUseBothArrays(dewa as IntPTR, useboth as Integer) as Integer
End Function

' SRC\dewarp1.c (1069, 1)
' dewarpaSetCheckColumns()
' dewarpaSetCheckColumns(L_DEWARPA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This sets the 'check_columns" field.  If set, and if
'''  * 'useboth' is set, this will count the number of text
'''  * columns.  If the number is larger than 1, this will
'''  * prevent the application of horizontal disparity arrays
'''  * if they exist.  Note that the default value of check_columns
'''  * if 0 (FALSE).
'''  *   (2) This field is set to 0 by default.  For horizontal disparity
'''  * correction to take place on a single column of text, you must have:
'''  *  - a valid horizontal disparity array
'''  *  - useboth = 1 (TRUE)
'''  * If there are multiple columns, additionally
'''  *  - check_columns = 0 (FALSE)
'''  *
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="check_columns"> \param[in]    check_columns 0 for false, 1 for true</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaSetCheckColumns")> _
Friend Shared Function dewarpaSetCheckColumns(dewa as IntPTR, check_columns as Integer) as Integer
End Function

' SRC\dewarp1.c (1095, 1)
' dewarpaSetMaxDistance()
' dewarpaSetMaxDistance(L_DEWARPA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This sets the maxdist field.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="maxdist"> \param[in]    maxdist for using ref models</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaSetMaxDistance")> _
Friend Shared Function dewarpaSetMaxDistance(dewa as IntPTR, maxdist as Integer) as Integer
End Function

' SRC\dewarp1.c (1119, 1)
' dewarpRead()
' dewarpRead(const char *) as L_DEWARP *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dew, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpRead")> _
Friend Shared Function dewarpRead(filename as String) as IntPTR
End Function

' SRC\dewarp1.c (1159, 1)
' dewarpReadStream()
' dewarpReadStream(FILE *) as L_DEWARP *
''' <summary>
''' * Notes:
'''  *   (1) The dewarp struct is stored in minimized format, with only
'''  * subsampled disparity arrays.
'''  *   (2) The sampling and extra horizontal disparity parameters are
'''  * stored here.  During generation of the dewarp struct, they
'''  * are passed in from the dewarpa.  In readback, it is assumed
'''  * that they are (a) the same for each page and (b) the same
'''  * as the values used to create the dewarpa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dew, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpReadStream")> _
Friend Shared Function dewarpReadStream(fp as Object) as IntPTR
End Function

' SRC\dewarp1.c (1264, 1)
' dewarpReadMem()
' dewarpReadMem(const l_uint8 *, size_t) as L_DEWARP *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dew  dewarp, or NULL on error</returns>
''' <param name="data"> \param[in]    data  serialization of dewarp</param>
''' <param name="size"> \param[in]    size  of data in bytes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpReadMem")> _
Friend Shared Function dewarpReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\dewarp1.c (1292, 1)
' dewarpWrite()
' dewarpWrite(const char *, L_DEWARP *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="dew"> \param[in]    dew</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpWrite")> _
Friend Shared Function dewarpWrite(filename as String, dew as IntPTR) as Integer
End Function

' SRC\dewarp1.c (1330, 1)
' dewarpWriteStream()
' dewarpWriteStream(FILE *, L_DEWARP *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This should not be written if there is no sampled
'''  * vertical disparity array, which means that no model has
'''  * been built for this page.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream opened for "wb"</param>
''' <param name="dew"> \param[in]    dew</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpWriteStream")> _
Friend Shared Function dewarpWriteStream(fp as Object, dew as IntPTR) as Integer
End Function

' SRC\dewarp1.c (1386, 1)
' dewarpWriteMem()
' dewarpWriteMem(l_uint8 **, size_t *, L_DEWARP *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a dewarp in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of serialized dewarp (not ascii)</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="dew"> \param[in]    dew</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpWriteMem")> _
Friend Shared Function dewarpWriteMem(pdata as Object, psize as ULong, dew as IntPTR) as Integer
End Function

' SRC\dewarp1.c (1436, 1)
' dewarpaRead()
' dewarpaRead(const char *) as L_DEWARPA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dewa, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaRead")> _
Friend Shared Function dewarpaRead(filename as String) as IntPTR
End Function

' SRC\dewarp1.c (1473, 1)
' dewarpaReadStream()
' dewarpaReadStream(FILE *) as L_DEWARPA *
''' <summary>
''' * Notes:
'''  *   (1) The serialized dewarp contains a Numa that gives the
'''  * (increasing) page number of the dewarp structs that are
'''  * contained.
'''  *   (2) Reference pages are added in after readback.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dewa, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaReadStream")> _
Friend Shared Function dewarpaReadStream(fp as Object) as IntPTR
End Function

' SRC\dewarp1.c (1545, 1)
' dewarpaReadMem()
' dewarpaReadMem(const l_uint8 *, size_t) as L_DEWARPA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dewa  dewarpa, or NULL on error</returns>
''' <param name="data"> \param[in]    data  serialization of dewarpa</param>
''' <param name="size"> \param[in]    size  of data in bytes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaReadMem")> _
Friend Shared Function dewarpaReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\dewarp1.c (1573, 1)
' dewarpaWrite()
' dewarpaWrite(const char *, L_DEWARPA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="dewa"> \param[in]    dewa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaWrite")> _
Friend Shared Function dewarpaWrite(filename as String, dewa as IntPTR) as Integer
End Function

' SRC\dewarp1.c (1604, 1)
' dewarpaWriteStream()
' dewarpaWriteStream(FILE *, L_DEWARPA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream opened for "wb"</param>
''' <param name="dewa"> \param[in]    dewa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaWriteStream")> _
Friend Shared Function dewarpaWriteStream(fp as Object, dewa as IntPTR) as Integer
End Function

' SRC\dewarp1.c (1660, 1)
' dewarpaWriteMem()
' dewarpaWriteMem(l_uint8 **, size_t *, L_DEWARPA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a dewarpa in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of serialized dewarpa (not ascii)</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="dewa"> \param[in]    dewa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaWriteMem")> _
Friend Shared Function dewarpaWriteMem(pdata as Object, psize as ULong, dewa as IntPTR) as Integer
End Function

#End Region
#Region "SRC\dewarp2.c"
' SRC\dewarp2.c (64, 13)
' dewarpGetMeanVerticals()
' dewarpGetMeanVerticals(PIX *, l_int32, l_int32) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta (mean y-values in component for each x-value,</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, single c.c.</param>
''' <param name="x"> \param[in]    x,y location of UL corner of pixs with respect to page image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpGetMeanVerticals")> _
Friend Shared Function dewarpGetMeanVerticals(pixs as IntPTR, x as Integer, y as Integer) as IntPTR
End Function

' SRC\dewarp2.c (65, 16)
' dewarpGetLineEndPoints()
' dewarpGetLineEndPoints(l_int32, PTAA *, PTA **, PTA **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) We require that the set of end points extends over 45% of the
'''  * height of the input image, to insure good coverage and
'''  * avoid extrapolating the curvature too far beyond the
'''  * actual textlines.  Large extrapolations are particularly
'''  * dangerous if used as a reference model.  We also require
'''  * at least 10 lines of text.
'''  *   (2) We sort the lines from top to bottom (sort by x in the ptas).
'''  *   (3) For fitting the endpoints, x = f(y), we transpose x and y.
'''  * Thus all these ptas have x and y swapped!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="h"> \param[in]    h        height of pixs</param>
''' <param name="ptaa"> \param[in]    ptaa     lines</param>
''' <param name="pptal"> \param[out]   pptal    left end points of each line</param>
''' <param name="pptar"> \param[out]   pptar    right end points of each line</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpGetLineEndPoints")> _
Friend Shared Function dewarpGetLineEndPoints(h as Integer, ptaa as IntPTR, pptal as Object, pptar as Object) as Integer
End Function

' SRC\dewarp2.c (67, 16)
' dewarpFilterLineEndPoints()
' dewarpFilterLineEndPoints(L_DEWARP *, PTA *, PTA *, PTA **, PTA **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Avoid confusion with multiple columns by requiring that line
'''  * end points be close enough to leftmost and rightmost end points.
'''  * Must have at least 8 points on left and right after this step.
'''  *   (2) Apply second filtering step, find the median positions in
'''  * top and bottom halves, and removing end points that are
'''  * displaced too much from these in the x direction.
'''  * Must have at least 6 points on left and right after this step.
'''  *   (3) Reminder: x and y in the pta are transposed; think x = f(y).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="dew"> \param[in]    dew</param>
''' <param name="ptal1"> \param[in]    ptal     input left end points of each line</param>
''' <param name="ptar1"> \param[in]    ptar     input right end points of each line</param>
''' <param name="pptal2"> \param[out]   pptalf   filtered left end points</param>
''' <param name="pptar2"> \param[out]   pptarf   filtered right end points</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpFilterLineEndPoints")> _
Friend Shared Function dewarpFilterLineEndPoints(dew as IntPTR, ptal1 as IntPTR, ptar1 as IntPTR, pptal2 as Object, pptar2 as Object) as Integer
End Function

' SRC\dewarp2.c (69, 13)
' dewarpRemoveBadEndPoints()
' dewarpRemoveBadEndPoints(l_int32, PTA *) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) The input set is sorted by line position (x value).
'''  * Break into two (upper and lower); for each find the median
'''  * horizontal (y value), and remove all points farther than
'''  * a fraction of the image width from this.  Make sure each
'''  * part still has at least 3 points, and join the two sections
'''  * before returning.
'''  *   (2) Reminder: x and y in the pta are transposed; think x = f(y).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad   filtered left or right end points, or NULL on error.</returns>
''' <param name="w"> \param[in]   w       width of input image</param>
''' <param name="ptas"> \param[in]   ptas    left or right line end points</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpRemoveBadEndPoints")> _
Friend Shared Function dewarpRemoveBadEndPoints(w as Integer, ptas as IntPTR) as IntPTR
End Function

' SRC\dewarp2.c (70, 16)
' dewarpIsLineCoverageValid()
' dewarpIsLineCoverageValid(PTAA *, l_int32, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) The criterion for valid coverage is:
'''  * (a) there must be lines in both halves (top and bottom)
'''  *  of the image.
'''  * (b) the coverage must be at least 40% of the image height
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if coverage is valid, 0 if not or on error.</returns>
''' <param name="ptaa2"> \param[in]    ptaa of validated lines</param>
''' <param name="h"> \param[in]    h height of pix</param>
''' <param name="ptopline"> \param[out]   ptopline location of top line</param>
''' <param name="pbotline"> \param[out]   pbotline location of bottom line</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpIsLineCoverageValid")> _
Friend Shared Function dewarpIsLineCoverageValid(ptaa2 as IntPTR, h as Integer, ptopline as Integer, pbotline as Integer) as Integer
End Function

' SRC\dewarp2.c (72, 16)
' dewarpQuadraticLSF()
' dewarpQuadraticLSF(PTA *, l_float32 *, l_float32 *, l_float32 *, l_float32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This is used for finding the left or right sides of
'''  * the text block, computed as a quadratic curve.
'''  * Only the longest lines are input, so there are
'''  * no outliers.
'''  *   (2) The ptas for the end points all have x and y swapped.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="ptad"> \param[in]    ptad left or right end points of longest lines</param>
''' <param name="pa"> \param[out]   pa  coeff a of LSF: y = ax^2 + bx + c</param>
''' <param name="pb"> \param[out]   pb  coeff b of LSF: y = ax^2 + bx + c</param>
''' <param name="pc"> \param[out]   pc  coeff c of LSF: y = ax^2 + bx + c</param>
''' <param name="pmederr"> \param[out]   pmederr [optional] median error</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpQuadraticLSF")> _
Friend Shared Function dewarpQuadraticLSF(ptad as IntPTR, pa as single, pb as single, pc as single, pmederr as single) as Integer
End Function

' SRC\dewarp2.c (74, 16)
' pixRenderMidYs()
' pixRenderMidYs(PIX *, NUMA *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="namidys"> \param[in]    namidys y location of reference lines for vertical disparity</param>
''' <param name="linew"> \param[in]    linew width of rendered line; typ 2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderMidYs")> _
Friend Shared Function pixRenderMidYs(pixs as IntPTR, namidys as IntPTR, linew as Integer) as Integer
End Function

' SRC\dewarp2.c (75, 16)
' pixRenderHorizEndPoints()
' pixRenderHorizEndPoints(PIX *, PTA *, PTA *, l_uint32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="ptal"> \param[in]    ptal left side line end points</param>
''' <param name="ptar"> \param[in]    ptar right side line end points</param>
''' <param name="color"> \param[in]    color 0xrrggbb00</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderHorizEndPoints")> _
Friend Shared Function pixRenderHorizEndPoints(pixs as IntPTR, ptal as IntPTR, ptar as IntPTR, color as UInteger) as Integer
End Function

' SRC\dewarp2.c (148, 1)
' dewarpBuildPageModel()
' dewarpBuildPageModel(L_DEWARP *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is the basic function that builds the horizontal and
'''  * vertical disparity arrays, which allow determination of the
'''  * src pixel in the input image corresponding to each
'''  * dest pixel in the dewarped image.
'''  *   (2) Sets vsuccess = 1 if the vertical disparity array builds.
'''  * Always attempts to build the horizontal disparity array,
'''  * even if it will not be requested (useboth == 0).
'''  * Sets hsuccess = 1 if horizontal disparity builds.
'''  *   (3) The method is as follows:
'''  * (a) Estimate the points along the centers of all the
'''  *  long textlines.  If there are too few lines, no
'''  *  disparity models are built.
'''  * (b) From the vertical deviation of the lines, estimate
'''  *  the vertical disparity.
'''  * (c) From the ends of the lines, estimate the horizontal
'''  *  disparity, assuming that the text is made of lines
'''  *  that are close to left and right justified.
'''  * (d) One can also compute an additional contribution to the
'''  *  horizontal disparity, inferred from slopes of the top
'''  *  and bottom lines.  We do not do this.
'''  *   (4) In more detail for the vertical disparity:
'''  * (a) Fit a LS quadratic to center locations along each line.
'''  *  This smooths the curves.
'''  * (b) Sample each curve at a regular interval, find the y-value
'''  *  of the mid-point on each curve, and subtract the sampled
'''  *  curve value from this value.  This is the vertical
'''  *  disparity at sampled points along each curve.
'''  * (c) Fit a LS quadratic to each set of vertically aligned
'''  *  disparity samples.  This smooths the disparity values
'''  *  in the vertical direction.  Then resample at the same
'''  *  regular interval.  We now have a regular grid of smoothed
'''  *  vertical disparity valuels.
'''  *   (5) Once the sampled vertical disparity array is found, it can be
'''  * interpolated to get a full resolution vertical disparity map.
'''  * This can be applied directly to the src image pixels
'''  * to dewarp the image in the vertical direction, making
'''  * all textlines horizontal.  Likewise, the horizontal
'''  * disparity array is used to left- and right-align the
'''  * longest textlines.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 if unable to build the model or on error</returns>
''' <param name="dew"> \param[in]    dew</param>
''' <param name="debugfile"> \param[in]    debugfile use NULL to skip writing this</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpBuildPageModel")> _
Friend Shared Function dewarpBuildPageModel(dew as IntPTR, debugfile as String) as Integer
End Function

' SRC\dewarp2.c (294, 1)
' dewarpFindVertDisparity()
' dewarpFindVertDisparity(L_DEWARP *, PTAA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This starts with points along the centers of textlines.
'''  * It does quadratic fitting (and smoothing), first along the
'''  * lines and then in the vertical direction, to generate
'''  * the sampled vertical disparity map.  This can then be
'''  * interpolated to full resolution and used to remove
'''  * the vertical line warping.
'''  *   (2) Use %rotflag == 1 if you are dewarping vertical lines, as
'''  * is done in dewarpBuildLineModel().  The usual case is for
'''  * %rotflag == 0.
'''  *   (3) Note that this builds a vertical disparity model (VDM), but
'''  * does not check it against constraints for validity.
'''  * Constraint checking is done after building the models,
'''  * and before inserting reference models.
'''  *   (4) This sets the vsuccess flag to 1 on success.
'''  *   (5) Pix debug output goes to /tmp/dewvert/ for collection into
'''  * a pdf.  Non-pix debug output goes to /tmp.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dew"> \param[in]    dew</param>
''' <param name="ptaa"> \param[in]    ptaa unsmoothed lines, not vertically ordered</param>
''' <param name="rotflag"> \param[in]    rotflag 0 if using dew->pixs; 1 if rotated by 90 degrees cw</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpFindVertDisparity")> _
Friend Shared Function dewarpFindVertDisparity(dew as IntPTR, ptaa as IntPTR, rotflag as Integer) as Integer
End Function

' SRC\dewarp2.c (558, 1)
' dewarpFindHorizDisparity()
' dewarpFindHorizDisparity(L_DEWARP *, PTAA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This builds a horizontal disparity model (HDM), but
'''  * does not check it against constraints for validity.
'''  * Constraint checking is done at rendering time.
'''  *   (2) Horizontal disparity is not required for a successful model;
'''  * only the vertical disparity is required.  This will not be
'''  * called if the function to build the vertical disparity fails.
'''  *   (3) This sets the hsuccess flag to 1 on success.
'''  *   (4) Internally in ptal1, ptar1, ptal2, ptar2: x and y are reversed,
'''  * so the 'y' value is horizontal distance across the image width.
'''  *   (5) Debug output goes to /tmp/lept/dewmod/ for collection into a pdf.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 if horizontal disparity array is not built, or on error</returns>
''' <param name="dew"> \param[in]    dew</param>
''' <param name="ptaa"> \param[in]    ptaa unsmoothed lines, not vertically ordered</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpFindHorizDisparity")> _
Friend Shared Function dewarpFindHorizDisparity(dew as IntPTR, ptaa as IntPTR) as Integer
End Function

' SRC\dewarp2.c (762, 1)
' dewarpGetTextlineCenters()
' dewarpGetTextlineCenters(PIX *, l_int32) as PTAA *
''' <summary>
''' * Notes:
'''  *   (1) This in general does not have a point for each value
'''  * of x, because there will be gaps between words.
'''  * It doesn't matter because we will fit a quadratic to the
'''  * points that we do have.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptaa of center values of textlines</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="debugflag"> \param[in]    debugflag 1 for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpGetTextlineCenters")> _
Friend Shared Function dewarpGetTextlineCenters(pixs as IntPTR, debugflag as Integer) as IntPTR
End Function

' SRC\dewarp2.c (916, 1)
' dewarpRemoveShortLines()
' dewarpRemoveShortLines(PIX *, PTAA *, l_float32, l_int32) as PTAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptaad containing only lines of sufficient length,</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="ptaas"> \param[in]    ptaas input lines</param>
''' <param name="fract"> \param[in]    fract minimum fraction of longest line to keep</param>
''' <param name="debugflag"> \param[in]    debugflag</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpRemoveShortLines")> _
Friend Shared Function dewarpRemoveShortLines(pixs as IntPTR, ptaas as IntPTR, fract as single, debugflag as Integer) as IntPTR
End Function

' SRC\dewarp2.c (1378, 1)
' dewarpFindHorizSlopeDisparity()
' dewarpFindHorizSlopeDisparity(L_DEWARP *, PIX *, l_float32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) %fractthresh is a threshold on the fractional difference in stroke
'''  * density between between left and right sides.  Process this
'''  * disparity only if the absolute value of the fractional
'''  * difference equals or exceeds this threshold.
'''  *   (2) %parity indicates where the binding is: on the left for
'''  * %parity == 0 and on the right for %parity == 1.
'''  *   (3) This takes a 1 bpp %pixb where both vertical and horizontal
'''  * disparity have been applied, so the text lines are straight and,
'''  * more importantly, the line end points are vertically aligned.
'''  * It estimates the foreshortening of the characters on the
'''  * binding side, and if significant, computes a one-dimensional
'''  * horizontal disparity function to compensate.
'''  *   (4) The first attempt was to use the average width of the
'''  * connected components (c.c.) in vertical slices.  This does not work
'''  * reliably, because the horizontal compression of the text is
'''  * often accompanied by horizontal joining of c.c.
'''  *   (5) We use the density of vertical strokes, measured by first using
'''  * a vertical opening, which improves the signal.  The result
'''  * is relatively insensitive to the size of the opening; we use
'''  * a 10-pixel opening.  The relative density is measured by
'''  * finding the number of c.c. in a full height sliding window
'''  * of width 50 pixels, and compute every 25 pixels.  Similar results
'''  * are obtained counting c.c. that either intersect the window
'''  * or are fully contained within it.
'''  *   (6) Debug output goes to /tmp/lept/dewmod/ for collection into a pdf.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return       0 if OK, 1 on error</returns>
''' <param name="dew"> \param[in]    dew</param>
''' <param name="pixb"> \param[in]    pixb (1 bpp, with vertical and horizontal disparity removed)</param>
''' <param name="fractthresh"> \param[in]    fractthresh (threshold fractional difference in density)</param>
''' <param name="parity"> \param[in]    parity (0 if even page, 1 if odd page)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpFindHorizSlopeDisparity")> _
Friend Shared Function dewarpFindHorizSlopeDisparity(dew as IntPTR, pixb as IntPTR, fractthresh as single, parity as Integer) as Integer
End Function

' SRC\dewarp2.c (1606, 1)
' dewarpBuildLineModel()
' dewarpBuildLineModel(L_DEWARP *, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This builds the horizontal and vertical disparity arrays
'''  * for an input of ruled lines, typically for calibration.
'''  * In book scanning, you could lay the ruled paper over a page.
'''  * Then for that page and several below it, you can use the
'''  * disparity correction of the line model to dewarp the pages.
'''  *   (2) The dew has been initialized with the image of ruled lines.
'''  * These lines must be continuous, but we do a small amount
'''  * of pre-processing here to insure that.
'''  *   (3) %opensize is typically about 8.  It must be larger than
'''  * the thickness of the lines to be extracted.  This is the
'''  * default value, which is applied if %opensize  3.
'''  *   (4) Sets vsuccess = 1 and hsuccess = 1 if the vertical and/or
'''  * horizontal disparity arrays build.
'''  *   (5) Similar to dewarpBuildPageModel(), except here the vertical
'''  * and horizontal disparity arrays are both built from ruled lines.
'''  * See notes there.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 if unable to build the model or on error</returns>
''' <param name="dew"> \param[in]    dew</param>
''' <param name="opensize"> \param[in]    opensize size of opening to remove perpendicular lines</param>
''' <param name="debugfile"> \param[in]    debugfile use NULL to skip writing this</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpBuildLineModel")> _
Friend Shared Function dewarpBuildLineModel(dew as IntPTR, opensize as Integer, debugfile as String) as Integer
End Function

' SRC\dewarp2.c (1790, 1)
' dewarpaModelStatus()
' dewarpaModelStatus(L_DEWARPA *, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This tests if a model has been built, not if it is valid.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="pageno"> \param[in]    pageno</param>
''' <param name="pvsuccess"> \param[out]   pvsuccess [optional] 1 on success</param>
''' <param name="phsuccess"> \param[out]   phsuccess [optional] 1 on success</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaModelStatus")> _
Friend Shared Function dewarpaModelStatus(dewa as IntPTR, pageno as Integer, pvsuccess as Integer, phsuccess as Integer) as Integer
End Function

#End Region
#Region "SRC\dewarp3.c"
' SRC\dewarp3.c (57, 16)
' dewarpaApplyInit()
' dewarpaApplyInit(L_DEWARPA *, l_int32, PIX *, l_int32, l_int32, L_DEWARP **, const char *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This prepares pixs for being dewarped.  It returns 1 if
'''  * no dewarping model exists.
'''  *   (2) The returned %dew contains the model to be used for this page
'''  * image.  The %dew is owned by dewa; do not destroy.
'''  *   (3) If both the 'useboth' and 'check_columns' fields are true,
'''  * this checks for multiple text columns and if found, sets
'''  * the 'skip_horiz' field in the %dew for this page.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error no models or ref models available</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="pageno"> \param[in]    pageno of page model to be used; may be a ref model</param>
''' <param name="pixs"> \param[in]    pixs image to be modified; can be 1, 8 or 32 bpp</param>
''' <param name="x"> \param[in]    x, y origin for generation of disparity arrays</param>
''' <param name="y"> \param[out]   pdew dewarp to be used for this page</param>
''' <param name="pdew"> \param[in]    debugfile use NULL to skip writing this</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaApplyInit")> _
Friend Shared Function dewarpaApplyInit(dewa as IntPTR, pageno as Integer, pixs as IntPTR, x as Integer, y as Integer, pdew as Object, debugfile as String) as Integer
End Function

' SRC\dewarp3.c (60, 13)
' pixApplyVertDisparity()
' pixApplyVertDisparity(L_DEWARP *, PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This applies the vertical disparity array to the specified
'''  * image.  For src pixels above the image, we use the pixels
'''  * in the first raster line.
'''  *   (2) Specify gray color for pixels brought in from the outside:
'''  * 0 is black, 255 is white.  Use -1 to select pixels from the
'''  * boundary of the source image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd modified to remove vertical disparity, or NULL on error</returns>
''' <param name="dew"> \param[in]    dew</param>
''' <param name="pixs"> \param[in]    pixs 1, 8 or 32 bpp</param>
''' <param name="grayin"> \param[in]    grayin gray value, from 0 to 255, for pixels brought in;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixApplyVertDisparity")> _
Friend Shared Function pixApplyVertDisparity(dew as IntPTR, pixs as IntPTR, grayin as Integer) as IntPTR
End Function

' SRC\dewarp3.c (61, 14)
' pixApplyHorizDisparity()
' pixApplyHorizDisparity(L_DEWARP *, PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This applies the horizontal disparity array to the specified
'''  * image.
'''  *   (2) Specify gray color for pixels brought in from the outside:
'''  * 0 is black, 255 is white.  Use -1 to select pixels from the
'''  * boundary of the source image.
'''  *   (3) The input pixs has already been corrected for vertical disparity.
'''  * If the horizontal disparity array doesn't exist, this returns
'''  * a clone of %pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd modified to remove horizontal disparity if possible,</returns>
''' <param name="dew"> \param[in]    dew</param>
''' <param name="pixs"> \param[in]    pixs 1, 8 or 32 bpp</param>
''' <param name="grayin"> \param[in]    grayin gray value, from 0 to 255, for pixels brought in;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixApplyHorizDisparity")> _
Friend Shared Function pixApplyHorizDisparity(dew as IntPTR, pixs as IntPTR, grayin as Integer) as IntPTR
End Function

' SRC\dewarp3.c (62, 14)
' boxaApplyDisparity()
' boxaApplyDisparity(L_DEWARP *, BOXA *, l_int32, l_int32) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad modified by the disparity, or NULL on error</returns>
''' <param name="dew"> \param[in]    dew</param>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="direction"> \param[in]    direction L_HORIZ or L_VERT</param>
''' <param name="mapdir"> \param[in]    mapdir 1 if mapping forward from original to dewarped;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaApplyDisparity")> _
Friend Shared Function boxaApplyDisparity(dew as IntPTR, boxa as IntPTR, direction as Integer, mapdir as Integer) as IntPTR
End Function

' SRC\dewarp3.c (114, 1)
' dewarpaApplyDisparity()
' dewarpaApplyDisparity(L_DEWARPA *, l_int32, PIX *, l_int32, l_int32, l_int32, PIX **, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This applies the disparity arrays to the specified image.
'''  *   (2) Specify gray color for pixels brought in from the outside:
'''  * 0 is black, 255 is white.  Use -1 to select pixels from the
'''  * boundary of the source image.
'''  *   (3) If the models and ref models have not been validated, this
'''  * will do so by calling dewarpaInsertRefModels().
'''  *   (4) This works with both stripped and full resolution page models.
'''  * If the full res disparity array(s) are missing, they are remade.
'''  *   (5) The caller must handle errors that are returned because there
'''  * are no valid models or ref models for the page -- typically
'''  * by using the input pixs.
'''  *   (6) If there is no model for %pageno, this will use the model for
'''  * 'refpage' and put the result in the dew for %pageno.
'''  *   (7) This populates the full resolution disparity arrays if
'''  * necessary.  If x and/or y are positive, they are used,
'''  * in conjunction with pixs, to determine the required
'''  * slope-based extension of the full resolution disparity
'''  * arrays in each direction.  When (x,y) == (0,0), all
'''  * extension is to the right and down.  Nonzero values of (x,y)
'''  * are useful for dewarping when pixs is deliberately undercropped.
'''  *   (8) Important: when applying disparity to a number of images,
'''  * after calling this function and saving the resulting pixd,
'''  * you should call dewarpMinimize(dew) on the dew for %pageno.
'''  * This will remove pixs and pixd (or their clones) stored in dew,
'''  * as well as the full resolution disparity arrays.  Together,
'''  * these hold approximately 16 bytes for each pixel in pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error no models or ref models available</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="pageno"> \param[in]    pageno of page model to be used; may be a ref model</param>
''' <param name="pixs"> \param[in]    pixs image to be modified; can be 1, 8 or 32 bpp</param>
''' <param name="grayin"> \param[in]    grayin gray value, from 0 to 255, for pixels brought in;</param>
''' <param name="x"> \param[in]    x, y origin for generation of disparity arrays</param>
''' <param name="y"> \param[out]   ppixd disparity corrected image</param>
''' <param name="ppixd"> \param[in]    debugfile use NULL to skip writing this</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaApplyDisparity")> _
Friend Shared Function dewarpaApplyDisparity(dewa as IntPTR, pageno as Integer, pixs as IntPTR, grayin as Integer, x as Integer, y as Integer, ppixd as Object, debugfile as String) as Integer
End Function

' SRC\dewarp3.c (537, 1)
' dewarpaApplyDisparityBoxa()
' dewarpaApplyDisparityBoxa(L_DEWARPA *, l_int32, PIX *, BOXA *, l_int32, l_int32, l_int32, BOXA **, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This applies the disparity arrays in one of two mapping directions
'''  * to the specified boxa.  It can be used in the backward direction
'''  * to locate a box in the original coordinates that would have
'''  * been dewarped to to the specified image.
'''  *   (2) If there is no model for %pageno, this will use the model for
'''  * 'refpage' and put the result in the dew for %pageno.
'''  *   (3) This works with both stripped and full resolution page models.
'''  * If the full res disparity array(s) are missing, they are remade.
'''  *   (4) If an error occurs, a copy of the input boxa is returned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error no models or ref models available</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="pageno"> \param[in]    pageno of page model to be used; may be a ref model</param>
''' <param name="pixs"> \param[in]    pixs initial pix reference; for alignment and debugging</param>
''' <param name="boxas"> \param[in]    boxas boxa to be mapped</param>
''' <param name="mapdir"> \param[in]    mapdir 1 if mapping forward from original to dewarped;</param>
''' <param name="x"> \param[in]    x, y origin for generation of disparity arrays with</param>
''' <param name="y"> \param[out]   pboxad disparity corrected boxa</param>
''' <param name="pboxad"> \param[in]    debugfile use NULL to skip writing this</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaApplyDisparityBoxa")> _
Friend Shared Function dewarpaApplyDisparityBoxa(dewa as IntPTR, pageno as Integer, pixs as IntPTR, boxas as IntPTR, mapdir as Integer, x as Integer, y as Integer, pboxad as Object, debugfile as String) as Integer
End Function

' SRC\dewarp3.c (729, 1)
' dewarpMinimize()
' dewarpMinimize(L_DEWARP *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This removes all data that is not needed for serialization.
'''  * It keeps the subsampled disparity array(s), so the full
'''  * resolution arrays can be reconstructed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dew"> \param[in]    dew</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpMinimize")> _
Friend Shared Function dewarpMinimize(dew as IntPTR) as Integer
End Function

' SRC\dewarp3.c (785, 1)
' dewarpPopulateFullRes()
' dewarpPopulateFullRes(L_DEWARP *, PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If the full resolution vertical and horizontal disparity
'''  * arrays do not exist, they are built from the subsampled ones.
'''  *   (2) If pixs is not given, the size of the arrays is determined
'''  * by the original image from which the sampled version was
'''  * generated.  Any values of (x,y) are ignored.
'''  *   (3) If pixs is given, the full resolution disparity arrays must
'''  * be large enough to accommodate it.
'''  * (a) If the arrays do not exist, the value of (x,y) determines
'''  *  the origin of the full resolution arrays without extension,
'''  *  relative to pixs.  Thus, (x,y) gives the amount of
'''  *  slope extension in (left, top).  The (right, bottom)
'''  *  extension is then determined by the size of pixs and
'''  *  (x,y); the values should never be  0.
'''  * (b) If the arrays exist and pixs is too large, the existing
'''  *  full res arrays are destroyed and new ones are made,
'''  *  again using (x,y) to determine the extension in the
'''  *  four directions.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dew"> \param[in]    dew</param>
''' <param name="pix"> \param[in]    pix [optional], to give size of actual image</param>
''' <param name="x"> \param[in]    x, y origin for generation of disparity arrays</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpPopulateFullRes")> _
Friend Shared Function dewarpPopulateFullRes(dew as IntPTR, pix as IntPTR, x as Integer, y as Integer) as Integer
End Function

#End Region
#Region "SRC\dewarp4.c"
' SRC\dewarp4.c (60, 16)
' dewarpaTestForValidModel()
' dewarpaTestForValidModel(L_DEWARPA *, L_DEWARP *, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Computes validity of vertical (vvalid) model and both
'''  * vertical and horizontal (hvalid) models.
'''  *   (2) If %notests == 1, this ignores the curvature constraints
'''  * and assumes that all successfully built models are valid.
'''  *   (3) This is just about the models, not the rendering process,
'''  * so the value of useboth is not considered here.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="dew"> \param[in]    dew</param>
''' <param name="notests"> \param[in]    notests</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaTestForValidModel")> _
Friend Shared Function dewarpaTestForValidModel(dewa as IntPTR, dew as IntPTR, notests as Integer) as Integer
End Function

' SRC\dewarp4.c (97, 1)
' dewarpSinglePage()
' dewarpSinglePage(PIX *, l_int32, l_int32, l_int32, l_int32, PIX **, L_DEWARPA **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Dewarps pixs and returns the result in &pixd.
'''  *   (2) This uses default values for all model parameters.
'''  *   (3) If pixs is 1 bpp, the parameters %adaptive and %thresh are ignored.
'''  *   (4) If it can't build a model, returns a copy of pixs in &pixd.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error list of page numbers, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs with text, any depth</param>
''' <param name="thresh"> \param[in]    thresh for global thresholding to 1 bpp; ignored otherwise</param>
''' <param name="adaptive"> \param[in]    adaptive 1 for adaptive thresholding; 0 for global threshold</param>
''' <param name="useboth"> \param[in]    useboth 1 for horizontal and vertical; 0 for vertical only</param>
''' <param name="check_columns"> \param[in]    check_columns 1 to skip horizontal if multiple columns;</param>
''' <param name="ppixd"> \param[out]   ppixd dewarped result</param>
''' <param name="pdewa"> \param[out]   pdewa [optional] dewa with single page; NULL to skip</param>
''' <param name="debug"> \param[in]    debug 1 for debugging output, 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpSinglePage")> _
Friend Shared Function dewarpSinglePage(pixs as IntPTR, thresh as Integer, adaptive as Integer, useboth as Integer, check_columns as Integer, ppixd as Object, pdewa as Object, debug as Integer) as Integer
End Function

' SRC\dewarp4.c (165, 1)
' dewarpSinglePageInit()
' dewarpSinglePageInit(PIX *, l_int32, l_int32, l_int32, l_int32, PIX **, L_DEWARPA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This binarizes the input pixs if necessary, returning the
'''  * binarized image.  It also initializes the dewa to default values
'''  * for the model parameters.
'''  *   (2) If pixs is 1 bpp, the parameters %adaptive and %thresh are ignored.
'''  *   (3) To change the model parameters, call dewarpaSetCurvatures()
'''  * before running dewarpSinglePageRun().  For example:
'''  * dewarpSinglePageInit(pixs, 0, 1, 1, 1, &pixb, &dewa);
'''  * dewarpaSetCurvatures(dewa, 250, -1, -1, 80, 70, 150);
'''  * dewarpSinglePageRun(pixs, pixb, dewa, &pixd, 0);
'''  * dewarpaDestroy(&dewa);
'''  * pixDestroy(&pixb);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error list of page numbers, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs with text, any depth</param>
''' <param name="thresh"> \param[in]    thresh for global thresholding to 1 bpp; ignored otherwise</param>
''' <param name="adaptive"> \param[in]    adaptive 1 for adaptive thresholding; 0 for global threshold</param>
''' <param name="useboth"> \param[in]    useboth 1 for horizontal and vertical; 0 for vertical only</param>
''' <param name="check_columns"> \param[in]    check_columns 1 to skip horizontal if multiple columns;</param>
''' <param name="ppixb"> \param[out]   ppixb 1 bpp image</param>
''' <param name="pdewa"> \param[out]   pdewa initialized dewa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpSinglePageInit")> _
Friend Shared Function dewarpSinglePageInit(pixs as IntPTR, thresh as Integer, adaptive as Integer, useboth as Integer, check_columns as Integer, ppixb as Object, pdewa as Object) as Integer
End Function

' SRC\dewarp4.c (223, 1)
' dewarpSinglePageRun()
' dewarpSinglePageRun(PIX *, PIX *, L_DEWARPA *, PIX **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Dewarps pixs and returns the result in &pixd.
'''  *   (2) The 1 bpp version %pixb and %dewa are conveniently generated by
'''  * dewarpSinglePageInit().
'''  *   (3) Non-default model parameters must be set before calling this.
'''  *   (4) If a model cannot be built, this returns a copy of pixs in &pixd.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error list of page numbers, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth</param>
''' <param name="pixb"> \param[in]    pixb 1 bpp</param>
''' <param name="dewa"> \param[in]    dewa initialized</param>
''' <param name="ppixd"> \param[out]   ppixd dewarped result</param>
''' <param name="debug"> \param[in]    debug 1 for debugging output, 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpSinglePageRun")> _
Friend Shared Function dewarpSinglePageRun(pixs as IntPTR, pixb as IntPTR, dewa as IntPTR, ppixd as Object, debug as Integer) as Integer
End Function

' SRC\dewarp4.c (289, 1)
' dewarpaListPages()
' dewarpaListPages(L_DEWARPA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This generates two numas, stored in the dewarpa, that give:
'''  * (a) the page number for each dew that has a page model.
'''  * (b) the page number for each dew that has either a page
'''  *  model or a reference model.
'''  * It can be called at any time.
'''  *   (2) It is called by the dewarpa serializer before writing.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error list of page numbers, or NULL on error</returns>
''' <param name="dewa"> \param[in]    dewa populated with dewarp structs for pages</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaListPages")> _
Friend Shared Function dewarpaListPages(dewa as IntPTR) as Integer
End Function

' SRC\dewarp4.c (341, 1)
' dewarpaSetValidModels()
' dewarpaSetValidModels(L_DEWARPA *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) A valid model must meet the rendering requirements, which
'''  * include whether or not a vertical disparity model exists
'''  * and conditions on curvatures for vertical and horizontal
'''  * disparity models.
'''  *   (2) If %notests == 1, this ignores the curvature constraints
'''  * and assumes that all successfully built models are valid.
'''  *   (3) This function does not need to be called by the application.
'''  * It is called by dewarpaInsertRefModels(), which
'''  * will destroy all invalid dewarps.  Consequently, to inspect
'''  * an invalid dewarp model, it must be done before calling
'''  * dewarpaInsertRefModels().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="notests"> \param[in]    notests</param>
''' <param name="debug"> \param[in]    debug 1 to output information on invalid page models</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaSetValidModels")> _
Friend Shared Function dewarpaSetValidModels(dewa as IntPTR, notests as Integer, debug as Integer) as Integer
End Function

' SRC\dewarp4.c (447, 1)
' dewarpaInsertRefModels()
' dewarpaInsertRefModels(L_DEWARPA *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This destroys all dewarp models that are invalid, and then
'''  * inserts reference models where possible.
'''  *   (2) If %notests == 1, this ignores the curvature constraints
'''  * and assumes that all successfully built models are valid.
'''  *   (3) If useboth == 0, it uses the closest valid model within the
'''  * distance and parity constraints.  If useboth == 1, it tries
'''  * to use the closest allowed hvalid model; if it doesn't find
'''  * an hvalid model, it uses the closest valid model.
'''  *   (4) For all pages without a model, this clears out any existing
'''  * invalid and reference dewarps, finds the nearest valid model
'''  * with the same parity, and inserts an empty dewarp with the
'''  * reference page.
'''  *   (5) Then if it is requested to use both vertical and horizontal
'''  * disparity arrays (useboth == 1), it tries to replace any
'''  * hvalid == 0 model or reference with an hvalid == 1 reference.
'''  *   (6) The distance constraint is that any reference model must
'''  * be within maxdist.  Note that with the parity constraint,
'''  * no reference models will be used if maxdist  2.
'''  *   (7) This function must be called, even if reference models will
'''  * not be used.  It should be called after building models on all
'''  * available pages, and after setting the rendering parameters.
'''  *   (8) If the dewa has been serialized, this function is called by
'''  * dewarpaRead() when it is read back.  It is also called
'''  * any time the rendering parameters are changed.
'''  *   (9) Note: if this has been called with useboth == 1, and useboth
'''  * is reset to 0, you should first call dewarpaRestoreModels()
'''  * to bring real models from the cache back to the primary array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="notests"> \param[in]    notests if 1, ignore curvature constraints on model</param>
''' <param name="debug"> \param[in]    debug 1 to output information on invalid page models</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaInsertRefModels")> _
Friend Shared Function dewarpaInsertRefModels(dewa as IntPTR, notests as Integer, debug as Integer) as Integer
End Function

' SRC\dewarp4.c (578, 1)
' dewarpaStripRefModels()
' dewarpaStripRefModels(L_DEWARPA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This examines each dew in a dewarpa, and removes
'''  * all that don't have their own page model (i.e., all
'''  * that have "references" to nearby pages with valid models).
'''  * These references were generated by dewarpaInsertRefModels(dewa).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa populated with dewarp structs for pages</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaStripRefModels")> _
Friend Shared Function dewarpaStripRefModels(dewa as IntPTR) as Integer
End Function

' SRC\dewarp4.c (619, 1)
' dewarpaRestoreModels()
' dewarpaRestoreModels(L_DEWARPA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This puts all real models (and only real models) in the
'''  * primary dewarpa array.  First remove all dewarps that are
'''  * only references to other page models.  Then move all models
'''  * that had been cached back into the primary dewarp array.
'''  *   (2) After this is done, we still need to recompute and insert
'''  * the reference models before dewa->modelsready is true.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa populated with dewarp structs for pages</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaRestoreModels")> _
Friend Shared Function dewarpaRestoreModels(dewa as IntPTR) as Integer
End Function

' SRC\dewarp4.c (664, 1)
' dewarpaInfo()
' dewarpaInfo(FILE *, L_DEWARPA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp</param>
''' <param name="dewa"> \param[in]    dewa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaInfo")> _
Friend Shared Function dewarpaInfo(fp as Object, dewa as IntPTR) as Integer
End Function

' SRC\dewarp4.c (756, 1)
' dewarpaModelStats()
' dewarpaModelStats(L_DEWARPA *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) A page without a model has no dew.  It most likely failed to
'''  * generate a vertical model, and has not been assigned a ref
'''  * model from a neighboring page with a valid vertical model.
'''  *   (2) A page has vsuccess == 1 if there is at least a model of the
'''  * vertical disparity.  The model may be invalid, in which case
'''  * dewarpaInsertRefModels() will stash it in the cache and
'''  * attempt to replace it by a valid ref model.
'''  *   (3) A vvvalid model is a vertical disparity model whose parameters
'''  * satisfy the constraints given in dewarpaSetValidModels().
'''  *   (4) A page has hsuccess == 1 if both the vertical and horizontal
'''  * disparity arrays have been constructed.
'''  *   (5) An  hvalid model has vertical and horizontal disparity
'''  * models whose parameters satisfy the constraints given
'''  * in dewarpaSetValidModels().
'''  *   (6) A page has a ref model if it failed to generate a valid
'''  * model but was assigned a vvalid or hvalid model on another
'''  * page (within maxdist) by dewarpaInsertRefModel().
'''  *   (7) This calls dewarpaTestForValidModel(); it ignores the vvalid
'''  * and hvalid fields.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="pnnone"> \param[out]   pnnone [optional] number without any model</param>
''' <param name="pnvsuccess"> \param[out]   pnvsuccess [optional] number with a vert model</param>
''' <param name="pnvvalid"> \param[out]   pnvvalid [optional] number with a valid vert model</param>
''' <param name="pnhsuccess"> \param[out]   pnhsuccess [optional] number with both models</param>
''' <param name="pnhvalid"> \param[out]   pnhvalid [optional] number with both models valid</param>
''' <param name="pnref"> \param[out]   pnref [optional] number with a reference model</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaModelStats")> _
Friend Shared Function dewarpaModelStats(dewa as IntPTR, pnnone as Integer, pnvsuccess as Integer, pnvvalid as Integer, pnhsuccess as Integer, pnhvalid as Integer, pnref as Integer) as Integer
End Function

' SRC\dewarp4.c (912, 1)
' dewarpaShowArrays()
' dewarpaShowArrays(L_DEWARPA *, l_float32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Generates a pdf of contour plots of the disparity arrays.
'''  *   (2) This only shows actual models; not ref models
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="scalefact"> \param[in]    scalefact on contour images; typ. 0.5</param>
''' <param name="first"> \param[in]    first first page model to render</param>
''' <param name="last"> \param[in]    last last page model to render; use 0 to go to end</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpaShowArrays")> _
Friend Shared Function dewarpaShowArrays(dewa as IntPTR, scalefact as single, first as Integer, last as Integer) as Integer
End Function

' SRC\dewarp4.c (1008, 1)
' dewarpDebug()
' dewarpDebug(L_DEWARP *, const char *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Prints dewarp fields and generates disparity array contour images.
'''  * The contour images are written to file:
'''  * /tmp/[subdirs]/pixv_[index].png
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dew"> \param[in]    dew</param>
''' <param name="subdirs"> \param[in]    subdirs one or more subdirectories of /tmp; e.g., "dew1"</param>
''' <param name="index"> \param[in]    index to help label output images; e.g., the page number</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpDebug")> _
Friend Shared Function dewarpDebug(dew as IntPTR, subdirs as String, index as Integer) as Integer
End Function

' SRC\dewarp4.c (1094, 1)
' dewarpShowResults()
' dewarpShowResults(L_DEWARPA *, SARRAY *, BOXA *, l_int32, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This generates a pdf of image pairs (before, after) for
'''  * the designated set of input pages.
'''  *   (2) If the boxa exists, its elements are aligned with numbers
'''  * in the filenames in %sa.  It is used to crop the input images.
'''  * It is assumed that the dewa was generated from the cropped
'''  * images.  No undercropping is applied before rendering.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dewa"> \param[in]    dewa</param>
''' <param name="sa"> \param[in]    sa of indexed input images</param>
''' <param name="boxa"> \param[in]    boxa crop boxes for input images; can be null</param>
''' <param name="firstpage"> \param[in]    firstpage, lastpage</param>
''' <param name="lastpage"> \param[in]    pdfout filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dewarpShowResults")> _
Friend Shared Function dewarpShowResults(dewa as IntPTR, sa as IntPTR, boxa as IntPTR, firstpage as Integer, lastpage as Integer, pdfout as String) as Integer
End Function

#End Region
#Region "SRC\dnabasic.c"
' SRC\dnabasic.c (155, 16)
' l_dnaExtendArray()
' l_dnaExtendArray(L_DNA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaExtendArray")> _
Friend Shared Function l_dnaExtendArray(da as IntPTR) as Integer
End Function

' SRC\dnabasic.c (156, 16)
' l_dnaaExtendArray()
' l_dnaaExtendArray(L_DNAA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="daa"> \param[in]    daa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaExtendArray")> _
Friend Shared Function l_dnaaExtendArray(daa as IntPTR) as Integer
End Function

' SRC\dnabasic.c (169, 1)
' l_dnaCreate()
' l_dnaCreate(l_int32) as L_DNA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  da, or NULL on error</returns>
''' <param name="n"> \param[in]    n size of number array to be alloc'd; 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaCreate")> _
Friend Shared Function l_dnaCreate(n as Integer) as IntPTR
End Function

' SRC\dnabasic.c (210, 1)
' l_dnaCreateFromIArray()
' l_dnaCreateFromIArray(l_int32 *, l_int32) as L_DNA *
''' <summary>
''' * Notes:
'''  *   (1) We can't insert this int array into the l_dna, because a l_dna
'''  * takes a double array.  So this just copies the data from the
'''  * input array into the l_dna.  The input array continues to be
'''  * owned by the caller.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  da, or NULL on error</returns>
''' <param name="iarray"> \param[in]    iarray integer</param>
''' <param name="size"> \param[in]    size of the array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaCreateFromIArray")> _
Friend Shared Function l_dnaCreateFromIArray(iarray as Integer, size as Integer) as IntPTR
End Function

' SRC\dnabasic.c (247, 1)
' l_dnaCreateFromDArray()
' l_dnaCreateFromDArray(l_float64 *, l_int32, l_int32) as L_DNA *
''' <summary>
''' * Notes:
'''  *   (1) With L_INSERT, ownership of the input array is transferred
'''  * to the returned l_dna, and all %size elements are considered
'''  * to be valid.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  da, or NULL on error</returns>
''' <param name="darray"> \param[in]    darray float</param>
''' <param name="size"> \param[in]    size of the array</param>
''' <param name="copyflag"> \param[in]    copyflag L_INSERT or L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaCreateFromDArray")> _
Friend Shared Function l_dnaCreateFromDArray(darray as Double, size as Integer, copyflag as Integer) as IntPTR
End Function

' SRC\dnabasic.c (286, 1)
' l_dnaMakeSequence()
' l_dnaMakeSequence(l_float64, l_float64, l_int32) as L_DNA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  l_dna of sequence of evenly spaced values, or NULL on error</returns>
''' <param name="startval"> \param[in]    startval</param>
''' <param name="increment"> \param[in]    increment</param>
''' <param name="size"> \param[in]    size of sequence</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaMakeSequence")> _
Friend Shared Function l_dnaMakeSequence(startval as Double, increment as Double, size as Integer) as IntPTR
End Function

' SRC\dnabasic.c (321, 1)
' l_dnaDestroy()
' l_dnaDestroy(L_DNA **) as void
''' <summary>
''' * Notes:
'''  *   (1) Decrements the ref count and, if 0, destroys the l_dna.
'''  *   (2) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pda"> \param[in,out]   pda to be nulled if it exists</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaDestroy")> _
Friend Shared Function l_dnaDestroy(pda as Object) as Boolean ' Org. Void
End Function

' SRC\dnabasic.c (360, 1)
' l_dnaCopy()
' l_dnaCopy(L_DNA *) as L_DNA *
''' <summary>
''' * Notes:
'''  *   (1) This removes unused ptrs above da->n.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  copy of da, or NULL on error</returns>
''' <param name="da"> \param[in]    da</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaCopy")> _
Friend Shared Function l_dnaCopy(da as IntPTR) as IntPTR
End Function

' SRC\dnabasic.c (389, 1)
' l_dnaClone()
' l_dnaClone(L_DNA *) as L_DNA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to same da, or NULL on error</returns>
''' <param name="da"> \param[in]    da</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaClone")> _
Friend Shared Function l_dnaClone(da as IntPTR) as IntPTR
End Function

' SRC\dnabasic.c (415, 1)
' l_dnaEmpty()
' l_dnaEmpty(L_DNA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does not change the allocation of the array.
'''  * It just clears the number of stored numbers, so that
'''  * the array appears to be empty.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaEmpty")> _
Friend Shared Function l_dnaEmpty(da as IntPTR) as Integer
End Function

' SRC\dnabasic.c (439, 1)
' l_dnaAddNumber()
' l_dnaAddNumber(L_DNA *, l_float64) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="val"> \param[in]    val  float or int to be added; stored as a float</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaAddNumber")> _
Friend Shared Function l_dnaAddNumber(da as IntPTR, val as Double) as Integer
End Function

' SRC\dnabasic.c (500, 1)
' l_dnaInsertNumber()
' l_dnaInsertNumber(L_DNA *, l_int32, l_float64) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This shifts da[i] --> da[i + 1] for all i >= index,
'''  * and then inserts val as da[index].
'''  *   (2) It should not be used repeatedly on large arrays,
'''  * because the function is O(n).
'''  *
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="index"> \param[in]    index location in da to insert new value</param>
''' <param name="val"> \param[in]    val  float64 or integer to be added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaInsertNumber")> _
Friend Shared Function l_dnaInsertNumber(da as IntPTR, index as Integer, val as Double) as Integer
End Function

' SRC\dnabasic.c (539, 1)
' l_dnaRemoveNumber()
' l_dnaRemoveNumber(L_DNA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This shifts da[i] --> da[i - 1] for all i > index.
'''  *   (2) It should not be used repeatedly on large arrays,
'''  * because the function is O(n).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="index"> \param[in]    index element to be removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaRemoveNumber")> _
Friend Shared Function l_dnaRemoveNumber(da as IntPTR, index as Integer) as Integer
End Function

' SRC\dnabasic.c (568, 1)
' l_dnaReplaceNumber()
' l_dnaReplaceNumber(L_DNA *, l_int32, l_float64) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="index"> \param[in]    index element to be replaced</param>
''' <param name="val"> \param[in]    val new value to replace old one</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaReplaceNumber")> _
Friend Shared Function l_dnaReplaceNumber(da as IntPTR, index as Integer, val as Double) as Integer
End Function

' SRC\dnabasic.c (597, 1)
' l_dnaGetCount()
' l_dnaGetCount(L_DNA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 if no numbers or on error</returns>
''' <param name="da"> \param[in]    da</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaGetCount")> _
Friend Shared Function l_dnaGetCount(da as IntPTR) as Integer
End Function

' SRC\dnabasic.c (624, 1)
' l_dnaSetCount()
' l_dnaSetCount(L_DNA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If newcount = da->nalloc, this resets da->n.
'''  * Using newcount = 0 is equivalent to l_dnaEmpty().
'''  *   (2) If newcount > da->nalloc, this causes a realloc
'''  * to a size da->nalloc = newcount.
'''  *   (3) All the previously unused values in da are set to 0.0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="newcount"> \param[in]    newcount</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaSetCount")> _
Friend Shared Function l_dnaSetCount(da as IntPTR, newcount as Integer) as Integer
End Function

' SRC\dnabasic.c (658, 1)
' l_dnaGetDValue()
' l_dnaGetDValue(L_DNA *, l_int32, l_float64 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Caller may need to check the function return value to
'''  * decide if a 0.0 in the returned ival is valid.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="index"> \param[in]    index into l_dna</param>
''' <param name="pval"> \param[out]   pval  double value; 0.0 on error</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaGetDValue")> _
Friend Shared Function l_dnaGetDValue(da as IntPTR, index as Integer, pval as Double) as Integer
End Function

' SRC\dnabasic.c (693, 1)
' l_dnaGetIValue()
' l_dnaGetIValue(L_DNA *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Caller may need to check the function return value to
'''  * decide if a 0 in the returned ival is valid.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="index"> \param[in]    index into l_dna</param>
''' <param name="pival"> \param[out]   pival  integer value; 0 on error</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaGetIValue")> _
Friend Shared Function l_dnaGetIValue(da as IntPTR, index as Integer, pival as Integer) as Integer
End Function

' SRC\dnabasic.c (725, 1)
' l_dnaSetValue()
' l_dnaSetValue(L_DNA *, l_int32, l_float64) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="index"> \param[in]    index  to element to be set</param>
''' <param name="val"> \param[in]    val  to set element</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaSetValue")> _
Friend Shared Function l_dnaSetValue(da as IntPTR, index as Integer, val as Double) as Integer
End Function

' SRC\dnabasic.c (750, 1)
' l_dnaShiftValue()
' l_dnaShiftValue(L_DNA *, l_int32, l_float64) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="index"> \param[in]    index to element to change relative to the current value</param>
''' <param name="diff"> \param[in]    diff  increment if diff > 0 or decrement if diff < 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaShiftValue")> _
Friend Shared Function l_dnaShiftValue(da as IntPTR, index as Integer, diff as Double) as Integer
End Function

' SRC\dnabasic.c (786, 1)
' l_dnaGetIArray()
' l_dnaGetIArray(L_DNA *) as l_int32 *
''' <summary>
''' * Notes:
'''  *   (1) A copy of the array is made, because we need to
'''  * generate an integer array from the bare double array.
'''  * The caller is responsible for freeing the array.
'''  *   (2) The array size is determined by the number of stored numbers,
'''  * not by the size of the allocated array in the l_dna.
'''  *   (3) This function is provided to simplify calculations
'''  * using the bare internal array, rather than continually
'''  * calling accessors on the l_dna.  It is typically used
'''  * on an array of size 256.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  a copy of the bare internal array, integerized</returns>
''' <param name="da"> \param[in]    da</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaGetIArray")> _
Friend Shared Function l_dnaGetIArray(da as IntPTR) as String
End Function

' SRC\dnabasic.c (831, 1)
' l_dnaGetDArray()
' l_dnaGetDArray(L_DNA *, l_int32) as l_float64 *
''' <summary>
''' * Notes:
'''  *   (1) If copyflag == L_COPY, it makes a copy which the caller
'''  * is responsible for freeing.  Otherwise, it operates
'''  * directly on the bare array of the l_dna.
'''  *   (2) Very important: for L_NOCOPY, any writes to the array
'''  * will be in the l_dna.  Do not write beyond the size of
'''  * the count field, because it will not be accessible
'''  * from the l_dna!  If necessary, be sure to set the count
'''  * field to a larger number (such as the alloc size)
'''  * BEFORE calling this function.  Creating with l_dnaMakeConstant()
'''  * is another way to insure full initialization.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  either the bare internal array or a copy of it,</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="copyflag"> \param[in]    copyflag L_NOCOPY or L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaGetDArray")> _
Friend Shared Function l_dnaGetDArray(da as IntPTR, copyflag as Integer) as String
End Function

' SRC\dnabasic.c (863, 1)
' l_dnaGetRefCount()
' l_dnaGetRefcount(L_DNA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  refcount, or UNDEF on error</returns>
''' <param name="da"> \param[in]    da</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaGetRefcount")> _
Friend Shared Function l_dnaGetRefcount(da as IntPTR) as Integer
End Function

' SRC\dnabasic.c (881, 1)
' l_dnaChangeRefCount()
' l_dnaChangeRefcount(L_DNA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="delta"> \param[in]    delta change to be applied</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaChangeRefcount")> _
Friend Shared Function l_dnaChangeRefcount(da as IntPTR, delta as Integer) as Integer
End Function

' SRC\dnabasic.c (902, 1)
' l_dnaGetParameters()
' l_dnaGetParameters(L_DNA *, l_float64 *, l_float64 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="pstartx"> \param[out]   pstartx [optional] startx</param>
''' <param name="pdelx"> \param[out]   pdelx [optional] delx</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaGetParameters")> _
Friend Shared Function l_dnaGetParameters(da as IntPTR, pstartx as Double, pdelx as Double) as Integer
End Function

' SRC\dnabasic.c (932, 1)
' l_dnaSetParameters()
' l_dnaSetParameters(L_DNA *, l_float64, l_float64) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="startx"> \param[in]    startx x value corresponding to da[0]</param>
''' <param name="delx"> \param[in]    delx difference in x values for the situation where the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaSetParameters")> _
Friend Shared Function l_dnaSetParameters(da as IntPTR, startx as Double, delx as Double) as Integer
End Function

' SRC\dnabasic.c (955, 1)
' l_dnaCopyParameters()
' l_dnaCopyParameters(L_DNA *, L_DNA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dad"> \param[in]    dad destination DNuma</param>
''' <param name="das"> \param[in]    das source DNuma</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaCopyParameters")> _
Friend Shared Function l_dnaCopyParameters(dad as IntPTR, das as IntPTR) as Integer
End Function

' SRC\dnabasic.c (981, 1)
' l_dnaRead()
' l_dnaRead(const char *) as L_DNA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  da, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaRead")> _
Friend Shared Function l_dnaRead(filename as String) as IntPTR
End Function

' SRC\dnabasic.c (1013, 1)
' l_dnaReadStream()
' l_dnaReadStream(FILE *) as L_DNA *
''' <summary>
''' * Notes:
'''  *   (1) fscanf takes %lf to read a double; fprintf takes %f to write it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  da, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaReadStream")> _
Friend Shared Function l_dnaReadStream(fp as Object) as IntPTR
End Function

' SRC\dnabasic.c (1056, 1)
' l_dnaWrite()
' l_dnaWrite(const char *, L_DNA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename, da</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaWrite")> _
Friend Shared Function l_dnaWrite(filename as String, da as IntPTR) as Integer
End Function

' SRC\dnabasic.c (1087, 1)
' l_dnaWriteStream()
' l_dnaWriteStream(FILE *, L_DNA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="da"> \param[in]    da</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaWriteStream")> _
Friend Shared Function l_dnaWriteStream(fp as Object, da as IntPTR) as Integer
End Function

' SRC\dnabasic.c (1127, 1)
' l_dnaaCreate()
' l_dnaaCreate(l_int32) as L_DNAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  daa, or NULL on error</returns>
''' <param name="n"> \param[in]    n size of l_dna ptr array to be alloc'd 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaCreate")> _
Friend Shared Function l_dnaaCreate(n as Integer) as IntPTR
End Function

' SRC\dnabasic.c (1163, 1)
' l_dnaaCreateFull()
' l_dnaaCreateFull(l_int32, l_int32) as L_DNAA *
''' <summary>
''' * Notes:
'''  *   (1) This allocates a dnaa and fills the array with allocated dnas.
'''  * In use, after calling this function, use
'''  *  l_dnaaAddNumber(dnaa, index, val);
'''  * to add val to the index-th dna in dnaa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  daa, or NULL on error</returns>
''' <param name="nptr"> \param[in]    nptr: size of dna ptr array to be alloc'd</param>
''' <param name="n"> \param[in]    n: size of individual dna arrays to be alloc'd 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaCreateFull")> _
Friend Shared Function l_dnaaCreateFull(nptr as Integer, n as Integer) as IntPTR
End Function

' SRC\dnabasic.c (1194, 1)
' l_dnaaTruncate()
' l_dnaaTruncate(L_DNAA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This identifies the largest index containing a dna that
'''  * has any numbers within it, destroys all dna beyond that
'''  * index, and resets the count.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="daa"> \param[in]    daa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaTruncate")> _
Friend Shared Function l_dnaaTruncate(daa as IntPTR) as Integer
End Function

' SRC\dnabasic.c (1228, 1)
' l_dnaaDestroy()
' l_dnaaDestroy(L_DNAA **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pdaa"> \param[in,out] pdaa to be nulled if it exists</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaDestroy")> _
Friend Shared Function l_dnaaDestroy(pdaa as Object) as Boolean ' Org. Void
End Function

' SRC\dnabasic.c (1265, 1)
' l_dnaaAddDna()
' l_dnaaAddDna(L_DNAA *, L_DNA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="daa"> \param[in]    daa</param>
''' <param name="da"> \param[in]    da   to be added</param>
''' <param name="copyflag"> \param[in]    copyflag  L_INSERT, L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaAddDna")> _
Friend Shared Function l_dnaaAddDna(daa as IntPTR, da as IntPTR, copyflag as Integer) as Integer
End Function

' SRC\dnabasic.c (1333, 1)
' l_dnaaGetCount()
' l_dnaaGetCount(L_DNAA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count number of l_dna, or 0 if no l_dna or on error</returns>
''' <param name="daa"> \param[in]    daa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaGetCount")> _
Friend Shared Function l_dnaaGetCount(daa as IntPTR) as Integer
End Function

' SRC\dnabasic.c (1351, 1)
' l_dnaaGetDnaCount()
' l_dnaaGetDnaCount(L_DNAA *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count of numbers in the referenced l_dna, or 0 on error.</returns>
''' <param name="daa"> \param[in]    daa</param>
''' <param name="index"> \param[in]    index of l_dna in daa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaGetDnaCount")> _
Friend Shared Function l_dnaaGetDnaCount(daa as IntPTR, index as Integer) as Integer
End Function

' SRC\dnabasic.c (1372, 1)
' l_dnaaGetNumberCount()
' l_dnaaGetNumberCount(L_DNAA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count total number of numbers in the l_dnaa,</returns>
''' <param name="daa"> \param[in]    daa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaGetNumberCount")> _
Friend Shared Function l_dnaaGetNumberCount(daa as IntPTR) as Integer
End Function

' SRC\dnabasic.c (1402, 1)
' l_dnaaGetDna()
' l_dnaaGetDna(L_DNAA *, l_int32, l_int32) as L_DNA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  l_dna, or NULL on error</returns>
''' <param name="daa"> \param[in]    daa</param>
''' <param name="index"> \param[in]    index  to the index-th l_dna</param>
''' <param name="accessflag"> \param[in]    accessflag   L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaGetDna")> _
Friend Shared Function l_dnaaGetDna(daa as IntPTR, index as Integer, accessflag as Integer) as IntPTR
End Function

' SRC\dnabasic.c (1438, 1)
' l_dnaaReplaceDna()
' l_dnaaReplaceDna(L_DNAA *, l_int32, L_DNA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Any existing l_dna is destroyed, and the input one
'''  * is inserted in its place.
'''  *   (2) If the index is invalid, return 1 (error)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="daa"> \param[in]    daa</param>
''' <param name="index"> \param[in]    index  to the index-th l_dna</param>
''' <param name="da"> \param[in]    da insert and replace any existing one</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaReplaceDna")> _
Friend Shared Function l_dnaaReplaceDna(daa as IntPTR, index as Integer, da as IntPTR) as Integer
End Function

' SRC\dnabasic.c (1470, 1)
' l_dnaaGetValue()
' l_dnaaGetValue(L_DNAA *, l_int32, l_int32, l_float64 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="daa"> \param[in]    daa</param>
''' <param name="i"> \param[in]    i index of l_dna within l_dnaa</param>
''' <param name="j"> \param[in]    j index into l_dna</param>
''' <param name="pval"> \param[out]   pval double value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaGetValue")> _
Friend Shared Function l_dnaaGetValue(daa as IntPTR, i as Integer, j as Integer, pval as Double) as Integer
End Function

' SRC\dnabasic.c (1510, 1)
' l_dnaaAddNumber()
' l_dnaaAddNumber(L_DNAA *, l_int32, l_float64) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Adds to an existing l_dna only.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="daa"> \param[in]    daa</param>
''' <param name="index"> \param[in]    index of l_dna within l_dnaa</param>
''' <param name="val"> \param[in]    val  number to be added; stored as a double</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaAddNumber")> _
Friend Shared Function l_dnaaAddNumber(daa as IntPTR, index as Integer, val as Double) as Integer
End Function

' SRC\dnabasic.c (1542, 1)
' l_dnaaRead()
' l_dnaaRead(const char *) as L_DNAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  daa, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaRead")> _
Friend Shared Function l_dnaaRead(filename as String) as IntPTR
End Function

' SRC\dnabasic.c (1569, 1)
' l_dnaaReadStream()
' l_dnaaReadStream(FILE *) as L_DNAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  daa, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaReadStream")> _
Friend Shared Function l_dnaaReadStream(fp as Object) as IntPTR
End Function

' SRC\dnabasic.c (1613, 1)
' l_dnaaWrite()
' l_dnaaWrite(const char *, L_DNAA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename, daa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaWrite")> _
Friend Shared Function l_dnaaWrite(filename as String, daa as IntPTR) as Integer
End Function

' SRC\dnabasic.c (1644, 1)
' l_dnaaWriteStream()
' l_dnaaWriteStream(FILE *, L_DNAA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="daa"> \param[in]    daa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaWriteStream")> _
Friend Shared Function l_dnaaWriteStream(fp as Object, daa as IntPTR) as Integer
End Function

#End Region
#Region "SRC\dnafunc1.c"
' SRC\dnafunc1.c (79, 1)
' l_dnaJoin()
' l_dnaJoin(L_DNA *, L_DNA *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) istart  0 is taken to mean 'read from the start' (istart = 0)
'''  *   (2) iend  0 means 'read to the end'
'''  *   (3) if das == NULL, this is a no-op
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dad"> \param[in]    dad  dest dna; add to this one</param>
''' <param name="das"> \param[in]    das  [optional] source dna; add from this one</param>
''' <param name="istart"> \param[in]    istart  starting index in das</param>
''' <param name="iend"> \param[in]    iend  ending index in das; use -1 to cat all</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaJoin")> _
Friend Shared Function l_dnaJoin(dad as IntPTR, das as IntPTR, istart as Integer, iend as Integer) as Integer
End Function

' SRC\dnafunc1.c (125, 1)
' l_dnaaFlattenToDna()
' l_dnaaFlattenToDna(L_DNAA *) as L_DNA *
''' <summary>
''' * Notes:
'''  *   (1) This 'flattens' the dnaa to a dna, by joining successively
'''  * each dna in the dnaa.
'''  *   (2) It leaves the input dnaa unchanged.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dad, or NULL on error</returns>
''' <param name="daa"> \param[in]    daa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaaFlattenToDna")> _
Friend Shared Function l_dnaaFlattenToDna(daa as IntPTR) as IntPTR
End Function

' SRC\dnafunc1.c (159, 1)
' l_dnaConvertToNuma()
' l_dnaConvertToNuma(L_DNA *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na, or NULL on error</returns>
''' <param name="da"> \param[in]    da</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaConvertToNuma")> _
Friend Shared Function l_dnaConvertToNuma(da as IntPTR) as IntPTR
End Function

' SRC\dnafunc1.c (187, 1)
' numaConvertToDna
' numaConvertToDna(NUMA *) as L_DNA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  da, or NULL on error</returns>
''' <param name="na"> \param[in]    na</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaConvertToDna")> _
Friend Shared Function numaConvertToDna(na as IntPTR) as IntPTR
End Function

' SRC\dnafunc1.c (226, 1)
' l_dnaUnionByAset()
' l_dnaUnionByAset(L_DNA *, L_DNA *) as L_DNA *
''' <summary>
''' * Notes:
'''  *   (1) See sarrayUnionByAset() for the approach.
'''  *   (2) Here, the key in building the sorted tree is the number itself.
'''  *   (3) Operations using an underlying tree are O(nlogn), which is
'''  * typically less efficient than hashing, which is O(n).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dad with the union of the set of numbers, or NULL on error</returns>
''' <param name="da1"> \param[in]    da1, da2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaUnionByAset")> _
Friend Shared Function l_dnaUnionByAset(da1 as IntPTR, da2 as IntPTR) as IntPTR
End Function

' SRC\dnafunc1.c (256, 1)
' l_dnaRemoveDupsByAset()
' l_dnaRemoveDupsByAset(L_DNA *) as L_DNA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dad with duplicates removed, or NULL on error</returns>
''' <param name="das"> \param[in]    das</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaRemoveDupsByAset")> _
Friend Shared Function l_dnaRemoveDupsByAset(das as IntPTR) as IntPTR
End Function

' SRC\dnafunc1.c (301, 1)
' l_dnaIntersectionByAset()
' l_dnaIntersectionByAset(L_DNA *, L_DNA *) as L_DNA *
''' <summary>
''' * Notes:
'''  *   (1) See sarrayIntersection() for the approach.
'''  *   (2) Here, the key in building the sorted tree is the number itself.
'''  *   (3) Operations using an underlying tree are O(nlogn), which is
'''  * typically less efficient than hashing, which is O(n).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dad with the intersection of the two arrays, or NULL on error</returns>
''' <param name="da1"> \param[in]    da1, da2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaIntersectionByAset")> _
Friend Shared Function l_dnaIntersectionByAset(da1 as IntPTR, da2 as IntPTR) as IntPTR
End Function

' SRC\dnafunc1.c (350, 1)
' l_asetCreateFromDna()
' l_asetCreateFromDna(L_DNA *) as L_ASET *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  set using the doubles in %da as keys</returns>
''' <param name="da"> \param[in]    da source dna</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_asetCreateFromDna")> _
Friend Shared Function l_asetCreateFromDna(da as IntPTR) as IntPTR
End Function

' SRC\dnafunc1.c (385, 1)
' l_dnaDiffAdjValues()
' l_dnaDiffAdjValues(L_DNA *) as L_DNA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dad of difference values val[i+1] - val[i],</returns>
''' <param name="das"> \param[in]    das input l_dna</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaDiffAdjValues")> _
Friend Shared Function l_dnaDiffAdjValues(das as IntPTR) as IntPTR
End Function

#End Region
#Region "SRC\dnahash.c"
' SRC\dnahash.c (122, 1)
' l_dnaHashCreate()
' l_dnaHashCreate(l_int32, l_int32) as L_DNAHASH *
''' <summary>
''' * Notes:
'''  *   (1) Actual dna are created only as required by l_dnaHashAdd()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to new dnahash, or NULL on error</returns>
''' <param name="nbuckets"> \param[in]   nbuckets the number of buckets in the hash table,</param>
''' <param name="initsize"> \param[in]   initsize initial size of each allocated dna; 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaHashCreate")> _
Friend Shared Function l_dnaHashCreate(nbuckets as Integer, initsize as Integer) as IntPTR
End Function

' SRC\dnahash.c (152, 1)
' l_dnaHashDestroy()
' l_dnaHashDestroy(L_DNAHASH **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pdahash"> \param[in,out]   pdahash to be nulled, if it exists</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaHashDestroy")> _
Friend Shared Function l_dnaHashDestroy(pdahash as Object) as Boolean ' Org. Void
End Function

' SRC\dnahash.c (185, 1)
' l_dnaHashGetCount()
' l_dnaHashGetCount(L_DNAHASH *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nbuckets allocated, or 0 on error</returns>
''' <param name="dahash"> \param[in]    dahash</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaHashGetCount")> _
Friend Shared Function l_dnaHashGetCount(dahash as IntPTR) as Integer
End Function

' SRC\dnahash.c (203, 1)
' l_dnaHashGetTotalCount()
' l_dnaHashGetTotalCount(L_DNAHASH *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  n number of numbers in all dna, or 0 on error</returns>
''' <param name="dahash"> \param[in]    dahash</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaHashGetTotalCount")> _
Friend Shared Function l_dnaHashGetTotalCount(dahash as IntPTR) as Integer
End Function

' SRC\dnahash.c (232, 1)
' l_dnaHashGetDna()
' l_dnaHashGetDna(L_DNAHASH *, l_uint64, l_int32) as L_DNA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to dna</returns>
''' <param name="dahash"> \param[in]    dahash</param>
''' <param name="key"> \param[in]    key  key to be hashed into a bucket number</param>
''' <param name="copyflag"> \param[in]    copyflag L_NOCOPY, L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaHashGetDna")> _
Friend Shared Function l_dnaHashGetDna(dahash as IntPTR, key as ULong, copyflag as Integer) as IntPTR
End Function

' SRC\dnahash.c (267, 1)
' l_dnaHashAdd()
' l_dnaHashAdd(L_DNAHASH *, l_uint64, l_float64) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="dahash"> \param[in]    dahash</param>
''' <param name="key"> \param[in]    key  key to be hashed into a bucket number</param>
''' <param name="value"> \param[in]    value  float value to be appended to the specific dna</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaHashAdd")> _
Friend Shared Function l_dnaHashAdd(dahash as IntPTR, key as ULong, value as Double) as Integer
End Function

' SRC\dnahash.c (306, 1)
' l_dnaHashCreateFromDna()
' l_dnaHashCreateFromDna(L_DNA *) as L_DNAHASH *
''' <summary>
''' * Notes:
'''  *   (1) The values stored in the %dahash are indices into %da;
'''  * %dahash has no use without %da.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dahash if OK; 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaHashCreateFromDna")> _
Friend Shared Function l_dnaHashCreateFromDna(da as IntPTR) as IntPTR
End Function

' SRC\dnahash.c (350, 1)
' l_dnaRemoveDupsByHash()
' l_dnaRemoveDupsByHash(L_DNA *, L_DNA **, L_DNAHASH **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Generates a dna with unique values.
'''  *   (2) The dnahash is built up with dad to assure uniqueness.
'''  * It can be used to find if an element is in the set:
'''  *  l_dnaFindValByHash(dad, dahash, val, &index)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="das"> \param[in]    das</param>
''' <param name="pdad"> \param[out]   pdad hash set</param>
''' <param name="pdahash"> \param[out]   pdahash [optional] dnahash used for lookup</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaRemoveDupsByHash")> _
Friend Shared Function l_dnaRemoveDupsByHash(das as IntPTR, pdad as Object, pdahash as Object) as Integer
End Function

' SRC\dnahash.c (421, 1)
' l_dnaMakeHistoByHash()
' l_dnaMakeHistoByHash(L_DNA *, L_DNAHASH **, L_DNA **, L_DNA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Generates and returns a dna of occurrences (histogram),
'''  * an aligned dna of values, and an associated hashmap.
'''  * The hashmap takes %dav and a value, and points into the
'''  * histogram in %dac.
'''  *   (2) The dna of values, %dav, is aligned with the histogram %dac,
'''  * and is needed for fast lookup.  It is a hash set, because
'''  * the values are unique.
'''  *   (3) Lookup is simple:
'''  *  l_dnaFindValByHash(dav, dahash, val, &index);
'''  *  if (index >= 0)
'''  *   l_dnaGetIValue(dac, index, &icount);
'''  *  else
'''  *   icount = 0;
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="das"> \param[in]    das</param>
''' <param name="pdahash"> \param[out]   pdahash hash map: val --> index</param>
''' <param name="pdav"> \param[out]   pdav array of values: index --> val</param>
''' <param name="pdac"> \param[out]   pdac histo array of counts: index --> count</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaMakeHistoByHash")> _
Friend Shared Function l_dnaMakeHistoByHash(das as IntPTR, pdahash as Object, pdav as Object, pdac as Object) as Integer
End Function

' SRC\dnahash.c (485, 1)
' l_dnaIntersectionByHash()
' l_dnaIntersectionByHash(L_DNA *, L_DNA *) as L_DNA *
''' <summary>
''' * Notes:
'''  *   (1) This uses the same method for building the intersection set
'''  * as ptaIntersectionByHash() and sarrayIntersectionByHash().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dad intersection of the number arrays, or NULL on error</returns>
''' <param name="da1"> \param[in]    da1, da2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaIntersectionByHash")> _
Friend Shared Function l_dnaIntersectionByHash(da1 as IntPTR, da2 as IntPTR) as IntPTR
End Function

' SRC\dnahash.c (553, 1)
' l_dnaFindValByHash()
' l_dnaFindValByHash(L_DNA *, L_DNAHASH *, l_float64, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Algo: hash %val into a key; hash the key to get the dna
'''  * in %dahash (that holds indices into %da); traverse
'''  * the dna of indices looking for %val in %da.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="da"> \param[in]    da</param>
''' <param name="dahash"> \param[in]    dahash containing indices into %da</param>
''' <param name="val"> \param[in]    val  searching for this number in %da</param>
''' <param name="pindex"> \param[out]   pindex index into da if found; -1 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaFindValByHash")> _
Friend Shared Function l_dnaFindValByHash(da as IntPTR, dahash as IntPTR, val as Double, pindex as Integer) as Integer
End Function

#End Region
#Region "SRC\dwacomb.2.c"
' SRC\dwacomb.2.c (37, 6)
' pixMorphDwa_2()
' pixMorphDwa_2(PIX *, PIX *, l_int32, char *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This simply adds a border, calls the appropriate
'''  * pixFMorphopGen_*(), and removes the border.
'''  * See the notes for that function.
'''  *   (2) The size of the border depends on the operation
'''  * and the boundary conditions.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd usual 3 choices: null, == pixs, != pixs</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="operation"> \param[in]    operation  L_MORPH_DILATE, L_MORPH_ERODE,</param>
''' <param name="selname"> \param[in]    sel name</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMorphDwa_2")> _
Friend Shared Function pixMorphDwa_2(pixd as IntPTR, pixs as IntPTR, operation as Integer, selname as Object) as IntPTR
End Function

' SRC\dwacomb.2.c (38, 6)
' pixFMorphopGen_2()
' pixFMorphopGen_2(PIX *, PIX *, l_int32, char *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a dwa operation, and the Sels must be limited in
'''  * size to not more than 31 pixels about the origin.
'''  *   (2) A border of appropriate size (32 pixels, or 64 pixels
'''  * for safe closing with asymmetric b.c.) must be added before
'''  * this function is called.
'''  *   (3) This handles all required setting of the border pixels
'''  * before erosion and dilation.
'''  *   (4) The closing operation is safe; no pixels can be removed
'''  * near the boundary.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd usual 3 choices: null, == pixs, != pixs</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="operation"> \param[in]    operation  L_MORPH_DILATE, L_MORPH_ERODE,</param>
''' <param name="selname"> \param[in]    sel name</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFMorphopGen_2")> _
Friend Shared Function pixFMorphopGen_2(pixd as IntPTR, pixs as IntPTR, operation as Integer, selname as Object) as IntPTR
End Function

' SRC\dwacomb.2.c (39, 9)
' 
' fmorphopgen_low_2(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fmorphopgen_low_2")> _
Friend Shared Function fmorphopgen_low_2(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, index as Integer) as Integer
End Function

#End Region
#Region "SRC\dwacomblow.2.c"
' SRC\dwacomblow.2.c (40, 14)
' 
' fdilate_2_0(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_0")> _
Friend Shared Function fdilate_2_0(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (41, 14)
' 
' ferode_2_0(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_0")> _
Friend Shared Function ferode_2_0(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (42, 14)
' 
' fdilate_2_1(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_1")> _
Friend Shared Function fdilate_2_1(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (43, 14)
' 
' ferode_2_1(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_1")> _
Friend Shared Function ferode_2_1(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (44, 14)
' 
' fdilate_2_2(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_2")> _
Friend Shared Function fdilate_2_2(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (45, 14)
' 
' ferode_2_2(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_2")> _
Friend Shared Function ferode_2_2(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (46, 14)
' 
' fdilate_2_3(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_3")> _
Friend Shared Function fdilate_2_3(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (47, 14)
' 
' ferode_2_3(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_3")> _
Friend Shared Function ferode_2_3(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (48, 14)
' 
' fdilate_2_4(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_4")> _
Friend Shared Function fdilate_2_4(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (49, 14)
' 
' ferode_2_4(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_4")> _
Friend Shared Function ferode_2_4(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (50, 14)
' 
' fdilate_2_5(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_5")> _
Friend Shared Function fdilate_2_5(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (51, 14)
' 
' ferode_2_5(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_5")> _
Friend Shared Function ferode_2_5(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (52, 14)
' 
' fdilate_2_6(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_6")> _
Friend Shared Function fdilate_2_6(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (53, 14)
' 
' ferode_2_6(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_6")> _
Friend Shared Function ferode_2_6(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (54, 14)
' 
' fdilate_2_7(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_7")> _
Friend Shared Function fdilate_2_7(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (55, 14)
' 
' ferode_2_7(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_7")> _
Friend Shared Function ferode_2_7(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (56, 14)
' 
' fdilate_2_8(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_8")> _
Friend Shared Function fdilate_2_8(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (57, 14)
' 
' ferode_2_8(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_8")> _
Friend Shared Function ferode_2_8(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (58, 14)
' 
' fdilate_2_9(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_9")> _
Friend Shared Function fdilate_2_9(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (59, 14)
' 
' ferode_2_9(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_9")> _
Friend Shared Function ferode_2_9(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (60, 14)
' 
' fdilate_2_10(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_10")> _
Friend Shared Function fdilate_2_10(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (61, 14)
' 
' ferode_2_10(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_10")> _
Friend Shared Function ferode_2_10(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (62, 14)
' 
' fdilate_2_11(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_11")> _
Friend Shared Function fdilate_2_11(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (63, 14)
' 
' ferode_2_11(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_11")> _
Friend Shared Function ferode_2_11(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (64, 14)
' 
' fdilate_2_12(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_12")> _
Friend Shared Function fdilate_2_12(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (65, 14)
' 
' ferode_2_12(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_12")> _
Friend Shared Function ferode_2_12(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (66, 14)
' 
' fdilate_2_13(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_13")> _
Friend Shared Function fdilate_2_13(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (67, 14)
' 
' ferode_2_13(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_13")> _
Friend Shared Function ferode_2_13(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (68, 14)
' 
' fdilate_2_14(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_14")> _
Friend Shared Function fdilate_2_14(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (69, 14)
' 
' ferode_2_14(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_14")> _
Friend Shared Function ferode_2_14(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (70, 14)
' 
' fdilate_2_15(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_15")> _
Friend Shared Function fdilate_2_15(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (71, 14)
' 
' ferode_2_15(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_15")> _
Friend Shared Function ferode_2_15(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (72, 14)
' 
' fdilate_2_16(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_16")> _
Friend Shared Function fdilate_2_16(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (73, 14)
' 
' ferode_2_16(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_16")> _
Friend Shared Function ferode_2_16(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (74, 14)
' 
' fdilate_2_17(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_17")> _
Friend Shared Function fdilate_2_17(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (75, 14)
' 
' ferode_2_17(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_17")> _
Friend Shared Function ferode_2_17(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (76, 14)
' 
' fdilate_2_18(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_18")> _
Friend Shared Function fdilate_2_18(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (77, 14)
' 
' ferode_2_18(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_18")> _
Friend Shared Function ferode_2_18(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (78, 14)
' 
' fdilate_2_19(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_19")> _
Friend Shared Function fdilate_2_19(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (79, 14)
' 
' ferode_2_19(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_19")> _
Friend Shared Function ferode_2_19(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (80, 14)
' 
' fdilate_2_20(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_20")> _
Friend Shared Function fdilate_2_20(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (81, 14)
' 
' ferode_2_20(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_20")> _
Friend Shared Function ferode_2_20(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (82, 14)
' 
' fdilate_2_21(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_21")> _
Friend Shared Function fdilate_2_21(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (83, 14)
' 
' ferode_2_21(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_21")> _
Friend Shared Function ferode_2_21(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (84, 14)
' 
' fdilate_2_22(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_22")> _
Friend Shared Function fdilate_2_22(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (85, 14)
' 
' ferode_2_22(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_22")> _
Friend Shared Function ferode_2_22(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (86, 14)
' 
' fdilate_2_23(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_23")> _
Friend Shared Function fdilate_2_23(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (87, 14)
' 
' ferode_2_23(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_23")> _
Friend Shared Function ferode_2_23(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (88, 14)
' 
' fdilate_2_24(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_24")> _
Friend Shared Function fdilate_2_24(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (89, 14)
' 
' ferode_2_24(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_24")> _
Friend Shared Function ferode_2_24(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (90, 14)
' 
' fdilate_2_25(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_25")> _
Friend Shared Function fdilate_2_25(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (91, 14)
' 
' ferode_2_25(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_25")> _
Friend Shared Function ferode_2_25(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (92, 14)
' 
' fdilate_2_26(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_26")> _
Friend Shared Function fdilate_2_26(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (93, 14)
' 
' ferode_2_26(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_26")> _
Friend Shared Function ferode_2_26(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (94, 14)
' 
' fdilate_2_27(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_27")> _
Friend Shared Function fdilate_2_27(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (95, 14)
' 
' ferode_2_27(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_27")> _
Friend Shared Function ferode_2_27(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (96, 14)
' 
' fdilate_2_28(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_28")> _
Friend Shared Function fdilate_2_28(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (97, 14)
' 
' ferode_2_28(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_28")> _
Friend Shared Function ferode_2_28(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (98, 14)
' 
' fdilate_2_29(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_29")> _
Friend Shared Function fdilate_2_29(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (99, 14)
' 
' ferode_2_29(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_29")> _
Friend Shared Function ferode_2_29(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (100, 14)
' 
' fdilate_2_30(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_30")> _
Friend Shared Function fdilate_2_30(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (101, 14)
' 
' ferode_2_30(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_30")> _
Friend Shared Function ferode_2_30(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (102, 14)
' 
' fdilate_2_31(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_31")> _
Friend Shared Function fdilate_2_31(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (103, 14)
' 
' ferode_2_31(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_31")> _
Friend Shared Function ferode_2_31(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (104, 14)
' 
' fdilate_2_32(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_32")> _
Friend Shared Function fdilate_2_32(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (105, 14)
' 
' ferode_2_32(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_32")> _
Friend Shared Function ferode_2_32(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (106, 14)
' 
' fdilate_2_33(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_33")> _
Friend Shared Function fdilate_2_33(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (107, 14)
' 
' ferode_2_33(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_33")> _
Friend Shared Function ferode_2_33(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (108, 14)
' 
' fdilate_2_34(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_34")> _
Friend Shared Function fdilate_2_34(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (109, 14)
' 
' ferode_2_34(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_34")> _
Friend Shared Function ferode_2_34(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (110, 14)
' 
' fdilate_2_35(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_35")> _
Friend Shared Function fdilate_2_35(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (111, 14)
' 
' ferode_2_35(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_35")> _
Friend Shared Function ferode_2_35(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (112, 14)
' 
' fdilate_2_36(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_36")> _
Friend Shared Function fdilate_2_36(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (113, 14)
' 
' ferode_2_36(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_36")> _
Friend Shared Function ferode_2_36(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (114, 14)
' 
' fdilate_2_37(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_37")> _
Friend Shared Function fdilate_2_37(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (115, 14)
' 
' ferode_2_37(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_37")> _
Friend Shared Function ferode_2_37(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (116, 14)
' 
' fdilate_2_38(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_38")> _
Friend Shared Function fdilate_2_38(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (117, 14)
' 
' ferode_2_38(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_38")> _
Friend Shared Function ferode_2_38(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (118, 14)
' 
' fdilate_2_39(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_39")> _
Friend Shared Function fdilate_2_39(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (119, 14)
' 
' ferode_2_39(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_39")> _
Friend Shared Function ferode_2_39(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (120, 14)
' 
' fdilate_2_40(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_40")> _
Friend Shared Function fdilate_2_40(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (121, 14)
' 
' ferode_2_40(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_40")> _
Friend Shared Function ferode_2_40(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (122, 14)
' 
' fdilate_2_41(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_41")> _
Friend Shared Function fdilate_2_41(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (123, 14)
' 
' ferode_2_41(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_41")> _
Friend Shared Function ferode_2_41(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (124, 14)
' 
' fdilate_2_42(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_42")> _
Friend Shared Function fdilate_2_42(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (125, 14)
' 
' ferode_2_42(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_42")> _
Friend Shared Function ferode_2_42(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (126, 14)
' 
' fdilate_2_43(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_43")> _
Friend Shared Function fdilate_2_43(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (127, 14)
' 
' ferode_2_43(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_43")> _
Friend Shared Function ferode_2_43(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (128, 14)
' 
' fdilate_2_44(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_44")> _
Friend Shared Function fdilate_2_44(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (129, 14)
' 
' ferode_2_44(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_44")> _
Friend Shared Function ferode_2_44(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (130, 14)
' 
' fdilate_2_45(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_45")> _
Friend Shared Function fdilate_2_45(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (131, 14)
' 
' ferode_2_45(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_45")> _
Friend Shared Function ferode_2_45(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (132, 14)
' 
' fdilate_2_46(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_46")> _
Friend Shared Function fdilate_2_46(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (133, 14)
' 
' ferode_2_46(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_46")> _
Friend Shared Function ferode_2_46(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (134, 14)
' 
' fdilate_2_47(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_47")> _
Friend Shared Function fdilate_2_47(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (135, 14)
' 
' ferode_2_47(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_47")> _
Friend Shared Function ferode_2_47(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (136, 14)
' 
' fdilate_2_48(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_48")> _
Friend Shared Function fdilate_2_48(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (137, 14)
' 
' ferode_2_48(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_48")> _
Friend Shared Function ferode_2_48(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (138, 14)
' 
' fdilate_2_49(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_49")> _
Friend Shared Function fdilate_2_49(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (139, 14)
' 
' ferode_2_49(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_49")> _
Friend Shared Function ferode_2_49(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (140, 14)
' 
' fdilate_2_50(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_50")> _
Friend Shared Function fdilate_2_50(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (141, 14)
' 
' ferode_2_50(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_50")> _
Friend Shared Function ferode_2_50(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (142, 14)
' 
' fdilate_2_51(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_51")> _
Friend Shared Function fdilate_2_51(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (143, 14)
' 
' ferode_2_51(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_51")> _
Friend Shared Function ferode_2_51(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (144, 14)
' 
' fdilate_2_52(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_52")> _
Friend Shared Function fdilate_2_52(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (145, 14)
' 
' ferode_2_52(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_52")> _
Friend Shared Function ferode_2_52(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (146, 14)
' 
' fdilate_2_53(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_53")> _
Friend Shared Function fdilate_2_53(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (147, 14)
' 
' ferode_2_53(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_53")> _
Friend Shared Function ferode_2_53(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (148, 14)
' 
' fdilate_2_54(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_54")> _
Friend Shared Function fdilate_2_54(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (149, 14)
' 
' ferode_2_54(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_54")> _
Friend Shared Function ferode_2_54(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (150, 14)
' 
' fdilate_2_55(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_55")> _
Friend Shared Function fdilate_2_55(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (151, 14)
' 
' ferode_2_55(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_55")> _
Friend Shared Function ferode_2_55(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (152, 14)
' 
' fdilate_2_56(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_56")> _
Friend Shared Function fdilate_2_56(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (153, 14)
' 
' ferode_2_56(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_56")> _
Friend Shared Function ferode_2_56(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (154, 14)
' 
' fdilate_2_57(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_57")> _
Friend Shared Function fdilate_2_57(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (155, 14)
' 
' ferode_2_57(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_57")> _
Friend Shared Function ferode_2_57(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (156, 14)
' 
' fdilate_2_58(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_58")> _
Friend Shared Function fdilate_2_58(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (157, 14)
' 
' ferode_2_58(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_58")> _
Friend Shared Function ferode_2_58(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (158, 14)
' 
' fdilate_2_59(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_59")> _
Friend Shared Function fdilate_2_59(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (159, 14)
' 
' ferode_2_59(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_59")> _
Friend Shared Function ferode_2_59(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (160, 14)
' 
' fdilate_2_60(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_60")> _
Friend Shared Function fdilate_2_60(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (161, 14)
' 
' ferode_2_60(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_60")> _
Friend Shared Function ferode_2_60(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (162, 14)
' 
' fdilate_2_61(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_61")> _
Friend Shared Function fdilate_2_61(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (163, 14)
' 
' ferode_2_61(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_61")> _
Friend Shared Function ferode_2_61(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (164, 14)
' 
' fdilate_2_62(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_62")> _
Friend Shared Function fdilate_2_62(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (165, 14)
' 
' ferode_2_62(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_62")> _
Friend Shared Function ferode_2_62(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (166, 14)
' 
' fdilate_2_63(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_63")> _
Friend Shared Function fdilate_2_63(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (167, 14)
' 
' ferode_2_63(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_63")> _
Friend Shared Function ferode_2_63(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (168, 14)
' 
' fdilate_2_64(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_64")> _
Friend Shared Function fdilate_2_64(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (169, 14)
' 
' ferode_2_64(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_64")> _
Friend Shared Function ferode_2_64(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (170, 14)
' 
' fdilate_2_65(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_65")> _
Friend Shared Function fdilate_2_65(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (171, 14)
' 
' ferode_2_65(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_65")> _
Friend Shared Function ferode_2_65(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (172, 14)
' 
' fdilate_2_66(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_66")> _
Friend Shared Function fdilate_2_66(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (173, 14)
' 
' ferode_2_66(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_66")> _
Friend Shared Function ferode_2_66(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (174, 14)
' 
' fdilate_2_67(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_67")> _
Friend Shared Function fdilate_2_67(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (175, 14)
' 
' ferode_2_67(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_67")> _
Friend Shared Function ferode_2_67(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (176, 14)
' 
' fdilate_2_68(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_68")> _
Friend Shared Function fdilate_2_68(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (177, 14)
' 
' ferode_2_68(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_68")> _
Friend Shared Function ferode_2_68(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (178, 14)
' 
' fdilate_2_69(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_69")> _
Friend Shared Function fdilate_2_69(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (179, 14)
' 
' ferode_2_69(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_69")> _
Friend Shared Function ferode_2_69(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (180, 14)
' 
' fdilate_2_70(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_70")> _
Friend Shared Function fdilate_2_70(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (181, 14)
' 
' ferode_2_70(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_70")> _
Friend Shared Function ferode_2_70(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (182, 14)
' 
' fdilate_2_71(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_71")> _
Friend Shared Function fdilate_2_71(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (183, 14)
' 
' ferode_2_71(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_71")> _
Friend Shared Function ferode_2_71(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (184, 14)
' 
' fdilate_2_72(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_72")> _
Friend Shared Function fdilate_2_72(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (185, 14)
' 
' ferode_2_72(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_72")> _
Friend Shared Function ferode_2_72(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (186, 14)
' 
' fdilate_2_73(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_73")> _
Friend Shared Function fdilate_2_73(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (187, 14)
' 
' ferode_2_73(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_73")> _
Friend Shared Function ferode_2_73(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (188, 14)
' 
' fdilate_2_74(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_74")> _
Friend Shared Function fdilate_2_74(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (189, 14)
' 
' ferode_2_74(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_74")> _
Friend Shared Function ferode_2_74(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (190, 14)
' 
' fdilate_2_75(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_2_75")> _
Friend Shared Function fdilate_2_75(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\dwacomblow.2.c (191, 14)
' 
' ferode_2_75(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_2_75")> _
Friend Shared Function ferode_2_75(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

#End Region
#Region "SRC\edge.c"
' SRC\edge.c (91, 1)
' pixSobelEdgeFilter()
' pixSobelEdgeFilter(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Invert pixd to see larger gradients as darker (grayscale).
'''  *   (2) To generate a binary image of the edges, threshold
'''  * the result using pixThresholdToBinary().  If the high
'''  * edge values are to be fg (1), invert after running
'''  * pixThresholdToBinary().
'''  *   (3) Label the pixels as follows:
'''  *  1 4 7
'''  *  2 5 8
'''  *  3 6 9
'''  * Read the data incrementally across the image and unroll
'''  * the loop.
'''  *   (4) This runs at about 45 Mpix/sec on a 3 GHz processor.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, edges are brighter, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp; no colormap</param>
''' <param name="orientflag"> \param[in]    orientflag L_HORIZONTAL_EDGES, L_VERTICAL_EDGES, L_ALL_EDGES</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSobelEdgeFilter")> _
Friend Shared Function pixSobelEdgeFilter(pixs as IntPTR, orientflag as Integer) as IntPTR
End Function

' SRC\edge.c (199, 1)
' pixTwoSidedEdgeFilter()
' pixTwoSidedEdgeFilter(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For detecting vertical edges, this considers the
'''  * difference of the central pixel from those on the left
'''  * and right.  For situations where the gradient is the same
'''  * sign on both sides, this computes and stores the minimum
'''  * (absolute value of the) difference.  The reason for
'''  * checking the sign is that we are looking for pixels within
'''  * a transition.  By contrast, for single pixel noise, the pixel
'''  * value is either larger than or smaller than its neighbors,
'''  * so the gradient would change direction on each side.  Horizontal
'''  * edges are handled similarly, looking for vertical gradients.
'''  *   (2) To generate a binary image of the edges, threshold
'''  * the result using pixThresholdToBinary().  If the high
'''  * edge values are to be fg (1), invert after running
'''  * pixThresholdToBinary().
'''  *   (3) This runs at about 60 Mpix/sec on a 3 GHz processor.
'''  * It is about 30% faster than Sobel, and the results are
'''  * similar.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, edges are brighter, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp; no colormap</param>
''' <param name="orientflag"> \param[in]    orientflag L_HORIZONTAL_EDGES, L_VERTICAL_EDGES</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTwoSidedEdgeFilter")> _
Friend Shared Function pixTwoSidedEdgeFilter(pixs as IntPTR, orientflag as Integer) as IntPTR
End Function

' SRC\edge.c (309, 1)
' pixMeasureEdgeSmoothness()
' pixMeasureEdgeSmoothness(PIX *, l_int32, l_int32, l_int32, l_float32 *, l_float32 *, l_float32 *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This computes three measures of smoothness of the edge of a
'''  * connected component:
'''  *   * jumps/length: (jpl) the number of jumps of size >= %minjump,
'''  *  normalized to the length of the side
'''  *   * jump sum/length: (jspl) the sum of all jump lengths of
'''  *  size >= %minjump, normalized to the length of the side
'''  *   * reversals/length: (rpl) the number of peak --> valley
'''  *  reversals, using %minreverse as a minimum deviation of
'''  *  the peak or valley from its preceding extremum,
'''  *  normalized to the length of the side
'''  *   (2) The input pix should be a single connected component, but
'''  * this is not required.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="side"> \param[in]    side L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
''' <param name="minjump"> \param[in]    minjump minimum jump to be counted; >= 1</param>
''' <param name="minreversal"> \param[in]    minreversal minimum reversal size for new peak or valley</param>
''' <param name="pjpl"> \param[out]   pjpl [optional] jumps/length: number of jumps,</param>
''' <param name="pjspl"> \param[out]   pjspl [optional] jumpsum/length: sum of all</param>
''' <param name="prpl"> \param[out]   prpl [optional] reversals/length: number of</param>
''' <param name="debugfile"> \param[in]    debugfile [optional] displays constructed edge; use NULL</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMeasureEdgeSmoothness")> _
Friend Shared Function pixMeasureEdgeSmoothness(pixs as IntPTR, side as Integer, minjump as Integer, minreversal as Integer, pjpl as single, pjspl as single, prpl as single, debugfile as String) as Integer
End Function

' SRC\edge.c (386, 1)
' pixGetEdgeProfile()
' pixGetEdgeProfile(PIX *, l_int32, const char *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of fg edge pixel locations, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="side"> \param[in]    side L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
''' <param name="debugfile"> \param[in]    debugfile [optional] displays constructed edge; use NULL</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetEdgeProfile")> _
Friend Shared Function pixGetEdgeProfile(pixs as IntPTR, side as Integer, debugfile as String) as IntPTR
End Function

' SRC\edge.c (515, 1)
' 
' pixGetLastOffPixelInRun(PIX *, l_int32, l_int32, l_int32, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetLastOffPixelInRun")> _
Friend Shared Function pixGetLastOffPixelInRun(pixs as IntPTR, x as Integer, y as Integer, direction as Integer, ploc as Integer) as Integer
End Function

' SRC\edge.c (587, 1)
' 
' pixGetLastOnPixelInRun(PIX *, l_int32, l_int32, l_int32, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetLastOnPixelInRun")> _
Friend Shared Function pixGetLastOnPixelInRun(pixs as IntPTR, x as Integer, y as Integer, direction as Integer, ploc as Integer) as Integer
End Function

#End Region
#Region "SRC\encoding.c"
' SRC\encoding.c (63, 16)
' isBase64()
' isBase64(char) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="isBase64")> _
Friend Shared Function isBase64(Parameter_1 as Object) as Integer
End Function

' SRC\encoding.c (64, 17)
' genReverseTab64()
' genReverseTab64() as l_int32 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="genReverseTab64")> _
Friend Shared Function genReverseTab64() as String
End Function

' SRC\encoding.c (65, 13)
' byteConvert3to4()
' byteConvert3to4(l_uint8 *, l_uint8 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="byteConvert3to4")> _
Friend Shared Function byteConvert3to4(in3 as Byte, out4 as Byte) as Boolean ' Org. Void
End Function

' SRC\encoding.c (66, 13)
' byteConvert4to3()
' byteConvert4to3(l_uint8 *, l_uint8 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="byteConvert4to3")> _
Friend Shared Function byteConvert4to3(in4 as Byte, out3 as Byte) as Boolean ' Org. Void
End Function

' SRC\encoding.c (76, 16)
' convertChunkToAscii85()
' convertChunkToAscii85(l_uint8 *, l_int32, l_int32 *, char *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Attempts to read 4 bytes and write 5.
'''  *   (2) Writes 1 byte if the value is 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boolean for eof 0 if more data, 1 if end of file</returns>
''' <param name="inarray"> \param[in]    inarray input data</param>
''' <param name="insize"> \param[in]    insize  number of bytes in input array</param>
''' <param name="pindex"> \param[out]   pindex use and -- ptr</param>
''' <param name="outbuf"> \param[in]    outbuf holds 8 ascii chars; we use no more than 7</param>
''' <param name="pnbout"> \param[out]   pnbsout number of bytes written to outbuf</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertChunkToAscii85")> _
Friend Shared Function convertChunkToAscii85(inarray as Byte, insize as Integer, pindex as Integer, outbuf as Object, pnbout as Integer) as Integer
End Function

' SRC\encoding.c (100, 1)
' encodeBase64()
' encodeBase64(l_uint8 *, l_int32, l_int32 *) as char *
''' <summary>
''' * Notes:
'''  *   (1) The input character data is unrestricted binary.
'''  * The output encoded data consists of the 64 characters
'''  * in the base64 set, plus newlines and the pad character '='.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  chara with MAX_BASE64_LINE characters + \n in each line</returns>
''' <param name="inarray"> \param[in]    inarray input binary data</param>
''' <param name="insize"> \param[in]    insize number of bytes in input array</param>
''' <param name="poutsize"> \param[out]   poutsize number of bytes in output char array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="encodeBase64")> _
Friend Shared Function encodeBase64(inarray as Byte, insize as Integer, poutsize as Integer) as String
End Function

' SRC\encoding.c (188, 1)
' decodeBase64()
' decodeBase64(const char *, l_int32, l_int32 *) as l_uint8 *
''' <summary>
''' * Notes:
'''  *   (1) The input character data should have only 66 different characters:
'''  * The 64 character set for base64 encoding, plus the pad
'''  * character '=' and newlines for formatting with fixed line
'''  * lengths.  If there are any other characters, the decoder
'''  * will declare the input data to be invalid and return NULL.
'''  *   (2) The decoder ignores newlines and, for a valid input string,
'''  * stops reading input when a pad byte is found.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  bytea decoded byte data, or NULL on error</returns>
''' <param name="inarray"> \param[in]    inarray input encoded char data, with 72 chars/line)</param>
''' <param name="insize"> \param[in]    insize number of bytes in input array</param>
''' <param name="poutsize"> \param[out]   poutsize number of bytes in output byte array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="decodeBase64")> _
Friend Shared Function decodeBase64(inarray as String, insize as Integer, poutsize as Integer) as String
End Function

' SRC\encoding.c (339, 1)
' encodeAscii85()
' encodeAscii85(l_uint8 *, l_int32, l_int32 *) as char *
''' <summary>
''' * Notes:
'''  *   (1) Ghostscript has a stack break if the last line of
'''  * data only has a '>', so we avoid the problem by
'''  * always putting '~>' on the last line.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  chara with 64 characters + \n in each line</returns>
''' <param name="inarray"> \param[in]    inarray input data</param>
''' <param name="insize"> \param[in]    insize number of bytes in input array</param>
''' <param name="poutsize"> \param[out]   poutsize number of bytes in output char array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="encodeAscii85")> _
Friend Shared Function encodeAscii85(inarray as Byte, insize as Integer, poutsize as Integer) as String
End Function

' SRC\encoding.c (473, 1)
' decodeAscii85()
' decodeAscii85(char *, l_int32, l_int32 *) as l_uint8 *
''' <summary>
''' * Notes:
'''  *   (1) We assume the data is properly encoded, so we do not check
'''  * for invalid characters or the final '>' character.
'''  *   (2) We permit whitespace to be added to the encoding in an
'''  * arbitrary way.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  outarray binary</returns>
''' <param name="inarray"> \param[in]    inarray ascii85 input data</param>
''' <param name="insize"> \param[in]    insize number of bytes in input array</param>
''' <param name="poutsize"> \param[out]   poutsize number of bytes in output l_uint8 array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="decodeAscii85")> _
Friend Shared Function decodeAscii85(inarray as Object, insize as Integer, poutsize as Integer) as String
End Function

' SRC\encoding.c (587, 1)
' reformatPacked64()
' reformatPacked64(char *, l_int32, l_int32, l_int32, l_int32, l_int32 *) as char *
''' <summary>
''' * Notes:
'''  *   (1) Each line in the output array has %leadspace space characters,
'''  * followed optionally by a double-quote, followed by %linechars
'''  * bytes of base64 data, followed optionally by a double-quote,
'''  * followed by a newline.
'''  *   (2) This can be used to convert a base64 encoded string to a
'''  * string formatted for inclusion in a C source file.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  outarray ascii</returns>
''' <param name="inarray"> \param[in]    inarray base64 encoded string with newlines</param>
''' <param name="insize"> \param[in]    insize number of bytes in input array</param>
''' <param name="leadspace"> \param[in]    leadspace number of spaces in each line before the data</param>
''' <param name="linechars"> \param[in]    linechars number of bytes of data in each line; multiple of 4</param>
''' <param name="addquotes"> \param[in]    addquotes 1 to add quotes to each line of data; 0 to skip</param>
''' <param name="poutsize"> \param[out]   poutsize number of bytes in output char array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="reformatPacked64")> _
Friend Shared Function reformatPacked64(inarray as Object, insize as Integer, leadspace as Integer, linechars as Integer, addquotes as Integer, poutsize as Integer) as String
End Function

#End Region
#Region "SRC\enhance.c"
' SRC\enhance.c (174, 1)
' pixGammaTRC()
' pixGammaTRC(PIX *, PIX *, l_float32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pixd must either be null or equal to pixs.
'''  * For in-place operation, set pixd == pixs:
'''  * pixGammaTRC(pixs, pixs, ...);
'''  * To get a new image, set pixd == null:
'''  * pixd = pixGammaTRC(NULL, pixs, ...);
'''  *   (2) If pixs is colormapped, the colormap is transformed,
'''  * either in-place or in a copy of pixs.
'''  *   (3) We use a gamma mapping between minval and maxval.
'''  *   (4) If gamma  1.0, the image will appear darker;
'''  * if gamma > 1.0, the image will appear lighter;
'''  *   (5) If gamma = 1.0 and minval = 0 and maxval = 255, no
'''  * enhancement is performed; return a copy unless in-place,
'''  * in which case this is a no-op.
'''  *   (6) For color images that are not colormapped, the mapping
'''  * is applied to each component.
'''  *   (7) minval and maxval are not restricted to the interval [0, 255].
'''  * If minval  0, an input value of 0 is mapped to a
'''  * nonzero output.  This will turn black to gray.
'''  * If maxval > 255, an input value of 255 is mapped to
'''  * an output value less than 255.  This will turn
'''  * white (e.g., in the background) to gray.
'''  *   (8) Increasing minval darkens the image.
'''  *   (9) Decreasing maxval bleaches the image.
'''  *   (10) Simultaneously increasing minval and decreasing maxval
'''  *  will darken the image and make the colors more intense;
'''  *  e.g., minval = 50, maxval = 200.
'''  *   (11) See numaGammaTRC() for further examples of use.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd     [optional] null or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs     8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
''' <param name="gamma"> \param[in]    gamma    gamma correction; must be > 0.0</param>
''' <param name="minval"> \param[in]    minval   input value that gives 0 for output; can be < 0</param>
''' <param name="maxval"> \param[in]    maxval   input value that gives 255 for output; can be > 255</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGammaTRC")> _
Friend Shared Function pixGammaTRC(pixd as IntPTR, pixs as IntPTR, gamma as single, minval as Integer, maxval as Integer) as IntPTR
End Function

' SRC\enhance.c (242, 1)
' pixGammaTRCMasked()
' pixGammaTRCMasked(PIX *, PIX *, PIX *, l_float32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Same as pixGammaTRC() except mapping is optionally over
'''  * a subset of pixels described by pixm.
'''  *   (2) Masking does not work for colormapped images.
'''  *   (3) See pixGammaTRC() for details on how to use the parameters.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd      [optional] null or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs      8 or 32 bpp; not colormapped</param>
''' <param name="pixm"> \param[in]    pixm      [optional] null or 1 bpp</param>
''' <param name="gamma"> \param[in]    gamma     gamma correction; must be > 0.0</param>
''' <param name="minval"> \param[in]    minval    input value that gives 0 for output; can be < 0</param>
''' <param name="maxval"> \param[in]    maxval    input value that gives 255 for output; can be > 255</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGammaTRCMasked")> _
Friend Shared Function pixGammaTRCMasked(pixd as IntPTR, pixs as IntPTR, pixm as IntPTR, gamma as single, minval as Integer, maxval as Integer) as IntPTR
End Function

' SRC\enhance.c (306, 1)
' pixGammaTRCWithAlpha()
' pixGammaTRCWithAlpha(PIX *, PIX *, l_float32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See usage notes in pixGammaTRC().
'''  *   (2) This version saves the alpha channel.  It is only valid
'''  * for 32 bpp (no colormap), and is a bit slower.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd     [optional] null or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs     32 bpp</param>
''' <param name="gamma"> \param[in]    gamma    gamma correction; must be > 0.0</param>
''' <param name="minval"> \param[in]    minval   input value that gives 0 for output; can be < 0</param>
''' <param name="maxval"> \param[in]    maxval   input value that gives 255 for output; can be > 255</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGammaTRCWithAlpha")> _
Friend Shared Function pixGammaTRCWithAlpha(pixd as IntPTR, pixs as IntPTR, gamma as single, minval as Integer, maxval as Integer) as IntPTR
End Function

' SRC\enhance.c (366, 1)
' numaGammaTRC()
' numaGammaTRC(l_float32, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The map is returned as a numa; values are clipped to [0, 255].
'''  *   (2) To force all intensities into a range within fraction delta
'''  * of white, use: minval = -256 * (1 - delta) / delta
'''  *    maxval = 255
'''  *   (3) To force all intensities into a range within fraction delta
'''  * of black, use: minval = 0
'''  *    maxval = 256 * (1 - delta) / delta
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na, or NULL on error</returns>
''' <param name="gamma"> \param[in]    gamma   gamma factor; must be > 0.0</param>
''' <param name="minval"> \param[in]    minval  input value that gives 0 for output</param>
''' <param name="maxval"> \param[in]    maxval  input value that gives 255 for output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGammaTRC")> _
Friend Shared Function numaGammaTRC(gamma as single, minval as Integer, maxval as Integer) as IntPTR
End Function

' SRC\enhance.c (436, 1)
' pixContrastTRC()
' pixContrastTRC(PIX *, PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pixd must either be null or equal to pixs.
'''  * For in-place operation, set pixd == pixs:
'''  * pixContrastTRC(pixs, pixs, ...);
'''  * To get a new image, set pixd == null:
'''  * pixd = pixContrastTRC(NULL, pixs, ...);
'''  *   (2) If pixs is colormapped, the colormap is transformed,
'''  * either in-place or in a copy of pixs.
'''  *   (3) Contrast is enhanced by mapping each color component
'''  * using an atan function with maximum slope at 127.
'''  * Pixels below 127 are lowered in intensity and pixels
'''  * above 127 are increased.
'''  *   (4) The useful range for the contrast factor is scaled to
'''  * be in (0.0 to 1.0), but larger values can also be used.
'''  *   (5) If factor == 0.0, no enhancement is performed; return a copy
'''  * unless in-place, in which case this is a no-op.
'''  *   (6) For color images that are not colormapped, the mapping
'''  * is applied to each component.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd     [optional] null or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs     8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
''' <param name="factor"> \param[in]    factor   0.0 is no enhancement</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixContrastTRC")> _
Friend Shared Function pixContrastTRC(pixd as IntPTR, pixs as IntPTR, factor as single) as IntPTR
End Function

' SRC\enhance.c (498, 1)
' pixContrastTRCMasked()
' pixContrastTRCMasked(PIX *, PIX *, PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Same as pixContrastTRC() except mapping is optionally over
'''  * a subset of pixels described by pixm.
'''  *   (2) Masking does not work for colormapped images.
'''  *   (3) See pixContrastTRC() for details on how to use the parameters.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd     [optional] null or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs     8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
''' <param name="pixm"> \param[in]    pixm     [optional] null or 1 bpp</param>
''' <param name="factor"> \param[in]    factor   0.0 is no enhancement</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixContrastTRCMasked")> _
Friend Shared Function pixContrastTRCMasked(pixd as IntPTR, pixs as IntPTR, pixm as IntPTR, factor as single) as IntPTR
End Function

' SRC\enhance.c (557, 1)
' numaContrastTRC()
' numaContrastTRC(l_float32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The mapping is monotonic increasing, where 0 is mapped
'''  * to 0 and 255 is mapped to 255.
'''  *   (2) As 'factor' is increased from 0.0 (where the mapping is linear),
'''  * the map gets closer to its limit as a step function that
'''  * jumps from 0 to 255 at the center (input value = 127).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na, or NULL on error</returns>
''' <param name="factor"> \param[in]    factor   generally between 0.0 [no enhancement]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaContrastTRC")> _
Friend Shared Function numaContrastTRC(factor as single) as IntPTR
End Function

' SRC\enhance.c (627, 1)
' pixEqualizeTRC()
' pixEqualizeTRC(PIX *, PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pixd must either be null or equal to pixs.
'''  * For in-place operation, set pixd == pixs:
'''  * pixEqualizeTRC(pixs, pixs, ...);
'''  * To get a new image, set pixd == null:
'''  * pixd = pixEqualizeTRC(NULL, pixs, ...);
'''  *   (2) In histogram equalization, a tone reproduction curve
'''  * mapping is used to make the number of pixels at each
'''  * intensity equal.
'''  *   (3) If fract == 0.0, no equalization is performed; return a copy
'''  * unless in-place, in which case this is a no-op.
'''  * If fract == 1.0, equalization is complete.
'''  *   (4) Set the subsampling factor > 1 to reduce the amount of computation.
'''  *   (5) If pixs is colormapped, the colormap is removed and
'''  * converted to rgb or grayscale.
'''  *   (6) If pixs has color, equalization is done in each channel
'''  * separately.
'''  *   (7) Note that even if there is a colormap, we can get an
'''  * in-place operation because the intermediate image pixt
'''  * is copied back to pixs (which for in-place is the same
'''  * as pixd).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd     [optional] null or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs     8 bpp gray, 32 bpp rgb, or colormapped</param>
''' <param name="fract"> \param[in]    fract    fraction of equalization movement of pixel values</param>
''' <param name="factor"> \param[in]    factor   subsampling factor; integer >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixEqualizeTRC")> _
Friend Shared Function pixEqualizeTRC(pixd as IntPTR, pixs as IntPTR, fract as single, factor as Integer) as IntPTR
End Function

' SRC\enhance.c (714, 1)
' numaEqualizeTRC()
' numaEqualizeTRC(PIX *, l_float32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) If fract == 0.0, no equalization will be performed.
'''  * If fract == 1.0, equalization is complete.
'''  *   (2) Set the subsampling factor > 1 to reduce the amount of computation.
'''  *   (3) The map is returned as a numa with 256 values, specifying
'''  * the equalized value (array value) for every input value
'''  * (the array index).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix     8 bpp, no colormap</param>
''' <param name="fract"> \param[in]    fract   fraction of equalization movement of pixel values</param>
''' <param name="factor"> \param[in]    factor  subsampling factor; integer >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaEqualizeTRC")> _
Friend Shared Function numaEqualizeTRC(pix as IntPTR, fract as single, factor as Integer) as IntPTR
End Function

' SRC\enhance.c (781, 1)
' pixTRCMap()
' pixTRCMap(PIX *, PIX *, NUMA *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This operation is in-place on pixs.
'''  *   (2) For 32 bpp, this applies the same map to each of the r,g,b
'''  * components.
'''  *   (3) The mapping array is of size 256, and it maps the input
'''  * index into values in the range [0, 255].
'''  *   (4) If defined, the optional 1 bpp mask pixm has its origin
'''  * aligned with pixs, and the map function is applied only
'''  * to pixels in pixs under the fg of pixm.
'''  *   (5) For 32 bpp, this does not save the alpha channel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    8 grayscale or 32 bpp rgb; not colormapped</param>
''' <param name="pixm"> \param[in]    pixm    [optional] 1 bpp mask</param>
''' <param name="na"> \param[in]    na      mapping array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTRCMap")> _
Friend Shared Function pixTRCMap(pixs as IntPTR, pixm as IntPTR, na as IntPTR) as Integer
End Function

' SRC\enhance.c (904, 1)
' pixUnsharpMasking()
' pixUnsharpMasking(PIX *, l_int32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) We use symmetric smoothing filters of odd dimension,
'''  * typically use sizes of 3, 5, 7, etc.  The %halfwidth parameter
'''  * for these is (size - 1)/2; i.e., 1, 2, 3, etc.
'''  *   (2) The fract parameter is typically taken in the
'''  * range:  0.2  fract  0.7
'''  *   (3) Returns a clone if no sharpening is requested.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs       all depths except 1 bpp; with or without colormaps</param>
''' <param name="halfwidth"> \param[in]    halfwidth  "half-width" of smoothing filter</param>
''' <param name="fract"> \param[in]    fract      fraction of edge added back into image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixUnsharpMasking")> _
Friend Shared Function pixUnsharpMasking(pixs as IntPTR, halfwidth as Integer, fract as single) as IntPTR
End Function

' SRC\enhance.c (973, 1)
' pixUnsharpMaskingGray()
' pixUnsharpMaskingGray(PIX *, l_int32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) We use symmetric smoothing filters of odd dimension,
'''  * typically use sizes of 3, 5, 7, etc.  The %halfwidth parameter
'''  * for these is (size - 1)/2; i.e., 1, 2, 3, etc.
'''  *   (2) The fract parameter is typically taken in the range:
'''  * 0.2  fract  0.7
'''  *   (3) Returns a clone if no sharpening is requested.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs       8 bpp; no colormap</param>
''' <param name="halfwidth"> \param[in]    halfwidth  "half-width" of smoothing filter</param>
''' <param name="fract"> \param[in]    fract      fraction of edge added back into image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixUnsharpMaskingGray")> _
Friend Shared Function pixUnsharpMaskingGray(pixs as IntPTR, halfwidth as Integer, fract as single) as IntPTR
End Function

' SRC\enhance.c (1070, 1)
' pixUnsharpMaskingFast()
' pixUnsharpMaskingFast(PIX *, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The fast version uses separable 1-D filters directly on
'''  * the input image.  The halfwidth is either 1 (full width = 3)
'''  * or 2 (full width = 5).
'''  *   (2) The fract parameter is typically taken in the
'''  *   range:  0.2  fract  0.7
'''  *   (3) To skip horizontal sharpening, use %fracth = 0.0; ditto for %fractv
'''  *   (4) For one dimensional filtering (as an example):
'''  * For %halfwidth = 1, the low-pass filter is
'''  *  L: 1/3 1/3   1/3
'''  * and the high-pass filter is
'''  *  H = I - L:   -1/3   2/3   -1/3
'''  * For %halfwidth = 2, the low-pass filter is
'''  *  L: 1/5 1/5   1/5 1/5 1/5
'''  * and the high-pass filter is
'''  *  H = I - L:   -1/5  -1/5   4/5  -1/5   -1/5
'''  * The new sharpened pixel value is found by adding some fraction
'''  * of the high-pass filter value (which sums to 0) to the
'''  * initial pixel value:
'''  *  N = I + fract * H
'''  *   (5) For 2D, the sharpening filter is not separable, because the
'''  * vertical filter depends on the horizontal location relative
'''  * to the filter origin, and v.v.   So we either do the full
'''  * 2D filter (for %halfwidth == 1) or do the low-pass
'''  * convolution separably and then compose with the original pix.
'''  *   (6) Returns a clone if no sharpening is requested.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs       all depths except 1 bpp; with or without colormaps</param>
''' <param name="halfwidth"> \param[in]    halfwidth  "half-width" of smoothing filter; 1 and 2 only</param>
''' <param name="fract"> \param[in]    fract      fraction of high frequency added to image</param>
''' <param name="direction"> \param[in]    direction  L_HORIZ, L_VERT, L_BOTH_DIRECTIONS</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixUnsharpMaskingFast")> _
Friend Shared Function pixUnsharpMaskingFast(pixs as IntPTR, halfwidth as Integer, fract as single, direction as Integer) as IntPTR
End Function

' SRC\enhance.c (1141, 1)
' pixUnsharpMaskingGrayFast()
' pixUnsharpMaskingGrayFast(PIX *, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For usage and explanation of the algorithm, see notes
'''  * in pixUnsharpMaskingFast().
'''  *   (2) Returns a clone if no sharpening is requested.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs       8 bpp; no colormap</param>
''' <param name="halfwidth"> \param[in]    halfwidth  "half-width" of smoothing filter: 1 or 2</param>
''' <param name="fract"> \param[in]    fract      fraction of high frequency added to image</param>
''' <param name="direction"> \param[in]    direction  L_HORIZ, L_VERT, L_BOTH_DIRECTIONS</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixUnsharpMaskingGrayFast")> _
Friend Shared Function pixUnsharpMaskingGrayFast(pixs as IntPTR, halfwidth as Integer, fract as single, direction as Integer) as IntPTR
End Function

' SRC\enhance.c (1190, 1)
' pixUnsharpMaskingGray1D()
' pixUnsharpMaskingGray1D(PIX *, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For usage and explanation of the algorithm, see notes
'''  * in pixUnsharpMaskingFast().
'''  *   (2) Returns a clone if no sharpening is requested.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs        8 bpp; no colormap</param>
''' <param name="halfwidth"> \param[in]    halfwidth   "half-width" of smoothing filter: 1 or 2</param>
''' <param name="fract"> \param[in]    fract       fraction of high frequency added to image</param>
''' <param name="direction"> \param[in]    direction   filtering direction; use L_HORIZ or L_VERT</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixUnsharpMaskingGray1D")> _
Friend Shared Function pixUnsharpMaskingGray1D(pixs as IntPTR, halfwidth as Integer, fract as single, direction as Integer) as IntPTR
End Function

' SRC\enhance.c (1324, 1)
' pixUnsharpMaskingGray2D()
' pixUnsharpMaskingGray2D(PIX *, l_int32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is for %halfwidth == 1, 2.
'''  *   (2) The lowpass filter is implemented separably.
'''  *   (3) Returns a clone if no sharpening is requested.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs       8 bpp; no colormap</param>
''' <param name="halfwidth"> \param[in]    halfwidth  "half-width" of smoothing filter: 1 or 2</param>
''' <param name="fract"> \param[in]    fract      fraction of high frequency added to image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixUnsharpMaskingGray2D")> _
Friend Shared Function pixUnsharpMaskingGray2D(pixs as IntPTR, halfwidth as Integer, fract as single) as IntPTR
End Function

' SRC\enhance.c (1469, 1)
' pixModifyHue()
' pixModifyHue(PIX *, PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pixd must either be null or equal to pixs.
'''  * For in-place operation, set pixd == pixs:
'''  * pixEqualizeTRC(pixs, pixs, ...);
'''  * To get a new image, set pixd == null:
'''  * pixd = pixEqualizeTRC(NULL, pixs, ...);
'''  *   (1) Use fract > 0.0 to increase hue value;  0.0 to decrease it.
'''  * 1.0 (or -1.0) represents a 360 degree rotation; i.e., no change.
'''  *   (2) If no modification is requested (fract = -1.0 or 0 or 1.0),
'''  * return a copy unless in-place, in which case this is a no-op.
'''  *   (3) See discussion of color-modification methods, in coloring.c.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd      [optional] can be null or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs      32 bpp rgb</param>
''' <param name="fract"> \param[in]    fract     between -1.0 and 1.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixModifyHue")> _
Friend Shared Function pixModifyHue(pixd as IntPTR, pixs as IntPTR, fract as single) as IntPTR
End Function

' SRC\enhance.c (1542, 1)
' pixModifySaturation()
' pixModifySaturation(PIX *, PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If fract > 0.0, it gives the fraction that the pixel
'''  * saturation is moved from its initial value toward 255.
'''  * If fract  0.0, it gives the fraction that the pixel
'''  * saturation is moved from its initial value toward 0.
'''  * The limiting values for fract = -1.0 (1.0) thus set the
'''  * saturation to 0 (255).
'''  *   (2) If fract = 0, no modification is requested; return a copy
'''  * unless in-place, in which case this is a no-op.
'''  *   (3) See discussion of color-modification methods, in coloring.c.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd     [optional] can be null, existing or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs     32 bpp rgb</param>
''' <param name="fract"> \param[in]    fract    between -1.0 and 1.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixModifySaturation")> _
Friend Shared Function pixModifySaturation(pixd as IntPTR, pixs as IntPTR, fract as single) as IntPTR
End Function

' SRC\enhance.c (1597, 1)
' pixMeasureSaturation()
' pixMeasureSaturation(PIX *, l_int32, l_float32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     32 bpp rgb</param>
''' <param name="factor"> \param[in]    factor   subsampling factor; integer >= 1</param>
''' <param name="psat"> \param[out]   psat     average saturation</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMeasureSaturation")> _
Friend Shared Function pixMeasureSaturation(pixs as IntPTR, factor as Integer, psat as single) as Integer
End Function

' SRC\enhance.c (1658, 1)
' pixModifyBrightness()
' pixModifyBrightness(PIX *, PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If fract > 0.0, it gives the fraction that the v-parameter,
'''  * which is max(r,g,b), is moved from its initial value toward 255.
'''  * If fract  0.0, it gives the fraction that the v-parameter
'''  * is moved from its initial value toward 0.
'''  * The limiting values for fract = -1.0 (1.0) thus set the
'''  * v-parameter to 0 (255).
'''  *   (2) If fract = 0, no modification is requested; return a copy
'''  * unless in-place, in which case this is a no-op.
'''  *   (3) See discussion of color-modification methods, in coloring.c.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd     [optional] can be null, existing or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs     32 bpp rgb</param>
''' <param name="fract"> \param[in]    fract    between -1.0 and 1.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixModifyBrightness")> _
Friend Shared Function pixModifyBrightness(pixd as IntPTR, pixs as IntPTR, fract as single) as IntPTR
End Function

' SRC\enhance.c (1737, 1)
' pixMosaicColorShiftRGB()
' pixMosaicColorShiftRGB(PIX *, l_float32, l_float32, l_float32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This generates a mosaic view of the effect of shifting the RGB
'''  * components.  See pixColorShiftRGB() for details on the shifting.
'''  *   (2) The offsets (%roff, %goff, %boff) set the color center point,
'''  * and the deviations from this are shown separately for deltas
'''  * in r, g and b.  For each component, we show 2 * %nincr + 1
'''  * images.
'''  *   (3) Usage: color prints differ from the original due to three factors:
'''  * illumination, calibration of the camera in acquisition,
'''  * and calibration of the printer.  This function can be used
'''  * to iteratively match a color print to the original.  On each
'''  * iteration, the center offsets are set to the best match so
'''  * far, and the %delta increments are typically reduced.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     32 bpp rgb</param>
''' <param name="roff"> \param[in]    roff   center offset of red component</param>
''' <param name="goff"> \param[in]    goff   center offset of green component</param>
''' <param name="boff"> \param[in]    boff   center offset of blue component</param>
''' <param name="delta"> \param[in]    delta  increments from center offsets [0.0 - 0.1];</param>
''' <param name="nincr"> \param[in]    nincr  number of increments in each (positive and negative)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMosaicColorShiftRGB")> _
Friend Shared Function pixMosaicColorShiftRGB(pixs as IntPTR, roff as single, goff as single, boff as single, delta as single, nincr as Integer) as IntPTR
End Function

' SRC\enhance.c (1833, 1)
' pixColorShiftRGB()
' pixColorShiftRGB(PIX *, l_float32, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This allows independent fractional shifts of the r,g and b
'''  * components.  A positive shift pushes to saturation (255);
'''  * a negative shift pushes toward 0 (black).
'''  *   (2) The effect can be imagined using a color wheel that consists
'''  * (for our purposes) of these 6 colors, separated by 60 degrees:
'''  * red, magenta, blue, cyan, green, yellow
'''  *   (3) So, for example, a negative shift of the blue component
'''  * (bfract  0) could be accompanied by positive shifts
'''  * of red and green to make an image more yellow.
'''  *   (4) Examples of limiting cases:
'''  *   rfract = 1 ==> r = 255
'''  *   rfract = -1 ==> r = 0
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     32 bpp rgb</param>
''' <param name="rfract"> \param[in]    rfract   fractional shift in red component</param>
''' <param name="gfract"> \param[in]    gfract   fractional shift in green component</param>
''' <param name="bfract"> \param[in]    bfract   fractional shift in blue component</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorShiftRGB")> _
Friend Shared Function pixColorShiftRGB(pixs as IntPTR, rfract as single, gfract as single, bfract as single) as IntPTR
End Function

' SRC\enhance.c (1930, 1)
' pixDarkenGray()
' pixDarkenGray(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This darkens gray pixels, by a fraction (sat/%satlimit), where
'''  * the sat, the saturation, is the component difference (max - min).
'''  * The pixel value is unchanged if sat >= %satlimit.  A typical
'''  * value of %satlimit might be 50; the larger the value, the
'''  * more that pixels with a smaller saturation will be darkened.
'''  *   (2) Pixels with max component >= %thresh are unchanged. This can be
'''  * used to prevent bright pixels with low saturation from being
'''  * darkened.  Setting thresh == 0 is a no-op; setting %thresh == 255
'''  * causes the darkening to be applied to all pixels.
'''  *   (3) This function is useful to enhance pixels relative to a
'''  * gray background.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd     [optional] can be null or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs      32 bpp rgb</param>
''' <param name="thresh"> \param[in]    thresh    pixels with max component >= %thresh are unchanged</param>
''' <param name="satlimit"> \param[in]    satlimit  pixels with saturation >= %satlimit are unchanged</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDarkenGray")> _
Friend Shared Function pixDarkenGray(pixd as IntPTR, pixs as IntPTR, thresh as Integer, satlimit as Integer) as IntPTR
End Function

' SRC\enhance.c (2002, 1)
' pixMultConstantColor()
' pixMultConstantColor(PIX *, l_float32, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) rfact, gfact and bfact can only have non-negative values.
'''  * They can be greater than 1.0.  All transformed component
'''  * values are clipped to the interval [0, 255].
'''  *   (2) For multiplication with a general 3x3 matrix of constants,
'''  * use pixMultMatrixColor().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd colormapped or rgb, with colors scaled, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     colormapped or rgb</param>
''' <param name="rfact"> \param[in]    rfact    red multiplicative factor</param>
''' <param name="gfact"> \param[in]    gfact    green multiplicative factor</param>
''' <param name="bfact"> \param[in]    bfact    blue multiplicative factor</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMultConstantColor")> _
Friend Shared Function pixMultConstantColor(pixs as IntPTR, rfact as single, gfact as single, bfact as single) as IntPTR
End Function

' SRC\enhance.c (2104, 1)
' pixMultMatrixColor()
' pixMultMatrixColor(PIX *, L_KERNEL *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The kernel is a data structure used mostly for floating point
'''  * convolution.  Here it is a 3x3 matrix of floats that are used
'''  * to transform the pixel values by matrix multiplication:
'''  *   nrval = a[0,0] * rval + a[0,1] * gval + a[0,2] * bval
'''  *   ngval = a[1,0] * rval + a[1,1] * gval + a[1,2] * bval
'''  *   nbval = a[2,0] * rval + a[2,1] * gval + a[2,2] * bval
'''  *   (2) The matrix can be generated in several ways.
'''  * See kernel.c for details.  Here are two of them:
'''  *   (a) kel = kernelCreate(3, 3);
'''  * kernelSetElement(kel, 0, 0, val00);
'''  * kernelSetElement(kel, 0, 1, val01);
'''  * ...
'''  *   (b) from a static string; e.g.,:
'''  * const char *kdata = " 0.6  0.3 -0.2 "
'''  *   " 0.1  1.2  0.4 "
'''  *   " -0.4 0.2  0.9 ";
'''  * kel = kernelCreateFromString(3, 3, 0, 0, kdata);
'''  *   (3) For the special case where the matrix is diagonal, it is easier
'''  * to use pixMultConstantColor().
'''  *   (4) Matrix entries can have positive and negative values, and can
'''  * be larger than 1.0.  All transformed component values
'''  * are clipped to [0, 255].
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd colormapped or rgb, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    colormapped or rgb</param>
''' <param name="kel"> \param[in]    kel     kernel 3x3 matrix of floats</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMultMatrixColor")> _
Friend Shared Function pixMultMatrixColor(pixs as IntPTR, kel as IntPTR) as IntPTR
End Function

' SRC\enhance.c (2213, 1)
' pixHalfEdgeByBandpass()
' pixHalfEdgeByBandpass(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) We use symmetric smoothing filters of odd dimension,
'''  * typically use 3, 5, 7, etc.  The smoothing parameters
'''  * for these are 1, 2, 3, etc.  The filter size is related
'''  * to the smoothing parameter by
'''  *   size = 2 * smoothing + 1
'''  *   (2) Because we take the difference of two lowpass filters,
'''  * this is actually a bandpass filter.
'''  *   (3) We allow both filters to be anisotropic.
'''  *   (4) Consider either the h or v component of the 2 filters.
'''  * Depending on whether sm1 > sm2 or sm2 > sm1, we get
'''  * different halves of the smoothed gradients (or "edges").
'''  * This difference of smoothed signals looks more like
'''  * a second derivative of a transition, which we rectify
'''  * by not allowing the signal to go below zero.  If sm1  sm2,
'''  * the sm2 transition is broader, so the difference between
'''  * sm1 and sm2 signals is positive on the upper half of
'''  * the transition.  Likewise, if sm1 > sm2, the sm1 - sm2
'''  * signal difference is positive on the lower half of
'''  * the transition.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs         8 bpp gray or 32 bpp rgb</param>
''' <param name="sm1h"> \param[in]    sm1h, sm1v   "half-widths" of smoothing filter sm1</param>
''' <param name="sm1v"> \param[in]    sm2h, sm2v   "half-widths" of smoothing filter sm2;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixHalfEdgeByBandpass")> _
Friend Shared Function pixHalfEdgeByBandpass(pixs as IntPTR, sm1h as Integer, sm1v as Integer, sm2h as Integer, sm2v as Integer) as IntPTR
End Function

#End Region
#Region "SRC\fhmtauto.c"
' SRC\fhmtauto.c (104, 15)
' makeBarrelshiftString()
' makeBarrelshiftString(l_int32, l_int32, l_int32) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeBarrelshiftString")> _
Friend Shared Function makeBarrelshiftString(delx as Integer, dely as Integer, type as Integer) as String
End Function

' SRC\fhmtauto.c (105, 17)
' sarrayMakeInnerLoopDWACode()
' sarrayMakeInnerLoopDWACode(SEL *, l_int32, l_int32) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayMakeInnerLoopDWACode")> _
Friend Shared Function sarrayMakeInnerLoopDWACode(sel as IntPTR, nhits as Integer, nmisses as Integer) as IntPTR
End Function

' SRC\fhmtauto.c (106, 17)
' sarrayMakeWplsCode()
' sarrayMakeWplsCode(SEL *) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayMakeWplsCode")> _
Friend Shared Function sarrayMakeWplsCode(sel as IntPTR) as IntPTR
End Function

' SRC\fhmtauto.c (207, 1)
' fhmtautogen()
' fhmtautogen(SELA *, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function generates all the code for implementing
'''  * dwa morphological operations using all the sels in the sela.
'''  *   (2) See fhmtautogen1() and fhmtautogen2() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="sela"> \param[in]    sela</param>
''' <param name="fileindex"> \param[in]    fileindex</param>
''' <param name="filename"> \param[in]    filename [optional]; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmtautogen")> _
Friend Shared Function fhmtautogen(sela as IntPTR, fileindex as Integer, filename as String) as Integer
End Function

' SRC\fhmtauto.c (249, 1)
' fhmtautogen1()
' fhmtautogen1(SELA *, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function uses hmttemplate1.txt to create a
'''  * top-level file that contains two functions that carry
'''  * out the hit-miss transform for any of the sels in
'''  * the input sela.
'''  *   (2) The fileindex parameter is inserted into the output
'''  * filename, as described below.
'''  *   (3) If filename == NULL, the output file is fhmtgen.[n].c,
'''  * where [n] is equal to the 'fileindex' parameter.
'''  *   (4) If filename != NULL, the output file is [filename].[n].c.
'''  *   (5) Each sel must have at least one hit.  A sel with only misses
'''  * generates code that will abort the operation if it is called.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="sela"> \param[in]    sela array</param>
''' <param name="fileindex"> \param[in]    fileindex</param>
''' <param name="filename"> \param[in]    filename [optional]; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmtautogen1")> _
Friend Shared Function fhmtautogen1(sela as IntPTR, fileindex as Integer, filename as String) as Integer
End Function

' SRC\fhmtauto.c (431, 1)
' fhmtautogen2()
' fhmtautogen2(SELA *, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function uses hmttemplate2.txt to create a
'''  * low-level file that contains the low-level functions for
'''  * implementing the hit-miss transform for every sel
'''  * in the input sela.
'''  *   (2) The fileindex parameter is inserted into the output
'''  * filename, as described below.
'''  *   (3) If filename == NULL, the output file is fhmtgenlow.[n].c,
'''  * where [n] is equal to the %fileindex parameter.
'''  *   (4) If filename != NULL, the output file is [filename]low.[n].c.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="sela"> \param[in]    sela array</param>
''' <param name="fileindex"> \param[in]    fileindex</param>
''' <param name="filename"> \param[in]    filename [optional]; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmtautogen2")> _
Friend Shared Function fhmtautogen2(sela as IntPTR, fileindex as Integer, filename as String) as Integer
End Function

#End Region
#Region "SRC\fhmtgen.1.c"
' SRC\fhmtgen.1.c (37, 6)
' pixHMTDwa_1()
' pixHMTDwa_1(PIX *, PIX *, const char *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This simply adds a 32 pixel border, calls the appropriate
'''  * pixFHMTGen_*(), and removes the border.
'''  * See notes below for that function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd usual 3 choices: null, == pixs, != pixs</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="selname"> \param[in]    sel name</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixHMTDwa_1")> _
Friend Shared Function pixHMTDwa_1(pixd as IntPTR, pixs as IntPTR, selname as String) as IntPTR
End Function

' SRC\fhmtgen.1.c (38, 6)
' pixFHMTGen_1()
' pixFHMTGen_1(PIX *, PIX *, const char *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a dwa implementation of the hit-miss transform
'''  * on pixs by the sel.
'''  *   (2) The sel must be limited in size to not more than 31 pixels
'''  * about the origin.  It must have at least one hit, and it
'''  * can have any number of misses.
'''  *   (3) This handles all required setting of the border pixels
'''  * before erosion and dilation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd usual 3 choices: null, == pixs, != pixs</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="selname"> \param[in]    sel name</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFHMTGen_1")> _
Friend Shared Function pixFHMTGen_1(pixd as IntPTR, pixs as IntPTR, selname as String) as IntPTR
End Function

' SRC\fhmtgen.1.c (39, 9)
' 
' fhmtgen_low_1(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmtgen_low_1")> _
Friend Shared Function fhmtgen_low_1(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, index as Integer) as Integer
End Function

#End Region
#Region "SRC\fhmtgenlow.1.c"
' SRC\fhmtgenlow.1.c (39, 14)
' 
' fhmt_1_0(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmt_1_0")> _
Friend Shared Function fhmt_1_0(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fhmtgenlow.1.c (40, 14)
' 
' fhmt_1_1(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmt_1_1")> _
Friend Shared Function fhmt_1_1(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fhmtgenlow.1.c (41, 14)
' 
' fhmt_1_2(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmt_1_2")> _
Friend Shared Function fhmt_1_2(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fhmtgenlow.1.c (42, 14)
' 
' fhmt_1_3(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmt_1_3")> _
Friend Shared Function fhmt_1_3(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fhmtgenlow.1.c (43, 14)
' 
' fhmt_1_4(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmt_1_4")> _
Friend Shared Function fhmt_1_4(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fhmtgenlow.1.c (44, 14)
' 
' fhmt_1_5(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmt_1_5")> _
Friend Shared Function fhmt_1_5(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fhmtgenlow.1.c (45, 14)
' 
' fhmt_1_6(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmt_1_6")> _
Friend Shared Function fhmt_1_6(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fhmtgenlow.1.c (46, 14)
' 
' fhmt_1_7(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmt_1_7")> _
Friend Shared Function fhmt_1_7(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fhmtgenlow.1.c (47, 14)
' 
' fhmt_1_8(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmt_1_8")> _
Friend Shared Function fhmt_1_8(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fhmtgenlow.1.c (48, 14)
' 
' fhmt_1_9(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fhmt_1_9")> _
Friend Shared Function fhmt_1_9(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

#End Region
#Region "SRC\finditalic.c"
' SRC\finditalic.c (110, 1)
' pixItalicWords()
' pixItalicWords(PIX *, BOXA *, PIX *, BOXA **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) You can input the bounding boxes for the words in one of
'''  * two forms: as bounding boxes (%boxaw) or as a word mask with
'''  * the word bounding boxes filled (%pixw).  For example,
'''  * to compute %pixw, you can use pixWordMaskByDilation().
'''  *   (2) Alternatively, you can set both of these inputs to NULL,
'''  * in which case the word mask is generated here.  This is
'''  * done by dilating and closing the input image to connect
'''  * letters within a word, while leaving the words separated.
'''  * The parameters are chosen under the assumption that the
'''  * input is 10 to 12 pt text, scanned at about 300 ppi.
'''  *   (3) sel_ital1 and sel_ital2 detect the right edges that are
'''  * nearly vertical, at approximately the angle of italic
'''  * strokes.  We use the right edge to avoid getting seeds
'''  * from lower-case 'y'.  The typical italic slant has a smaller
'''  * angle with the vertical than the 'W', so in most cases we
'''  * will not trigger on the slanted lines in the 'W'.
'''  *   (4) Note that sel_ital2 is shorter than sel_ital1.  It is
'''  * more appropriate for a typical font scanned at 200 ppi.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs       1 bpp</param>
''' <param name="boxaw"> \param[in]    boxaw      [optional] word bounding boxes; can be NULL</param>
''' <param name="pixw"> \param[in]    pixw       [optional] word box mask; can be NULL</param>
''' <param name="pboxa"> \param[out]   pboxa      boxa of italic words</param>
''' <param name="debugflag"> \param[in]    debugflag  1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixItalicWords")> _
Friend Shared Function pixItalicWords(pixs as IntPTR, boxaw as IntPTR, pixw as IntPTR, pboxa as Object, debugflag as Integer) as Integer
End Function

#End Region
#Region "SRC\flipdetect.c"
' SRC\flipdetect.c (211, 13)
' 
' pixDebugFlipDetect(const char *, PIX *, PIX *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDebugFlipDetect")> _
Friend Shared Function pixDebugFlipDetect(filename as String, pixs as IntPTR, pixhm as IntPTR, enable as Integer) as Boolean ' Org. Void
End Function

' SRC\flipdetect.c (242, 1)
' pixOrientCorrect()
' pixOrientCorrect(PIX *, l_float32, l_float32, l_float32 *, l_float32 *, l_int32 *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Simple top-level function to detect if Roman text is in
'''  * reading orientation, and to rotate the image accordingly if not.
'''  *   (2) Returns a copy if no rotation is needed.
'''  *   (3) See notes for pixOrientDetect() and pixOrientDecision().
'''  * Use 0.0 for default values for %minupconf and %minratio
'''  *   (4) Optional output of intermediate confidence results and
'''  * the rotation performed on pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd  may be rotated by 90, 180 or 270; null on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, deskewed, English text, 150 - 300 ppi</param>
''' <param name="minupconf"> \param[in]    minupconf minimum value for which a decision can be made</param>
''' <param name="minratio"> \param[in]    minratio minimum conf ratio required for a decision</param>
''' <param name="pupconf"> \param[out]   pupconf [optional] ; use NULL to skip</param>
''' <param name="pleftconf"> \param[out]   pleftconf [optional] ; use NULL to skip</param>
''' <param name="protation"> \param[out]   protation [optional] ; use NULL to skip</param>
''' <param name="debug"> \param[in]    debug 1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOrientCorrect")> _
Friend Shared Function pixOrientCorrect(pixs as IntPTR, minupconf as single, minratio as single, pupconf as single, pleftconf as single, protation as Integer, debug as Integer) as IntPTR
End Function

' SRC\flipdetect.c (370, 1)
' pixOrientDetect()
' pixOrientDetect(PIX *, l_float32 *, l_float32 *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See "Measuring document image skew and orientation"
'''  * Dan S. Bloomberg, Gary E. Kopec and Lakshmi Dasari
'''  * IS&T/SPIE EI'95, Conference 2422: Document Recognition II
'''  * pp 302-316, Feb 6-7, 1995, San Jose, CA
'''  *   (2) upconf is the normalized difference between up ascenders
'''  * and down ascenders.  The image is analyzed without rotation
'''  * for being rightside-up or upside-down.  Set &upconf to null
'''  * to skip this operation.
'''  *   (3) leftconf is the normalized difference between up ascenders
'''  * and down ascenders in the image after it has been
'''  * rotated 90 degrees clockwise.  With that rotation, ascenders
'''  * projecting to the left in the source image will project up
'''  * in the rotated image.  We compute this by rotating 90 degrees
'''  * clockwise and testing for up and down ascenders.  Set
'''  * &leftconf to null to skip this operation.
'''  *   (4) Note that upconf and leftconf are not linear measures of
'''  * confidence, e.g., in a range between 0 and 100.  They
'''  * measure how far you are out on the tail of a (presumably)
'''  * normal distribution.  For example, a confidence of 10 means
'''  * that it is nearly certain that the difference did not
'''  * happen at random.  However, these values must be interpreted
'''  * cautiously, taking into consideration the estimated prior
'''  * for a particular orientation or mirror flip.   The up-down
'''  * signal is very strong if applied to text with ascenders
'''  * up and down, and relatively weak for text at 90 degrees,
'''  * but even at 90 degrees, the difference can look significant.
'''  * For example, suppose the ascenders are oriented horizontally,
'''  * but the test is done vertically.  Then upconf can
'''  * be  -MIN_CONF_FOR_UP_DOWN, suggesting the text may be
'''  * upside-down.  However, if instead the test were done
'''  * horizontally, leftconf will be very much larger
'''  * (in absolute value), giving the correct orientation.
'''  *   (5) If you compute both upconf and leftconf, and there is
'''  * sufficient signal, the following table determines the
'''  * cw angle necessary to rotate pixs so that the text is
'''  * rightside-up:
'''  * 0 deg :  upconf >> 1, abs(upconf) >> abs(leftconf)
'''  * 90 deg : leftconf >> 1,  abs(leftconf) >> abs(upconf)
'''  * 180 deg :   upconf  -1,   abs(upconf) >> abs(leftconf)
'''  * 270 deg :   leftconf  -1, abs(leftconf) >> abs(upconf)
'''  *   (6) One should probably not interpret the direction unless
'''  * there are a sufficient number of counts for both orientations,
'''  * in which case neither upconf nor leftconf will be 0.0.
'''  *   (7) Uses rasterop implementation of HMT.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, deskewed, English text, 150 - 300 ppi</param>
''' <param name="pupconf"> \param[out]   pupconf [optional] ; may be NULL</param>
''' <param name="pleftconf"> \param[out]   pleftconf [optional] ; may be NULL</param>
''' <param name="mincount"> \param[in]    mincount min number of up + down; use 0 for default</param>
''' <param name="debug"> \param[in]    debug 1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOrientDetect")> _
Friend Shared Function pixOrientDetect(pixs as IntPTR, pupconf as single, pleftconf as single, mincount as Integer, debug as Integer) as Integer
End Function

' SRC\flipdetect.c (431, 1)
' makeOrientDecision()
' makeOrientDecision(l_float32, l_float32, l_float32, l_float32, l_int32 *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This can be run after pixOrientDetect()
'''  *   (2) Both upconf and leftconf must be nonzero; otherwise the
'''  * orientation cannot be determined.
'''  *   (3) The abs values of the input confidences are compared to
'''  * minupconf.
'''  *   (4) The abs value of the largest of (upconf/leftconf) and
'''  * (leftconf/upconf) is compared with minratio.
'''  *   (5) Input 0.0 for the default values for minupconf and minratio.
'''  *   (6) The return value of orient is interpreted thus:
'''  *   L_TEXT_ORIENT_UNKNOWN:  not enough evidence to determine
'''  *   L_TEXT_ORIENT_UP: text rightside-up
'''  *   L_TEXT_ORIENT_LEFT:  landscape, text up facing left
'''  *   L_TEXT_ORIENT_DOWN:  text upside-down
'''  *   L_TEXT_ORIENT_RIGHT: landscape, text up facing right
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="upconf"> \param[in]    upconf nonzero</param>
''' <param name="leftconf"> \param[in]    leftconf nonzero</param>
''' <param name="minupconf"> \param[in]    minupconf minimum value for which a decision can be made</param>
''' <param name="minratio"> \param[in]    minratio minimum conf ratio required for a decision</param>
''' <param name="porient"> \param[out]   porient text orientation enum {0,1,2,3,4}</param>
''' <param name="debug"> \param[in]    debug 1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeOrientDecision")> _
Friend Shared Function makeOrientDecision(upconf as single, leftconf as single, minupconf as single, minratio as single, porient as Integer, debug as Integer) as Integer
End Function

' SRC\flipdetect.c (510, 1)
' pixUpDownDetect()
' pixUpDownDetect(PIX *, l_float32 *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Special (typical, slightly faster) case, where the pixels
'''  * identified through the HMT (hit-miss transform) are not
'''  * clipped by a truncated word mask pixm.  See pixOrientDetect()
'''  * and pixUpDownDetectGeneral() for details.
'''  *   (2) The returned confidence is the normalized difference
'''  * between the number of detected up and down ascenders,
'''  * assuming that the text is either rightside-up or upside-down
'''  * and not rotated at a 90 degree angle.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, deskewed, English text, 150 - 300 ppi</param>
''' <param name="pconf"> \param[out]   pconf confidence that text is rightside-up</param>
''' <param name="mincount"> \param[in]    mincount min number of up + down; use 0 for default</param>
''' <param name="debug"> \param[in]    debug 1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixUpDownDetect")> _
Friend Shared Function pixUpDownDetect(pixs as IntPTR, pconf as single, mincount as Integer, debug as Integer) as Integer
End Function

' SRC\flipdetect.c (558, 1)
' pixUpDownDetectGeneral()
' pixUpDownDetectGeneral(PIX *, l_float32 *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See pixOrientDetect() for other details.
'''  *   (2) %conf is the normalized difference between the number of
'''  * detected up and down ascenders, assuming that the text
'''  * is either rightside-up or upside-down and not rotated
'''  * at a 90 degree angle.
'''  *   (3) The typical mode of operation is %npixels == 0.
'''  * If %npixels > 0, this removes HMT matches at the
'''  * beginning and ending of "words."  This is useful for
'''  * pages that may have mostly digits, because if npixels == 0,
'''  * leading "1" and "3" digits can register as having
'''  * ascenders or descenders, and "7" digits can match descenders.
'''  * Consequently, a page image of only digits may register
'''  * as being upside-down.
'''  *   (4) We want to count the number of instances found using the HMT.
'''  * An expensive way to do this would be to count the
'''  * number of connected components.  A cheap way is to do a rank
'''  * reduction cascade that reduces each component to a single
'''  * pixel, and results (after two or three 2x reductions)
'''  * in one pixel for each of the original components.
'''  * After the reduction, you have a much smaller pix over
'''  * which to count pixels.  We do only 2 reductions, because
'''  * this function is designed to work for input pix between
'''  * 150 and 300 ppi, and an 8x reduction on a 150 ppi image
'''  * is going too far -- components will get merged.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, deskewed, English text, 150 - 300 ppi</param>
''' <param name="pconf"> \param[out]   pconf confidence that text is rightside-up</param>
''' <param name="mincount"> \param[in]    mincount min number of up + down; use 0 for default</param>
''' <param name="npixels"> \param[in]    npixels number of pixels removed from each side of word box</param>
''' <param name="debug"> \param[in]    debug 1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixUpDownDetectGeneral")> _
Friend Shared Function pixUpDownDetectGeneral(pixs as IntPTR, pconf as single, mincount as Integer, npixels as Integer, debug as Integer) as Integer
End Function

' SRC\flipdetect.c (699, 1)
' pixOrientDetectDwa()
' pixOrientDetectDwa(PIX *, l_float32 *, l_float32 *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Same interface as for pixOrientDetect().  See notes
'''  * there for usage.
'''  *   (2) Uses auto-gen'd code for the Sels defined at the
'''  * top of this file, with some renaming of functions.
'''  * The auto-gen'd code is in fliphmtgen.c, and can
'''  * be generated by a simple executable; see prog/flipselgen.c.
'''  *   (3) This runs about 2.5 times faster than the pixOrientDetect().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, deskewed, English text</param>
''' <param name="pupconf"> \param[out]   pupconf [optional] ; may be NULL</param>
''' <param name="pleftconf"> \param[out]   pleftconf [optional] ; may be NULL</param>
''' <param name="mincount"> \param[in]    mincount min number of up + down; use 0 for default</param>
''' <param name="debug"> \param[in]    debug 1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOrientDetectDwa")> _
Friend Shared Function pixOrientDetectDwa(pixs as IntPTR, pupconf as single, pleftconf as single, mincount as Integer, debug as Integer) as Integer
End Function

' SRC\flipdetect.c (752, 1)
' pixUpDownDetectDwa()
' pixUpDownDetectDwa(PIX *, l_float32 *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Faster (DWA) version of pixUpDownDetect().
'''  *   (2) This is a special case (but typical and slightly faster) of
'''  * pixUpDownDetectGeneralDwa(), where the pixels identified
'''  * through the HMT (hit-miss transform) are not clipped by
'''  * a truncated word mask pixm.  See pixUpDownDetectGeneral()
'''  * for usage and other details.
'''  *   (3) The returned confidence is the normalized difference
'''  * between the number of detected up and down ascenders,
'''  * assuming that the text is either rightside-up or upside-down
'''  * and not rotated at a 90 degree angle.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, deskewed, English text, 150 - 300 ppi</param>
''' <param name="pconf"> \param[out]   pconf confidence that text is rightside-up</param>
''' <param name="mincount"> \param[in]    mincount min number of up + down; use 0 for default</param>
''' <param name="debug"> \param[in]    debug 1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixUpDownDetectDwa")> _
Friend Shared Function pixUpDownDetectDwa(pixs as IntPTR, pconf as single, mincount as Integer, debug as Integer) as Integer
End Function

' SRC\flipdetect.c (777, 1)
' pixUpDownDetectGeneralDwa()
' pixUpDownDetectGeneralDwa(PIX *, l_float32 *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See the notes in pixUpDownDetectGeneral() for usage.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, deskewed, English text</param>
''' <param name="pconf"> \param[out]   pconf confidence that text is rightside-up</param>
''' <param name="mincount"> \param[in]    mincount min number of up + down; use 0 for default</param>
''' <param name="npixels"> \param[in]    npixels number of pixels removed from each side of word box</param>
''' <param name="debug"> \param[in]    debug 1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixUpDownDetectGeneralDwa")> _
Friend Shared Function pixUpDownDetectGeneralDwa(pixs as IntPTR, pconf as single, mincount as Integer, npixels as Integer, debug as Integer) as Integer
End Function

' SRC\flipdetect.c (934, 1)
' pixMirrorDetect()
' pixMirrorDetect(PIX *, l_float32 *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For this test, it is necessary that the text is horizontally
'''  * oriented, with ascenders going up.
'''  *   (2) conf is the normalized difference between the number of
'''  * right and left facing characters with ascenders.
'''  * Left-facing are {d}; right-facing are {b, h, k}.
'''  * At least that was the expectation.  In practice, we can
'''  * really just say that it is the normalized difference in
'''  * hits using two specific hit-miss filters, textsel1 and textsel2,
'''  * after the image has been suitably pre-filtered so that
'''  * these filters are effective.  See (4) for what's really happening.
'''  *   (3) A large positive conf value indicates normal text, whereas
'''  * a large negative conf value means the page is mirror reversed.
'''  *   (4) The implementation is a bit tricky.  The general idea is
'''  * to fill the x-height part of characters, but not the space
'''  * between them, before doing the HMT.  This is done by
'''  * finding pixels added using two different operations -- a
'''  * horizontal close and a vertical dilation -- and adding
'''  * the intersection of these sets to the original.  It turns
'''  * out that the original intuition about the signal was largely
'''  * in error: much of the signal for right-facing characters
'''  * comes from the lower part of common x-height characters, like
'''  * the e and c, that remain open after these operations.
'''  * So it's important that the operations to close the x-height
'''  * parts of the characters are purposely weakened sufficiently
'''  * to allow these characters to remain open.  The wonders
'''  * of morphology!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, deskewed, English text</param>
''' <param name="pconf"> \param[out]   pconf confidence that text is not LR mirror reversed</param>
''' <param name="mincount"> \param[in]    mincount min number of left + right; use 0 for default</param>
''' <param name="debug"> \param[in]    debug 1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMirrorDetect")> _
Friend Shared Function pixMirrorDetect(pixs as IntPTR, pconf as single, mincount as Integer, debug as Integer) as Integer
End Function

' SRC\flipdetect.c (1025, 1)
' pixMirrorDetectDwa()
' pixMirrorDetectDwa(PIX *, l_float32 *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) We assume the text is horizontally oriented, with
'''  * ascenders going up.
'''  *   (2) See notes in pixMirrorDetect().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, deskewed, English text</param>
''' <param name="pconf"> \param[out]   pconf confidence that text is not LR mirror reversed</param>
''' <param name="mincount"> \param[in]    mincount min number of left + right; use 0 for default</param>
''' <param name="debug"> \param[in]    debug 1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMirrorDetectDwa")> _
Friend Shared Function pixMirrorDetectDwa(pixs as IntPTR, pconf as single, mincount as Integer, debug as Integer) as Integer
End Function

#End Region
#Region "SRC\fliphmtgen.c"
' SRC\fliphmtgen.c (52, 16)
' 
' flipfhmtgen_low(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="flipfhmtgen_low")> _
Friend Shared Function flipfhmtgen_low(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer, Parameter_7 as Integer) as Integer
End Function

' SRC\fliphmtgen.c (77, 1)
' 
' pixFlipFHMTGen(PIX *, PIX *, const char *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFlipFHMTGen")> _
Friend Shared Function pixFlipFHMTGen(pixd as IntPTR, pixs as IntPTR, selname as String) as IntPTR
End Function

#End Region
#Region "SRC\fmorphauto.c"
' SRC\fmorphauto.c (108, 15)
' makeBarrelshiftString()
' makeBarrelshiftString(l_int32, l_int32) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeBarrelshiftString")> _
Friend Shared Function makeBarrelshiftString(delx as Integer, dely as Integer) as String
End Function

' SRC\fmorphauto.c (109, 17)
' sarrayMakeInnerLoopDWACode()
' sarrayMakeInnerLoopDWACode(SEL *, l_int32) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayMakeInnerLoopDWACode")> _
Friend Shared Function sarrayMakeInnerLoopDWACode(sel as IntPTR, index as Integer) as IntPTR
End Function

' SRC\fmorphauto.c (243, 1)
' fmorphautogen()
' fmorphautogen(SELA *, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function generates all the code for implementing
'''  * dwa morphological operations using all the sels in the sela.
'''  *   (2) See fmorphautogen1() and fmorphautogen2() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="sela"> \param[in]    sela</param>
''' <param name="fileindex"> \param[in]    fileindex</param>
''' <param name="filename"> \param[in]    filename [optional]; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fmorphautogen")> _
Friend Shared Function fmorphautogen(sela as IntPTR, fileindex as Integer, filename as String) as Integer
End Function

' SRC\fmorphauto.c (283, 1)
' fmorphautogen1()
' fmorphautogen1(SELA *, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function uses morphtemplate1.txt to create a
'''  * top-level file that contains two functions.  These
'''  * functions will carry out dilation, erosion,
'''  * opening or closing for any of the sels in the input sela.
'''  *   (2) The fileindex parameter is inserted into the output
'''  * filename, as described below.
'''  *   (3) If filename == NULL, the output file is fmorphgen.[n].c,
'''  * where [n] is equal to the %fileindex parameter.
'''  *   (4) If filename != NULL, the output file is [%filename].[n].c.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="sela"> \param[in]    sela</param>
''' <param name="fileindex"> \param[in]    fileindex</param>
''' <param name="filename"> \param[in]    filename [optional]; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fmorphautogen1")> _
Friend Shared Function fmorphautogen1(sela as IntPTR, fileindex as Integer, filename as String) as Integer
End Function

' SRC\fmorphauto.c (490, 1)
' 
' fmorphautogen2(SELA *, l_int32, const char *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fmorphautogen2")> _
Friend Shared Function fmorphautogen2(sela as IntPTR, fileindex as Integer, filename as String) as Integer
End Function

#End Region
#Region "SRC\fmorphgen.1.c"
' SRC\fmorphgen.1.c (37, 6)
' pixMorphDwa_1()
' pixMorphDwa_1(PIX *, PIX *, l_int32, char *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This simply adds a border, calls the appropriate
'''  * pixFMorphopGen_*(), and removes the border.
'''  * See the notes for that function.
'''  *   (2) The size of the border depends on the operation
'''  * and the boundary conditions.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd usual 3 choices: null, == pixs, != pixs</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="operation"> \param[in]    operation  L_MORPH_DILATE, L_MORPH_ERODE,</param>
''' <param name="selname"> \param[in]    sel name</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMorphDwa_1")> _
Friend Shared Function pixMorphDwa_1(pixd as IntPTR, pixs as IntPTR, operation as Integer, selname as Object) as IntPTR
End Function

' SRC\fmorphgen.1.c (38, 6)
' pixFMorphopGen_1()
' pixFMorphopGen_1(PIX *, PIX *, l_int32, char *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a dwa operation, and the Sels must be limited in
'''  * size to not more than 31 pixels about the origin.
'''  *   (2) A border of appropriate size (32 pixels, or 64 pixels
'''  * for safe closing with asymmetric b.c.) must be added before
'''  * this function is called.
'''  *   (3) This handles all required setting of the border pixels
'''  * before erosion and dilation.
'''  *   (4) The closing operation is safe; no pixels can be removed
'''  * near the boundary.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd usual 3 choices: null, == pixs, != pixs</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="operation"> \param[in]    operation  L_MORPH_DILATE, L_MORPH_ERODE,</param>
''' <param name="selname"> \param[in]    sel name</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFMorphopGen_1")> _
Friend Shared Function pixFMorphopGen_1(pixd as IntPTR, pixs as IntPTR, operation as Integer, selname as Object) as IntPTR
End Function

' SRC\fmorphgen.1.c (39, 9)
' 
' fmorphopgen_low_1(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fmorphopgen_low_1")> _
Friend Shared Function fmorphopgen_low_1(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, index as Integer) as Integer
End Function

#End Region
#Region "SRC\fmorphgenlow.1.c"
' SRC\fmorphgenlow.1.c (40, 14)
' 
' fdilate_1_0(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_0")> _
Friend Shared Function fdilate_1_0(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (41, 14)
' 
' ferode_1_0(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_0")> _
Friend Shared Function ferode_1_0(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (42, 14)
' 
' fdilate_1_1(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_1")> _
Friend Shared Function fdilate_1_1(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (43, 14)
' 
' ferode_1_1(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_1")> _
Friend Shared Function ferode_1_1(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (44, 14)
' 
' fdilate_1_2(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_2")> _
Friend Shared Function fdilate_1_2(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (45, 14)
' 
' ferode_1_2(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_2")> _
Friend Shared Function ferode_1_2(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (46, 14)
' 
' fdilate_1_3(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_3")> _
Friend Shared Function fdilate_1_3(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (47, 14)
' 
' ferode_1_3(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_3")> _
Friend Shared Function ferode_1_3(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (48, 14)
' 
' fdilate_1_4(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_4")> _
Friend Shared Function fdilate_1_4(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (49, 14)
' 
' ferode_1_4(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_4")> _
Friend Shared Function ferode_1_4(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (50, 14)
' 
' fdilate_1_5(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_5")> _
Friend Shared Function fdilate_1_5(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (51, 14)
' 
' ferode_1_5(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_5")> _
Friend Shared Function ferode_1_5(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (52, 14)
' 
' fdilate_1_6(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_6")> _
Friend Shared Function fdilate_1_6(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (53, 14)
' 
' ferode_1_6(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_6")> _
Friend Shared Function ferode_1_6(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (54, 14)
' 
' fdilate_1_7(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_7")> _
Friend Shared Function fdilate_1_7(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (55, 14)
' 
' ferode_1_7(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_7")> _
Friend Shared Function ferode_1_7(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (56, 14)
' 
' fdilate_1_8(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_8")> _
Friend Shared Function fdilate_1_8(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (57, 14)
' 
' ferode_1_8(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_8")> _
Friend Shared Function ferode_1_8(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (58, 14)
' 
' fdilate_1_9(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_9")> _
Friend Shared Function fdilate_1_9(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (59, 14)
' 
' ferode_1_9(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_9")> _
Friend Shared Function ferode_1_9(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (60, 14)
' 
' fdilate_1_10(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_10")> _
Friend Shared Function fdilate_1_10(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (61, 14)
' 
' ferode_1_10(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_10")> _
Friend Shared Function ferode_1_10(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (62, 14)
' 
' fdilate_1_11(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_11")> _
Friend Shared Function fdilate_1_11(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (63, 14)
' 
' ferode_1_11(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_11")> _
Friend Shared Function ferode_1_11(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (64, 14)
' 
' fdilate_1_12(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_12")> _
Friend Shared Function fdilate_1_12(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (65, 14)
' 
' ferode_1_12(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_12")> _
Friend Shared Function ferode_1_12(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (66, 14)
' 
' fdilate_1_13(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_13")> _
Friend Shared Function fdilate_1_13(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (67, 14)
' 
' ferode_1_13(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_13")> _
Friend Shared Function ferode_1_13(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (68, 14)
' 
' fdilate_1_14(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_14")> _
Friend Shared Function fdilate_1_14(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (69, 14)
' 
' ferode_1_14(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_14")> _
Friend Shared Function ferode_1_14(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (70, 14)
' 
' fdilate_1_15(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_15")> _
Friend Shared Function fdilate_1_15(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (71, 14)
' 
' ferode_1_15(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_15")> _
Friend Shared Function ferode_1_15(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (72, 14)
' 
' fdilate_1_16(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_16")> _
Friend Shared Function fdilate_1_16(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (73, 14)
' 
' ferode_1_16(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_16")> _
Friend Shared Function ferode_1_16(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (74, 14)
' 
' fdilate_1_17(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_17")> _
Friend Shared Function fdilate_1_17(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (75, 14)
' 
' ferode_1_17(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_17")> _
Friend Shared Function ferode_1_17(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (76, 14)
' 
' fdilate_1_18(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_18")> _
Friend Shared Function fdilate_1_18(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (77, 14)
' 
' ferode_1_18(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_18")> _
Friend Shared Function ferode_1_18(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (78, 14)
' 
' fdilate_1_19(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_19")> _
Friend Shared Function fdilate_1_19(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (79, 14)
' 
' ferode_1_19(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_19")> _
Friend Shared Function ferode_1_19(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (80, 14)
' 
' fdilate_1_20(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_20")> _
Friend Shared Function fdilate_1_20(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (81, 14)
' 
' ferode_1_20(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_20")> _
Friend Shared Function ferode_1_20(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (82, 14)
' 
' fdilate_1_21(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_21")> _
Friend Shared Function fdilate_1_21(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (83, 14)
' 
' ferode_1_21(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_21")> _
Friend Shared Function ferode_1_21(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (84, 14)
' 
' fdilate_1_22(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_22")> _
Friend Shared Function fdilate_1_22(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (85, 14)
' 
' ferode_1_22(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_22")> _
Friend Shared Function ferode_1_22(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (86, 14)
' 
' fdilate_1_23(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_23")> _
Friend Shared Function fdilate_1_23(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (87, 14)
' 
' ferode_1_23(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_23")> _
Friend Shared Function ferode_1_23(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (88, 14)
' 
' fdilate_1_24(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_24")> _
Friend Shared Function fdilate_1_24(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (89, 14)
' 
' ferode_1_24(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_24")> _
Friend Shared Function ferode_1_24(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (90, 14)
' 
' fdilate_1_25(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_25")> _
Friend Shared Function fdilate_1_25(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (91, 14)
' 
' ferode_1_25(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_25")> _
Friend Shared Function ferode_1_25(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (92, 14)
' 
' fdilate_1_26(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_26")> _
Friend Shared Function fdilate_1_26(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (93, 14)
' 
' ferode_1_26(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_26")> _
Friend Shared Function ferode_1_26(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (94, 14)
' 
' fdilate_1_27(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_27")> _
Friend Shared Function fdilate_1_27(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (95, 14)
' 
' ferode_1_27(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_27")> _
Friend Shared Function ferode_1_27(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (96, 14)
' 
' fdilate_1_28(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_28")> _
Friend Shared Function fdilate_1_28(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (97, 14)
' 
' ferode_1_28(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_28")> _
Friend Shared Function ferode_1_28(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (98, 14)
' 
' fdilate_1_29(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_29")> _
Friend Shared Function fdilate_1_29(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (99, 14)
' 
' ferode_1_29(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_29")> _
Friend Shared Function ferode_1_29(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (100, 14)
' 
' fdilate_1_30(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_30")> _
Friend Shared Function fdilate_1_30(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (101, 14)
' 
' ferode_1_30(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_30")> _
Friend Shared Function ferode_1_30(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (102, 14)
' 
' fdilate_1_31(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_31")> _
Friend Shared Function fdilate_1_31(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (103, 14)
' 
' ferode_1_31(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_31")> _
Friend Shared Function ferode_1_31(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (104, 14)
' 
' fdilate_1_32(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_32")> _
Friend Shared Function fdilate_1_32(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (105, 14)
' 
' ferode_1_32(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_32")> _
Friend Shared Function ferode_1_32(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (106, 14)
' 
' fdilate_1_33(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_33")> _
Friend Shared Function fdilate_1_33(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (107, 14)
' 
' ferode_1_33(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_33")> _
Friend Shared Function ferode_1_33(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (108, 14)
' 
' fdilate_1_34(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_34")> _
Friend Shared Function fdilate_1_34(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (109, 14)
' 
' ferode_1_34(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_34")> _
Friend Shared Function ferode_1_34(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (110, 14)
' 
' fdilate_1_35(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_35")> _
Friend Shared Function fdilate_1_35(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (111, 14)
' 
' ferode_1_35(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_35")> _
Friend Shared Function ferode_1_35(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (112, 14)
' 
' fdilate_1_36(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_36")> _
Friend Shared Function fdilate_1_36(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (113, 14)
' 
' ferode_1_36(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_36")> _
Friend Shared Function ferode_1_36(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (114, 14)
' 
' fdilate_1_37(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_37")> _
Friend Shared Function fdilate_1_37(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (115, 14)
' 
' ferode_1_37(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_37")> _
Friend Shared Function ferode_1_37(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (116, 14)
' 
' fdilate_1_38(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_38")> _
Friend Shared Function fdilate_1_38(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (117, 14)
' 
' ferode_1_38(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_38")> _
Friend Shared Function ferode_1_38(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (118, 14)
' 
' fdilate_1_39(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_39")> _
Friend Shared Function fdilate_1_39(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (119, 14)
' 
' ferode_1_39(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_39")> _
Friend Shared Function ferode_1_39(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (120, 14)
' 
' fdilate_1_40(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_40")> _
Friend Shared Function fdilate_1_40(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (121, 14)
' 
' ferode_1_40(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_40")> _
Friend Shared Function ferode_1_40(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (122, 14)
' 
' fdilate_1_41(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_41")> _
Friend Shared Function fdilate_1_41(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (123, 14)
' 
' ferode_1_41(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_41")> _
Friend Shared Function ferode_1_41(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (124, 14)
' 
' fdilate_1_42(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_42")> _
Friend Shared Function fdilate_1_42(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (125, 14)
' 
' ferode_1_42(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_42")> _
Friend Shared Function ferode_1_42(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (126, 14)
' 
' fdilate_1_43(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_43")> _
Friend Shared Function fdilate_1_43(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (127, 14)
' 
' ferode_1_43(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_43")> _
Friend Shared Function ferode_1_43(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (128, 14)
' 
' fdilate_1_44(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_44")> _
Friend Shared Function fdilate_1_44(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (129, 14)
' 
' ferode_1_44(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_44")> _
Friend Shared Function ferode_1_44(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (130, 14)
' 
' fdilate_1_45(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_45")> _
Friend Shared Function fdilate_1_45(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (131, 14)
' 
' ferode_1_45(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_45")> _
Friend Shared Function ferode_1_45(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (132, 14)
' 
' fdilate_1_46(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_46")> _
Friend Shared Function fdilate_1_46(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (133, 14)
' 
' ferode_1_46(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_46")> _
Friend Shared Function ferode_1_46(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (134, 14)
' 
' fdilate_1_47(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_47")> _
Friend Shared Function fdilate_1_47(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (135, 14)
' 
' ferode_1_47(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_47")> _
Friend Shared Function ferode_1_47(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (136, 14)
' 
' fdilate_1_48(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_48")> _
Friend Shared Function fdilate_1_48(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (137, 14)
' 
' ferode_1_48(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_48")> _
Friend Shared Function ferode_1_48(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (138, 14)
' 
' fdilate_1_49(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_49")> _
Friend Shared Function fdilate_1_49(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (139, 14)
' 
' ferode_1_49(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_49")> _
Friend Shared Function ferode_1_49(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (140, 14)
' 
' fdilate_1_50(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_50")> _
Friend Shared Function fdilate_1_50(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (141, 14)
' 
' ferode_1_50(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_50")> _
Friend Shared Function ferode_1_50(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (142, 14)
' 
' fdilate_1_51(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_51")> _
Friend Shared Function fdilate_1_51(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (143, 14)
' 
' ferode_1_51(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_51")> _
Friend Shared Function ferode_1_51(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (144, 14)
' 
' fdilate_1_52(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_52")> _
Friend Shared Function fdilate_1_52(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (145, 14)
' 
' ferode_1_52(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_52")> _
Friend Shared Function ferode_1_52(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (146, 14)
' 
' fdilate_1_53(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_53")> _
Friend Shared Function fdilate_1_53(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (147, 14)
' 
' ferode_1_53(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_53")> _
Friend Shared Function ferode_1_53(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (148, 14)
' 
' fdilate_1_54(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_54")> _
Friend Shared Function fdilate_1_54(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (149, 14)
' 
' ferode_1_54(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_54")> _
Friend Shared Function ferode_1_54(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (150, 14)
' 
' fdilate_1_55(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_55")> _
Friend Shared Function fdilate_1_55(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (151, 14)
' 
' ferode_1_55(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_55")> _
Friend Shared Function ferode_1_55(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (152, 14)
' 
' fdilate_1_56(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_56")> _
Friend Shared Function fdilate_1_56(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (153, 14)
' 
' ferode_1_56(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_56")> _
Friend Shared Function ferode_1_56(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (154, 14)
' 
' fdilate_1_57(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fdilate_1_57")> _
Friend Shared Function fdilate_1_57(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

' SRC\fmorphgenlow.1.c (155, 14)
' 
' ferode_1_57(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ferode_1_57")> _
Friend Shared Function ferode_1_57(Parameter_1 as UInteger, Parameter_2 as Integer, Parameter_3 as Integer, Parameter_4 as Integer, Parameter_5 as UInteger, Parameter_6 as Integer) as Boolean ' Org. Void
End Function

#End Region
#Region "SRC\fpix1.c"
' SRC\fpix1.c (128, 16)
' fpixaExtendArray()
' fpixaExtendArray(FPIXA *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Doubles the size of the fpixa ptr array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fpixa"> \param[in]    fpixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaExtendArray")> _
Friend Shared Function fpixaExtendArray(fpixa as IntPTR) as Integer
End Function

' SRC\fpix1.c (129, 16)
' fpixaExtendArrayToSize()
' fpixaExtendArrayToSize(FPIXA *, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) If necessary, reallocs new fpixa ptrs array to %size.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fpixa"> \param[in]    fpixa</param>
''' <param name="size"> \param[in]    size new size</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaExtendArrayToSize")> _
Friend Shared Function fpixaExtendArrayToSize(fpixa as IntPTR, size as Integer) as Integer
End Function

' SRC\fpix1.c (149, 1)
' fpixCreate()
' fpixCreate(l_int32, l_int32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) Makes a FPix of specified size, with the data array
'''  * allocated and initialized to 0.
'''  *   (2) The number of pixels must be less than 2^29.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd   with data allocated and initialized to 0, or NULL on error</returns>
''' <param name="width"> \param[in]       width, height</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixCreate")> _
Friend Shared Function fpixCreate(width as Integer, height as Integer) as IntPTR
End Function

' SRC\fpix1.c (199, 1)
' fpixCreateTemplate()
' fpixCreateTemplate(FPIX *) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) Makes a FPix of the same size as the input FPix, with the
'''  * data array allocated and initialized to 0.
'''  *   (2) Copies the resolution.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixCreateTemplate")> _
Friend Shared Function fpixCreateTemplate(fpixs as IntPTR) as IntPTR
End Function

' SRC\fpix1.c (229, 1)
' fpixClone()
' fpixClone(FPIX *) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixClone() for definition and usage.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  same fpix ptr, or NULL on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixClone")> _
Friend Shared Function fpixClone(fpix as IntPTR) as IntPTR
End Function

' SRC\fpix1.c (272, 1)
' fpixCopy()
' fpixCopy(FPIX *, FPIX *) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) There are three cases:
'''  *   (a) fpixd == null  (makes a new fpix; refcount = 1)
'''  *   (b) fpixd == fpixs  (no-op)
'''  *   (c) fpixd != fpixs  (data copy; no change in refcount)
'''  * If the refcount of fpixd > 1, case (c) will side-effect
'''  * these handles.
'''  *   (2) The general pattern of use is:
'''  * fpixd = fpixCopy(fpixd, fpixs);
'''  * This will work for all three cases.
'''  * For clarity when the case is known, you can use:
'''  *   (a) fpixd = fpixCopy(NULL, fpixs);
'''  *   (c) fpixCopy(fpixd, fpixs);
'''  *   (3) For case (c), we check if fpixs and fpixd are the same size.
'''  * If so, the data is copied directly.
'''  * Otherwise, the data is reallocated to the correct size
'''  * and the copy proceeds.  The refcount of fpixd is unchanged.
'''  *   (4) This operation, like all others that may involve a pre-existing
'''  * fpixd, will side-effect any existing clones of fpixd.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixd"> \param[in]    fpixd [optional]; can be null, or equal to fpixs,</param>
''' <param name="fpixs"> \param[in]    fpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixCopy")> _
Friend Shared Function fpixCopy(fpixd as IntPTR, fpixs as IntPTR) as IntPTR
End Function

' SRC\fpix1.c (326, 1)
' fpixResizeImageData()
' fpixResizeImageData(FPIX *, FPIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If the data sizes differ, this destroys the existing
'''  * data in fpixd and allocates a new, uninitialized, data array
'''  * of the same size as the data in fpixs.  Otherwise, this
'''  * doesn't do anything.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpixd"> \param[in]    fpixd, fpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixResizeImageData")> _
Friend Shared Function fpixResizeImageData(fpixd as IntPTR, fpixs as IntPTR) as Integer
End Function

' SRC\fpix1.c (369, 1)
' fpixDestroy()
' fpixDestroy(FPIX **) as void
''' <summary>
''' * Notes:
'''  *   (1) Decrements the ref count and, if 0, destroys the fpix.
'''  *   (2) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pfpix"> \param[in,out]   pfpix will be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixDestroy")> _
Friend Shared Function fpixDestroy(pfpix as Object) as Boolean ' Org. Void
End Function

' SRC\fpix1.c (408, 1)
' fpixGetDimensions()
' fpixGetDimensions(FPIX *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="pw"> \param[out]   pw, ph [optional]  each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixGetDimensions")> _
Friend Shared Function fpixGetDimensions(fpix as IntPTR, pw as Integer, ph as Integer) as Integer
End Function

' SRC\fpix1.c (434, 1)
' fpixSetDimensions()
' fpixSetDimensions(FPIX *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="w"> \param[in]    w, h</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixSetDimensions")> _
Friend Shared Function fpixSetDimensions(fpix as IntPTR, w as Integer, h as Integer) as Integer
End Function

' SRC\fpix1.c (455, 1)
' fpixGetWpl()
' fpixGetWpl(FPIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  wpl, or UNDEF on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixGetWpl")> _
Friend Shared Function fpixGetWpl(fpix as IntPTR) as Integer
End Function

' SRC\fpix1.c (473, 1)
' fpixSetWpl()
' fpixSetWpl(FPIX *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="wpl"> \param[in]    wpl</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixSetWpl")> _
Friend Shared Function fpixSetWpl(fpix as IntPTR, wpl as Integer) as Integer
End Function

' SRC\fpix1.c (493, 1)
' fpixGetRefcount()
' fpixGetRefcount(FPIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  refcount, or UNDEF on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixGetRefcount")> _
Friend Shared Function fpixGetRefcount(fpix as IntPTR) as Integer
End Function

' SRC\fpix1.c (511, 1)
' fpixChangeRefcount()
' fpixChangeRefcount(FPIX *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="delta"> \param[in]    delta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixChangeRefcount")> _
Friend Shared Function fpixChangeRefcount(fpix as IntPTR, delta as Integer) as Integer
End Function

' SRC\fpix1.c (532, 1)
' fpixGetResolution()
' fpixGetResolution(FPIX *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="pxres"> \param[out]   pxres, pyres [optional] x and y resolution</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixGetResolution")> _
Friend Shared Function fpixGetResolution(fpix as IntPTR, pxres as Integer, pyres as Integer) as Integer
End Function

' SRC\fpix1.c (554, 1)
' fpixSetResolution()
' fpixSetResolution(FPIX *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="xres"> \param[in]    xres, yres x and y resolution</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixSetResolution")> _
Friend Shared Function fpixSetResolution(fpix as IntPTR, xres as Integer, yres as Integer) as Integer
End Function

' SRC\fpix1.c (576, 1)
' fpixCopyResolution()
' fpixCopyResolution(FPIX *, FPIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpixd"> \param[in]    fpixd, fpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixCopyResolution")> _
Friend Shared Function fpixCopyResolution(fpixd as IntPTR, fpixs as IntPTR) as Integer
End Function

' SRC\fpix1.c (598, 1)
' fpixGetData()
' fpixGetData(FPIX *) as l_float32 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr FPix::data, or NULL on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixGetData")> _
Friend Shared Function fpixGetData(fpix as IntPTR) as String
End Function

' SRC\fpix1.c (616, 1)
' fpixSetData()
' fpixSetData(FPIX *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="data"> \param[in]    data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixSetData")> _
Friend Shared Function fpixSetData(fpix as IntPTR, data as single) as Integer
End Function

' SRC\fpix1.c (638, 1)
' fpixGetPixel()
' fpixGetPixel(FPIX *, l_int32, l_int32, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="x"> \param[in]    x,y pixel coords</param>
''' <param name="y"> \param[out]   pval pixel value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixGetPixel")> _
Friend Shared Function fpixGetPixel(fpix as IntPTR, x as Integer, y as Integer, pval as single) as Integer
End Function

' SRC\fpix1.c (673, 1)
' fpixSetPixel()
' fpixSetPixel(FPIX *, l_int32, l_int32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="x"> \param[in]    x,y pixel coords</param>
''' <param name="y"> \param[in]    val pixel value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixSetPixel")> _
Friend Shared Function fpixSetPixel(fpix as IntPTR, x as Integer, y as Integer, val as single) as Integer
End Function

' SRC\fpix1.c (706, 1)
' fpixaCreate()
' fpixaCreate(l_int32) as FPIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixa, or NULL on error</returns>
''' <param name="n"> \param[in]    n  initial number of ptrs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaCreate")> _
Friend Shared Function fpixaCreate(n as Integer) as IntPTR
End Function

' SRC\fpix1.c (746, 1)
' fpixaCopy()
' fpixaCopy(FPIXA *, l_int32) as FPIXA *
''' <summary>
''' * Notes:
'''  *   copyflag may be one of
'''  *  ~ L_COPY makes a new fpixa and copies each fpix
'''  *  ~ L_CLONE gives a new ref-counted handle to the input fpixa
'''  *  ~ L_COPY_CLONE makes a new fpixa with clones of all fpix
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  new fpixa, or NULL on error</returns>
''' <param name="fpixa"> \param[in]    fpixa</param>
''' <param name="copyflag"> \param[in]    copyflag L_COPY, L_CLODE or L_COPY_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaCopy")> _
Friend Shared Function fpixaCopy(fpixa as IntPTR, copyflag as Integer) as IntPTR
End Function

' SRC\fpix1.c (793, 1)
' fpixaDestroy()
' fpixaDestroy(FPIXA **) as void
''' <summary>
''' * Notes:
'''  *   (1) Decrements the ref count and, if 0, destroys the fpixa.
'''  *   (2) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pfpixa"> \param[in,out]   pfpixa to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaDestroy")> _
Friend Shared Function fpixaDestroy(pfpixa as Object) as Boolean ' Org. Void
End Function

' SRC\fpix1.c (834, 1)
' fpixaAddFPix()
' fpixaAddFPix(FPIXA *, FPIX *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fpixa"> \param[in]    fpixa</param>
''' <param name="fpix"> \param[in]    fpix  to be added</param>
''' <param name="copyflag"> \param[in]    copyflag L_INSERT, L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaAddFPix")> _
Friend Shared Function fpixaAddFPix(fpixa as IntPTR, fpix as IntPTR, copyflag as Integer) as Integer
End Function

' SRC\fpix1.c (934, 1)
' fpixaGetCount()
' fpixaGetCount(FPIXA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 if no pixa</returns>
''' <param name="fpixa"> \param[in]    fpixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaGetCount")> _
Friend Shared Function fpixaGetCount(fpixa as IntPTR) as Integer
End Function

' SRC\fpix1.c (953, 1)
' fpixaChangeRefcount()
' fpixaChangeRefcount(FPIXA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpixa"> \param[in]    fpixa</param>
''' <param name="delta"> \param[in]    delta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaChangeRefcount")> _
Friend Shared Function fpixaChangeRefcount(fpixa as IntPTR, delta as Integer) as Integer
End Function

' SRC\fpix1.c (975, 1)
' fpixaGetFPix()
' fpixaGetFPix(FPIXA *, l_int32, l_int32) as FPIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpix, or NULL on error</returns>
''' <param name="fpixa"> \param[in]    fpixa</param>
''' <param name="index"> \param[in]    index  to the index-th fpix</param>
''' <param name="accesstype"> \param[in]    accesstype  L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaGetFPix")> _
Friend Shared Function fpixaGetFPix(fpixa as IntPTR, index as Integer, accesstype as Integer) as IntPTR
End Function

' SRC\fpix1.c (1004, 1)
' fpixaGetFPixDimensions()
' fpixaGetFPixDimensions(FPIXA *, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpixa"> \param[in]    fpixa</param>
''' <param name="index"> \param[in]    index  to the index-th box</param>
''' <param name="pw"> \param[out]   pw, ph [optional]  each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaGetFPixDimensions")> _
Friend Shared Function fpixaGetFPixDimensions(fpixa as IntPTR, index as Integer, pw as Integer, ph as Integer) as Integer
End Function

' SRC\fpix1.c (1038, 1)
' fpixaGetData()
' fpixaGetData(FPIXA *, l_int32) as l_float32 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data not a copy, or NULL on error</returns>
''' <param name="fpixa"> \param[in]    fpixa</param>
''' <param name="index"> \param[in]    index into fpixa array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaGetData")> _
Friend Shared Function fpixaGetData(fpixa as IntPTR, index as Integer) as String
End Function

' SRC\fpix1.c (1070, 1)
' fpixaGetPixel()
' fpixaGetPixel(FPIXA *, l_int32, l_int32, l_int32, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fpixa"> \param[in]    fpixa</param>
''' <param name="index"> \param[in]    index into fpixa array</param>
''' <param name="x"> \param[in]    x,y pixel coords</param>
''' <param name="y"> \param[out]   pval pixel value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaGetPixel")> _
Friend Shared Function fpixaGetPixel(fpixa as IntPTR, index as Integer, x as Integer, y as Integer, pval as single) as Integer
End Function

' SRC\fpix1.c (1107, 1)
' fpixaSetPixel()
' fpixaSetPixel(FPIXA *, l_int32, l_int32, l_int32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fpixa"> \param[in]    fpixa</param>
''' <param name="index"> \param[in]    index into fpixa array</param>
''' <param name="x"> \param[in]    x,y pixel coords</param>
''' <param name="y"> \param[in]    val pixel value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaSetPixel")> _
Friend Shared Function fpixaSetPixel(fpixa as IntPTR, index as Integer, x as Integer, y as Integer, val as single) as Integer
End Function

' SRC\fpix1.c (1148, 1)
' dpixCreate()
' dpixCreate(l_int32, l_int32) as DPIX *
''' <summary>
''' * Notes:
'''  *   (1) Makes a DPix of specified size, with the data array
'''  * allocated and initialized to 0.
'''  *   (2) The number of pixels must be less than 2^28.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dpix  with data allocated and initialized to 0, or NULL on error</returns>
''' <param name="width"> \param[in]     width, height</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixCreate")> _
Friend Shared Function dpixCreate(width as Integer, height as Integer) as IntPTR
End Function

' SRC\fpix1.c (1198, 1)
' dpixCreateTemplate()
' dpixCreateTemplate(DPIX *) as DPIX *
''' <summary>
''' * Notes:
'''  *   (1) Makes a DPix of the same size as the input DPix, with the
'''  * data array allocated and initialized to 0.
'''  *   (2) Copies the resolution.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dpixd, or NULL on error</returns>
''' <param name="dpixs"> \param[in]    dpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixCreateTemplate")> _
Friend Shared Function dpixCreateTemplate(dpixs as IntPTR) as IntPTR
End Function

' SRC\fpix1.c (1227, 1)
' dpixClone()
' dpixClone(DPIX *) as DPIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixClone() for definition and usage.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  same dpix ptr, or NULL on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixClone")> _
Friend Shared Function dpixClone(dpix as IntPTR) as IntPTR
End Function

' SRC\fpix1.c (1270, 1)
' dpixCopy()
' dpixCopy(DPIX *, DPIX *) as DPIX *
''' <summary>
''' * Notes:
'''  *   (1) There are three cases:
'''  *   (a) dpixd == null  (makes a new dpix; refcount = 1)
'''  *   (b) dpixd == dpixs  (no-op)
'''  *   (c) dpixd != dpixs  (data copy; no change in refcount)
'''  * If the refcount of dpixd > 1, case (c) will side-effect
'''  * these handles.
'''  *   (2) The general pattern of use is:
'''  * dpixd = dpixCopy(dpixd, dpixs);
'''  * This will work for all three cases.
'''  * For clarity when the case is known, you can use:
'''  *   (a) dpixd = dpixCopy(NULL, dpixs);
'''  *   (c) dpixCopy(dpixd, dpixs);
'''  *   (3) For case (c), we check if dpixs and dpixd are the same size.
'''  * If so, the data is copied directly.
'''  * Otherwise, the data is reallocated to the correct size
'''  * and the copy proceeds.  The refcount of dpixd is unchanged.
'''  *   (4) This operation, like all others that may involve a pre-existing
'''  * dpixd, will side-effect any existing clones of dpixd.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dpixd, or NULL on error</returns>
''' <param name="dpixd"> \param[in]    dpixd [optional]; can be null, or equal to dpixs,</param>
''' <param name="dpixs"> \param[in]    dpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixCopy")> _
Friend Shared Function dpixCopy(dpixd as IntPTR, dpixs as IntPTR) as IntPTR
End Function

' SRC\fpix1.c (1316, 1)
' dpixResizeImageData()
' dpixResizeImageData(DPIX *, DPIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dpixd"> \param[in]    dpixd, dpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixResizeImageData")> _
Friend Shared Function dpixResizeImageData(dpixd as IntPTR, dpixs as IntPTR) as Integer
End Function

' SRC\fpix1.c (1359, 1)
' dpixDestroy()
' dpixDestroy(DPIX **) as void
''' <summary>
''' * Notes:
'''  *   (1) Decrements the ref count and, if 0, destroys the dpix.
'''  *   (2) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pdpix"> \param[in,out]   pdpix will be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixDestroy")> _
Friend Shared Function dpixDestroy(pdpix as Object) as Boolean ' Org. Void
End Function

' SRC\fpix1.c (1398, 1)
' dpixGetDimensions()
' dpixGetDimensions(DPIX *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
''' <param name="pw"> \param[out]   pw, ph [optional]  each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixGetDimensions")> _
Friend Shared Function dpixGetDimensions(dpix as IntPTR, pw as Integer, ph as Integer) as Integer
End Function

' SRC\fpix1.c (1424, 1)
' dpixSetDimensions()
' dpixSetDimensions(DPIX *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
''' <param name="w"> \param[in]    w, h</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixSetDimensions")> _
Friend Shared Function dpixSetDimensions(dpix as IntPTR, w as Integer, h as Integer) as Integer
End Function

' SRC\fpix1.c (1445, 1)
' dpixGetWpl()
' dpixGetWpl(DPIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  wpl, or UNDEF on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixGetWpl")> _
Friend Shared Function dpixGetWpl(dpix as IntPTR) as Integer
End Function

' SRC\fpix1.c (1463, 1)
' dpixSetWpl()
' dpixSetWpl(DPIX *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
''' <param name="wpl"> \param[in]    wpl</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixSetWpl")> _
Friend Shared Function dpixSetWpl(dpix as IntPTR, wpl as Integer) as Integer
End Function

' SRC\fpix1.c (1483, 1)
' dpixGetRefcount()
' dpixGetRefcount(DPIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  refcount, or UNDEF on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixGetRefcount")> _
Friend Shared Function dpixGetRefcount(dpix as IntPTR) as Integer
End Function

' SRC\fpix1.c (1501, 1)
' dpixChangeRefcount()
' dpixChangeRefcount(DPIX *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
''' <param name="delta"> \param[in]    delta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixChangeRefcount")> _
Friend Shared Function dpixChangeRefcount(dpix as IntPTR, delta as Integer) as Integer
End Function

' SRC\fpix1.c (1522, 1)
' dpixGetResolution()
' dpixGetResolution(DPIX *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
''' <param name="pxres"> \param[out]   pxres, pyres [optional] x and y resolution</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixGetResolution")> _
Friend Shared Function dpixGetResolution(dpix as IntPTR, pxres as Integer, pyres as Integer) as Integer
End Function

' SRC\fpix1.c (1544, 1)
' dpixSetResolution()
' dpixSetResolution(DPIX *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
''' <param name="xres"> \param[in]    xres, yres x and y resolution</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixSetResolution")> _
Friend Shared Function dpixSetResolution(dpix as IntPTR, xres as Integer, yres as Integer) as Integer
End Function

' SRC\fpix1.c (1566, 1)
' dpixCopyResolution()
' dpixCopyResolution(DPIX *, DPIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dpixd"> \param[in]    dpixd, dpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixCopyResolution")> _
Friend Shared Function dpixCopyResolution(dpixd as IntPTR, dpixs as IntPTR) as Integer
End Function

' SRC\fpix1.c (1588, 1)
' dpixGetData()
' dpixGetData(DPIX *) as l_float64 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr DPix::data, or NULL on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixGetData")> _
Friend Shared Function dpixGetData(dpix as IntPTR) as String
End Function

' SRC\fpix1.c (1606, 1)
' dpixSetData()
' dpixSetData(DPIX *, l_float64 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
''' <param name="data"> \param[in]    data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixSetData")> _
Friend Shared Function dpixSetData(dpix as IntPTR, data as Double) as Integer
End Function

' SRC\fpix1.c (1628, 1)
' dpixGetPixel()
' dpixGetPixel(DPIX *, l_int32, l_int32, l_float64 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
''' <param name="x"> \param[in]    x,y pixel coords</param>
''' <param name="y"> \param[out]   pval pixel value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixGetPixel")> _
Friend Shared Function dpixGetPixel(dpix as IntPTR, x as Integer, y as Integer, pval as Double) as Integer
End Function

' SRC\fpix1.c (1663, 1)
' dpixSetPixel()
' dpixSetPixel(DPIX *, l_int32, l_int32, l_float64) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
''' <param name="x"> \param[in]    x,y pixel coords</param>
''' <param name="y"> \param[in]    val pixel value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixSetPixel")> _
Friend Shared Function dpixSetPixel(dpix as IntPTR, x as Integer, y as Integer, val as Double) as Integer
End Function

' SRC\fpix1.c (1696, 1)
' fpixRead()
' fpixRead(const char *) as FPIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpix, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixRead")> _
Friend Shared Function fpixRead(filename as String) as IntPTR
End Function

' SRC\fpix1.c (1723, 1)
' fpixReadStream()
' fpixReadStream(FILE *) as FPIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpix, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixReadStream")> _
Friend Shared Function fpixReadStream(fp as Object) as IntPTR
End Function

' SRC\fpix1.c (1776, 1)
' fpixReadMem()
' fpixReadMem(const l_uint8 *, size_t) as FPIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpix, or NULL on error</returns>
''' <param name="data"> \param[in]    data  of serialized fpix</param>
''' <param name="size"> \param[in]    size  of data in bytes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixReadMem")> _
Friend Shared Function fpixReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\fpix1.c (1804, 1)
' fpixWrite()
' fpixWrite(const char *, FPIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="fpix"> \param[in]    fpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixWrite")> _
Friend Shared Function fpixWrite(filename as String, fpix as IntPTR) as Integer
End Function

' SRC\fpix1.c (1835, 1)
' fpixWriteStream()
' fpixWriteStream(FILE *, FPIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream opened for "wb"</param>
''' <param name="fpix"> \param[in]    fpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixWriteStream")> _
Friend Shared Function fpixWriteStream(fp as Object, fpix as IntPTR) as Integer
End Function

' SRC\fpix1.c (1881, 1)
' fpixWriteMem()
' fpixWriteMem(l_uint8 **, size_t *, FPIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a fpix in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of serialized fpix</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="fpix"> \param[in]    fpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixWriteMem")> _
Friend Shared Function fpixWriteMem(pdata as Object, psize as ULong, fpix as IntPTR) as Integer
End Function

' SRC\fpix1.c (1941, 1)
' fpixEndianByteSwap()
' fpixEndianByteSwap(FPIX *, FPIX *) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) On big-endian hardware, this does byte-swapping on each of
'''  * the 4-byte floats in the fpix data.  On little-endians,
'''  * the data is unchanged.  This is used for serialization
'''  * of fpix; the data is serialized in little-endian byte
'''  * order because most hardware is little-endian.
'''  *   (2) The operation can be either in-place or, if fpixd == NULL,
'''  * a new fpix is made.  If not in-place, caller must catch
'''  * the returned pointer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd always</returns>
''' <param name="fpixd"> \param[in]    fpixd can be equal to fpixs or NULL</param>
''' <param name="fpixs"> \param[in]    fpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixEndianByteSwap")> _
Friend Shared Function fpixEndianByteSwap(fpixd as IntPTR, fpixs as IntPTR) as IntPTR
End Function

' SRC\fpix1.c (1993, 1)
' dpixRead()
' dpixRead(const char *) as DPIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dpix, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixRead")> _
Friend Shared Function dpixRead(filename as String) as IntPTR
End Function

' SRC\fpix1.c (2020, 1)
' dpixReadStream()
' dpixReadStream(FILE *) as DPIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dpix, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixReadStream")> _
Friend Shared Function dpixReadStream(fp as Object) as IntPTR
End Function

' SRC\fpix1.c (2073, 1)
' dpixReadMem()
' dpixReadMem(const l_uint8 *, size_t) as DPIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dpix, or NULL on error</returns>
''' <param name="data"> \param[in]    data  of serialized dpix</param>
''' <param name="size"> \param[in]    size  of data in bytes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixReadMem")> _
Friend Shared Function dpixReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\fpix1.c (2101, 1)
' dpixWrite()
' dpixWrite(const char *, DPIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="dpix"> \param[in]    dpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixWrite")> _
Friend Shared Function dpixWrite(filename as String, dpix as IntPTR) as Integer
End Function

' SRC\fpix1.c (2132, 1)
' dpixWriteStream()
' dpixWriteStream(FILE *, DPIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream opened for "wb"</param>
''' <param name="dpix"> \param[in]    dpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixWriteStream")> _
Friend Shared Function dpixWriteStream(fp as Object, dpix as IntPTR) as Integer
End Function

' SRC\fpix1.c (2178, 1)
' dpixWriteMem()
' dpixWriteMem(l_uint8 **, size_t *, DPIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a dpix in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of serialized dpix</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="dpix"> \param[in]    dpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixWriteMem")> _
Friend Shared Function dpixWriteMem(pdata as Object, psize as ULong, dpix as IntPTR) as Integer
End Function

' SRC\fpix1.c (2238, 1)
' dpixEndianByteSwap()
' dpixEndianByteSwap(DPIX *, DPIX *) as DPIX *
''' <summary>
''' * Notes:
'''  *   (1) On big-endian hardware, this does byte-swapping on each of
'''  * the 4-byte words in the dpix data.  On little-endians,
'''  * the data is unchanged.  This is used for serialization
'''  * of dpix; the data is serialized in little-endian byte
'''  * order because most hardware is little-endian.
'''  *   (2) The operation can be either in-place or, if dpixd == NULL,
'''  * a new dpix is made.  If not in-place, caller must catch
'''  * the returned pointer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dpixd always</returns>
''' <param name="dpixd"> \param[in]    dpixd can be equal to dpixs or NULL</param>
''' <param name="dpixs"> \param[in]    dpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixEndianByteSwap")> _
Friend Shared Function dpixEndianByteSwap(dpixd as IntPTR, dpixs as IntPTR) as IntPTR
End Function

' SRC\fpix1.c (2297, 1)
' fpixPrintStream()
' fpixPrintStream(FILE *, FPIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Subsampled printout of fpix for debugging.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="factor"> \param[in]    factor subsampled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixPrintStream")> _
Friend Shared Function fpixPrintStream(fp as Object, fpix as IntPTR, factor as Integer) as Integer
End Function

#End Region
#Region "SRC\fpix2.c"
' SRC\fpix2.c (124, 1)
' pixConvertToFPix()
' pixConvertToFPix(PIX *, l_int32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) If colormapped, remove to grayscale.
'''  *   (2) If 32 bpp and %ncomps == 3, this is RGB; convert to luminance.
'''  * In all other cases the src image is treated as having a single
'''  * component of pixel values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 16 or 32 bpp</param>
''' <param name="ncomps"> \param[in]    ncomps number of components: 3 for RGB, 1 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertToFPix")> _
Friend Shared Function pixConvertToFPix(pixs as IntPTR, ncomps as Integer) as IntPTR
End Function

' SRC\fpix2.c (217, 1)
' pixConvertToDPix()
' pixConvertToDPix(PIX *, l_int32) as DPIX *
''' <summary>
''' * Notes:
'''  *   (1) If colormapped, remove to grayscale.
'''  *   (2) If 32 bpp and %ncomps == 3, this is RGB; convert to luminance.
'''  * In all other cases the src image is treated as having a single
'''  * component of pixel values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dpix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 16 or 32 bpp</param>
''' <param name="ncomps"> \param[in]    ncomps number of components: 3 for RGB, 1 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertToDPix")> _
Friend Shared Function pixConvertToDPix(pixs as IntPTR, ncomps as Integer) as IntPTR
End Function

' SRC\fpix2.c (318, 1)
' fpixConvertToPix()
' fpixConvertToPix(FPIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Use %outdepth = 0 to programmatically determine the
'''  * output depth.  If no values are greater than 255,
'''  * it will set outdepth = 8; otherwise to 16 or 32.
'''  *   (2) Because we are converting a float to an unsigned int
'''  * with a specified dynamic range (8, 16 or 32 bits), errors
'''  * can occur.  If errorflag == TRUE, output the number
'''  * of values out of range, both negative and positive.
'''  *   (3) If a pixel value is positive and out of range, clip to
'''  * the maximum value represented at the outdepth of 8, 16
'''  * or 32 bits.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs</param>
''' <param name="outdepth"> \param[in]    outdepth 0, 8, 16 or 32 bpp</param>
''' <param name="negvals"> \param[in]    negvals L_CLIP_TO_ZERO, L_TAKE_ABSVAL</param>
''' <param name="errorflag"> \param[in]    errorflag 1 to output error stats; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixConvertToPix")> _
Friend Shared Function fpixConvertToPix(fpixs as IntPTR, outdepth as Integer, negvals as Integer, errorflag as Integer) as IntPTR
End Function

' SRC\fpix2.c (422, 1)
' fpixDisplayMaxDynamicRange()
' fpixDisplayMaxDynamicRange(FPIX *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixDisplayMaxDynamicRange")> _
Friend Shared Function fpixDisplayMaxDynamicRange(fpixs as IntPTR) as IntPTR
End Function

' SRC\fpix2.c (479, 1)
' fpixConvertToDPix()
' fpixConvertToDPix(FPIX *) as DPIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dpix, or NULL on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixConvertToDPix")> _
Friend Shared Function fpixConvertToDPix(fpix as IntPTR) as IntPTR
End Function

' SRC\fpix2.c (537, 1)
' dpixConvertToPix()
' dpixConvertToPix(DPIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Use %outdepth = 0 to programmatically determine the
'''  * output depth.  If no values are greater than 255,
'''  * it will set outdepth = 8; otherwise to 16 or 32.
'''  *   (2) Because we are converting a float to an unsigned int
'''  * with a specified dynamic range (8, 16 or 32 bits), errors
'''  * can occur.  If errorflag == TRUE, output the number
'''  * of values out of range, both negative and positive.
'''  *   (3) If a pixel value is positive and out of range, clip to
'''  * the maximum value represented at the outdepth of 8, 16
'''  * or 32 bits.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="dpixs"> \param[in]    dpixs</param>
''' <param name="outdepth"> \param[in]    outdepth 0, 8, 16 or 32 bpp</param>
''' <param name="negvals"> \param[in]    negvals L_CLIP_TO_ZERO, L_TAKE_ABSVAL</param>
''' <param name="errorflag"> \param[in]    errorflag 1 to output error stats; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixConvertToPix")> _
Friend Shared Function dpixConvertToPix(dpixs as IntPTR, outdepth as Integer, negvals as Integer, errorflag as Integer) as IntPTR
End Function

' SRC\fpix2.c (641, 1)
' dpixConvertToFPix()
' dpixConvertToFPix(DPIX *) as FPIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpix, or NULL on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixConvertToFPix")> _
Friend Shared Function dpixConvertToFPix(dpix as IntPTR) as IntPTR
End Function

' SRC\fpix2.c (689, 1)
' fpixGetMin()
' fpixGetMin(FPIX *, l_float32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="pminval"> \param[out]   pminval [optional] min value</param>
''' <param name="pxminloc"> \param[out]   pxminloc [optional] x location of min</param>
''' <param name="pyminloc"> \param[out]   pyminloc [optional] y location of min</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixGetMin")> _
Friend Shared Function fpixGetMin(fpix as IntPTR, pminval as single, pxminloc as Integer, pyminloc as Integer) as Integer
End Function

' SRC\fpix2.c (742, 1)
' fpixGetMax()
' fpixGetMax(FPIX *, l_float32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="pmaxval"> \param[out]   pmaxval [optional] max value</param>
''' <param name="pxmaxloc"> \param[out]   pxmaxloc [optional] x location of max</param>
''' <param name="pymaxloc"> \param[out]   pymaxloc [optional] y location of max</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixGetMax")> _
Friend Shared Function fpixGetMax(fpix as IntPTR, pmaxval as single, pxmaxloc as Integer, pymaxloc as Integer) as Integer
End Function

' SRC\fpix2.c (795, 1)
' dpixGetMin()
' dpixGetMin(DPIX *, l_float64 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
''' <param name="pminval"> \param[out]   pminval [optional] min value</param>
''' <param name="pxminloc"> \param[out]   pxminloc [optional] x location of min</param>
''' <param name="pyminloc"> \param[out]   pyminloc [optional] y location of min</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixGetMin")> _
Friend Shared Function dpixGetMin(dpix as IntPTR, pminval as Double, pxminloc as Integer, pyminloc as Integer) as Integer
End Function

' SRC\fpix2.c (848, 1)
' dpixGetMax()
' dpixGetMax(DPIX *, l_float64 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
''' <param name="pmaxval"> \param[out]   pmaxval [optional] max value</param>
''' <param name="pxmaxloc"> \param[out]   pxmaxloc [optional] x location of max</param>
''' <param name="pymaxloc"> \param[out]   pymaxloc [optional] y location of max</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixGetMax")> _
Friend Shared Function dpixGetMax(dpix as IntPTR, pmaxval as Double, pxmaxloc as Integer, pymaxloc as Integer) as Integer
End Function

' SRC\fpix2.c (915, 1)
' fpixScaleByInteger()
' fpixScaleByInteger(FPIX *, l_int32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) The width wd of fpixd is related to ws of fpixs by:
'''  *  wd = factor * (ws - 1) + 1   (and ditto for the height)
'''  * We avoid special-casing boundary pixels in the interpolation
'''  * by constructing fpixd by inserting (factor - 1) interpolated
'''  * pixels between each pixel in fpixs.  Then
'''  *   wd = ws + (ws - 1) * (factor - 1) (same as above)
'''  * This also has the advantage that if we subsample by %factor,
'''  * throwing out all the interpolated pixels, we regain the
'''  * original low resolution fpix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd interpolated result, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs low resolution, subsampled</param>
''' <param name="factor"> \param[in]    factor scaling factor</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixScaleByInteger")> _
Friend Shared Function fpixScaleByInteger(fpixs as IntPTR, factor as Integer) as IntPTR
End Function

' SRC\fpix2.c (1007, 1)
' dpixScaleByInteger()
' dpixScaleByInteger(DPIX *, l_int32) as DPIX *
''' <summary>
''' * Notes:
'''  *   (1) The width wd of dpixd is related to ws of dpixs by:
'''  *  wd = factor * (ws - 1) + 1   (and ditto for the height)
'''  * We avoid special-casing boundary pixels in the interpolation
'''  * by constructing fpixd by inserting (factor - 1) interpolated
'''  * pixels between each pixel in fpixs.  Then
'''  *   wd = ws + (ws - 1) * (factor - 1) (same as above)
'''  * This also has the advantage that if we subsample by %factor,
'''  * throwing out all the interpolated pixels, we regain the
'''  * original low resolution dpix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dpixd interpolated result, or NULL on error</returns>
''' <param name="dpixs"> \param[in]    dpixs low resolution, subsampled</param>
''' <param name="factor"> \param[in]    factor scaling factor</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixScaleByInteger")> _
Friend Shared Function dpixScaleByInteger(dpixs as IntPTR, factor as Integer) as IntPTR
End Function

' SRC\fpix2.c (1104, 1)
' fpixLinearCombination()
' fpixLinearCombination(FPIX *, FPIX *, FPIX *, l_float32, l_float32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) Computes pixelwise linear combination: a * src1 + b * src2
'''  *   (2) Alignment is to UL corner.
'''  *   (3) There are 3 cases.  The result can go to a new dest,
'''  * in-place to fpixs1, or to an existing input dest:
'''  * * fpixd == null:   (src1 + src2) --> new fpixd
'''  * * fpixd == fpixs1:  (src1 + src2) --> src1  (in-place)
'''  * * fpixd != fpixs1: (src1 + src2) --> input fpixd
'''  *   (4) fpixs2 must be different from both fpixd and fpixs1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd always</returns>
''' <param name="fpixd"> \param[in]    fpixd [optional]; this can be null, equal to fpixs1, or</param>
''' <param name="fpixs1"> \param[in]    fpixs1 can be == to fpixd</param>
''' <param name="fpixs2"> \param[in]    fpixs2</param>
''' <param name="a"> \param[in]    a, b multiplication factors on fpixs1 and fpixs2, rsp.</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixLinearCombination")> _
Friend Shared Function fpixLinearCombination(fpixd as IntPTR, fpixs1 as IntPTR, fpixs2 as IntPTR, a as single, b as single) as IntPTR
End Function

' SRC\fpix2.c (1163, 1)
' fpixAddMultConstant()
' fpixAddMultConstant(FPIX *, l_float32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place operation.
'''  *   (2) It can be used to multiply each pixel by a constant,
'''  * and also to add a constant to each pixel.  Multiplication
'''  * is done first.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="addc"> \param[in]    addc  use 0.0 to skip the operation</param>
''' <param name="multc"> \param[in]    multc use 1.0 to skip the operation</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixAddMultConstant")> _
Friend Shared Function fpixAddMultConstant(fpix as IntPTR, addc as single, multc as single) as Integer
End Function

' SRC\fpix2.c (1223, 1)
' dpixLinearCombination()
' dpixLinearCombination(DPIX *, DPIX *, DPIX *, l_float32, l_float32) as DPIX *
''' <summary>
''' * Notes:
'''  *   (1) Computes pixelwise linear combination: a * src1 + b * src2
'''  *   (2) Alignment is to UL corner.
'''  *   (3) There are 3 cases.  The result can go to a new dest,
'''  * in-place to dpixs1, or to an existing input dest:
'''  * * dpixd == null:   (src1 + src2) --> new dpixd
'''  * * dpixd == dpixs1:  (src1 + src2) --> src1  (in-place)
'''  * * dpixd != dpixs1: (src1 + src2) --> input dpixd
'''  *   (4) dpixs2 must be different from both dpixd and dpixs1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dpixd always</returns>
''' <param name="dpixd"> \param[in]    dpixd [optional]; this can be null, equal to dpixs1, or</param>
''' <param name="dpixs1"> \param[in]    dpixs1 can be == to dpixd</param>
''' <param name="dpixs2"> \param[in]    dpixs2</param>
''' <param name="a"> \param[in]    a, b multiplication factors on dpixs1 and dpixs2, rsp.</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixLinearCombination")> _
Friend Shared Function dpixLinearCombination(dpixd as IntPTR, dpixs1 as IntPTR, dpixs2 as IntPTR, a as single, b as single) as IntPTR
End Function

' SRC\fpix2.c (1282, 1)
' dpixAddMultConstant()
' dpixAddMultConstant(DPIX *, l_float64, l_float64) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place operation.
'''  *   (2) It can be used to multiply each pixel by a constant,
'''  * and also to add a constant to each pixel.  Multiplication
'''  * is done first.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
''' <param name="addc"> \param[in]    addc  use 0.0 to skip the operation</param>
''' <param name="multc"> \param[in]    multc use 1.0 to skip the operation</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixAddMultConstant")> _
Friend Shared Function dpixAddMultConstant(dpix as IntPTR, addc as Double, multc as Double) as Integer
End Function

' SRC\fpix2.c (1329, 1)
' fpixSetAllArbitrary()
' fpixSetAllArbitrary(FPIX *, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="inval"> \param[in]    inval to set at each pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixSetAllArbitrary")> _
Friend Shared Function fpixSetAllArbitrary(fpix as IntPTR, inval as single) as Integer
End Function

' SRC\fpix2.c (1360, 1)
' dpixSetAllArbitrary()
' dpixSetAllArbitrary(DPIX *, l_float64) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dpix"> \param[in]    dpix</param>
''' <param name="inval"> \param[in]    inval to set at each pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dpixSetAllArbitrary")> _
Friend Shared Function dpixSetAllArbitrary(dpix as IntPTR, inval as Double) as Integer
End Function

' SRC\fpix2.c (1399, 1)
' fpixAddBorder()
' fpixAddBorder(FPIX *, l_int32, l_int32, l_int32, l_int32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) Adds border of '0' 32-bit pixels
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs</param>
''' <param name="left"> \param[in]    left, right, top, bot pixels on each side to be added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixAddBorder")> _
Friend Shared Function fpixAddBorder(fpixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer) as IntPTR
End Function

' SRC\fpix2.c (1435, 1)
' fpixRemoveBorder()
' fpixRemoveBorder(FPIX *, l_int32, l_int32, l_int32, l_int32) as FPIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs</param>
''' <param name="left"> \param[in]    left, right, top, bot pixels on each side to be removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixRemoveBorder")> _
Friend Shared Function fpixRemoveBorder(fpixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer) as IntPTR
End Function

' SRC\fpix2.c (1479, 1)
' fpixAddMirroredBorder()
' fpixAddMirroredBorder(FPIX *, l_int32, l_int32, l_int32, l_int32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixAddMirroredBorder() for situations of usage.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs</param>
''' <param name="left"> \param[in]    left, right, top, bot pixels on each side to be added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixAddMirroredBorder")> _
Friend Shared Function fpixAddMirroredBorder(fpixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer) as IntPTR
End Function

' SRC\fpix2.c (1526, 1)
' fpixAddContinuedBorder()
' fpixAddContinuedBorder(FPIX *, l_int32, l_int32, l_int32, l_int32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) This adds pixels on each side whose values are equal to
'''  * the value on the closest boundary pixel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs</param>
''' <param name="left"> \param[in]    left, right, top, bot pixels on each side to be added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixAddContinuedBorder")> _
Friend Shared Function fpixAddContinuedBorder(fpixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer) as IntPTR
End Function

' SRC\fpix2.c (1571, 1)
' fpixAddSlopeBorder()
' fpixAddSlopeBorder(FPIX *, l_int32, l_int32, l_int32, l_int32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) This adds pixels on each side whose values have a normal
'''  * derivative equal to the normal derivative at the boundary
'''  * of fpixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs</param>
''' <param name="left"> \param[in]    left, right, top, bot pixels on each side to be added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixAddSlopeBorder")> _
Friend Shared Function fpixAddSlopeBorder(fpixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer) as IntPTR
End Function

' SRC\fpix2.c (1660, 1)
' fpixRasterop()
' fpixRasterop(FPIX *, l_int32, l_int32, l_int32, l_int32, FPIX *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is similar in structure to pixRasterop(), except
'''  * it only allows copying from the source into the destination.
'''  * For that reason, no op code is necessary.  Additionally,
'''  * all pixels are 32 bit words (float values), which makes
'''  * the copy very simple.
'''  *   (2) Clipping of both src and dest fpix are done automatically.
'''  *   (3) This allows in-place copying, without checking to see if
'''  * the result is valid:  use for in-place with caution!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error.</returns>
''' <param name="fpixd"> \param[in]    fpixd  dest fpix</param>
''' <param name="dx"> \param[in]    dx     x val of UL corner of dest rectangle</param>
''' <param name="dy"> \param[in]    dy     y val of UL corner of dest rectangle</param>
''' <param name="dw"> \param[in]    dw     width of dest rectangle</param>
''' <param name="dh"> \param[in]    dh     height of dest rectangle</param>
''' <param name="fpixs"> \param[in]    fpixs  src fpix</param>
''' <param name="sx"> \param[in]    sx     x val of UL corner of src rectangle</param>
''' <param name="sy"> \param[in]    sy     y val of UL corner of src rectangle</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixRasterop")> _
Friend Shared Function fpixRasterop(fpixd as IntPTR, dx as Integer, dy as Integer, dw as Integer, dh as Integer, fpixs as IntPTR, sx as Integer, sy as Integer) as Integer
End Function

' SRC\fpix2.c (1760, 1)
' fpixRotateOrth()
' fpixRotateOrth(FPIX *, l_int32) as FPIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs</param>
''' <param name="quads"> \param[in]    quads 0-3; number of 90 degree cw rotations</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixRotateOrth")> _
Friend Shared Function fpixRotateOrth(fpixs as IntPTR, quads as Integer) as IntPTR
End Function

' SRC\fpix2.c (1806, 1)
' fpixRotate180()
' fpixRotate180(FPIX *, FPIX *) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) This does a 180 rotation of the image about the center,
'''  * which is equivalent to a left-right flip about a vertical
'''  * line through the image center, followed by a top-bottom
'''  * flip about a horizontal line through the image center.
'''  *   (2) There are 3 cases for input:
'''  * (a) fpixd == null (creates a new fpixd)
'''  * (b) fpixd == fpixs (in-place operation)
'''  * (c) fpixd != fpixs (existing fpixd)
'''  *   (3) For clarity, use these three patterns, respectively:
'''  * (a) fpixd = fpixRotate180(NULL, fpixs);
'''  * (b) fpixRotate180(fpixs, fpixs);
'''  * (c) fpixRotate180(fpixd, fpixs);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixd"> \param[in]    fpixd  [optional]; can be null, equal to fpixs,</param>
''' <param name="fpixs"> \param[in]    fpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixRotate180")> _
Friend Shared Function fpixRotate180(fpixd as IntPTR, fpixs as IntPTR) as IntPTR
End Function

' SRC\fpix2.c (1839, 1)
' fpixRotate90()
' fpixRotate90(FPIX *, l_int32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) This does a 90 degree rotation of the image about the center,
'''  * either cw or ccw, returning a new pix.
'''  *   (2) The direction must be either 1 (cw) or -1 (ccw).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs</param>
''' <param name="direction"> \param[in]    direction 1 = clockwise,  -1 = counter-clockwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixRotate90")> _
Friend Shared Function fpixRotate90(fpixs as IntPTR, direction as Integer) as IntPTR
End Function

' SRC\fpix2.c (1912, 1)
' pixFlipLR()
' fpixFlipLR(FPIX *, FPIX *) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) This does a left-right flip of the image, which is
'''  * equivalent to a rotation out of the plane about a
'''  * vertical line through the image center.
'''  *   (2) There are 3 cases for input:
'''  * (a) fpixd == null (creates a new fpixd)
'''  * (b) fpixd == fpixs (in-place operation)
'''  * (c) fpixd != fpixs (existing fpixd)
'''  *   (3) For clarity, use these three patterns, respectively:
'''  * (a) fpixd = fpixFlipLR(NULL, fpixs);
'''  * (b) fpixFlipLR(fpixs, fpixs);
'''  * (c) fpixFlipLR(fpixd, fpixs);
'''  *   (4) If an existing fpixd is not the same size as fpixs, the
'''  * image data will be reallocated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixd"> \param[in]    fpixd [optional]; can be null, equal to fpixs,</param>
''' <param name="fpixs"> \param[in]    fpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixFlipLR")> _
Friend Shared Function fpixFlipLR(fpixd as IntPTR, fpixs as IntPTR) as IntPTR
End Function

' SRC\fpix2.c (1973, 1)
' fpixFlipTB()
' fpixFlipTB(FPIX *, FPIX *) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) This does a top-bottom flip of the image, which is
'''  * equivalent to a rotation out of the plane about a
'''  * horizontal line through the image center.
'''  *   (2) There are 3 cases for input:
'''  * (a) fpixd == null (creates a new fpixd)
'''  * (b) fpixd == fpixs (in-place operation)
'''  * (c) fpixd != fpixs (existing fpixd)
'''  *   (3) For clarity, use these three patterns, respectively:
'''  * (a) fpixd = fpixFlipTB(NULL, fpixs);
'''  * (b) fpixFlipTB(fpixs, fpixs);
'''  * (c) fpixFlipTB(fpixd, fpixs);
'''  *   (4) If an existing fpixd is not the same size as fpixs, the
'''  * image data will be reallocated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixd"> \param[in]    fpixd [optional]; can be null, equal to fpixs,</param>
''' <param name="fpixs"> \param[in]    fpixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixFlipTB")> _
Friend Shared Function fpixFlipTB(fpixd as IntPTR, fpixs as IntPTR) as IntPTR
End Function

' SRC\fpix2.c (2035, 1)
' fpixAffinePta()
' fpixAffinePta(FPIX *, PTA *, PTA *, l_int32, l_float32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) If %border > 0, all four sides are extended by that distance,
'''  * and removed after the transformation is finished.  Pixels
'''  * that would be brought in to the trimmed result from outside
'''  * the extended region are assigned %inval.  The purpose of
'''  * extending the image is to avoid such assignments.
'''  *   (2) On the other hand, you may want to give all pixels that
'''  * are brought in from outside fpixs a specific value.  In that
'''  * case, set %border == 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs 8 bpp</param>
''' <param name="ptad"> \param[in]    ptad  4 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  4 pts of initial coordinate space</param>
''' <param name="border"> \param[in]    border size of extension with constant normal derivative</param>
''' <param name="inval"> \param[in]    inval value brought in; typ. 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixAffinePta")> _
Friend Shared Function fpixAffinePta(fpixs as IntPTR, ptad as IntPTR, ptas as IntPTR, border as Integer, inval as single) as IntPTR
End Function

' SRC\fpix2.c (2092, 1)
' fpixAffine()
' fpixAffine(FPIX *, l_float32 *, l_float32) as FPIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs 8 bpp</param>
''' <param name="vc"> \param[in]    vc  vector of 8 coefficients for projective transformation</param>
''' <param name="inval"> \param[in]    inval value brought in; typ. 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixAffine")> _
Friend Shared Function fpixAffine(fpixs as IntPTR, vc as single, inval as single) as IntPTR
End Function

' SRC\fpix2.c (2154, 1)
' fpixProjectivePta()
' fpixProjectivePta(FPIX *, PTA *, PTA *, l_int32, l_float32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) If %border > 0, all four sides are extended by that distance,
'''  * and removed after the transformation is finished.  Pixels
'''  * that would be brought in to the trimmed result from outside
'''  * the extended region are assigned %inval.  The purpose of
'''  * extending the image is to avoid such assignments.
'''  *   (2) On the other hand, you may want to give all pixels that
'''  * are brought in from outside fpixs a specific value.  In that
'''  * case, set %border == 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs 8 bpp</param>
''' <param name="ptad"> \param[in]    ptad  4 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  4 pts of initial coordinate space</param>
''' <param name="border"> \param[in]    border size of extension with constant normal derivative</param>
''' <param name="inval"> \param[in]    inval value brought in; typ. 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixProjectivePta")> _
Friend Shared Function fpixProjectivePta(fpixs as IntPTR, ptad as IntPTR, ptas as IntPTR, border as Integer, inval as single) as IntPTR
End Function

' SRC\fpix2.c (2211, 1)
' fpixProjective()
' fpixProjective(FPIX *, l_float32 *, l_float32) as FPIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs 8 bpp</param>
''' <param name="vc"> \param[in]    vc  vector of 8 coefficients for projective transformation</param>
''' <param name="inval"> \param[in]    inval value brought in; typ. 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixProjective")> _
Friend Shared Function fpixProjective(fpixs as IntPTR, vc as single, inval as single) as IntPTR
End Function

' SRC\fpix2.c (2269, 1)
' linearInterpolatePixelFloat()
' linearInterpolatePixelFloat(l_float32 *, l_int32, l_int32, l_float32, l_float32, l_float32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a standard linear interpolation function.  It is
'''  * equivalent to area weighting on each component, and
'''  * avoids "jaggies" when rendering sharp edges.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="datas"> \param[in]    datas ptr to beginning of float image data</param>
''' <param name="w"> \param[in]    w, h of image</param>
''' <param name="h"> \param[in]    x, y floating pt location for evaluation</param>
''' <param name="x"> \param[in]    inval float value brought in from the outside when the</param>
''' <param name="y"> \param[out]   pval interpolated float value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="linearInterpolatePixelFloat")> _
Friend Shared Function linearInterpolatePixelFloat(datas as single, w as Integer, h as Integer, x as single, y as single, inval as single, pval as single) as Integer
End Function

' SRC\fpix2.c (2333, 1)
' fpixThresholdToPix()
' fpixThresholdToPix(FPIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For all values of fpix that are = thresh, sets the pixel
'''  * in pixd to 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="thresh"> \param[in]    thresh</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixThresholdToPix")> _
Friend Shared Function fpixThresholdToPix(fpix as IntPTR, thresh as single) as IntPTR
End Function

' SRC\fpix2.c (2391, 1)
' pixComponentFunction()
' pixComponentFunction(PIX *, l_float32, l_float32, l_float32, l_float32, l_float32, l_float32) as FPIX *
''' <summary>
''' * Notes:
'''  *   (1) This stores a function of the component values of each
'''  * input pixel in %fpixd.
'''  *   (2) The function is a ratio of linear combinations of component values.
'''  * There are two special cases for denominator coefficients:
'''  * (a) The denominator is 1.0: input 0 for all denominator coefficients
'''  * (b) Only one component is used in the denominator: input 1.0
'''  *  for that denominator component and 0.0 for the other two.
'''  *   (3) If the denominator is 0, multiply by an arbitrary number that
'''  * is much larger than 1.  Choose 256 "arbitrarily".
'''  *
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fpixd, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix 32 bpp rgb</param>
''' <param name="rnum"> \param[in]    rnum, gnum, bnum coefficients for numerator</param>
''' <param name="gnum"> \param[in]    rdenom, gdenom, bdenom coefficients for denominator</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixComponentFunction")> _
Friend Shared Function pixComponentFunction(pix as IntPTR, rnum as single, gnum as single, bnum as single, rdenom as single, gdenom as single, bdenom as single) as IntPTR
End Function

#End Region
#Region "SRC\gifiostub.c"
' SRC\gifiostub.c (45, 7)
' 
' pixReadStreamGif(FILE *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadStreamGif")> _
Friend Shared Function pixReadStreamGif(fp as Object) as IntPTR
End Function

' SRC\gifiostub.c (52, 7)
' 
' pixReadMemGif(const l_uint8 *, size_t) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadMemGif")> _
Friend Shared Function pixReadMemGif(cdata as Byte, size as ULong) as IntPTR
End Function

' SRC\gifiostub.c (59, 6)
' 
' pixWriteStreamGif(FILE *, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamGif")> _
Friend Shared Function pixWriteStreamGif(fp as Object, pix as IntPTR) as Integer
End Function

' SRC\gifiostub.c (66, 6)
' 
' pixWriteMemGif(l_uint8 **, size_t *, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMemGif")> _
Friend Shared Function pixWriteMemGif(pdata as Object, psize as ULong, pix as IntPTR) as Integer
End Function

#End Region
#Region "SRC\gplot.c"
' SRC\gplot.c (138, 1)
' gplotCreate()
' gplotCreate(const char *, l_int32, const char *, const char *, const char *) as GPLOT *
''' <summary>
''' * Notes:
'''  *   (1) This initializes the plot.
'''  *   (2) The 'title', 'xlabel' and 'ylabel' strings can have spaces,
'''  * double quotes and backquotes, but not single quotes.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  gplot, or NULL on error</returns>
''' <param name="rootname"> \param[in]    rootname root for all output files</param>
''' <param name="outformat"> \param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
''' <param name="title"> \param[in]    title  [optional] overall title</param>
''' <param name="xlabel"> \param[in]    xlabel [optional] x axis label</param>
''' <param name="ylabel"> \param[in]    ylabel [optional] y axis label</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotCreate")> _
Friend Shared Function gplotCreate(rootname as String, outformat as Integer, title as String, xlabel as String, ylabel as String) as IntPTR
End Function

' SRC\gplot.c (197, 1)
' gplotDestroy()
' gplotDestroy(GPLOT **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="pgplot"> \param[in,out] pgplot to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotDestroy")> _
Friend Shared Function gplotDestroy(pgplot as Object) as Boolean ' Org. Void
End Function

' SRC\gplot.c (263, 1)
' gplotAddPlot()
' gplotAddPlot(GPLOT *, NUMA *, NUMA *, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) There are 2 options for (x,y) values:
'''  *   o  To plot an array vs a linear function of the
'''  *   index, set nax = NULL.
'''  *   o  To plot one array vs another, use both nax and nay.
'''  *   (2) If nax is NULL, the x value corresponding to the i-th
'''  * value of nay is found from the startx and delx fields
'''  * in nay:
'''  *   x = startx + i * delx
'''  * These are set with numaSetParameters().  Their default
'''  * values are startx = 0.0, delx = 1.0.
'''  *   (3) If nax is defined, it must be the same size as nay, and
'''  * must have at least one number.
'''  *   (4) The 'plottitle' string can have spaces, double
'''  * quotes and backquotes, but not single quotes.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="gplot"> \param[in]    gplot</param>
''' <param name="nax"> \param[in]    nax [optional] numa: set to null for Y_VS_I;</param>
''' <param name="nay"> \param[in]    nay numa: required for both Y_VS_I and Y_VS_X</param>
''' <param name="plotstyle"> \param[in]    plotstyle GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,</param>
''' <param name="plottitle"> \param[in]    plottitle  [optional] title for individual plot</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotAddPlot")> _
Friend Shared Function gplotAddPlot(gplot as IntPTR, nax as IntPTR, nay as IntPTR, plotstyle as Integer, plottitle as String) as Integer
End Function

' SRC\gplot.c (343, 1)
' gplotSetScaling()
' gplotSetScaling(GPLOT *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) By default, the x and y axis scaling is linear.
'''  *   (2) Call this function to set semi-log or log-log scaling.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="gplot"> \param[in]    gplot</param>
''' <param name="scaling"> \param[in]    scaling GPLOT_LINEAR_SCALE, GPLOT_LOG_SCALE_X,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotSetScaling")> _
Friend Shared Function gplotSetScaling(gplot as IntPTR, scaling as Integer) as Integer
End Function

' SRC\gplot.c (379, 1)
' gplotMakeOutput()
' gplotMakeOutput(GPLOT *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This uses gplot and the new arrays to add a plot
'''  * to the output, by writing a new data file and appending
'''  * the appropriate plot commands to the command file.
'''  *   (2) This is the only function in this file that requires the
'''  * gnuplot executable, to actually generate the plot.
'''  *   (3) The command file name for unix is canonical (i.e., directory /tmp)
'''  * but the temp filename paths in the command file must be correct.
'''  *   (4) The gnuplot program for windows is wgnuplot.exe.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="gplot"> \param[in]    gplot</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotMakeOutput")> _
Friend Shared Function gplotMakeOutput(gplot as IntPTR) as Integer
End Function

' SRC\gplot.c (422, 1)
' gplotGenCommandFile()
' gplotGenCommandFile(GPLOT *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="gplot"> \param[in]    gplot</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotGenCommandFile")> _
Friend Shared Function gplotGenCommandFile(gplot as IntPTR) as Integer
End Function

' SRC\gplot.c (528, 1)
' gplotGenDataFiles()
' gplotGenDataFiles(GPLOT *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The pathnames in the gplot command file are actual pathnames,
'''  * which can be in temp directories.  Consequently, they must not be
'''  * rewritten by calling fopenWriteStream(), and we use fopen().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="gplot"> \param[in]    gplot</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotGenDataFiles")> _
Friend Shared Function gplotGenDataFiles(gplot as IntPTR) as Integer
End Function

' SRC\gplot.c (575, 1)
' gplotSimple1()
' gplotSimple1(NUMA *, l_int32, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This gives a line plot of a numa, where the array value
'''  * is plotted vs the array index.  The plot is generated
'''  * in the specified output format; the title  is optional.
'''  *   (2) When calling these simple plot functions more than once, use
'''  * different %outroot to avoid overwriting the output files.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na numa; plot Y_VS_I</param>
''' <param name="outformat"> \param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
''' <param name="outroot"> \param[in]    outroot root of output files</param>
''' <param name="title"> \param[in]    title  [optional], can be NULL</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotSimple1")> _
Friend Shared Function gplotSimple1(na as IntPTR, outformat as Integer, outroot as String, title as String) as Integer
End Function

' SRC\gplot.c (604, 1)
' gplotSimple2()
' gplotSimple2(NUMA *, NUMA *, l_int32, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This gives a line plot of two numa, where the array values
'''  * are each plotted vs the array index.  The plot is generated
'''  * in the specified output format; the title  is optional.
'''  *   (2) When calling these simple plot functions more than once, use
'''  * different %outroot to avoid overwriting the output files.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na1"> \param[in]    na1 numa; plotted with Y_VS_I</param>
''' <param name="na2"> \param[in]    na2 ditto</param>
''' <param name="outformat"> \param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
''' <param name="outroot"> \param[in]    outroot root of output files</param>
''' <param name="title"> \param[in]    title  [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotSimple2")> _
Friend Shared Function gplotSimple2(na1 as IntPTR, na2 as IntPTR, outformat as Integer, outroot as String, title as String) as Integer
End Function

' SRC\gplot.c (635, 1)
' gplotSimpleN()
' gplotSimpleN(NUMAA *, l_int32, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This gives a line plot of all numas in a numaa (array of numa),
'''  * where the array values are each plotted vs the array index.
'''  * The plot is generated in the specified output format;
'''  * the title  is optional.
'''  *   (2) When calling these simple plot functions more than once, use
'''  * different %outroot to avoid overwriting the output files.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="naa"> \param[in]    naa numaa; we plotted with Y_VS_I for each numa</param>
''' <param name="outformat"> \param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
''' <param name="outroot"> \param[in]    outroot root of output files</param>
''' <param name="title"> \param[in]    title [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotSimpleN")> _
Friend Shared Function gplotSimpleN(naa as IntPTR, outformat as Integer, outroot as String, title as String) as Integer
End Function

' SRC\gplot.c (668, 1)
' gplotSimpleXY1()
' gplotSimpleXY1(NUMA *, NUMA *, l_int32, l_int32, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This gives a plot of a %nay vs %nax, generated in
'''  * the specified output format.  The title is optional.
'''  *   (2) Use 0 for default plotstyle (lines).
'''  *   (3) %nax is optional.  If NULL, %nay is plotted against
'''  * the array index.
'''  *   (4) When calling these simple plot functions more than once, use
'''  * different %outroot to avoid overwriting the output files.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nax"> \param[in]    nax [optional]</param>
''' <param name="nay"> \param[in]    nay</param>
''' <param name="plotstyle"> \param[in]    plotstyle GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,</param>
''' <param name="outformat"> \param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
''' <param name="outroot"> \param[in]    outroot root of output files</param>
''' <param name="title"> \param[in]    title  [optional], can be NULL</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotSimpleXY1")> _
Friend Shared Function gplotSimpleXY1(nax as IntPTR, nay as IntPTR, plotstyle as Integer, outformat as Integer, outroot as String, title as String) as Integer
End Function

' SRC\gplot.c (723, 1)
' gplotSimpleXY2()
' gplotSimpleXY2(NUMA *, NUMA *, NUMA *, l_int32, l_int32, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This gives plots of %nay1 and %nay2 against nax, generated
'''  * in the specified output format.  The title is optional.
'''  *   (2) Use 0 for default plotstyle (lines).
'''  *   (3) %nax is optional.  If NULL, %nay1 and %nay2 are plotted
'''  * against the array index.
'''  *   (4) When calling these simple plot functions more than once, use
'''  * different %outroot to avoid overwriting the output files.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nax"> \param[in]    nax <optional; can be NULL</param>
''' <param name="nay1"> \param[in]    nay1</param>
''' <param name="nay2"> \param[in]    nay2</param>
''' <param name="plotstyle"> \param[in]    plotstyle GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,</param>
''' <param name="outformat"> \param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
''' <param name="outroot"> \param[in]    outroot root of output files</param>
''' <param name="title"> \param[in]    title  [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotSimpleXY2")> _
Friend Shared Function gplotSimpleXY2(nax as IntPTR, nay1 as IntPTR, nay2 as IntPTR, plotstyle as Integer, outformat as Integer, outroot as String, title as String) as Integer
End Function

' SRC\gplot.c (779, 1)
' gplotSimpleXYN()
' gplotSimpleXYN(NUMA *, NUMAA *, l_int32, l_int32, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This gives plots of each Numa in %naa against nax,
'''  * generated in the specified output format.  The title is optional.
'''  *   (2) Use 0 for default plotstyle (lines).
'''  *   (3) %nax is optional.  If NULL, each Numa array is plotted against
'''  * the array index.
'''  *   (4) When calling these simple plot functions more than once, use
'''  * different %outroot to avoid overwriting the output files.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nax"> \param[in]    nax [optional]; can be NULL</param>
''' <param name="naay"> \param[in]    naay numaa of arrays to plot against %nax</param>
''' <param name="plotstyle"> \param[in]    plotstyle GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,</param>
''' <param name="outformat"> \param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
''' <param name="outroot"> \param[in]    outroot root of output files</param>
''' <param name="title"> \param[in]    title [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotSimpleXYN")> _
Friend Shared Function gplotSimpleXYN(nax as IntPTR, naay as IntPTR, plotstyle as Integer, outformat as Integer, outroot as String, title as String) as Integer
End Function

' SRC\gplot.c (827, 1)
' gplotRead()
' gplotRead(const char *) as GPLOT *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  gplot, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotRead")> _
Friend Shared Function gplotRead(filename as String) as IntPTR
End Function

' SRC\gplot.c (912, 1)
' gplotWrite()
' gplotWrite(const char *, GPLOT *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="gplot"> \param[in]    gplot</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="gplotWrite")> _
Friend Shared Function gplotWrite(filename as String, gplot as IntPTR) as Integer
End Function

#End Region
#Region "SRC\graphics.c"
' SRC\graphics.c (138, 1)
' generatePtaLine()
' generatePtaLine(l_int32, l_int32, l_int32, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) Uses Bresenham line drawing, which results in an 8-connected line.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="x1"> \param[in]    x1, y1  end point 1</param>
''' <param name="y1"> \param[in]    x2, y2  end point 2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePtaLine")> _
Friend Shared Function generatePtaLine(x1 as Integer, y1 as Integer, x2 as Integer, y2 as Integer) as IntPTR
End Function

' SRC\graphics.c (203, 1)
' generatePtaWideLine()
' generatePtaWideLine(l_int32, l_int32, l_int32, l_int32, l_int32) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptaj, or NULL on error</returns>
''' <param name="x1"> \param[in]    x1, y1  end point 1</param>
''' <param name="y1"> \param[in]    x2, y2  end point 2</param>
''' <param name="x2"> \param[in]    width</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePtaWideLine")> _
Friend Shared Function generatePtaWideLine(x1 as Integer, y1 as Integer, x2 as Integer, y2 as Integer, width as Integer) as IntPTR
End Function

' SRC\graphics.c (273, 1)
' generatePtaBox()
' generatePtaBox(BOX *, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) Because the box is constructed so that we don't have any
'''  * overlapping lines, there is no need to remove duplicates.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad, or NULL on error</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="width"> \param[in]    width of line</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePtaBox")> _
Friend Shared Function generatePtaBox(box as IntPTR, width as Integer) as IntPTR
End Function

' SRC\graphics.c (350, 1)
' generatePtaBoxa()
' generatePtaBoxa(BOXA *, l_int32, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) If the boxa has overlapping boxes, and if blending will
'''  * be used to give a transparent effect, transparency
'''  * artifacts at line intersections can be removed using
'''  * removedups = 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad, or NULL on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="width"> \param[in]    width</param>
''' <param name="removedups"> \param[in]    removedups  1 to remove, 0 to leave</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePtaBoxa")> _
Friend Shared Function generatePtaBoxa(boxa as IntPTR, width as Integer, removedups as Integer) as IntPTR
End Function

' SRC\graphics.c (405, 1)
' generatePtaHashBox()
' generatePtaHashBox(BOX *, l_int32, l_int32, l_int32, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) The orientation takes on one of 4 orientations (horiz, vertical,
'''  * slope +1, slope -1).
'''  *   (2) The full outline is also drawn if %outline = 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad, or NULL on error</returns>
''' <param name="box"> \param[in]    box</param>
''' <param name="spacing"> \param[in]    spacing spacing between lines; must be > 1</param>
''' <param name="width"> \param[in]    width  of line</param>
''' <param name="orient"> \param[in]    orient  orientation of lines: L_HORIZONTAL_LINE, ...</param>
''' <param name="outline"> \param[in]    outline  0 to skip drawing box outline</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePtaHashBox")> _
Friend Shared Function generatePtaHashBox(box as IntPTR, spacing as Integer, width as Integer, orient as Integer, outline as Integer) as IntPTR
End Function

' SRC\graphics.c (505, 1)
' generatePtaHashBoxa()
' generatePtaHashBoxa(BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) The orientation takes on one of 4 orientations (horiz, vertical,
'''  * slope +1, slope -1).
'''  *   (2) The full outline is also drawn if %outline = 1.
'''  *   (3) If the boxa has overlapping boxes, and if blending will
'''  * be used to give a transparent effect, transparency
'''  * artifacts at line intersections can be removed using
'''  * removedups = 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad, or NULL on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="spacing"> \param[in]    spacing spacing between lines; must be > 1</param>
''' <param name="width"> \param[in]    width  of line</param>
''' <param name="orient"> \param[in]    orient  orientation of lines: L_HORIZONTAL_LINE, ...</param>
''' <param name="outline"> \param[in]    outline  0 to skip drawing box outline</param>
''' <param name="removedups"> \param[in]    removedups  1 to remove, 0 to leave</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePtaHashBoxa")> _
Friend Shared Function generatePtaHashBoxa(boxa as IntPTR, spacing as Integer, width as Integer, orient as Integer, outline as Integer, removedups as Integer) as IntPTR
End Function

' SRC\graphics.c (565, 1)
' generatePtaaBoxa()
' generatePtaaBoxa(BOXA *) as PTAA *
''' <summary>
''' * Notes:
'''  *   (1) This generates a pta of the four corners for each box in
'''  * the boxa.
'''  *   (2) Each of these pta can be rendered onto a pix with random colors,
'''  * by using pixRenderRandomCmapPtaa() with closeflag = 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptaa, or NULL on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePtaaBoxa")> _
Friend Shared Function generatePtaaBoxa(boxa as IntPTR) as IntPTR
End Function

' SRC\graphics.c (616, 1)
' generatePtaaHashBoxa()
' generatePtaaHashBoxa(BOXA *, l_int32, l_int32, l_int32, l_int32) as PTAA *
''' <summary>
''' * Notes:
'''  *   (1) The orientation takes on one of 4 orientations (horiz, vertical,
'''  * slope +1, slope -1).
'''  *   (2) The full outline is also drawn if %outline = 1.
'''  *   (3) Each of these pta can be rendered onto a pix with random colors,
'''  * by using pixRenderRandomCmapPtaa() with closeflag = 1.
'''  *
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptaa, or NULL on error</returns>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="spacing"> \param[in]    spacing spacing between hash lines; must be > 1</param>
''' <param name="width"> \param[in]    width  hash line width</param>
''' <param name="orient"> \param[in]    orient  orientation of lines: L_HORIZONTAL_LINE, ...</param>
''' <param name="outline"> \param[in]    outline  0 to skip drawing box outline</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePtaaHashBoxa")> _
Friend Shared Function generatePtaaHashBoxa(boxa as IntPTR, spacing as Integer, width as Integer, orient as Integer, outline as Integer) as IntPTR
End Function

' SRC\graphics.c (664, 1)
' generatePtaPolyline()
' generatePtaPolyline(PTA *, l_int32, l_int32, l_int32) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas vertices of polyline</param>
''' <param name="width"> \param[in]    width</param>
''' <param name="closeflag"> \param[in]    closeflag 1 to close the contour; 0 otherwise</param>
''' <param name="removedups"> \param[in]    removedups  1 to remove, 0 to leave</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePtaPolyline")> _
Friend Shared Function generatePtaPolyline(ptas as IntPTR, width as Integer, closeflag as Integer, removedups as Integer) as IntPTR
End Function

' SRC\graphics.c (722, 1)
' generatePtaGrid()
' generatePtaGrid(l_int32, l_int32, l_int32, l_int32, l_int32) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad, or NULL on error</returns>
''' <param name="w"> \param[in]    w, h of region where grid will be displayed</param>
''' <param name="h"> \param[in]    nx, ny  number of rectangles in each direction in grid</param>
''' <param name="nx"> \param[in]    width of rendered lines</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePtaGrid")> _
Friend Shared Function generatePtaGrid(w as Integer, h as Integer, nx as Integer, ny as Integer, width as Integer) as IntPTR
End Function

' SRC\graphics.c (780, 1)
' convertPtaLineTo4cc()
' convertPtaLineTo4cc(PTA *) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) When a polyline is generated with width = 1, the resulting
'''  * line is not 4-connected in general.  This function adds
'''  * points as necessary to convert the line to 4-cconnected.
'''  * It is useful when rendering 1 bpp on a pix.
'''  *   (2) Do not use this for lines generated with width > 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad 4-connected line, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas 8-connected line of points</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertPtaLineTo4cc")> _
Friend Shared Function convertPtaLineTo4cc(ptas as IntPTR) as IntPTR
End Function

' SRC\graphics.c (823, 1)
' generatePtaFilledCircle()
' generatePtaFilledCircle(l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) The circle is has diameter = 2 * radius + 1.
'''  *   (2) It is located with the center of the circle at the
'''  * point (radius, radius).
'''  *   (3) Consequently, it typically must be translated if
'''  * it is to represent a set of pixels in an image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="radius"> \param[in]    radius</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePtaFilledCircle")> _
Friend Shared Function generatePtaFilledCircle(radius as Integer) as IntPTR
End Function

' SRC\graphics.c (863, 1)
' generatePtaFilledSquare()
' generatePtaFilledSquare(l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) The center of the square can be chosen to be at
'''  * (side / 2, side / 2).  It must be translated by this amount
'''  * when used for replication.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="side"> \param[in]    side</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePtaFilledSquare")> _
Friend Shared Function generatePtaFilledSquare(side as Integer) as IntPTR
End Function

' SRC\graphics.c (897, 1)
' generatePtaLineFromPt()
' generatePtaLineFromPt(l_int32, l_int32, l_float64, l_float64) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) The %length of the line is 1 greater than the distance
'''  * used in locatePtRadially().  Example: a distance of 1
'''  * gives rise to a length of 2.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="x"> \param[in]    x, y  point of origination</param>
''' <param name="y"> \param[in]    length of line, including starting point</param>
''' <param name="length"> \param[in]    radang angle in radians, CW from horizontal</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePtaLineFromPt")> _
Friend Shared Function generatePtaLineFromPt(x as Integer, y as Integer, length as Double, radang as Double) as IntPTR
End Function

' SRC\graphics.c (921, 1)
' locatePtRadially()
' locatePtRadially(l_int32, l_int32, l_float64, l_float64, l_float64 *, l_float64 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="xr"> \param[in]    xr, yr  reference point</param>
''' <param name="yr"> \param[in]    radang angle in radians, CW from horizontal</param>
''' <param name="dist"> \param[in]    dist distance of point from reference point along line</param>
''' <param name="radang"> \param[out]   px, py location of point</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="locatePtRadially")> _
Friend Shared Function locatePtRadially(xr as Integer, yr as Integer, dist as Double, radang as Double, px as Double, py as Double) as Integer
End Function

' SRC\graphics.c (963, 1)
' pixRenderPlotFromNuma()
' pixRenderPlotFromNuma(PIX **, NUMA *, l_int32, l_int32, l_int32, l_uint32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Simplified interface for plotting row or column aligned data
'''  * on a pix.
'''  *   (2) This replaces %pix with a 32 bpp rgb version if it is not
'''  * already 32 bpp.  It then draws the plot on the pix.
'''  *   (3) See makePlotPtaFromNumaGen() for more details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ppix"> \param[in,out]  ppix any type; replaced if not 32 bpp rgb</param>
''' <param name="na"> \param[in]      na to be plotted</param>
''' <param name="plotloc"> \param[in]      plotloc location of plot: L_PLOT_AT_TOP, etc</param>
''' <param name="linewidth"> \param[in]      linewidth width of "line" that is drawn; between 1 and 7</param>
''' <param name="max"> \param[in]      max maximum excursion in pixels from baseline</param>
''' <param name="color"> \param[in]      color plot color: 0xrrggbb00</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderPlotFromNuma")> _
Friend Shared Function pixRenderPlotFromNuma(ppix as Object, na as IntPTR, plotloc as Integer, linewidth as Integer, max as Integer, color as UInteger) as Integer
End Function

' SRC\graphics.c (1021, 1)
' makePlotPtaFromNuma()
' makePlotPtaFromNuma(NUMA *, l_int32, l_int32, l_int32, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) This generates points from %numa representing y(x) or x(y)
'''  * with respect to a pix.  A horizontal plot y(x) is drawn for
'''  * a function of column position, and a vertical plot is drawn
'''  * for a function x(y) of row position.  The baseline is located
'''  * so that all plot points will fit in the pix.
'''  *   (2) See makePlotPtaFromNumaGen() for more details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad, or NULL on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="size"> \param[in]    size pix height for horizontal plot; width for vertical plot</param>
''' <param name="plotloc"> \param[in]    plotloc location of plot: L_PLOT_AT_TOP, etc</param>
''' <param name="linewidth"> \param[in]    linewidth width of "line" that is drawn; between 1 and 7</param>
''' <param name="max"> \param[in]    max maximum excursion in pixels from baseline</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makePlotPtaFromNuma")> _
Friend Shared Function makePlotPtaFromNuma(na as IntPTR, size as Integer, plotloc as Integer, linewidth as Integer, max as Integer) as IntPTR
End Function

' SRC\graphics.c (1077, 1)
' pixRenderPlotFromNumaGen()
' pixRenderPlotFromNumaGen(PIX **, NUMA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_uint32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) General interface for plotting row or column aligned data
'''  * on a pix.
'''  *   (2) This replaces %pix with a 32 bpp rgb version if it is not
'''  * already 32 bpp.  It then draws the plot on the pix.
'''  *   (3) See makePlotPtaFromNumaGen() for other input parameters.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ppix"> \param[in,out]  ppix any type; replaced if not 32 bpp rgb</param>
''' <param name="na"> \param[in]      na to be plotted</param>
''' <param name="orient"> \param[in]      orient L_HORIZONTAL_LINE, L_VERTICAL_LINE</param>
''' <param name="linewidth"> \param[in]      linewidth width of "line" that is drawn; between 1 and 7</param>
''' <param name="refpos"> \param[in]      refpos reference position: y for horizontal and x for vertical</param>
''' <param name="max"> \param[in]      max maximum excursion in pixels from baseline</param>
''' <param name="drawref"> \param[in]      drawref 1 to draw the reference line and the normal to it</param>
''' <param name="color"> \param[in]      color plot color: 0xrrggbb00</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderPlotFromNumaGen")> _
Friend Shared Function pixRenderPlotFromNumaGen(ppix as Object, na as IntPTR, orient as Integer, linewidth as Integer, refpos as Integer, max as Integer, drawref as Integer, color as UInteger) as Integer
End Function

' SRC\graphics.c (1142, 1)
' makePlotPtaFromNumaGen()
' makePlotPtaFromNumaGen(NUMA *, l_int32, l_int32, l_int32, l_int32, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) This generates points from %numa representing y(x) or x(y)
'''  * with respect to a pix.  For y(x), we draw a horizontal line
'''  * at the reference position and a vertical line at the edge; then
'''  * we draw the values of %numa, scaled so that the maximum
'''  * excursion from the reference position is %max pixels.
'''  *   (2) The start and delx parameters of %numa are used to refer
'''  * its values to the raster lines (L_VERTICAL_LINE) or columns
'''  * (L_HORIZONTAL_LINE).
'''  *   (3) The linewidth is chosen in the interval [1 ... 7].
'''  *   (4) %refpos should be chosen so the plot is entirely within the pix
'''  * that it will be painted onto.
'''  *   (5) This would typically be used to plot, in place, a function
'''  * computed along pixel rows or columns.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad, or NULL on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="orient"> \param[in]    orient L_HORIZONTAL_LINE, L_VERTICAL_LINE</param>
''' <param name="linewidth"> \param[in]    linewidth width of "line" that is drawn; between 1 and 7</param>
''' <param name="refpos"> \param[in]    refpos reference position: y for horizontal and x for vertical</param>
''' <param name="max"> \param[in]    max maximum excursion in pixels from baseline</param>
''' <param name="drawref"> \param[in]    drawref 1 to draw the reference line and the normal to it</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makePlotPtaFromNumaGen")> _
Friend Shared Function makePlotPtaFromNumaGen(na as IntPTR, orient as Integer, linewidth as Integer, refpos as Integer, max as Integer, drawref as Integer) as IntPTR
End Function

' SRC\graphics.c (1254, 1)
' pixRenderPta()
' pixRenderPta(PIX *, PTA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) L_SET_PIXELS puts all image bits in each pixel to 1
'''  * (black for 1 bpp; white for depth > 1)
'''  *   (2) L_CLEAR_PIXELS puts all image bits in each pixel to 0
'''  * (white for 1 bpp; black for depth > 1)
'''  *   (3) L_FLIP_PIXELS reverses all image bits in each pixel
'''  *   (4) This function clips the rendering to the pix.  It performs
'''  * clipping for functions such as pixRenderLine(),
'''  * pixRenderBox() and pixRenderBoxa(), that call pixRenderPta().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  any depth, not cmapped</param>
''' <param name="pta"> \param[in]    pta  arbitrary set of points</param>
''' <param name="op"> \param[in]    op   one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderPta")> _
Friend Shared Function pixRenderPta(pix as IntPTR, pta as IntPTR, op as Integer) as Integer
End Function

' SRC\graphics.c (1343, 1)
' pixRenderPtaArb()
' pixRenderPtaArb(PIX *, PTA *, l_uint8, l_uint8, l_uint8) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If pix is colormapped, render this color (or the nearest
'''  * color if the cmap is full) on each pixel.
'''  *   (2) The rgb components have the standard dynamic range [0 ... 255]
'''  *   (3) If pix is not colormapped, do the best job you can using
'''  * the input colors:
'''  * ~ d = 1: set the pixels
'''  * ~ d = 2, 4, 8: average the input rgb value
'''  * ~ d = 32: use the input rgb value
'''  *   (4) This function clips the rendering to the pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix any depth, cmapped ok</param>
''' <param name="pta"> \param[in]    pta arbitrary set of points</param>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderPtaArb")> _
Friend Shared Function pixRenderPtaArb(pix as IntPTR, pta as IntPTR, rval as Byte, gval as Byte, bval as Byte) as Integer
End Function

' SRC\graphics.c (1418, 1)
' pixRenderPtaBlend()
' pixRenderPtaBlend(PIX *, PTA *, l_uint8, l_uint8, l_uint8, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function clips the rendering to the pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  32 bpp rgb</param>
''' <param name="pta"> \param[in]    pta  arbitrary set of points</param>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
''' <param name="gval"> \param[in]    fract</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderPtaBlend")> _
Friend Shared Function pixRenderPtaBlend(pix as IntPTR, pta as IntPTR, rval as Byte, gval as Byte, bval as Byte, fract as single) as Integer
End Function

' SRC\graphics.c (1483, 1)
' pixRenderLine()
' pixRenderLine(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  any depth, not cmapped</param>
''' <param name="x1"> \param[in]    x1, y1</param>
''' <param name="y1"> \param[in]    x2, y2</param>
''' <param name="x2"> \param[in]    width  thickness of line</param>
''' <param name="y2"> \param[in]    op  one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderLine")> _
Friend Shared Function pixRenderLine(pix as IntPTR, x1 as Integer, y1 as Integer, x2 as Integer, y2 as Integer, width as Integer, op as Integer) as Integer
End Function

' SRC\graphics.c (1523, 1)
' pixRenderLineArb()
' pixRenderLineArb(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_uint8, l_uint8, l_uint8) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix   any depth, cmapped ok</param>
''' <param name="x1"> \param[in]    x1, y1</param>
''' <param name="y1"> \param[in]    x2, y2</param>
''' <param name="x2"> \param[in]    width  thickness of line</param>
''' <param name="y2"> \param[in]    rval, gval, bval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderLineArb")> _
Friend Shared Function pixRenderLineArb(pix as IntPTR, x1 as Integer, y1 as Integer, x2 as Integer, y2 as Integer, width as Integer, rval as Byte, gval as Byte, bval as Byte) as Integer
End Function

' SRC\graphics.c (1564, 1)
' pixRenderLineBlend()
' pixRenderLineBlend(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_uint8, l_uint8, l_uint8, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  32 bpp rgb</param>
''' <param name="x1"> \param[in]    x1, y1</param>
''' <param name="y1"> \param[in]    x2, y2</param>
''' <param name="x2"> \param[in]    width  thickness of line</param>
''' <param name="y2"> \param[in]    rval, gval, bval</param>
''' <param name="width"> \param[in]    fract</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderLineBlend")> _
Friend Shared Function pixRenderLineBlend(pix as IntPTR, x1 as Integer, y1 as Integer, x2 as Integer, y2 as Integer, width as Integer, rval as Byte, gval as Byte, bval as Byte, fract as single) as Integer
End Function

' SRC\graphics.c (1604, 1)
' pixRenderBox()
' pixRenderBox(PIX *, BOX *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  any depth, not cmapped</param>
''' <param name="box"> \param[in]    box</param>
''' <param name="width"> \param[in]    width  thickness of box lines</param>
''' <param name="op"> \param[in]    op  one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderBox")> _
Friend Shared Function pixRenderBox(pix as IntPTR, box as IntPTR, width as Integer, op as Integer) as Integer
End Function

' SRC\graphics.c (1642, 1)
' pixRenderBoxArb()
' pixRenderBoxArb(PIX *, BOX *, l_int32, l_uint8, l_uint8, l_uint8) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix any depth, cmapped ok</param>
''' <param name="box"> \param[in]    box</param>
''' <param name="width"> \param[in]    width  thickness of box lines</param>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderBoxArb")> _
Friend Shared Function pixRenderBoxArb(pix as IntPTR, box as IntPTR, width as Integer, rval as Byte, gval as Byte, bval as Byte) as Integer
End Function

' SRC\graphics.c (1682, 1)
' pixRenderBoxBlend()
' pixRenderBoxBlend(PIX *, BOX *, l_int32, l_uint8, l_uint8, l_uint8, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  32 bpp rgb</param>
''' <param name="box"> \param[in]    box</param>
''' <param name="width"> \param[in]    width  thickness of box lines</param>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
''' <param name="gval"> \param[in]    fract in [0.0 - 1.0]; complete transparency (no effect</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderBoxBlend")> _
Friend Shared Function pixRenderBoxBlend(pix as IntPTR, box as IntPTR, width as Integer, rval as Byte, gval as Byte, bval as Byte, fract as single) as Integer
End Function

' SRC\graphics.c (1721, 1)
' pixRenderBoxa()
' pixRenderBoxa(PIX *, BOXA *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  any depth, not cmapped</param>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="width"> \param[in]    width  thickness of line</param>
''' <param name="op"> \param[in]    op  one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderBoxa")> _
Friend Shared Function pixRenderBoxa(pix as IntPTR, boxa as IntPTR, width as Integer, op as Integer) as Integer
End Function

' SRC\graphics.c (1759, 1)
' pixRenderBoxaArb()
' pixRenderBoxaArb(PIX *, BOXA *, l_int32, l_uint8, l_uint8, l_uint8) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  any depth; colormapped is ok</param>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="width"> \param[in]    width  thickness of line</param>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderBoxaArb")> _
Friend Shared Function pixRenderBoxaArb(pix as IntPTR, boxa as IntPTR, width as Integer, rval as Byte, gval as Byte, bval as Byte) as Integer
End Function

' SRC\graphics.c (1800, 1)
' pixRenderBoxaBlend()
' pixRenderBoxaBlend(PIX *, BOXA *, l_int32, l_uint8, l_uint8, l_uint8, l_float32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  32 bpp rgb</param>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="width"> \param[in]    width  thickness of line</param>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
''' <param name="gval"> \param[in]    fract in [0.0 - 1.0]; complete transparency (no effect</param>
''' <param name="bval"> \param[in]    removedups  1 to remove; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderBoxaBlend")> _
Friend Shared Function pixRenderBoxaBlend(pix as IntPTR, boxa as IntPTR, width as Integer, rval as Byte, gval as Byte, bval as Byte, fract as single, removedups as Integer) as Integer
End Function

' SRC\graphics.c (1843, 1)
' pixRenderHashBox()
' pixRenderHashBox(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  any depth, not cmapped</param>
''' <param name="box"> \param[in]    box</param>
''' <param name="spacing"> \param[in]    spacing spacing between lines; must be > 1</param>
''' <param name="width"> \param[in]    width  thickness of box and hash lines</param>
''' <param name="orient"> \param[in]    orient  orientation of lines: L_HORIZONTAL_LINE, ...</param>
''' <param name="outline"> \param[in]    outline  0 to skip drawing box outline</param>
''' <param name="op"> \param[in]    op  one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderHashBox")> _
Friend Shared Function pixRenderHashBox(pix as IntPTR, box as IntPTR, spacing as Integer, width as Integer, orient as Integer, outline as Integer, op as Integer) as Integer
End Function

' SRC\graphics.c (1893, 1)
' pixRenderHashBoxArb()
' pixRenderHashBoxArb(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  any depth; cmapped ok</param>
''' <param name="box"> \param[in]    box</param>
''' <param name="spacing"> \param[in]    spacing spacing between lines; must be > 1</param>
''' <param name="width"> \param[in]    width  thickness of box and hash lines</param>
''' <param name="orient"> \param[in]    orient  orientation of lines: L_HORIZONTAL_LINE, ...</param>
''' <param name="outline"> \param[in]    outline  0 to skip drawing box outline</param>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderHashBoxArb")> _
Friend Shared Function pixRenderHashBoxArb(pix as IntPTR, box as IntPTR, spacing as Integer, width as Integer, orient as Integer, outline as Integer, rval as Integer, gval as Integer, bval as Integer) as Integer
End Function

' SRC\graphics.c (1945, 1)
' pixRenderHashBoxBlend()
' pixRenderHashBoxBlend(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix   32 bpp</param>
''' <param name="box"> \param[in]    box</param>
''' <param name="spacing"> \param[in]    spacing spacing between lines; must be > 1</param>
''' <param name="width"> \param[in]    width  thickness of box and hash lines</param>
''' <param name="orient"> \param[in]    orient  orientation of lines: L_HORIZONTAL_LINE, ...</param>
''' <param name="outline"> \param[in]    outline  0 to skip drawing box outline</param>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
''' <param name="gval"> \param[in]    fract in [0.0 - 1.0]; complete transparency (no effect</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderHashBoxBlend")> _
Friend Shared Function pixRenderHashBoxBlend(pix as IntPTR, box as IntPTR, spacing as Integer, width as Integer, orient as Integer, outline as Integer, rval as Integer, gval as Integer, bval as Integer, fract as single) as Integer
End Function

' SRC\graphics.c (2003, 1)
' pixRenderHashMaskArb()
' pixRenderHashMaskArb(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place operation that renders hash lines
'''  * through a mask %pixm onto %pix.  The mask origin is
'''  * translated by (%x,%y) relative to the origin of %pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  any depth; cmapped ok</param>
''' <param name="pixm"> \param[in]    pixm  1 bpp clipping mask for hash marks</param>
''' <param name="x"> \param[in]    x,y   UL corner of %pixm with respect to %pix</param>
''' <param name="y"> \param[in]    spacing spacing between lines; must be > 1</param>
''' <param name="spacing"> \param[in]    width  thickness of box and hash lines</param>
''' <param name="width"> \param[in]    orient  orientation of lines: L_HORIZONTAL_LINE, ...</param>
''' <param name="orient"> \param[in]    outline  0 to skip drawing box outline</param>
''' <param name="outline"> \param[in]    rval, gval, bval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderHashMaskArb")> _
Friend Shared Function pixRenderHashMaskArb(pix as IntPTR, pixm as IntPTR, x as Integer, y as Integer, spacing as Integer, width as Integer, orient as Integer, outline as Integer, rval as Integer, gval as Integer, bval as Integer) as Integer
End Function

' SRC\graphics.c (2071, 1)
' pixRenderHashBoxa()
' pixRenderHashBoxa(PIX *, BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  any depth, not cmapped</param>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="spacing"> \param[in]    spacing spacing between lines; must be > 1</param>
''' <param name="width"> \param[in]    width  thickness of box and hash lines</param>
''' <param name="orient"> \param[in]    orient  orientation of lines: L_HORIZONTAL_LINE, ...</param>
''' <param name="outline"> \param[in]    outline  0 to skip drawing box outline</param>
''' <param name="op"> \param[in]    op  one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderHashBoxa")> _
Friend Shared Function pixRenderHashBoxa(pix as IntPTR, boxa as IntPTR, spacing as Integer, width as Integer, orient as Integer, outline as Integer, op as Integer) as Integer
End Function

' SRC\graphics.c (2121, 1)
' pixRenderHashBoxaArb()
' pixRenderHashBoxaArb(PIX *, BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  any depth; cmapped ok</param>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="spacing"> \param[in]    spacing spacing between lines; must be > 1</param>
''' <param name="width"> \param[in]    width  thickness of box and hash lines</param>
''' <param name="orient"> \param[in]    orient  orientation of lines: L_HORIZONTAL_LINE, ...</param>
''' <param name="outline"> \param[in]    outline  0 to skip drawing box outline</param>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderHashBoxaArb")> _
Friend Shared Function pixRenderHashBoxaArb(pix as IntPTR, boxa as IntPTR, spacing as Integer, width as Integer, orient as Integer, outline as Integer, rval as Integer, gval as Integer, bval as Integer) as Integer
End Function

' SRC\graphics.c (2173, 1)
' pixRenderHashBoxaBlend()
' pixRenderHashBoxaBlend(PIX *, BOXA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  32 bpp rgb</param>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="spacing"> \param[in]    spacing spacing between lines; must be > 1</param>
''' <param name="width"> \param[in]    width  thickness of box and hash lines</param>
''' <param name="orient"> \param[in]    orient  orientation of lines: L_HORIZONTAL_LINE, ...</param>
''' <param name="outline"> \param[in]    outline  0 to skip drawing box outline</param>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
''' <param name="gval"> \param[in]    fract in [0.0 - 1.0]; complete transparency (no effect</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderHashBoxaBlend")> _
Friend Shared Function pixRenderHashBoxaBlend(pix as IntPTR, boxa as IntPTR, spacing as Integer, width as Integer, orient as Integer, outline as Integer, rval as Integer, gval as Integer, bval as Integer, fract as single) as Integer
End Function

' SRC\graphics.c (2227, 1)
' pixRenderPolyline()
' pixRenderPolyline(PIX *, PTA *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   This renders a closed contour.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  any depth, not cmapped</param>
''' <param name="ptas"> \param[in]    ptas</param>
''' <param name="width"> \param[in]    width  thickness of line</param>
''' <param name="op"> \param[in]    op  one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
''' <param name="closeflag"> \param[in]    closeflag 1 to close the contour; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderPolyline")> _
Friend Shared Function pixRenderPolyline(pix as IntPTR, ptas as IntPTR, width as Integer, op as Integer, closeflag as Integer) as Integer
End Function

' SRC\graphics.c (2272, 1)
' pixRenderPolylineArb()
' pixRenderPolylineArb(PIX *, PTA *, l_int32, l_uint8, l_uint8, l_uint8, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   This renders a closed contour.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  any depth; cmapped ok</param>
''' <param name="ptas"> \param[in]    ptas</param>
''' <param name="width"> \param[in]    width  thickness of line</param>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
''' <param name="gval"> \param[in]    closeflag 1 to close the contour; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderPolylineArb")> _
Friend Shared Function pixRenderPolylineArb(pix as IntPTR, ptas as IntPTR, width as Integer, rval as Byte, gval as Byte, bval as Byte, closeflag as Integer) as Integer
End Function

' SRC\graphics.c (2315, 1)
' pixRenderPolylineBlend()
' pixRenderPolylineBlend(PIX *, PTA *, l_int32, l_uint8, l_uint8, l_uint8, l_float32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix  32 bpp rgb</param>
''' <param name="ptas"> \param[in]    ptas</param>
''' <param name="width"> \param[in]    width  thickness of line</param>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
''' <param name="gval"> \param[in]    fract in [0.0 - 1.0]; complete transparency (no effect</param>
''' <param name="bval"> \param[in]    closeflag 1 to close the contour; 0 otherwise</param>
''' <param name="fract"> \param[in]    removedups  1 to remove; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderPolylineBlend")> _
Friend Shared Function pixRenderPolylineBlend(pix as IntPTR, ptas as IntPTR, width as Integer, rval as Byte, gval as Byte, bval as Byte, fract as single, closeflag as Integer, removedups as Integer) as Integer
End Function

' SRC\graphics.c (2356, 1)
' pixRenderGridArb()
' pixRenderGridArb(PIX *, l_int32, l_int32, l_int32, l_uint8, l_uint8, l_uint8) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix    any depth, cmapped ok</param>
''' <param name="nx"> \param[in]    nx, ny number of rectangles in each direction</param>
''' <param name="ny"> \param[in]    width  thickness of grid lines</param>
''' <param name="width"> \param[in]    rval, gval, bval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderGridArb")> _
Friend Shared Function pixRenderGridArb(pix as IntPTR, nx as Integer, ny as Integer, width as Integer, rval as Byte, gval as Byte, bval as Byte) as Integer
End Function

' SRC\graphics.c (2416, 1)
' pixRenderRandomCmapPtaa()
' pixRenderRandomCmapPtaa(PIX *, PTAA *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a debugging routine, that displays a set of
'''  * pixels, selected by the set of Ptas in a Ptaa,
'''  * in a random color in a pix.
'''  *   (2) If %polyflag == 1, each Pta is considered to be a polyline,
'''  * and is rendered using %width and %closeflag.  Each polyline
'''  * is rendered in a random color.
'''  *   (3) If %polyflag == 0, all points in each Pta are rendered in a
'''  * random color.  The %width and %closeflag parameters are ignored.
'''  *   (4) The output pix is 8 bpp and colormapped.  Up to 254
'''  * different, randomly selected colors, can be used.
'''  *   (5) The rendered pixels replace the input pixels.  They will
'''  * be clipped silently to the input pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd cmapped, 8 bpp or NULL on error</returns>
''' <param name="pix"> \param[in]    pix 1, 2, 4, 8, 16, 32 bpp</param>
''' <param name="ptaa"> \param[in]    ptaa</param>
''' <param name="polyflag"> \param[in]    polyflag 1 to interpret each Pta as a polyline; 0 to simply</param>
''' <param name="width"> \param[in]    width  thickness of line; use only for polyline</param>
''' <param name="closeflag"> \param[in]    closeflag 1 to close the contour; 0 otherwise;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderRandomCmapPtaa")> _
Friend Shared Function pixRenderRandomCmapPtaa(pix as IntPTR, ptaa as IntPTR, polyflag as Integer, width as Integer, closeflag as Integer) as IntPTR
End Function

' SRC\graphics.c (2485, 1)
' pixRenderPolygon()
' pixRenderPolygon(PTA *, l_int32, l_int32 *, l_int32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The pix is the minimum size required to contain the origin
'''  * and the polygon.  For example, the max x value of the input
'''  * points is w - 1, where w is the pix width.
'''  *   (2) The rendered line is 4-connected, so that an interior or
'''  * exterior 8-c.c. flood fill operation works properly.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix 1 bpp, with outline generated, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas of vertices, none repeated</param>
''' <param name="width"> \param[in]    width of polygon outline</param>
''' <param name="pxmin"> \param[out]   pxmin [optional] min x value of input pts</param>
''' <param name="pymin"> \param[out]   pymin [optional] min y value of input pts</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderPolygon")> _
Friend Shared Function pixRenderPolygon(ptas as IntPTR, width as Integer, pxmin as Integer, pymin as Integer) as IntPTR
End Function

' SRC\graphics.c (2540, 1)
' pixFillPolygon()
' pixFillPolygon(PIX *, PTA *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This fills the interior of the polygon, returning a
'''  * new pix.  It works for both convex and non-convex polygons.
'''  *   (2) To generate a filled polygon from a pta:
'''  *   PIX *pixt = pixRenderPolygon(pta, 1, &xmin, &ymin);
'''  *   PIX *pixd = pixFillPolygon(pixt, pta, xmin, ymin);
'''  *   pixDestroy(&pixt);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with outline filled, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, with 4-connected polygon outline</param>
''' <param name="pta"> \param[in]    pta vertices of the polygon</param>
''' <param name="xmin"> \param[in]    xmin, ymin min values of vertices of polygon</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFillPolygon")> _
Friend Shared Function pixFillPolygon(pixs as IntPTR, pta as IntPTR, xmin as Integer, ymin as Integer) as IntPTR
End Function

' SRC\graphics.c (2619, 1)
' pixRenderContours()
' pixRenderContours(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The output can be either 1 bpp, showing just the contour
'''  * lines, or a copy of the input pixs with the contour lines
'''  * superposed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 or 16 bpp; no colormap</param>
''' <param name="startval"> \param[in]    startval value of lowest contour; must be in [0 ... maxval]</param>
''' <param name="incr"> \param[in]    incr  increment to next contour; must be > 0</param>
''' <param name="outdepth"> \param[in]    outdepth either 1 or depth of pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRenderContours")> _
Friend Shared Function pixRenderContours(pixs as IntPTR, startval as Integer, incr as Integer, outdepth as Integer) as IntPTR
End Function

' SRC\graphics.c (2745, 1)
' fpixAutoRenderContours()
' fpixAutoRenderContours(FPIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The increment is set to get approximately %ncontours.
'''  *   (2) The proximity to the target value for contour display
'''  * is set to 0.15.
'''  *   (3) Negative values are rendered in red; positive values as black.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="fpix"> \param[in]    fpix</param>
''' <param name="ncontours"> \param[in]    ncontours > 1, < 500, typ. about 50</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixAutoRenderContours")> _
Friend Shared Function fpixAutoRenderContours(fpix as IntPTR, ncontours as Integer) as IntPTR
End Function

' SRC\graphics.c (2783, 1)
' fpixRenderContours()
' fpixRenderContours(FPIX *, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Values are displayed when val/incr is within +-proxim
'''  * to an integer.  The default value is 0.15; smaller values
'''  * result in thinner contour lines.
'''  *   (2) Negative values are rendered in red; positive values as black.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="fpixs"> \param[in]    fpixs</param>
''' <param name="incr"> \param[in]    incr  increment between contours; must be > 0.0</param>
''' <param name="proxim"> \param[in]    proxim required proximity to target value; default 0.15</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixRenderContours")> _
Friend Shared Function fpixRenderContours(fpixs as IntPTR, incr as single, proxim as single) as IntPTR
End Function

' SRC\graphics.c (2862, 1)
' pixGeneratePtaBoundary()
' pixGeneratePtaBoundary(PIX *, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) Similar to ptaGetBoundaryPixels(), except here:
'''  * * we only get pixels in the foreground
'''  * * we can have a "line" width greater than 1 pixel.
'''  *   (2) Once generated, this can be applied to a random 1 bpp image
'''  * to add a color boundary as follows:
'''  * Pta *pta = pixGeneratePtaBoundary(pixs, width);
'''  * Pix *pix1 = pixConvert1To8Cmap(pixs);
'''  * pixRenderPtaArb(pix1, pta, rval, gval, bval);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="width"> \param[in]    width of boundary line</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGeneratePtaBoundary")> _
Friend Shared Function pixGeneratePtaBoundary(pixs as IntPTR, width as Integer) as IntPTR
End Function

#End Region
#Region "SRC\graymorph.c"
' SRC\graymorph.c (125, 13)
' pixErodeGray3h()
' pixErodeGray3h(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Special case for horizontal 3x1 brick Sel;
'''  * also used as the first step for the 3x3 brick Sel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixErodeGray3h")> _
Friend Shared Function pixErodeGray3h(pixs as IntPTR) as IntPTR
End Function

' SRC\graymorph.c (126, 13)
' pixErodeGray3v()
' pixErodeGray3v(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Special case for vertical 1x3 brick Sel;
'''  * also used as the second step for the 3x3 brick Sel.
'''  *   (2) Surprisingly, this is faster than setting up the
'''  * lineptrs array and accessing into it; e.g.,
'''  *  val4 = GET_DATA_BYTE(lines8[i + 3], j);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixErodeGray3v")> _
Friend Shared Function pixErodeGray3v(pixs as IntPTR) as IntPTR
End Function

' SRC\graymorph.c (127, 13)
' pixDilateGray3h()
' pixDilateGray3h(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Special case for horizontal 3x1 brick Sel;
'''  * also used as the first step for the 3x3 brick Sel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDilateGray3h")> _
Friend Shared Function pixDilateGray3h(pixs as IntPTR) as IntPTR
End Function

' SRC\graymorph.c (128, 13)
' pixDilateGray3v()
' pixDilateGray3v(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Special case for vertical 1x3 brick Sel;
'''  * also used as the second step for the 3x3 brick Sel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDilateGray3v")> _
Friend Shared Function pixDilateGray3v(pixs as IntPTR) as IntPTR
End Function

' SRC\graymorph.c (131, 13)
' dilateGrayLow()
' dilateGrayLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32, l_uint8 *, l_uint8 *) as void
''' <summary>
''' * Notes:
'''  *  (1) To eliminate border effects on the actual image, these images
'''  *   are prepared with an additional border of dimensions:
'''  *   leftpix = 0.5 * size
'''  *   rightpix = 1.5 * size
'''  *   toppix = 0.5 * size
'''  *   bottompix = 1.5 * size
'''  *   and we initialize the src border pixels to 0.
'''  *   This allows full processing over the actual image; at
'''  *   the end the border is removed.
'''  *  (2) Uses algorithm of van Herk, Gil and Werman
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="datad"> \param[in]    datad, w, h, wpld 8 bpp image</param>
''' <param name="w"> \param[in]    datas, wpls  8 bpp image, of same dimensions</param>
''' <param name="h"> \param[in]    size  full length of SEL; restricted to odd numbers</param>
''' <param name="wpld"> \param[in]    direction  L_HORIZ or L_VERT</param>
''' <param name="datas"> \param[in]    buffer  holds full line or column of src image pixels</param>
''' <param name="wpls"> \param[in]    maxarray  array of dimension 2size+1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dilateGrayLow")> _
Friend Shared Function dilateGrayLow(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, size as Integer, direction as Integer, buffer as Byte, maxarray as Byte) as Boolean ' Org. Void
End Function

' SRC\graymorph.c (135, 13)
' erodeGrayLow()
' erodeGrayLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32, l_uint8 *, l_uint8 *) as void
''' <summary>
''' * Notes:
'''  *  (1) See notes in dilateGrayLow()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="datad"> \param[in]    datad, w, h, wpld 8 bpp image</param>
''' <param name="w"> \param[in]    datas, wpls  8 bpp image, of same dimensions</param>
''' <param name="h"> \param[in]    size  full length of SEL; restricted to odd numbers</param>
''' <param name="wpld"> \param[in]    direction  L_HORIZ or L_VERT</param>
''' <param name="datas"> \param[in]    buffer  holds full line or column of src image pixels</param>
''' <param name="wpls"> \param[in]    minarray  array of dimension 2size+1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="erodeGrayLow")> _
Friend Shared Function erodeGrayLow(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, size as Integer, direction as Integer, buffer as Byte, minarray as Byte) as Boolean ' Org. Void
End Function

' SRC\graymorph.c (158, 1)
' pixErodeGray()
' pixErodeGray(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) If hsize = vsize = 1, just returns a copy.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="hsize"> \param[in]    hsize  of Sel; must be odd; origin implicitly in center</param>
''' <param name="vsize"> \param[in]    vsize  ditto</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixErodeGray")> _
Friend Shared Function pixErodeGray(pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\graymorph.c (274, 1)
' pixDilateGray()
' pixDilateGray(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) If hsize = vsize = 1, just returns a copy.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="hsize"> \param[in]    hsize  of Sel; must be odd; origin implicitly in center</param>
''' <param name="vsize"> \param[in]    vsize  ditto</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDilateGray")> _
Friend Shared Function pixDilateGray(pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\graymorph.c (390, 1)
' pixOpenGray()
' pixOpenGray(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) If hsize = vsize = 1, just returns a copy.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="hsize"> \param[in]    hsize  of Sel; must be odd; origin implicitly in center</param>
''' <param name="vsize"> \param[in]    vsize  ditto</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOpenGray")> _
Friend Shared Function pixOpenGray(pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\graymorph.c (522, 1)
' pixCloseGray()
' pixCloseGray(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) If hsize = vsize = 1, just returns a copy.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="hsize"> \param[in]    hsize  of Sel; must be odd; origin implicitly in center</param>
''' <param name="vsize"> \param[in]    vsize  ditto</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCloseGray")> _
Friend Shared Function pixCloseGray(pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\graymorph.c (661, 1)
' pixErodeGray3()
' pixErodeGray3(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
'''  *   (2) If hsize = vsize = 1, just returns a copy.
'''  *   (3) It would be nice not to add a border, but it is required
'''  * if we want the same results as from the general case.
'''  * We add 4 bytes on the left to speed up the copying, and
'''  * 8 bytes at the right and bottom to allow unrolling of
'''  * the computation of 8 pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
''' <param name="hsize"> \param[in]    hsize  1 or 3</param>
''' <param name="vsize"> \param[in]    vsize  1 or 3</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixErodeGray3")> _
Friend Shared Function pixErodeGray3(pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\graymorph.c (847, 1)
' pixDilateGray3()
' pixDilateGray3(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
'''  *   (2) If hsize = vsize = 1, just returns a copy.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
''' <param name="hsize"> \param[in]    hsize  1 or 3</param>
''' <param name="vsize"> \param[in]    vsize  1 or 3</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDilateGray3")> _
Friend Shared Function pixDilateGray3(pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\graymorph.c (1032, 1)
' pixOpenGray3()
' pixOpenGray3(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
'''  *   (2) If hsize = vsize = 1, just returns a copy.
'''  *   (3) It would be nice not to add a border, but it is required
'''  * to get the same results as for the general case.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
''' <param name="hsize"> \param[in]    hsize  1 or 3</param>
''' <param name="vsize"> \param[in]    vsize  1 or 3</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOpenGray3")> _
Friend Shared Function pixOpenGray3(pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\graymorph.c (1098, 1)
' pixCloseGray3()
' pixCloseGray3(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
'''  *   (2) If hsize = vsize = 1, just returns a copy.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
''' <param name="hsize"> \param[in]    hsize  1 or 3</param>
''' <param name="vsize"> \param[in]    vsize  1 or 3</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCloseGray3")> _
Friend Shared Function pixCloseGray3(pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

#End Region
#Region "SRC\grayquant.c"
' SRC\grayquant.c (104, 13)
' ditherToBinaryLow()
' ditherToBinaryLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_uint32 *, l_uint32 *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ditherToBinaryLow")> _
Friend Shared Function ditherToBinaryLow(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, bufs1 as UInteger, bufs2 as UInteger, lowerclip as Integer, upperclip as Integer) as Boolean ' Org. Void
End Function

' SRC\grayquant.c (108, 13)
' thresholdToBinaryLow()
' thresholdToBinaryLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="thresholdToBinaryLow")> _
Friend Shared Function thresholdToBinaryLow(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, d as Integer, wpls as Integer, thresh as Integer) as Boolean ' Org. Void
End Function

' SRC\grayquant.c (111, 13)
' ditherTo2bppLow()
' ditherTo2bppLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_uint32 *, l_uint32 *, l_int32 *, l_int32 *, l_int32 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ditherTo2bppLow")> _
Friend Shared Function ditherTo2bppLow(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, bufs1 as UInteger, bufs2 as UInteger, tabval as Integer, tab38 as Integer, tab14 as Integer) as Boolean ' Org. Void
End Function

' SRC\grayquant.c (115, 13)
' ditherTo2bppLineLow()
' ditherTo2bppLineLow(l_uint32 *, l_int32, l_uint32 *, l_uint32 *, l_int32 *, l_int32 *, l_int32 *, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="lined"> \param[in]    lined  ptr to beginning of dest line</param>
''' <param name="w"> \param[in]    w      width of image in pixels</param>
''' <param name="bufs1"> \param[in]    bufs1 buffer of current source line</param>
''' <param name="bufs2"> \param[in]    bufs2 buffer of next source line</param>
''' <param name="tabval"> \param[in]    tabval value to assign for current pixel</param>
''' <param name="tab38"> \param[in]    tab38 excess value to give to neighboring 3/8 pixels</param>
''' <param name="tab14"> \param[in]    tab14 excess value to give to neighboring 1/4 pixel</param>
''' <param name="lastlineflag"> \param[in]    lastlineflag  0 if not last dest line, 1 if last dest line</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ditherTo2bppLineLow")> _
Friend Shared Function ditherTo2bppLineLow(lined as UInteger, w as Integer, bufs1 as UInteger, bufs2 as UInteger, tabval as Integer, tab38 as Integer, tab14 as Integer, lastlineflag as Integer) as Boolean ' Org. Void
End Function

' SRC\grayquant.c (119, 16)
' make8To2DitherTables()
' make8To2DitherTables(l_int32 **, l_int32 **, l_int32 **, l_int32, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ptabval"> \param[out]  ptabval value assigned to output pixel; 0, 1, 2 or 3</param>
''' <param name="ptab38"> \param[out]  ptab38  amount propagated to pixels left and below</param>
''' <param name="ptab14"> \param[out]  ptab14  amount propagated to pixel to left and down</param>
''' <param name="cliptoblack"> \param[in]   cliptoblack values near 0 where the excess is not propagated</param>
''' <param name="cliptowhite"> \param[in]   cliptowhite values near 255 where the deficit is not propagated</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="make8To2DitherTables")> _
Friend Shared Function make8To2DitherTables(ptabval as Object, ptab38 as Object, ptab14 as Object, cliptoblack as Integer, cliptowhite as Integer) as Integer
End Function

' SRC\grayquant.c (122, 13)
' thresholdTo2bppLow()
' thresholdTo2bppLow(l_uint32 *, l_int32, l_int32, l_uint32 *, l_int32, l_int32 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="thresholdTo2bppLow")> _
Friend Shared Function thresholdTo2bppLow(datad as UInteger, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, tab as Integer) as Boolean ' Org. Void
End Function

' SRC\grayquant.c (124, 13)
' thresholdTo4bppLow()
' thresholdTo4bppLow(l_uint32 *, l_int32, l_int32, l_uint32 *, l_int32, l_int32 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="thresholdTo4bppLow")> _
Friend Shared Function thresholdTo4bppLow(datad as UInteger, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, tab as Integer) as Boolean ' Org. Void
End Function

' SRC\grayquant.c (126, 17)
' makeGrayQuantTargetTable()
' makeGrayQuantTargetTable(l_int32, l_int32) as l_int32 *
''' <summary>
''' * Notes:
'''  *   (1) nlevels is some number between 2 and 2^(depth)
'''  *   (2) The table is used in two similar ways:
'''  *  ~ for 8 bpp, it quantizes to a given number of target levels
'''  *  ~ for 2 and 4 bpp, it thresholds to appropriate target values
'''  * that will use the full dynamic range of the dest pix.
'''  *   (3) For depth = 8, the number of thresholds chosen is
'''  * ('nlevels' - 1), and the 'nlevels' values stored in the
'''  * table are at the two at the extreme ends, (0, 255), plus
'''  * plus ('nlevels' - 2) values chosen at equal intervals between.
'''  * For example, for depth = 8 and 'nlevels' = 3, the two
'''  * threshold values are 3f and bf, and the three target pixel
'''  * values are 0, 7f and ff.
'''  *   (4) For depth  8, we ignore nlevels, and always use the maximum
'''  * number of levels, which is 2^(depth).
'''  * If you want nlevels  the maximum number, you should always
'''  * use a colormap.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  table maps input gray level to thresholded gray level,</returns>
''' <param name="nlevels"> \param[in]    nlevels number of output levels</param>
''' <param name="depth"> \param[in]    depth of dest pix, in bpp; 2, 4 or 8 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeGrayQuantTargetTable")> _
Friend Shared Function makeGrayQuantTargetTable(nlevels as Integer, depth as Integer) as String
End Function

' SRC\grayquant.c (127, 16)
' makeGrayQuantColormapArb()
' makeGrayQuantColormapArb(PIX *, l_int32 *, l_int32, PIXCMAP **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) The table is a 256-entry inverse colormap: it maps input gray
'''  * level to colormap index (the bin number).  It is computed
'''  * using makeGrayQuantTableArb().
'''  *   (2) The colormap generated here has quantized values at the
'''  * average gray value of the pixels that are in each bin.
'''  *   (3) Returns an error if there are not enough levels in the
'''  * output colormap for the number of bins.  The number
'''  * of bins must not exceed 2^outdepth.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="tab"> \param[in]    tab table mapping input gray level to cmap index</param>
''' <param name="outdepth"> \param[in]    outdepth of colormap: 1, 2, 4 or 8</param>
''' <param name="pcmap"> \param[out]   pcmap colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeGrayQuantColormapArb")> _
Friend Shared Function makeGrayQuantColormapArb(pixs as IntPTR, tab as Integer, outdepth as Integer, pcmap as Object) as Integer
End Function

' SRC\grayquant.c (129, 16)
' numaFillCmapFromHisto()
' numaFillCmapFromHisto(NUMA *, PIXCMAP *, l_float32, l_int32, l_int32 **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This static function must be called from pixGrayQuantFromHisto()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na histogram of gray values</param>
''' <param name="cmap"> \param[in]    cmap 8 bpp cmap, possibly initialized with color value</param>
''' <param name="minfract"> \param[in]    minfract minimum fraction of pixels in a set of adjacent</param>
''' <param name="maxsize"> \param[in]    maxsize maximum number of adjacent bins allowed to represent</param>
''' <param name="plut"> \param[out]  plut lookup table from gray value to colormap index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaFillCmapFromHisto")> _
Friend Shared Function numaFillCmapFromHisto(na as IntPTR, cmap as IntPTR, minfract as single, maxsize as Integer, plut as Object) as Integer
End Function

' SRC\grayquant.c (171, 1)
' pixDitherToBinary()
' pixDitherToBinary(PIX *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd dithered binary, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDitherToBinary")> _
Friend Shared Function pixDitherToBinary(pixs as IntPTR) as IntPTR
End Function

' SRC\grayquant.c (203, 1)
' pixDitherToBinarySpec()
' pixDitherToBinarySpec(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See comments above in pixDitherToBinary() for details.
'''  *   (2) The input parameters lowerclip and upperclip specify the range
'''  * of lower and upper values (near 0 and 255, rsp) that are
'''  * clipped to black and white without propagating the excess.
'''  * For that reason, lowerclip and upperclip should be small numbers.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd dithered binary, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="lowerclip"> \param[in]    lowerclip lower clip distance to black; use 0 for default</param>
''' <param name="upperclip"> \param[in]    upperclip upper clip distance to white; use 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDitherToBinarySpec")> _
Friend Shared Function pixDitherToBinarySpec(pixs as IntPTR, lowerclip as Integer, upperclip as Integer) as IntPTR
End Function

' SRC\grayquant.c (322, 1)
' ditherToBinaryLineLow()
' ditherToBinaryLineLow(l_uint32 *, l_int32, l_uint32 *, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="lined"> \param[in]    lined  ptr to beginning of dest line</param>
''' <param name="w"> \param[in]    w      width of image in pixels</param>
''' <param name="bufs1"> \param[in]    bufs1 buffer of current source line</param>
''' <param name="bufs2"> \param[in]    bufs2 buffer of next source line</param>
''' <param name="lowerclip"> \param[in]    lowerclip lower clip distance to black</param>
''' <param name="upperclip"> \param[in]    upperclip upper clip distance to white</param>
''' <param name="lastlineflag"> \param[in]    lastlineflag  0 if not last dest line, 1 if last dest line</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ditherToBinaryLineLow")> _
Friend Shared Function ditherToBinaryLineLow(lined as UInteger, w as Integer, bufs1 as UInteger, bufs2 as UInteger, lowerclip as Integer, upperclip as Integer, lastlineflag as Integer) as Boolean ' Org. Void
End Function

' SRC\grayquant.c (443, 1)
' pixThresholdToBinary()
' pixThresholdToBinary(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If the source pixel is less than the threshold value,
'''  * the dest will be 1; otherwise, it will be 0.
'''  *   (2) For example, for 8 bpp src pix, if %thresh == 256, the dest
'''  * 1 bpp pix is all ones (fg), and if %thresh == 0, the dest
'''  * pix is all zeros (bg).
'''  *
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 4 or 8 bpp</param>
''' <param name="thresh"> \param[in]    thresh threshold value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixThresholdToBinary")> _
Friend Shared Function pixThresholdToBinary(pixs as IntPTR, thresh as Integer) as IntPTR
End Function

' SRC\grayquant.c (519, 1)
' 
' thresholdToBinaryLineLow(l_uint32 *, l_int32, l_uint32 *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="thresholdToBinaryLineLow")> _
Friend Shared Function thresholdToBinaryLineLow(lined as UInteger, w as Integer, lines as UInteger, d as Integer, thresh as Integer) as Boolean ' Org. Void
End Function

' SRC\grayquant.c (650, 1)
' pixVarThresholdToBinary()
' pixVarThresholdToBinary(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If the pixel in pixs is less than the corresponding pixel
'''  * in pixg, the dest will be 1; otherwise it will be 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="pixg"> \param[in]    pixg 8 bpp; contains threshold values for each pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixVarThresholdToBinary")> _
Friend Shared Function pixVarThresholdToBinary(pixs as IntPTR, pixg as IntPTR) as IntPTR
End Function

' SRC\grayquant.c (725, 1)
' pixAdaptThresholdToBinary()
' pixAdaptThresholdToBinary(PIX *, PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a simple convenience function for doing adaptive
'''  * thresholding on a grayscale image with variable background.
'''  * It uses default parameters appropriate for typical text images.
'''  *   (2) %pixm is a 1 bpp mask over "image" regions, which are not
'''  * expected to have a white background.  The mask inhibits
'''  * background finding under the fg pixels of the mask.  For
'''  * images with both text and image, the image regions would
'''  * be binarized (or quantized) by a different set of operations.
'''  *   (3) As %gamma is increased, the foreground pixels are reduced.
'''  *   (4) Under the covers:  The default background value for normalization
'''  * is 200, so we choose 170 for 'maxval' in pixGammaTRC.  Likewise,
'''  * the default foreground threshold for normalization is 60,
'''  * so we choose 50 for 'minval' in pixGammaTRC.  Because
'''  * 170 was mapped to 255, choosing 200 for the threshold is
'''  * quite safe for avoiding speckle noise from the background.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="pixm"> \param[in]    pixm [optional] 1 bpp image mask; can be null</param>
''' <param name="gamma"> \param[in]    gamma gamma correction; must be > 0.0; typically ~1.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAdaptThresholdToBinary")> _
Friend Shared Function pixAdaptThresholdToBinary(pixs as IntPTR, pixm as IntPTR, gamma as single) as IntPTR
End Function

' SRC\grayquant.c (765, 1)
' pixAdaptThresholdToBinaryGen()
' pixAdaptThresholdToBinaryGen(PIX *, PIX *, l_float32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a convenience function for doing adaptive thresholding
'''  * on a grayscale image with variable background.  Also see notes
'''  * in pixAdaptThresholdToBinary().
'''  *   (2) Reducing %gamma increases the foreground (text) pixels.
'''  * Use a low value (e.g., 0.5) for images with light text.
'''  *   (3) For normal images, see default args in pixAdaptThresholdToBinary().
'''  * For images with very light text, these values are appropriate:
'''  * gamma  ~0.5
'''  * blackval  ~70
'''  * whiteval  ~190
'''  * thresh ~200
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="pixm"> \param[in]    pixm [optional] 1 bpp image mask; can be null</param>
''' <param name="gamma"> \param[in]    gamma gamma correction; must be > 0.0; typically ~1.0</param>
''' <param name="blackval"> \param[in]    blackval dark value to set to black (0)</param>
''' <param name="whiteval"> \param[in]    whiteval light value to set to white (255)</param>
''' <param name="thresh"> \param[in]    thresh final threshold for binarization</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAdaptThresholdToBinaryGen")> _
Friend Shared Function pixAdaptThresholdToBinaryGen(pixs as IntPTR, pixm as IntPTR, gamma as single, blackval as Integer, whiteval as Integer, thresh as Integer) as IntPTR
End Function

' SRC\grayquant.c (810, 1)
' pixGenerateMaskByValue()
' pixGenerateMaskByValue(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) %val is the pixel value that we are selecting.  It can be
'''  * either a gray value or a colormap index.
'''  *   (2) If pixs is colormapped, %usecmap determines if the colormap
'''  * index values are used, or if the colormap is removed to gray and
'''  * the gray values are used.  For the latter, it generates
'''  * an approximate grayscale value for each pixel, and then looks
'''  * for gray pixels with the value %val.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 2, 4 or 8 bpp, or colormapped</param>
''' <param name="val"> \param[in]    val of pixels for which we set 1 in dest</param>
''' <param name="usecmap"> \param[in]    usecmap 1 to retain cmap values; 0 to convert to gray</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateMaskByValue")> _
Friend Shared Function pixGenerateMaskByValue(pixs as IntPTR, val as Integer, usecmap as Integer) as IntPTR
End Function

' SRC\grayquant.c (900, 1)
' pixGenerateMaskByBand()
' pixGenerateMaskByBand(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Generates a 1 bpp mask pixd, the same size as pixs, where
'''  * the fg pixels in the mask are those either within the specified
'''  * band (for inband == 1) or outside the specified band
'''  * (for inband == 0).
'''  *   (2) If pixs is colormapped, %usecmap determines if the colormap
'''  * values are used, or if the colormap is removed to gray and
'''  * the gray values are used.  For the latter, it generates
'''  * an approximate grayscale value for each pixel, and then looks
'''  * for gray pixels with the value %val.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 2, 4 or 8 bpp, or colormapped</param>
''' <param name="lower"> \param[in]    lower, upper two pixel values from which a range, either</param>
''' <param name="upper"> \param[in]    inband 1 for finding pixels in [lower, upper];</param>
''' <param name="inband"> \param[in]    usecmap 1 to retain cmap values; 0 to convert to gray</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateMaskByBand")> _
Friend Shared Function pixGenerateMaskByBand(pixs as IntPTR, lower as Integer, upper as Integer, inband as Integer, usecmap as Integer) as IntPTR
End Function

' SRC\grayquant.c (1013, 1)
' pixDitherTo2bpp()
' pixDitherTo2bpp(PIX *, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd dithered 2 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="cmapflag"> \param[in]    cmapflag 1 to generate a colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDitherTo2bpp")> _
Friend Shared Function pixDitherTo2bpp(pixs as IntPTR, cmapflag as Integer) as IntPTR
End Function

' SRC\grayquant.c (1047, 1)
' pixDitherTo2bppSpec()
' pixDitherTo2bppSpec(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See comments above in pixDitherTo2bpp() for details.
'''  *   (2) The input parameters lowerclip and upperclip specify the range
'''  * of lower and upper values (near 0 and 255, rsp) that are
'''  * clipped to black and white without propagating the excess.
'''  * For that reason, lowerclip and upperclip should be small numbers.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd dithered 2 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="lowerclip"> \param[in]    lowerclip lower clip distance to black; use 0 for default</param>
''' <param name="upperclip"> \param[in]    upperclip upper clip distance to white; use 0 for default</param>
''' <param name="cmapflag"> \param[in]    cmapflag 1 to generate a colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDitherTo2bppSpec")> _
Friend Shared Function pixDitherTo2bppSpec(pixs as IntPTR, lowerclip as Integer, upperclip as Integer, cmapflag as Integer) as IntPTR
End Function

' SRC\grayquant.c (1373, 1)
' pixThresholdTo2bpp()
' pixThresholdTo2bpp(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Valid values for nlevels is the set {2, 3, 4}.
'''  *   (2) Any colormap on the input pixs is removed to 8 bpp grayscale.
'''  *   (3) This function is typically invoked with cmapflag == 1.
'''  * In the situation where no colormap is desired, nlevels is
'''  * ignored and pixs is thresholded to 4 levels.
'''  *   (4) The target output colors are equally spaced, with the
'''  * darkest at 0 and the lightest at 255.  The thresholds are
'''  * chosen halfway between adjacent output values.  A table
'''  * is built that specifies the mapping from src to dest.
'''  *   (5) If cmapflag == 1, a colormap of size 'nlevels' is made,
'''  * and the pixel values in pixs are replaced by their
'''  * appropriate color indices.  The number of holdouts,
'''  * 4 - nlevels, will be between 0 and 2.
'''  *   (6) If you don't want the thresholding to be equally spaced,
'''  * either first transform the 8 bpp src using pixGammaTRC().
'''  * or, if cmapflag == 1, after calling this function you can use
'''  * pixcmapResetColor() to change any individual colors.
'''  *   (7) If a colormap is generated, it will specify (to display
'''  * programs) exactly how each level is to be represented in RGB
'''  * space.  When representing text, 3 levels is far better than
'''  * 2 because of the antialiasing of the single gray level,
'''  * and 4 levels (black, white and 2 gray levels) is getting
'''  * close to the perceptual quality of a (nearly continuous)
'''  * grayscale image.  With 2 bpp, you can set up a colormap
'''  * and allocate from 2 to 4 levels to represent antialiased text.
'''  * Any left over colormap entries can be used for coloring regions.
'''  * For the same number of levels, the file size of a 2 bpp image
'''  * is about 10% smaller than that of a 4 bpp result for the same
'''  * number of levels.  For both 2 bpp and 4 bpp, using 4 levels you
'''  * get compression far better than that of jpeg, because the
'''  * quantization to 4 levels will remove the jpeg ringing in the
'''  * background near character edges.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 2 bpp, optionally with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="nlevels"> \param[in]    nlevels equally spaced; must be between 2 and 4</param>
''' <param name="cmapflag"> \param[in]    cmapflag 1 to build colormap; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixThresholdTo2bpp")> _
Friend Shared Function pixThresholdTo2bpp(pixs as IntPTR, nlevels as Integer, cmapflag as Integer) as IntPTR
End Function

' SRC\grayquant.c (1515, 1)
' pixThresholdTo4bpp()
' pixThresholdTo4bpp(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Valid values for nlevels is the set {2, ... 16}.
'''  *   (2) Any colormap on the input pixs is removed to 8 bpp grayscale.
'''  *   (3) This function is typically invoked with cmapflag == 1.
'''  * In the situation where no colormap is desired, nlevels is
'''  * ignored and pixs is thresholded to 16 levels.
'''  *   (4) The target output colors are equally spaced, with the
'''  * darkest at 0 and the lightest at 255.  The thresholds are
'''  * chosen halfway between adjacent output values.  A table
'''  * is built that specifies the mapping from src to dest.
'''  *   (5) If cmapflag == 1, a colormap of size 'nlevels' is made,
'''  * and the pixel values in pixs are replaced by their
'''  * appropriate color indices.  The number of holdouts,
'''  * 16 - nlevels, will be between 0 and 14.
'''  *   (6) If you don't want the thresholding to be equally spaced,
'''  * either first transform the 8 bpp src using pixGammaTRC().
'''  * or, if cmapflag == 1, after calling this function you can use
'''  * pixcmapResetColor() to change any individual colors.
'''  *   (7) If a colormap is generated, it will specify, to display
'''  * programs, exactly how each level is to be represented in RGB
'''  * space.  When representing text, 3 levels is far better than
'''  * 2 because of the antialiasing of the single gray level,
'''  * and 4 levels (black, white and 2 gray levels) is getting
'''  * close to the perceptual quality of a (nearly continuous)
'''  * grayscale image.  Therefore, with 4 bpp, you can set up a
'''  * colormap, allocate a relatively small fraction of the 16
'''  * possible values to represent antialiased text, and use the
'''  * other colormap entries for other things, such as coloring
'''  * text or background.  Two other reasons for using a small number
'''  * of gray values for antialiased text are (1) PNG compression
'''  * gets worse as the number of levels that are used is increased,
'''  * and (2) using a small number of levels will filter out most of
'''  * the jpeg ringing that is typically introduced near sharp edges
'''  * of text.  This filtering is partly responsible for the improved
'''  * compression.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 4 bpp, optionally with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, can have colormap</param>
''' <param name="nlevels"> \param[in]    nlevels equally spaced; must be between 2 and 16</param>
''' <param name="cmapflag"> \param[in]    cmapflag 1 to build colormap; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixThresholdTo4bpp")> _
Friend Shared Function pixThresholdTo4bpp(pixs as IntPTR, nlevels as Integer, cmapflag as Integer) as IntPTR
End Function

' SRC\grayquant.c (1632, 1)
' pixThresholdOn8bpp()
' pixThresholdOn8bpp(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Valid values for nlevels is the set {2,...,256}.
'''  *   (2) Any colormap on the input pixs is removed to 8 bpp grayscale.
'''  *   (3) If cmapflag == 1, a colormap of size 'nlevels' is made,
'''  * and the pixel values in pixs are replaced by their
'''  * appropriate color indices.  Otherwise, the pixel values
'''  * are the actual thresholded (i.e., quantized) grayscale values.
'''  *   (4) If you don't want the thresholding to be equally spaced,
'''  * first transform the input 8 bpp src using pixGammaTRC().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, optionally with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, can have colormap</param>
''' <param name="nlevels"> \param[in]    nlevels equally spaced; must be between 2 and 256</param>
''' <param name="cmapflag"> \param[in]    cmapflag 1 to build colormap; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixThresholdOn8bpp")> _
Friend Shared Function pixThresholdOn8bpp(pixs as IntPTR, nlevels as Integer, cmapflag as Integer) as IntPTR
End Function

' SRC\grayquant.c (1733, 1)
' pixThresholdGrayArb()
' pixThresholdGrayArb(PIX *, const char *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function allows exact specification of the quantization bins.
'''  * The string %edgevals is a space-separated set of values
'''  * specifying the dividing points between output quantization bins.
'''  * These threshold values are assigned to the bin with higher
'''  * values, so that each of them is the smallest value in their bin.
'''  *   (2) The output image (pixd) depth is specified by %outdepth.  The
'''  * number of bins is the number of edgevals + 1.  The
'''  * relation between outdepth and the number of bins is:
'''  *   outdepth = 2 nbins = 4
'''  *   outdepth = 4 nbins = 16
'''  *   outdepth = 8 nbins = 256
'''  * With %outdepth == 0, the minimum required depth for the
'''  * given number of bins is used.
'''  * The output pixd has a colormap.
'''  *   (3) The last 3 args determine the specific values that go into
'''  * the colormap.
'''  *   (4) For %use_average:
'''  *   ~ if TRUE, the average value of pixels falling in the bin is
'''  *  chosen as the representative gray value.  Otherwise,
'''  *   ~ if FALSE, the central value of each bin is chosen as
'''  *  the representative value.
'''  * The colormap holds the representative value.
'''  *   (5) For %setblack, if TRUE the darkest color is set to (0,0,0).
'''  *   (6) For %setwhite, if TRUE the lightest color is set to (255,255,255).
'''  *   (7) An alternative to using this function to quantize to
'''  * unequally-spaced bins is to first transform the 8 bpp pixs
'''  * using pixGammaTRC(), and follow this with pixThresholdTo4bpp().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 2, 4 or 8 bpp quantized image with colormap,</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale; can have colormap</param>
''' <param name="edgevals"> \param[in]    edgevals string giving edge value of each bin</param>
''' <param name="outdepth"> \param[in]    outdepth 0, 2, 4 or 8 bpp; 0 is default for min depth</param>
''' <param name="use_average"> \param[in]    use_average 1 if use the average pixel value in colormap</param>
''' <param name="setblack"> \param[in]    setblack 1 if darkest color is set to black</param>
''' <param name="setwhite"> \param[in]    setwhite 1 if lightest color is set to white</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixThresholdGrayArb")> _
Friend Shared Function pixThresholdGrayArb(pixs as IntPTR, edgevals as String, outdepth as Integer, use_average as Integer, setblack as Integer, setwhite as Integer) as IntPTR
End Function

' SRC\grayquant.c (1843, 1)
' makeGrayQuantIndexTable()
' makeGrayQuantIndexTable(l_int32) as l_int32 *
''' <summary>
''' * Notes:
'''  *   (1) 'nlevels' is some number between 2 and 256 (typically 8 or less).
'''  *   (2) The table is typically used for quantizing 2, 4 and 8 bpp
'''  * grayscale src pix, and generating a colormapped dest pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  table maps input gray level to colormap index,</returns>
''' <param name="nlevels"> \param[in]    nlevels number of output levels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeGrayQuantIndexTable")> _
Friend Shared Function makeGrayQuantIndexTable(nlevels as Integer) as String
End Function

' SRC\grayquant.c (1952, 1)
' makeGrayQuantTableArb()
' makeGrayQuantTableArb(NUMA *, l_int32, l_int32 **, PIXCMAP **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The number of bins is the count of %na + 1.
'''  *   (2) The bin boundaries in na must be sorted in increasing order.
'''  *   (3) The table is an inverse colormap: it maps input gray level
'''  * to colormap index (the bin number).
'''  *   (4) The colormap generated here has quantized values at the
'''  * center of each bin.  If you want to use the average gray
'''  * value of pixels within the bin, discard the colormap and
'''  * compute it using makeGrayQuantColormapArb().
'''  *   (5) Returns an error if there are not enough levels in the
'''  * output colormap for the number of bins.  The number
'''  * of bins must not exceed 2^outdepth.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na numa of bin boundaries</param>
''' <param name="outdepth"> \param[in]    outdepth of colormap: 1, 2, 4 or 8</param>
''' <param name="ptab"> \param[out]   ptab table mapping input gray level to cmap index</param>
''' <param name="pcmap"> \param[out]   pcmap colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeGrayQuantTableArb")> _
Friend Shared Function makeGrayQuantTableArb(na as IntPTR, outdepth as Integer, ptab as Object, pcmap as Object) as Integer
End Function

' SRC\grayquant.c (2129, 1)
' pixGenerateMaskByBand32()
' pixGenerateMaskByBand32(PIX *, l_uint32, l_int32, l_int32, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Generates a 1 bpp mask pixd, the same size as pixs, where
'''  * the fg pixels in the mask within a band of rgb values
'''  * surrounding %refval.  The band can be chosen in two ways
'''  * for each component:
'''  * (a) Use (%delm, %delp) to specify how many levels down and up
'''  * (b) Use (%fractm, %fractp) to specify the fractional
'''  *  distance toward 0 and 255, respectively.
'''  * Note that %delm and %delp must be in [0 ... 255], whereas
'''  * %fractm and %fractp must be in [0.0 - 1.0].
'''  *   (2) Either (%delm, %delp) or (%fractm, %fractp) can be used.
'''  * Set each value in the other pair to 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="refval"> \param[in]    refval reference rgb value</param>
''' <param name="delm"> \param[in]    delm max amount below the ref value for any component</param>
''' <param name="delp"> \param[in]    delp max amount above the ref value for any component</param>
''' <param name="fractm"> \param[in]    fractm fractional amount below ref value for all components</param>
''' <param name="fractp"> \param[in]    fractp fractional amount above ref value for all components</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateMaskByBand32")> _
Friend Shared Function pixGenerateMaskByBand32(pixs as IntPTR, refval as UInteger, delm as Integer, delp as Integer, fractm as single, fractp as single) as IntPTR
End Function

' SRC\grayquant.c (2227, 1)
' pixGenerateMaskByDiscr32()
' pixGenerateMaskByDiscr32(PIX *, l_uint32, l_uint32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Generates a 1 bpp mask pixd, the same size as pixs, where
'''  * the fg pixels in the mask are those where the pixel in pixs
'''  * is "closer" to refval1 than to refval2.
'''  *   (2) "Closer" can be defined in several ways, such as:
'''  *   ~ manhattan distance (L1)
'''  *   ~ euclidean distance (L2)
'''  *   ~ majority vote of the individual components
'''  * Here, we have a choice of L1 or L2.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="refval1"> \param[in]    refval1 reference rgb value</param>
''' <param name="refval2"> \param[in]    refval2 reference rgb value</param>
''' <param name="distflag"> \param[in]    distflag L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateMaskByDiscr32")> _
Friend Shared Function pixGenerateMaskByDiscr32(pixs as IntPTR, refval1 as UInteger, refval2 as UInteger, distflag as Integer) as IntPTR
End Function

' SRC\grayquant.c (2341, 1)
' pixGrayQuantFromHisto()
' pixGrayQuantFromHisto(PIX *, PIX *, PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is useful for quantizing images with relatively few
'''  * colors, but which may have both color and gray pixels.
'''  * If there are color pixels, it is assumed that an input
'''  * rgb image has been color quantized first so that:
'''  *   ~ pixd has a colormap describing the color pixels
'''  *   ~ pixm is a mask over the non-color pixels in pixd
'''  *   ~ the colormap in pixd, and the color pixels in pixd,
'''  *  have been repacked to go from 0 to n-1 (n colors)
'''  * If there are no color pixels, pixd and pixm are both null,
'''  * and all pixels in pixs are quantized to gray.
'''  *   (2) A 256-entry histogram is built of the gray values in pixs.
'''  * If pixm exists, the pixels contributing to the histogram are
'''  * restricted to the fg of pixm.  A colormap and LUT are generated
'''  * from this histogram.  We break up the array into a set
'''  * of intervals, each one constituting a color in the colormap:
'''  * An interval is identified by summing histogram bins until
'''  * either the sum equals or exceeds the %minfract of the total
'''  * number of pixels, or the span itself equals or exceeds %maxsize.
'''  * The color of each bin is always an average of the pixels
'''  * that constitute it.
'''  *   (3) Note that we do not specify the number of gray colors in
'''  * the colormap.  Instead, we specify two parameters that
'''  * describe the accuracy of the color assignments; this and
'''  * the actual image determine the number of resulting colors.
'''  *   (4) If a mask exists and it is not the same size as pixs, make
'''  * a new mask the same size as pixs, with the original mask
'''  * aligned at the UL corners.  Set all additional pixels
'''  * in the (larger) new mask set to 1, causing those pixels
'''  * in pixd to be set as gray.
'''  *   (5) We estimate the total number of colors (color plus gray);
'''  * if it exceeds 255, return null.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, cmapped, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd [optional] quantized pix with cmap; can be null</param>
''' <param name="pixs"> \param[in]    pixs 8 bpp gray input pix; not cmapped</param>
''' <param name="pixm"> \param[in]    pixm [optional] mask over pixels in pixs to quantize</param>
''' <param name="minfract"> \param[in]    minfract minimum fraction of pixels in a set of adjacent</param>
''' <param name="maxsize"> \param[in]    maxsize maximum number of adjacent bins allowed to represent</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGrayQuantFromHisto")> _
Friend Shared Function pixGrayQuantFromHisto(pixd as IntPTR, pixs as IntPTR, pixm as IntPTR, minfract as single, maxsize as Integer) as IntPTR
End Function

' SRC\grayquant.c (2564, 1)
' pixGrayQuantFromCmap()
' pixGrayQuantFromCmap(PIX *, PIXCMAP *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) In use, pixs is an 8 bpp grayscale image without a colormap.
'''  * If there is an existing colormap, a warning is issued and
'''  * a copy of the input pixs is returned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 2, 4 or 8 bpp, colormapped, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale without cmap</param>
''' <param name="cmap"> \param[in]    cmap to quantize to; of dest pix</param>
''' <param name="mindepth"> \param[in]    mindepth minimum depth of pixd: can be 2, 4 or 8 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGrayQuantFromCmap")> _
Friend Shared Function pixGrayQuantFromCmap(pixs as IntPTR, cmap as IntPTR, mindepth as Integer) as IntPTR
End Function

#End Region
#Region "SRC\heap.c"
' SRC\heap.c (88, 16)
' lheapExtendArray()
' lheapExtendArray(L_HEAP *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="lh"> \param[in]    lh heap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lheapExtendArray")> _
Friend Shared Function lheapExtendArray(lh as IntPTR) as Integer
End Function

' SRC\heap.c (102, 1)
' lheapCreate()
' lheapCreate(l_int32, l_int32) as L_HEAP *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  lheap, or NULL on error</returns>
''' <param name="nalloc"> \param[in]    nalloc size of ptr array to be alloc'd 0 for default</param>
''' <param name="direction"> \param[in]    direction L_SORT_INCREASING, L_SORT_DECREASING</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lheapCreate")> _
Friend Shared Function lheapCreate(nalloc as Integer, direction as Integer) as IntPTR
End Function

' SRC\heap.c (145, 1)
' lheapDestroy()
' lheapDestroy(L_HEAP **, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) Use freeflag == TRUE when the items in the array can be
'''  * simply destroyed using free.  If those items require their
'''  * own destroy function, they must be destroyed before
'''  * calling this function, and then this function is called
'''  * with freeflag == FALSE.
'''  *   (2) To destroy the lheap, we destroy the ptr array, then
'''  * the lheap, and then null the contents of the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="plh"> \param[in,out]   plh  to be nulled</param>
''' <param name="freeflag"> \param[in]    freeflag TRUE to free each remaining struct in the array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lheapDestroy")> _
Friend Shared Function lheapDestroy(plh as Object, freeflag as Integer) as Boolean ' Org. Void
End Function

' SRC\heap.c (186, 1)
' lheapAdd()
' lheapAdd(L_HEAP *, void *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="lh"> \param[in]    lh heap</param>
''' <param name="item"> \param[in]    item to be added to the tail of the heap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lheapAdd")> _
Friend Shared Function lheapAdd(lh as IntPTR, item as Object) as Integer
End Function

' SRC\heap.c (242, 1)
' lheapRemove()
' lheapRemove(L_HEAP *) as void *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to item popped from the root of the heap,</returns>
''' <param name="lh"> \param[in]    lh heap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lheapRemove")> _
Friend Shared Function lheapRemove(lh as IntPTR) as String
End Function

' SRC\heap.c (271, 1)
' lheapGetCount()
' lheapGetCount(L_HEAP *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 on error</returns>
''' <param name="lh"> \param[in]    lh heap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lheapGetCount")> _
Friend Shared Function lheapGetCount(lh as IntPTR) as Integer
End Function

' SRC\heap.c (304, 1)
' lheapSwapUp()
' lheapSwapUp(L_HEAP *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is called after a new item is put on the heap, at the
'''  * bottom of a complete tree.
'''  *   (2) To regain the heap order, we let it bubble up,
'''  * iteratively swapping with its parent, until it either
'''  * reaches the root of the heap or it finds a parent that
'''  * is in the correct position already vis-a-vis the child.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="lh"> \param[in]    lh heap</param>
''' <param name="index"> \param[in]    index of array corresponding to node to be swapped up</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lheapSwapUp")> _
Friend Shared Function lheapSwapUp(lh as IntPTR, index as Integer) as Integer
End Function

' SRC\heap.c (370, 1)
' lheapSwapDown()
' lheapSwapDown(L_HEAP *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is called after an item has been popped off the
'''  * root of the heap, and the last item in the heap has
'''  * been placed at the root.
'''  *   (2) To regain the heap order, we let it bubble down,
'''  * iteratively swapping with one of its children.  For a
'''  * decreasing sort, it swaps with the largest child; for
'''  * an increasing sort, the smallest.  This continues until
'''  * it either reaches the lowest level in the heap, or the
'''  * parent finds that neither child should swap with it
'''  * (e.g., for a decreasing heap, the parent is larger
'''  * than or equal to both children).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="lh"> \param[in]    lh heap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lheapSwapDown")> _
Friend Shared Function lheapSwapDown(lh as IntPTR) as Integer
End Function

' SRC\heap.c (453, 1)
' lheapSort()
' lheapSort(L_HEAP *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This sorts an array into heap order.  If the heap is already
'''  * in heap order for the direction given, this has no effect.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="lh"> \param[in]    lh heap, with internal array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lheapSort")> _
Friend Shared Function lheapSort(lh as IntPTR) as Integer
End Function

' SRC\heap.c (487, 1)
' lheapSortStrictOrder()
' lheapSortStrictOrder(L_HEAP *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This sorts a heap into strict order.
'''  *   (2) For each element, starting at the end of the array and
'''  * working forward, the element is swapped with the head
'''  * element and then allowed to swap down onto a heap of
'''  * size reduced by one.  The result is that the heap is
'''  * reversed but in strict order.  The array elements are
'''  * then reversed to put it in the original order.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="lh"> \param[in]    lh heap, with internal array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lheapSortStrictOrder")> _
Friend Shared Function lheapSortStrictOrder(lh as IntPTR) as Integer
End Function

' SRC\heap.c (524, 1)
' lheapPrint()
' lheapPrint(FILE *, L_HEAP *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="lh"> \param[in]    lh heap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lheapPrint")> _
Friend Shared Function lheapPrint(fp as Object, lh as IntPTR) as Integer
End Function

#End Region
#Region "SRC\jbclass.c"
' SRC\jbclass.c (248, 20)
' 
' jbCorrelationInitInternal(l_int32, l_int32, l_int32, l_float32, l_float32, l_int32) as JBCLASSER *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbCorrelationInitInternal")> _
Friend Shared Function jbCorrelationInitInternal(components as Integer, maxwidth as Integer, maxheight as Integer, thresh as single, weightfactor as single, keep_components as Integer) as IntPTR
End Function

' SRC\jbclass.c (253, 20)
' findSimilarSizedTemplatesInit()
' findSimilarSizedTemplatesInit(JBCLASSER *, PIX *) as JBFINDCTX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  Allocated context to be used with findSimilar</returns>
''' <param name="classer"> \param[in]  classer</param>
''' <param name="pixs"> \param[in]  pixs     instance to be matched</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="findSimilarSizedTemplatesInit")> _
Friend Shared Function findSimilarSizedTemplatesInit(classer as IntPTR, pixs as IntPTR) as IntPTR
End Function

' SRC\jbclass.c (254, 16)
' findSimilarSizedTemplatesNext()
' findSimilarSizedTemplatesNext(JBFINDCTX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  next template number, or -1 when finished</returns>
''' <param name="context"> \param[in]   state   from findSimilarSizedTemplatesInit</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="findSimilarSizedTemplatesNext")> _
Friend Shared Function findSimilarSizedTemplatesNext(context as IntPTR) as Integer
End Function

' SRC\jbclass.c (255, 13)
' 
' findSimilarSizedTemplatesDestroy(JBFINDCTX **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="findSimilarSizedTemplatesDestroy")> _
Friend Shared Function findSimilarSizedTemplatesDestroy(pcontext as Object) as Boolean ' Org. Void
End Function

' SRC\jbclass.c (256, 16)
' finalPositioningForAlignment()
' finalPositioningForAlignment(PIX *, l_int32, l_int32, l_int32, l_int32, PIX *, l_int32 *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]  pixs          input page image</param>
''' <param name="x"> \param[in]  x, y          location of UL corner of bb of component in pixs</param>
''' <param name="y"> \param[in]  idelx, idely  compensation to match centroids of component</param>
''' <param name="idelx"> \param[in]  pixt          template, with JB_ADDED_PIXELS of padding</param>
''' <param name="idely"> \param[in]  sumtab        for summing fg pixels in an image</param>
''' <param name="pixt"> \param[in]  pdx, pdy      return delta on position for best match; each</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="finalPositioningForAlignment")> _
Friend Shared Function finalPositioningForAlignment(pixs as IntPTR, x as Integer, y as Integer, idelx as Integer, idely as Integer, pixt as IntPTR, sumtab as Integer, pdx as Integer, pdy as Integer) as Integer
End Function

' SRC\jbclass.c (283, 1)
' jbRankHausInit()
' jbRankHausInit(l_int32, l_int32, l_int32, l_int32, l_float32) as JBCLASSER *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  jbclasser if OK; NULL on error</returns>
''' <param name="components"> \param[in]  components  JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
''' <param name="maxwidth"> \param[in]  maxwidth    of component; use 0 for default</param>
''' <param name="maxheight"> \param[in]  maxheight   of component; use 0 for default</param>
''' <param name="size"> \param[in]  size        of square structuring element; 2, representing</param>
''' <param name="rank"> \param[in]    rank      rank val of match, each way; in [0.5 - 1.0];</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbRankHausInit")> _
Friend Shared Function jbRankHausInit(components as Integer, maxwidth as Integer, maxheight as Integer, size as Integer, rank as single) as IntPTR
End Function

' SRC\jbclass.c (344, 1)
' jbCorrelationInit()
' jbCorrelationInit(l_int32, l_int32, l_int32, l_float32, l_float32) as JBCLASSER *
''' <summary>
''' * Notes:
'''  *   (1) For scanned text, suggested input values are:
'''  *   thresh ~ [0.8 - 0.85]
'''  *   weightfactor ~ [0.5 - 0.6]
'''  *   (2) For electronically generated fonts (e.g., rasterized pdf),
'''  * a very high thresh (e.g., 0.95) will not cause a significant
'''  * increase in the number of classes.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  jbclasser if OK; NULL on error</returns>
''' <param name="components"> \param[in]  components    JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
''' <param name="maxwidth"> \param[in]  maxwidth      of component; use 0 for default</param>
''' <param name="maxheight"> \param[in]  maxheight     of component; use 0 for default</param>
''' <param name="thresh"> \param[in]  thresh        value for correlation score: in [0.4 - 0.98]</param>
''' <param name="weightfactor"> \param[in]  weightfactor  corrects thresh for thick characters [0.0 - 1.0]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbCorrelationInit")> _
Friend Shared Function jbCorrelationInit(components as Integer, maxwidth as Integer, maxheight as Integer, thresh as single, weightfactor as single) as IntPTR
End Function

' SRC\jbclass.c (371, 1)
' jbCorrelationInitWithoutComponents()
' jbCorrelationInitWithoutComponents(l_int32, l_int32, l_int32, l_float32, l_float32) as JBCLASSER *
''' <summary>
''' * Notes:
'''  *   Acts the same as jbCorrelationInit(), but the resulting
'''  *   object doesn't keep a list of all the components.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  jbclasser if OK; NULL on error</returns>
''' <param name="components"> \param[in]  components    JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
''' <param name="maxwidth"> \param[in]  maxwidth      of component; use 0 for default</param>
''' <param name="maxheight"> \param[in]  maxheight     of component; use 0 for default</param>
''' <param name="thresh"> \param[in]  thresh value  for correlation score: in [0.4 - 0.98]</param>
''' <param name="weightfactor"> \param[in]  weightfactor  corrects thresh for thick characters [0.0 - 1.0]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbCorrelationInitWithoutComponents")> _
Friend Shared Function jbCorrelationInitWithoutComponents(components as Integer, maxwidth as Integer, maxheight as Integer, thresh as single, weightfactor as single) as IntPTR
End Function

' SRC\jbclass.c (444, 1)
' jbAddPages()
' jbAddPages(JBCLASSER *, SARRAY *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) jbclasser makes a copy of the array of file names.
'''  *   (2) The caller is still responsible for destroying the input array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="classer"> \param[in]    jbclasser</param>
''' <param name="safiles"> \param[in]    safiles      of page image file names</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbAddPages")> _
Friend Shared Function jbAddPages(classer as IntPTR, safiles as IntPTR) as Integer
End Function

' SRC\jbclass.c (486, 1)
' jbAddPage()
' jbAddPage(JBCLASSER *, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="classer"> \param[in]    jbclasser</param>
''' <param name="pixs"> \param[in]    pixs      input page</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbAddPage")> _
Friend Shared Function jbAddPage(classer as IntPTR, pixs as IntPTR) as Integer
End Function

' SRC\jbclass.c (531, 1)
' jbAddPageComponents()
' jbAddPageComponents(JBCLASSER *, PIX *, BOXA *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If there are no components on the page, we don't require input
'''  * of empty boxas or pixas, although that's the typical situation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="classer"> \param[in]    jbclasser</param>
''' <param name="pixs"> \param[in]    pixs      input page</param>
''' <param name="boxas"> \param[in]    boxas     b.b. of components for this page</param>
''' <param name="pixas"> \param[in]    pixas     components for this page</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbAddPageComponents")> _
Friend Shared Function jbAddPageComponents(classer as IntPTR, pixs as IntPTR, boxas as IntPTR, pixas as IntPTR) as Integer
End Function

' SRC\jbclass.c (591, 1)
' jbClassifyRankHaus()
' jbClassifyRankHaus(JBCLASSER *, BOXA *, PIXA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="classer"> \param[in]    jbclasser</param>
''' <param name="boxa"> \param[in]    boxa      new components for classification</param>
''' <param name="pixas"> \param[in]    pixas     new components for classification</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbClassifyRankHaus")> _
Friend Shared Function jbClassifyRankHaus(classer as IntPTR, boxa as IntPTR, pixas as IntPTR) as Integer
End Function

' SRC\jbclass.c (845, 1)
' pixHaustest()
' pixHaustest(PIX *, PIX *, PIX *, PIX *, l_float32, l_float32, l_int32, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *  We check first that the two pix are roughly
'''  *  the same size.  Only if they meet that criterion do
'''  *  we compare the bitmaps.  The Hausdorff is a 2-way
'''  *  check.  The centroid difference is used to align the two
'''  *  images to the nearest integer for each of the checks.
'''  *  These check that the dilated image of one contains
'''  *  ALL the pixels of the undilated image of the other.
'''  *  Checks are done in both direction.  A single pixel not
'''  *  contained in either direction results in failure of the test.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 FALSE) if no match, 1 (TRUE if the new</returns>
''' <param name="pix1"> \param[in]  pix1      new pix, not dilated</param>
''' <param name="pix2"> \param[in]  pix2      new pix, dilated</param>
''' <param name="pix3"> \param[in]  pix3      exemplar pix, not dilated</param>
''' <param name="pix4"> \param[in]  pix4      exemplar pix, dilated</param>
''' <param name="delx"> \param[in]  delx      x comp of centroid difference</param>
''' <param name="dely"> \param[in]  dely      y comp of centroid difference</param>
''' <param name="maxdiffw"> \param[in]  maxdiffw  max width difference of pix1 and pix2</param>
''' <param name="maxdiffh"> \param[in]  maxdiffh  max height difference of pix1 and pix2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixHaustest")> _
Friend Shared Function pixHaustest(pix1 as IntPTR, pix2 as IntPTR, pix3 as IntPTR, pix4 as IntPTR, delx as single, dely as single, maxdiffw as Integer, maxdiffh as Integer) as Integer
End Function

' SRC\jbclass.c (943, 1)
' pixRankHaustest()
' pixRankHaustest(PIX *, PIX *, PIX *, PIX *, l_float32, l_float32, l_int32, l_int32, l_int32, l_int32, l_float32, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *  We check first that the two pix are roughly
'''  *  the same size.  Only if they meet that criterion do
'''  *  we compare the bitmaps.  We convert the rank value to
'''  *  a number of pixels by multiplying the rank fraction by the number
'''  *  of pixels in the undilated image.  The Hausdorff is a 2-way
'''  *  check.  The centroid difference is used to align the two
'''  *  images to the nearest integer for each of the checks.
'''  *  The rank hausdorff checks that the dilated image of one
'''  *  contains the rank fraction of the pixels of the undilated
'''  *  image of the other.   Checks are done in both direction.
'''  *  Failure of the test in either direction results in failure
'''  *  of the test.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 FALSE) if no match, 1 (TRUE if the new</returns>
''' <param name="pix1"> \param[in]   pix1      new pix, not dilated</param>
''' <param name="pix2"> \param[in]   pix2      new pix, dilated</param>
''' <param name="pix3"> \param[in]   pix3      exemplar pix, not dilated</param>
''' <param name="pix4"> \param[in]   pix4      exemplar pix, dilated</param>
''' <param name="delx"> \param[in]   delx      x comp of centroid difference</param>
''' <param name="dely"> \param[in]   dely      y comp of centroid difference</param>
''' <param name="maxdiffw"> \param[in]   maxdiffw  max width difference of pix1 and pix2</param>
''' <param name="maxdiffh"> \param[in]   maxdiffh  max height difference of pix1 and pix2</param>
''' <param name="area1"> \param[in]   area1     fg pixels in pix1</param>
''' <param name="area3"> \param[in]   area3     fg pixels in pix3</param>
''' <param name="rank"> \param[in]   rank      rank value of test, each way</param>
''' <param name="tab8"> \param[in]   tab8      table of pixel sums for byte</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRankHaustest")> _
Friend Shared Function pixRankHaustest(pix1 as IntPTR, pix2 as IntPTR, pix3 as IntPTR, pix4 as IntPTR, delx as single, dely as single, maxdiffw as Integer, maxdiffh as Integer, area1 as Integer, area3 as Integer, rank as single, tab8 as Integer) as Integer
End Function

' SRC\jbclass.c (1030, 1)
' jbClassifyCorrelation()
' jbClassifyCorrelation(JBCLASSER *, BOXA *, PIXA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="classer"> \param[in]   jbclasser</param>
''' <param name="boxa"> \param[in]   boxa      new components for classification</param>
''' <param name="pixas"> \param[in]   pixas     new components for classification</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbClassifyCorrelation")> _
Friend Shared Function jbClassifyCorrelation(classer as IntPTR, boxa as IntPTR, pixas as IntPTR) as Integer
End Function

' SRC\jbclass.c (1312, 1)
' jbGetComponents()
' jbGetComponents(PIX *, l_int32, l_int32, l_int32, BOXA **, PIXA **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs        1 bpp</param>
''' <param name="components"> \param[in]    components  JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
''' <param name="maxwidth"> \param[in]    maxwidth    of saved components; larger are discarded</param>
''' <param name="maxheight"> \param[in]    maxheight   of saved components; larger are discarded</param>
''' <param name="pboxad"> \param[out]   ppboxa      b.b. of component items</param>
''' <param name="ppixad"> \param[out]   pppixa      component items</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbGetComponents")> _
Friend Shared Function jbGetComponents(pixs as IntPTR, components as Integer, maxwidth as Integer, maxheight as Integer, pboxad as Object, ppixad as Object) as Integer
End Function

' SRC\jbclass.c (1454, 1)
' pixWordMaskByDilation()
' pixWordMaskByDilation(PIX *, PIX **, l_int32 *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This gives an estimate of the word masks.  See
'''  * pixWordBoxesByDilation() for further filtering of the word boxes.
'''  *   (2) The resolution should be between 75 and 150 ppi, and the optimal
'''  * dilation will be between 3 and 10.
'''  *   (3) A good size for dilating to get word masks is optionally returned.
'''  *   (4) Typically, the number of c.c. reduced with each successive
'''  * dilation (stored in nadiff) decreases quickly to a minimum
'''  * (where the characters in a word are joined), and then
'''  * increases again as the smaller number of words are joined.
'''  * For the typical case, you can then look for this minimum
'''  * and dilate to get the word mask.  However, there are many
'''  * cases where the function is not so simple. For example, if the
'''  * pix has been upscaled 2x, the nadiff function oscillates, with
'''  * every other value being zero!  And for some images it tails
'''  * off without a clear minimum to indicate where to break.
'''  * So a more simple and robust method is to find the dilation
'''  * where the initial number of c.c. has been reduced by some
'''  * fraction (we use a 70% reduction).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs    1 bpp; typ. at 75 to 150 ppi</param>
''' <param name="ppixm"> \param[out]   pmask   [optional] dilated word mask</param>
''' <param name="psize"> \param[out]   psize   [optional] size of good horizontal dilation</param>
''' <param name="pixadb"> \param[out]   pixadb  [optional] debug: pixa of intermediate steps</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWordMaskByDilation")> _
Friend Shared Function pixWordMaskByDilation(pixs as IntPTR, ppixm as Object, psize as Integer, pixadb as IntPTR) as Integer
End Function

' SRC\jbclass.c (1597, 1)
' pixWordBoxesByDilation()
' pixWordBoxesByDilation(PIX *, l_int32, l_int32, l_int32, l_int32, BOXA **, l_int32 *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Returns a pruned set of word boxes.
'''  *   (2) See pixWordMaskByDilation().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs       1 bpp; typ. 75 - 200 ppi</param>
''' <param name="minwidth"> \param[in]    minwidth   saved components; smaller are discarded</param>
''' <param name="minheight"> \param[in]    minheight  saved components; smaller are discarded</param>
''' <param name="maxwidth"> \param[in]    maxwidth   saved components; larger are discarded</param>
''' <param name="maxheight"> \param[in]    maxheight  saved components; larger are discarded</param>
''' <param name="pboxa"> \param[out]   pboxa      of dilated word mask</param>
''' <param name="psize"> \param[out]   psize      [optional] size of good horizontal dilation</param>
''' <param name="pixadb"> \param[out]   pixadb     [optional] debug: pixa of intermediate steps</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWordBoxesByDilation")> _
Friend Shared Function pixWordBoxesByDilation(pixs as IntPTR, minwidth as Integer, minheight as Integer, maxwidth as Integer, maxheight as Integer, pboxa as Object, psize as Integer, pixadb as IntPTR) as Integer
End Function

' SRC\jbclass.c (1659, 1)
' jbAccumulateComposites()
' jbAccumulateComposites(PIXAA *, NUMA **, PTA **) as PIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad accumulated sum of samples in each class, or NULL on error</returns>
''' <param name="pixaa"> \param[in]    pixaa   one pixa for each class</param>
''' <param name="pna"> \param[out]   ppna    number of samples used to build each composite</param>
''' <param name="pptat"> \param[out]   pptat   centroids of bordered composites</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbAccumulateComposites")> _
Friend Shared Function jbAccumulateComposites(pixaa as IntPTR, pna as Object, pptat as Object) as IntPTR
End Function

' SRC\jbclass.c (1749, 1)
' jbTemplatesFromComposites()
' jbTemplatesFromComposites(PIXA *, NUMA *) as PIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad 8 bpp templates for each class, or NULL on error</returns>
''' <param name="pixac"> \param[in]    pixac   one pix of composites for each class</param>
''' <param name="na"> \param[in]    na      number of samples used for each class composite</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbTemplatesFromComposites")> _
Friend Shared Function jbTemplatesFromComposites(pixac as IntPTR, na as IntPTR) as IntPTR
End Function

' SRC\jbclass.c (1794, 1)
' jbClasserCreate()
' jbClasserCreate(l_int32, l_int32) as JBCLASSER *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  jbclasser, or NULL on error</returns>
''' <param name="method"> \param[in]    method      JB_RANKHAUS, JB_CORRELATION</param>
''' <param name="components"> \param[in]    components  JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbClasserCreate")> _
Friend Shared Function jbClasserCreate(method as Integer, components as Integer) as IntPTR
End Function

' SRC\jbclass.c (1832, 1)
' 
' jbClasserDestroy(JBCLASSER **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbClasserDestroy")> _
Friend Shared Function jbClasserDestroy(pclasser as Object) as Boolean ' Org. Void
End Function

' SRC\jbclass.c (1882, 1)
' jbDataSave()
' jbDataSave(JBCLASSER *) as JBDATA *
''' <summary>
''' * Notes:
'''  *   (1) This routine stores the jbig2-type data required for
'''  * generating a lossy jbig2 version of the image.
'''  * It can be losslessly written to (and read from) two files.
'''  *   (2) It generates and stores the mosaic of templates.
'''  *   (3) It clones the Numa and Pta arrays, so these must all
'''  * be destroyed by the caller.
'''  *   (4) Input 0 to use the default values for latticew and/or latticeh,
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  jbdata, or NULL on error</returns>
''' <param name="classer"> \param[in]    jbclasser</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbDataSave")> _
Friend Shared Function jbDataSave(classer as IntPTR) as IntPTR
End Function

' SRC\jbclass.c (1922, 1)
' 
' jbDataDestroy(JBDATA **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbDataDestroy")> _
Friend Shared Function jbDataDestroy(pdata as Object) as Boolean ' Org. Void
End Function

' SRC\jbclass.c (1954, 1)
' jbDataWrite()
' jbDataWrite(const char *, JBDATA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serialization function that writes data in jbdata to file.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="rootout"> \param[in]  rootname    for output files; everything but the extension</param>
''' <param name="jbdata"> \param[in]  jbdata</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbDataWrite")> _
Friend Shared Function jbDataWrite(rootout as String, jbdata as IntPTR) as Integer
End Function

' SRC\jbclass.c (2014, 1)
' jbDataRead()
' jbDataRead(const char *) as JBDATA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  jbdata, or NULL on error</returns>
''' <param name="rootname"> \param[in]  rootname    for template and data files</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbDataRead")> _
Friend Shared Function jbDataRead(rootname as String) as IntPTR
End Function

' SRC\jbclass.c (2119, 1)
' jbDataRender()
' jbDataRender(JBDATA *, l_int32) as PIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa reconstruction of original images, using templates or</returns>
''' <param name="data"> \param[in]  jbdata</param>
''' <param name="debugflag"> \param[in]  debugflag   if TRUE, writes into 2 bpp pix and adds</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbDataRender")> _
Friend Shared Function jbDataRender(data as IntPTR, debugflag as Integer) as IntPTR
End Function

' SRC\jbclass.c (2228, 1)
' jbGetULCorners()
' jbGetULCorners(JBCLASSER *, PIX *, BOXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This computes the ptaul field, which has the global UL corners,
'''  * adjusted for each specific component, so that each component
'''  * can be replaced by the template for its class and have the
'''  * centroid in the template in the same position as the
'''  * centroid of the original connected component.  It is important
'''  * that this be done properly to avoid a wavy baseline in the
'''  * result.
'''  *   (2) The array fields ptac and ptact give the centroids of
'''  * those components relative to the UL corner of each component.
'''  * Here, we compute the difference in each component, round to
'''  * nearest integer, and correct the box->x and box->y by
'''  * the appropriate integral difference.
'''  *   (3) The templates and stored instances are all bordered.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="classer"> \param[in]  jbclasser</param>
''' <param name="pixs"> \param[in]  pixs       full res image</param>
''' <param name="boxa"> \param[in]  boxa       of c.c. bounding rectangles for this page</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbGetULCorners")> _
Friend Shared Function jbGetULCorners(classer as IntPTR, pixs as IntPTR, boxa as IntPTR) as Integer
End Function

' SRC\jbclass.c (2320, 1)
' jbGetLLCorners()
' jbGetLLCorners(JBCLASSER *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This computes the ptall field, which has the global LL corners,
'''  * adjusted for each specific component, so that each component
'''  * can be replaced by the template for its class and have the
'''  * centroid in the template in the same position as the
'''  * centroid of the original connected component. It is important
'''  * that this be done properly to avoid a wavy baseline in the result.
'''  *   (2) It is computed here from the corresponding UL corners, where
'''  * the input templates and stored instances are all bordered.
'''  * This should be done after all pages have been processed.
'''  *   (3) For proper substitution, the templates whose LL corners are
'''  * placed in these locations must be UN-bordered.
'''  * This is available for a realistic jbig2 encoder, which would
'''  * (1) encode each template without a border, and (2) encode
'''  * the position using the LL corner (rather than the UL
'''  * corner) because the difference between y-values
'''  * of successive instances is typically close to zero.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="classer"> \param[in]    jbclasser</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jbGetLLCorners")> _
Friend Shared Function jbGetLLCorners(classer as IntPTR) as Integer
End Function

#End Region
#Region "SRC\jp2kheader.c"
' SRC\jp2kheader.c (75, 1)
' readHeaderJp2k()
' readHeaderJp2k(const char *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pw"> \param[out]   pw [optional]</param>
''' <param name="ph"> \param[out]   ph [optional]</param>
''' <param name="pbps"> \param[out]   pbps [optional]  bits/sample</param>
''' <param name="pspp"> \param[out]   pspp [optional]  samples/pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readHeaderJp2k")> _
Friend Shared Function readHeaderJp2k(filename as String, pw as Integer, ph as Integer, pbps as Integer, pspp as Integer) as Integer
End Function

' SRC\jp2kheader.c (112, 1)
' freadHeaderJp2k()
' freadHeaderJp2k(FILE *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream opened for read</param>
''' <param name="pw"> \param[out]   pw [optional]</param>
''' <param name="ph"> \param[out]   ph [optional]</param>
''' <param name="pbps"> \param[out]   pbps [optional]  bits/sample</param>
''' <param name="pspp"> \param[out]   pspp [optional]  samples/pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="freadHeaderJp2k")> _
Friend Shared Function freadHeaderJp2k(fp as Object, pw as Integer, ph as Integer, pbps as Integer, pspp as Integer) as Integer
End Function

' SRC\jp2kheader.c (167, 1)
' readHeaderMemJp2k()
' readHeaderMemJp2k(const l_uint8 *, size_t, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The ISO/IEC reference for jpeg2000 is
'''  *   http://www.jpeg.org/public/15444-1annexi.pdf
'''  * and the file format syntax begins at page 127.
'''  *   (2) The Image Header Box begins with 'ihdr' = 0x69686472 in
'''  * big-endian order.  This typically, but not always, starts
'''  * byte 44, with the big-endian data fields beginning at byte 48:
'''  *   h: 4 bytes
'''  *   w: 4 bytes
'''  *   spp:  2 bytes
'''  *   bps:  1 byte   (contains bps - 1)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="data"> \param[in]    data</param>
''' <param name="size"> \param[in]    size at least 80</param>
''' <param name="pw"> \param[out]   pw [optional]</param>
''' <param name="ph"> \param[out]   ph [optional]</param>
''' <param name="pbps"> \param[out]   pbps [optional]  bits/sample</param>
''' <param name="pspp"> \param[out]   pspp [optional]  samples/pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readHeaderMemJp2k")> _
Friend Shared Function readHeaderMemJp2k(data as Byte, size as ULong, pw as Integer, ph as Integer, pbps as Integer, pspp as Integer) as Integer
End Function

' SRC\jp2kheader.c (240, 1)
' 
' fgetJp2kResolution(FILE *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fgetJp2kResolution")> _
Friend Shared Function fgetJp2kResolution(fp as Object, pxres as Integer, pyres as Integer) as Integer
End Function

#End Region
#Region "SRC\jp2kiostub.c"
' SRC\jp2kiostub.c (47, 7)
' 
' pixReadJp2k(const char *, l_uint32, BOX *, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadJp2k")> _
Friend Shared Function pixReadJp2k(filename as String, reduction as UInteger, box as IntPTR, hint as Integer, debug as Integer) as IntPTR
End Function

' SRC\jp2kiostub.c (55, 7)
' 
' pixReadStreamJp2k(FILE *, l_uint32, BOX *, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadStreamJp2k")> _
Friend Shared Function pixReadStreamJp2k(fp as Object, reduction as UInteger, box as IntPTR, hint as Integer, debug as Integer) as IntPTR
End Function

' SRC\jp2kiostub.c (63, 6)
' 
' pixWriteJp2k(const char *, PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteJp2k")> _
Friend Shared Function pixWriteJp2k(filename as String, pix as IntPTR, quality as Integer, nlevels as Integer, hint as Integer, debug as Integer) as Integer
End Function

' SRC\jp2kiostub.c (71, 6)
' 
' pixWriteStreamJp2k(FILE *, PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamJp2k")> _
Friend Shared Function pixWriteStreamJp2k(fp as Object, pix as IntPTR, quality as Integer, nlevels as Integer, hint as Integer, debug as Integer) as Integer
End Function

' SRC\jp2kiostub.c (79, 7)
' 
' pixReadMemJp2k(const l_uint8 *, size_t, l_uint32, BOX *, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadMemJp2k")> _
Friend Shared Function pixReadMemJp2k(data as Byte, size as ULong, reduction as UInteger, box as IntPTR, hint as Integer, debug as Integer) as IntPTR
End Function

' SRC\jp2kiostub.c (87, 6)
' 
' pixWriteMemJp2k(l_uint8 **, size_t *, PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMemJp2k")> _
Friend Shared Function pixWriteMemJp2k(pdata as Object, psize as ULong, pix as IntPTR, quality as Integer, nlevels as Integer, hint as Integer, debug as Integer) as Integer
End Function

#End Region
#Region "SRC\jpegio.c"
' SRC\jpegio.c (151, 13)
' 
' jpeg_error_catch_all_1(int) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jpeg_error_catch_all_1")> _
Friend Shared Function jpeg_error_catch_all_1(cinfo as Object) as Boolean ' Org. Void
End Function

' SRC\jpegio.c (152, 13)
' 
' jpeg_error_catch_all_2(int) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jpeg_error_catch_all_2")> _
Friend Shared Function jpeg_error_catch_all_2(cinfo as Object) as Boolean ' Org. Void
End Function

' SRC\jpegio.c (153, 16)
' 
' jpeg_getc(int) as l_uint8
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jpeg_getc")> _
Friend Shared Function jpeg_getc(cinfo as Object) as Byte
End Function

' SRC\jpegio.c (159, 16)
' 
' jpeg_comment_callback(int) as int
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="jpeg_comment_callback")> _
Friend Shared Function jpeg_comment_callback(cinfo as Object) as Integer
End Function

' SRC\jpegio.c (214, 1)
' pixReadJpeg()
' pixReadJpeg(const char *, l_int32, l_int32, l_int32 *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a special function for reading jpeg files.
'''  *   (2) Use this if you want the jpeg library to create
'''  * an 8 bpp colormapped image.
'''  *   (3) Images reduced by factors of 2, 4 or 8 can be returned
'''  * significantly faster than full resolution images.
'''  *   (4) If the jpeg data is bad, the jpeg library will continue
'''  * silently, or return warnings, or attempt to exit.  Depending
'''  * on the severity of the data corruption, there are two possible
'''  * outcomes:
'''  * (a) a possibly damaged pix can be generated, along with zero
'''  *  or more warnings, or
'''  * (b) the library will attempt to exit (caught by our error
'''  *  handler) and no pix will be returned.
'''  * If a pix is generated with at least one warning of data
'''  * corruption, and if L_JPEG_FAIL_ON_BAD_DATA is included in %hint,
'''  * no pix will be returned.
'''  *   (5) The possible hint values are given in the enum in imageio.h:
'''  *   * L_JPEG_READ_LUMINANCE
'''  *   * L_JPEG_FAIL_ON_BAD_DATA
'''  * Default (0) is to do neither.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="cmapflag"> \param[in]    cmapflag   0 for no colormap in returned pix;</param>
''' <param name="reduction"> \param[in]    reduction  scaling factor: 1, 2, 4 or 8</param>
''' <param name="pnwarn"> \param[out]   pnwarn     [optional] number of warnings about</param>
''' <param name="hint"> \param[in]    hint       a bitwise OR of L_JPEG_ values; 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadJpeg")> _
Friend Shared Function pixReadJpeg(filename as String, cmapflag as Integer, reduction as Integer, pnwarn as Integer, hint as Integer) as IntPTR
End Function

' SRC\jpegio.c (270, 1)
' pixReadStreamJpeg()
' pixReadStreamJpeg(FILE *, l_int32, l_int32, l_int32 *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The jpeg comment, if it exists, is not stored in the pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp         file stream</param>
''' <param name="cmapflag"> \param[in]    cmapflag   0 for no colormap in returned pix;</param>
''' <param name="reduction"> \param[in]    reduction  scaling factor: 1, 2, 4 or 8</param>
''' <param name="pnwarn"> \param[out]   pnwarn     [optional] number of warnings</param>
''' <param name="hint"> \param[in]    hint       a bitwise OR of L_JPEG_ values; 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadStreamJpeg")> _
Friend Shared Function pixReadStreamJpeg(fp as Object, cmapflag as Integer, reduction as Integer, pnwarn as Integer, hint as Integer) as IntPTR
End Function

' SRC\jpegio.c (507, 1)
' readHeaderJpeg()
' readHeaderJpeg(const char *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pw"> \param[out]   pw     [optional]</param>
''' <param name="ph"> \param[out]   ph     [optional]</param>
''' <param name="pspp"> \param[out]   pspp   [optional] samples/pixel</param>
''' <param name="pycck"> \param[out]   pycck  [optional] 1 if ycck color space; 0 otherwise</param>
''' <param name="pcmyk"> \param[out]   pcmyk  [optional] 1 if cmyk color space; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readHeaderJpeg")> _
Friend Shared Function readHeaderJpeg(filename as String, pw as Integer, ph as Integer, pspp as Integer, pycck as Integer, pcmyk as Integer) as Integer
End Function

' SRC\jpegio.c (549, 1)
' freadHeaderJpeg()
' freadHeaderJpeg(FILE *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp     file stream</param>
''' <param name="pw"> \param[out]   pw     [optional]</param>
''' <param name="ph"> \param[out]   ph     [optional]</param>
''' <param name="pspp"> \param[out]   pspp   [optional]  samples/pixel</param>
''' <param name="pycck"> \param[out]   pycck  [optional]  1 if ycck color space; 0 otherwise</param>
''' <param name="pcmyk"> \param[out]   pcmyk  [optional]  1 if cmyk color space; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="freadHeaderJpeg")> _
Friend Shared Function freadHeaderJpeg(fp as Object, pw as Integer, ph as Integer, pspp as Integer, pycck as Integer, pcmyk as Integer) as Integer
End Function

' SRC\jpegio.c (618, 1)
' 
' fgetJpegResolution(FILE *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fgetJpegResolution")> _
Friend Shared Function fgetJpegResolution(fp as Object, pxres as Integer, pyres as Integer) as Integer
End Function

' SRC\jpegio.c (678, 1)
' 
' fgetJpegComment(FILE *, l_uint8 **) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fgetJpegComment")> _
Friend Shared Function fgetJpegComment(fp as Object, pcomment as Object) as Integer
End Function

' SRC\jpegio.c (732, 1)
' pixWriteJpeg()
' pixWriteJpeg(const char *, PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pix"> \param[in]    pix           any depth; cmap is OK</param>
''' <param name="quality"> \param[in]    quality       1 - 100; 75 is default</param>
''' <param name="progressive"> \param[in]    progressive   0 for baseline sequential; 1 for progressive</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteJpeg")> _
Friend Shared Function pixWriteJpeg(filename as String, pix as IntPTR, quality as Integer, progressive as Integer) as Integer
End Function

' SRC\jpegio.c (793, 1)
' pixWriteStreamJpeg()
' pixWriteStreamJpeg(FILE *, PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Progressive encoding gives better compression, at the
'''  * expense of slower encoding and decoding.
'''  *   (2) Standard chroma subsampling is 2x2 on both the U and V
'''  * channels.  For highest quality, use no subsampling; this
'''  * option is set by pixSetChromaSampling(pix, 0).
'''  *   (3) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16
'''  * and 32 bpp.  However, it is possible, and in some cases desirable,
'''  * to write out a jpeg file using an rgb pix that has 24 bpp.
'''  * This can be created by appending the raster data for a 24 bpp
'''  * image (with proper scanline padding) directly to a 24 bpp
'''  * pix that was created without a data array.
'''  *   (4) There are two compression paths in this function:
'''  * * Grayscale image, no colormap: compress as 8 bpp image.
'''  * * rgb full color image: copy each line into the color
'''  *   line buffer, and compress as three 8 bpp images.
'''  *   (5) Under the covers, the jpeg library transforms rgb to a
'''  * luminance-chromaticity triple, each component of which is
'''  * also 8 bits, and compresses that.  It uses 2 Huffman tables,
'''  * a higher resolution one (with more quantization levels)
'''  * for luminosity and a lower resolution one for the chromas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp           file stream</param>
''' <param name="pixs"> \param[in]    pixs         any depth; cmap is OK</param>
''' <param name="quality"> \param[in]    quality      1 - 100; 75 is default value; 0 is also default</param>
''' <param name="progressive"> \param[in]    progressive  0 for baseline sequential; 1 for progressive</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamJpeg")> _
Friend Shared Function pixWriteStreamJpeg(fp as Object, pixs as IntPTR, quality as Integer, progressive as Integer) as Integer
End Function

' SRC\jpegio.c (991, 1)
' pixReadMemJpeg()
' pixReadMemJpeg(const l_uint8 *, size_t, l_int32, l_int32, l_int32 *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The %size byte of %data must be a null character.
'''  *   (2) The only hint flag so far is L_JPEG_READ_LUMINANCE,
'''  * given in the enum in imageio.h.
'''  *   (3) See pixReadJpeg() for usage.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="data"> \param[in]    data       const; jpeg-encoded</param>
''' <param name="size"> \param[in]    size       of data</param>
''' <param name="cmflag"> \param[in]    cmflag     colormap flag 0 means return RGB image if color;</param>
''' <param name="reduction"> \param[in]    reduction  scaling factor: 1, 2, 4 or 8</param>
''' <param name="pnwarn"> \param[out]   pnwarn     [optional] number of warnings</param>
''' <param name="hint"> \param[in]    hint       a bitwise OR of L_JPEG_ values; 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadMemJpeg")> _
Friend Shared Function pixReadMemJpeg(data as Byte, size as ULong, cmflag as Integer, reduction as Integer, pnwarn as Integer, hint as Integer) as IntPTR
End Function

' SRC\jpegio.c (1038, 1)
' readHeaderMemJpeg()
' readHeaderMemJpeg(const l_uint8 *, size_t, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="data"> \param[in]    data    const; jpeg-encoded</param>
''' <param name="size"> \param[in]    size    of data</param>
''' <param name="pw"> \param[out]   pw      [optional] width</param>
''' <param name="ph"> \param[out]   ph      [optional] height</param>
''' <param name="pspp"> \param[out]   pspp    [optional] samples/pixel</param>
''' <param name="pycck"> \param[out]   pycck   [optional] 1 if ycck color space; 0 otherwise</param>
''' <param name="pcmyk"> \param[out]   pcmyk   [optional] 1 if cmyk color space; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readHeaderMemJpeg")> _
Friend Shared Function readHeaderMemJpeg(data as Byte, size as ULong, pw as Integer, ph as Integer, pspp as Integer, pycck as Integer, pcmyk as Integer) as Integer
End Function

' SRC\jpegio.c (1079, 1)
' readResolutionMemJpeg()
' readResolutionMemJpeg(const l_uint8 *, size_t, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="data"> \param[in]   data    const; jpeg-encoded</param>
''' <param name="size"> \param[in]   size    of data</param>
''' <param name="pxres"> \param[out]  pxres   [optional]</param>
''' <param name="pyres"> \param[out]  pyres   [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readResolutionMemJpeg")> _
Friend Shared Function readResolutionMemJpeg(data as Byte, size as ULong, pxres as Integer, pyres as Integer) as Integer
End Function

' SRC\jpegio.c (1121, 1)
' pixWriteMemJpeg()
' pixWriteMemJpeg(l_uint8 **, size_t *, PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See pixWriteStreamJpeg() for usage.  This version writes to
'''  * memory instead of to a file stream.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata        data of jpeg compressed image</param>
''' <param name="psize"> \param[out]   psize        size of returned data</param>
''' <param name="pix"> \param[in]    pix          any depth; cmap is OK</param>
''' <param name="quality"> \param[in]    quality      1 - 100; 75 is default value; 0 is also default</param>
''' <param name="progressive"> \param[in]    progressive  0 for baseline sequential; 1 for progressive</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMemJpeg")> _
Friend Shared Function pixWriteMemJpeg(pdata as Object, psize as ULong, pix as IntPTR, quality as Integer, progressive as Integer) as Integer
End Function

' SRC\jpegio.c (1182, 1)
' pixSetChromaSampling()
' pixSetChromaSampling(PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The default is for 2x2 chroma subsampling because the files are
'''  * considerably smaller and the appearance is typically satisfactory.
'''  * To get full resolution output in the chroma channels for
'''  * jpeg writing, call this with %sampling == 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="sampling"> \param[in]    sampling    1 for subsampling; 0 for no subsampling</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetChromaSampling")> _
Friend Shared Function pixSetChromaSampling(pix as IntPTR, sampling as Integer) as Integer
End Function

#End Region
#Region "SRC\kernel.c"
' SRC\kernel.c (106, 1)
' kernelCreate()
' kernelCreate(l_int32, l_int32) as L_KERNEL *
''' <summary>
''' * Notes:
'''  *   (1) kernelCreate() initializes all values to 0.
'''  *   (2) After this call, (cy,cx) and nonzero data values must be
'''  * assigned.
'''  *   (2) The number of kernel elements must be less than 2^29.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  kernel, or NULL on error</returns>
''' <param name="height"> \param[in]    height, width</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelCreate")> _
Friend Shared Function kernelCreate(height as Integer, width as Integer) as IntPTR
End Function

' SRC\kernel.c (144, 1)
' kernelDestroy()
' kernelDestroy(L_KERNEL **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pkel"> \param[in,out]   pkel to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelDestroy")> _
Friend Shared Function kernelDestroy(pkel as Object) as Boolean ' Org. Void
End Function

' SRC\kernel.c (175, 1)
' kernelCopy()
' kernelCopy(L_KERNEL *) as L_KERNEL *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  keld copy of kels, or NULL on error</returns>
''' <param name="kels"> \param[in]    kels source kernel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelCopy")> _
Friend Shared Function kernelCopy(kels as IntPTR) as IntPTR
End Function

' SRC\kernel.c (211, 1)
' kernelGetElement()
' kernelGetElement(L_KERNEL *, l_int32, l_int32, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="kel"> \param[in]    kel</param>
''' <param name="row"> \param[in]    row</param>
''' <param name="col"> \param[in]    col</param>
''' <param name="pval"> \param[out]   pval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelGetElement")> _
Friend Shared Function kernelGetElement(kel as IntPTR, row as Integer, col as Integer, pval as single) as Integer
End Function

' SRC\kernel.c (243, 1)
' kernelSetElement()
' kernelSetElement(L_KERNEL *, l_int32, l_int32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="kel"> \param[in]    kel kernel</param>
''' <param name="row"> \param[in]    row</param>
''' <param name="col"> \param[in]    col</param>
''' <param name="val"> \param[in]    val</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelSetElement")> _
Friend Shared Function kernelSetElement(kel as IntPTR, row as Integer, col as Integer, val as single) as Integer
End Function

' SRC\kernel.c (270, 1)
' kernelGetParameters()
' kernelGetParameters(L_KERNEL *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="kel"> \param[in]    kel  kernel</param>
''' <param name="psy"> \param[out]   psy, psx, pcy, pcx [optional]  each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelGetParameters")> _
Friend Shared Function kernelGetParameters(kel as IntPTR, psy as Integer, psx as Integer, pcy as Integer, pcx as Integer) as Integer
End Function

' SRC\kernel.c (300, 1)
' kernelSetOrigin()
' kernelSetOrigin(L_KERNEL *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="kel"> \param[in]    kel  kernel</param>
''' <param name="cy"> \param[in]    cy, cx</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelSetOrigin")> _
Friend Shared Function kernelSetOrigin(kel as IntPTR, cy as Integer, cx as Integer) as Integer
End Function

' SRC\kernel.c (322, 1)
' kernelGetSum()
' kernelGetSum(L_KERNEL *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="kel"> \param[in]    kel  kernel</param>
''' <param name="psum"> \param[out]   psum sum of all kernel values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelGetSum")> _
Friend Shared Function kernelGetSum(kel as IntPTR, psum as single) as Integer
End Function

' SRC\kernel.c (354, 1)
' kernelGetMinMax()
' kernelGetMinMax(L_KERNEL *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="kel"> \param[in]    kel  kernel</param>
''' <param name="pmin"> \param[out]   pmin [optional] minimum value</param>
''' <param name="pmax"> \param[out]   pmax [optional] maximum value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelGetMinMax")> _
Friend Shared Function kernelGetMinMax(kel as IntPTR, pmin as single, pmax as single) as Integer
End Function

' SRC\kernel.c (410, 1)
' kernelNormalize()
' kernelNormalize(L_KERNEL *, l_float32) as L_KERNEL *
''' <summary>
''' * Notes:
'''  *   (1) If the sum of kernel elements is close to 0, do not
'''  * try to calculate the normalized kernel.  Instead,
'''  * return a copy of the input kernel, with a warning.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  keld normalized version of kels, or NULL on error</returns>
''' <param name="kels"> \param[in]    kels source kel, to be normalized</param>
''' <param name="normsum"> \param[in]    normsum desired sum of elements in keld</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelNormalize")> _
Friend Shared Function kernelNormalize(kels as IntPTR, normsum as single) as IntPTR
End Function

' SRC\kernel.c (456, 1)
' kernelInvert()
' kernelInvert(L_KERNEL *) as L_KERNEL *
''' <summary>
''' * Notes:
'''  *   (1) For convolution, the kernel is spatially inverted before
'''  * a "correlation" operation is done between the kernel and the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  keld spatially inverted, about the origin, or NULL on error</returns>
''' <param name="kels"> \param[in]    kels source kel, to be inverted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelInvert")> _
Friend Shared Function kernelInvert(kels as IntPTR) as IntPTR
End Function

' SRC\kernel.c (499, 1)
' create2dFloatArray()
' create2dFloatArray(l_int32, l_int32) as l_float32 **
''' <summary>
''' * Notes:
'''  *   (1) The array[sy][sx] is indexed in standard "matrix notation",
'''  * with the row index first.
'''  *   (2) The caller kernelCreate() limits the size to  2^29 pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  doubly indexed array i.e., an array of sy row pointers,</returns>
''' <param name="sy"> \param[in]    sy rows == height</param>
''' <param name="sx"> \param[in]    sx columns == width</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="create2dFloatArray")> _
Friend Shared Function create2dFloatArray(sy as Integer, sx as Integer) as String
End Function

' SRC\kernel.c (526, 1)
' kernelRead()
' kernelRead(const char *) as L_KERNEL *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  kernel, or NULL on error</returns>
''' <param name="fname"> \param[in]    fname filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelRead")> _
Friend Shared Function kernelRead(fname as String) as IntPTR
End Function

' SRC\kernel.c (555, 1)
' kernelReadStream()
' kernelReadStream(FILE *) as L_KERNEL *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  kernel, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelReadStream")> _
Friend Shared Function kernelReadStream(fp as Object) as IntPTR
End Function

' SRC\kernel.c (598, 1)
' kernelWrite()
' kernelWrite(const char *, L_KERNEL *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fname"> \param[in]    fname output file</param>
''' <param name="kel"> \param[in]    kel kernel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelWrite")> _
Friend Shared Function kernelWrite(fname as String, kel as IntPTR) as Integer
End Function

' SRC\kernel.c (627, 1)
' kernelWriteStream()
' kernelWriteStream(FILE *, L_KERNEL *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="kel"> \param[in]    kel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelWriteStream")> _
Friend Shared Function kernelWriteStream(fp as Object, kel as IntPTR) as Integer
End Function

' SRC\kernel.c (679, 1)
' kernelCreateFromString()
' kernelCreateFromString(l_int32, l_int32, l_int32, l_int32, const char *) as L_KERNEL *
''' <summary>
''' * Notes:
'''  *   (1) The data is an array of chars, in row-major order, giving
'''  * space separated integers in the range [-255 ... 255].
'''  *   (2) The only other formatting limitation is that you must
'''  * leave space between the last number in each row and
'''  * the double-quote.  If possible, it's also nice to have each
'''  * line in the string represent a line in the kernel; e.g.,
'''  *  static const char *kdata =
'''  *   " 20   50   20 "
'''  *   " 70  140   70 "
'''  *   " 20   50   20 ";
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  kernel of the given size, or NULL on error</returns>
''' <param name="h"> \param[in]    h, w     height, width</param>
''' <param name="w"> \param[in]    cy, cx   origin</param>
''' <param name="cy"> \param[in]    kdata</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelCreateFromString")> _
Friend Shared Function kernelCreateFromString(h as Integer, w as Integer, cy as Integer, cx as Integer, kdata as String) as IntPTR
End Function

' SRC\kernel.c (765, 1)
' kernelCreateFromFile()
' kernelCreateFromFile(const char *) as L_KERNEL *
''' <summary>
''' * Notes:
'''  *   (1) The file contains, in the following order:
'''  *  ~ Any number of comment lines starting with '#' are ignored
'''  *  ~ The height and width of the kernel
'''  *  ~ The y and x values of the kernel origin
'''  *  ~ The kernel data, formatted as lines of numbers (integers
'''  * or floats) for the kernel values in row-major order,
'''  * and with no other punctuation.
'''  * (Note: this differs from kernelCreateFromString(),
'''  * where each line must begin and end with a double-quote
'''  * to tell the compiler it's part of a string.)
'''  *  ~ The kernel specification ends when a blank line,
'''  * a comment line, or the end of file is reached.
'''  *   (2) All lines must be left-justified.
'''  *   (3) See kernelCreateFromString() for a description of the string
'''  * format for the kernel data.  As an example, here are the lines
'''  * of a valid kernel description file  In the file, all lines
'''  * are left-justified:
'''  * \code
'''  *  # small 3x3 kernel
'''  *  3 3
'''  *  1 1
'''  *  25.5   51 24.3
'''  *  70.2  146.3  73.4
'''  *  20  50.9  18.4
'''  * \endcode
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  kernel, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelCreateFromFile")> _
Friend Shared Function kernelCreateFromFile(filename as String) as IntPTR
End Function

' SRC\kernel.c (865, 1)
' kernelCreateFromPix()
' kernelCreateFromPix(PIX *, l_int32, l_int32) as L_KERNEL *
''' <summary>
''' * Notes:
'''  *   (1) The origin must be positive and within the dimensions of the pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  kernel, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="cy"> \param[in]    cy, cx origin of kernel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelCreateFromPix")> _
Friend Shared Function kernelCreateFromPix(pix as IntPTR, cy as Integer, cx as Integer) as IntPTR
End Function

' SRC\kernel.c (926, 1)
' kernelDisplayInPix()
' kernelDisplayInPix(L_KERNEL *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This gives a visual representation of a kernel.
'''  *   (2) There are two modes of display:
'''  * (a) Grid lines of minimum width 2, surrounding regions
'''  *  representing kernel elements of minimum size 17,
'''  *  with a "plus" mark at the kernel origin, or
'''  * (b) A pix without grid lines and using 1 pixel per kernel element.
'''  *   (3) For both cases, the kernel absolute value is displayed,
'''  * normalized such that the maximum absolute value is 255.
'''  *   (4) Large 2D separable kernels should be used for convolution
'''  * with two 1D kernels.  However, for the bilateral filter,
'''  * the computation time is independent of the size of the
'''  * 2D content kernel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix display of kernel, or NULL on error</returns>
''' <param name="kel"> \param[in]    kel kernel</param>
''' <param name="size"> \param[in]    size of grid interiors; odd; either 1 or a minimum size</param>
''' <param name="gthick"> \param[in]    gthick grid thickness; either 0 or a minimum size of 2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="kernelDisplayInPix")> _
Friend Shared Function kernelDisplayInPix(kel as IntPTR, size as Integer, gthick as Integer) as IntPTR
End Function

' SRC\kernel.c (1040, 1)
' parseStringForNumbers()
' parseStringForNumbers(const char *, const char *) as NUMA *
''' <summary>
''' * Notes:
'''  *  (1) The numbers can be ints or floats.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa of numbers found, or NULL on error</returns>
''' <param name="str"> \param[in]    str string containing numbers; not changed</param>
''' <param name="seps"> \param[in]    seps string of characters that can be used between ints</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="parseStringForNumbers")> _
Friend Shared Function parseStringForNumbers(str as String, seps as String) as IntPTR
End Function

' SRC\kernel.c (1092, 1)
' makeFlatKernel()
' makeFlatKernel(l_int32, l_int32, l_int32, l_int32) as L_KERNEL *
''' <summary>
''' * Notes:
'''  *   (1) This is the same low-pass filtering kernel that is used
'''  * in the block convolution functions.
'''  *   (2) The kernel origin (%cy, %cx) is typically placed as near
'''  * the center of the kernel as possible.  If height and
'''  * width are odd, then using cy = height / 2 and
'''  * cx = width / 2 places the origin at the exact center.
'''  *   (3) This returns a normalized kernel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  kernel, or NULL on error</returns>
''' <param name="height"> \param[in]    height, width</param>
''' <param name="width"> \param[in]    cy, cx origin of kernel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeFlatKernel")> _
Friend Shared Function makeFlatKernel(height as Integer, width as Integer, cy as Integer, cx as Integer) as IntPTR
End Function

' SRC\kernel.c (1137, 1)
' makeGaussianKernel()
' makeGaussianKernel(l_int32, l_int32, l_float32, l_float32) as L_KERNEL *
''' <summary>
''' * Notes:
'''  *   (1) The kernel size (sx, sy) = (2 * halfwidth + 1, 2 * halfheight + 1).
'''  *   (2) The kernel center (cx, cy) = (halfwidth, halfheight).
'''  *   (3) The halfwidth and halfheight are typically equal, and
'''  * are typically several times larger than the standard deviation.
'''  *   (4) If pixConvolve() is invoked with normalization (the sum of
'''  * kernel elements = 1.0), use 1.0 for max (or any number that's
'''  * not too small or too large).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  kernel, or NULL on error</returns>
''' <param name="halfheight"> \param[in]    halfheight, halfwidth sx = 2  halfwidth + 1, etc</param>
''' <param name="halfwidth"> \param[in]    stdev standard deviation</param>
''' <param name="stdev"> \param[in]    max value at (cx,cy)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeGaussianKernel")> _
Friend Shared Function makeGaussianKernel(halfheight as Integer, halfwidth as Integer, stdev as single, max as single) as IntPTR
End Function

' SRC\kernel.c (1191, 1)
' makeGaussianKernelSep()
' makeGaussianKernelSep(l_int32, l_int32, l_float32, l_float32, L_KERNEL **, L_KERNEL **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See makeGaussianKernel() for description of input parameters.
'''  *   (2) These kernels are constructed so that the result of both
'''  * normalized and un-normalized convolution will be the same
'''  * as when convolving with pixConvolve() using the full kernel.
'''  *   (3) The trick for the un-normalized convolution is to have the
'''  * product of the two kernel elemets at (cx,cy) be equal to max,
'''  * not max**2.  That's why the max for kely is 1.0.  If instead
'''  * we use sqrt(max) for both, the results are slightly less
'''  * accurate, when compared to using the full kernel in
'''  * makeGaussianKernel().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="halfheight"> \param[in]    halfheight, halfwidth sx = 2  halfwidth + 1, etc</param>
''' <param name="halfwidth"> \param[in]    stdev standard deviation</param>
''' <param name="stdev"> \param[in]    max value at (cx,cy)</param>
''' <param name="max"> \param[out]   pkelx x part of kernel</param>
''' <param name="pkelx"> \param[out]   pkely y part of kernel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeGaussianKernelSep")> _
Friend Shared Function makeGaussianKernelSep(halfheight as Integer, halfwidth as Integer, stdev as single, max as single, pkelx as Object, pkely as Object) as Integer
End Function

' SRC\kernel.c (1236, 1)
' makeDoGKernel()
' makeDoGKernel(l_int32, l_int32, l_float32, l_float32) as L_KERNEL *
''' <summary>
''' * Notes:
'''  *   (1) The DoG (difference of gaussians) is a wavelet mother
'''  * function with null total sum.  By subtracting two blurred
'''  * versions of the image, it acts as a bandpass filter for
'''  * frequencies passed by the narrow gaussian but stopped
'''  * by the wide one.See:
'''  *   http://en.wikipedia.org/wiki/Difference_of_Gaussians
'''  *   (2) The kernel size (sx, sy) = (2 * halfwidth + 1, 2 * halfheight + 1).
'''  *   (3) The kernel center (cx, cy) = (halfwidth, halfheight).
'''  *   (4) The halfwidth and halfheight are typically equal, and
'''  * are typically several times larger than the standard deviation.
'''  *   (5) The ratio is the ratio of standard deviations of the wide
'''  * to narrow gaussian.  It must be >= 1.0; 1.0 is a no-op.
'''  *   (6) Because the kernel is a null sum, it must be invoked without
'''  * normalization in pixConvolve().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  kernel, or NULL on error</returns>
''' <param name="halfheight"> \param[in]    halfheight, halfwidth sx = 2  halfwidth + 1, etc</param>
''' <param name="halfwidth"> \param[in]    stdev standard deviation of narrower gaussian</param>
''' <param name="stdev"> \param[in]    ratio of stdev for wide filter to stdev for narrow one</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeDoGKernel")> _
Friend Shared Function makeDoGKernel(halfheight as Integer, halfwidth as Integer, stdev as single, ratio as single) as IntPTR
End Function

#End Region
#Region "SRC\leptwin.c"
' SRC\leptwin.c (67, 1)
' 
' DSImageBitsSize(LPBITMAPINFO) as DWORD
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="DSImageBitsSize")> _
Friend Shared Function DSImageBitsSize(pbmi as Object) as Object
End Function

' SRC\leptwin.c (101, 1)
' 
' ImageBitsSize(HBITMAP) as DWORD
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ImageBitsSize")> _
Friend Shared Function ImageBitsSize(hBitmap as Object) as Object
End Function

' SRC\leptwin.c (132, 1)
' setColormap(LPBITMAPINFO pbmi, PIXCMAP cmap)
' setColormap(LPBITMAPINFO, PIXCMAP *) as int
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  number of colors in cmap</returns>
''' <param name="pbmi"> \param[in]    pbmi pointer to a BITMAPINFO describing a DIB</param>
''' <param name="cmap"> \param[in]    cmap leptonica colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="setColormap")> _
Friend Shared Function setColormap(pbmi as Object, cmap as IntPTR) as Integer
End Function

' SRC\leptwin.c (168, 1)
' 
' DSCreateBitmapInfo(l_int32, l_int32, l_int32, PIXCMAP *) as LPBITMAPINFO
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="DSCreateBitmapInfo")> _
Friend Shared Function DSCreateBitmapInfo(width as Integer, height as Integer, depth as Integer, cmap as IntPTR) as Object
End Function

' SRC\leptwin.c (263, 1)
' 
' DSCreateDIBSection(l_int32, l_int32, l_int32, PIXCMAP *) as HBITMAP
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="DSCreateDIBSection")> _
Friend Shared Function DSCreateDIBSection(width as Integer, height as Integer, depth as Integer, cmap as IntPTR) as Object
End Function

' SRC\leptwin.c (303, 1)
' pixGetWindowsHBITMAP()
' pixGetWindowsHBITMAP(PIX *) as HBITMAP
''' <summary>
''' * Notes:
'''  *   (1) It's the responsibility of the caller to destroy the
'''  * returned hBitmap with a call to DeleteObject (or with
'''  * something that eventually calls DeleteObject).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  Windows hBitmap, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetWindowsHBITMAP")> _
Friend Shared Function pixGetWindowsHBITMAP(pix as IntPTR) as Object
End Function

#End Region
#Region "SRC\libversions.c"
' SRC\libversions.c (101, 1)
' getImagelibVersions()
' getImagelibVersions() as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getImagelibVersions")> _
Friend Shared Function getImagelibVersions() as String
End Function

#End Region
#Region "SRC\list.c"
' SRC\list.c (236, 1)
' listDestroy()
' listDestroy(DLLIST **) as void
''' <summary>
''' * Notes:
'''  *   (1) This only destroys the cons cells.  Before destroying
'''  * the list, it is necessary to remove all data and set the
'''  * data pointers in each cons cell to NULL.
'''  *   (2) listDestroy() will give a warning message for each data
'''  * ptr that is not NULL.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="phead"> \param[in,out]   phead   to be nulled; head of list</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="listDestroy")> _
Friend Shared Function listDestroy(phead as Object) as Boolean ' Org. Void
End Function

' SRC\list.c (277, 1)
' listAddToHead()
' listAddToHead(DLLIST **, void *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This makes a new cell, attaches the data, and adds the
'''  * cell to the head of the list.
'''  *   (2) When consing from NULL, be sure to initialize head to NULL
'''  * before calling this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="phead"> \param[in,out]   phead  [optional] input head</param>
''' <param name="data"> \param[in]    data  void ptr, to be added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="listAddToHead")> _
Friend Shared Function listAddToHead(phead as Object, data as Object) as Integer
End Function

' SRC\list.c (331, 1)
' listAddToTail()
' listAddToTail(DLLIST **, DLLIST **, void *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This makes a new cell, attaches the data, and adds the
'''  * cell to the tail of the list.
'''  *   (2) &head is input to allow the list to be "cons'd" up from NULL.
'''  *   (3) &tail is input to allow the tail to be updated
'''  * for efficient sequential operation with this function.
'''  *   (4) We assume that if *phead and/or *ptail are not NULL,
'''  * then they are valid addresses.  Therefore:
'''  *  (a) when consing from NULL, be sure to initialize both
'''  *   head and tail to NULL.
'''  *  (b) when tail == NULL for an existing list, the tail
'''  *   will be found and updated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="phead"> \param[in,out]   phead  [may be updated], can be NULL</param>
''' <param name="ptail"> \param[in,out]   ptail  [updated], can be NULL</param>
''' <param name="data"> \param[in]    data  void ptr, to be hung on tail cons cell</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="listAddToTail")> _
Friend Shared Function listAddToTail(phead as Object, ptail as Object, data as Object) as Integer
End Function

' SRC\list.c (394, 1)
' listInsertBefore()
' listInsertBefore(DLLIST **, DLLIST *, void *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This can be called on a null list, in which case both
'''  * head and elem must be null.
'''  *   (2) If you are searching through a list, looking for a condition
'''  * to add an element, you can do something like this:
'''  * \code
'''  *   L_BEGIN_LIST_FORWARD(head, elem)
'''  * identify an elem to insert before>
'''  * listInsertBefore(&head, elem, data);
'''  *   L_END_LIST
'''  * \endcode
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="phead"> \param[in,out]   phead  [optional] input head</param>
''' <param name="elem"> \param[in]     elem  list element to be inserted in front of;</param>
''' <param name="data"> \param[in]     data  void  address, to be added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="listInsertBefore")> _
Friend Shared Function listInsertBefore(phead as Object, elem as IntPTR, data as Object) as Integer
End Function

' SRC\list.c (459, 1)
' listInsertAfter()
' listInsertAfter(DLLIST **, DLLIST *, void *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This can be called on a null list, in which case both
'''  * head and elem must be null.  The head is included
'''  * in the call to allow "consing" up from NULL.
'''  *   (2) If you are searching through a list, looking for a condition
'''  * to add an element, you can do something like this:
'''  * \code
'''  *   L_BEGIN_LIST_FORWARD(head, elem)
'''  * identify an elem to insert after>
'''  * listInsertAfter(&head, elem, data);
'''  *   L_END_LIST
'''  * \endcode
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="phead"> \param[in,out]   phead  [optional] input head</param>
''' <param name="elem"> \param[in]     elem  list element to be inserted after;</param>
''' <param name="data"> \param[in]     data  void  ptr, to be added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="listInsertAfter")> _
Friend Shared Function listInsertAfter(phead as Object, elem as IntPTR, data as Object) as Integer
End Function

' SRC\list.c (514, 1)
' listRemoveElement()
' listRemoveElement(DLLIST **, DLLIST *) as void *
''' <summary>
''' * Notes:
'''  *   (1) in ANSI C, it is not necessary to cast return to actual type; e.g.,
'''  * pix = listRemoveElement(&head, elem);
'''  * but in ANSI C++, it is necessary to do the cast:
'''  * pix = (Pix *)listRemoveElement(&head, elem);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data  void struct on cell</returns>
''' <param name="phead"> \param[in,out]   phead [can be changed] input head</param>
''' <param name="elem"> \param[in]    elem list element to be removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="listRemoveElement")> _
Friend Shared Function listRemoveElement(phead as Object, elem as IntPTR) as String
End Function

' SRC\list.c (566, 1)
' listRemoveFromHead()
' listRemoveFromHead(DLLIST **) as void *
''' <summary>
''' * Notes:
'''  *   (1) in ANSI C, it is not necessary to cast return to actual type; e.g.,
'''  *   pix = listRemoveFromHead(&head);
'''  * but in ANSI C++, it is necessary to do the cast; e.g.,
'''  *   pix = (Pix *)listRemoveFromHead(&head);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data  void struct on cell, or NULL on error</returns>
''' <param name="phead"> \param[in,out]   phead head of list [to be updated]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="listRemoveFromHead")> _
Friend Shared Function listRemoveFromHead(phead as Object) as String
End Function

' SRC\list.c (614, 1)
' listRemoveFromTail()
' listRemoveFromTail(DLLIST **, DLLIST **) as void *
''' <summary>
''' * Notes:
'''  *   (1) We include &head so that it can be set to NULL if
'''  * if the only element in the list is removed.
'''  *   (2) The function is relying on the fact that if tail is
'''  * not NULL, then is is a valid address.  You can use
'''  * this function with tail == NULL for an existing list, in
'''  * which case  the tail is found and updated, and the
'''  * removed element is returned.
'''  *   (3) In ANSI C, it is not necessary to cast return to actual type; e.g.,
'''  *   pix = listRemoveFromTail(&head, &tail);
'''  * but in ANSI C++, it is necessary to do the cast; e.g.,
'''  *   pix = (Pix *)listRemoveFromTail(&head, &tail);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data  void struct on cell or NULL on error</returns>
''' <param name="phead"> \param[in,out]   phead [may be changed], head must NOT be NULL</param>
''' <param name="ptail"> \param[in,out]   ptail [always updated], tail may be NULL</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="listRemoveFromTail")> _
Friend Shared Function listRemoveFromTail(phead as Object, ptail as Object) as String
End Function

' SRC\list.c (668, 1)
' listFindElement()
' listFindElement(DLLIST *, void *) as DLLIST *
''' <summary>
''' * Notes:
'''  *   (1) This returns a ptr to the cell, which is still embedded in
'''  * the list.
'''  *   (2) This handle and the attached data have not been copied or
'''  * reference counted, so they must not be destroyed.  This
'''  * violates our basic rule that every handle returned from a
'''  * function is owned by that function and must be destroyed,
'''  * but if rules aren't there to be broken, why have them?
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cell  the containing cell, or NULL if not found or on error</returns>
''' <param name="head"> \param[in]    head  list head</param>
''' <param name="data"> \param[in]    data  void  address, to be searched for</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="listFindElement")> _
Friend Shared Function listFindElement(head as IntPTR, data as Object) as IntPTR
End Function

' SRC\list.c (696, 1)
' listFindTail()
' listFindTail(DLLIST *) as DLLIST *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  tail, or NULL on error</returns>
''' <param name="head"> \param[in]    head</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="listFindTail")> _
Friend Shared Function listFindTail(head as IntPTR) as IntPTR
End Function

' SRC\list.c (721, 1)
' listGetCount()
' listGetCount(DLLIST *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  number of elements; 0 if no list or on error</returns>
''' <param name="head"> \param[in]    head  of list</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="listGetCount")> _
Friend Shared Function listGetCount(head as IntPTR) as Integer
End Function

' SRC\list.c (751, 1)
' listReverse()
' listReverse(DLLIST **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This reverses the list in-place.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="phead"> \param[in,out]   phead  [may be changed] list head</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="listReverse")> _
Friend Shared Function listReverse(phead as Object) as Integer
End Function

' SRC\list.c (788, 1)
' listJoin()
' listJoin(DLLIST **, DLLIST **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The concatenated list is returned with head1 as the new head.
'''  *   (2) Both input ptrs must exist, though either can have the value NULL.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="phead1"> \param[in,out]   phead1  [may be changed] head of first list</param>
''' <param name="phead2"> \param[in,out]   phead2  to be nulled; head of second list</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="listJoin")> _
Friend Shared Function listJoin(phead1 as Object, phead2 as Object) as Integer
End Function

#End Region
#Region "SRC\map.c"
' SRC\map.c (107, 1)
' 
' l_amapCreate(l_int32) as L_AMAP *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_amapCreate")> _
Friend Shared Function l_amapCreate(keytype as Integer) as IntPTR
End Function

' SRC\map.c (121, 1)
' 
' l_amapFind(L_AMAP *, RB_TYPE) as RB_TYPE *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_amapFind")> _
Friend Shared Function l_amapFind(m as IntPTR, key as Rb_Type) as IntPTR
End Function

' SRC\map.c (128, 1)
' 
' l_amapInsert(L_AMAP *, RB_TYPE, RB_TYPE) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_amapInsert")> _
Friend Shared Function l_amapInsert(m as IntPTR, key as Rb_Type, value as Rb_Type) as Boolean ' Org. Void
End Function

' SRC\map.c (136, 1)
' 
' l_amapDelete(L_AMAP *, RB_TYPE) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_amapDelete")> _
Friend Shared Function l_amapDelete(m as IntPTR, key as Rb_Type) as Boolean ' Org. Void
End Function

' SRC\map.c (143, 1)
' 
' l_amapDestroy(L_AMAP **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_amapDestroy")> _
Friend Shared Function l_amapDestroy(pm as Object) as Boolean ' Org. Void
End Function

' SRC\map.c (149, 1)
' 
' l_amapGetFirst(L_AMAP *) as L_AMAP_NODE *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_amapGetFirst")> _
Friend Shared Function l_amapGetFirst(m as IntPTR) as IntPTR
End Function

' SRC\map.c (155, 1)
' 
' l_amapGetNext(L_AMAP_NODE *) as L_AMAP_NODE *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_amapGetNext")> _
Friend Shared Function l_amapGetNext(n as IntPTR) as IntPTR
End Function

' SRC\map.c (161, 1)
' 
' l_amapGetLast(L_AMAP *) as L_AMAP_NODE *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_amapGetLast")> _
Friend Shared Function l_amapGetLast(m as IntPTR) as IntPTR
End Function

' SRC\map.c (167, 1)
' 
' l_amapGetPrev(L_AMAP_NODE *) as L_AMAP_NODE *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_amapGetPrev")> _
Friend Shared Function l_amapGetPrev(n as IntPTR) as IntPTR
End Function

' SRC\map.c (173, 1)
' 
' l_amapSize(L_AMAP *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_amapSize")> _
Friend Shared Function l_amapSize(m as IntPTR) as Integer
End Function

' SRC\map.c (183, 1)
' 
' l_asetCreate(l_int32) as L_ASET *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_asetCreate")> _
Friend Shared Function l_asetCreate(keytype as Integer) as IntPTR
End Function

' SRC\map.c (203, 1)
' 
' l_asetFind(L_ASET *, RB_TYPE) as RB_TYPE *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_asetFind")> _
Friend Shared Function l_asetFind(s as IntPTR, key as Rb_Type) as IntPTR
End Function

' SRC\map.c (210, 1)
' 
' l_asetInsert(L_ASET *, RB_TYPE) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_asetInsert")> _
Friend Shared Function l_asetInsert(s as IntPTR, key as Rb_Type) as Boolean ' Org. Void
End Function

' SRC\map.c (220, 1)
' 
' l_asetDelete(L_ASET *, RB_TYPE) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_asetDelete")> _
Friend Shared Function l_asetDelete(s as IntPTR, key as Rb_Type) as Boolean ' Org. Void
End Function

' SRC\map.c (227, 1)
' 
' l_asetDestroy(L_ASET **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_asetDestroy")> _
Friend Shared Function l_asetDestroy(ps as Object) as Boolean ' Org. Void
End Function

' SRC\map.c (233, 1)
' 
' l_asetGetFirst(L_ASET *) as L_ASET_NODE *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_asetGetFirst")> _
Friend Shared Function l_asetGetFirst(s as IntPTR) as IntPTR
End Function

' SRC\map.c (239, 1)
' 
' l_asetGetNext(L_ASET_NODE *) as L_ASET_NODE *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_asetGetNext")> _
Friend Shared Function l_asetGetNext(n as IntPTR) as IntPTR
End Function

' SRC\map.c (245, 1)
' 
' l_asetGetLast(L_ASET *) as L_ASET_NODE *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_asetGetLast")> _
Friend Shared Function l_asetGetLast(s as IntPTR) as IntPTR
End Function

' SRC\map.c (251, 1)
' 
' l_asetGetPrev(L_ASET_NODE *) as L_ASET_NODE *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_asetGetPrev")> _
Friend Shared Function l_asetGetPrev(n as IntPTR) as IntPTR
End Function

' SRC\map.c (257, 1)
' 
' l_asetSize(L_ASET *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_asetSize")> _
Friend Shared Function l_asetSize(s as IntPTR) as Integer
End Function

#End Region
#Region "SRC\maze.c"
' SRC\maze.c (86, 16)
' 
' mazeelCreate(l_int32, l_int32, l_int32) as MAZEEL *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="mazeelCreate")> _
Friend Shared Function mazeelCreate(x as Integer, y as Integer, dir as Integer) as IntPTR
End Function

' SRC\maze.c (87, 16)
' localSearchForBackground()
' localSearchForBackground(PIX *, l_int32 *, l_int32 *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if bg pixel found; 1 if not found</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="px"> \param[out]   px, py starting position for search; return found position</param>
''' <param name="py"> \param[in]    maxrad max distance to search from starting location</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="localSearchForBackground")> _
Friend Shared Function localSearchForBackground(pix as IntPTR, px as Integer, py as Integer, maxrad as Integer) as Integer
End Function

' SRC\maze.c (142, 1)
' generateBinaryMaze()
' generateBinaryMaze(l_int32, l_int32, l_int32, l_int32, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) We have two input probability factors that determine the
'''  * density of walls and average length of straight passages.
'''  * When ranis  1.0, you are more likely to generate a wall
'''  * to the side than going forward.  Enter 0.0 for either if
'''  * you want to use the default values.
'''  *   (2) This is a type of percolation problem, and exhibits
'''  * different phases for different parameters wallps and ranis.
'''  * For larger values of these parameters, regions in the maze
'''  * are not explored because the maze generator walls them
'''  * off and cannot get through.  The boundary between the
'''  * two phases in this two-dimensional parameter space goes
'''  * near these values:
'''  * wallps ranis
'''  * 0.35   1.00
'''  * 0.40   0.85
'''  * 0.45   0.70
'''  * 0.50   0.50
'''  * 0.55   0.40
'''  * 0.60   0.30
'''  * 0.65   0.25
'''  * 0.70   0.19
'''  * 0.75   0.15
'''  * 0.80   0.11
'''  *   (3) Because there is a considerable amount of overhead in calling
'''  * pixGetPixel() and pixSetPixel(), this function can be sped
'''  * up with little effort using raster line pointers and the
'''  * GET_DATA* and SET_DATA* macros.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="w"> \param[in]    w, h  size of maze</param>
''' <param name="h"> \param[in]    xi, yi  initial location</param>
''' <param name="xi"> \param[in]    wallps probability that a pixel to the side is ON</param>
''' <param name="yi"> \param[in]    ranis ratio of prob that pixel in forward direction</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generateBinaryMaze")> _
Friend Shared Function generateBinaryMaze(w as Integer, h as Integer, xi as Integer, yi as Integer, wallps as single, ranis as single) as IntPTR
End Function

' SRC\maze.c (339, 1)
' pixSearchBinaryMaze()
' pixSearchBinaryMaze(PIX *, l_int32, l_int32, l_int32, l_int32, PIX **) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) Because of the overhead in calling pixGetPixel() and
'''  * pixSetPixel(), we have used raster line pointers and the
'''  * GET_DATA* and SET_DATA* macros for many of the pix accesses.
'''  *   (2) Commentary:
'''  *   The goal is to find the shortest path between beginning and
'''  * end points, without going through walls, and there are many
'''  * ways to solve this problem.
'''  *   We use a queue to implement a breadth-first search.  Two auxiliary
'''  * "image" data structures can be used: one to mark the visited
'''  * pixels and one to give the direction to the parent for each
'''  * visited pixel.  The first structure is used to avoid putting
'''  * pixels on the queue more than once, and the second is used
'''  * for retracing back to the origin, like the breadcrumbs in
'''  * Hansel and Gretel.  Each pixel taken off the queue is destroyed
'''  * after it is used to locate the allowed neighbors.  In fact,
'''  * only one distance image is required, if you initialize it
'''  * to some value that signifies "not yet visited."  (We use
'''  * a binary image for marking visited pixels because it is clearer.)
'''  * This method for a simple search of a binary maze is implemented in
'''  * pixSearchBinaryMaze().
'''  *   An alternative method would store the (manhattan) distance
'''  * from the start point with each pixel on the queue.  The children
'''  * of each pixel get a distance one larger than the parent.  These
'''  * values can be stored in an auxiliary distance map image
'''  * that is constructed simultaneously with the search.  Once the
'''  * end point is reached, the distance map is used to backtrack
'''  * along a minimum path.  There may be several equal length
'''  * minimum paths, any one of which can be chosen this way.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta shortest path, or NULL if either no path</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, maze</param>
''' <param name="xi"> \param[in]    xi, yi  beginning point; use same initial point</param>
''' <param name="yi"> \param[in]    xf, yf  end point, or close to it</param>
''' <param name="xf"> \param[out]   ppixd [optional] maze with path illustrated, or</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSearchBinaryMaze")> _
Friend Shared Function pixSearchBinaryMaze(pixs as IntPTR, xi as Integer, yi as Integer, xf as Integer, yf as Integer, ppixd as Object) as IntPTR
End Function

' SRC\maze.c (723, 1)
' pixSearchGrayMaze()
' pixSearchGrayMaze(PIX *, l_int32, l_int32, l_int32, l_int32, PIX **) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta shortest path, or NULL if either no path</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, maze</param>
''' <param name="xi"> \param[in]    xi, yi  beginning point; use same initial point</param>
''' <param name="yi"> \param[in]    xf, yf  end point, or close to it</param>
''' <param name="xf"> \param[out]   ppixd [optional] maze with path illustrated, or</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSearchGrayMaze")> _
Friend Shared Function pixSearchGrayMaze(pixs as IntPTR, xi as Integer, yi as Integer, xf as Integer, yf as Integer, ppixd as Object) as IntPTR
End Function

#End Region
#Region "SRC\morph.c"
' SRC\morph.c (178, 14)
' processMorphArgs1()
' processMorphArgs1(PIX *, PIX *, SEL *, PIX **) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is used for generic erosion, dilation and HMT.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error.</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="sel"> \param[in]    sel</param>
''' <param name="ppixt"> \param[out]   ppixt ptr to PIX</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="processMorphArgs1")> _
Friend Shared Function processMorphArgs1(pixd as IntPTR, pixs as IntPTR, sel as IntPTR, ppixt as Object) as IntPTR
End Function

' SRC\morph.c (179, 14)
' processMorphArgs2()
' processMorphArgs2(PIX *, PIX *, SEL *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="processMorphArgs2")> _
Friend Shared Function processMorphArgs2(pixd as IntPTR, pixs as IntPTR, sel as IntPTR) as IntPTR
End Function

' SRC\morph.c (209, 1)
' pixDilate()
' pixDilate(PIX *, PIX *, SEL *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This dilates src using hits in Sel.
'''  *   (2) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (3) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixDilate(NULL, pixs, ...);
'''  * (b) pixDilate(pixs, pixs, ...);
'''  * (c) pixDilate(pixd, pixs, ...);
'''  *   (4) The size of the result is determined by pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="sel"> \param[in]    sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDilate")> _
Friend Shared Function pixDilate(pixd as IntPTR, pixs as IntPTR, sel as IntPTR) as IntPTR
End Function

' SRC\morph.c (263, 1)
' pixErode()
' pixErode(PIX *, PIX *, SEL *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This erodes src using hits in Sel.
'''  *   (2) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (3) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixErode(NULL, pixs, ...);
'''  * (b) pixErode(pixs, pixs, ...);
'''  * (c) pixErode(pixd, pixs, ...);
'''  *   (4) The size of the result is determined by pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="sel"> \param[in]    sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixErode")> _
Friend Shared Function pixErode(pixd as IntPTR, pixs as IntPTR, sel as IntPTR) as IntPTR
End Function

' SRC\morph.c (338, 1)
' pixHMT()
' pixHMT(PIX *, PIX *, SEL *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The hit-miss transform erodes the src, using both hits
'''  * and misses in the Sel.  It ANDs the shifted src for hits
'''  * and ANDs the inverted shifted src for misses.
'''  *   (2) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (3) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixHMT(NULL, pixs, ...);
'''  * (b) pixHMT(pixs, pixs, ...);
'''  * (c) pixHMT(pixd, pixs, ...);
'''  *   (4) The size of the result is determined by pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="sel"> \param[in]    sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixHMT")> _
Friend Shared Function pixHMT(pixd as IntPTR, pixs as IntPTR, sel as IntPTR) as IntPTR
End Function

' SRC\morph.c (422, 1)
' pixOpen()
' pixOpen(PIX *, PIX *, SEL *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Generic morphological opening, using hits in the Sel.
'''  *   (2) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (3) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixOpen(NULL, pixs, ...);
'''  * (b) pixOpen(pixs, pixs, ...);
'''  * (c) pixOpen(pixd, pixs, ...);
'''  *   (4) The size of the result is determined by pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="sel"> \param[in]    sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOpen")> _
Friend Shared Function pixOpen(pixd as IntPTR, pixs as IntPTR, sel as IntPTR) as IntPTR
End Function

' SRC\morph.c (469, 1)
' pixClose()
' pixClose(PIX *, PIX *, SEL *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Generic morphological closing, using hits in the Sel.
'''  *   (2) This implementation is a strict dual of the opening if
'''  * symmetric boundary conditions are used (see notes at top
'''  * of this file).
'''  *   (3) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (4) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixClose(NULL, pixs, ...);
'''  * (b) pixClose(pixs, pixs, ...);
'''  * (c) pixClose(pixd, pixs, ...);
'''  *   (5) The size of the result is determined by pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="sel"> \param[in]    sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixClose")> _
Friend Shared Function pixClose(pixd as IntPTR, pixs as IntPTR, sel as IntPTR) as IntPTR
End Function

' SRC\morph.c (520, 1)
' pixCloseSafe()
' pixCloseSafe(PIX *, PIX *, SEL *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Generic morphological closing, using hits in the Sel.
'''  *   (2) If non-symmetric boundary conditions are used, this
'''  * function adds a border of OFF pixels that is of
'''  * sufficient size to avoid losing pixels from the dilation,
'''  * and it removes the border after the operation is finished.
'''  * It thus enforces a correct extensive result for closing.
'''  *   (3) If symmetric b.c. are used, it is not necessary to add
'''  * and remove this border.
'''  *   (4) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (5) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixCloseSafe(NULL, pixs, ...);
'''  * (b) pixCloseSafe(pixs, pixs, ...);
'''  * (c) pixCloseSafe(pixd, pixs, ...);
'''  *   (6) The size of the result is determined by pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="sel"> \param[in]    sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCloseSafe")> _
Friend Shared Function pixCloseSafe(pixd as IntPTR, pixs as IntPTR, sel as IntPTR) as IntPTR
End Function

' SRC\morph.c (587, 1)
' pixOpenGeneralized()
' pixOpenGeneralized(PIX *, PIX *, SEL *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Generalized morphological opening, using both hits and
'''  * misses in the Sel.
'''  *   (2) This does a hit-miss transform, followed by a dilation
'''  * using the hits.
'''  *   (3) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (4) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixOpenGeneralized(NULL, pixs, ...);
'''  * (b) pixOpenGeneralized(pixs, pixs, ...);
'''  * (c) pixOpenGeneralized(pixd, pixs, ...);
'''  *   (5) The size of the result is determined by pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="sel"> \param[in]    sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOpenGeneralized")> _
Friend Shared Function pixOpenGeneralized(pixd as IntPTR, pixs as IntPTR, sel as IntPTR) as IntPTR
End Function

' SRC\morph.c (634, 1)
' pixCloseGeneralized()
' pixCloseGeneralized(PIX *, PIX *, SEL *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Generalized morphological closing, using both hits and
'''  * misses in the Sel.
'''  *   (2) This does a dilation using the hits, followed by a
'''  * hit-miss transform.
'''  *   (3) This operation is a dual of the generalized opening.
'''  *   (4) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (5) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixCloseGeneralized(NULL, pixs, ...);
'''  * (b) pixCloseGeneralized(pixs, pixs, ...);
'''  * (c) pixCloseGeneralized(pixd, pixs, ...);
'''  *   (6) The size of the result is determined by pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="sel"> \param[in]    sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCloseGeneralized")> _
Friend Shared Function pixCloseGeneralized(pixd as IntPTR, pixs as IntPTR, sel as IntPTR) as IntPTR
End Function

' SRC\morph.c (684, 1)
' pixDilateBrick()
' pixDilateBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) The origin is at (x, y) = (hsize/2, vsize/2)
'''  *   (3) Do separably if both hsize and vsize are > 1.
'''  *   (4) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (5) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixDilateBrick(NULL, pixs, ...);
'''  * (b) pixDilateBrick(pixs, pixs, ...);
'''  * (c) pixDilateBrick(pixd, pixs, ...);
'''  *   (6) The size of the result is determined by pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDilateBrick")> _
Friend Shared Function pixDilateBrick(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morph.c (748, 1)
' pixErodeBrick()
' pixErodeBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) The origin is at (x, y) = (hsize/2, vsize/2)
'''  *   (3) Do separably if both hsize and vsize are > 1.
'''  *   (4) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (5) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixErodeBrick(NULL, pixs, ...);
'''  * (b) pixErodeBrick(pixs, pixs, ...);
'''  * (c) pixErodeBrick(pixd, pixs, ...);
'''  *   (6) The size of the result is determined by pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixErodeBrick")> _
Friend Shared Function pixErodeBrick(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morph.c (812, 1)
' pixOpenBrick()
' pixOpenBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) The origin is at (x, y) = (hsize/2, vsize/2)
'''  *   (3) Do separably if both hsize and vsize are > 1.
'''  *   (4) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (5) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixOpenBrick(NULL, pixs, ...);
'''  * (b) pixOpenBrick(pixs, pixs, ...);
'''  * (c) pixOpenBrick(pixd, pixs, ...);
'''  *   (6) The size of the result is determined by pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOpenBrick")> _
Friend Shared Function pixOpenBrick(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morph.c (878, 1)
' pixCloseBrick()
' pixCloseBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) The origin is at (x, y) = (hsize/2, vsize/2)
'''  *   (3) Do separably if both hsize and vsize are > 1.
'''  *   (4) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (5) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixCloseBrick(NULL, pixs, ...);
'''  * (b) pixCloseBrick(pixs, pixs, ...);
'''  * (c) pixCloseBrick(pixd, pixs, ...);
'''  *   (6) The size of the result is determined by pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCloseBrick")> _
Friend Shared Function pixCloseBrick(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morph.c (949, 1)
' pixCloseSafeBrick()
' pixCloseSafeBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) The origin is at (x, y) = (hsize/2, vsize/2)
'''  *   (3) Do separably if both hsize and vsize are > 1.
'''  *   (4) Safe closing adds a border of 0 pixels, of sufficient size so
'''  * that all pixels in input image are processed within
'''  * 32-bit words in the expanded image.  As a result, there is
'''  * no special processing for pixels near the boundary, and there
'''  * are no boundary effects.  The border is removed at the end.
'''  *   (5) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (6) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixCloseBrick(NULL, pixs, ...);
'''  * (b) pixCloseBrick(pixs, pixs, ...);
'''  * (c) pixCloseBrick(pixd, pixs, ...);
'''  *   (7) The size of the result is determined by pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCloseSafeBrick")> _
Friend Shared Function pixCloseSafeBrick(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morph.c (1037, 1)
' 
' selectComposableSels(l_int32, l_int32, SEL **, SEL **) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selectComposableSels")> _
Friend Shared Function selectComposableSels(size as Integer, direction as Integer, psel1 as Object, psel2 as Object) as Integer
End Function

' SRC\morph.c (1092, 1)
' selectComposableSizes()
' selectComposableSizes(l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This works for Sel sizes up to 62500, which seems sufficient.
'''  *   (2) The composable sel size is typically within +- 1 of
'''  * the requested size.  Up to size = 300, the maximum difference
'''  * is +- 2.
'''  *   (3) We choose an overall cost function where the penalty for
'''  * the size difference between input and actual is 4 times
'''  * the penalty for additional rasterops.
'''  *   (4) Returned values: factor1 >= factor2
'''  * If size > 1, then factor1 > 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="size"> \param[in]    size of sel to be decomposed</param>
''' <param name="pfactor1"> \param[out]   pfactor1 larger factor</param>
''' <param name="pfactor2"> \param[out]   pfactor2 smaller factor</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selectComposableSizes")> _
Friend Shared Function selectComposableSizes(size as Integer, pfactor1 as Integer, pfactor2 as Integer) as Integer
End Function

' SRC\morph.c (1204, 1)
' pixDilateCompBrick()
' pixDilateCompBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) The origin is at (x, y) = (hsize/2, vsize/2)
'''  *   (3) Do compositely for each dimension > 1.
'''  *   (4) Do separably if both hsize and vsize are > 1.
'''  *   (5) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (6) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixDilateCompBrick(NULL, pixs, ...);
'''  * (b) pixDilateCompBrick(pixs, pixs, ...);
'''  * (c) pixDilateCompBrick(pixd, pixs, ...);
'''  *   (7) The dimensions of the resulting image are determined by pixs.
'''  *   (8) CAUTION: both hsize and vsize are being decomposed.
'''  * The decomposer chooses a product of sizes (call them
'''  * 'terms') for each that is close to the input size,
'''  * but not necessarily equal to it.  It attempts to optimize:
'''  * (a) for consistency with the input values: the product
'''  *  of terms is close to the input size
'''  * (b) for efficiency of the operation: the sum of the
'''  *  terms is small; ideally about twice the square
'''  *  root of the input size.
'''  * So, for example, if the input hsize = 37, which is
'''  * a prime number, the decomposer will break this into two
'''  * terms, 6 and 6, so that the net result is a dilation
'''  * with hsize = 36.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDilateCompBrick")> _
Friend Shared Function pixDilateCompBrick(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morph.c (1304, 1)
' pixErodeCompBrick()
' pixErodeCompBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) The origin is at (x, y) = (hsize/2, vsize/2)
'''  *   (3) Do compositely for each dimension > 1.
'''  *   (4) Do separably if both hsize and vsize are > 1.
'''  *   (5) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (6) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixErodeCompBrick(NULL, pixs, ...);
'''  * (b) pixErodeCompBrick(pixs, pixs, ...);
'''  * (c) pixErodeCompBrick(pixd, pixs, ...);
'''  *   (7) The dimensions of the resulting image are determined by pixs.
'''  *   (8) CAUTION: both hsize and vsize are being decomposed.
'''  * The decomposer chooses a product of sizes (call them
'''  * 'terms') for each that is close to the input size,
'''  * but not necessarily equal to it.  It attempts to optimize:
'''  * (a) for consistency with the input values: the product
'''  *  of terms is close to the input size
'''  * (b) for efficiency of the operation: the sum of the
'''  *  terms is small; ideally about twice the square
'''  *  root of the input size.
'''  * So, for example, if the input hsize = 37, which is
'''  * a prime number, the decomposer will break this into two
'''  * terms, 6 and 6, so that the net result is a dilation
'''  * with hsize = 36.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixErodeCompBrick")> _
Friend Shared Function pixErodeCompBrick(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morph.c (1395, 1)
' pixOpenCompBrick()
' pixOpenCompBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) The origin is at (x, y) = (hsize/2, vsize/2)
'''  *   (3) Do compositely for each dimension > 1.
'''  *   (4) Do separably if both hsize and vsize are > 1.
'''  *   (5) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (6) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixOpenCompBrick(NULL, pixs, ...);
'''  * (b) pixOpenCompBrick(pixs, pixs, ...);
'''  * (c) pixOpenCompBrick(pixd, pixs, ...);
'''  *   (7) The dimensions of the resulting image are determined by pixs.
'''  *   (8) CAUTION: both hsize and vsize are being decomposed.
'''  * The decomposer chooses a product of sizes (call them
'''  * 'terms') for each that is close to the input size,
'''  * but not necessarily equal to it.  It attempts to optimize:
'''  * (a) for consistency with the input values: the product
'''  *  of terms is close to the input size
'''  * (b) for efficiency of the operation: the sum of the
'''  *  terms is small; ideally about twice the square
'''  *  root of the input size.
'''  * So, for example, if the input hsize = 37, which is
'''  * a prime number, the decomposer will break this into two
'''  * terms, 6 and 6, so that the net result is a dilation
'''  * with hsize = 36.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOpenCompBrick")> _
Friend Shared Function pixOpenCompBrick(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morph.c (1494, 1)
' pixCloseCompBrick()
' pixCloseCompBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) The origin is at (x, y) = (hsize/2, vsize/2)
'''  *   (3) Do compositely for each dimension > 1.
'''  *   (4) Do separably if both hsize and vsize are > 1.
'''  *   (5) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (6) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixCloseCompBrick(NULL, pixs, ...);
'''  * (b) pixCloseCompBrick(pixs, pixs, ...);
'''  * (c) pixCloseCompBrick(pixd, pixs, ...);
'''  *   (7) The dimensions of the resulting image are determined by pixs.
'''  *   (8) CAUTION: both hsize and vsize are being decomposed.
'''  * The decomposer chooses a product of sizes (call them
'''  * 'terms') for each that is close to the input size,
'''  * but not necessarily equal to it.  It attempts to optimize:
'''  * (a) for consistency with the input values: the product
'''  *  of terms is close to the input size
'''  * (b) for efficiency of the operation: the sum of the
'''  *  terms is small; ideally about twice the square
'''  *  root of the input size.
'''  * So, for example, if the input hsize = 37, which is
'''  * a prime number, the decomposer will break this into two
'''  * terms, 6 and 6, so that the net result is a dilation
'''  * with hsize = 36.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCloseCompBrick")> _
Friend Shared Function pixCloseCompBrick(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morph.c (1598, 1)
' pixCloseSafeCompBrick()
' pixCloseSafeCompBrick(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) The origin is at (x, y) = (hsize/2, vsize/2)
'''  *   (3) Do compositely for each dimension > 1.
'''  *   (4) Do separably if both hsize and vsize are > 1.
'''  *   (5) Safe closing adds a border of 0 pixels, of sufficient size so
'''  * that all pixels in input image are processed within
'''  * 32-bit words in the expanded image.  As a result, there is
'''  * no special processing for pixels near the boundary, and there
'''  * are no boundary effects.  The border is removed at the end.
'''  *   (6) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (7) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixCloseSafeCompBrick(NULL, pixs, ...);
'''  * (b) pixCloseSafeCompBrick(pixs, pixs, ...);
'''  * (c) pixCloseSafeCompBrick(pixd, pixs, ...);
'''  *   (8) The dimensions of the resulting image are determined by pixs.
'''  *   (9) CAUTION: both hsize and vsize are being decomposed.
'''  * The decomposer chooses a product of sizes (call them
'''  * 'terms') for each that is close to the input size,
'''  * but not necessarily equal to it.  It attempts to optimize:
'''  * (a) for consistency with the input values: the product
'''  *  of terms is close to the input size
'''  * (b) for efficiency of the operation: the sum of the
'''  *  terms is small; ideally about twice the square
'''  *  root of the input size.
'''  * So, for example, if the input hsize = 37, which is
'''  * a prime number, the decomposer will break this into two
'''  * terms, 6 and 6, so that the net result is a dilation
'''  * with hsize = 36.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCloseSafeCompBrick")> _
Friend Shared Function pixCloseSafeCompBrick(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morph.c (1687, 1)
' resetMorphBoundaryCondition()
' resetMorphBoundaryCondition(l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="bc"> \param[in]    bc SYMMETRIC_MORPH_BC, ASYMMETRIC_MORPH_BC</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="resetMorphBoundaryCondition")> _
Friend Shared Function resetMorphBoundaryCondition(bc as Integer) as Boolean ' Org. Void
End Function

' SRC\morph.c (1708, 1)
' getMorphBorderPixelColor()
' getMorphBorderPixelColor(l_int32, l_int32) as l_uint32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  color of border pixels for this operation</returns>
''' <param name="type"> \param[in]    type L_MORPH_DILATE, L_MORPH_ERODE</param>
''' <param name="depth"> \param[in]    depth of pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getMorphBorderPixelColor")> _
Friend Shared Function getMorphBorderPixelColor(type as Integer, depth as Integer) as UInteger
End Function

#End Region
#Region "SRC\morphapp.c"
' SRC\morphapp.c (108, 1)
' pixExtractBoundary()
' pixExtractBoundary(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Extracts the fg or bg boundary pixels for each component.
'''  * Components are assumed to end at the boundary of pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="type"> \param[in]    type 0 for background pixels; 1 for foreground pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExtractBoundary")> _
Friend Shared Function pixExtractBoundary(pixs as IntPTR, type as Integer) as IntPTR
End Function

' SRC\morphapp.c (148, 1)
' pixMorphSequenceMasked()
' pixMorphSequenceMasked(PIX *, PIX *, const char *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This applies the morph sequence to the image, but only allows
'''  * changes in pixs for pixels under the background of pixm.
'''  *   (5) If pixm is NULL, this is just pixMorphSequence().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="pixm"> \param[in]    pixm [optional] 1 bpp mask</param>
''' <param name="sequence"> \param[in]    sequence string specifying sequence of operations</param>
''' <param name="dispsep"> \param[in]    dispsep horizontal separation in pixels between</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMorphSequenceMasked")> _
Friend Shared Function pixMorphSequenceMasked(pixs as IntPTR, pixm as IntPTR, sequence as String, dispsep as Integer) as IntPTR
End Function

' SRC\morphapp.c (195, 1)
' pixMorphSequenceByComponent()
' pixMorphSequenceByComponent(PIX *, const char *, l_int32, l_int32, l_int32, BOXA **) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixMorphSequence() for composing operation sequences.
'''  *   (2) This operates separately on each c.c. in the input pix.
'''  *   (3) The dilation does NOT increase the c.c. size; it is clipped
'''  * to the size of the original c.c.   This is necessary to
'''  * keep the c.c. independent after the operation.
'''  *   (4) You can specify that the width and/or height must equal
'''  * or exceed a minimum size for the operation to take place.
'''  *   (5) Use NULL for boxa to avoid returning the boxa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="sequence"> \param[in]    sequence string specifying sequence</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
''' <param name="minw"> \param[in]    minw  minimum width to consider; use 0 or 1 for any width</param>
''' <param name="minh"> \param[in]    minh  minimum height to consider; use 0 or 1 for any height</param>
''' <param name="pboxa"> \param[out]   pboxa [optional] return boxa of c.c. in pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMorphSequenceByComponent")> _
Friend Shared Function pixMorphSequenceByComponent(pixs as IntPTR, sequence as String, connectivity as Integer, minw as Integer, minh as Integer, pboxa as Object) as IntPTR
End Function

' SRC\morphapp.c (265, 1)
' pixaMorphSequenceByComponent()
' pixaMorphSequenceByComponent(PIXA *, const char *, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) See pixMorphSequence() for composing operation sequences.
'''  *   (2) This operates separately on each c.c. in the input pixa.
'''  *   (3) You can specify that the width and/or height must equal
'''  * or exceed a minimum size for the operation to take place.
'''  *   (4) The input pixa should have a boxa giving the locations
'''  * of the pix components.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas of 1 bpp pix</param>
''' <param name="sequence"> \param[in]    sequence string specifying sequence</param>
''' <param name="minw"> \param[in]    minw  minimum width to consider; use 0 or 1 for any width</param>
''' <param name="minh"> \param[in]    minh  minimum height to consider; use 0 or 1 for any height</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaMorphSequenceByComponent")> _
Friend Shared Function pixaMorphSequenceByComponent(pixas as IntPTR, sequence as String, minw as Integer, minh as Integer) as IntPTR
End Function

' SRC\morphapp.c (348, 1)
' pixMorphSequenceByRegion()
' pixMorphSequenceByRegion(PIX *, PIX *, const char *, l_int32, l_int32, l_int32, BOXA **) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixMorphCompSequence() for composing operation sequences.
'''  *   (2) This operates separately on the region in pixs corresponding
'''  * to each c.c. in the mask pixm.  It differs from
'''  * pixMorphSequenceByComponent() in that the latter does not have
'''  * a pixm (mask), but instead operates independently on each
'''  * component in pixs.
'''  *   (3) Dilation will NOT increase the region size; the result
'''  * is clipped to the size of the mask region.  This is necessary
'''  * to make regions independent after the operation.
'''  *   (4) You can specify that the width and/or height of a region must
'''  * equal or exceed a minimum size for the operation to take place.
'''  *   (5) Use NULL for %pboxa to avoid returning the boxa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="pixm"> \param[in]    pixm mask specifying regions</param>
''' <param name="sequence"> \param[in]    sequence string specifying sequence</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8, used on mask</param>
''' <param name="minw"> \param[in]    minw  minimum width to consider; use 0 or 1 for any width</param>
''' <param name="minh"> \param[in]    minh  minimum height to consider; use 0 or 1 for any height</param>
''' <param name="pboxa"> \param[out]   pboxa [optional] return boxa of c.c. in pixm</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMorphSequenceByRegion")> _
Friend Shared Function pixMorphSequenceByRegion(pixs as IntPTR, pixm as IntPTR, sequence as String, connectivity as Integer, minw as Integer, minh as Integer, pboxa as Object) as IntPTR
End Function

' SRC\morphapp.c (427, 1)
' pixaMorphSequenceByRegion()
' pixaMorphSequenceByRegion(PIX *, PIXA *, const char *, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) See pixMorphSequence() for composing operation sequences.
'''  *   (2) This operates separately on each region in the input pixs
'''  * defined by the components in pixam.
'''  *   (3) You can specify that the width and/or height of a mask
'''  * component must equal or exceed a minimum size for the
'''  * operation to take place.
'''  *   (4) The input pixam should have a boxa giving the locations
'''  * of the regions in pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="pixam"> \param[in]    pixam of 1 bpp mask elements</param>
''' <param name="sequence"> \param[in]    sequence string specifying sequence</param>
''' <param name="minw"> \param[in]    minw  minimum width to consider; use 0 or 1 for any width</param>
''' <param name="minh"> \param[in]    minh  minimum height to consider; use 0 or 1 for any height</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaMorphSequenceByRegion")> _
Friend Shared Function pixaMorphSequenceByRegion(pixs as IntPTR, pixam as IntPTR, sequence as String, minw as Integer, minh as Integer) as IntPTR
End Function

' SRC\morphapp.c (502, 1)
' pixUnionOfMorphOps()
' pixUnionOfMorphOps(PIX *, SELA *, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd union of the specified morphological operation</returns>
''' <param name="pixs"> \param[in]    pixs binary</param>
''' <param name="sela"> \param[in]    sela</param>
''' <param name="type"> \param[in]    type L_MORPH_DILATE, etc.</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixUnionOfMorphOps")> _
Friend Shared Function pixUnionOfMorphOps(pixs as IntPTR, sela as IntPTR, type as Integer) as IntPTR
End Function

' SRC\morphapp.c (555, 1)
' pixIntersectionOfMorphOps()
' pixIntersectionOfMorphOps(PIX *, SELA *, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd intersection of the specified morphological operation</returns>
''' <param name="pixs"> \param[in]    pixs binary</param>
''' <param name="sela"> \param[in]    sela</param>
''' <param name="type"> \param[in]    type L_MORPH_DILATE, etc.</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixIntersectionOfMorphOps")> _
Friend Shared Function pixIntersectionOfMorphOps(pixs as IntPTR, sela as IntPTR, type as Integer) as IntPTR
End Function

' SRC\morphapp.c (613, 1)
' pixSelectiveConnCompFill()
' pixSelectiveConnCompFill(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix with holes filled in selected c.c., or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs binary</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
''' <param name="minw"> \param[in]    minw  minimum width to consider; use 0 or 1 for any width</param>
''' <param name="minh"> \param[in]    minh  minimum height to consider; use 0 or 1 for any height</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSelectiveConnCompFill")> _
Friend Shared Function pixSelectiveConnCompFill(pixs as IntPTR, connectivity as Integer, minw as Integer, minh as Integer) as IntPTR
End Function

' SRC\morphapp.c (684, 1)
' pixRemoveMatchedPattern()
' pixRemoveMatchedPattern(PIX *, PIX *, PIX *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  * (1) This is in-place.
'''  * (2) You can use various functions in selgen to create a Sel
'''  *  that is used to generate pixe from pixs.
'''  * (3) This function is applied after pixe has been computed.
'''  *  It finds the centroid of each c.c., and subtracts
'''  *  (the appropriately dilated version of) pixp, with the center
'''  *  of the Sel used to align pixp with pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs input image, 1 bpp</param>
''' <param name="pixp"> \param[in]    pixp pattern to be removed from image, 1 bpp</param>
''' <param name="pixe"> \param[in]    pixe image after erosion by Sel that approximates pixp, 1 bpp</param>
''' <param name="x0"> \param[in]    x0, y0 center of Sel</param>
''' <param name="y0"> \param[in]    dsize number of pixels on each side by which pixp is</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRemoveMatchedPattern")> _
Friend Shared Function pixRemoveMatchedPattern(pixs as IntPTR, pixp as IntPTR, pixe as IntPTR, x0 as Integer, y0 as Integer, dsize as Integer) as Integer
End Function

' SRC\morphapp.c (789, 1)
' pixDisplayMatchedPattern()
' pixDisplayMatchedPattern(PIX *, PIX *, PIX *, l_int32, l_int32, l_uint32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  * (1) A 4 bpp colormapped image is generated.
'''  * (2) If scale = 1.0, do scale to gray for the output, and threshold
'''  *  to nlevels of gray.
'''  * (3) You can use various functions in selgen to create a Sel
'''  *  that will generate pixe from pixs.
'''  * (4) This function is applied after pixe has been computed.
'''  *  It finds the centroid of each c.c., and colors the output
'''  *  pixels using pixp (appropriately aligned) as a stencil.
'''  *  Alignment is done using the origin of the Sel and the
'''  *  centroid of the eroded image to place the stencil pixp.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, colormapped, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs input image, 1 bpp</param>
''' <param name="pixp"> \param[in]    pixp pattern to be removed from image, 1 bpp</param>
''' <param name="pixe"> \param[in]    pixe image after erosion by Sel that approximates pixp, 1 bpp</param>
''' <param name="x0"> \param[in]    x0, y0 center of Sel</param>
''' <param name="y0"> \param[in]    color to paint the matched patterns; 0xrrggbb00</param>
''' <param name="color"> \param[in]    scale reduction factor for output pixd</param>
''' <param name="scale"> \param[in]    nlevels if scale < 1.0, threshold to this number of levels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDisplayMatchedPattern")> _
Friend Shared Function pixDisplayMatchedPattern(pixs as IntPTR, pixp as IntPTR, pixe as IntPTR, x0 as Integer, y0 as Integer, color as UInteger, scale as single, nlevels as Integer) as IntPTR
End Function

' SRC\morphapp.c (901, 1)
' pixaExtendByMorph()
' pixaExtendByMorph(PIXA *, l_int32, l_int32, SEL *, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  * (1) This dilates or erodes every pix in %pixas, iteratively,
'''  *  using the input Sel (or, if null, a 2x2 Sel by default),
'''  *  and puts the results in %pixad.
'''  * (2) If %niters = 0, this is a no-op; it returns a clone of pixas.
'''  * (3) If %include == 1, the output %pixad contains all the pix
'''  *  in %pixas.  Otherwise, it doesn't, but pixaJoin() can be
'''  *  used later to join pixas with pixad.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad   with derived pix, using all iterations, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="type"> \param[in]    type L_MORPH_DILATE, L_MORPH_ERODE</param>
''' <param name="niters"> \param[in]    niters</param>
''' <param name="sel"> \param[in]    sel used for dilation, erosion; uses 2x2 if null</param>
''' <param name="include"> \param[in]    include 1 to include a copy of the input pixas in pixad;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaExtendByMorph")> _
Friend Shared Function pixaExtendByMorph(pixas as IntPTR, type as Integer, niters as Integer, sel as IntPTR, include as Integer) as IntPTR
End Function

' SRC\morphapp.c (973, 1)
' pixaExtendByScaling()
' pixaExtendByScaling(PIXA *, NUMA *, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  * (1) This scales every pix in %pixas by each factor in %nasc.
'''  *  and puts the results in %pixad.
'''  * (2) If %include == 1, the output %pixad contains all the pix
'''  *  in %pixas.  Otherwise, it doesn't, but pixaJoin() can be
'''  *  used later to join pixas with pixad.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad   with derived pix, using all scalings, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="nasc"> \param[in]    nasc   numa of scaling factors</param>
''' <param name="type"> \param[in]    type    L_HORIZ, L_VERT, L_BOTH_DIRECTIONS</param>
''' <param name="include"> \param[in]    include 1 to include a copy of the input pixas in pixad;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaExtendByScaling")> _
Friend Shared Function pixaExtendByScaling(pixas as IntPTR, nasc as IntPTR, type as Integer, include as Integer) as IntPTR
End Function

' SRC\morphapp.c (1041, 1)
' pixSeedfillMorph()
' pixSeedfillMorph(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  * (1) This is in general a very inefficient method for filling
'''  *  from a seed into a mask.  Use it for a small number of iterations,
'''  *  but if you expect more than a few iterations, use
'''  *  pixSeedfillBinary().
'''  * (2) We use a 3x3 brick SEL for 8-cc filling and a 3x3 plus SEL for 4-cc.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd after filling into the mask or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs seed</param>
''' <param name="pixm"> \param[in]    pixm mask</param>
''' <param name="maxiters"> \param[in]    maxiters use 0 to go to completion</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfillMorph")> _
Friend Shared Function pixSeedfillMorph(pixs as IntPTR, pixm as IntPTR, maxiters as Integer, connectivity as Integer) as IntPTR
End Function

' SRC\morphapp.c (1103, 1)
' pixRunHistogramMorph()
' pixRunHistogramMorph(PIX *, l_int32, l_int32, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa of run-lengths</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="runtype"> \param[in]    runtype L_RUN_OFF, L_RUN_ON</param>
''' <param name="direction"> \param[in]    direction L_HORIZ, L_VERT</param>
''' <param name="maxsize"> \param[in]    maxsize  size of largest runlength counted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRunHistogramMorph")> _
Friend Shared Function pixRunHistogramMorph(pixs as IntPTR, runtype as Integer, direction as Integer, maxsize as Integer) as IntPTR
End Function

' SRC\morphapp.c (1203, 1)
' pixTophat()
' pixTophat(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Sel is a brick with all elements being hits
'''  *   (2) If hsize = vsize = 1, returns an image with all 0 data.
'''  *   (3) The L_TOPHAT_WHITE flag emphasizes small bright regions,
'''  * whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.
'''  * The L_TOPHAT_WHITE tophat can be accomplished by doing a
'''  * L_TOPHAT_BLACK tophat on the inverse, or v.v.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="hsize"> \param[in]    hsize of Sel; must be odd; origin implicitly in center</param>
''' <param name="vsize"> \param[in]    vsize ditto</param>
''' <param name="type"> \param[in]    type   L_TOPHAT_WHITE: image - opening</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTophat")> _
Friend Shared Function pixTophat(pixs as IntPTR, hsize as Integer, vsize as Integer, type as Integer) as IntPTR
End Function

' SRC\morphapp.c (1303, 1)
' pixHDome()
' pixHDome(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) It is more efficient to use a connectivity of 4 for the fill.
'''  *   (2) This fills bumps to some level, and extracts the unfilled
'''  * part of the bump.  To extract the troughs of basins, first
'''  * invert pixs and then apply pixHDome().
'''  *   (3) It is useful to compare the HDome operation with the TopHat.
'''  * The latter extracts peaks or valleys that have a width
'''  * not exceeding the size of the structuring element used
'''  * in the opening or closing, rsp.  The height of the peak is
'''  * irrelevant.  By contrast, for the HDome, the gray seedfill
'''  * is used to extract all peaks that have a height not exceeding
'''  * a given value, regardless of their width!
'''  *   (4) Slightly more precisely, suppose you set 'height' = 40.
'''  * Then all bumps in pixs with a height greater than or equal
'''  * to 40 become, in pixd, bumps with a max value of exactly 40.
'''  * All shorter bumps have a max value in pixd equal to the height
'''  * of the bump.
'''  *   (5) The method: the filling mask, pixs, is the image whose peaks
'''  * are to be extracted.  The height of a peak is the distance
'''  * between the top of the peak and the highest "leak" to the
'''  * outside -- think of a sombrero, where the leak occurs
'''  * at the highest point on the rim.
'''  *   (a) Generate a seed, pixd, by subtracting some value, p, from
'''  * each pixel in the filling mask, pixs.  The value p is
'''  * the 'height' input to this function.
'''  *   (b) Fill in pixd starting with this seed, clipping by pixs,
'''  * in the way described in seedfillGrayLow().  The filling
'''  * stops before the peaks in pixs are filled.
'''  * For peaks that have a height > p, pixd is filled to
'''  * the level equal to the (top-of-the-peak - p).
'''  * For peaks of height  p, the peak is left unfilled
'''  * from its highest saddle point (the leak to the outside).
'''  *   (c) Subtract the filled seed (pixd) from the filling mask (pixs).
'''  * Note that in this procedure, everything is done starting
'''  * with the filling mask, pixs.
'''  *   (6) For segmentation, the resulting image, pixd, can be thresholded
'''  * and used as a seed for another filling operation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, filling mask</param>
''' <param name="height"> \param[in]    height of seed below the filling maskhdome; must be >= 0</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixHDome")> _
Friend Shared Function pixHDome(pixs as IntPTR, height as Integer, connectivity as Integer) as IntPTR
End Function

' SRC\morphapp.c (1359, 1)
' pixFastTophat()
' pixFastTophat(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Don't be fooled. This is NOT a tophat.  It is a tophat-like
'''  * operation, where the result is similar to what you'd get
'''  * if you used an erosion instead of an opening, or a dilation
'''  * instead of a closing.
'''  *   (2) Instead of opening or closing at full resolution, it does
'''  * a fast downscale/minmax operation, then a quick small smoothing
'''  * at low res, a replicative expansion of the "background"
'''  * to full res, and finally a removal of the background level
'''  * from the input image.  The smoothing step may not be important.
'''  *   (3) It does not remove noise as well as a tophat, but it is
'''  * 5 to 10 times faster.
'''  * If you need the preciseness of the tophat, don't use this.
'''  *   (4) The L_TOPHAT_WHITE flag emphasizes small bright regions,
'''  * whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="xsize"> \param[in]    xsize width of max/min op, smoothing; any integer >= 1</param>
''' <param name="ysize"> \param[in]    ysize height of max/min op, smoothing; any integer >= 1</param>
''' <param name="type"> \param[in]    type   L_TOPHAT_WHITE: image - min</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFastTophat")> _
Friend Shared Function pixFastTophat(pixs as IntPTR, xsize as Integer, ysize as Integer, type as Integer) as IntPTR
End Function

' SRC\morphapp.c (1421, 1)
' pixMorphGradient()
' pixMorphGradient(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="hsize"> \param[in]    hsize of Sel; must be odd; origin implicitly in center</param>
''' <param name="vsize"> \param[in]    vsize ditto</param>
''' <param name="smoothing"> \param[in]    smoothing  half-width of convolution smoothing filter.</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMorphGradient")> _
Friend Shared Function pixMorphGradient(pixs as IntPTR, hsize as Integer, vsize as Integer, smoothing as Integer) as IntPTR
End Function

' SRC\morphapp.c (1475, 1)
' pixaCentroids()
' pixaCentroids(PIXA *) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) An error message is returned if any pix has something other
'''  * than 1 bpp or 8 bpp depth, and the centroid from that pix
'''  * is saved as (0, 0).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta of centroids relative to the UL corner of</returns>
''' <param name="pixa"> \param[in]    pixa of components 1 or 8 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaCentroids")> _
Friend Shared Function pixaCentroids(pixa as IntPTR) as IntPTR
End Function

' SRC\morphapp.c (1527, 1)
' pixCentroid()
' pixCentroid(PIX *, l_int32 *, l_int32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Any table not passed in will be made internally and destroyed
'''  * after use.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix 1 or 8 bpp</param>
''' <param name="centtab"> \param[in]    centtab [optional] table for finding centroids; can be null</param>
''' <param name="sumtab"> \param[in]    sumtab [optional] table for finding pixel sums; can be null</param>
''' <param name="pxave"> \param[out]   pxave, pyave coordinates of centroid, relative to</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCentroid")> _
Friend Shared Function pixCentroid(pix as IntPTR, centtab as Integer, sumtab as Integer, pxave as single, pyave as single) as Integer
End Function

#End Region
#Region "SRC\morphdwa.c"
' SRC\morphdwa.c (175, 1)
' pixDilateBrickDwa()
' pixDilateBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) These implement 2D brick Sels, using linear Sels generated
'''  * with selaAddBasic().
'''  *   (2) A brick Sel has hits for all elements.
'''  *   (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
'''  *   (4) Do separably if both hsize and vsize are > 1.
'''  *   (5) It is necessary that both horizontal and vertical Sels
'''  * of the input size are defined in the basic sela.
'''  *   (6) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (7) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixDilateBrickDwa(NULL, pixs, ...);
'''  * (b) pixDilateBrickDwa(pixs, pixs, ...);
'''  * (c) pixDilateBrickDwa(pixd, pixs, ...);
'''  *   (8) The size of pixd is determined by pixs.
'''  *   (9) If either linear Sel is not found, this calls
'''  * the appropriate decomposible function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDilateBrickDwa")> _
Friend Shared Function pixDilateBrickDwa(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morphdwa.c (277, 1)
' pixErodeBrickDwa()
' pixErodeBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) These implement 2D brick Sels, using linear Sels generated
'''  * with selaAddBasic().
'''  *   (2) A brick Sel has hits for all elements.
'''  *   (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
'''  *   (4) Do separably if both hsize and vsize are > 1.
'''  *   (5) It is necessary that both horizontal and vertical Sels
'''  * of the input size are defined in the basic sela.
'''  *   (6) Note that we must always set or clear the border pixels
'''  * before each operation, depending on the the b.c.
'''  * (symmetric or asymmetric).
'''  *   (7) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (8) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixErodeBrickDwa(NULL, pixs, ...);
'''  * (b) pixErodeBrickDwa(pixs, pixs, ...);
'''  * (c) pixErodeBrickDwa(pixd, pixs, ...);
'''  *   (9) The size of the result is determined by pixs.
'''  *   (10) If either linear Sel is not found, this calls
'''  *  the appropriate decomposible function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixErodeBrickDwa")> _
Friend Shared Function pixErodeBrickDwa(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morphdwa.c (379, 1)
' pixOpenBrickDwa()
' pixOpenBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) These implement 2D brick Sels, using linear Sels generated
'''  * with selaAddBasic().
'''  *   (2) A brick Sel has hits for all elements.
'''  *   (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
'''  *   (4) Do separably if both hsize and vsize are > 1.
'''  *   (5) It is necessary that both horizontal and vertical Sels
'''  * of the input size are defined in the basic sela.
'''  *   (6) Note that we must always set or clear the border pixels
'''  * before each operation, depending on the the b.c.
'''  * (symmetric or asymmetric).
'''  *   (7) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (8) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixOpenBrickDwa(NULL, pixs, ...);
'''  * (b) pixOpenBrickDwa(pixs, pixs, ...);
'''  * (c) pixOpenBrickDwa(pixd, pixs, ...);
'''  *   (9) The size of the result is determined by pixs.
'''  *   (10) If either linear Sel is not found, this calls
'''  *  the appropriate decomposible function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOpenBrickDwa")> _
Friend Shared Function pixOpenBrickDwa(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morphdwa.c (486, 1)
' pixCloseBrickDwa()
' pixCloseBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a 'safe' closing; we add an extra border of 32 OFF
'''  * pixels for the standard asymmetric b.c.
'''  *   (2) These implement 2D brick Sels, using linear Sels generated
'''  * with selaAddBasic().
'''  *   (3) A brick Sel has hits for all elements.
'''  *   (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
'''  *   (5) Do separably if both hsize and vsize are > 1.
'''  *   (6) It is necessary that both horizontal and vertical Sels
'''  * of the input size are defined in the basic sela.
'''  *   (7) Note that we must always set or clear the border pixels
'''  * before each operation, depending on the the b.c.
'''  * (symmetric or asymmetric).
'''  *   (8) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (9) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixCloseBrickDwa(NULL, pixs, ...);
'''  * (b) pixCloseBrickDwa(pixs, pixs, ...);
'''  * (c) pixCloseBrickDwa(pixd, pixs, ...);
'''  *   (10) The size of the result is determined by pixs.
'''  *   (11) If either linear Sel is not found, this calls
'''  *  the appropriate decomposible function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCloseBrickDwa")> _
Friend Shared Function pixCloseBrickDwa(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morphdwa.c (613, 1)
' pixDilateCompBrickDwa()
' pixDilateCompBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) These implement a separable composite dilation with 2D brick Sels.
'''  *   (2) For efficiency, it may decompose each linear morphological
'''  * operation into two (brick + comb).
'''  *   (3) A brick Sel has hits for all elements.
'''  *   (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
'''  *   (5) Do separably if both hsize and vsize are > 1.
'''  *   (6) It is necessary that both horizontal and vertical Sels
'''  * of the input size are defined in the basic sela.
'''  *   (7) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (8) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixDilateCompBrickDwa(NULL, pixs, ...);
'''  * (b) pixDilateCompBrickDwa(pixs, pixs, ...);
'''  * (c) pixDilateCompBrickDwa(pixd, pixs, ...);
'''  *   (9) The size of pixd is determined by pixs.
'''  *   (10) CAUTION: both hsize and vsize are being decomposed.
'''  * The decomposer chooses a product of sizes (call them
'''  * 'terms') for each that is close to the input size,
'''  *  but not necessarily equal to it.  It attempts to optimize:
'''  *  (a) for consistency with the input values: the product
'''  *   of terms is close to the input size
'''  *  (b) for efficiency of the operation: the sum of the
'''  *   terms is small; ideally about twice the square
'''  *    root of the input size.
'''  *  So, for example, if the input hsize = 37, which is
'''  *  a prime number, the decomposer will break this into two
'''  *  terms, 6 and 6, so that the net result is a dilation
'''  *  with hsize = 36.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDilateCompBrickDwa")> _
Friend Shared Function pixDilateCompBrickDwa(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morphdwa.c (746, 1)
' pixErodeCompBrickDwa()
' pixErodeCompBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) These implement a separable composite erosion with 2D brick Sels.
'''  *   (2) For efficiency, it may decompose each linear morphological
'''  * operation into two (brick + comb).
'''  *   (3) A brick Sel has hits for all elements.
'''  *   (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
'''  *   (5) Do separably if both hsize and vsize are > 1.
'''  *   (6) It is necessary that both horizontal and vertical Sels
'''  * of the input size are defined in the basic sela.
'''  *   (7) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (8) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixErodeCompBrickDwa(NULL, pixs, ...);
'''  * (b) pixErodeCompBrickDwa(pixs, pixs, ...);
'''  * (c) pixErodeCompBrickDwa(pixd, pixs, ...);
'''  *   (9) The size of pixd is determined by pixs.
'''  *   (10) CAUTION: both hsize and vsize are being decomposed.
'''  * The decomposer chooses a product of sizes (call them
'''  * 'terms') for each that is close to the input size,
'''  *  but not necessarily equal to it.  It attempts to optimize:
'''  *  (a) for consistency with the input values: the product
'''  *   of terms is close to the input size
'''  *  (b) for efficiency of the operation: the sum of the
'''  *   terms is small; ideally about twice the square
'''  *    root of the input size.
'''  *  So, for example, if the input hsize = 37, which is
'''  *  a prime number, the decomposer will break this into two
'''  *  terms, 6 and 6, so that the net result is a dilation
'''  *  with hsize = 36.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixErodeCompBrickDwa")> _
Friend Shared Function pixErodeCompBrickDwa(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morphdwa.c (875, 1)
' pixOpenCompBrickDwa()
' pixOpenCompBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) These implement a separable composite opening with 2D brick Sels.
'''  *   (2) For efficiency, it may decompose each linear morphological
'''  * operation into two (brick + comb).
'''  *   (3) A brick Sel has hits for all elements.
'''  *   (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
'''  *   (5) Do separably if both hsize and vsize are > 1.
'''  *   (6) It is necessary that both horizontal and vertical Sels
'''  * of the input size are defined in the basic sela.
'''  *   (7) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (8) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixOpenCompBrickDwa(NULL, pixs, ...);
'''  * (b) pixOpenCompBrickDwa(pixs, pixs, ...);
'''  * (c) pixOpenCompBrickDwa(pixd, pixs, ...);
'''  *   (9) The size of pixd is determined by pixs.
'''  *   (10) CAUTION: both hsize and vsize are being decomposed.
'''  * The decomposer chooses a product of sizes (call them
'''  * 'terms') for each that is close to the input size,
'''  *  but not necessarily equal to it.  It attempts to optimize:
'''  *  (a) for consistency with the input values: the product
'''  *   of terms is close to the input size
'''  *  (b) for efficiency of the operation: the sum of the
'''  *   terms is small; ideally about twice the square
'''  *    root of the input size.
'''  *  So, for example, if the input hsize = 37, which is
'''  *  a prime number, the decomposer will break this into two
'''  *  terms, 6 and 6, so that the net result is a dilation
'''  *  with hsize = 36.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOpenCompBrickDwa")> _
Friend Shared Function pixOpenCompBrickDwa(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morphdwa.c (1042, 1)
' pixCloseCompBrickDwa()
' pixCloseCompBrickDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This implements a separable composite safe closing with 2D
'''  * brick Sels.
'''  *   (2) For efficiency, it may decompose each linear morphological
'''  * operation into two (brick + comb).
'''  *   (3) A brick Sel has hits for all elements.
'''  *   (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
'''  *   (5) Do separably if both hsize and vsize are > 1.
'''  *   (6) It is necessary that both horizontal and vertical Sels
'''  * of the input size are defined in the basic sela.
'''  *   (7) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (8) For clarity, if the case is known, use these patterns:
'''  * (a) pixd = pixCloseCompBrickDwa(NULL, pixs, ...);
'''  * (b) pixCloseCompBrickDwa(pixs, pixs, ...);
'''  * (c) pixCloseCompBrickDwa(pixd, pixs, ...);
'''  *   (9) The size of pixd is determined by pixs.
'''  *   (10) CAUTION: both hsize and vsize are being decomposed.
'''  * The decomposer chooses a product of sizes (call them
'''  * 'terms') for each that is close to the input size,
'''  *  but not necessarily equal to it.  It attempts to optimize:
'''  *  (a) for consistency with the input values: the product
'''  *   of terms is close to the input size
'''  *  (b) for efficiency of the operation: the sum of the
'''  *   terms is small; ideally about twice the square
'''  *    root of the input size.
'''  *  So, for example, if the input hsize = 37, which is
'''  *  a prime number, the decomposer will break this into two
'''  *  terms, 6 and 6, so that the net result is a dilation
'''  *  with hsize = 36.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCloseCompBrickDwa")> _
Friend Shared Function pixCloseCompBrickDwa(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morphdwa.c (1192, 1)
' pixDilateCompBrickExtendDwa()
' pixDilateCompBrickExtendDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Ankur Jain suggested and implemented extending the composite
'''  * DWA operations beyond the 63 pixel limit.  This is a
'''  * simplified and approximate implementation of the extension.
'''  * This allows arbitrary Dwa morph operations using brick Sels,
'''  * by decomposing the horizontal and vertical dilations into
'''  * a sequence of 63-element dilations plus a dilation of size
'''  * between 3 and 62.
'''  *   (2) The 63-element dilations are exact, whereas the extra dilation
'''  * is approximate, because the underlying decomposition is
'''  * in pixDilateCompBrickDwa().  See there for further details.
'''  *   (3) There are three cases:
'''  * (a) pixd == null   (result into new pixd)
'''  * (b) pixd == pixs   (in-place; writes result back to pixs)
'''  * (c) pixd != pixs   (puts result into existing pixd)
'''  *   (4) There is no need to call this directly:  pixDilateCompBrickDwa()
'''  * calls this function if either brick dimension exceeds 63.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDilateCompBrickExtendDwa")> _
Friend Shared Function pixDilateCompBrickExtendDwa(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morphdwa.c (1312, 1)
' pixErodeCompBrickExtendDwa()
' pixErodeCompBrickExtendDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixDilateCompBrickExtendDwa() for usage.
'''  *   (2) There is no need to call this directly:  pixErodeCompBrickDwa()
'''  * calls this function if either brick dimension exceeds 63.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixErodeCompBrickExtendDwa")> _
Friend Shared Function pixErodeCompBrickExtendDwa(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morphdwa.c (1432, 1)
' pixOpenCompBrickExtendDwa()
' pixOpenCompBrickExtendDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOpenCompBrickExtendDwa")> _
Friend Shared Function pixOpenCompBrickExtendDwa(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morphdwa.c (1473, 1)
' pixCloseCompBrickExtendDwa()
' pixCloseCompBrickExtendDwa(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="hsize"> \param[in]    hsize width of brick Sel</param>
''' <param name="vsize"> \param[in]    vsize height of brick Sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCloseCompBrickExtendDwa")> _
Friend Shared Function pixCloseCompBrickExtendDwa(pixd as IntPTR, pixs as IntPTR, hsize as Integer, vsize as Integer) as IntPTR
End Function

' SRC\morphdwa.c (1562, 1)
' getExtendedCompositeParameters()
' getExtendedCompositeParameters(l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The DWA implementation allows Sels to be used with hits
'''  * up to 31 pixels from the origin, either horizontally or
'''  * vertically.  Larger Sels can be used if decomposed into
'''  * a set of operations with Sels not exceeding 63 pixels
'''  * in either width or height (and with the origin as close
'''  * to the center of the Sel as possible).
'''  *   (2) This returns the decomposition of a linear Sel of length
'''  * %size into a set of %n Sels of length 63 plus an extra
'''  * Sel of length %extra.
'''  *   (3) For notation, let w == %size, n == %n, and e == %extra.
'''  * We have 1  e  63.
'''  *
'''  * Then if w  64, we have n = 0 and e = w.
'''  * The general formula for w > 63 is:
'''  * w = 63 + (n - 1) * 62 + (e - 1)
'''  *
'''  * Where did this come from?  Each successive convolution with
'''  * a Sel of length L adds a total length (L - 1) to w.
'''  * This accounts for using 62 for each additional Sel of size 63,
'''  * and using (e - 1) for the additional Sel of size e.
'''  *
'''  * Solving for n and e for w > 63:
'''  * n = 1 + Int((w - 63) / 62)
'''  * e = w - 63 - (n - 1) * 62 + 1
'''  *
'''  * The extra part is decomposed into two factors f1 and f2,
'''  * and the actual size of the extra part is
'''  * e' = f1 * f2
'''  * Then the actual width is:
'''  * w' = 63 + (n - 1) * 62 + f1 * f2 - 1
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="size"> \param[in]    size of linear Sel</param>
''' <param name="pn"> \param[out]   pn number of 63 wide convolutions</param>
''' <param name="pextra"> \param[out]   pextra size of extra Sel</param>
''' <param name="pactualsize"> \param[out]   pactualsize [optional] actual size used in operation</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getExtendedCompositeParameters")> _
Friend Shared Function getExtendedCompositeParameters(size as Integer, pn as Integer, pextra as Integer, pactualsize as Integer) as Integer
End Function

#End Region
#Region "SRC\morphseq.c"
' SRC\morphseq.c (133, 1)
' pixMorphSequence()
' pixMorphSequence(PIX *, const char *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does rasterop morphology on binary images.
'''  *   (2) This runs a pipeline of operations; no branching is allowed.
'''  *   (3) This only uses brick Sels, which are created on the fly.
'''  * In the future this will be generalized to extract Sels from
'''  * a Sela by name.
'''  *   (4) A new image is always produced; the input image is not changed.
'''  *   (5) This contains an interpreter, allowing sequences to be
'''  * generated and run.
'''  *   (6) The format of the sequence string is defined below.
'''  *   (7) In addition to morphological operations, rank order reduction
'''  * and replicated expansion allow operations to take place
'''  * downscaled by a power of 2.
'''  *   (8) Intermediate results can optionally be displayed.
'''  *   (9) Thanks to Dar-Shyang Lee, who had the idea for this and
'''  * built the first implementation.
'''  *   (10) The sequence string is formatted as follows:
'''  *   ~ An arbitrary number of operations,  each separated
'''  *  by a '+' character.  White space is ignored.
'''  *   ~ Each operation begins with a case-independent character
'''  *  specifying the operation:
'''  *  d or D  (dilation)
'''  *  e or E  (erosion)
'''  *  o or O  (opening)
'''  *  c or C  (closing)
'''  *  r or R  (rank binary reduction)
'''  *  x or X  (replicative binary expansion)
'''  *  b or B  (add a border of 0 pixels of this size)
'''  *   ~ The args to the morphological operations are bricks of hits,
'''  *  and are formatted as a.b, where a and b are horizontal and
'''  *  vertical dimensions, rsp.
'''  *   ~ The args to the reduction are a sequence of up to 4 integers,
'''  *  each from 1 to 4.
'''  *   ~ The arg to the expansion is a power of two, in the set
'''  *  {2, 4, 8, 16}.
'''  *   (11) An example valid sequence is:
'''  *   "b32 + o1.3 + C3.1 + r23 + e2.2 + D3.2 + X4"
'''  *  In this example, the following operation sequence is carried out:
'''  * * b32: Add a 32 pixel border around the input image
'''  * * o1.3: Opening with vert sel of length 3 (e.g., 1 x 3)
'''  * * C3.1: Closing with horiz sel of length 3  (e.g., 3 x 1)
'''  * * r23: Two successive 2x2 reductions with rank 2 in the first
'''  *  and rank 3 in the second.  The result is a 4x reduced pix.
'''  * * e2.2: Erosion with a 2x2 sel (origin will be at x,y: 0,0)
'''  * * d3.2: Dilation with a 3x2 sel (origin will be at x,y: 1,0)
'''  * * X4: 4x replicative expansion, back to original resolution
'''  *   (12) The safe closing is used.  However, if you implement a
'''  *  closing as separable dilations followed by separable erosions,
'''  *  it will not be safe.  For that situation, you need to add
'''  *  a sufficiently large border as the first operation in
'''  *  the sequence.  This will be removed automatically at the
'''  *  end.  There are two cautions:
'''  *  ~ When computing what is sufficient, remember that if
'''  * reductions are carried out, the border is also reduced.
'''  *  ~ The border is removed at the end, so if a border is
'''  * added at the beginning, the result must be at the
'''  * same resolution as the input!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="sequence"> \param[in]    sequence string specifying sequence</param>
''' <param name="dispsep"> \param[in]    dispsep controls debug display of each result in the sequence:</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMorphSequence")> _
Friend Shared Function pixMorphSequence(pixs as IntPTR, sequence as String, dispsep as Integer) as IntPTR
End Function

' SRC\morphseq.c (300, 1)
' pixMorphCompSequence()
' pixMorphCompSequence(PIX *, const char *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does rasterop morphology on binary images, using composite
'''  * operations for extra speed on large Sels.
'''  *   (2) Safe closing is used atomically.  However, if you implement a
'''  * closing as a sequence with a dilation followed by an
'''  * erosion, it will not be safe, and to ensure that you have
'''  * no boundary effects you must add a border in advance and
'''  * remove it at the end.
'''  *   (3) For other usage details, see the notes for pixMorphSequence().
'''  *   (4) The sequence string is formatted as follows:
'''  *   ~ An arbitrary number of operations,  each separated
'''  *  by a '+' character.  White space is ignored.
'''  *   ~ Each operation begins with a case-independent character
'''  *  specifying the operation:
'''  *  d or D  (dilation)
'''  *  e or E  (erosion)
'''  *  o or O  (opening)
'''  *  c or C  (closing)
'''  *  r or R  (rank binary reduction)
'''  *  x or X  (replicative binary expansion)
'''  *  b or B  (add a border of 0 pixels of this size)
'''  *   ~ The args to the morphological operations are bricks of hits,
'''  *  and are formatted as a.b, where a and b are horizontal and
'''  *  vertical dimensions, rsp.
'''  *   ~ The args to the reduction are a sequence of up to 4 integers,
'''  *  each from 1 to 4.
'''  *   ~ The arg to the expansion is a power of two, in the set
'''  *  {2, 4, 8, 16}.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="sequence"> \param[in]    sequence string specifying sequence</param>
''' <param name="dispsep"> \param[in]    dispsep controls debug display of each result in the sequence:</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMorphCompSequence")> _
Friend Shared Function pixMorphCompSequence(pixs as IntPTR, sequence as String, dispsep as Integer) as IntPTR
End Function

' SRC\morphseq.c (449, 1)
' pixMorphSequenceDwa()
' pixMorphSequenceDwa(PIX *, const char *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does dwa morphology on binary images.
'''  *   (2) This runs a pipeline of operations; no branching is allowed.
'''  *   (3) This only uses brick Sels that have been pre-compiled with
'''  * dwa code.
'''  *   (4) A new image is always produced; the input image is not changed.
'''  *   (5) This contains an interpreter, allowing sequences to be
'''  * generated and run.
'''  *   (6) See pixMorphSequence() for further information about usage.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="sequence"> \param[in]    sequence string specifying sequence</param>
''' <param name="dispsep"> \param[in]    dispsep controls debug display of each result in the sequence:</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMorphSequenceDwa")> _
Friend Shared Function pixMorphSequenceDwa(pixs as IntPTR, sequence as String, dispsep as Integer) as IntPTR
End Function

' SRC\morphseq.c (598, 1)
' pixMorphCompSequenceDwa()
' pixMorphCompSequenceDwa(PIX *, const char *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does dwa morphology on binary images, using brick Sels.
'''  *   (2) This runs a pipeline of operations; no branching is allowed.
'''  *   (3) It implements all brick Sels that have dimensions up to 63
'''  * on each side, using a composite (linear + comb) when useful.
'''  *   (4) A new image is always produced; the input image is not changed.
'''  *   (5) This contains an interpreter, allowing sequences to be
'''  * generated and run.
'''  *   (6) See pixMorphSequence() for further information about usage.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="sequence"> \param[in]    sequence string specifying sequence</param>
''' <param name="dispsep"> \param[in]    dispsep controls debug display of each result in the sequence:</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMorphCompSequenceDwa")> _
Friend Shared Function pixMorphCompSequenceDwa(pixs as IntPTR, sequence as String, dispsep as Integer) as IntPTR
End Function

' SRC\morphseq.c (737, 1)
' morphSequenceVerify()
' morphSequenceVerify(SARRAY *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This does verification of valid binary morphological
'''  * operation sequences.
'''  *   (2) See pixMorphSequence() for notes on valid operations
'''  * in the sequence.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  TRUE if valid; FALSE otherwise or on error</returns>
''' <param name="sa"> \param[in]    sa string array of operation sequence</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="morphSequenceVerify")> _
Friend Shared Function morphSequenceVerify(sa as IntPTR) as Integer
End Function

' SRC\morphseq.c (912, 1)
' pixGrayMorphSequence()
' pixGrayMorphSequence(PIX *, const char *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This works on 8 bpp grayscale images.
'''  *   (2) This runs a pipeline of operations; no branching is allowed.
'''  *   (3) This only uses brick SELs.
'''  *   (4) A new image is always produced; the input image is not changed.
'''  *   (5) This contains an interpreter, allowing sequences to be
'''  * generated and run.
'''  *   (6) The format of the sequence string is defined below.
'''  *   (7) In addition to morphological operations, the composite
'''  * morph/subtract tophat can be performed.
'''  *   (8) Sel sizes (width, height) must each be odd numbers.
'''  *   (9) Intermediate results can optionally be displayed
'''  *   (10) The sequence string is formatted as follows:
'''  *   ~ An arbitrary number of operations,  each separated
'''  *  by a '+' character.  White space is ignored.
'''  *   ~ Each operation begins with a case-independent character
'''  *  specifying the operation:
'''  *  d or D  (dilation)
'''  *  e or E  (erosion)
'''  *  o or O  (opening)
'''  *  c or C  (closing)
'''  *  t or T  (tophat)
'''  *   ~ The args to the morphological operations are bricks of hits,
'''  *  and are formatted as a.b, where a and b are horizontal and
'''  *  vertical dimensions, rsp. (each must be an odd number)
'''  *   ~ The args to the tophat are w or W (for white tophat)
'''  *  or b or B (for black tophat), followed by a.b as for
'''  *  the dilation, erosion, opening and closing.
'''  *  Example valid sequences are:
'''  * "c5.3 + o7.5"
'''  * "c9.9 + tw9.9"
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="sequence"> \param[in]    sequence string specifying sequence</param>
''' <param name="dispsep"> \param[in]    dispsep controls debug display of each result in the sequence:</param>
''' <param name="dispy"> \param[in]    dispy if dispsep > 0, this gives the y-value of the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGrayMorphSequence")> _
Friend Shared Function pixGrayMorphSequence(pixs as IntPTR, sequence as String, dispsep as Integer, dispy as Integer) as IntPTR
End Function

' SRC\morphseq.c (1117, 1)
' pixColorMorphSequence()
' pixColorMorphSequence(PIX *, const char *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This works on 32 bpp rgb images.
'''  *   (2) Each component is processed separately.
'''  *   (3) This runs a pipeline of operations; no branching is allowed.
'''  *   (4) This only uses brick SELs.
'''  *   (5) A new image is always produced; the input image is not changed.
'''  *   (6) This contains an interpreter, allowing sequences to be
'''  * generated and run.
'''  *   (7) Sel sizes (width, height) must each be odd numbers.
'''  *   (8) The format of the sequence string is defined below.
'''  *   (9) Intermediate results can optionally be displayed.
'''  *   (10) The sequence string is formatted as follows:
'''  *   ~ An arbitrary number of operations,  each separated
'''  *  by a '+' character.  White space is ignored.
'''  *   ~ Each operation begins with a case-independent character
'''  *  specifying the operation:
'''  *  d or D  (dilation)
'''  *  e or E  (erosion)
'''  *  o or O  (opening)
'''  *  c or C  (closing)
'''  *   ~ The args to the morphological operations are bricks of hits,
'''  *  and are formatted as a.b, where a and b are horizontal and
'''  *  vertical dimensions, rsp. (each must be an odd number)
'''  *  Example valid sequences are:
'''  * "c5.3 + o7.5"
'''  * "D9.1"
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="sequence"> \param[in]    sequence string specifying sequence</param>
''' <param name="dispsep"> \param[in]    dispsep controls debug display of each result in the sequence:</param>
''' <param name="dispy"> \param[in]    dispy if dispsep > 0, this gives the y-value of the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorMorphSequence")> _
Friend Shared Function pixColorMorphSequence(pixs as IntPTR, sequence as String, dispsep as Integer, dispy as Integer) as IntPTR
End Function

#End Region
#Region "SRC\numabasic.c"
' SRC\numabasic.c (173, 16)
' numaExtendArray()
' numaExtendArray(NUMA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaExtendArray")> _
Friend Shared Function numaExtendArray(na as IntPTR) as Integer
End Function

' SRC\numabasic.c (174, 16)
' numaaExtendArray()
' numaaExtendArray(NUMAA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="naa"> \param[in]    naa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaExtendArray")> _
Friend Shared Function numaaExtendArray(naa as IntPTR) as Integer
End Function

' SRC\numabasic.c (187, 1)
' numaCreate()
' numaCreate(l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na, or NULL on error</returns>
''' <param name="n"> \param[in]    n size of number array to be alloc'd 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaCreate")> _
Friend Shared Function numaCreate(n as Integer) as IntPTR
End Function

' SRC\numabasic.c (228, 1)
' numaCreateFromIArray()
' numaCreateFromIArray(l_int32 *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) We can't insert this int array into the numa, because a numa
'''  * takes a float array.  So this just copies the data from the
'''  * input array into the numa.  The input array continues to be
'''  * owned by the caller.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na, or NULL on error</returns>
''' <param name="iarray"> \param[in]    iarray integer</param>
''' <param name="size"> \param[in]    size of the array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaCreateFromIArray")> _
Friend Shared Function numaCreateFromIArray(iarray as Integer, size as Integer) as IntPTR
End Function

' SRC\numabasic.c (265, 1)
' numaCreateFromFArray()
' numaCreateFromFArray(l_float32 *, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) With L_INSERT, ownership of the input array is transferred
'''  * to the returned numa, and all %size elements are considered
'''  * to be valid.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na, or NULL on error</returns>
''' <param name="farray"> \param[in]    farray float</param>
''' <param name="size"> \param[in]    size of the array</param>
''' <param name="copyflag"> \param[in]    copyflag L_INSERT or L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaCreateFromFArray")> _
Friend Shared Function numaCreateFromFArray(farray as single, size as Integer, copyflag as Integer) as IntPTR
End Function

' SRC\numabasic.c (309, 1)
' numaCreateFromString()
' numaCreateFromString(const char *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The numbers can be ints or floats; they will be interpreted
'''  * and stored as floats.  To use them as integers (e.g., for
'''  * indexing into arrays), use numaGetIValue(...).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na, or NULL on error</returns>
''' <param name="str"> \param[in]    str string of comma-separated numbers</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaCreateFromString")> _
Friend Shared Function numaCreateFromString(str as String) as IntPTR
End Function

' SRC\numabasic.c (360, 1)
' numaDestroy()
' numaDestroy(NUMA **) as void
''' <summary>
''' * Notes:
'''  *   (1) Decrements the ref count and, if 0, destroys the numa.
'''  *   (2) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pna"> \param[in,out] pna to be nulled if it exists</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaDestroy")> _
Friend Shared Function numaDestroy(pna as Object) as Boolean ' Org. Void
End Function

' SRC\numabasic.c (394, 1)
' numaCopy()
' numaCopy(NUMA *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  copy of numa, or NULL on error</returns>
''' <param name="na"> \param[in]    na</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaCopy")> _
Friend Shared Function numaCopy(na as IntPTR) as IntPTR
End Function

' SRC\numabasic.c (423, 1)
' numaClone()
' numaClone(NUMA *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to same numa, or NULL on error</returns>
''' <param name="na"> \param[in]    na</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaClone")> _
Friend Shared Function numaClone(na as IntPTR) as IntPTR
End Function

' SRC\numabasic.c (449, 1)
' numaEmpty()
' numaEmpty(NUMA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does not change the allocation of the array.
'''  * It just clears the number of stored numbers, so that
'''  * the array appears to be empty.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaEmpty")> _
Friend Shared Function numaEmpty(na as IntPTR) as Integer
End Function

' SRC\numabasic.c (473, 1)
' numaAddNumber()
' numaAddNumber(NUMA *, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="val"> \param[in]    val  float or int to be added; stored as a float</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaAddNumber")> _
Friend Shared Function numaAddNumber(na as IntPTR, val as single) as Integer
End Function

' SRC\numabasic.c (534, 1)
' numaInsertNumber()
' numaInsertNumber(NUMA *, l_int32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This shifts na[i] --> na[i + 1] for all i >= index,
'''  * and then inserts val as na[index].
'''  *   (2) It should not be used repeatedly on large arrays,
'''  * because the function is O(n).
'''  *
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="index"> \param[in]    index location in na to insert new value</param>
''' <param name="val"> \param[in]    val  float32 or integer to be added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaInsertNumber")> _
Friend Shared Function numaInsertNumber(na as IntPTR, index as Integer, val as single) as Integer
End Function

' SRC\numabasic.c (573, 1)
' numaRemoveNumber()
' numaRemoveNumber(NUMA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This shifts na[i] --> na[i - 1] for all i > index.
'''  *   (2) It should not be used repeatedly on large arrays,
'''  * because the function is O(n).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="index"> \param[in]    index element to be removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaRemoveNumber")> _
Friend Shared Function numaRemoveNumber(na as IntPTR, index as Integer) as Integer
End Function

' SRC\numabasic.c (602, 1)
' numaReplaceNumber()
' numaReplaceNumber(NUMA *, l_int32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="index"> \param[in]    index element to be replaced</param>
''' <param name="val"> \param[in]    val new value to replace old one</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaReplaceNumber")> _
Friend Shared Function numaReplaceNumber(na as IntPTR, index as Integer, val as single) as Integer
End Function

' SRC\numabasic.c (631, 1)
' numaGetCount()
' numaGetCount(NUMA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 if no numbers or on error</returns>
''' <param name="na"> \param[in]    na</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetCount")> _
Friend Shared Function numaGetCount(na as IntPTR) as Integer
End Function

' SRC\numabasic.c (658, 1)
' numaSetCount()
' numaSetCount(NUMA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If newcount = na->nalloc, this resets na->n.
'''  * Using newcount = 0 is equivalent to numaEmpty().
'''  *   (2) If newcount > na->nalloc, this causes a realloc
'''  * to a size na->nalloc = newcount.
'''  *   (3) All the previously unused values in na are set to 0.0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="newcount"> \param[in]    newcount</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSetCount")> _
Friend Shared Function numaSetCount(na as IntPTR, newcount as Integer) as Integer
End Function

' SRC\numabasic.c (692, 1)
' numaGetFValue()
' numaGetFValue(NUMA *, l_int32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Caller may need to check the function return value to
'''  * decide if a 0.0 in the returned ival is valid.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="index"> \param[in]    index into numa</param>
''' <param name="pval"> \param[out]   pval  float value; 0.0 on error</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetFValue")> _
Friend Shared Function numaGetFValue(na as IntPTR, index as Integer, pval as single) as Integer
End Function

' SRC\numabasic.c (727, 1)
' numaGetIValue()
' numaGetIValue(NUMA *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Caller may need to check the function return value to
'''  * decide if a 0 in the returned ival is valid.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="index"> \param[in]    index into numa</param>
''' <param name="pival"> \param[out]   pival  integer value; 0 on error</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetIValue")> _
Friend Shared Function numaGetIValue(na as IntPTR, index as Integer, pival as Integer) as Integer
End Function

' SRC\numabasic.c (759, 1)
' numaSetValue()
' numaSetValue(NUMA *, l_int32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="index"> \param[in]    index   to element to be set</param>
''' <param name="val"> \param[in]    val  to set element</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSetValue")> _
Friend Shared Function numaSetValue(na as IntPTR, index as Integer, val as single) as Integer
End Function

' SRC\numabasic.c (784, 1)
' numaShiftValue()
' numaShiftValue(NUMA *, l_int32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="index"> \param[in]    index to element to change relative to the current value</param>
''' <param name="diff"> \param[in]    diff  increment if diff > 0 or decrement if diff < 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaShiftValue")> _
Friend Shared Function numaShiftValue(na as IntPTR, index as Integer, diff as single) as Integer
End Function

' SRC\numabasic.c (820, 1)
' numaGetIArray()
' numaGetIArray(NUMA *) as l_int32 *
''' <summary>
''' * Notes:
'''  *   (1) A copy of the array is always made, because we need to
'''  * generate an integer array from the bare float array.
'''  * The caller is responsible for freeing the array.
'''  *   (2) The array size is determined by the number of stored numbers,
'''  * not by the size of the allocated array in the Numa.
'''  *   (3) This function is provided to simplify calculations
'''  * using the bare internal array, rather than continually
'''  * calling accessors on the numa.  It is typically used
'''  * on an array of size 256.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  a copy of the bare internal array, integerized</returns>
''' <param name="na"> \param[in]    na</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetIArray")> _
Friend Shared Function numaGetIArray(na as IntPTR) as String
End Function

' SRC\numabasic.c (865, 1)
' numaGetFArray()
' numaGetFArray(NUMA *, l_int32) as l_float32 *
''' <summary>
''' * Notes:
'''  *   (1) If copyflag == L_COPY, it makes a copy which the caller
'''  * is responsible for freeing.  Otherwise, it operates
'''  * directly on the bare array of the numa.
'''  *   (2) Very important: for L_NOCOPY, any writes to the array
'''  * will be in the numa.  Do not write beyond the size of
'''  * the count field, because it will not be accessible
'''  * from the numa!  If necessary, be sure to set the count
'''  * field to a larger number (such as the alloc size)
'''  * BEFORE calling this function.  Creating with numaMakeConstant()
'''  * is another way to insure full initialization.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  either the bare internal array or a copy of it,</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="copyflag"> \param[in]    copyflag L_NOCOPY or L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetFArray")> _
Friend Shared Function numaGetFArray(na as IntPTR, copyflag as Integer) as String
End Function

' SRC\numabasic.c (897, 1)
' numaGetRefCount()
' numaGetRefcount(NUMA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  refcount, or UNDEF on error</returns>
''' <param name="na"> \param[in]    na</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetRefcount")> _
Friend Shared Function numaGetRefcount(na as IntPTR) as Integer
End Function

' SRC\numabasic.c (915, 1)
' numaChangeRefCount()
' numaChangeRefcount(NUMA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="delta"> \param[in]    delta change to be applied</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaChangeRefcount")> _
Friend Shared Function numaChangeRefcount(na as IntPTR, delta as Integer) as Integer
End Function

' SRC\numabasic.c (936, 1)
' numaGetParameters()
' numaGetParameters(NUMA *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="pstartx"> \param[out]   pstartx [optional] startx</param>
''' <param name="pdelx"> \param[out]   pdelx [optional] delx</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetParameters")> _
Friend Shared Function numaGetParameters(na as IntPTR, pstartx as single, pdelx as single) as Integer
End Function

' SRC\numabasic.c (966, 1)
' numaSetParameters()
' numaSetParameters(NUMA *, l_float32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="startx"> \param[in]    startx x value corresponding to na[0]</param>
''' <param name="delx"> \param[in]    delx difference in x values for the situation where the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSetParameters")> _
Friend Shared Function numaSetParameters(na as IntPTR, startx as single, delx as single) as Integer
End Function

' SRC\numabasic.c (989, 1)
' numaCopyParameters()
' numaCopyParameters(NUMA *, NUMA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nad"> \param[in]    nad destination Numa</param>
''' <param name="nas"> \param[in]    nas source Numa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaCopyParameters")> _
Friend Shared Function numaCopyParameters(nad as IntPTR, nas as IntPTR) as Integer
End Function

' SRC\numabasic.c (1027, 1)
' numaConvertToSarray()
' numaConvertToSarray(NUMA *, l_int32, l_int32, l_int32, l_int32) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) For integer conversion, size2 is ignored.
'''  * For float conversion, addzeroes is ignored.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  a sarray of the float values converted to strings</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="size1"> \param[in]    size1 size of conversion field</param>
''' <param name="size2"> \param[in]    size2 for float conversion: size of field to the right</param>
''' <param name="addzeros"> \param[in]    addzeros for integer conversion: to add lead zeros</param>
''' <param name="type"> \param[in]    type L_INTEGER_VALUE, L_FLOAT_VALUE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaConvertToSarray")> _
Friend Shared Function numaConvertToSarray(na as IntPTR, size1 as Integer, size2 as Integer, addzeros as Integer, type as Integer) as IntPTR
End Function

' SRC\numabasic.c (1083, 1)
' numaRead()
' numaRead(const char *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaRead")> _
Friend Shared Function numaRead(filename as String) as IntPTR
End Function

' SRC\numabasic.c (1110, 1)
' numaReadStream()
' numaReadStream(FILE *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaReadStream")> _
Friend Shared Function numaReadStream(fp as Object) as IntPTR
End Function

' SRC\numabasic.c (1156, 1)
' numaReadMem()
' numaReadMem(const l_uint8 *, size_t) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na, or NULL on error</returns>
''' <param name="data"> \param[in]    data  numa serialization; in ascii</param>
''' <param name="size"> \param[in]    size  of data; can use strlen to get it</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaReadMem")> _
Friend Shared Function numaReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\numabasic.c (1193, 1)
' numaWriteDebug()
' numaWriteDebug(const char *, NUMA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Debug version, intended for use in the library when writing
'''  * to files in a temp directory with names that are compiled in.
'''  * This is used instead of numaWrite() for all such library calls.
'''  *   (2) The global variable LeptDebugOK defaults to 0, and can be set
'''  * or cleared by the function setLeptDebugOK().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="na"> \param[in]    na</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaWriteDebug")> _
Friend Shared Function numaWriteDebug(filename as String, na as IntPTR) as Integer
End Function

' SRC\numabasic.c (1214, 1)
' numaWrite()
' numaWrite(const char *, NUMA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename, na</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaWrite")> _
Friend Shared Function numaWrite(filename as String, na as IntPTR) as Integer
End Function

' SRC\numabasic.c (1245, 1)
' numaWriteStream()
' numaWriteStream(FILE *, NUMA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="na"> \param[in]    na</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaWriteStream")> _
Friend Shared Function numaWriteStream(fp as Object, na as IntPTR) as Integer
End Function

' SRC\numabasic.c (1288, 1)
' numaWriteMem()
' numaWriteMem(l_uint8 **, size_t *, NUMA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a numa in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of serialized numa; ascii</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="na"> \param[in]    na</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaWriteMem")> _
Friend Shared Function numaWriteMem(pdata as Object, psize as ULong, na as IntPTR) as Integer
End Function

' SRC\numabasic.c (1339, 1)
' numaaCreate()
' numaaCreate(l_int32) as NUMAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  naa, or NULL on error</returns>
''' <param name="n"> \param[in]    n size of numa ptr array to be alloc'd 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaCreate")> _
Friend Shared Function numaaCreate(n as Integer) as IntPTR
End Function

' SRC\numabasic.c (1377, 1)
' numaaCreateFull()
' numaaCreateFull(l_int32, l_int32) as NUMAA *
''' <summary>
''' * Notes:
'''  *   (1) This allocates numaa and fills the array with allocated numas.
'''  * In use, after calling this function, use
'''  *  numaaAddNumber(naa, index, val);
'''  * to add val to the index-th numa in naa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  naa, or NULL on error</returns>
''' <param name="nptr"> \param[in]    nptr: size of numa ptr array to be alloc'd</param>
''' <param name="n"> \param[in]    n: size of individual numa arrays to be alloc'd 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaCreateFull")> _
Friend Shared Function numaaCreateFull(nptr as Integer, n as Integer) as IntPTR
End Function

' SRC\numabasic.c (1408, 1)
' numaaTruncate()
' numaaTruncate(NUMAA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This identifies the largest index containing a numa that
'''  * has any numbers within it, destroys all numa beyond that
'''  * index, and resets the count.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="naa"> \param[in]    naa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaTruncate")> _
Friend Shared Function numaaTruncate(naa as IntPTR) as Integer
End Function

' SRC\numabasic.c (1442, 1)
' numaaDestroy()
' numaaDestroy(NUMAA **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pnaa"> \param[in,out]  pnaa to be nulled if it exists</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaDestroy")> _
Friend Shared Function numaaDestroy(pnaa as Object) as Boolean ' Org. Void
End Function

' SRC\numabasic.c (1480, 1)
' numaaAddNuma()
' numaaAddNuma(NUMAA *, NUMA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="naa"> \param[in]    naa</param>
''' <param name="na"> \param[in]    na   to be added</param>
''' <param name="copyflag"> \param[in]    copyflag  L_INSERT, L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaAddNuma")> _
Friend Shared Function numaaAddNuma(naa as IntPTR, na as IntPTR, copyflag as Integer) as Integer
End Function

' SRC\numabasic.c (1548, 1)
' numaaGetCount()
' numaaGetCount(NUMAA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count number of numa, or 0 if no numa or on error</returns>
''' <param name="naa"> \param[in]    naa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaGetCount")> _
Friend Shared Function numaaGetCount(naa as IntPTR) as Integer
End Function

' SRC\numabasic.c (1566, 1)
' numaaGetNumaCount()
' numaaGetNumaCount(NUMAA *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count of numbers in the referenced numa, or 0 on error.</returns>
''' <param name="naa"> \param[in]    naa</param>
''' <param name="index"> \param[in]    index of numa in naa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaGetNumaCount")> _
Friend Shared Function numaaGetNumaCount(naa as IntPTR, index as Integer) as Integer
End Function

' SRC\numabasic.c (1587, 1)
' numaaGetNumberCount()
' numaaGetNumberCount(NUMAA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count total number of numbers in the numaa,</returns>
''' <param name="naa"> \param[in]    naa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaGetNumberCount")> _
Friend Shared Function numaaGetNumberCount(naa as IntPTR) as Integer
End Function

' SRC\numabasic.c (1636, 1)
' numaaGetPtrArray()
' numaaGetPtrArray(NUMAA *) as NUMA **
''' <summary>
''' * Notes:
'''  *   (1) This function is convenient for doing direct manipulation on
'''  * a fixed size array of Numas.  To do this, it sets the count
'''  * to the full size of the allocated array of Numa ptrs.
'''  * The originating Numaa owns this array: DO NOT free it!
'''  *   (2) Intended usage:
'''  *   Numaa *naa = numaaCreate(n);
'''  *   Numa **array = numaaGetPtrArray(naa);
'''  * ...  [manipulate Numas directly on the array]
'''  *   numaaDestroy(&naa);
'''  *   (3) Cautions:
'''  *  ~ Do not free this array; it is owned by tne Numaa.
'''  *  ~ Do not call any functions on the Numaa, other than
'''  * numaaDestroy() when you're finished with the array.
'''  * Adding a Numa will force a resize, destroying the ptr array.
'''  *  ~ Do not address the array outside its allocated size.
'''  * With the bare array, there are no protections.  If the
'''  * allocated size is n, array[n] is an error.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  the internal array of ptrs to Numa, or NULL on error</returns>
''' <param name="naa"> \param[in]    naa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaGetPtrArray")> _
Friend Shared Function numaaGetPtrArray(naa as IntPTR) as String
End Function

' SRC\numabasic.c (1657, 1)
' numaaGetNuma()
' numaaGetNuma(NUMAA *, l_int32, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa, or NULL on error</returns>
''' <param name="naa"> \param[in]    naa</param>
''' <param name="index"> \param[in]    index  to the index-th numa</param>
''' <param name="accessflag"> \param[in]    accessflag   L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaGetNuma")> _
Friend Shared Function numaaGetNuma(naa as IntPTR, index as Integer, accessflag as Integer) as IntPTR
End Function

' SRC\numabasic.c (1693, 1)
' numaaReplaceNuma()
' numaaReplaceNuma(NUMAA *, l_int32, NUMA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Any existing numa is destroyed, and the input one
'''  * is inserted in its place.
'''  *   (2) If the index is invalid, return 1 (error)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="naa"> \param[in]    naa</param>
''' <param name="index"> \param[in]    index  to the index-th numa</param>
''' <param name="na"> \param[in]    na insert and replace any existing one</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaReplaceNuma")> _
Friend Shared Function numaaReplaceNuma(naa as IntPTR, index as Integer, na as IntPTR) as Integer
End Function

' SRC\numabasic.c (1726, 1)
' numaaGetValue()
' numaaGetValue(NUMAA *, l_int32, l_int32, l_float32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="naa"> \param[in]    naa</param>
''' <param name="i"> \param[in]    i index of numa within numaa</param>
''' <param name="j"> \param[in]    j index into numa</param>
''' <param name="pfval"> \param[out]   pfval [optional] float value</param>
''' <param name="pival"> \param[out]   pival [optional] int value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaGetValue")> _
Friend Shared Function numaaGetValue(naa as IntPTR, i as Integer, j as Integer, pfval as single, pival as Integer) as Integer
End Function

' SRC\numabasic.c (1769, 1)
' numaaAddNumber()
' numaaAddNumber(NUMAA *, l_int32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Adds to an existing numa only.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="naa"> \param[in]    naa</param>
''' <param name="index"> \param[in]    index of numa within numaa</param>
''' <param name="val"> \param[in]    val  float or int to be added; stored as a float</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaAddNumber")> _
Friend Shared Function numaaAddNumber(naa as IntPTR, index as Integer, val as single) as Integer
End Function

' SRC\numabasic.c (1801, 1)
' numaaRead()
' numaaRead(const char *) as NUMAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  naa, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaRead")> _
Friend Shared Function numaaRead(filename as String) as IntPTR
End Function

' SRC\numabasic.c (1828, 1)
' numaaReadStream()
' numaaReadStream(FILE *) as NUMAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  naa, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaReadStream")> _
Friend Shared Function numaaReadStream(fp as Object) as IntPTR
End Function

' SRC\numabasic.c (1873, 1)
' numaaReadMem()
' numaaReadMem(const l_uint8 *, size_t) as NUMAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  naa, or NULL on error</returns>
''' <param name="data"> \param[in]    data  numaa serialization; in ascii</param>
''' <param name="size"> \param[in]    size  of data; can use strlen to get it</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaReadMem")> _
Friend Shared Function numaaReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\numabasic.c (1900, 1)
' numaaWrite()
' numaaWrite(const char *, NUMAA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename, naa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaWrite")> _
Friend Shared Function numaaWrite(filename as String, naa as IntPTR) as Integer
End Function

' SRC\numabasic.c (1931, 1)
' numaaWriteStream()
' numaaWriteStream(FILE *, NUMAA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="naa"> \param[in]    naa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaWriteStream")> _
Friend Shared Function numaaWriteStream(fp as Object, naa as IntPTR) as Integer
End Function

' SRC\numabasic.c (1973, 1)
' numaaWriteMem()
' numaaWriteMem(l_uint8 **, size_t *, NUMAA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a numaa in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata  data of serialized numaa; ascii</param>
''' <param name="psize"> \param[out]   psize  size of returned data</param>
''' <param name="naa"> \param[in]    naa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaWriteMem")> _
Friend Shared Function numaaWriteMem(pdata as Object, psize as ULong, naa as IntPTR) as Integer
End Function

#End Region
#Region "SRC\numafunc1.c"
' SRC\numafunc1.c (153, 1)
' numaArithOp()
' numaArithOp(NUMA *, NUMA *, NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The sizes of na1 and na2 must be equal.
'''  *   (2) nad can only null or equal to na1.
'''  *   (3) To add a constant to a numa, or to multipy a numa by
'''  * a constant, use numaTransform().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad always: operation applied to na1 and na2</returns>
''' <param name="nad"> \param[in]    nad [optional] can be null or equal to na1 (in-place</param>
''' <param name="na1"> \param[in]    na1</param>
''' <param name="na2"> \param[in]    na2</param>
''' <param name="op"> \param[in]    op L_ARITH_ADD, L_ARITH_SUBTRACT,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaArithOp")> _
Friend Shared Function numaArithOp(nad as IntPTR, na1 as IntPTR, na2 as IntPTR, op as Integer) as IntPTR
End Function

' SRC\numafunc1.c (233, 1)
' numaLogicalOp()
' numaLogicalOp(NUMA *, NUMA *, NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The sizes of na1 and na2 must be equal.
'''  *   (2) nad can only be null or equal to na1.
'''  *   (3) This is intended for use with indicator arrays (0s and 1s).
'''  * Input data is extracted as integers (0 == false, anything
'''  * else == true); output results are 0 and 1.
'''  *   (4) L_SUBTRACTION is subtraction of val2 from val1.  For bit logical
'''  * arithmetic this is (val1 & ~val2), but because these values
'''  * are integers, we use (val1 && !val2).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad always: operation applied to na1 and na2</returns>
''' <param name="nad"> \param[in]    nad [optional] can be null or equal to na1 (in-place</param>
''' <param name="na1"> \param[in]    na1</param>
''' <param name="na2"> \param[in]    na2</param>
''' <param name="op"> \param[in]    op L_UNION, L_INTERSECTION, L_SUBTRACTION, L_EXCLUSIVE_OR</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaLogicalOp")> _
Friend Shared Function numaLogicalOp(nad as IntPTR, na1 as IntPTR, na2 as IntPTR, op as Integer) as IntPTR
End Function

' SRC\numafunc1.c (306, 1)
' numaInvert()
' numaInvert(NUMA *, NUMA *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This is intended for use with indicator arrays (0s and 1s).
'''  * It gives a boolean-type output, taking the input as
'''  * an integer and inverting it:
'''  *  0  -->  1
'''  *  anything else  -->   0
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad always: 'inverts' nas</returns>
''' <param name="nad"> \param[in]    nad [optional] can be null or equal to nas (in-place</param>
''' <param name="nas"> \param[in]    nas</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaInvert")> _
Friend Shared Function numaInvert(nad as IntPTR, nas as IntPTR) as IntPTR
End Function

' SRC\numafunc1.c (351, 1)
' numaSimilar()
' numaSimilar(NUMA *, NUMA *, l_float32, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Float values can differ slightly due to roundoff and
'''  * accumulated errors.  Using %maxdiff > 0.0 allows similar
'''  * arrays to be identified.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na1"> \param[in]    na1</param>
''' <param name="na2"> \param[in]    na2</param>
''' <param name="maxdiff"> \param[in]    maxdiff use 0.0 for exact equality</param>
''' <param name="psimilar"> \param[out]   psimilar 1 if similar; 0 if different</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSimilar")> _
Friend Shared Function numaSimilar(na1 as IntPTR, na2 as IntPTR, maxdiff as single, psimilar as Integer) as Integer
End Function

' SRC\numafunc1.c (400, 1)
' numaAddToNumber()
' numaAddToNumber(NUMA *, l_int32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is useful for accumulating sums, regardless of the index
'''  * order in which the values are made available.
'''  *   (2) Before use, the numa has to be filled up to %index.  This would
'''  * typically be used by creating the numa with the full sized
'''  * array, initialized to 0.0, using numaMakeConstant().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="index"> \param[in]    index element to be changed</param>
''' <param name="val"> \param[in]    val new value to be added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaAddToNumber")> _
Friend Shared Function numaAddToNumber(na as IntPTR, index as Integer, val as single) as Integer
End Function

' SRC\numafunc1.c (431, 1)
' numaGetMin()
' numaGetMin(NUMA *, l_float32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="pminval"> \param[out]   pminval [optional] min value</param>
''' <param name="piminloc"> \param[out]   piminloc [optional] index of min location</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetMin")> _
Friend Shared Function numaGetMin(na as IntPTR, pminval as single, piminloc as Integer) as Integer
End Function

' SRC\numafunc1.c (473, 1)
' numaGetMax()
' numaGetMax(NUMA *, l_float32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="pmaxval"> \param[out]   pmaxval [optional] max value</param>
''' <param name="pimaxloc"> \param[out]   pimaxloc [optional] index of max location</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetMax")> _
Friend Shared Function numaGetMax(na as IntPTR, pmaxval as single, pimaxloc as Integer) as Integer
End Function

' SRC\numafunc1.c (514, 1)
' numaGetSum()
' numaGetSum(NUMA *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="psum"> \param[out]   psum sum of values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetSum")> _
Friend Shared Function numaGetSum(na as IntPTR, psum as single) as Integer
End Function

' SRC\numafunc1.c (553, 1)
' numaGetPartialSums()
' numaGetPartialSums(NUMA *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) nasum[i] is the sum for all j = i of na[j].
'''  * So nasum[0] = na[0].
'''  *   (2) If you want to generate a rank function, where rank[0] - 0.0,
'''  * insert a 0.0 at the beginning of the nasum array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nasum, or NULL on error</returns>
''' <param name="na"> \param[in]    na source numa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetPartialSums")> _
Friend Shared Function numaGetPartialSums(na as IntPTR) as IntPTR
End Function

' SRC\numafunc1.c (586, 1)
' numaGetSumOnInterval()
' numaGetSumOnInterval(NUMA *, l_int32, l_int32, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="first"> \param[in]    first beginning index</param>
''' <param name="last"> \param[in]    last final index</param>
''' <param name="psum"> \param[out]   psum sum of values in the index interval range</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetSumOnInterval")> _
Friend Shared Function numaGetSumOnInterval(na as IntPTR, first as Integer, last as Integer, psum as single) as Integer
End Function

' SRC\numafunc1.c (632, 1)
' numaHasOnlyIntegers()
' numaHasOnlyIntegers(NUMA *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Set %maxsamples == 0 to check every integer in na.  Otherwise,
'''  * this samples no more than %maxsamples.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="maxsamples"> \param[in]    maxsamples maximum number of samples to check</param>
''' <param name="pallints"> \param[out]   pallints 1 if all sampled values are ints; else 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaHasOnlyIntegers")> _
Friend Shared Function numaHasOnlyIntegers(na as IntPTR, maxsamples as Integer, pallints as Integer) as Integer
End Function

' SRC\numafunc1.c (673, 1)
' numaSubsample()
' numaSubsample(NUMA *, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad evenly sampled values from nas, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="subfactor"> \param[in]    subfactor subsample factor, >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSubsample")> _
Friend Shared Function numaSubsample(nas as IntPTR, subfactor as Integer) as IntPTR
End Function

' SRC\numafunc1.c (707, 1)
' numaMakeDelta()
' numaMakeDelta(NUMA *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa of difference values val[i+1] - val[i],</returns>
''' <param name="nas"> \param[in]    nas input numa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaMakeDelta")> _
Friend Shared Function numaMakeDelta(nas as IntPTR) as IntPTR
End Function

' SRC\numafunc1.c (737, 1)
' numaMakeSequence()
' numaMakeSequence(l_float32, l_float32, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa of sequence of evenly spaced values, or NULL on error</returns>
''' <param name="startval"> \param[in]    startval</param>
''' <param name="increment"> \param[in]    increment</param>
''' <param name="size"> \param[in]    size of sequence</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaMakeSequence")> _
Friend Shared Function numaMakeSequence(startval as single, increment as single, size as Integer) as IntPTR
End Function

' SRC\numafunc1.c (768, 1)
' numaMakeConstant()
' numaMakeConstant(l_float32, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa of given size with all entries equal to 'val',</returns>
''' <param name="val"> \param[in]    val</param>
''' <param name="size"> \param[in]    size of numa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaMakeConstant")> _
Friend Shared Function numaMakeConstant(val as single, size as Integer) as IntPTR
End Function

' SRC\numafunc1.c (784, 1)
' numaMakeAbsValue()
' numaMakeAbsValue(NUMA *, NUMA *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad with all numbers being the absval of the input,</returns>
''' <param name="nad"> \param[in]    nad can be null for new array, or the same as nas for inplace</param>
''' <param name="nas"> \param[in]    nas input numa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaMakeAbsValue")> _
Friend Shared Function numaMakeAbsValue(nad as IntPTR, nas as IntPTR) as IntPTR
End Function

' SRC\numafunc1.c (818, 1)
' numaAddBorder()
' numaAddBorder(NUMA *, l_int32, l_int32, l_float32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad with added elements at left and right, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="left"> \param[in]    left, right number of elements to add on each side</param>
''' <param name="right"> \param[in]    val initialize border elements</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaAddBorder")> _
Friend Shared Function numaAddBorder(nas as IntPTR, left as Integer, right as Integer, val as single) as IntPTR
End Function

' SRC\numafunc1.c (860, 1)
' numaAddSpecifiedBorder()
' numaAddSpecifiedBorder(NUMA *, l_int32, l_int32, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad with added elements at left and right, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="left"> \param[in]    left, right number of elements to add on each side</param>
''' <param name="right"> \param[in]    type L_CONTINUED_BORDER, L_MIRRORED_BORDER</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaAddSpecifiedBorder")> _
Friend Shared Function numaAddSpecifiedBorder(nas as IntPTR, left as Integer, right as Integer, type as Integer) as IntPTR
End Function

' SRC\numafunc1.c (910, 1)
' numaRemoveBorder()
' numaRemoveBorder(NUMA *, l_int32, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad with removed elements at left and right, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="left"> \param[in]    left, right number of elements to remove from each side</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaRemoveBorder")> _
Friend Shared Function numaRemoveBorder(nas as IntPTR, left as Integer, right as Integer) as IntPTR
End Function

' SRC\numafunc1.c (951, 1)
' numaCountNonzeroRuns()
' numaCountNonzeroRuns(NUMA *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na      e.g., of pixel counts in rows or columns</param>
''' <param name="pcount"> \param[out]   pcount  number of nonzero runs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaCountNonzeroRuns")> _
Friend Shared Function numaCountNonzeroRuns(na as IntPTR, pcount as Integer) as Integer
End Function

' SRC\numafunc1.c (990, 1)
' numaGetNonzeroRange()
' numaGetNonzeroRange(NUMA *, l_float32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if no nonzero range is found.</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="eps"> \param[in]    eps largest value considered to be zero</param>
''' <param name="pfirst"> \param[out]   pfirst, plast interval of array indices</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetNonzeroRange")> _
Friend Shared Function numaGetNonzeroRange(na as IntPTR, eps as single, pfirst as Integer, plast as Integer) as Integer
End Function

' SRC\numafunc1.c (1041, 1)
' numaGetCountRelativeToZero()
' numaGetCountRelativeToZero(NUMA *, l_int32, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="type"> \param[in]    type L_LESS_THAN_ZERO, L_EQUAL_TO_ZERO, L_GREATER_THAN_ZERO</param>
''' <param name="pcount"> \param[out]   pcount count of values of given type</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetCountRelativeToZero")> _
Friend Shared Function numaGetCountRelativeToZero(na as IntPTR, type as Integer, pcount as Integer) as Integer
End Function

' SRC\numafunc1.c (1089, 1)
' numaClipToInterval()
' numaClipToInterval(NUMA *, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *  If you want the indices of the array values to be unchanged,
'''  *  use first = 0.
'''  *  Usage:
'''  *  This is useful to clip a histogram that has a few nonzero
'''  *  values to its nonzero range.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa with the same values as the input, but clipped</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="first"> \param[in]    first, last clipping interval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaClipToInterval")> _
Friend Shared Function numaClipToInterval(nas as IntPTR, first as Integer, last as Integer) as IntPTR
End Function

' SRC\numafunc1.c (1137, 1)
' numaMakeThresholdIndicator()
' numaMakeThresholdIndicator(NUMA *, l_float32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) For each element in nas, if the constraint given by 'type'
'''  * correctly specifies its relation to thresh, a value of 1
'''  * is recorded in nad.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="nas"> \param[in]    nas input numa</param>
''' <param name="thresh"> \param[in]    thresh threshold value</param>
''' <param name="type"> \param[in]    type L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaMakeThresholdIndicator")> _
Friend Shared Function numaMakeThresholdIndicator(nas as IntPTR, thresh as single, type as Integer) as IntPTR
End Function

' SRC\numafunc1.c (1193, 1)
' numaUniformSampling()
' numaUniformSampling(NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This resamples the values in the array, using %nsamp
'''  * equal divisions.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="nas"> \param[in]    nas input numa</param>
''' <param name="nsamp"> \param[in]    nsamp number of samples</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaUniformSampling")> _
Friend Shared Function numaUniformSampling(nas as IntPTR, nsamp as Integer) as IntPTR
End Function

' SRC\numafunc1.c (1258, 1)
' numaReverse()
' numaReverse(NUMA *, NUMA *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) Usage:
'''  *   numaReverse(nas, nas);   // in-place
'''  *   nad = numaReverse(NULL, nas);  // makes a new one
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="nad"> \param[in]    nad [optional] can be null or equal to nas</param>
''' <param name="nas"> \param[in]    nas input numa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaReverse")> _
Friend Shared Function numaReverse(nad as IntPTR, nas as IntPTR) as IntPTR
End Function

' SRC\numafunc1.c (1313, 1)
' numaLowPassIntervals()
' numaLowPassIntervals(NUMA *, l_float32, l_float32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) For each interval where the value is less than a specified
'''  * fraction of the maximum, this records the left and right "x"
'''  * value.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="nas"> \param[in]    nas input numa</param>
''' <param name="thresh"> \param[in]    thresh threshold fraction of max; in [0.0 ... 1.0]</param>
''' <param name="maxn"> \param[in]    maxn for normalizing; set maxn = 0.0 to use the max in nas</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaLowPassIntervals")> _
Friend Shared Function numaLowPassIntervals(nas as IntPTR, thresh as single, maxn as single) as IntPTR
End Function

' SRC\numafunc1.c (1389, 1)
' numaThresholdEdges()
' numaThresholdEdges(NUMA *, l_float32, l_float32, l_float32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) For each edge interval, where where the value is less
'''  * than %thresh1 on one side, greater than %thresh2 on
'''  * the other, and between these thresholds throughout the
'''  * interval, this records a triplet of values: the
'''  * 'left' and 'right' edges, and either +1 or -1, depending
'''  * on whether the edge is rising or falling.
'''  *   (2) No assumption is made about the value outside the array,
'''  * so if the value at the array edge is between the threshold
'''  * values, it is not considered part of an edge.  We start
'''  * looking for edge intervals only after leaving the thresholded
'''  * band.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="nas"> \param[in]    nas input numa</param>
''' <param name="thresh1"> \param[in]    thresh1 low threshold as fraction of max; in [0.0 ... 1.0]</param>
''' <param name="thresh2"> \param[in]    thresh2 high threshold as fraction of max; in [0.0 ... 1.0]</param>
''' <param name="maxn"> \param[in]    maxn for normalizing; set maxn = 0.0 to use the max in nas</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaThresholdEdges")> _
Friend Shared Function numaThresholdEdges(nas as IntPTR, thresh1 as single, thresh2 as single, maxn as single) as IntPTR
End Function

' SRC\numafunc1.c (1509, 1)
' numaGetSpanValues()
' numaGetSpanValues(NUMA *, l_int32, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="na"> \param[in]    na numa that is output of numaLowPassIntervals()</param>
''' <param name="span"> \param[in]    span span number, zero-based</param>
''' <param name="pstart"> \param[out]   pstart [optional] location of start of transition</param>
''' <param name="pend"> \param[out]   pend [optional] location of end of transition</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetSpanValues")> _
Friend Shared Function numaGetSpanValues(na as IntPTR, span as Integer, pstart as Integer, pend as Integer) as Integer
End Function

' SRC\numafunc1.c (1545, 1)
' numaGetEdgeValues()
' numaGetEdgeValues(NUMA *, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="na"> \param[in]    na numa that is output of numaThresholdEdges()</param>
''' <param name="edge"> \param[in]    edge edge number, zero-based</param>
''' <param name="pstart"> \param[out]   pstart [optional] location of start of transition</param>
''' <param name="pend"> \param[out]   pend [optional] location of end of transition</param>
''' <param name="psign"> \param[out]   psign [optional] transition sign: +1 is rising,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetEdgeValues")> _
Friend Shared Function numaGetEdgeValues(na as IntPTR, edge as Integer, pstart as Integer, pend as Integer, psign as Integer) as Integer
End Function

' SRC\numafunc1.c (1602, 1)
' numaInterpolateEqxVal()
' numaInterpolateEqxVal(l_float32, l_float32, NUMA *, l_int32, l_float32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Considering nay as a function of x, the x values
'''  * are equally spaced
'''  *   (2) Caller should check for valid return.
'''  *
'''  *  For linear Lagrangian interpolation (through 2 data pts):
'''  *   y(x) = y1(x-x2)/(x1-x2) + y2(x-x1)/(x2-x1)
'''  *
'''  *  For quadratic Lagrangian interpolation (through 3 data pts):
'''  *   y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +
'''  * y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +
'''  * y3(x-x1)(x-x2)/((x3-x1)(x3-x2))
'''  *
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error e.g., if xval is outside range</returns>
''' <param name="startx"> \param[in]    startx xval corresponding to first element in array</param>
''' <param name="deltax"> \param[in]    deltax x increment between array elements</param>
''' <param name="nay"> \param[in]    nay  numa of ordinate values, assumed equally spaced</param>
''' <param name="type"> \param[in]    type L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
''' <param name="xval"> \param[in]    xval</param>
''' <param name="pyval"> \param[out]   pyval interpolated value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaInterpolateEqxVal")> _
Friend Shared Function numaInterpolateEqxVal(startx as single, deltax as single, nay as IntPTR, type as Integer, xval as single, pyval as single) as Integer
End Function

' SRC\numafunc1.c (1695, 1)
' numaInterpolateArbxVal()
' numaInterpolateArbxVal(NUMA *, NUMA *, l_int32, l_float32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The values in nax must be sorted in increasing order.
'''  * If, additionally, they are equally spaced, you can use
'''  * numaInterpolateEqxVal().
'''  *   (2) Caller should check for valid return.
'''  *   (3) Uses lagrangian interpolation.  See numaInterpolateEqxVal()
'''  * for formulas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error e.g., if xval is outside range</returns>
''' <param name="nax"> \param[in]    nax numa of abscissa values</param>
''' <param name="nay"> \param[in]    nay numa of ordinate values, corresponding to nax</param>
''' <param name="type"> \param[in]    type L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
''' <param name="xval"> \param[in]    xval</param>
''' <param name="pyval"> \param[out]   pyval interpolated value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaInterpolateArbxVal")> _
Friend Shared Function numaInterpolateArbxVal(nax as IntPTR, nay as IntPTR, type as Integer, xval as single, pyval as single) as Integer
End Function

' SRC\numafunc1.c (1812, 1)
' numaInterpolateEqxInterval()
' numaInterpolateEqxInterval(l_float32, l_float32, NUMA *, l_int32, l_float32, l_float32, l_int32, NUMA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Considering nasy as a function of x, the x values
'''  * are equally spaced.
'''  *   (2) This creates nay (and optionally nax) of interpolated
'''  * values over the specified interval (x0, x1).
'''  *   (3) If the interval (x0, x1) lies partially outside the array
'''  * nasy (as interpreted by startx and deltax), it is an
'''  * error and returns 1.
'''  *   (4) Note that deltax is the intrinsic x-increment for the input
'''  * array nasy, whereas delx is the intrinsic x-increment for the
'''  * output interpolated array nay.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="startx"> \param[in]    startx xval corresponding to first element in nas</param>
''' <param name="deltax"> \param[in]    deltax x increment between array elements in nas</param>
''' <param name="nasy"> \param[in]    nasy  numa of ordinate values, assumed equally spaced</param>
''' <param name="type"> \param[in]    type L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
''' <param name="x0"> \param[in]    x0 start value of interval</param>
''' <param name="x1"> \param[in]    x1 end value of interval</param>
''' <param name="npts"> \param[in]    npts number of points to evaluate function in interval</param>
''' <param name="pnax"> \param[out]   pnax [optional] array of x values in interval</param>
''' <param name="pnay"> \param[out]   pnay array of y values in interval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaInterpolateEqxInterval")> _
Friend Shared Function numaInterpolateEqxInterval(startx as single, deltax as single, nasy as IntPTR, type as Integer, x0 as single, x1 as single, npts as Integer, pnax as Object, pnay as Object) as Integer
End Function

' SRC\numafunc1.c (1900, 1)
' numaInterpolateArbxInterval()
' numaInterpolateArbxInterval(NUMA *, NUMA *, l_int32, l_float32, l_float32, l_int32, NUMA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The values in nax must be sorted in increasing order.
'''  * If they are not sorted, we do it here, and complain.
'''  *   (2) If the values in nax are equally spaced, you can use
'''  * numaInterpolateEqxInterval().
'''  *   (3) Caller should check for valid return.
'''  *   (4) We don't call numaInterpolateArbxVal() for each output
'''  * point, because that requires an O(n) search for
'''  * each point.  Instead, we do a single O(n) pass through
'''  * nax, saving the indices to be used for each output yval.
'''  *   (5) Uses lagrangian interpolation.  See numaInterpolateEqxVal()
'''  * for formulas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error e.g., if x0 or x1 is outside range</returns>
''' <param name="nax"> \param[in]    nax numa of abscissa values</param>
''' <param name="nay"> \param[in]    nay numa of ordinate values, corresponding to nax</param>
''' <param name="type"> \param[in]    type L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
''' <param name="x0"> \param[in]    x0 start value of interval</param>
''' <param name="x1"> \param[in]    x1 end value of interval</param>
''' <param name="npts"> \param[in]    npts number of points to evaluate function in interval</param>
''' <param name="pnadx"> \param[out]   pnadx [optional] array of x values in interval</param>
''' <param name="pnady"> \param[out]   pnady array of y values in interval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaInterpolateArbxInterval")> _
Friend Shared Function numaInterpolateArbxInterval(nax as IntPTR, nay as IntPTR, type as Integer, x0 as single, x1 as single, npts as Integer, pnadx as Object, pnady as Object) as Integer
End Function

' SRC\numafunc1.c (2061, 1)
' numaFitMax()
' numaFitMax(NUMA *, l_float32 *, NUMA *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *  If %naloc is given, there is no requirement that the
'''  *  data points are evenly spaced.  Lagrangian interpolation
'''  *  handles that.  The only requirement is that the
'''  *  data points are ordered so that the values in naloc
'''  *  are either increasing or decreasing.  We test to make
'''  *  sure that the sizes of na and naloc are equal, and it
'''  *  is assumed that the correspondences %na[i] as a function
'''  *  of %naloc[i] are properly arranged for all i.
'''  *
'''  *  The formula for Lagrangian interpolation through 3 data pts is:
'''  * y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +
'''  *  y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +
'''  *  y3(x-x1)(x-x2)/((x3-x1)(x3-x2))
'''  *
'''  *  Then the derivative, using the constants (c1,c2,c3) defined below,
'''  *  is set to 0:
'''  * y'(x) = 2x(c1+c2+c3) - c1(x2+x3) - c2(x1+x3) - c3(x1+x2) = 0
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="na"> \param[in]    na       numa of ordinate values, to fit a max to</param>
''' <param name="pmaxval"> \param[out]   pmaxval  max value</param>
''' <param name="naloc"> \param[in]    naloc    [optional] associated numa of abscissa values</param>
''' <param name="pmaxloc"> \param[out]   pmaxloc  abscissa value that gives max value in na;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaFitMax")> _
Friend Shared Function numaFitMax(na as IntPTR, pmaxval as single, naloc as IntPTR, pmaxloc as single) as Integer
End Function

' SRC\numafunc1.c (2166, 1)
' numaDifferentiateInterval()
' numaDifferentiateInterval(NUMA *, NUMA *, l_float32, l_float32, l_int32, NUMA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The values in nax must be sorted in increasing order.
'''  * If they are not sorted, it is done in the interpolation
'''  * step, and a warning is issued.
'''  *   (2) Caller should check for valid return.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error e.g., if x0 or x1 is outside range</returns>
''' <param name="nax"> \param[in]    nax numa of abscissa values</param>
''' <param name="nay"> \param[in]    nay numa of ordinate values, corresponding to nax</param>
''' <param name="x0"> \param[in]    x0 start value of interval</param>
''' <param name="x1"> \param[in]    x1 end value of interval</param>
''' <param name="npts"> \param[in]    npts number of points to evaluate function in interval</param>
''' <param name="pnadx"> \param[out]   pnadx [optional] array of x values in interval</param>
''' <param name="pnady"> \param[out]   pnady array of derivatives in interval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaDifferentiateInterval")> _
Friend Shared Function numaDifferentiateInterval(nax as IntPTR, nay as IntPTR, x0 as single, x1 as single, npts as Integer, pnadx as Object, pnady as Object) as Integer
End Function

' SRC\numafunc1.c (2249, 1)
' numaIntegrateInterval()
' numaIntegrateInterval(NUMA *, NUMA *, l_float32, l_float32, l_int32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The values in nax must be sorted in increasing order.
'''  * If they are not sorted, it is done in the interpolation
'''  * step, and a warning is issued.
'''  *   (2) Caller should check for valid return.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error e.g., if x0 or x1 is outside range</returns>
''' <param name="nax"> \param[in]    nax numa of abscissa values</param>
''' <param name="nay"> \param[in]    nay numa of ordinate values, corresponding to nax</param>
''' <param name="x0"> \param[in]    x0 start value of interval</param>
''' <param name="x1"> \param[in]    x1 end value of interval</param>
''' <param name="npts"> \param[in]    npts number of points to evaluate function in interval</param>
''' <param name="psum"> \param[out]   psum integral of function over interval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaIntegrateInterval")> _
Friend Shared Function numaIntegrateInterval(nax as IntPTR, nay as IntPTR, x0 as single, x1 as single, npts as Integer, psum as single) as Integer
End Function

' SRC\numafunc1.c (2354, 1)
' numaSortGeneral()
' numaSortGeneral(NUMA *, NUMA **, NUMA **, NUMA **, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Sorting can be confusing.  Here's an array of five values with
'''  * the results shown for the 3 output arrays.
'''  *
'''  * na   nasort   naindex   nainvert
'''  * -----------------------------------
'''  * 3   9   2   3
'''  * 4   6   3   2
'''  * 9   4   1   0
'''  * 6   3   0   1
'''  * 1   1   4   4
'''  *
'''  * Note that naindex is a LUT into na for the sorted array values,
'''  * and nainvert directly gives the sorted index values for the
'''  * input array.  It is useful to view naindex is as a map:
'''  *  0  -->  2
'''  *  1  -->  3
'''  *  2  -->  1
'''  *  3  -->  0
'''  *  4  -->  4
'''  * and nainvert, the inverse of this map:
'''  *  0  -->  3
'''  *  1  -->  2
'''  *  2  -->  0
'''  *  3  -->  1
'''  *  4  -->  4
'''  *
'''  * We can write these relations symbolically as:
'''  *  nasort[i] = na[naindex[i]]
'''  *  na[i] = nasort[nainvert[i]]
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na        source numa</param>
''' <param name="pnasort"> \param[out]   pnasort   [optional] sorted numa</param>
''' <param name="pnaindex"> \param[out]   pnaindex  [optional] index of elements in na associated</param>
''' <param name="pnainvert"> \param[out]   pnainvert [optional] index of elements in nasort associated</param>
''' <param name="sortorder"> \param[in]    sortorder L_SORT_INCREASING or L_SORT_DECREASING</param>
''' <param name="sorttype"> \param[in]    sorttype  L_SHELL_SORT or L_BIN_SORT</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSortGeneral")> _
Friend Shared Function numaSortGeneral(na as IntPTR, pnasort as Object, pnaindex as Object, pnainvert as Object, sortorder as Integer, sorttype as Integer) as Integer
End Function

' SRC\numafunc1.c (2408, 1)
' numaSortAutoSelect()
' numaSortAutoSelect(NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This does either a shell sort or a bin sort, depending on
'''  * the number of elements in nas and the dynamic range.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  naout output sorted numa, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas input numa</param>
''' <param name="sortorder"> \param[in]    sortorder L_SORT_INCREASING or L_SORT_DECREASING</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSortAutoSelect")> _
Friend Shared Function numaSortAutoSelect(nas as IntPTR, sortorder as Integer) as IntPTR
End Function

' SRC\numafunc1.c (2444, 1)
' numaSortIndexAutoSelect()
' numaSortIndexAutoSelect(NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This does either a shell sort or a bin sort, depending on
'''  * the number of elements in nas and the dynamic range.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad indices of nas, sorted by value in nas, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="sortorder"> \param[in]    sortorder L_SORT_INCREASING or L_SORT_DECREASING</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSortIndexAutoSelect")> _
Friend Shared Function numaSortIndexAutoSelect(nas as IntPTR, sortorder as Integer) as IntPTR
End Function

' SRC\numafunc1.c (2480, 1)
' numaChooseSortType()
' numaChooseSortType(NUMA *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This selects either a shell sort or a bin sort, depending on
'''  * the number of elements in nas and the dynamic range.
'''  *   (2) If there are negative values in nas, it selects shell sort.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sorttype L_SHELL_SORT or L_BIN_SORT, or UNDEF on error.</returns>
''' <param name="nas"> \param[in]    nas to be sorted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaChooseSortType")> _
Friend Shared Function numaChooseSortType(nas as IntPTR) as Integer
End Function

' SRC\numafunc1.c (2531, 1)
' numaSort()
' numaSort(NUMA *, NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) Set naout = nain for in-place; otherwise, set naout = NULL.
'''  *   (2) Source: Shell sort, modified from K&R, 2nd edition, p.62.
'''  * Slow but simple O(n logn) sort.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  naout output sorted numa, or NULL on error</returns>
''' <param name="naout"> \param[in]    naout output numa; can be NULL or equal to nain</param>
''' <param name="nain"> \param[in]    nain input numa</param>
''' <param name="sortorder"> \param[in]    sortorder L_SORT_INCREASING or L_SORT_DECREASING</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSort")> _
Friend Shared Function numaSort(naout as IntPTR, nain as IntPTR, sortorder as Integer) as IntPTR
End Function

' SRC\numafunc1.c (2593, 1)
' numaBinSort()
' numaBinSort(NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) Because this uses a bin sort with buckets of size 1, it
'''  * is not appropriate for sorting either small arrays or
'''  * arrays containing very large integer values.  For such
'''  * arrays, use a standard general sort function like
'''  * numaSort().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na sorted, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas of non-negative integers with a max that is</param>
''' <param name="sortorder"> \param[in]    sortorder L_SORT_INCREASING or L_SORT_DECREASING</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaBinSort")> _
Friend Shared Function numaBinSort(nas as IntPTR, sortorder as Integer) as IntPTR
End Function

' SRC\numafunc1.c (2621, 1)
' numaGetSortIndex()
' numaGetSortIndex(NUMA *, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na giving an array of indices that would sort</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="sortorder"> \param[in]    sortorder L_SORT_INCREASING or L_SORT_DECREASING</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetSortIndex")> _
Friend Shared Function numaGetSortIndex(na as IntPTR, sortorder as Integer) as IntPTR
End Function

' SRC\numafunc1.c (2697, 1)
' numaGetBinSortIndex()
' numaGetBinSortIndex(NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This creates an array (or lookup table) that contains
'''  * the sorted position of the elements in the input Numa.
'''  *   (2) Because it uses a bin sort with buckets of size 1, it
'''  * is not appropriate for sorting either small arrays or
'''  * arrays containing very large integer values.  For such
'''  * arrays, use a standard general sort function like
'''  * numaGetSortIndex().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na sorted, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas of non-negative integers with a max that is typically</param>
''' <param name="sortorder"> \param[in]    sortorder L_SORT_INCREASING or L_SORT_DECREASING</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetBinSortIndex")> _
Friend Shared Function numaGetBinSortIndex(nas as IntPTR, sortorder as Integer) as IntPTR
End Function

' SRC\numafunc1.c (2770, 1)
' numaSortByIndex()
' numaSortByIndex(NUMA *, NUMA *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad sorted, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="naindex"> \param[in]    naindex na that maps from the new numa to the input numa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSortByIndex")> _
Friend Shared Function numaSortByIndex(nas as IntPTR, naindex as IntPTR) as IntPTR
End Function

' SRC\numafunc1.c (2812, 1)
' numaIsSorted()
' numaIsSorted(NUMA *, l_int32, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This is a quick O(n) test if nas is sorted.  It is useful
'''  * in situations where the array is likely to be already
'''  * sorted, and a sort operation can be avoided.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if OK; 0 on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="sortorder"> \param[in]    sortorder L_SORT_INCREASING or L_SORT_DECREASING</param>
''' <param name="psorted"> \param[out]   psorted 1 if sorted; 0 if not</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaIsSorted")> _
Friend Shared Function numaIsSorted(nas as IntPTR, sortorder as Integer, psorted as Integer) as Integer
End Function

' SRC\numafunc1.c (2859, 1)
' numaSortPair()
' numaSortPair(NUMA *, NUMA *, l_int32, NUMA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function sorts the two input arrays, nax and nay,
'''  * together, using nax as the key for sorting.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nax"> \param[in]    nax, nay input arrays</param>
''' <param name="nay"> \param[in]    sortorder L_SORT_INCREASING or L_SORT_DECREASING</param>
''' <param name="sortorder"> \param[out]   pnasx sorted</param>
''' <param name="pnasx"> \param[out]   pnasy sorted exactly in order of nasx</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSortPair")> _
Friend Shared Function numaSortPair(nax as IntPTR, nay as IntPTR, sortorder as Integer, pnasx as Object, pnasy as Object) as Integer
End Function

' SRC\numafunc1.c (2910, 1)
' numaInvertMap()
' numaInvertMap(NUMA *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This requires that nas contain each integer from 0 to n-1.
'''  * The array is typically an index array into a sort or permutation
'''  * of another array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad the inverted map, or NULL on error or if not invertible</returns>
''' <param name="nas"> \param[in]    nas</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaInvertMap")> _
Friend Shared Function numaInvertMap(nas as IntPTR) as IntPTR
End Function

' SRC\numafunc1.c (2969, 1)
' numaPseudorandomSequence()
' numaPseudorandomSequence(l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This uses the Durstenfeld shuffle.
'''  * See: http://en.wikipedia.org/wiki/FisherYates_shuffle.
'''  * Result is a pseudorandom permutation of the sequence of integers
'''  * from 0 to size - 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na pseudorandom on {0,...,size - 1}, or NULL on error</returns>
''' <param name="size"> \param[in]    size of sequence</param>
''' <param name="seed"> \param[in]    seed for random number generation</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaPseudorandomSequence")> _
Friend Shared Function numaPseudorandomSequence(size as Integer, seed as Integer) as IntPTR
End Function

' SRC\numafunc1.c (3008, 1)
' numaRandomPermutation()
' numaRandomPermutation(NUMA *, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nas randomly shuffled array, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas input array</param>
''' <param name="seed"> \param[in]    seed for random number generation</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaRandomPermutation")> _
Friend Shared Function numaRandomPermutation(nas as IntPTR, seed as Integer) as IntPTR
End Function

' SRC\numafunc1.c (3065, 1)
' numaGetRankValue()
' numaGetRankValue(NUMA *, l_float32, NUMA *, l_int32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Computes the rank value of a number in the %na, which is
'''  * the number that is a fraction %fract from the small
'''  * end of the sorted version of %na.
'''  *   (2) If you do this multiple times for different rank values,
'''  * sort the array in advance and use that for %nasort;
'''  * if you're only calling this once, input %nasort == NULL.
'''  *   (3) If %usebins == 1, this uses a bin sorting method.
'''  * Use this only where:
'''  *  * the numbers are non-negative integers
'''  *  * there are over 100 numbers
'''  *  * the maximum value is less than about 50,000
'''  *   (4) The advantage of using a bin sort is that it is O(n),
'''  * instead of O(nlogn) for general sort routines.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="fract"> \param[in]    fract use 0.0 for smallest, 1.0 for largest</param>
''' <param name="nasort"> \param[in]    nasort [optional] increasing sorted version of na</param>
''' <param name="usebins"> \param[in]    usebins 0 for general sort; 1 for bin sort</param>
''' <param name="pval"> \param[out]   pval  rank val</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetRankValue")> _
Friend Shared Function numaGetRankValue(na as IntPTR, fract as single, nasort as IntPTR, usebins as Integer, pval as single) as Integer
End Function

' SRC\numafunc1.c (3119, 1)
' numaGetMedian()
' numaGetMedian(NUMA *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Computes the median value of the numbers in the numa, by
'''  * sorting and finding the middle value in the sorted array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="pval"> \param[out]   pval  median value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetMedian")> _
Friend Shared Function numaGetMedian(na as IntPTR, pval as single) as Integer
End Function

' SRC\numafunc1.c (3150, 1)
' numaGetBinnedMedian()
' numaGetBinnedMedian(NUMA *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Computes the median value of the numbers in the numa,
'''  * using bin sort and finding the middle value in the sorted array.
'''  *   (2) See numaGetRankValue() for conditions on na for which
'''  * this should be used.  Otherwise, use numaGetMedian().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="pval"> \param[out]   pval  integer median value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetBinnedMedian")> _
Friend Shared Function numaGetBinnedMedian(na as IntPTR, pval as Integer) as Integer
End Function

' SRC\numafunc1.c (3187, 1)
' numaGetMode()
' numaGetMode(NUMA *, l_float32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Computes the mode value of the numbers in the numa, by
'''  * sorting and finding the value of the number with the
'''  * largest count.
'''  *   (2) Optionally, also returns that count.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="pval"> \param[out]   pval  mode val</param>
''' <param name="pcount"> \param[out]   pcount  [optional] mode count</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetMode")> _
Friend Shared Function numaGetMode(na as IntPTR, pval as single, pcount as Integer) as Integer
End Function

' SRC\numafunc1.c (3266, 1)
' numaGetMedianVariation()
' numaGetMedianVariation(NUMA *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Finds the median of the absolute value of the variation from
'''  * the median value in the array.  Why take the absolute value?
'''  * Consider the case where you have values equally distributed
'''  * about both sides of a median value.  Without taking the absolute
'''  * value of the differences, you will get 0 for the variation,
'''  * and this is not useful.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="na"> \param[in]    na source numa</param>
''' <param name="pmedval"> \param[out]   pmedval  [optional] median value</param>
''' <param name="pmedvar"> \param[out]   pmedvar  median variation from median val</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetMedianVariation")> _
Friend Shared Function numaGetMedianVariation(na as IntPTR, pmedval as single, pmedvar as single) as Integer
End Function

' SRC\numafunc1.c (3319, 1)
' numaJoin()
' numaJoin(NUMA *, NUMA *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) istart  0 is taken to mean 'read from the start' (istart = 0)
'''  *   (2) iend  0 means 'read to the end'
'''  *   (3) if nas == NULL, this is a no-op
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nad"> \param[in]    nad  dest numa; add to this one</param>
''' <param name="nas"> \param[in]    nas  [optional] source numa; add from this one</param>
''' <param name="istart"> \param[in]    istart  starting index in nas</param>
''' <param name="iend"> \param[in]    iend  ending index in nas; use -1 to cat all</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaJoin")> _
Friend Shared Function numaJoin(nad as IntPTR, nas as IntPTR, istart as Integer, iend as Integer) as Integer
End Function

' SRC\numafunc1.c (3368, 1)
' numaaJoin()
' numaaJoin(NUMAA *, NUMAA *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) istart  0 is taken to mean 'read from the start' (istart = 0)
'''  *   (2) iend  0 means 'read to the end'
'''  *   (3) if naas == NULL, this is a no-op
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="naad"> \param[in]    naad  dest naa; add to this one</param>
''' <param name="naas"> \param[in]    naas  [optional] source naa; add from this one</param>
''' <param name="istart"> \param[in]    istart  starting index in nas</param>
''' <param name="iend"> \param[in]    iend  ending index in naas; use -1 to cat all</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaJoin")> _
Friend Shared Function numaaJoin(naad as IntPTR, naas as IntPTR, istart as Integer, iend as Integer) as Integer
End Function

' SRC\numafunc1.c (3416, 1)
' numaaFlattenToNuma()
' numaaFlattenToNuma(NUMAA *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This 'flattens' the Numaa to a Numa, by joining successively
'''  * each Numa in the Numaa.
'''  *   (2) It doesn't make any assumptions about the location of the
'''  * Numas in the Numaa array, unlike most Numaa functions.
'''  *   (3) It leaves the input Numaa unchanged.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa, or NULL on error</returns>
''' <param name="naa"> \param[in]    naa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaaFlattenToNuma")> _
Friend Shared Function numaaFlattenToNuma(naa as IntPTR) as IntPTR
End Function

#End Region
#Region "SRC\numafunc2.c"
' SRC\numafunc2.c (165, 1)
' numaErode()
' numaErode(NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The structuring element (sel) is linear, all "hits"
'''  *   (2) If size == 1, this returns a copy
'''  *   (3) General comment.  The morphological operations are equivalent
'''  * to those that would be performed on a 1-dimensional fpix.
'''  * However, because we have not implemented morphological
'''  * operations on fpix, we do this here.  Because it is only
'''  * 1 dimensional, there is no reason to use the more
'''  * complicated van Herk/Gil-Werman algorithm, and we do it
'''  * by brute force.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad eroded, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="size"> \param[in]    size of sel; greater than 0, odd; origin implicitly in center</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaErode")> _
Friend Shared Function numaErode(nas as IntPTR, size as Integer) as IntPTR
End Function

' SRC\numafunc2.c (233, 1)
' numaDilate()
' numaDilate(NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The structuring element (sel) is linear, all "hits"
'''  *   (2) If size == 1, this returns a copy
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad dilated, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="size"> \param[in]    size of sel; greater than 0, odd; origin implicitly in center</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaDilate")> _
Friend Shared Function numaDilate(nas as IntPTR, size as Integer) as IntPTR
End Function

' SRC\numafunc2.c (301, 1)
' numaOpen()
' numaOpen(NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The structuring element (sel) is linear, all "hits"
'''  *   (2) If size == 1, this returns a copy
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad opened, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="size"> \param[in]    size of sel; greater than 0, odd; origin implicitly in center</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaOpen")> _
Friend Shared Function numaOpen(nas as IntPTR, size as Integer) as IntPTR
End Function

' SRC\numafunc2.c (347, 1)
' numaClose()
' numaClose(NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The structuring element (sel) is linear, all "hits"
'''  *   (2) If size == 1, this returns a copy
'''  *   (3) We add a border before doing this operation, for the same
'''  * reason that we add a border to a pix before doing a safe closing.
'''  * Without the border, a small component near the border gets
'''  * clipped at the border on dilation, and can be entirely removed
'''  * by the following erosion, violating the basic extensivity
'''  * property of closing.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad opened, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="size"> \param[in]    size of sel; greater than 0, odd; origin implicitly in center</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaClose")> _
Friend Shared Function numaClose(nas as IntPTR, size as Integer) as IntPTR
End Function

' SRC\numafunc2.c (394, 1)
' numaTransform()
' numaTransform(NUMA *, l_float32, l_float32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) Each number is shifted before scaling.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad with all values shifted and scaled, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="shift"> \param[in]    shift add this to each number</param>
''' <param name="scale"> \param[in]    scale multiply each number by this</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaTransform")> _
Friend Shared Function numaTransform(nas as IntPTR, shift as single, scale as single) as IntPTR
End Function

' SRC\numafunc2.c (431, 1)
' numaSimpleStats()
' numaSimpleStats(NUMA *, l_int32, l_int32, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na input numa</param>
''' <param name="first"> \param[in]    first first element to use</param>
''' <param name="last"> \param[in]    last last element to use; 0 to go to the end</param>
''' <param name="pmean"> \param[out]   pmean [optional] mean value</param>
''' <param name="pvar"> \param[out]   pvar [optional] variance</param>
''' <param name="prvar"> \param[out]   prvar [optional] rms deviation from the mean</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSimpleStats")> _
Friend Shared Function numaSimpleStats(na as IntPTR, first as Integer, last as Integer, pmean as single, pvar as single, prvar as single) as Integer
End Function

' SRC\numafunc2.c (511, 1)
' numaWindowedStats()
' numaWindowedStats(NUMA *, l_int32, NUMA **, NUMA **, NUMA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a high-level convenience function for calculating
'''  * any or all of these derived arrays.
'''  *   (2) These statistical measures over the values in the
'''  * rectangular window are:
'''  *   ~ average value: [x]  (nam)
'''  *   ~ average squared value: [x*x] (nams)
'''  *   ~ variance: [(x - [x])*(x - [x])] = [x*x] - [x]*[x]  (nav)
'''  *   ~ square-root of variance: (narv)
'''  * where the brackets [ .. ] indicate that the average value is
'''  * to be taken over the window.
'''  *   (3) Note that the variance is just the mean square difference from
'''  * the mean value; and the square root of the variance is the
'''  * root mean square difference from the mean, sometimes also
'''  * called the 'standard deviation'.
'''  *   (4) Internally, use mirrored borders to handle values near the
'''  * end of each array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nas"> \param[in]    nas input numa</param>
''' <param name="wc"> \param[in]    wc half width of the window</param>
''' <param name="pnam"> \param[out]   pnam [optional] mean value in window</param>
''' <param name="pnams"> \param[out]   pnams [optional] mean square value in window</param>
''' <param name="pnav"> \param[out]   pnav [optional] variance in window</param>
''' <param name="pnarv"> \param[out]   pnarv [optional] rms deviation from the mean</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaWindowedStats")> _
Friend Shared Function numaWindowedStats(nas as IntPTR, wc as Integer, pnam as Object, pnams as Object, pnav as Object, pnarv as Object) as Integer
End Function

' SRC\numafunc2.c (562, 1)
' numaWindowedMean()
' numaWindowedMean(NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This is a convolution.  The window has width = 2 * %wc + 1.
'''  *   (2) We add a mirrored border of size %wc to each end of the array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad after low-pass filtering, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="wc"> \param[in]    wc half width of the convolution window</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaWindowedMean")> _
Friend Shared Function numaWindowedMean(nas as IntPTR, wc as Integer) as IntPTR
End Function

' SRC\numafunc2.c (622, 1)
' numaWindowedMeanSquare()
' numaWindowedMeanSquare(NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The window has width = 2 * %wc + 1.
'''  *   (2) We add a mirrored border of size %wc to each end of the array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad containing windowed mean square values, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="wc"> \param[in]    wc half width of the window</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaWindowedMeanSquare")> _
Friend Shared Function numaWindowedMeanSquare(nas as IntPTR, wc as Integer) as IntPTR
End Function

' SRC\numafunc2.c (690, 1)
' numaWindowedVariance()
' numaWindowedVariance(NUMA *, NUMA *, NUMA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The numas of windowed mean and mean square are precomputed,
'''  * using numaWindowedMean() and numaWindowedMeanSquare().
'''  *   (2) Either or both of the variance and square-root of variance
'''  * are returned, where the variance is the average over the
'''  * window of the mean square difference of the pixel value
'''  * from the mean:
'''  * [(x - [x])*(x - [x])] = [x*x] - [x]*[x]
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nam"> \param[in]    nam windowed mean values</param>
''' <param name="nams"> \param[in]    nams windowed mean square values</param>
''' <param name="pnav"> \param[out]   pnav [optional] numa of variance -- the ms deviation</param>
''' <param name="pnarv"> \param[out]   pnarv [optional] numa of rms deviation from the mean</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaWindowedVariance")> _
Friend Shared Function numaWindowedVariance(nam as IntPTR, nams as IntPTR, pnav as Object, pnarv as Object) as Integer
End Function

' SRC\numafunc2.c (758, 1)
' numaWindowedMedian()
' numaWindowedMedian(NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The requested window has width = 2 * %halfwin + 1.
'''  *   (2) If the input nas has less then 3 elements, return a copy.
'''  *   (3) If the filter is too small (%halfwin = 0), return a copy.
'''  *   (4) If the filter is too large, it is reduced in size.
'''  *   (5) We add a mirrored border of size %halfwin to each end of
'''  * the array to simplify the calculation by avoiding end-effects.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad after windowed median filtering, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas</param>
''' <param name="halfwin"> \param[in]    halfwin half width of window over which the median is found</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaWindowedMedian")> _
Friend Shared Function numaWindowedMedian(nas as IntPTR, halfwin as Integer) as IntPTR
End Function

' SRC\numafunc2.c (807, 1)
' numaConvertToInt()
' numaConvertToInt(NUMA *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na with all values rounded to nearest integer, or</returns>
''' <param name="nas"> \param[in]    nas source numa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaConvertToInt")> _
Friend Shared Function numaConvertToInt(nas as IntPTR) as IntPTR
End Function

' SRC\numafunc2.c (859, 1)
' numaMakeHistogram()
' numaMakeHistogram(NUMA *, l_int32, l_int32 *, l_int32 *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This simple interface is designed for integer data.
'''  * The bins are of integer width and start on integer boundaries,
'''  * so the results on float data will not have high precision.
'''  *   (2) Specify the max number of input bins.   Then %binsize,
'''  * the size of bins necessary to accommodate the input data,
'''  * is returned.  It is one of the sequence:
'''  * {1, 2, 5, 10, 20, 50, ...}.
'''  *   (3) If &binstart is given, all values are accommodated,
'''  * and the min value of the starting bin is returned.
'''  * Otherwise, all negative values are discarded and
'''  * the histogram bins start at 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na consisiting of histogram of integerized values,</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="maxbins"> \param[in]    maxbins max number of histogram bins</param>
''' <param name="pbinsize"> \param[out]   pbinsize  size of histogram bins</param>
''' <param name="pbinstart"> \param[out]   pbinstart [optional] start val of minimum bin;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaMakeHistogram")> _
Friend Shared Function numaMakeHistogram(na as IntPTR, maxbins as Integer, pbinsize as Integer, pbinstart as Integer) as IntPTR
End Function

' SRC\numafunc2.c (971, 1)
' numaMakeHistogramAuto()
' numaMakeHistogramAuto(NUMA *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This simple interface is designed for accurate binning
'''  * of both integer and float data.
'''  *   (2) If the array data is integers, and the range of integers
'''  * is smaller than %maxbins, they are binned as they fall,
'''  * with binsize = 1.
'''  *   (3) If the range of data, (maxval - minval), is larger than
'''  * %maxbins, or if the data is floats, they are binned into
'''  * exactly %maxbins bins.
'''  *   (4) Unlike numaMakeHistogram(), these bins in general have
'''  * non-integer location and width, even for integer data.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na consisiting of histogram of quantized float values,</returns>
''' <param name="na"> \param[in]    na numa of floats; these may be integers</param>
''' <param name="maxbins"> \param[in]    maxbins max number of histogram bins; >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaMakeHistogramAuto")> _
Friend Shared Function numaMakeHistogramAuto(na as IntPTR, maxbins as Integer) as IntPTR
End Function

' SRC\numafunc2.c (1055, 1)
' numaMakeHistogramClipped()
' numaMakeHistogramClipped(NUMA *, l_float32, l_float32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This simple function generates a histogram of values
'''  * from na, discarding all values  0.0 or greater than
'''  * min(%maxsize, maxval), where maxval is the maximum value in na.
'''  * The histogram data is put in bins of size delx = %binsize,
'''  * starting at x = 0.0.  We use as many bins as are
'''  * needed to hold the data.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na histogram of bins of size %binsize, starting with</returns>
''' <param name="na"> \param[in]    na</param>
''' <param name="binsize"> \param[in]    binsize typically 1.0</param>
''' <param name="maxsize"> \param[in]    maxsize of histogram ordinate</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaMakeHistogramClipped")> _
Friend Shared Function numaMakeHistogramClipped(na as IntPTR, binsize as single, maxsize as single) as IntPTR
End Function

' SRC\numafunc2.c (1104, 1)
' numaRebinHistogram()
' numaRebinHistogram(NUMA *, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad more coarsely re-binned histogram, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas input histogram</param>
''' <param name="newsize"> \param[in]    newsize number of old bins contained in each new bin</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaRebinHistogram")> _
Friend Shared Function numaRebinHistogram(nas as IntPTR, newsize as Integer) as IntPTR
End Function

' SRC\numafunc2.c (1153, 1)
' numaNormalizeHistogram()
' numaNormalizeHistogram(NUMA *, l_float32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad normalized histogram, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas input histogram</param>
''' <param name="tsum"> \param[in]    tsum target sum of all numbers in dest histogram;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaNormalizeHistogram")> _
Friend Shared Function numaNormalizeHistogram(nas as IntPTR, tsum as single) as IntPTR
End Function

' SRC\numafunc2.c (1235, 1)
' numaGetStatsUsingHistogram()
' numaGetStatsUsingHistogram(NUMA *, l_int32, l_float32 *, l_float32 *, l_float32 *, l_float32 *, l_float32 *, l_float32, l_float32 *, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a simple interface for gathering statistics
'''  * from a numa, where a histogram is used 'under the covers'
'''  * to avoid sorting if a rank value is requested.  In that case,
'''  * by using a histogram we are trading speed for accuracy, because
'''  * the values in %na are quantized to the center of a set of bins.
'''  *   (2) If the median, other rank value, or histogram are not requested,
'''  * the calculation is all performed on the input Numa.
'''  *   (3) The variance is the average of the square of the
'''  * difference from the mean.  The median is the value in na
'''  * with rank 0.5.
'''  *   (4) There are two situations where this gives rank results with
'''  * accuracy comparable to computing stastics directly on the input
'''  * data, without binning into a histogram:
'''  *  (a) the data is integers and the range of data is less than
'''  *   %maxbins, and
'''  *  (b) the data is floats and the range is small compared to
'''  *   %maxbins, so that the binsize is much less than 1.
'''  *   (5) If a histogram is used and the numbers in the Numa extend
'''  * over a large range, you can limit the required storage by
'''  * specifying the maximum number of bins in the histogram.
'''  * Use %maxbins == 0 to force the bin size to be 1.
'''  *   (6) This optionally returns the median and one arbitrary rank value.
'''  * If you need several rank values, return the histogram and use
'''  *   numaHistogramGetValFromRank(nah, rank, &rval)
'''  * multiple times.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na an arbitrary set of numbers; not ordered and not</param>
''' <param name="maxbins"> \param[in]    maxbins the maximum number of bins to be allowed in</param>
''' <param name="pmin"> \param[out]   pmin [optional] min value of set</param>
''' <param name="pmax"> \param[out]   pmax [optional] max value of set</param>
''' <param name="pmean"> \param[out]   pmean [optional] mean value of set</param>
''' <param name="pvariance"> \param[out]   pvariance [optional] variance</param>
''' <param name="pmedian"> \param[out]   pmedian [optional] median value of set</param>
''' <param name="rank"> \param[in]    rank in [0.0 ... 1.0]; median has a rank 0.5; ignored</param>
''' <param name="prval"> \param[out]   prval [optional] value in na corresponding to %rank</param>
''' <param name="phisto"> \param[out]   phisto [optional] Numa histogram; use NULL to prevent</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetStatsUsingHistogram")> _
Friend Shared Function numaGetStatsUsingHistogram(na as IntPTR, maxbins as Integer, pmin as single, pmax as single, pmean as single, pvariance as single, pmedian as single, rank as single, prval as single, phisto as Object) as Integer
End Function

' SRC\numafunc2.c (1326, 1)
' numaGetHistogramStats()
' numaGetHistogramStats(NUMA *, l_float32, l_float32, l_float32 *, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If the histogram represents the relation y(x), the
'''  * computed values that are returned are the x values.
'''  * These are NOT the bucket indices i; they are related to the
'''  * bucket indices by
'''  * x(i) = startx + i * deltax
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nahisto"> \param[in]    nahisto histogram: y(x(i)), i = 0 ... nbins - 1</param>
''' <param name="startx"> \param[in]    startx x value of first bin: x(0)</param>
''' <param name="deltax"> \param[in]    deltax x increment between bins; the bin size; x(1) - x(0)</param>
''' <param name="pxmean"> \param[out]   pxmean [optional] mean value of histogram</param>
''' <param name="pxmedian"> \param[out]   pxmedian [optional] median value of histogram</param>
''' <param name="pxmode"> \param[out]   pxmode [optional] mode value of histogram:</param>
''' <param name="pxvariance"> \param[out]   pxvariance [optional] variance of x</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetHistogramStats")> _
Friend Shared Function numaGetHistogramStats(nahisto as IntPTR, startx as single, deltax as single, pxmean as single, pxmedian as single, pxmode as single, pxvariance as single) as Integer
End Function

' SRC\numafunc2.c (1375, 1)
' numaGetHistogramStatsOnInterval()
' numaGetHistogramStatsOnInterval(NUMA *, l_float32, l_float32, l_int32, l_int32, l_float32 *, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If the histogram represents the relation y(x), the
'''  * computed values that are returned are the x values.
'''  * These are NOT the bucket indices i; they are related to the
'''  * bucket indices by
'''  * x(i) = startx + i * deltax
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nahisto"> \param[in]    nahisto histogram: y(x(i)), i = 0 ... nbins - 1</param>
''' <param name="startx"> \param[in]    startx x value of first bin: x(0)</param>
''' <param name="deltax"> \param[in]    deltax x increment between bins; the bin size; x(1) - x(0)</param>
''' <param name="ifirst"> \param[in]    ifirst first bin to use for collecting stats</param>
''' <param name="ilast"> \param[in]    ilast last bin for collecting stats; use 0 to go to the end</param>
''' <param name="pxmean"> \param[out]   pxmean [optional] mean value of histogram</param>
''' <param name="pxmedian"> \param[out]   pxmedian [optional] median value of histogram</param>
''' <param name="pxmode"> \param[out]   pxmode [optional] mode value of histogram:</param>
''' <param name="pxvariance"> \param[out]   pxvariance [optional] variance of x</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetHistogramStatsOnInterval")> _
Friend Shared Function numaGetHistogramStatsOnInterval(nahisto as IntPTR, startx as single, deltax as single, ifirst as Integer, ilast as Integer, pxmean as single, pxmedian as single, pxmode as single, pxvariance as single) as Integer
End Function

' SRC\numafunc2.c (1462, 1)
' numaMakeRankFromHistogram()
' numaMakeRankFromHistogram(l_float32, l_float32, NUMA *, l_int32, NUMA **, NUMA **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="startx"> \param[in]    startx xval corresponding to first element in nay</param>
''' <param name="deltax"> \param[in]    deltax x increment between array elements in nay</param>
''' <param name="nasy"> \param[in]    nasy input histogram, assumed equally spaced</param>
''' <param name="npts"> \param[in]    npts number of points to evaluate rank function</param>
''' <param name="pnax"> \param[out]   pnax [optional] array of x values in range</param>
''' <param name="pnay"> \param[out]   pnay rank array of specified npts</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaMakeRankFromHistogram")> _
Friend Shared Function numaMakeRankFromHistogram(startx as single, deltax as single, nasy as IntPTR, npts as Integer, pnax as Object, pnay as Object) as Integer
End Function

' SRC\numafunc2.c (1530, 1)
' numaHistogramGetRankFromVal()
' numaHistogramGetRankFromVal(NUMA *, l_float32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If we think of the histogram as a function y(x), normalized
'''  * to 1, for a given input value of x, this computes the
'''  * rank of x, which is the integral of y(x) from the start
'''  * value of x to the input value.
'''  *   (2) This function only makes sense when applied to a Numa that
'''  * is a histogram.  The values in the histogram can be ints and
'''  * floats, and are computed as floats.  The rank is returned
'''  * as a float between 0.0 and 1.0.
'''  *   (3) The numa parameters startx and binsize are used to
'''  * compute x from the Numa index i.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na histogram</param>
''' <param name="rval"> \param[in]    rval value of input sample for which we want the rank</param>
''' <param name="prank"> \param[out]   prank fraction of total samples below rval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaHistogramGetRankFromVal")> _
Friend Shared Function numaHistogramGetRankFromVal(na as IntPTR, rval as single, prank as single) as Integer
End Function

' SRC\numafunc2.c (1601, 1)
' numaHistogramGetValFromRank()
' numaHistogramGetValFromRank(NUMA *, l_float32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If we think of the histogram as a function y(x), this returns
'''  * the value x such that the integral of y(x) from the start
'''  * value to x gives the fraction 'rank' of the integral
'''  * of y(x) over all bins.
'''  *   (2) This function only makes sense when applied to a Numa that
'''  * is a histogram.  The values in the histogram can be ints and
'''  * floats, and are computed as floats.  The val is returned
'''  * as a float, even though the buckets are of integer width.
'''  *   (3) The numa parameters startx and binsize are used to
'''  * compute x from the Numa index i.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na histogram</param>
''' <param name="rank"> \param[in]    rank fraction of total samples</param>
''' <param name="prval"> \param[out]   prval approx. to the bin value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaHistogramGetValFromRank")> _
Friend Shared Function numaHistogramGetValFromRank(na as IntPTR, rank as single, prval as single) as Integer
End Function

' SRC\numafunc2.c (1681, 1)
' numaDiscretizeRankAndIntensity()
' numaDiscretizeRankAndIntensity(NUMA *, l_int32, NUMA **, NUMA **, NUMA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) We are inverting the rank(intensity) function to get
'''  * the intensity(rank) function at %nbins equally spaced
'''  * values of rank between 0.0 and 1.0.  We save integer values
'''  * for the intensity.
'''  *   (2) We are using the word "intensity" to describe the type of
'''  * array values, but any array of non-negative numbers will work.
'''  *   (3) The output arrays give the following mappings, where the
'''  * input is a normalized histogram of array values:
'''  * array values  -->  rank bin number  (narbin)
'''  * rank bin number  -->  median array value in bin (nam)
'''  * array values  -->  cumulative norm = rank  (nar)
'''  * rank bin number  -->  array value at right bin edge (nabb)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na normalized histogram of probability density vs intensity</param>
''' <param name="nbins"> \param[in]    nbins number of bins at which the rank is divided</param>
''' <param name="pnarbin"> \param[out]   pnarbin [optional] rank bin value vs intensity</param>
''' <param name="pnam"> \param[out]   pnam [optional] median intensity in a bin vs</param>
''' <param name="pnar"> \param[out]   pnar [optional] rank vs intensity; this is</param>
''' <param name="pnabb"> \param[out]   pnabb [optional] intensity at the right bin boundary</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaDiscretizeRankAndIntensity")> _
Friend Shared Function numaDiscretizeRankAndIntensity(na as IntPTR, nbins as Integer, pnarbin as Object, pnam as Object, pnar as Object, pnabb as Object) as Integer
End Function

' SRC\numafunc2.c (1829, 1)
' numaGetRankBinValues()
' numaGetRankBinValues(NUMA *, l_int32, NUMA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Simple interface for getting a binned rank representation
'''  * of an input array of values.  This returns two mappings:
'''  * array value  -->  rank bin number  (narbin)
'''  * rank bin number -->  median array value in each rank bin (nam)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na just an array of values</param>
''' <param name="nbins"> \param[in]    nbins number of bins at which the rank is divided</param>
''' <param name="pnarbin"> \param[out]   pnarbin [optional] rank bin value vs array value</param>
''' <param name="pnam"> \param[out]   pnam [optional] median intensity in a bin vs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetRankBinValues")> _
Friend Shared Function numaGetRankBinValues(na as IntPTR, nbins as Integer, pnarbin as Object, pnam as Object) as Integer
End Function

' SRC\numafunc2.c (1924, 1)
' numaSplitDistribution()
' numaSplitDistribution(NUMA *, l_float32, l_int32 *, l_float32 *, l_float32 *, l_float32 *, l_float32 *, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function is intended to be used on a distribution of
'''  * values that represent two sets, such as a histogram of
'''  * pixel values for an image with a fg and bg, and the goal
'''  * is to determine the averages of the two sets and the
'''  * best splitting point.
'''  *   (2) The Otsu method finds a split point that divides the distribution
'''  * into two parts by maximizing a score function that is the
'''  * product of two terms:
'''  *   (a) the square of the difference of centroids, (ave1 - ave2)^2
'''  *   (b) fract1 * (1 - fract1)
'''  * where fract1 is the fraction in the lower distribution.
'''  *   (3) This works well for images where the fg and bg are
'''  * each relatively homogeneous and well-separated in color.
'''  * However, if the actual fg and bg sets are very different
'''  * in size, and the bg is highly varied, as can occur in some
'''  * scanned document images, this will bias the split point
'''  * into the larger "bump" (i.e., toward the point where the
'''  * (b) term reaches its maximum of 0.25 at fract1 = 0.5.
'''  * To avoid this, we define a range of values near the
'''  * maximum of the score function, and choose the value within
'''  * this range such that the histogram itself has a minimum value.
'''  * The range is determined by scorefract: we include all abscissa
'''  * values to the left and right of the value that maximizes the
'''  * score, such that the score stays above (1 - scorefract) * maxscore.
'''  * The intuition behind this modification is to try to find
'''  * a split point that both has a high variance score and is
'''  * at or near a minimum in the histogram, so that the histogram
'''  * slope is small at the split point.
'''  *   (4) We normalize the score so that if the two distributions
'''  * were of equal size and at opposite ends of the numa, the
'''  * score would be 1.0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na"> \param[in]    na histogram</param>
''' <param name="scorefract"> \param[in]    scorefract fraction of the max score, used to determine</param>
''' <param name="psplitindex"> \param[out]   psplitindex [optional] index for splitting</param>
''' <param name="pave1"> \param[out]   pave1 [optional] average of lower distribution</param>
''' <param name="pave2"> \param[out]   pave2 [optional] average of upper distribution</param>
''' <param name="pnum1"> \param[out]   pnum1 [optional] population of lower distribution</param>
''' <param name="pnum2"> \param[out]   pnum2 [optional] population of upper distribution</param>
''' <param name="pnascore"> \param[out]   pnascore [optional] for debugging; otherwise use NULL</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSplitDistribution")> _
Friend Shared Function numaSplitDistribution(na as IntPTR, scorefract as single, psplitindex as Integer, pave1 as single, pave2 as single, pnum1 as single, pnum2 as single, pnascore as Object) as Integer
End Function

' SRC\numafunc2.c (2086, 1)
' grayHistogramsToEMD()
' grayHistogramsToEMD(NUMAA *, NUMAA *, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *  (1) The two numaas must be the same size and have corresponding
'''  *   256-element histograms.  Pairs do not need to be normalized
'''  *   to the same sum.
'''  *  (2) This is typically used on two sets of histograms from
'''  *   corresponding tiles of two images.  The similarity of two
'''  *   images can be found with the scoring function used in
'''  *   pixCompareGrayByHisto():
'''  * score S = 1.0 - k * D, where
'''  *  k is a constant, say in the range 5-10
'''  *  D = EMD
'''  * for each tile; for multiple tiles, take the Min(S) over
'''  * the set of tiles to be the final score.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="naa1"> \param[in]    naa1, naa2 two numaa, each with one or more 256-element</param>
''' <param name="naa2"> \param[out]   pnad nad of EM distances for each histogram</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="grayHistogramsToEMD")> _
Friend Shared Function grayHistogramsToEMD(naa1 as IntPTR, naa2 as IntPTR, pnad as Object) as Integer
End Function

' SRC\numafunc2.c (2152, 1)
' numaEarthMoverDistance()
' numaEarthMoverDistance(NUMA *, NUMA *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *  (1) The two numas must have the same size.  They do not need to be
'''  *   normalized to the same sum before applying the function.
'''  *  (2) For a 1D discrete function, the implementation of the EMD
'''  *   is trivial.  Just keep filling or emptying buckets in one numa
'''  *   to match the amount in the other, moving sequentially along
'''  *   both arrays.
'''  *  (3) We divide the sum of the absolute value of everything moved
'''  *   (by 1 unit at a time) by the sum of the numa (amount of "earth")
'''  *   to get the average distance that the "earth" was moved.
'''  *   This is the value returned here.
'''  *  (4) The caller can do a further normalization, by the number of
'''  *   buckets (minus 1), to get the EM distance as a fraction of
'''  *   the maximum possible distance, which is n-1.  This fraction
'''  *   is 1.0 for the situation where all the 'earth' in the first
'''  *   array is at one end, and all in the second array is at the
'''  *   other end.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="na1"> \param[in]    na1, na2 two numas of the same size, typically histograms</param>
''' <param name="na2"> \param[out]   pdist EM distance</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaEarthMoverDistance")> _
Friend Shared Function numaEarthMoverDistance(na1 as IntPTR, na2 as IntPTR, pdist as single) as Integer
End Function

' SRC\numafunc2.c (2243, 1)
' grayInterHistogramStats()
' grayInterHistogramStats(NUMAA *, l_int32, NUMA **, NUMA **, NUMA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *  (1) The %naa has two or more 256-element numa histograms, which
'''  *   are to be compared value-wise at each of the 256 gray levels.
'''  *   The result are stats (mean, mean square, variance, root variance)
'''  *   aggregated across the set of histograms, and each is output
'''  *   as a 256 entry numa.  Think of these histograms as a matrix,
'''  *   where each histogram is one row of the array.  The stats are
'''  *   then aggregated column-wise, between the histograms.
'''  *  (2) These stats are:
'''  *   ~ average value: v>  (nam)
'''  *   ~ average squared value: v*v> (nams)
'''  *   ~ variance: (v - v>)*(v - v>)> = v*v> - v>*v>  (nav)
'''  *   ~ square-root of variance: (narv)
'''  *   where the brackets  .. > indicate that the average value is
'''  *   to be taken over each column of the array.
'''  *  (3) The input histograms are optionally smoothed before these
'''  *   statistical operations.
'''  *  (4) The input histograms are normalized to a sum of 10000.  By
'''  *   doing this, the resulting numbers are independent of the
'''  *   number of samples used in building the individual histograms.
'''  *  (5) A typical application is on a set of histograms from tiles
'''  *   of an image, to distinguish between text/tables and photo
'''  *   regions.  If the tiles are much larger than the text line
'''  *   spacing, text/table regions typically have smaller variance
'''  *   across tiles than photo regions.  For this application, it
'''  *   may be useful to ignore values near white, which are large for
'''  *   text and would magnify the variance due to variations in
'''  *   illumination.  However, because the variance of a drawing or
'''  *   a light photo can be similar to that of grayscale text, this
'''  *   function is only a discriminator between darker photos/drawings
'''  *   and light photos/text/line-graphics.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="naa"> \param[in]    naa numaa with two or more 256-element histograms</param>
''' <param name="wc"> \param[in]    wc half-width of the smoothing window</param>
''' <param name="pnam"> \param[out]   pnam [optional] mean values</param>
''' <param name="pnams"> \param[out]   pnams [optional] mean square values</param>
''' <param name="pnav"> \param[out]   pnav [optional] variances</param>
''' <param name="pnarv"> \param[out]   pnarv [optional] rms deviations from the mean</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="grayInterHistogramStats")> _
Friend Shared Function grayInterHistogramStats(naa as IntPTR, wc as Integer, pnam as Object, pnams as Object, pnav as Object, pnarv as Object) as Integer
End Function

' SRC\numafunc2.c (2333, 1)
' numaFindPeaks()
' numaFindPeaks(NUMA *, l_int32, l_float32, l_float32) as NUMA *
''' <summary>
''' * Notes:
'''  *  (1) The returned na consists of sets of four numbers representing
'''  *   the peak, in the following order:
'''  *   left edge; peak center; right edge; normalized peak area
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  peak na, or NULL on error.</returns>
''' <param name="nas"> \param[in]    nas     source numa</param>
''' <param name="nmax"> \param[in]    nmax    max number of peaks to be found</param>
''' <param name="fract1"> \param[in]    fract1  min fraction of peak value</param>
''' <param name="fract2"> \param[in]    fract2  min slope</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaFindPeaks")> _
Friend Shared Function numaFindPeaks(nas as IntPTR, nmax as Integer, fract1 as single, fract2 as single) as IntPTR
End Function

' SRC\numafunc2.c (2448, 1)
' numaFindExtrema()
' numaFindExtrema(NUMA *, l_float32, NUMA **) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This returns a sequence of extrema (peaks and valleys).
'''  *   (2) The algorithm is analogous to that for determining
'''  * mountain peaks.  Suppose we have a local peak, with
'''  * bumps on the side.  Under what conditions can we consider
'''  * those 'bumps' to be actual peaks?  The answer: if the
'''  * bump is separated from the peak by a saddle that is at
'''  * least 500 feet below the bump.
'''  *   (3) Operationally, suppose we are looking for a peak.
'''  * We are keeping the largest value we've seen since the
'''  * last valley, and are looking for a value that is delta
'''  * BELOW our current peak.  When we find such a value,
'''  * we label the peak, use the current value to label the
'''  * valley, and then do the same operation in reverse (looking
'''  * for a valley).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad (locations of extrema, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas input values</param>
''' <param name="delta"> \param[in]    delta relative amount to resolve peaks and valleys</param>
''' <param name="pnav"> \param[out]   pnav [optional] values of extrema</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaFindExtrema")> _
Friend Shared Function numaFindExtrema(nas as IntPTR, delta as single, pnav as Object) as IntPTR
End Function

' SRC\numafunc2.c (2544, 1)
' numaCountReversals()
' numaCountReversals(NUMA *, l_float32, l_int32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The input numa is can be generated from pixExtractAlongLine().
'''  * If so, the x parameters can be used to find the reversal
'''  * frequency along a line.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nas"> \param[in]    nas input values</param>
''' <param name="minreversal"> \param[in]    minreversal relative amount to resolve peaks and valleys</param>
''' <param name="pnr"> \param[out]   pnr [optional] number of reversals</param>
''' <param name="pnrpl"> \param[out]   pnrpl ([optional] reversal density: reversals/length</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaCountReversals")> _
Friend Shared Function numaCountReversals(nas as IntPTR, minreversal as single, pnr as Integer, pnrpl as single) as Integer
End Function

' SRC\numafunc2.c (2606, 1)
' numaSelectCrossingThreshold()
' numaSelectCrossingThreshold(NUMA *, NUMA *, l_float32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *  (1) When a valid threshold is used, the number of crossings is
'''  *   a maximum, because none are missed.  If no threshold intersects
'''  *   all the crossings, the crossings must be determined with
'''  *   numaCrossingsByPeaks().
'''  *  (2) %estthresh is an input estimate of the threshold that should
'''  *   be used.  We compute the crossings with 41 thresholds
'''  *   (20 below and 20 above).  There is a range in which the
'''  *   number of crossings is a maximum.  Return a threshold
'''  *   in the center of this stable plateau of crossings.
'''  *   This can then be used with numaCrossingsByThreshold()
'''  *   to get a good estimate of crossing locations.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nax"> \param[in]    nax [optional] numa of abscissa values; can be NULL</param>
''' <param name="nay"> \param[in]    nay signal</param>
''' <param name="estthresh"> \param[in]    estthresh estimated pixel threshold for crossing: e.g., for</param>
''' <param name="pbestthresh"> \param[out]   pbestthresh robust estimate of threshold to use</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaSelectCrossingThreshold")> _
Friend Shared Function numaSelectCrossingThreshold(nax as IntPTR, nay as IntPTR, estthresh as single, pbestthresh as single) as Integer
End Function

' SRC\numafunc2.c (2713, 1)
' numaCrossingsByThreshold()
' numaCrossingsByThreshold(NUMA *, NUMA *, l_float32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) If nax == NULL, we use startx and delx from nay to compute
'''  * the crossing values in nad.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad abscissa pts at threshold, or NULL on error</returns>
''' <param name="nax"> \param[in]    nax [optional] numa of abscissa values; can be NULL</param>
''' <param name="nay"> \param[in]    nay numa of ordinate values, corresponding to nax</param>
''' <param name="thresh"> \param[in]    thresh threshold value for nay</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaCrossingsByThreshold")> _
Friend Shared Function numaCrossingsByThreshold(nax as IntPTR, nay as IntPTR, thresh as single) as IntPTR
End Function

' SRC\numafunc2.c (2778, 1)
' numaCrossingsByPeaks()
' numaCrossingsByPeaks(NUMA *, NUMA *, l_float32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) If nax == NULL, we use startx and delx from nay to compute
'''  * the crossing values in nad.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad abscissa pts at threshold, or NULL on error</returns>
''' <param name="nax"> \param[in]    nax [optional] numa of abscissa values</param>
''' <param name="nay"> \param[in]    nay numa of ordinate values, corresponding to nax</param>
''' <param name="delta"> \param[in]    delta parameter used to identify when a new peak can be found</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaCrossingsByPeaks")> _
Friend Shared Function numaCrossingsByPeaks(nax as IntPTR, nay as IntPTR, delta as single) as IntPTR
End Function

' SRC\numafunc2.c (2890, 1)
' numaEvalBestHaarParameters()
' numaEvalBestHaarParameters(NUMA *, l_float32, l_int32, l_int32, l_float32, l_float32, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does a linear sweep of widths, evaluating at %nshift
'''  * shifts for each width, computing the score from a convolution
'''  * with a long comb, and finding the (width, shift) pair that
'''  * gives the maximum score.  The best width is the "half-wavelength"
'''  * of the signal.
'''  *   (2) The convolving function is a comb of alternating values
'''  * +1 and -1 * relweight, separated by the width and phased by
'''  * the shift.  This is similar to a Haar transform, except
'''  * there the convolution is performed with a square wave.
'''  *   (3) The function is useful for finding the line spacing
'''  * and strength of line signal from pixel sum projections.
'''  *   (4) The score is normalized to the size of nas divided by
'''  * the number of half-widths.  For image applications, the input is
'''  * typically an array of pixel projections, so one should
'''  * normalize by dividing the score by the image width in the
'''  * pixel projection direction.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nas"> \param[in]    nas numa of non-negative signal values</param>
''' <param name="relweight"> \param[in]    relweight relative weight of (-1 comb) / (+1 comb)</param>
''' <param name="nwidth"> \param[in]    nwidth number of widths to consider</param>
''' <param name="nshift"> \param[in]    nshift number of shifts to consider for each width</param>
''' <param name="minwidth"> \param[in]    minwidth smallest width to consider</param>
''' <param name="maxwidth"> \param[in]    maxwidth largest width to consider</param>
''' <param name="pbestwidth"> \param[out]   pbestwidth width giving largest score</param>
''' <param name="pbestshift"> \param[out]   pbestshift shift giving largest score</param>
''' <param name="pbestscore"> \param[out]   pbestscore [optional] convolution with</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaEvalBestHaarParameters")> _
Friend Shared Function numaEvalBestHaarParameters(nas as IntPTR, relweight as single, nwidth as Integer, nshift as Integer, minwidth as single, maxwidth as single, pbestwidth as single, pbestshift as single, pbestscore as single) as Integer
End Function

' SRC\numafunc2.c (2975, 1)
' numaEvalHaarSum()
' numaEvalHaarSum(NUMA *, l_float32, l_float32, l_float32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does a convolution with a comb of alternating values
'''  * +1 and -relweight, separated by the width and phased by the shift.
'''  * This is similar to a Haar transform, except that for Haar,
'''  *   (1) the convolution kernel is symmetric about 0, so the
'''  * relweight is 1.0, and
'''  *   (2) the convolution is performed with a square wave.
'''  *   (2) The score is normalized to the size of nas divided by
'''  * twice the "width".  For image applications, the input is
'''  * typically an array of pixel projections, so one should
'''  * normalize by dividing the score by the image width in the
'''  * pixel projection direction.
'''  *   (3) To get a Haar-like result, use relweight = 1.0.  For detecting
'''  * signals where you expect every other sample to be close to
'''  * zero, as with barcodes or filtered text lines, you can
'''  * use relweight > 1.0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nas"> \param[in]    nas numa of non-negative signal values</param>
''' <param name="width"> \param[in]    width distance between +1 and -1 in convolution comb</param>
''' <param name="shift"> \param[in]    shift phase of the comb: location of first +1</param>
''' <param name="relweight"> \param[in]    relweight relative weight of (-1 comb) / (+1 comb)</param>
''' <param name="pscore"> \param[out]   pscore convolution with "Haar"-like comb</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaEvalHaarSum")> _
Friend Shared Function numaEvalHaarSum(nas as IntPTR, width as single, shift as single, relweight as single, pscore as single) as Integer
End Function

' SRC\numafunc2.c (3032, 1)
' genConstrainedNumaInRange()
' genConstrainedNumaInRange(l_int32, l_int32, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *  (1) Selection is made uniformly in the range.  This can be used
'''  *   to select pages distributed as uniformly as possible
'''  *   through a book, where you are constrained to:
'''  * ~ choose between [first, ... biggest],
'''  * ~ choose no more than nmax numbers, and
'''  *   and you have the option of requiring pairs of adjacent numbers.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="first"> \param[in]    first first number to choose; >= 0</param>
''' <param name="last"> \param[in]    last biggest possible number to reach; >= first</param>
''' <param name="nmax"> \param[in]    nmax maximum number of numbers to select; > 0</param>
''' <param name="use_pairs"> \param[in]    use_pairs 1 = select pairs of adjacent numbers;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="genConstrainedNumaInRange")> _
Friend Shared Function genConstrainedNumaInRange(first as Integer, last as Integer, nmax as Integer, use_pairs as Integer) as IntPTR
End Function

#End Region
#Region "SRC\pageseg.c"
' SRC\pageseg.c (102, 1)
' pixGetRegionsBinary()
' pixGetRegionsBinary(PIX *, PIX **, PIX **, PIX **, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) It is best to deskew the image before segmenting.
'''  *   (2) Passing in %pixadb enables debug output.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs      1 bpp, assumed to be 300 to 400 ppi</param>
''' <param name="ppixhm"> \param[out]   ppixhm    [optional] halftone mask</param>
''' <param name="ppixtm"> \param[out]   ppixtm    [optional] textline mask</param>
''' <param name="ppixtb"> \param[out]   ppixtb    [optional] textblock mask</param>
''' <param name="pixadb"> \param[in]    pixadb    input for collecting debug pix; use NULL to skip</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRegionsBinary")> _
Friend Shared Function pixGetRegionsBinary(pixs as IntPTR, ppixhm as Object, ppixtm as Object, ppixtb as Object, pixadb as IntPTR) as Integer
End Function

' SRC\pageseg.c (264, 1)
' pixGenHalftoneMask()
' pixGenHalftoneMask(PIX *, PIX **, l_int32 *, l_int32) as PIX *
''' <summary>
''' * Deprecated:
'''  *   This wrapper avoids an ABI change with tesseract 3.0.4.
'''  *   It should be removed when we no longer need to support 3.0.4.
'''  *   The debug parameter is ignored (assumed 0).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenHalftoneMask")> _
Friend Shared Function pixGenHalftoneMask(pixs as IntPTR, ppixtext as Object, phtfound as Integer, debug as Integer) as IntPTR
End Function

' SRC\pageseg.c (289, 1)
' pixGenerateHalftoneMask()
' pixGenerateHalftoneMask(PIX *, PIX **, l_int32 *, PIXA *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is not intended to work on small thumbnails.  The
'''  * dimensions of pixs must be at least MinWidth x MinHeight.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd halftone mask, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs      1 bpp, assumed to be 150 to 200 ppi</param>
''' <param name="ppixtext"> \param[out]   ppixtext  [optional] text part of pixs</param>
''' <param name="phtfound"> \param[out]   phtfound  [optional] 1 if the mask is not empty</param>
''' <param name="pixadb"> \param[in]    pixadb    input for collecting debug pix; use NULL to skip</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateHalftoneMask")> _
Friend Shared Function pixGenerateHalftoneMask(pixs as IntPTR, ppixtext as Object, phtfound as Integer, pixadb as IntPTR) as IntPTR
End Function

' SRC\pageseg.c (372, 1)
' pixGenTextlineMask()
' pixGenTextlineMask(PIX *, PIX **, l_int32 *, PIXA *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The input pixs should be deskewed.
'''  *   (2) pixs should have no halftone pixels.
'''  *   (3) This is not intended to work on small thumbnails.  The
'''  * dimensions of pixs must be at least MinWidth x MinHeight.
'''  *   (4) Both the input image and the returned textline mask
'''  * are at the same resolution.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd textline mask, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs      1 bpp, assumed to be 150 to 200 ppi</param>
''' <param name="ppixvws"> \param[out]   ppixvws   vertical whitespace mask</param>
''' <param name="ptlfound"> \param[out]   ptlfound  [optional] 1 if the mask is not empty</param>
''' <param name="pixadb"> \param[in]    pixadb    input for collecting debug pix; use NULL to skip</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenTextlineMask")> _
Friend Shared Function pixGenTextlineMask(pixs as IntPTR, ppixvws as Object, ptlfound as Integer, pixadb as IntPTR) as IntPTR
End Function

' SRC\pageseg.c (464, 1)
' pixGenTextblockMask()
' pixGenTextblockMask(PIX *, PIX *, PIXA *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Both the input masks (textline and vertical white space) and
'''  * the returned textblock mask are at the same resolution.
'''  *   (2) This is not intended to work on small thumbnails.  The
'''  * dimensions of pixs must be at least MinWidth x MinHeight.
'''  *   (3) The result is somewhat noisy, in that small "blocks" of
'''  * text may be included.  These can be removed by post-processing,
'''  * using, e.g.,
'''  * pixSelectBySize(pix, 60, 60, 4, L_SELECT_IF_EITHER,
'''  *  L_SELECT_IF_GTE, NULL);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd textblock mask, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     1 bpp, textline mask, assumed to be 150 to 200 ppi</param>
''' <param name="pixvws"> \param[in]    pixvws   vertical white space mask</param>
''' <param name="pixadb"> \param[in]    pixadb   input for collecting debug pix; use NULL to skip</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenTextblockMask")> _
Friend Shared Function pixGenTextblockMask(pixs as IntPTR, pixvws as IntPTR, pixadb as IntPTR) as IntPTR
End Function

' SRC\pageseg.c (548, 1)
' pixFindPageForeground()
' pixFindPageForeground(PIX *, l_int32, l_int32, l_int32, l_int32, PIXAC *) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This doesn't simply crop to the fg.  It attempts to remove
'''  * pixel noise and junk at the edge of the image before cropping.
'''  * The input %threshold is used if pixs is not 1 bpp.
'''  *   (2) This is not intended to work on small thumbnails.  The
'''  * dimensions of pixs must be at least MinWidth x MinHeight.
'''  *   (3) Debug: set showmorph to display the intermediate image in
'''  * the morphological operations on this page.
'''  *   (4) Debug: to get pdf output of results when called repeatedly,
'''  * call with an existing pixac, which will add an image of this page,
'''  * with the fg outlined.  If no foreground is found, there is
'''  * no output for this page image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box region including foreground, with some pixel noise</returns>
''' <param name="pixs"> \param[in]    pixs       full resolution (any type or depth</param>
''' <param name="threshold"> \param[in]    threshold  for binarization; typically about 128</param>
''' <param name="mindist"> \param[in]    mindist    min distance of text from border to allow</param>
''' <param name="erasedist"> \param[in]    erasedist  when conditions are satisfied, erase anything</param>
''' <param name="showmorph"> \param[in]    showmorph  debug: set to a negative integer to show steps</param>
''' <param name="pixac"> \param[in]    pixac      debug: allocate outside and pass this in to</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindPageForeground")> _
Friend Shared Function pixFindPageForeground(pixs as IntPTR, threshold as Integer, mindist as Integer, erasedist as Integer, showmorph as Integer, pixac as IntPTR) as IntPTR
End Function

' SRC\pageseg.c (679, 1)
' pixSplitIntoCharacters()
' pixSplitIntoCharacters(PIX *, l_int32, l_int32, BOXA **, PIXA **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a simple function that attempts to find split points
'''  * based on vertical pixel profiles.
'''  *   (2) It should be given an image that has an arbitrary number
'''  * of text characters.
'''  *   (3) The returned pixa includes the boxes from which the
'''  * (possibly split) components are extracted.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs      1 bpp, contains only deskewed text</param>
''' <param name="minw"> \param[in]    minw      min component width for initial filtering; typ. 4</param>
''' <param name="minh"> \param[in]    minh      min component height for initial filtering; typ. 4</param>
''' <param name="pboxa"> \param[out]   pboxa     [optional] character bounding boxes</param>
''' <param name="ppixa"> \param[out]   ppixa     [optional] character images</param>
''' <param name="ppixdebug"> \param[out]   ppixdebug [optional] showing splittings</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSplitIntoCharacters")> _
Friend Shared Function pixSplitIntoCharacters(pixs as IntPTR, minw as Integer, minh as Integer, pboxa as Object, ppixa as Object, ppixdebug as Object) as Integer
End Function

' SRC\pageseg.c (780, 1)
' pixSplitComponentWithProfile()
' pixSplitComponentWithProfile(PIX *, l_int32, l_int32, PIX **) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This will split the most obvious cases of touching characters.
'''  * The split points it is searching for are narrow and deep
'''  * minimima in the vertical pixel projection profile, after a
'''  * large vertical closing has been applied to the component.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa of c.c. after splitting, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs       1 bpp, exactly one connected component</param>
''' <param name="delta"> \param[in]    delta      distance used in extrema finding in a numa; typ. 10</param>
''' <param name="mindel"> \param[in]    mindel     minimum required difference between profile</param>
''' <param name="ppixdebug"> \param[out]   ppixdebug  [optional] debug image of splitting</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSplitComponentWithProfile")> _
Friend Shared Function pixSplitComponentWithProfile(pixs as IntPTR, delta as Integer, mindel as Integer, ppixdebug as Object) as IntPTR
End Function

' SRC\pageseg.c (936, 1)
' pixExtractTextlines()
' pixExtractTextlines(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, PIXA *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This function assumes that textline fragments have sufficient
'''  * vertical separation and small enough skew so that a
'''  * horizontal dilation sufficient to join words will not join
'''  * textlines.  It does not guarantee that horizontally adjacent
'''  * textline fragments on the same line will be joined.
'''  *   (2) For images with multiple columns, it attempts to avoid joining
'''  * textlines across the space between columns.  If that is not
'''  * a concern, you can also use pixExtractRawTextlines(),
'''  * which will join them with alacrity.
'''  *   (3) This first removes components from pixs that are either
'''  * wide (> %maxw) or tall (> %maxh).
'''  *   (4) A final filtering operation removes small components, such
'''  * that width  %minw or height  %minh.
'''  *   (5) For reasonable accuracy, the resolution of pixs should be
'''  * at least 100 ppi.  For reasonable efficiency, the resolution
'''  * should not exceed 600 ppi.
'''  *   (6) This can be used to determine if some region of a scanned
'''  * image is horizontal text.
'''  *   (7) As an example, for a pix with resolution 300 ppi, a reasonable
'''  * set of parameters is:
'''  * pixExtractTextlines(pix, 150, 150, 36, 20, 5, 5, NULL);
'''  * The defaults minw and minh for 300 ppi are about 36 and 20,
'''  * so the same result is obtained with:
'''  * pixExtractTextlines(pix, 150, 150, 0, 0, 5, 5, NULL);
'''  *   (8) The output pixa is composed of subimages, one for each textline,
'''  * and the boxa in the pixa tells where in %pixs each textline goes.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa of textline images, including bounding boxes, or</returns>
''' <param name="pixs"> \param[in]    pixs        any depth, assumed to have nearly horizontal text</param>
''' <param name="maxw"> \param[in]    maxw, maxh  initial filtering: remove any components in pixs</param>
''' <param name="maxh"> \param[in]    minw, minh  final filtering: remove extracted 'lines'</param>
''' <param name="minw"> \param[in]    adjw, adjh  final adjustment of boxes representing each</param>
''' <param name="minh"> \param[in]    pixadb      pixa for saving intermediate steps; NULL to omit</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExtractTextlines")> _
Friend Shared Function pixExtractTextlines(pixs as IntPTR, maxw as Integer, maxh as Integer, minw as Integer, minh as Integer, adjw as Integer, adjh as Integer, pixadb as IntPTR) as IntPTR
End Function

' SRC\pageseg.c (1076, 1)
' pixExtractRawTextlines()
' pixExtractRawTextlines(PIX *, l_int32, l_int32, l_int32, l_int32, PIXA *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This function assumes that textlines have sufficient
'''  * vertical separation and small enough skew so that a
'''  * horizontal dilation sufficient to join words will not join
'''  * textlines.  It aggressively joins textlines across multiple
'''  * columns, so if that is not desired, you must either (a) make
'''  * sure that %pixs is a single column of text or (b) use instead
'''  * pixExtractTextlines(), which is more conservative
'''  * about joining text fragments that have vertical overlap.
'''  *   (2) This first removes components from pixs that are either
'''  * very wide (> %maxw) or very tall (> %maxh).
'''  *   (3) For reasonable accuracy, the resolution of pixs should be
'''  * at least 100 ppi.  For reasonable efficiency, the resolution
'''  * should not exceed 600 ppi.
'''  *   (4) This can be used to determine if some region of a scanned
'''  * image is horizontal text.
'''  *   (5) As an example, for a pix with resolution 300 ppi, a reasonable
'''  * set of parameters is:
'''  * pixExtractRawTextlines(pix, 150, 150, 0, 0, NULL);
'''  *   (6) The output pixa is composed of subimages, one for each textline,
'''  * and the boxa in the pixa tells where in %pixs each textline goes.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa of textline images, including bounding boxes, or</returns>
''' <param name="pixs"> \param[in]    pixs        any depth, assumed to have nearly horizontal text</param>
''' <param name="maxw"> \param[in]    maxw, maxh  initial filtering: remove any components in pixs</param>
''' <param name="maxh"> \param[in]    adjw, adjh  final adjustment of boxes representing each</param>
''' <param name="adjw"> \param[in]    pixadb      pixa for saving intermediate steps; NULL to omit</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExtractRawTextlines")> _
Friend Shared Function pixExtractRawTextlines(pixs as IntPTR, maxw as Integer, maxh as Integer, adjw as Integer, adjh as Integer, pixadb as IntPTR) as IntPTR
End Function

' SRC\pageseg.c (1204, 1)
' pixCountTextColumns()
' pixCountTextColumns(PIX *, l_float32, l_float32, l_float32, l_int32 *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) It is assumed that pixs has the correct resolution set.
'''  * If the resolution is 0, we set to 300 and issue a warning.
'''  *   (2) If necessary, the image is scaled to between 37 and 75 ppi;
'''  * most of the processing is done at this resolution.
'''  *   (3) If no text is found (essentially a blank page),
'''  * this returns ncols = 0.
'''  *   (4) For debug output, input a pre-allocated pixa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs        1 bpp</param>
''' <param name="deltafract"> \param[in]    deltafract  fraction of (max - min) to be used in the delta</param>
''' <param name="peakfract"> \param[in]    peakfract   fraction of (max - min) to be used to threshold</param>
''' <param name="clipfract"> \param[in]    clipfract   fraction of image dimension removed on each side;</param>
''' <param name="pncols"> \param[out]   pncols      number of columns; -1 if not determined</param>
''' <param name="pixadb"> \param[in]    pixadb      [optional] pre-allocated, for showing</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCountTextColumns")> _
Friend Shared Function pixCountTextColumns(pixs as IntPTR, deltafract as single, peakfract as single, clipfract as single, pncols as Integer, pixadb as IntPTR) as Integer
End Function

' SRC\pageseg.c (1352, 1)
' pixDecideIfText()
' pixDecideIfText(PIX *, BOX *, l_int32 *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) It is assumed that pixs has the correct resolution set.
'''  * If the resolution is 0, we set to 300 and issue a warning.
'''  *   (2) If necessary, the image is scaled to 300 ppi; most of the
'''  * processing is done at this resolution.
'''  *   (3) Text is assumed to be in horizontal lines.
'''  *   (4) Because thin vertical lines are removed before filtering for
'''  * text lines, this should identify tables as text.
'''  *   (5) If %box is null and pixs contains both text lines and line art,
'''  * this function might return %istext == true.
'''  *   (6) If the input pixs is empty, or for some other reason the
'''  * result can not be determined, return -1.
'''  *   (7) For debug output, input a pre-allocated pixa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     any depth</param>
''' <param name="box"> \param[in]    box      [optional]  if null, use entire pixs</param>
''' <param name="pistext"> \param[out]   pistext  1 if text; 0 if photo; -1 if not determined or empty</param>
''' <param name="pixadb"> \param[in]    pixadb   [optional] pre-allocated, for showing intermediate</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDecideIfText")> _
Friend Shared Function pixDecideIfText(pixs as IntPTR, box as IntPTR, pistext as Integer, pixadb as IntPTR) as Integer
End Function

' SRC\pageseg.c (1518, 1)
' pixFindThreshFgExtent()
' pixFindThreshFgExtent(PIX *, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     1 bpp</param>
''' <param name="thresh"> \param[in]    thresh   threshold number of pixels in row</param>
''' <param name="ptop"> \param[out]   ptop     [optional] location of top of region</param>
''' <param name="pbot"> \param[out]   pbot     [optional] location of bottom of region</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindThreshFgExtent")> _
Friend Shared Function pixFindThreshFgExtent(pixs as IntPTR, thresh as Integer, ptop as Integer, pbot as Integer) as Integer
End Function

' SRC\pageseg.c (1608, 1)
' pixDecideIfTable()
' pixDecideIfTable(PIX *, BOX *, l_int32, l_int32 *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) It is assumed that pixs has the correct resolution set.
'''  * If the resolution is 0, we assume it is 300 ppi and issue a warning.
'''  *   (2) If %orient == L_LANDSCAPE_MODE, the image is rotated 90 degrees
'''  * clockwise before being analyzed.
'''  *   (3) The interpretation of the returned score:
'''  *   -1  undetermined
'''  * 0  no table
'''  * 1  unlikely to have a table
'''  * 2  likely to have a table
'''  * 3  even more likely to have a table
'''  * 4  extremely likely to have a table
'''  * * Setting the condition for finding a table at score >= 2 works
'''  *   well, except for false positives on kanji and landscape text.
'''  * * These false positives can be removed by setting the condition
'''  *   at score >= 3, but recall is lowered because it will not find
'''  *   tables without either horizontal or vertical lines.
'''  *   (4) Most of the processing takes place at 75 ppi.
'''  *   (5) Internally, three numbers are determined, for horizontal and
'''  * vertical fg lines, and for vertical bg lines.  From these,
'''  * four tests are made to decide if there is a table occupying
'''  * a significant part of the image.
'''  *   (6) Images have arbitrary content and would be likely to trigger
'''  * this detector, so they are checked for first, and if found,
'''  * return with a 0 (no table) score.
'''  *   (7) Musical scores (tablature) are likely to trigger the detector.
'''  *   (8) Tables of content with more than 2 columns are likely to
'''  * trigger the detector.
'''  *   (9) For debug output, input a pre-allocated pixa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs      any depth, any resolution >= 75 ppi</param>
''' <param name="box"> \param[in]    box       [optional] if null, use entire pixs</param>
''' <param name="orient"> \param[in]    orient    L_PORTRAIT_MODE, L_LANDSCAPE_MODE</param>
''' <param name="pscore"> \param[out]   pscore    0 - 4; -1 if not determined</param>
''' <param name="pixadb"> \param[in]    pixadb    [optional] pre-allocated, for showing intermediate</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDecideIfTable")> _
Friend Shared Function pixDecideIfTable(pixs as IntPTR, box as IntPTR, orient as Integer, pscore as Integer, pixadb as IntPTR) as Integer
End Function

' SRC\pageseg.c (1758, 1)
' pixPrepare1bpp()
' pixPrepare1bpp(PIX *, BOX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This handles some common pre-processing operations,
'''  * where the page segmentation algorithm takes a 1 bpp image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd if OK, NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs       any depth</param>
''' <param name="box"> \param[in]    box        [optional] if null, use entire pixs</param>
''' <param name="cropfract"> \param[in]    cropfract  fraction to be removed from the boundary;</param>
''' <param name="outres"> \param[in]    outres     desired resolution of output image; if the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixPrepare1bpp")> _
Friend Shared Function pixPrepare1bpp(pixs as IntPTR, box as IntPTR, cropfract as single, outres as Integer) as IntPTR
End Function

' SRC\pageseg.c (1843, 1)
' pixEstimateBackground()
' pixEstimateBackground(PIX *, l_int32, l_float32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Caller should check that return bg value is > 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs         8 bpp, with or without colormap</param>
''' <param name="darkthresh"> \param[in]    darkthresh   pixels below this value are never considered</param>
''' <param name="edgecrop"> \param[in]    edgecrop     fraction of half-width on each side, and of</param>
''' <param name="pbg"> \param[out]   pbg          estimated background, or 0 on error</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixEstimateBackground")> _
Friend Shared Function pixEstimateBackground(pixs as IntPTR, darkthresh as Integer, edgecrop as single, pbg as Integer) as Integer
End Function

' SRC\pageseg.c (1927, 1)
' pixFindLargeRectangles()
' pixFindLargeRectangles(PIX *, l_int32, l_int32, BOXA **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does a greedy search to find the largest rectangles,
'''  * either black or white and without overlaps, in %pix.
'''  *   (2) See pixFindLargestRectangle(), which is called multiple
'''  * times, for details.  On each call, the largest rectangle
'''  * found is painted, so that none of its pixels can be
'''  * used later, before calling it again.
'''  *   (3) This function is surprisingly fast.  Although
'''  * pixFindLargestRectangle() runs at about 50 MPix/sec, when it
'''  * is run multiple times by pixFindLargeRectangles(), it processes
'''  * at 150 - 250 MPix/sec, and the time is approximately linear
'''  * in %nrect.  For example, for a 1 MPix image, searching for
'''  * the largest 50 boxes takes about 0.2 seconds.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs       1 bpp</param>
''' <param name="polarity"> \param[in]    polarity   0 within background, 1 within foreground</param>
''' <param name="nrect"> \param[in]    nrect      number of rectangles to be found</param>
''' <param name="pboxa"> \param[out]   pboxa      largest rectangles, sorted by decreasing area</param>
''' <param name="ppixdb"> \param[in,out]  ppixdb   optional return output with rectangles drawn on it</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindLargeRectangles")> _
Friend Shared Function pixFindLargeRectangles(pixs as IntPTR, polarity as Integer, nrect as Integer, pboxa as Object, ppixdb as Object) as Integer
End Function

' SRC\pageseg.c (2030, 1)
' pixFindLargestRectangle()
' pixFindLargestRectangle(PIX *, l_int32, BOX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a simple and elegant solution to a problem in
'''  * computational geometry that at first appears to be quite
'''  * difficult: what is the largest rectangle that can be
'''  * placed in the image, covering only pixels of one polarity
'''  * (bg or fg)?  The solution is O(n), where n is the number
'''  * of pixels in the image, and it requires nothing more than
'''  * using a simple recursion relation in a single sweep of the image.
'''  *   (2) In a sweep from UL to LR with left-to-right being the fast
'''  * direction, calculate the largest white rectangle at (x, y),
'''  * using previously calculated values at pixels #1 and #2:
'''  * #1: (x, y - 1)
'''  * #2: (x - 1, y)
'''  * We also need the most recent "black" pixels that were seen
'''  * in the current row and column.
'''  * Consider the largest area.  There are only two possibilities:
'''  * (a)  Min(w(1), horizdist) * (h(1) + 1)
'''  * (b)  Min(h(2), vertdist) * (w(2) + 1)
'''  * where
'''  * horizdist: the distance from the rightmost "black" pixel seen
'''  *   in the current row across to the current pixel
'''  * vertdist: the distance from the lowest "black" pixel seen
'''  *  in the current column down to the current pixel
'''  * and we choose the Max of (a) and (b).
'''  *   (3) To convince yourself that these recursion relations are correct,
'''  * it helps to draw the maximum rectangles at #1 and #2.
'''  * Then for #1, you try to extend the rectangle down one line,
'''  * so that the height is h(1) + 1.  Do you get the full
'''  * width of #1, w(1)?  It depends on where the black pixels are
'''  * in the current row.  You know the final width is bounded by w(1)
'''  * and w(2) + 1, but the actual value depends on the distribution
'''  * of black pixels in the current row that are at a distance
'''  * from the current pixel that is between these limits.
'''  * We call that value "horizdist", and the area is then given
'''  * by the expression (a) above.  Using similar reasoning for #2,
'''  * where you attempt to extend the rectangle to the right
'''  * by 1 pixel, you arrive at (b).  The largest rectangle is
'''  * then found by taking the Max.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs       1 bpp</param>
''' <param name="polarity"> \param[in]    polarity   0 within background, 1 within foreground</param>
''' <param name="pbox"> \param[out]   pbox       largest area rectangle</param>
''' <param name="ppixdb"> \param[in,out]  ppixdb   optional return output with rectangle drawn on it</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindLargestRectangle")> _
Friend Shared Function pixFindLargestRectangle(pixs as IntPTR, polarity as Integer, pbox as Object, ppixdb as Object) as Integer
End Function

#End Region
#Region "SRC\paintcmap.c"
' SRC\paintcmap.c (98, 1)
' pixSetSelectCmap()
' pixSetSelectCmap(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place operation.
'''  *   (2) It sets all pixels in region that have the color specified
'''  * by the colormap index 'sindex' to the new color.
'''  *   (3) sindex must be in the existing colormap; otherwise an
'''  * error is returned.
'''  *   (4) If the new color exists in the colormap, it is used;
'''  * otherwise, it is added to the colormap.  If it cannot be
'''  * added because the colormap is full, an error is returned.
'''  *   (5) If box is NULL, applies function to the entire image; otherwise,
'''  * clips the operation to the intersection of the box and pix.
'''  *   (6) An example of use would be to set to a specific color all
'''  * the light (background) pixels within a certain region of
'''  * a 3-level 2 bpp image, while leaving light pixels outside
'''  * this region unchanged.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4 or 8 bpp, with colormap</param>
''' <param name="box"> \param[in]    box [optional] region to set color; can be NULL</param>
''' <param name="sindex"> \param[in]    sindex colormap index of pixels to be changed</param>
''' <param name="rval"> \param[in]    rval, gval, bval new color to paint</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetSelectCmap")> _
Friend Shared Function pixSetSelectCmap(pixs as IntPTR, box as IntPTR, sindex as Integer, rval as Integer, gval as Integer, bval as Integer) as Integer
End Function

' SRC\paintcmap.c (219, 1)
' pixColorGrayRegionsCmap()
' pixColorGrayRegionsCmap(PIX *, BOXA *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place operation.
'''  *   (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
'''  * preserving antialiasing.
'''  * If type == L_PAINT_DARK, it colorizes non-white pixels,
'''  * preserving antialiasing.  See pixColorGrayCmap() for details.
'''  *   (3) This can also be called through pixColorGrayRegions().
'''  *   (4) This increases the colormap size by the number of
'''  * different gray (non-black or non-white) colors in the
'''  * selected regions of pixs.  If there is not enough room in
'''  * the colormap for this expansion, it returns 1 (error),
'''  * and the caller should check the return value.
'''  *   (5) Because two boxes in the boxa can overlap, pixels that
'''  * are colorized in the first box must be excluded in the
'''  * second because their value exceeds the size of the map.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, with colormap</param>
''' <param name="boxa"> \param[in]    boxa of regions in which to apply color</param>
''' <param name="type"> \param[in]    type L_PAINT_LIGHT, L_PAINT_DARK</param>
''' <param name="rval"> \param[in]    rval, gval, bval target color</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorGrayRegionsCmap")> _
Friend Shared Function pixColorGrayRegionsCmap(pixs as IntPTR, boxa as IntPTR, type as Integer, rval as Integer, gval as Integer, bval as Integer) as Integer
End Function

' SRC\paintcmap.c (327, 1)
' pixColorGrayCmap()
' pixColorGrayCmap(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place operation.
'''  *   (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
'''  * preserving antialiasing.
'''  * If type == L_PAINT_DARK, it colorizes non-white pixels,
'''  * preserving antialiasing.
'''  *   (3) box gives the region to apply color; if NULL, this
'''  * colorizes the entire image.
'''  *   (4) If the cmap is only 2 or 4 bpp, pixs is converted in-place
'''  * to an 8 bpp cmap.  A 1 bpp cmap is not a valid input pix.
'''  *   (5) This can also be called through pixColorGray().
'''  *   (6) This operation increases the colormap size by the number of
'''  * different gray (non-black or non-white) colors in the
'''  * input colormap.  If there is not enough room in the colormap
'''  * for this expansion, it returns 1 (error), and the caller
'''  * should check the return value.
'''  *   (7) Using the darkness of each original pixel in the rect,
'''  * it generates a new color (based on the input rgb values).
'''  * If type == L_PAINT_LIGHT, the new color is a (generally)
'''  * darken-to-black version of the  input rgb color, where the
'''  * amount of darkening increases with the darkness of the
'''  * original pixel color.
'''  * If type == L_PAINT_DARK, the new color is a (generally)
'''  * faded-to-white version of the  input rgb color, where the
'''  * amount of fading increases with the brightness of the
'''  * original pixel color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 2, 4 or 8 bpp, with colormap</param>
''' <param name="box"> \param[in]    box [optional] region to set color; can be NULL</param>
''' <param name="type"> \param[in]    type L_PAINT_LIGHT, L_PAINT_DARK</param>
''' <param name="rval"> \param[in]    rval, gval, bval target color</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorGrayCmap")> _
Friend Shared Function pixColorGrayCmap(pixs as IntPTR, box as IntPTR, type as Integer, rval as Integer, gval as Integer, bval as Integer) as Integer
End Function

' SRC\paintcmap.c (395, 1)
' pixColorGrayMaskedCmap()
' pixColorGrayMaskedCmap(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place operation.
'''  *   (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
'''  * preserving antialiasing.
'''  * If type == L_PAINT_DARK, it colorizes non-white pixels,
'''  * preserving antialiasing.  See pixColorGrayCmap() for details.
'''  *   (3) This increases the colormap size by the number of
'''  * different gray (non-black or non-white) colors in the
'''  * input colormap.  If there is not enough room in the colormap
'''  * for this expansion, it returns 1 (error).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, with colormap</param>
''' <param name="pixm"> \param[in]    pixm 1 bpp mask, through which to apply color</param>
''' <param name="type"> \param[in]    type L_PAINT_LIGHT, L_PAINT_DARK</param>
''' <param name="rval"> \param[in]    rval, gval, bval target color</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorGrayMaskedCmap")> _
Friend Shared Function pixColorGrayMaskedCmap(pixs as IntPTR, pixm as IntPTR, type as Integer, rval as Integer, gval as Integer, bval as Integer) as Integer
End Function

' SRC\paintcmap.c (492, 1)
' addColorizedGrayToCmap()
' addColorizedGrayToCmap(PIXCMAP *, l_int32, l_int32, l_int32, l_int32, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
'''  * preserving antialiasing.
'''  * If type == L_PAINT_DARK, it colorizes non-white pixels,
'''  * preserving antialiasing.
'''  *   (2) This increases the colormap size by the number of
'''  * different gray (non-black or non-white) colors in the
'''  * input colormap.  If there is not enough room in the colormap
'''  * for this expansion, it returns 1 (treated as a warning);
'''  * the caller should check the return value.
'''  *   (3) This can be used to determine if the new colors will fit in
'''  * the cmap, using null for &na.  Returns 0 if they fit; 2 if
'''  * they don't fit.
'''  *   (4) The mapping table contains, for each gray color found, the
'''  * index of the corresponding colorized pixel.  Non-gray
'''  * pixels are assigned the invalid index 256.
'''  *   (5) See pixColorGrayCmap() for usage.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error; 2 if new colors will not fit in cmap.</returns>
''' <param name="cmap"> \param[in]    cmap from 2 or 4 bpp pix</param>
''' <param name="type"> \param[in]    type L_PAINT_LIGHT, L_PAINT_DARK</param>
''' <param name="rval"> \param[in]    rval, gval, bval target color</param>
''' <param name="gval"> \param[out]   pna [optional] table for mapping new cmap entries</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="addColorizedGrayToCmap")> _
Friend Shared Function addColorizedGrayToCmap(cmap as IntPTR, type as Integer, rval as Integer, gval as Integer, bval as Integer, pna as Object) as Integer
End Function

' SRC\paintcmap.c (583, 1)
' pixSetSelectMaskedCmap()
' pixSetSelectMaskedCmap(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place operation.
'''  *   (2) This paints through the fg of pixm and replaces all pixels
'''  * in pixs that have a particular value (sindex) with the new color.
'''  *   (3) If pixm == NULL, a warning is given.
'''  *   (4) sindex must be in the existing colormap; otherwise an
'''  * error is returned.
'''  *   (5) If the new color exists in the colormap, it is used;
'''  * otherwise, it is added to the colormap.  If the colormap
'''  * is full, an error is returned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 2, 4 or 8 bpp, with colormap</param>
''' <param name="pixm"> \param[in]    pixm [optional] 1 bpp mask; no-op if NULL</param>
''' <param name="x"> \param[in]    x, y UL corner of mask relative to pixs</param>
''' <param name="y"> \param[in]    sindex colormap index of pixels in pixs to be changed</param>
''' <param name="sindex"> \param[in]    rval, gval, bval new color to substitute</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetSelectMaskedCmap")> _
Friend Shared Function pixSetSelectMaskedCmap(pixs as IntPTR, pixm as IntPTR, x as Integer, y as Integer, sindex as Integer, rval as Integer, gval as Integer, bval as Integer) as Integer
End Function

' SRC\paintcmap.c (693, 1)
' pixSetMaskedCmap()
' pixSetMaskedCmap(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place operation.
'''  *   (2) It paints a single color through the mask (as a stencil).
'''  *   (3) The mask origin is placed at (x,y) on pixs, and the
'''  * operation is clipped to the intersection of the mask and pixs.
'''  *   (4) If pixm == NULL, a warning is given.
'''  *   (5) Typically, pixm is a small binary mask located somewhere
'''  * on the larger pixs.
'''  *   (6) If the color is in the colormap, it is used.  Otherwise,
'''  * it is added if possible; an error is returned if the
'''  * colormap is already full.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 2, 4 or 8 bpp, colormapped</param>
''' <param name="pixm"> \param[in]    pixm [optional] 1 bpp mask; no-op if NULL</param>
''' <param name="x"> \param[in]    x, y origin of pixm relative to pixs; can be negative</param>
''' <param name="y"> \param[in]    rval, gval, bval new color to set at each masked pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetMaskedCmap")> _
Friend Shared Function pixSetMaskedCmap(pixs as IntPTR, pixm as IntPTR, x as Integer, y as Integer, rval as Integer, gval as Integer, bval as Integer) as Integer
End Function

#End Region
#Region "SRC\parseprotos.c"
' SRC\parseprotos.c (51, 16)
' 
' getNextNonCommentLine(SARRAY *, l_int32, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getNextNonCommentLine")> _
Friend Shared Function getNextNonCommentLine(sa as IntPTR, start as Integer, pnext as Integer) as Integer
End Function

' SRC\parseprotos.c (52, 16)
' 
' getNextNonBlankLine(SARRAY *, l_int32, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getNextNonBlankLine")> _
Friend Shared Function getNextNonBlankLine(sa as IntPTR, start as Integer, pnext as Integer) as Integer
End Function

' SRC\parseprotos.c (53, 16)
' 
' getNextNonDoubleSlashLine(SARRAY *, l_int32, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getNextNonDoubleSlashLine")> _
Friend Shared Function getNextNonDoubleSlashLine(sa as IntPTR, start as Integer, pnext as Integer) as Integer
End Function

' SRC\parseprotos.c (55, 16)
' 
' searchForProtoSignature(SARRAY *, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="searchForProtoSignature")> _
Friend Shared Function searchForProtoSignature(sa as IntPTR, begin as Integer, pstart as Integer, pstop as Integer, pcharindex as Integer, pfound as Integer) as Integer
End Function

' SRC\parseprotos.c (58, 15)
' 
' captureProtoSignature(SARRAY *, l_int32, l_int32, l_int32) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="captureProtoSignature")> _
Friend Shared Function captureProtoSignature(sa as IntPTR, start as Integer, _stop_ as Integer, charindex as Integer) as String
End Function

' SRC\parseprotos.c (60, 15)
' 
' cleanProtoSignature(char *) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="cleanProtoSignature")> _
Friend Shared Function cleanProtoSignature(str as Object) as String
End Function

' SRC\parseprotos.c (61, 16)
' 
' skipToEndOfFunction(SARRAY *, l_int32, l_int32, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="skipToEndOfFunction")> _
Friend Shared Function skipToEndOfFunction(sa as IntPTR, start as Integer, charindex as Integer, pnext as Integer) as Integer
End Function

' SRC\parseprotos.c (63, 16)
' 
' skipToMatchingBrace(SARRAY *, l_int32, l_int32, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="skipToMatchingBrace")> _
Friend Shared Function skipToMatchingBrace(sa as IntPTR, start as Integer, lbindex as Integer, prbline as Integer, prbindex as Integer) as Integer
End Function

' SRC\parseprotos.c (65, 16)
' 
' skipToSemicolon(SARRAY *, l_int32, l_int32, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="skipToSemicolon")> _
Friend Shared Function skipToSemicolon(sa as IntPTR, start as Integer, charindex as Integer, pnext as Integer) as Integer
End Function

' SRC\parseprotos.c (67, 16)
' 
' getOffsetForCharacter(SARRAY *, l_int32, char, l_int32 *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getOffsetForCharacter")> _
Friend Shared Function getOffsetForCharacter(sa as IntPTR, start as Integer, tchar as Object, psoffset as Integer, pboffset as Integer, ptoffset as Integer) as Integer
End Function

' SRC\parseprotos.c (69, 16)
' 
' getOffsetForMatchingRP(SARRAY *, l_int32, l_int32, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getOffsetForMatchingRP")> _
Friend Shared Function getOffsetForMatchingRP(sa as IntPTR, start as Integer, soffsetlp as Integer, boffsetlp as Integer, toffsetlp as Integer, psoffset as Integer, pboffset as Integer, ptoffset as Integer) as Integer
End Function

' SRC\parseprotos.c (142, 1)
' 
' parseForProtos(const char *, const char *) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="parseForProtos")> _
Friend Shared Function parseForProtos(filein as String, prestring as String) as String
End Function

#End Region
#Region "SRC\partition.c"
' SRC\partition.c (55, 17)
' partelCreate()
' partelCreate(BOX *) as PARTEL *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  partel, or NULL on error</returns>
''' <param name="box"> \param[in]    box region; inserts a copy</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="partelCreate")> _
Friend Shared Function partelCreate(box as IntPTR) as IntPTR
End Function

' SRC\partition.c (56, 13)
' partelDestroy()
' partelDestroy(PARTEL **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="ppartel"> \param[in,out]   ppartel  contents will be set to null before returning</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="partelDestroy")> _
Friend Shared Function partelDestroy(ppartel as Object) as Boolean ' Org. Void
End Function

' SRC\partition.c (57, 16)
' partelSetSize()
' partelSetSize(PARTEL *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="partel"> \param[in]    partel</param>
''' <param name="sortflag"> \param[in]    sortflag L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="partelSetSize")> _
Friend Shared Function partelSetSize(partel as IntPTR, sortflag as Integer) as Integer
End Function

' SRC\partition.c (58, 15)
' boxaGenerateSubboxes()
' boxaGenerateSubboxes(BOX *, BOXA *, l_int32, l_float32) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa of four or less overlapping subrectangles of the box,</returns>
''' <param name="box"> \param[in]    box region to be split into up to four overlapping subregions</param>
''' <param name="boxa"> \param[in]    boxa boxes of rectangles intersecting the box</param>
''' <param name="maxperim"> \param[in]    maxperim maximum half-perimeter for which pivot</param>
''' <param name="fract"> \param[in]    fract fraction of box diagonal that is an acceptable</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGenerateSubboxes")> _
Friend Shared Function boxaGenerateSubboxes(box as IntPTR, boxa as IntPTR, maxperim as Integer, fract as single) as IntPTR
End Function

' SRC\partition.c (60, 14)
' boxaSelectPivotBox()
' boxaSelectPivotBox(BOX *, BOXA *, l_int32, l_float32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This is a tricky piece that wasn't discussed in the
'''  * Breuel's 2002 paper.
'''  *   (2) Selects a box from boxa whose centroid is reasonably close to
'''  * the centroid of the containing box (xc, yc) and whose
'''  * half-perimeter does not exceed the maxperim value.
'''  *   (3) If there are no boxes in the boxa that are small enough,
'''  * then it selects the smallest of the larger boxes,
'''  * without reference to its location in the containing box.
'''  *   (4) If a small box has a centroid at a distance from the
'''  * centroid of the containing box that is not more than
'''  * the fraction 'fract' of the diagonal of the containing
'''  * box, that box is chosen as the pivot, terminating the
'''  * search for the nearest small box.
'''  *   (5) Use fract in the range [0.0 ... 1.0].  Set fract = 0.0
'''  * to choose the small box nearest the centroid.
'''  *   (6) Choose maxperim to represent a connected component that is
'''  * small enough so that you don't care about the white space
'''  * that could be inside of it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box pivot box for subdivision into 4 rectangles, or</returns>
''' <param name="box"> \param[in]    box containing box; to be split by the pivot box</param>
''' <param name="boxa"> \param[in]    boxa boxes of rectangles, from which 1 is to be chosen</param>
''' <param name="maxperim"> \param[in]    maxperim maximum half-perimeter for which pivot</param>
''' <param name="fract"> \param[in]    fract fraction of box diagonal that is an acceptable</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaSelectPivotBox")> _
Friend Shared Function boxaSelectPivotBox(box as IntPTR, boxa as IntPTR, maxperim as Integer, fract as single) as IntPTR
End Function

' SRC\partition.c (62, 16)
' boxCheckIfOverlapIsBig()
' boxCheckIfOverlapIsBig(BOX *, BOXA *, l_float32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if box has small overlap with every box in boxa;</returns>
''' <param name="box"> \param[in]    box to be tested</param>
''' <param name="boxa"> \param[in]    boxa of boxes already stored</param>
''' <param name="maxoverlap"> \param[in]    maxoverlap maximum fractional overlap of the input box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxCheckIfOverlapIsBig")> _
Friend Shared Function boxCheckIfOverlapIsBig(box as IntPTR, boxa as IntPTR, maxoverlap as single) as Integer
End Function

' SRC\partition.c (189, 1)
' boxaGetWhiteblocks()
' boxaGetWhiteblocks(BOXA *, BOX *, l_int32, l_int32, l_float32, l_int32, l_float32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This uses the elegant Breuel algorithm, found in "Two
'''  * Geometric Algorithms for Layout Analysis", 2002,
'''  * url: "citeseer.ist.psu.edu/breuel02two.html".
'''  * It starts with the bounding boxes (b.b.) of the connected
'''  * components (c.c.) in a region, along with the rectangle
'''  * representing that region.  It repeatedly divides the
'''  * rectangle into four maximal rectangles that exclude a
'''  * pivot rectangle, sorting them in a priority queue
'''  * according to one of the six sort flags.  It returns a boxa
'''  * of the "largest" set that have no intersection with boxes
'''  * from the input boxas.
'''  *   (2) If box == NULL, the initial region is the minimal region
'''  * that includes the origin and every box in boxas.
'''  *   (3) maxboxes is the maximum number of whitespace boxes that will
'''  * be returned.  The actual number will depend on the image
'''  * and the values chosen for maxoverlap and maxpops.  In many
'''  * cases, the actual number will be 'maxboxes'.
'''  *   (4) maxoverlap allows pruning of whitespace boxes depending on
'''  * the overlap.  To avoid all pruning, use maxoverlap = 1.0.
'''  * To select only boxes that have no overlap with each other
'''  * (maximal pruning), choose maxoverlap = 0.0.
'''  * Otherwise, no box can have more than the 'maxoverlap' fraction
'''  * of its area overlapped by any larger (in the sense of the
'''  * sortflag) box.
'''  *   (5) Choose maxperim (actually, maximum half-perimeter) to
'''  * represent a c.c. that is small enough so that you don't care
'''  * about the white space that could be inside of it.  For all such
'''  * c.c., the pivot for 'quadfurcation' of a rectangle is selected
'''  * as having a reasonable proximity to the rectangle centroid.
'''  *   (6) Use fract in the range [0.0 ... 1.0].  Set fract = 0.0
'''  * to choose the small box nearest the centroid as the pivot.
'''  * If you choose fract > 0.0, it is suggested that you call
'''  * boxaPermuteRandom() first, to permute the boxes (see usage below).
'''  * This should reduce the search time for each of the pivot boxes.
'''  *   (7) Choose maxpops to be the maximum number of rectangles that
'''  * are popped from the heap.  This is an indirect way to limit the
'''  * execution time.  Use 0 for default (a fairly large number).
'''  * At any time, you can expect the heap to contain about
'''  * 2.5 times as many boxes as have been popped off.
'''  *   (8) The output result is a sorted set of overlapping
'''  * boxes, constrained by 'maxboxes', 'maxoverlap' and 'maxpops'.
'''  *   (9) The main defect of the method is that it abstracts out the
'''  * actual components, retaining only the b.b. for analysis.
'''  * Consider a component with a large b.b.  If this is chosen
'''  * as a pivot, all white space inside is immediately taken
'''  * out of consideration.  Furthermore, even if it is never chosen
'''  * as a pivot, as the partitioning continues, at no time will
'''  * any of the whitespace inside this component be part of a
'''  * rectangle with zero overlapping boxes.  Thus, the interiors
'''  * of all boxes are necessarily excluded from the union of
'''  * the returned whitespace boxes.
'''  *  (10) It should be noted that the algorithm puts a large number
'''  * of partels on the queue.  Setting a limit of X partels to
'''  * remove from the queue, one typically finds that there will be
'''  * several times that number (say, 2X - 3X) left on the queue.
'''  * For an efficient algorithm to find the largest white or
'''  * or black rectangles, without permitting them to overlap,
'''  * see pixFindLargeRectangles().
'''  *  (11) USAGE: One way to accommodate to this weakness is to remove such
'''  * large b.b. before starting the computation.  For example,
'''  * if 'box' is an input image region containing 'boxa' b.b. of c.c.:
'''  *
'''  *    // Faster pivot choosing
'''  *   boxaPermuteRandom(boxa, boxa);
'''  *
'''  *    // Remove anything either large width or height
'''  *   boxat = boxaSelectBySize(boxa, maxwidth, maxheight,
'''  *    L_SELECT_IF_BOTH, L_SELECT_IF_LT,
'''  *    NULL);
'''  *
'''  *   boxad = boxaGetWhiteblocks(boxat, box, type, maxboxes,
'''  *   maxoverlap, maxperim, fract,
'''  *   maxpops);
'''  *
'''  * The result will be rectangular regions of "white space" that
'''  * extend into (and often through) the excluded components.
'''  *  (11) As a simple example, suppose you wish to find the columns on a page.
'''  * First exclude large c.c. that may block the columns, and then call:
'''  *
'''  *   boxad = boxaGetWhiteblocks(boxa, box, L_SORT_BY_HEIGHT,
'''  *   20, 0.15, 200, 0.2, 2000);
'''  *
'''  * to get the 20 tallest boxes with no more than 0.15 overlap
'''  * between a box and any of the taller ones, and avoiding the
'''  * use of any c.c. with a b.b. half perimeter greater than 200
'''  * as a pivot.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa of sorted whitespace boxes, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas typically, a set of bounding boxes of fg components</param>
''' <param name="box"> \param[in]    box initial region; typically including all boxes in boxas;</param>
''' <param name="sortflag"> \param[in]    sortflag L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT,</param>
''' <param name="maxboxes"> \param[in]    maxboxes maximum number of output whitespace boxes; e.g., 100</param>
''' <param name="maxoverlap"> \param[in]    maxoverlap maximum fractional overlap of a box by any</param>
''' <param name="maxperim"> \param[in]    maxperim maximum half-perimeter, in pixels, for which</param>
''' <param name="fract"> \param[in]    fract fraction of box diagonal that is an acceptable</param>
''' <param name="maxpops"> \param[in]    maxpops maximum number of pops from the heap; use 0 as default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaGetWhiteblocks")> _
Friend Shared Function boxaGetWhiteblocks(boxas as IntPTR, box as IntPTR, sortflag as Integer, maxboxes as Integer, maxoverlap as single, maxperim as Integer, fract as single, maxpops as Integer) as IntPTR
End Function

' SRC\partition.c (621, 1)
' boxaPruneSortedOnOverlap()
' boxaPruneSortedOnOverlap(BOXA *, l_float32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This selectively removes smaller boxes when they are overlapped
'''  * by any larger box by more than the input 'maxoverlap' fraction.
'''  *   (2) To avoid all pruning, use maxoverlap = 1.0.  To select only
'''  * boxes that have no overlap with each other (maximal pruning),
'''  * set maxoverlap = 0.0.
'''  *   (3) If there are no boxes in boxas, returns an empty boxa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxad pruned, or NULL on error</returns>
''' <param name="boxas"> \param[in]    boxas sorted by size in decreasing order</param>
''' <param name="maxoverlap"> \param[in]    maxoverlap maximum fractional overlap of a box by any</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaPruneSortedOnOverlap")> _
Friend Shared Function boxaPruneSortedOnOverlap(boxas as IntPTR, maxoverlap as single) as IntPTR
End Function

#End Region
#Region "SRC\pdfio1.c"
' SRC\pdfio1.c (239, 1)
' convertFilesToPdf()
' convertFilesToPdf(const char *, const char *, l_int32, l_float32, l_int32, l_int32, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If %substr is not NULL, only image filenames that contain
'''  * the substring can be used.  If %substr == NULL, all files
'''  * in the directory are used.
'''  *   (2) The files in the directory, after optional filtering by
'''  * the substring, are lexically sorted in increasing order
'''  * before concatenation.
'''  *   (3) The scalefactor is applied to each image before encoding.
'''  * If you enter a value = 0.0, it will be set to 1.0.
'''  *   (4) Specifying one of the three encoding types for %type forces
'''  * all images to be compressed with that type.  Use 0 to have
'''  * the type determined for each image based on depth and whether
'''  * or not it has a colormap.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dirname"> \param[in]    dirname directory name containing images</param>
''' <param name="substr"> \param[in]    substr [optional] substring filter on filenames; can be NULL</param>
''' <param name="res"> \param[in]    res input resolution of all images</param>
''' <param name="scalefactor"> \param[in]    scalefactor scaling factor applied to each image; > 0.0</param>
''' <param name="type"> \param[in]    type encoding type (L_JPEG_ENCODE, L_G4_ENCODE,</param>
''' <param name="quality"> \param[in]    quality used for JPEG only; 0 for default (75)</param>
''' <param name="title"> \param[in]    title [optional] pdf title; if null, taken from the first</param>
''' <param name="fileout"> \param[in]    fileout pdf file of all images</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertFilesToPdf")> _
Friend Shared Function convertFilesToPdf(dirname as String, substr as String, res as Integer, scalefactor as single, type as Integer, quality as Integer, title as String, fileout as String) as Integer
End Function

' SRC\pdfio1.c (287, 1)
' saConvertFilesToPdf()
' saConvertFilesToPdf(SARRAY *, l_int32, l_float32, l_int32, l_int32, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See convertFilesToPdf().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa"> \param[in]    sa string array of pathnames for images</param>
''' <param name="res"> \param[in]    res input resolution of all images</param>
''' <param name="scalefactor"> \param[in]    scalefactor scaling factor applied to each image; > 0.0</param>
''' <param name="type"> \param[in]    type encoding type (L_JPEG_ENCODE, L_G4_ENCODE,</param>
''' <param name="quality"> \param[in]    quality used for JPEG only; 0 for default (75)</param>
''' <param name="title"> \param[in]    title [optional] pdf title; if null, taken from the first</param>
''' <param name="fileout"> \param[in]    fileout pdf file of all images</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="saConvertFilesToPdf")> _
Friend Shared Function saConvertFilesToPdf(sa as IntPTR, res as Integer, scalefactor as single, type as Integer, quality as Integer, title as String, fileout as String) as Integer
End Function

' SRC\pdfio1.c (340, 1)
' saConvertFilesToPdfData()
' saConvertFilesToPdfData(SARRAY *, l_int32, l_float32, l_int32, l_int32, const char *, l_uint8 **, size_t *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See convertFilesToPdf().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa"> \param[in]    sa string array of pathnames for images</param>
''' <param name="res"> \param[in]    res input resolution of all images</param>
''' <param name="scalefactor"> \param[in]    scalefactor scaling factor applied to each image; > 0.0</param>
''' <param name="type"> \param[in]    type encoding type (L_JPEG_ENCODE, L_G4_ENCODE,</param>
''' <param name="quality"> \param[in]    quality used for JPEG only; 0 for default (75)</param>
''' <param name="title"> \param[in]    title [optional] pdf title; if null, taken from the first</param>
''' <param name="pdata"> \param[out]   pdata output pdf data (of all images</param>
''' <param name="pnbytes"> \param[out]   pnbytes size of output pdf data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="saConvertFilesToPdfData")> _
Friend Shared Function saConvertFilesToPdfData(sa as IntPTR, res as Integer, scalefactor as single, type as Integer, quality as Integer, title as String, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\pdfio1.c (457, 1)
' selectDefaultPdfEncoding()
' selectDefaultPdfEncoding(PIX *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This attempts to choose an encoding for the pix that results
'''  * in the smallest file, assuming that if jpeg encoded, it will
'''  * use quality = 75.  The decision is approximate, in that
'''  * (a) all colormapped images will be losslessly encoded with
'''  * gzip (flate), and (b) an image with less than about 20 colors
'''  * is likely to be smaller if flate encoded than if encoded
'''  * as a jpeg (dct).  For example, an image made by pixScaleToGray3()
'''  * will have 10 colors, and flate encoding will give about
'''  * twice the compression as jpeg with quality = 75.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="ptype"> \param[out]   ptype L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selectDefaultPdfEncoding")> _
Friend Shared Function selectDefaultPdfEncoding(pix as IntPTR, ptype as Integer) as Integer
End Function

' SRC\pdfio1.c (520, 1)
' convertUnscaledFilesToPdf()
' convertUnscaledFilesToPdf(const char *, const char *, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If %substr is not NULL, only image filenames that contain
'''  * the substring can be used.  If %substr == NULL, all files
'''  * in the directory are used.
'''  *   (2) The files in the directory, after optional filtering by
'''  * the substring, are lexically sorted in increasing order
'''  * before concatenation.
'''  *   (3) For jpeg and jp2k, this is very fast because the compressed
'''  * data is wrapped up and concatenated.  For png and tiffg4,
'''  * the images must be read and recompressed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dirname"> \param[in]    dirname directory name containing images</param>
''' <param name="substr"> \param[in]    substr [optional] substring filter on filenames; can be NULL</param>
''' <param name="title"> \param[in]    title [optional] pdf title; if null, taken from the first</param>
''' <param name="fileout"> \param[in]    fileout pdf file of all images</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertUnscaledFilesToPdf")> _
Friend Shared Function convertUnscaledFilesToPdf(dirname as String, substr as String, title as String, fileout as String) as Integer
End Function

' SRC\pdfio1.c (558, 1)
' saConvertUnscaledFilesToPdf()
' saConvertUnscaledFilesToPdf(SARRAY *, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See convertUnscaledFilesToPdf().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa"> \param[in]    sa string array of pathnames for images</param>
''' <param name="title"> \param[in]    title [optional] pdf title; if null, taken from the first</param>
''' <param name="fileout"> \param[in]    fileout pdf file of all images</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="saConvertUnscaledFilesToPdf")> _
Friend Shared Function saConvertUnscaledFilesToPdf(sa as IntPTR, title as String, fileout as String) as Integer
End Function

' SRC\pdfio1.c (596, 1)
' saConvertUnscaledFilesToPdfData()
' saConvertUnscaledFilesToPdfData(SARRAY *, const char *, l_uint8 **, size_t *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa"> \param[in]    sa string array of pathnames for images</param>
''' <param name="title"> \param[in]    title [optional] pdf title; if null, taken from the first</param>
''' <param name="pdata"> \param[out]   pdata output pdf data (of all images)</param>
''' <param name="pnbytes"> \param[out]   pnbytes size of output pdf data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="saConvertUnscaledFilesToPdfData")> _
Friend Shared Function saConvertUnscaledFilesToPdfData(sa as IntPTR, title as String, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\pdfio1.c (668, 1)
' convertUnscaledToPdfData()
' convertUnscaledToPdfData(const char *, const char *, l_uint8 **, size_t *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fname"> \param[in]    fname of image file</param>
''' <param name="title"> \param[in]    title [optional] pdf title; can be NULL</param>
''' <param name="pdata"> \param[out]   pdata output pdf data for image</param>
''' <param name="pnbytes"> \param[out]   pnbytes size of output pdf data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertUnscaledToPdfData")> _
Friend Shared Function convertUnscaledToPdfData(fname as String, title as String, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\pdfio1.c (752, 1)
' pixaConvertToPdf()
' pixaConvertToPdf(PIXA *, l_int32, l_float32, l_int32, l_int32, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without
'''  * colormap and many colors, or 32 bpp; FLATE for anything else.
'''  *   (2) The scalefactor must be > 0.0; otherwise it is set to 1.0.
'''  *   (3) Specifying one of the three encoding types for %type forces
'''  * all images to be compressed with that type.  Use 0 to have
'''  * the type determined for each image based on depth and whether
'''  * or not it has a colormap.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa containing images all at the same resolution</param>
''' <param name="res"> \param[in]    res override the resolution of each input image, in ppi;</param>
''' <param name="scalefactor"> \param[in]    scalefactor scaling factor applied to each image; > 0.0</param>
''' <param name="type"> \param[in]    type encoding type (L_JPEG_ENCODE, L_G4_ENCODE,</param>
''' <param name="quality"> \param[in]    quality used for JPEG only; 0 for default (75)</param>
''' <param name="title"> \param[in]    title [optional] pdf title</param>
''' <param name="fileout"> \param[in]    fileout pdf file of all images</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaConvertToPdf")> _
Friend Shared Function pixaConvertToPdf(pixa as IntPTR, res as Integer, scalefactor as single, type as Integer, quality as Integer, title as String, fileout as String) as Integer
End Function

' SRC\pdfio1.c (804, 1)
' pixaConvertToPdfData()
' pixaConvertToPdfData(PIXA *, l_int32, l_float32, l_int32, l_int32, const char *, l_uint8 **, size_t *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See pixaConvertToPdf().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa containing images all at the same resolution</param>
''' <param name="res"> \param[in]    res input resolution of all images</param>
''' <param name="scalefactor"> \param[in]    scalefactor scaling factor applied to each image; > 0.0</param>
''' <param name="type"> \param[in]    type encoding type (L_JPEG_ENCODE, L_G4_ENCODE,</param>
''' <param name="quality"> \param[in]    quality used for JPEG only; 0 for default (75)</param>
''' <param name="title"> \param[in]    title [optional] pdf title</param>
''' <param name="pdata"> \param[out]   pdata output pdf data (of all images</param>
''' <param name="pnbytes"> \param[out]   pnbytes size of output pdf data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaConvertToPdfData")> _
Friend Shared Function pixaConvertToPdfData(pixa as IntPTR, res as Integer, scalefactor as single, type as Integer, quality as Integer, title as String, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\pdfio1.c (950, 1)
' convertToPdf()
' convertToPdf(const char *, l_int32, l_int32, const char *, l_int32, l_int32, l_int32, const char *, L_PDF_DATA **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) To wrap only one image in pdf, input %plpd = NULL, and
'''  * the value of %position will be ignored:
'''  *   convertToPdf(...  type, quality, x, y, res, NULL, 0);
'''  *   (2) To wrap multiple images on a single pdf page, this is called
'''  * once for each successive image.  Do it this way:
'''  *   L_PDF_DATA   *lpd;
'''  *   convertToPdf(...  type, quality, x, y, res, &lpd, L_FIRST_IMAGE);
'''  *   convertToPdf(...  type, quality, x, y, res, &lpd, L_NEXT_IMAGE);
'''  *   ...
'''  *   convertToPdf(...  type, quality, x, y, res, &lpd, L_LAST_IMAGE);
'''  * This will write the result to the value of %fileout specified
'''  * in the first call; succeeding values of %fileout are ignored.
'''  * On the last call: the pdf data bytes are computed and written
'''  * to %fileout, lpd is destroyed internally, and the returned
'''  * value of lpd is null.  So the client has nothing to clean up.
'''  *   (3) (a) Set %res == 0 to respect the resolution embedded in the
'''  *  image file.  If no resolution is embedded, it will be set
'''  *  to the default value.
'''  * (b) Set %res to some other value to override the file resolution.
'''  *   (4) (a) If the input %res and the resolution of the output device
'''  *  are equal, the image will be "displayed" at the same size
'''  *  as the original.
'''  * (b) If the input %res is 72, the output device will render
'''  *  the image at 1 pt/pixel.
'''  * (c) Some possible choices for the default input pix resolution are:
'''  *  72 ppi  Render pix on any output device at one pt/pixel
'''  *  96 ppi  Windows default for generated display images
'''  * 300 ppi  Typical default for scanned images.
'''  *  We choose 300, which is sensible for rendering page images.
'''  *  However,  images come from a variety of sources, and
'''  *  some are explicitly created for viewing on a display.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]      filein input image file -- any format</param>
''' <param name="type"> \param[in]      type L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
''' <param name="quality"> \param[in]      quality used for JPEG only; 0 for default (75)</param>
''' <param name="fileout"> \param[in]      fileout output pdf file; only required on last image on page</param>
''' <param name="x"> \param[in]      x, y location of lower-left corner of image, in pixels,</param>
''' <param name="y"> \param[in]      res override the resolution of the input image, in ppi;</param>
''' <param name="res"> \param[in]      title [optional] pdf title; if null, taken from filein</param>
''' <param name="title"> \param[in,out]  plpd ptr to lpd, which is created on the first invocation</param>
''' <param name="plpd"> \param[in]      position in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertToPdf")> _
Friend Shared Function convertToPdf(filein as String, type as Integer, quality as Integer, fileout as String, x as Integer, y as Integer, res as Integer, title as String, plpd as Object, position as Integer) as Integer
End Function

' SRC\pdfio1.c (1021, 1)
' convertImageDataToPdf()
' convertImageDataToPdf(l_uint8 *, size_t, l_int32, l_int32, const char *, l_int32, l_int32, l_int32, const char *, L_PDF_DATA **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If %res == 0 and the input resolution field is 0,
'''  * this will use DEFAULT_INPUT_RES.
'''  *   (2) See comments in convertToPdf().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="imdata"> \param[in]      imdata array of formatted image data; e.g., png, jpeg</param>
''' <param name="size"> \param[in]      size size of image data</param>
''' <param name="type"> \param[in]      type L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
''' <param name="quality"> \param[in]      quality used for JPEG only; 0 for default (75)</param>
''' <param name="fileout"> \param[in]      fileout output pdf file; only required on last image on page</param>
''' <param name="x"> \param[in]      x, y location of lower-left corner of image, in pixels,</param>
''' <param name="y"> \param[in]      res override the resolution of the input image, in ppi;</param>
''' <param name="res"> \param[in]      title [optional] pdf title</param>
''' <param name="title"> \param[in,out]  plpd ptr to lpd, which is created on the first invocation</param>
''' <param name="plpd"> \param[in]      position in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertImageDataToPdf")> _
Friend Shared Function convertImageDataToPdf(imdata as Byte, size as ULong, type as Integer, quality as Integer, fileout as String, x as Integer, y as Integer, res as Integer, title as String, plpd as Object, position as Integer) as Integer
End Function

' SRC\pdfio1.c (1086, 1)
' convertToPdfData()
' convertToPdfData(const char *, l_int32, l_int32, l_uint8 **, size_t *, l_int32, l_int32, l_int32, const char *, L_PDF_DATA **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If %res == 0 and the input resolution field is 0,
'''  * this will use DEFAULT_INPUT_RES.
'''  *   (2) See comments in convertToPdf().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]      filein input image file -- any format</param>
''' <param name="type"> \param[in]      type L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
''' <param name="quality"> \param[in]      quality used for JPEG only; 0 for default (75)</param>
''' <param name="pdata"> \param[out]     pdata pdf data in memory</param>
''' <param name="pnbytes"> \param[out]     pnbytes number of bytes in pdf data</param>
''' <param name="x"> \param[in]      x, y location of lower-left corner of image, in pixels,</param>
''' <param name="y"> \param[in]      res override the resolution of the input image, in ppi;</param>
''' <param name="res"> \param[in]      title [optional] pdf title; if null, use filein</param>
''' <param name="title"> \param[in,out]  plpd ptr to lpd, which is created on the first invocation</param>
''' <param name="plpd"> \param[in]      position in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertToPdfData")> _
Friend Shared Function convertToPdfData(filein as String, type as Integer, quality as Integer, pdata as Object, pnbytes as ULong, x as Integer, y as Integer, res as Integer, title as String, plpd as Object, position as Integer) as Integer
End Function

' SRC\pdfio1.c (1154, 1)
' convertImageDataToPdfData()
' convertImageDataToPdfData(l_uint8 *, size_t, l_int32, l_int32, l_uint8 **, size_t *, l_int32, l_int32, l_int32, const char *, L_PDF_DATA **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If %res == 0 and the input resolution field is 0,
'''  * this will use DEFAULT_INPUT_RES.
'''  *   (2) See comments in convertToPdf().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="imdata"> \param[in]    imdata array of formatted image data; e.g., png, jpeg</param>
''' <param name="size"> \param[in]    size size of image data</param>
''' <param name="type"> \param[in]    type L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
''' <param name="quality"> \param[in]    quality used for JPEG only; 0 for default (75)</param>
''' <param name="pdata"> \param[out]   pdata pdf data in memory</param>
''' <param name="pnbytes"> \param[out]   pnbytes number of bytes in pdf data</param>
''' <param name="x"> \param[in]    x, y location of lower-left corner of image, in pixels,</param>
''' <param name="y"> \param[in]    res override the resolution of the input image, in ppi;</param>
''' <param name="res"> \param[in]    title [optional] pdf title</param>
''' <param name="title"> \param[out]   plpd ptr to lpd, which is created on the first invocation</param>
''' <param name="plpd"> \param[in]    position in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertImageDataToPdfData")> _
Friend Shared Function convertImageDataToPdfData(imdata as Byte, size as ULong, type as Integer, quality as Integer, pdata as Object, pnbytes as ULong, x as Integer, y as Integer, res as Integer, title as String, plpd as Object, position as Integer) as Integer
End Function

' SRC\pdfio1.c (1223, 1)
' pixConvertToPdf()
' pixConvertToPdf(PIX *, l_int32, l_int32, const char *, l_int32, l_int32, l_int32, const char *, L_PDF_DATA **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If %res == 0 and the input resolution field is 0,
'''  * this will use DEFAULT_INPUT_RES.
'''  *   (2) This only writes data to fileout if it is the last
'''  * image to be written on the page.
'''  *   (3) See comments in convertToPdf().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]      pix</param>
''' <param name="type"> \param[in]      type L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
''' <param name="quality"> \param[in]      quality used for JPEG only; 0 for default (75)</param>
''' <param name="fileout"> \param[in]      fileout output pdf file; only required on last image on page</param>
''' <param name="x"> \param[in]      x, y location of lower-left corner of image, in pixels,</param>
''' <param name="y"> \param[in]      res override the resolution of the input image, in ppi;</param>
''' <param name="res"> \param[in]      title [optional] pdf title</param>
''' <param name="title"> \param[in,out]  plpd ptr to lpd, which is created on the first invocation</param>
''' <param name="plpd"> \param[in]      position in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertToPdf")> _
Friend Shared Function pixConvertToPdf(pix as IntPTR, type as Integer, quality as Integer, fileout as String, x as Integer, y as Integer, res as Integer, title as String, plpd as Object, position as Integer) as Integer
End Function

' SRC\pdfio1.c (1286, 1)
' pixWriteStreamPdf()
' pixWriteStreamPdf(FILE *, PIX *, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is the simplest interface for writing a single image
'''  * with pdf encoding to a stream.  It uses G4 encoding for 1 bpp,
'''  * JPEG encoding for 8 bpp (no cmap) and 32 bpp, and FLATE
'''  * encoding for everything else.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream opened for writing</param>
''' <param name="pix"> \param[in]    pix all depths, cmap OK</param>
''' <param name="res"> \param[in]    res override the resolution of the input image, in ppi;</param>
''' <param name="title"> \param[in]    title [optional] pdf title; taken from the first image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamPdf")> _
Friend Shared Function pixWriteStreamPdf(fp as Object, pix as IntPTR, res as Integer, title as String) as Integer
End Function

' SRC\pdfio1.c (1335, 1)
' pixWriteMemPdf()
' pixWriteMemPdf(l_uint8 **, size_t *, PIX *, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is the simplest interface for writing a single image
'''  * with pdf encoding to memory.  It uses G4 encoding for 1 bpp,
'''  * JPEG encoding for 8 bpp (no cmap) and 32 bpp, and FLATE
'''  * encoding for everything else.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata pdf as byte array</param>
''' <param name="pnbytes"> \param[out]   pnbytes number of bytes in pdf array</param>
''' <param name="pix"> \param[in]    pix all depths, cmap OK</param>
''' <param name="res"> \param[in]    res override the resolution of the input image, in ppi;</param>
''' <param name="title"> \param[in]    title [optional] pdf title; taken from the first image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMemPdf")> _
Friend Shared Function pixWriteMemPdf(pdata as Object, pnbytes as ULong, pix as IntPTR, res as Integer, title as String) as Integer
End Function

' SRC\pdfio1.c (1415, 1)
' convertSegmentedFilesToPdf()
' convertSegmentedFilesToPdf(const char *, const char *, l_int32, l_int32, l_int32, BOXAA *, l_int32, l_float32, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If %substr is not NULL, only image filenames that contain
'''  * the substring can be used.  If %substr == NULL, all files
'''  * in the directory are used.
'''  *   (2) The files in the directory, after optional filtering by
'''  * the substring, are lexically sorted in increasing order
'''  * before concatenation.
'''  *   (3) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without
'''  * colormap and many colors, or 32 bpp; FLATE for anything else.
'''  *   (4) The boxaa, if it exists, contains one boxa of "image regions"
'''  * for each image file.  The boxa must be aligned with the
'''  * sorted set of images.
'''  *   (5) The scalefactor is applied to each image region.  It is
'''  * typically  1.0, to save bytes in the final pdf, because
'''  * the resolution is often not critical in non-text regions.
'''  *   (6) If the non-image regions have pixel depth > 1 and the encoding
'''  * type is G4, they are automatically scaled up by 2x and
'''  * thresholded.  Otherwise, no scaling is performed on them.
'''  *   (7) Note that this function can be used to generate multipage
'''  * G4 compressed pdf from any input, by using %boxaa == NULL
'''  * and %type == L_G4_ENCODE.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dirname"> \param[in]    dirname directory name containing images</param>
''' <param name="substr"> \param[in]    substr [optional] substring filter on filenames; can be NULL</param>
''' <param name="res"> \param[in]    res input resolution of all images</param>
''' <param name="type"> \param[in]    type compression type for non-image regions; the</param>
''' <param name="thresh"> \param[in]    thresh used for converting gray --> 1 bpp with L_G4_ENCODE</param>
''' <param name="baa"> \param[in]    baa [optional] boxaa of image regions</param>
''' <param name="quality"> \param[in]    quality used for JPEG only; 0 for default (75)</param>
''' <param name="scalefactor"> \param[in]    scalefactor scaling factor applied to each image region</param>
''' <param name="title"> \param[in]    title [optional] pdf title; if null, taken from the first</param>
''' <param name="fileout"> \param[in]    fileout pdf file of all images</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertSegmentedFilesToPdf")> _
Friend Shared Function convertSegmentedFilesToPdf(dirname as String, substr as String, res as Integer, type as Integer, thresh as Integer, baa as IntPTR, quality as Integer, scalefactor as single, title as String, fileout as String) as Integer
End Function

' SRC\pdfio1.c (1535, 1)
' convertNumberedMasksToBoxaa()
' convertNumberedMasksToBoxaa(const char *, const char *, l_int32, l_int32) as BOXAA *
''' <summary>
''' * Notes:
'''  *   (1) This is conveniently used to generate the input boxaa
'''  * for convertSegmentedFilesToPdf().  It guarantees that the
'''  * boxa will be aligned with the page images, even if some
'''  * of the boxa are empty.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxaa of mask regions, or NULL on error</returns>
''' <param name="dirname"> \param[in]    dirname directory name containing mask images</param>
''' <param name="substr"> \param[in]    substr [optional] substring filter on filenames; can be NULL</param>
''' <param name="numpre"> \param[in]    numpre number of characters in name before number</param>
''' <param name="numpost"> \param[in]    numpost number of characters in name after number, up</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertNumberedMasksToBoxaa")> _
Friend Shared Function convertNumberedMasksToBoxaa(dirname as String, substr as String, numpre as Integer, numpost as Integer) as IntPTR
End Function

' SRC\pdfio1.c (1644, 1)
' convertToPdfSegmented()
' convertToPdfSegmented(const char *, l_int32, l_int32, l_int32, BOXA *, l_int32, l_float32, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If there are no image regions, set %boxa == NULL;
'''  * %quality and %scalefactor are ignored.
'''  *   (2) Typically, %scalefactor is  1.0, because the image regions
'''  * can be rendered at a lower resolution (for better compression)
'''  * than the text regions.  If %scalefactor == 0, we use 1.0.
'''  * If the input image is 1 bpp and scalefactor  1.0, we
'''  * use scaleToGray() to downsample the image regions to gray
'''  * before compressing them.
'''  *   (3) If the compression type for non-image regions is L_G4_ENCODE
'''  * and bpp > 1, the image is upscaled 2x and thresholded
'''  * to 1 bpp.  That is the only situation where %thresh is used.
'''  *   (4) The parameter %quality is only used for image regions.
'''  * If %type == L_JPEG_ENCODE, default jpeg quality (75) is
'''  * used for the non-image regions.
'''  *   (5) Processing matrix for non-image regions.
'''  *
'''  * Input  G4  JPEG FLATE
'''  * ----------|---------------------------------------------------
'''  * 1 bpp  |  1x, 1 bpp 1x flate, 1 bpp  1x, 1 bpp
'''  *  |
'''  * cmap   |  2x, 1 bpp 1x flate, cmap   1x, cmap
'''  *  |
'''  * 2,4 bpp   |  2x, 1 bpp 1x flate   1x, 2,4 bpp
'''  * no cmap   |   2,4 bpp
'''  *  |
'''  * 8,32 bpp  |  2x, 1 bpp 1x (jpeg)  1x, 8,32 bpp
'''  * no cmap   |   8,32 bpp
'''  *
'''  * Summary:
'''  * (a) if G4 is requested, G4 is used, with 2x upscaling
'''  *  for all cases except 1 bpp.
'''  * (b) if JPEG is requested, use flate encoding for all cases
'''  *  except 8 bpp without cmap and 32 bpp (rgb).
'''  * (c) if FLATE is requested, use flate with no transformation
'''  *  of the raster data.
'''  *   (6) Calling options/sequence for these functions:
'''  *  file  -->  file   (convertToPdfSegmented)
'''  *   pix  -->  file   (pixConvertToPdfSegmented)
'''  *    pix  -->  data   (pixConvertToPdfDataSegmented)
'''  *  file  -->  data   (convertToPdfDataSegmented)
'''  *    pix  -->  data   (pixConvertToPdfDataSegmented)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein input image file -- any format</param>
''' <param name="res"> \param[in]    res input image resolution; typ. 300 ppi; use 0 for default</param>
''' <param name="type"> \param[in]    type compression type for non-image regions; the</param>
''' <param name="thresh"> \param[in]    thresh used for converting gray --> 1 bpp with L_G4_ENCODE</param>
''' <param name="boxa"> \param[in]    boxa [optional] of image regions; can be null</param>
''' <param name="quality"> \param[in]    quality used for jpeg image regions; 0 for default</param>
''' <param name="scalefactor"> \param[in]    scalefactor used for jpeg regions; must be <= 1.0</param>
''' <param name="title"> \param[in]    title [optional] pdf title; typically taken from the</param>
''' <param name="fileout"> \param[in]    fileout output pdf file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertToPdfSegmented")> _
Friend Shared Function convertToPdfSegmented(filein as String, res as Integer, type as Integer, thresh as Integer, boxa as IntPTR, quality as Integer, scalefactor as single, title as String, fileout as String) as Integer
End Function

' SRC\pdfio1.c (1704, 1)
' pixConvertToPdfSegmented()
' pixConvertToPdfSegmented(PIX *, l_int32, l_int32, l_int32, BOXA *, l_int32, l_float32, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See convertToPdfSegmented() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth, cmap OK</param>
''' <param name="res"> \param[in]    res input image resolution; typ. 300 ppi; use 0 for default</param>
''' <param name="type"> \param[in]    type compression type for non-image regions; the</param>
''' <param name="thresh"> \param[in]    thresh used for converting gray --> 1 bpp with L_G4_ENCODE</param>
''' <param name="boxa"> \param[in]    boxa [optional] of image regions; can be null</param>
''' <param name="quality"> \param[in]    quality used for jpeg image regions; 0 for default</param>
''' <param name="scalefactor"> \param[in]    scalefactor used for jpeg regions; must be <= 1.0</param>
''' <param name="title"> \param[in]    title [optional] pdf title; typically taken from the</param>
''' <param name="fileout"> \param[in]    fileout output pdf file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertToPdfSegmented")> _
Friend Shared Function pixConvertToPdfSegmented(pixs as IntPTR, res as Integer, type as Integer, thresh as Integer, boxa as IntPTR, quality as Integer, scalefactor as single, title as String, fileout as String) as Integer
End Function

' SRC\pdfio1.c (1767, 1)
' convertToPdfDataSegmented()
' convertToPdfDataSegmented(const char *, l_int32, l_int32, l_int32, BOXA *, l_int32, l_float32, const char *, l_uint8 **, size_t *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If there are no image regions, set %boxa == NULL;
'''  * %quality and %scalefactor are ignored.
'''  *   (2) Typically, %scalefactor is  1.0.  The image regions are
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein input image file -- any format</param>
''' <param name="res"> \param[in]    res input image resolution; typ. 300 ppi; use 0 for default</param>
''' <param name="type"> \param[in]    type compression type for non-image regions; the</param>
''' <param name="thresh"> \param[in]    thresh used for converting gray --> 1 bpp with L_G4_ENCODE</param>
''' <param name="boxa"> \param[in]    boxa [optional] image regions; can be null</param>
''' <param name="quality"> \param[in]    quality used for jpeg image regions; 0 for default</param>
''' <param name="scalefactor"> \param[in]    scalefactor used for jpeg regions; must be <= 1.0</param>
''' <param name="title"> \param[in]    title [optional] pdf title; if null, uses filein</param>
''' <param name="pdata"> \param[out]   pdata pdf data in memory</param>
''' <param name="pnbytes"> \param[out]   pnbytes number of bytes in pdf data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertToPdfDataSegmented")> _
Friend Shared Function convertToPdfDataSegmented(filein as String, res as Integer, type as Integer, thresh as Integer, boxa as IntPTR, quality as Integer, scalefactor as single, title as String, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\pdfio1.c (1834, 1)
' pixConvertToPdfDataSegmented()
' pixConvertToPdfDataSegmented(PIX *, l_int32, l_int32, l_int32, BOXA *, l_int32, l_float32, const char *, l_uint8 **, size_t *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See convertToPdfSegmented() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth, cmap OK</param>
''' <param name="res"> \param[in]    res input image resolution; typ. 300 ppi; use 0 for default</param>
''' <param name="type"> \param[in]    type compression type for non-image regions; the</param>
''' <param name="thresh"> \param[in]    thresh used for converting gray --> 1 bpp with L_G4_ENCODE</param>
''' <param name="boxa"> \param[in]    boxa [optional] of image regions; can be null</param>
''' <param name="quality"> \param[in]    quality used for jpeg image regions; 0 for default</param>
''' <param name="scalefactor"> \param[in]    scalefactor used for jpeg regions; must be <= 1.0</param>
''' <param name="title"> \param[in]    title [optional] pdf title; typically taken from the</param>
''' <param name="pdata"> \param[out]   pdata pdf data in memory</param>
''' <param name="pnbytes"> \param[out]   pnbytes number of bytes in pdf data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertToPdfDataSegmented")> _
Friend Shared Function pixConvertToPdfDataSegmented(pixs as IntPTR, res as Integer, type as Integer, thresh as Integer, boxa as IntPTR, quality as Integer, scalefactor as single, title as String, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\pdfio1.c (1998, 1)
' concatenatePdf()
' concatenatePdf(const char *, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This only works with leptonica-formatted single-page pdf files.
'''  *   (2) If %substr is not NULL, only filenames that contain
'''  * the substring can be returned.  If %substr == NULL,
'''  * none of the filenames are filtered out.
'''  *   (3) The files in the directory, after optional filtering by
'''  * the substring, are lexically sorted in increasing order
'''  * before concatenation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dirname"> \param[in]    dirname directory name containing single-page pdf files</param>
''' <param name="substr"> \param[in]    substr [optional] substring filter on filenames; can be NULL</param>
''' <param name="fileout"> \param[in]    fileout concatenated pdf file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="concatenatePdf")> _
Friend Shared Function concatenatePdf(dirname as String, substr as String, fileout as String) as Integer
End Function

' SRC\pdfio1.c (2033, 1)
' saConcatenatePdf()
' saConcatenatePdf(SARRAY *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This only works with leptonica-formatted single-page pdf files.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa"> \param[in]    sa string array of pathnames for single-page pdf files</param>
''' <param name="fileout"> \param[in]    fileout concatenated pdf file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="saConcatenatePdf")> _
Friend Shared Function saConcatenatePdf(sa as IntPTR, fileout as String) as Integer
End Function

' SRC\pdfio1.c (2069, 1)
' ptraConcatenatePdf()
' ptraConcatenatePdf(L_PTRA *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This only works with leptonica-formatted single-page pdf files.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pa"> \param[in]    pa array of pdf strings, each for a single-page pdf file</param>
''' <param name="fileout"> \param[in]    fileout concatenated pdf file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraConcatenatePdf")> _
Friend Shared Function ptraConcatenatePdf(pa as IntPTR, fileout as String) as Integer
End Function

' SRC\pdfio1.c (2113, 1)
' concatenatePdfToData()
' concatenatePdfToData(const char *, const char *, l_uint8 **, size_t *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This only works with leptonica-formatted single-page pdf files.
'''  *   (2) If %substr is not NULL, only filenames that contain
'''  * the substring can be returned.  If %substr == NULL,
'''  * none of the filenames are filtered out.
'''  *   (3) The files in the directory, after optional filtering by
'''  * the substring, are lexically sorted in increasing order
'''  * before concatenation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dirname"> \param[in]    dirname directory name containing single-page pdf files</param>
''' <param name="substr"> \param[in]    substr [optional] substring filter on filenames; can be NULL</param>
''' <param name="pdata"> \param[out]   pdata concatenated pdf data in memory</param>
''' <param name="pnbytes"> \param[out]   pnbytes number of bytes in pdf data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="concatenatePdfToData")> _
Friend Shared Function concatenatePdfToData(dirname as String, substr as String, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\pdfio1.c (2154, 1)
' saConcatenatePdfToData()
' saConcatenatePdfToData(SARRAY *, l_uint8 **, size_t *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This only works with leptonica-formatted single-page pdf files.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa"> \param[in]    sa string array of pathnames for single-page pdf files</param>
''' <param name="pdata"> \param[out]   pdata concatenated pdf data in memory</param>
''' <param name="pnbytes"> \param[out]   pnbytes number of bytes in pdf data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="saConcatenatePdfToData")> _
Friend Shared Function saConcatenatePdfToData(sa as IntPTR, pdata as Object, pnbytes as ULong) as Integer
End Function

#End Region
#Region "SRC\pdfio2.c"
' SRC\pdfio2.c (105, 22)
' l_generateJp2kData()
' l_generateJp2kData(const char *) as L_COMP_DATA *
''' <summary>
''' * Notes:
'''  *   (1) This is only called after the file is verified to be jp2k.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cid containing jp2k data, or NULL on error</returns>
''' <param name="fname"> \param[in]    fname of jp2k file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_generateJp2kData")> _
Friend Shared Function l_generateJp2kData(fname as String) as IntPTR
End Function

' SRC\pdfio2.c (106, 22)
' pixGenerateFlateData()
' pixGenerateFlateData(PIX *, l_int32) as L_COMP_DATA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cid flate compressed image data, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="ascii85flag"> \param[in]    ascii85flag 0 for gzipped; 1 for ascii85-encoded gzipped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateFlateData")> _
Friend Shared Function pixGenerateFlateData(pixs as IntPTR, ascii85flag as Integer) as IntPTR
End Function

' SRC\pdfio2.c (107, 22)
' pixGenerateJpegData()
' pixGenerateJpegData(PIX *, l_int32, l_int32) as L_COMP_DATA *
''' <summary>
''' * Notes:
'''  *   (1) Set ascii85flag:
'''  *  ~ 0 for binary data (not permitted in PostScript)
'''  *  ~ 1 for ascii85 (5 for 4) encoded binary data
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cid jpeg compressed data, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 or 32 bpp, no colormap</param>
''' <param name="ascii85flag"> \param[in]    ascii85flag 0 for jpeg; 1 for ascii85-encoded jpeg</param>
''' <param name="quality"> \param[in]    quality 0 for default, which is 75</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateJpegData")> _
Friend Shared Function pixGenerateJpegData(pixs as IntPTR, ascii85flag as Integer, quality as Integer) as IntPTR
End Function

' SRC\pdfio2.c (109, 22)
' pixGenerateG4Data()
' pixGenerateG4Data(PIX *, l_int32) as L_COMP_DATA *
''' <summary>
''' * Notes:
'''  *   (1) Set ascii85flag:
'''  *  ~ 0 for binary data (not permitted in PostScript)
'''  *  ~ 1 for ascii85 (5 for 4) encoded binary data
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cid g4 compressed image data, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="ascii85flag"> \param[in]    ascii85flag 0 for gzipped; 1 for ascii85-encoded gzipped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateG4Data")> _
Friend Shared Function pixGenerateG4Data(pixs as IntPTR, ascii85flag as Integer) as IntPTR
End Function

' SRC\pdfio2.c (111, 22)
' l_generatePdf()
' l_generatePdf(l_uint8 **, size_t *, L_PDF_DATA *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) On error, no data is returned.
'''  *   (2) The objects are:
'''  *   1: Catalog
'''  *   2: Info
'''  *   3: Pages
'''  *   4: Page
'''  *   5: Contents  (rendering command)
'''  *   6 to 6+n-1: n XObjects
'''  *   6+n to 6+n+m-1: m colormaps
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata pdf array</param>
''' <param name="pnbytes"> \param[out]   pnbytes number of bytes in pdf array</param>
''' <param name="lpd"> \param[in]    lpd all the required input image data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_generatePdf")> _
Friend Shared Function l_generatePdf(pdata as Object, pnbytes as ULong, lpd as IntPTR) as Integer
End Function

' SRC\pdfio2.c (113, 22)
' 
' generateFixedStringsPdf(L_PDF_DATA *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generateFixedStringsPdf")> _
Friend Shared Function generateFixedStringsPdf(lpd as IntPTR) as Boolean ' Org. Void
End Function

' SRC\pdfio2.c (114, 22)
' generateEscapeString()
' generateEscapeString(const char *) as char *
''' <summary>
''' * Notes:
'''  *   (1) If the input string is not ascii, returns null.
'''  *   (2) This takes an input ascii string and generates a hex
'''  * ascii output string with 4 bytes out for each byte in.
'''  * The feff code at the beginning tells the pdf interpreter
'''  * that the data is to be interpreted as big-endian, 4 bytes
'''  * at a time.  For ascii, the first two bytes are 0 and the
'''  * last two bytes are less than 0x80.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   hex escape string, or null on error</returns>
''' <param name="str"> \param[in]   str   input string</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generateEscapeString")> _
Friend Shared Function generateEscapeString(str as String) as String
End Function

' SRC\pdfio2.c (115, 22)
' 
' generateMediaboxPdf(L_PDF_DATA *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generateMediaboxPdf")> _
Friend Shared Function generateMediaboxPdf(lpd as IntPTR) as Boolean ' Org. Void
End Function

' SRC\pdfio2.c (116, 22)
' 
' generatePageStringPdf(L_PDF_DATA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePageStringPdf")> _
Friend Shared Function generatePageStringPdf(lpd as IntPTR) as Integer
End Function

' SRC\pdfio2.c (117, 22)
' 
' generateContentStringPdf(L_PDF_DATA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generateContentStringPdf")> _
Friend Shared Function generateContentStringPdf(lpd as IntPTR) as Integer
End Function

' SRC\pdfio2.c (118, 22)
' 
' generatePreXStringsPdf(L_PDF_DATA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePreXStringsPdf")> _
Friend Shared Function generatePreXStringsPdf(lpd as IntPTR) as Integer
End Function

' SRC\pdfio2.c (119, 22)
' 
' generateColormapStringsPdf(L_PDF_DATA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generateColormapStringsPdf")> _
Friend Shared Function generateColormapStringsPdf(lpd as IntPTR) as Integer
End Function

' SRC\pdfio2.c (120, 22)
' 
' generateTrailerPdf(L_PDF_DATA *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generateTrailerPdf")> _
Friend Shared Function generateTrailerPdf(lpd as IntPTR) as Boolean ' Org. Void
End Function

' SRC\pdfio2.c (121, 22)
' 
' makeTrailerStringPdf(L_DNA *) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeTrailerStringPdf")> _
Friend Shared Function makeTrailerStringPdf(daloc as IntPTR) as String
End Function

' SRC\pdfio2.c (122, 22)
' generateOutputDataPdf()
' generateOutputDataPdf(l_uint8 **, size_t *, L_PDF_DATA *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Only called from l_generatePdf().  On error, no data is returned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata pdf data array</param>
''' <param name="pnbytes"> \param[out]   pnbytes size of pdf data array</param>
''' <param name="lpd"> \param[in]    lpd input data used to make pdf</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generateOutputDataPdf")> _
Friend Shared Function generateOutputDataPdf(pdata as Object, pnbytes as ULong, lpd as IntPTR) as Integer
End Function

' SRC\pdfio2.c (125, 22)
' parseTrailerPdf()
' parseTrailerPdf(L_BYTEA *, L_DNA **) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="bas"> \param[in]    bas lba of a pdf file</param>
''' <param name="pda"> \param[out]   pda byte locations of the beginning of each object</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="parseTrailerPdf")> _
Friend Shared Function parseTrailerPdf(bas as IntPTR, pda as Object) as Integer
End Function

' SRC\pdfio2.c (126, 22)
' 
' generatePagesObjStringPdf(NUMA *) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generatePagesObjStringPdf")> _
Friend Shared Function generatePagesObjStringPdf(napage as IntPTR) as String
End Function

' SRC\pdfio2.c (127, 22)
' substituteObjectNumbers()
' substituteObjectNumbers(L_BYTEA *, NUMA *) as L_BYTEA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="substituteObjectNumbers")> _
Friend Shared Function substituteObjectNumbers(bas as IntPTR, na_objs as IntPTR) as IntPTR
End Function

' SRC\pdfio2.c (129, 22)
' 
' pdfdataCreate(const char *) as L_PDF_DATA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pdfdataCreate")> _
Friend Shared Function pdfdataCreate(title as String) as IntPTR
End Function

' SRC\pdfio2.c (130, 22)
' 
' pdfdataDestroy(L_PDF_DATA **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pdfdataDestroy")> _
Friend Shared Function pdfdataDestroy(plpd as Object) as Boolean ' Org. Void
End Function

' SRC\pdfio2.c (131, 22)
' 
' pdfdataGetCid(L_PDF_DATA *, l_int32) as L_COMP_DATA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pdfdataGetCid")> _
Friend Shared Function pdfdataGetCid(lpd as IntPTR, index as Integer) as IntPTR
End Function

' SRC\pdfio2.c (182, 1)
' pixConvertToPdfData()
' pixConvertToPdfData(PIX *, l_int32, l_int32, l_uint8 **, size_t *, l_int32, l_int32, l_int32, const char *, L_PDF_DATA **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If %res == 0 and the input resolution field is 0,
'''  * this will use DEFAULT_INPUT_RES.
'''  *   (2) This only writes %data if it is the last image to be
'''  * written on the page.
'''  *   (3) See comments in convertToPdf().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]      pix all depths; cmap OK</param>
''' <param name="type"> \param[in]      type L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
''' <param name="quality"> \param[in]      quality used for JPEG only; 0 for default (75)</param>
''' <param name="pdata"> \param[out]     pdata pdf array</param>
''' <param name="pnbytes"> \param[out]     pnbytes number of bytes in pdf array</param>
''' <param name="x"> \param[in]      x, y location of lower-left corner of image, in pixels,</param>
''' <param name="y"> \param[in]      res override the resolution of the input image, in ppi;</param>
''' <param name="res"> \param[in]      title [optional] pdf title</param>
''' <param name="title"> \param[in,out]  plpd ptr to lpd, which is created on the first invocation</param>
''' <param name="plpd"> \param[in]      position in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertToPdfData")> _
Friend Shared Function pixConvertToPdfData(pix as IntPTR, type as Integer, quality as Integer, pdata as Object, pnbytes as ULong, x as Integer, y as Integer, res as Integer, title as String, plpd as Object, position as Integer) as Integer
End Function

' SRC\pdfio2.c (307, 1)
' ptraConcatenatePdfToData()
' ptraConcatenatePdfToData(L_PTRA *, SARRAY *, l_uint8 **, size_t *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This only works with leptonica-formatted single-page pdf files.
'''  * pdf files generated by other programs will have unpredictable
'''  * (and usually bad) results.  The requirements for each pdf file:
'''  *   (a) The Catalog and Info objects are the first two.
'''  *   (b) Object 3 is Pages
'''  *   (c) Object 4 is Page
'''  *   (d) The remaining objects are Contents, XObjects, and ColorSpace
'''  *   (2) We remove trailers from each page, and append the full trailer
'''  * for all pages at the end.
'''  *   (3) For all but the first file, remove the ID and the first 3
'''  * objects (catalog, info, pages), so that each subsequent
'''  * file has only objects of these classes:
'''  *  Page, Contents, XObject, ColorSpace (Indexed RGB).
'''  * For those objects, we substitute these refs to objects
'''  * in the local file:
'''  *  Page:  Parent(object 3), Contents, XObject(typically multiple)
'''  *  XObject:  [ColorSpace if indexed]
'''  * The Pages object on the first page (object 3) has a Kids array
'''  * of references to all the Page objects, with a Count equal
'''  * to the number of pages.  Each Page object refers back to
'''  * this parent.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pa_data"> \param[in]    pa_data ptra array of pdf strings, each for a single-page pdf file</param>
''' <param name="sa"> \param[in]    sa string array [optional] of pathnames for input pdf files</param>
''' <param name="pdata"> \param[out]   pdata concatenated pdf data in memory</param>
''' <param name="pnbytes"> \param[out]   pnbytes number of bytes in pdf data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraConcatenatePdfToData")> _
Friend Shared Function ptraConcatenatePdfToData(pa_data as IntPTR, sa as IntPTR, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\pdfio2.c (471, 1)
' convertTiffMultipageToPdf()
' convertTiffMultipageToPdf(const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) A multipage tiff file can also be converted to PS, using
'''  * convertTiffMultipageToPS()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein   (tiff)</param>
''' <param name="fileout"> \param[in]    fileout   (pdf)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertTiffMultipageToPdf")> _
Friend Shared Function convertTiffMultipageToPdf(filein as String, fileout as String) as Integer
End Function

' SRC\pdfio2.c (520, 1)
' l_generateCIDataForPdf()
' l_generateCIDataForPdf(const char *, PIX *, l_int32, L_COMP_DATA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) You must set either filename or pix.
'''  *   (2) Given an image file and optionally a pix raster of that data,
'''  * this provides a CID that is compatible with PDF, preferably
'''  * without transcoding.
'''  *   (3) The pix is included for efficiency, in case transcoding
'''  * is required and the pix is available to the caller.
'''  *   (4) We don't try to open files named "stdin" or "-" for Tesseract
'''  * compatibility reasons. We may remove this restriction
'''  * in the future.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fname"> \param[in]    fname [optional]; can be null</param>
''' <param name="pix"> \param[in]    pix [optional]; can be null</param>
''' <param name="quality"> \param[in]    quality for jpeg if transcoded; 75 is standard</param>
''' <param name="pcid"> \param[out]   pcid compressed data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_generateCIDataForPdf")> _
Friend Shared Function l_generateCIDataForPdf(fname as String, pix as IntPTR, quality as Integer, pcid as Object) as Integer
End Function

' SRC\pdfio2.c (598, 1)
' l_generateFlateDataPdf()
' l_generateFlateDataPdf(const char *, PIX *) as L_COMP_DATA *
''' <summary>
''' * Notes:
'''  *   (1) If you hand this a png file, you are going to get
'''  * png predictors embedded in the flate data. So it has
'''  * come to this. http://xkcd.com/1022/
'''  *   (2) Exception: if the png is interlaced or if it is RGBA,
'''  * it will be transcoded.
'''  *   (3) If transcoding is required, this will not have to read from
'''  * file if you also input a pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cid containing png data, or NULL on error</returns>
''' <param name="fname"> \param[in]    fname preferably png</param>
''' <param name="pixs"> \param[in]    pixs [optional]; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_generateFlateDataPdf")> _
Friend Shared Function l_generateFlateDataPdf(fname as String, pixs as IntPTR) as IntPTR
End Function

' SRC\pdfio2.c (795, 1)
' l_generateJpegData()
' l_generateJpegData(const char *, l_int32) as L_COMP_DATA *
''' <summary>
''' * Notes:
'''  *   (1) Set ascii85flag:
'''  *  ~ 0 for binary data (not permitted in PostScript)
'''  *  ~ 1 for ascii85 (5 for 4) encoded binary data
'''  *   (not permitted in pdf)
'''  *   (2) Do not free the data.  l_generateJpegDataMem() will free
'''  * the data if it does not use ascii encoding.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cid containing jpeg data, or NULL on error</returns>
''' <param name="fname"> \param[in]    fname of jpeg file</param>
''' <param name="ascii85flag"> \param[in]    ascii85flag 0 for jpeg; 1 for ascii85-encoded jpeg</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_generateJpegData")> _
Friend Shared Function l_generateJpegData(fname as String, ascii85flag as Integer) as IntPTR
End Function

' SRC\pdfio2.c (829, 1)
' l_generateJpegDataMem()
' l_generateJpegDataMem(l_uint8 *, size_t, l_int32) as L_COMP_DATA *
''' <summary>
''' * Notes:
'''  *   (1) See l_generateJpegData().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cid containing jpeg data, or NULL on error</returns>
''' <param name="data"> \param[in]    data     of jpeg file</param>
''' <param name="nbytes"> \param[in]    nbytes</param>
''' <param name="ascii85flag"> \param[in]    ascii85flag 0 for jpeg; 1 for ascii85-encoded jpeg</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_generateJpegDataMem")> _
Friend Shared Function l_generateJpegDataMem(data as Byte, nbytes as ULong, ascii85flag as Integer) as IntPTR
End Function

' SRC\pdfio2.c (943, 1)
' l_generateCIData()
' l_generateCIData(const char *, l_int32, l_int32, l_int32, L_COMP_DATA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This can be used for both PostScript and pdf.
'''  *   (1) Set ascii85:
'''  *  ~ 0 for binary data (not permitted in PostScript)
'''  *  ~ 1 for ascii85 (5 for 4) encoded binary data
'''  *   (2) This attempts to compress according to the requested type.
'''  * If this can't be done, it falls back to ordinary flate encoding.
'''  *   (3) This differs from l_generateCIDataPdf(), which determines
'''  * the format and attempts to generate the CID without transcoding.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fname"> \param[in]    fname</param>
''' <param name="type"> \param[in]    type L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE, L_JP2K_ENCODE</param>
''' <param name="quality"> \param[in]    quality used for jpeg only; 0 for default (75)</param>
''' <param name="ascii85"> \param[in]    ascii85 0 for binary; 1 for ascii85-encoded</param>
''' <param name="pcid"> \param[out]   pcid compressed data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_generateCIData")> _
Friend Shared Function l_generateCIData(fname as String, type as Integer, quality as Integer, ascii85 as Integer, pcid as Object) as Integer
End Function

' SRC\pdfio2.c (1039, 1)
' pixGenerateCIData()
' pixGenerateCIData(PIX *, l_int32, l_int32, l_int32, L_COMP_DATA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Set ascii85:
'''  *  ~ 0 for binary data (not permitted in PostScript)
'''  *  ~ 1 for ascii85 (5 for 4) encoded binary data
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 or 32 bpp, no colormap</param>
''' <param name="type"> \param[in]    type L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
''' <param name="quality"> \param[in]    quality used for jpeg only; 0 for default (75)</param>
''' <param name="ascii85"> \param[in]    ascii85 0 for binary; 1 for ascii85-encoded</param>
''' <param name="pcid"> \param[out]   pcid compressed data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateCIData")> _
Friend Shared Function pixGenerateCIData(pixs as IntPTR, type as Integer, quality as Integer, ascii85 as Integer, pcid as Object) as Integer
End Function

' SRC\pdfio2.c (1112, 1)
' l_generateFlateData()
' l_generateFlateData(const char *, l_int32) as L_COMP_DATA *
''' <summary>
''' * Notes:
'''  *   (1) The input image is converted to one of these 4 types:
'''  *  ~ 1 bpp
'''  *  ~ 8 bpp, no colormap
'''  *  ~ 8 bpp, colormap
'''  *  ~ 32 bpp rgb
'''  *   (2) Set ascii85flag:
'''  *  ~ 0 for binary data (not permitted in PostScript)
'''  *  ~ 1 for ascii85 (5 for 4) encoded binary data
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cid flate compressed image data, or NULL on error</returns>
''' <param name="fname"> \param[in]    fname</param>
''' <param name="ascii85flag"> \param[in]    ascii85flag 0 for gzipped; 1 for ascii85-encoded gzipped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_generateFlateData")> _
Friend Shared Function l_generateFlateData(fname as String, ascii85flag as Integer) as IntPTR
End Function

' SRC\pdfio2.c (1350, 1)
' l_generateG4Data()
' l_generateG4Data(const char *, l_int32) as L_COMP_DATA *
''' <summary>
''' * Notes:
'''  *   (1) Set ascii85flag:
'''  *  ~ 0 for binary data (not permitted in PostScript)
'''  *  ~ 1 for ascii85 (5 for 4) encoded binary data
'''  * (not permitted in pdf)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  cid g4 compressed image data, or NULL on error</returns>
''' <param name="fname"> \param[in]    fname of g4 compressed file</param>
''' <param name="ascii85flag"> \param[in]    ascii85flag 0 for g4 compressed; 1 for ascii85-encoded g4</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_generateG4Data")> _
Friend Shared Function l_generateG4Data(fname as String, ascii85flag as Integer) as IntPTR
End Function

' SRC\pdfio2.c (1427, 1)
' cidConvertToPdfData()
' cidConvertToPdfData(L_COMP_DATA *, const char *, l_uint8 **, size_t *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Caller must not destroy the cid.  It is absorbed in the
'''  * lpd and destroyed by this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cid"> \param[in]    cid compressed image data -- of jp2k image</param>
''' <param name="title"> \param[in]    title [optional] pdf title; can be NULL</param>
''' <param name="pdata"> \param[out]   pdata output pdf data for image</param>
''' <param name="pnbytes"> \param[out]   pnbytes size of output pdf data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="cidConvertToPdfData")> _
Friend Shared Function cidConvertToPdfData(cid as IntPTR, title as String, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\pdfio2.c (1476, 1)
' l_CIDataDestroy()
' l_CIDataDestroy(L_COMP_DATA **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pcid"> \param[in,out]   pcid will be set to null before returning</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_CIDataDestroy")> _
Friend Shared Function l_CIDataDestroy(pcid as Object) as Boolean ' Org. Void
End Function

' SRC\pdfio2.c (2438, 1)
' l_pdfSetG4ImageMask()
' l_pdfSetG4ImageMask(l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) The default is for writing only the fg (through the mask).
'''  * That way when you write a 1 bpp image, the bg is transparent,
'''  * so any previously written image remains visible behind it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="flag"> \param[in]    flag 1 for writing g4 data as fg only through a mask;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_pdfSetG4ImageMask")> _
Friend Shared Function l_pdfSetG4ImageMask(flag as Integer) as Boolean ' Org. Void
End Function

' SRC\pdfio2.c (2458, 1)
' l_pdfSetDateAndVersion()
' l_pdfSetDateAndVersion(l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) The default is for writing this data.  For regression tests
'''  * that compare output against golden files, it is useful to omit.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="flag"> \param[in]    flag 1 for writing date/time and leptonica version;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_pdfSetDateAndVersion")> _
Friend Shared Function l_pdfSetDateAndVersion(flag as Integer) as Boolean ' Org. Void
End Function

#End Region
#Region "SRC\pix1.c"
' SRC\pix1.c (195, 13)
' pixFree()
' pixFree(PIX *) as void
''' <summary>
''' * Notes:
'''  *   (1) Decrements the ref count and, if 0, destroys the pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pix"> \param[in]    pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFree")> _
Friend Shared Function pixFree(pix as IntPTR) as Boolean ' Org. Void
End Function

' SRC\pix1.c (231, 1)
' 
' pix_malloc(size_t) as void *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pix_malloc")> _
Friend Shared Function pix_malloc(size as ULong) as String
End Function

' SRC\pix1.c (243, 1)
' 
' pix_free(void *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pix_free")> _
Friend Shared Function pix_free(ptr as Object) as Boolean ' Org. Void
End Function

' SRC\pix1.c (282, 1)
' setPixMemoryManager()
' setPixMemoryManager(alloc_fn, dealloc_fn) as void
''' <summary>
''' * Notes:
'''  *   (1) Use this to change the alloc and/or dealloc functions;
'''  * e.g., setPixMemoryManager(my_malloc, my_free).
'''  *   (2) The C99 standard (section 6.7.5.3, par. 8) says:
'''  *   A declaration of a parameter as "function returning type"
'''  *   shall be adjusted to "pointer to function returning type"
'''  * so that it can be in either of these two forms:
'''  *   (a) type (function-ptr(type, ...))
'''  *   (b) type ((*function-ptr)(type, ...))
'''  * because form (a) is implictly converted to form (b), as in the
'''  * definition of struct PixMemoryManager above.  So, for example,
'''  * we should be able to declare either of these:
'''  *   (a) void *(allocator(size_t))
'''  *   (b) void *((*allocator)(size_t))
'''  * However, MSVC++ only accepts the second version.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="allocator"> \param[in]   allocator    [optional] use NULL to skip</param>
''' <param name="deallocator"> \param[in]   deallocator  [optional] use NULL to skip</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="setPixMemoryManager")> _
Friend Shared Function setPixMemoryManager(allocator as UInteger, deallocator as Object) as Boolean ' Org. Void
End Function

' SRC\pix1.c (302, 1)
' pixCreate()
' pixCreate(l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with data allocated and initialized to 0,</returns>
''' <param name="width"> \param[in]    width, height, depth</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCreate")> _
Friend Shared Function pixCreate(width as Integer, height as Integer, depth as Integer) as IntPTR
End Function

' SRC\pix1.c (331, 1)
' pixCreateNoInit()
' pixCreateNoInit(l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Must set pad bits to avoid reading uninitialized data, because
'''  * some optimized routines (e.g., pixConnComp()) read from pad bits.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with data allocated but not initialized,</returns>
''' <param name="width"> \param[in]    width, height, depth</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCreateNoInit")> _
Friend Shared Function pixCreateNoInit(width as Integer, height as Integer, depth as Integer) as IntPTR
End Function

' SRC\pix1.c (367, 1)
' pixCreateTemplate()
' pixCreateTemplate(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Makes a Pix of the same size as the input Pix, with the
'''  * data array allocated and initialized to 0.
'''  *   (2) Copies the other fields, including colormap if it exists.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCreateTemplate")> _
Friend Shared Function pixCreateTemplate(pixs as IntPTR) as IntPTR
End Function

' SRC\pix1.c (397, 1)
' pixCreateTemplateNoInit()
' pixCreateTemplateNoInit(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Makes a Pix of the same size as the input Pix, with
'''  * the data array allocated but not initialized to 0.
'''  *   (2) Copies the other fields, including colormap if it exists.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCreateTemplateNoInit")> _
Friend Shared Function pixCreateTemplateNoInit(pixs as IntPTR) as IntPTR
End Function

' SRC\pix1.c (439, 1)
' pixCreateHeader()
' pixCreateHeader(l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) It is assumed that all 32 bit pix have 3 spp.  If there is
'''  * a valid alpha channel, this will be set to 4 spp later.
'''  *   (2) If the number of bytes to be allocated is larger than the
'''  * maximum value in an int32, we can get overflow, resulting
'''  * in a smaller amount of memory actually being allocated.
'''  * Later, an attempt to access memory that wasn't allocated will
'''  * cause a crash.  So to avoid crashing a program (or worse)
'''  * with bad (or malicious) input, this is where we limit the
'''  * requested allocation of image data in a typesafe way.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with no data allocated, or NULL on error</returns>
''' <param name="width"> \param[in]    width, height, depth</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCreateHeader")> _
Friend Shared Function pixCreateHeader(width as Integer, height as Integer, depth as Integer) as IntPTR
End Function

' SRC\pix1.c (517, 1)
' pixClone()
' pixClone(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) A "clone" is simply a handle (ptr) to an existing pix.
'''  * It is implemented because (a) images can be large and
'''  * hence expensive to copy, and (b) extra handles to a data
'''  * structure need to be made with a simple policy to avoid
'''  * both double frees and memory leaks.  Pix are reference
'''  * counted.  The side effect of pixClone() is an increase
'''  * by 1 in the ref count.
'''  *   (2) The protocol to be used is:
'''  * (a) Whenever you want a new handle to an existing image,
'''  *  call pixClone(), which just bumps a ref count.
'''  * (b) Always call pixDestroy() on all handles.  This
'''  *  decrements the ref count, nulls the handle, and
'''  *  only destroys the pix when pixDestroy() has been
'''  *  called on all handles.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  same pix ptr, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixClone")> _
Friend Shared Function pixClone(pixs as IntPTR) as IntPTR
End Function

' SRC\pix1.c (545, 1)
' pixDestroy()
' pixDestroy(PIX **) as void
''' <summary>
''' * Notes:
'''  *   (1) Decrements the ref count and, if 0, destroys the pix.
'''  *   (2) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="ppix"> \param[in,out]   ppix will be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDestroy")> _
Friend Shared Function pixDestroy(ppix as Object) as Boolean ' Org. Void
End Function

' SRC\pix1.c (630, 1)
' pixCopy()
' pixCopy(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) There are three cases:
'''  *   (a) pixd == null  (makes a new pix; refcount = 1)
'''  *   (b) pixd == pixs  (no-op)
'''  *   (c) pixd != pixs  (data copy; no change in refcount)
'''  * If the refcount of pixd > 1, case (c) will side-effect
'''  * these handles.
'''  *   (2) The general pattern of use is:
'''  * pixd = pixCopy(pixd, pixs);
'''  * This will work for all three cases.
'''  * For clarity when the case is known, you can use:
'''  *   (a) pixd = pixCopy(NULL, pixs);
'''  *   (c) pixCopy(pixd, pixs);
'''  *   (3) For case (c), we check if pixs and pixd are the same
'''  * size (w,h,d).  If so, the data is copied directly.
'''  * Otherwise, the data is reallocated to the correct size
'''  * and the copy proceeds.  The refcount of pixd is unchanged.
'''  *   (4) This operation, like all others that may involve a pre-existing
'''  * pixd, will side-effect any existing clones of pixd.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd   [optional] can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCopy")> _
Friend Shared Function pixCopy(pixd as IntPTR, pixs as IntPTR) as IntPTR
End Function

' SRC\pix1.c (698, 1)
' pixResizeImageData()
' pixResizeImageData(PIX *, PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If the sizes of data in pixs and pixd are unequal, this
'''  * frees the existing image data in pixd and allocates
'''  * an uninitialized buffer that will hold the required amount
'''  * of image data in pixs.  The image data from pixs is not
'''  * copied into the new buffer.
'''  *   (2) On failure to allocate, pixd is unchanged.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixd"> \param[in]   pixd   gets new uninitialized buffer for image data</param>
''' <param name="pixs"> \param[in]   pixs   determines the size of the buffer; not changed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixResizeImageData")> _
Friend Shared Function pixResizeImageData(pixd as IntPTR, pixs as IntPTR) as Integer
End Function

' SRC\pix1.c (747, 1)
' pixCopyColormap()
' pixCopyColormap(PIX *, PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This always destroys any colormap in pixd (except if
'''  * the operation is a no-op.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixd"> \param[in]   pixd</param>
''' <param name="pixs"> \param[in]   pixs   copies the colormap to %pixd</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCopyColormap")> _
Friend Shared Function pixCopyColormap(pixd as IntPTR, pixs as IntPTR) as Integer
End Function

' SRC\pix1.c (780, 1)
' pixSizesEqual()
' pixSizesEqual(PIX *, PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if the two pix have same {h, w, d}; 0 otherwise.</returns>
''' <param name="pix1"> \param[in]    pix1, pix2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSizesEqual")> _
Friend Shared Function pixSizesEqual(pix1 as IntPTR, pix2 as IntPTR) as Integer
End Function

' SRC\pix1.c (854, 1)
' pixTransferAllData()
' pixTransferAllData(PIX *, PIX **, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does a complete data transfer from pixs to pixd,
'''  * followed by the destruction of pixs (refcount permitting).
'''  *   (2) If the refcount of pixs is 1, pixs is destroyed.  Otherwise,
'''  * the data in pixs is copied (rather than transferred) to pixd.
'''  *   (3) This operation, like all others with a pre-existing pixd,
'''  * will side-effect any existing clones of pixd.  The pixd
'''  * refcount does not change.
'''  *   (4) When might you use this?  Suppose you have an in-place Pix
'''  * function (returning void) with the typical signature:
'''  *  void function-inplace(PIX *pix, ...)
'''  * where "..." are non-pointer input parameters, and suppose
'''  * further that you sometimes want to return an arbitrary Pix
'''  * in place of the input Pix.  There are two ways you can do this:
'''  * (a) The straightforward way is to change the function
'''  *  signature to take the address of the Pix ptr:
'''  * \code
'''  *   void function-inplace(PIX **ppix, ...) {
'''  *    PIX *pixt = function-makenew(*ppix);
'''  *    pixDestroy(ppix);
'''  *    *ppix = pixt;
'''  *    return;
'''  *   }
'''  * \endcode
'''  *  Here, the input and returned pix are different, as viewed
'''  *  by the calling function, and the inplace function is
'''  *  expected to destroy the input pix to avoid a memory leak.
'''  * (b) Keep the signature the same and use pixTransferAllData()
'''  *  to return the new Pix in the input Pix struct:
'''  * \code
'''  *   void function-inplace(PIX *pix, ...) {
'''  *    PIX *pixt = function-makenew(pix);
'''  *    pixTransferAllData(pix, &pixt, 0, 0);
'''  *    // pixDestroy() is called on pixt
'''  *    return;
'''  *   }
'''  * \endcode
'''  *  Here, the input and returned pix are the same, as viewed
'''  *  by the calling function, and the inplace function must
'''  *  never destroy the input pix, because the calling function
'''  *  maintains an unchanged handle to it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixd"> \param[in]      pixd        must be different from pixs</param>
''' <param name="ppixs"> \param[in,out]  ppixs       will be nulled if refcount goes to 0</param>
''' <param name="copytext"> \param[in]      copytext    1 to copy the text field; 0 to skip</param>
''' <param name="copyformat"> \param[in]      copyformat  1 to copy the informat field; 0 to skip</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTransferAllData")> _
Friend Shared Function pixTransferAllData(pixd as IntPTR, ppixs as Object, copytext as Integer, copyformat as Integer) as Integer
End Function

' SRC\pix1.c (944, 1)
' pixSwapAndDestroy()
' pixSwapAndDestroy(PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Simple operation to change the handle name safely.
'''  * After this operation, the original image in pixd has
'''  * been destroyed, pixd points to what was pixs, and
'''  * the input pixs ptr has been nulled.
'''  *   (2) This works safely whether or not pixs and pixd are cloned.
'''  * If pixs is cloned, the other handles still point to
'''  * the original image, with the ref count reduced by 1.
'''  *   (3) Usage example:
'''  * \code
'''  *   Pix *pix1 = pixRead("...");
'''  *   Pix *pix2 = function(pix1, ...);
'''  *   pixSwapAndDestroy(&pix1, &pix2);
'''  *   pixDestroy(&pix1);  // holds what was in pix2
'''  * \endcode
'''  * Example with clones ([] shows ref count of image generated
'''  *    by the function):
'''  * \code
'''  *   Pix *pixs = pixRead("...");
'''  *   Pix *pix1 = pixClone(pixs);
'''  *   Pix *pix2 = function(pix1, ...);   [1]
'''  *   Pix *pix3 = pixClone(pix2);   [1] --> [2]
'''  *   pixSwapAndDestroy(&pix1, &pix2);
'''  *   pixDestroy(&pixs);  // still holds read image
'''  *   pixDestroy(&pix1);  // holds what was in pix2  [2] --> [1]
'''  *   pixDestroy(&pix3);  // holds what was in pix2  [1] --> [0]
'''  * \endcode
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ppixd"> \param[out]     ppixd   [optional] input pixd can be null,</param>
''' <param name="ppixs"> \param[in,out]  ppixs   will be nulled after the swap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSwapAndDestroy")> _
Friend Shared Function pixSwapAndDestroy(ppixd as Object, ppixs as Object) as Integer
End Function

' SRC\pix1.c (969, 1)
' 
' pixGetWidth(PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetWidth")> _
Friend Shared Function pixGetWidth(pix as IntPTR) as Integer
End Function

' SRC\pix1.c (981, 1)
' 
' pixSetWidth(PIX *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetWidth")> _
Friend Shared Function pixSetWidth(pix as IntPTR, width as Integer) as Integer
End Function

' SRC\pix1.c (999, 1)
' 
' pixGetHeight(PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetHeight")> _
Friend Shared Function pixGetHeight(pix as IntPTR) as Integer
End Function

' SRC\pix1.c (1011, 1)
' 
' pixSetHeight(PIX *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetHeight")> _
Friend Shared Function pixSetHeight(pix as IntPTR, height as Integer) as Integer
End Function

' SRC\pix1.c (1029, 1)
' 
' pixGetDepth(PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetDepth")> _
Friend Shared Function pixGetDepth(pix as IntPTR) as Integer
End Function

' SRC\pix1.c (1041, 1)
' 
' pixSetDepth(PIX *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetDepth")> _
Friend Shared Function pixSetDepth(pix as IntPTR, depth as Integer) as Integer
End Function

' SRC\pix1.c (1064, 1)
' pixGetDimensions()
' pixGetDimensions(PIX *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="pw"> \param[out]   pw, ph, pd    [optional] each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetDimensions")> _
Friend Shared Function pixGetDimensions(pix as IntPTR, pw as Integer, ph as Integer, pd as Integer) as Integer
End Function

' SRC\pix1.c (1091, 1)
' pixSetDimensions()
' pixSetDimensions(PIX *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="w"> \param[in]    w, h, d   use 0 to skip the setting for any of these</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetDimensions")> _
Friend Shared Function pixSetDimensions(pix as IntPTR, w as Integer, h as Integer, d as Integer) as Integer
End Function

' SRC\pix1.c (1115, 1)
' pixCopyDimensions()
' pixCopyDimensions(PIX *, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixd"> \param[in]   pixd</param>
''' <param name="pixs"> \param[in]   pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCopyDimensions")> _
Friend Shared Function pixCopyDimensions(pixd as IntPTR, pixs as IntPTR) as Integer
End Function

' SRC\pix1.c (1136, 1)
' 
' pixGetSpp(PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetSpp")> _
Friend Shared Function pixGetSpp(pix as IntPTR) as Integer
End Function

' SRC\pix1.c (1164, 1)
' 
' pixSetSpp(PIX *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetSpp")> _
Friend Shared Function pixSetSpp(pix as IntPTR, spp as Integer) as Integer
End Function

' SRC\pix1.c (1187, 1)
' pixCopySpp()
' pixCopySpp(PIX *, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixd"> \param[in]   pixd</param>
''' <param name="pixs"> \param[in]   pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCopySpp")> _
Friend Shared Function pixCopySpp(pixd as IntPTR, pixs as IntPTR) as Integer
End Function

' SRC\pix1.c (1205, 1)
' 
' pixGetWpl(PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetWpl")> _
Friend Shared Function pixGetWpl(pix as IntPTR) as Integer
End Function

' SRC\pix1.c (1216, 1)
' 
' pixSetWpl(PIX *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetWpl")> _
Friend Shared Function pixSetWpl(pix as IntPTR, wpl as Integer) as Integer
End Function

' SRC\pix1.c (1230, 1)
' 
' pixGetRefcount(PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRefcount")> _
Friend Shared Function pixGetRefcount(pix as IntPTR) as Integer
End Function

' SRC\pix1.c (1241, 1)
' 
' pixChangeRefcount(PIX *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixChangeRefcount")> _
Friend Shared Function pixChangeRefcount(pix as IntPTR, delta as Integer) as Integer
End Function

' SRC\pix1.c (1255, 1)
' 
' pixGetXRes(PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetXRes")> _
Friend Shared Function pixGetXRes(pix as IntPTR) as Integer
End Function

' SRC\pix1.c (1266, 1)
' 
' pixSetXRes(PIX *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetXRes")> _
Friend Shared Function pixSetXRes(pix as IntPTR, res as Integer) as Integer
End Function

' SRC\pix1.c (1280, 1)
' 
' pixGetYRes(PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetYRes")> _
Friend Shared Function pixGetYRes(pix as IntPTR) as Integer
End Function

' SRC\pix1.c (1291, 1)
' 
' pixSetYRes(PIX *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetYRes")> _
Friend Shared Function pixSetYRes(pix as IntPTR, res as Integer) as Integer
End Function

' SRC\pix1.c (1312, 1)
' pixGetResolution()
' pixGetResolution(PIX *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="pxres"> \param[out]   pxres, pyres   [optional] each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetResolution")> _
Friend Shared Function pixGetResolution(pix as IntPTR, pxres as Integer, pyres as Integer) as Integer
End Function

' SRC\pix1.c (1338, 1)
' pixSetResolution()
' pixSetResolution(PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]   pix</param>
''' <param name="xres"> \param[in]   xres, yres   use 0 to skip setting a value for either of these</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetResolution")> _
Friend Shared Function pixSetResolution(pix as IntPTR, xres as Integer, yres as Integer) as Integer
End Function

' SRC\pix1.c (1353, 1)
' 
' pixCopyResolution(PIX *, PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCopyResolution")> _
Friend Shared Function pixCopyResolution(pixd as IntPTR, pixs as IntPTR) as Integer
End Function

' SRC\pix1.c (1372, 1)
' 
' pixScaleResolution(PIX *, l_float32, l_float32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleResolution")> _
Friend Shared Function pixScaleResolution(pix as IntPTR, xscale as single, yscale as single) as Integer
End Function

' SRC\pix1.c (1390, 1)
' 
' pixGetInputFormat(PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetInputFormat")> _
Friend Shared Function pixGetInputFormat(pix as IntPTR) as Integer
End Function

' SRC\pix1.c (1401, 1)
' 
' pixSetInputFormat(PIX *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetInputFormat")> _
Friend Shared Function pixSetInputFormat(pix as IntPTR, informat as Integer) as Integer
End Function

' SRC\pix1.c (1414, 1)
' 
' pixCopyInputFormat(PIX *, PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCopyInputFormat")> _
Friend Shared Function pixCopyInputFormat(pixd as IntPTR, pixs as IntPTR) as Integer
End Function

' SRC\pix1.c (1432, 1)
' 
' pixSetSpecial(PIX *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetSpecial")> _
Friend Shared Function pixSetSpecial(pix as IntPTR, special as Integer) as Integer
End Function

' SRC\pix1.c (1457, 1)
' pixGetText()
' pixGetText(PIX *) as char *
''' <summary>
''' * Notes:
'''  *   (1) The text string belongs to the pix.  The caller must
'''  * NOT free it!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to existing text string</returns>
''' <param name="pix"> \param[in]   pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetText")> _
Friend Shared Function pixGetText(pix as IntPTR) as String
End Function

' SRC\pix1.c (1481, 1)
' pixSetText()
' pixSetText(PIX *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This removes any existing textstring and puts a copy of
'''  * the input textstring there.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]   pix</param>
''' <param name="textstring"> \param[in]   textstring   can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetText")> _
Friend Shared Function pixSetText(pix as IntPTR, textstring as String) as Integer
End Function

' SRC\pix1.c (1509, 1)
' pixAddText()
' pixAddText(PIX *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This adds the new textstring to any existing text.
'''  *   (2) Either or both the existing text and the new text
'''  * string can be null.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="textstring"> \param[in]    textstring   can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddText")> _
Friend Shared Function pixAddText(pix as IntPTR, textstring as String) as Integer
End Function

' SRC\pix1.c (1527, 1)
' 
' pixCopyText(PIX *, PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCopyText")> _
Friend Shared Function pixCopyText(pixd as IntPTR, pixs as IntPTR) as Integer
End Function

' SRC\pix1.c (1545, 1)
' 
' pixGetColormap(PIX *) as PIXCMAP *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetColormap")> _
Friend Shared Function pixGetColormap(pix as IntPTR) as IntPTR
End Function

' SRC\pix1.c (1571, 1)
' pixSetColormap()
' pixSetColormap(PIX *, PIXCMAP *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Unlike with the pix data field, pixSetColormap() destroys
'''  * any existing colormap before assigning the new one.
'''  * Because colormaps are not ref counted, it is important that
'''  * the new colormap does not belong to any other pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="pix"> \param[in]   pix</param>
''' <param name="colormap"> \param[in]   colormap   to be assigned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetColormap")> _
Friend Shared Function pixSetColormap(pix as IntPTR, colormap as IntPTR) as Integer
End Function

' SRC\pix1.c (1592, 1)
' pixDestroyColormap()
' pixDestroyColormap(PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]   pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDestroyColormap")> _
Friend Shared Function pixDestroyColormap(pix as IntPTR) as Integer
End Function

' SRC\pix1.c (1622, 1)
' pixGetData()
' pixGetData(PIX *) as l_uint32 *
''' <summary>
''' * Notes:
'''  *   (1) This gives a new handle for the data.  The data is still
'''  * owned by the pix, so do not call LEPT_FREE() on it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to image data</returns>
''' <param name="pix"> \param[in]    pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetData")> _
Friend Shared Function pixGetData(pix as IntPTR) as String
End Function

' SRC\pix1.c (1646, 1)
' pixSetData()
' pixSetData(PIX *, l_uint32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This does not free any existing data.  To free existing
'''  * data, use pixFreeData() before pixSetData().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]   pix</param>
''' <param name="data"> \param[in]   data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetData")> _
Friend Shared Function pixSetData(pix as IntPTR, data as UInteger) as Integer
End Function

' SRC\pix1.c (1676, 1)
' pixExtractData()
' pixExtractData(PIX *) as l_uint32 *
''' <summary>
''' * Notes:
'''  *   (1) This extracts the pix image data for use in another context.
'''  * The caller still needs to use pixDestroy() on the input pix.
'''  *   (2) If refcount == 1, the data is extracted and the
'''  * pix->data ptr is set to NULL.
'''  *   (3) If refcount > 1, this simply returns a copy of the data,
'''  * using the pix allocator, and leaving the input pix unchanged.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to data, or null on error</returns>
''' <param name="pixs"> \param[in]   pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExtractData")> _
Friend Shared Function pixExtractData(pixs as IntPTR) as String
End Function

' SRC\pix1.c (1717, 1)
' pixFreeData()
' pixFreeData(PIX *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This frees the data and sets the pix data ptr to null.
'''  * It should be used before pixSetData() in the situation where
'''  * you want to free any existing data before doing
'''  * a subsequent assignment with pixSetData().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]   pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFreeData")> _
Friend Shared Function pixFreeData(pix as IntPTR) as Integer
End Function

' SRC\pix1.c (1808, 1)
' pixGetLinePtrs()
' pixGetLinePtrs(PIX *, l_int32 *) as void **
''' <summary>
''' * Notes:
'''  *   (1) This is intended to be used for fast random pixel access.
'''  * For example, for an 8 bpp image,
'''  *  val = GET_DATA_BYTE(lines8[i], j);
'''  * is equivalent to, but much faster than,
'''  *  pixGetPixel(pix, j, i, &val);
'''  *   (2) How much faster?  For 1 bpp, it's from 6 to 10x faster.
'''  * For 8 bpp, it's an amazing 30x faster.  So if you are
'''  * doing random access over a substantial part of the image,
'''  * use this line ptr array.
'''  *   (3) When random access is used in conjunction with a stack,
'''  * queue or heap, the overall computation time depends on
'''  * the operations performed on each struct that is popped
'''  * or pushed, and whether we are using a priority queue (O(logn))
'''  * or a queue or stack (O(1)).  For example, for maze search,
'''  * the overall ratio of time for line ptrs vs. pixGet/Set* is
'''  * Maze type  Type    Time ratio
'''  *   binary   queue   0.4
'''  *   gray  heap (priority queue)  0.6
'''  *   (4) Because this returns a void** and the accessors take void*,
'''  * the compiler cannot check the pointer types.  It is
'''  * strongly recommended that you adopt a naming scheme for
'''  * the returned ptr arrays that indicates the pixel depth.
'''  * (This follows the original intent of Simonyi's "Hungarian"
'''  * application notation, where naming is used proactively
'''  * to make errors visibly obvious.)  By doing this, you can
'''  * tell by inspection if the correct accessor is used.
'''  * For example, for an 8 bpp pixg:
'''  *  void **lineg8 = pixGetLinePtrs(pixg, NULL);
'''  *  val = GET_DATA_BYTE(lineg8[i], j);  // fast access; BYTE, 8
'''  *  ...
'''  *  LEPT_FREE(lineg8);  // don't forget this
'''  *   (5) These are convenient for accessing bytes sequentially in an
'''  * 8 bpp grayscale image.  People who write image processing code
'''  * on 8 bpp images are accustomed to grabbing pixels directly out
'''  * of the raster array.  Note that for little endians, you first
'''  * need to reverse the byte order in each 32-bit word.
'''  * Here's a typical usage pattern:
'''  *  pixEndianByteSwap(pix);   // always safe; no-op on big-endians
'''  *  l_uint8 **lineptrs = (l_uint8 **)pixGetLinePtrs(pix, NULL);
'''  *  pixGetDimensions(pix, &w, &h, NULL);
'''  *  for (i = 0; i  h; i++) {
'''  *   l_uint8 *line = lineptrs[i];
'''  *   for (j = 0; j  w; j++) {
'''  *    val = line[j];
'''  *    ...
'''  *   }
'''  *  }
'''  *  pixEndianByteSwap(pix);  // restore big-endian order
'''  *  LEPT_FREE(lineptrs);
'''  * This can be done even more simply as follows:
'''  *  l_uint8 **lineptrs = pixSetupByteProcessing(pix, &w, &h);
'''  *  for (i = 0; i  h; i++) {
'''  *   l_uint8 *line = lineptrs[i];
'''  *   for (j = 0; j  w; j++) {
'''  *    val = line[j];
'''  *    ...
'''  *   }
'''  *  }
'''  *  pixCleanupByteProcessing(pix, lineptrs);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  array of line ptrs, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="psize"> \param[out]   psize   [optional] array size, which is the pix height</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetLinePtrs")> _
Friend Shared Function pixGetLinePtrs(pix as IntPTR, psize as Integer) as String
End Function

' SRC\pix1.c (1848, 1)
' pixPrintStreamInfo()
' pixPrintStreamInfo(FILE *, PIX *, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp    file stream</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="text"> \param[in]    text  [optional] identifying string; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixPrintStreamInfo")> _
Friend Shared Function pixPrintStreamInfo(fp as Object, pix as IntPTR, text as String) as Integer
End Function

#End Region
#Region "SRC\pix2.c"
' SRC\pix2.c (180, 1)
' pixGetPixel()
' pixGetPixel(PIX *, l_int32, l_int32, l_uint32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This returns the value in the data array.  If the pix is
'''  * colormapped, it returns the colormap index, not the rgb value.
'''  *   (2) Because of the function overhead and the parameter checking,
'''  * this is much slower than using the GET_DATA_*() macros directly.
'''  * Speed on a 1 Mpixel RGB image, using a 3 GHz machine:
'''  *   * pixGet/pixSet: ~25 Mpix/sec
'''  *   * GET_DATA/SET_DATA: ~350 MPix/sec
'''  * If speed is important and you're doing random access into
'''  * the pix, use pixGetLinePtrs() and the array access macros.
'''  *   (3) If the point is outside the image, this returns an error (1),
'''  * with 0 in %pval.  To avoid spamming output, it fails silently.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="x"> \param[in]    x,y    pixel coords</param>
''' <param name="y"> \param[out]   pval   pixel value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetPixel")> _
Friend Shared Function pixGetPixel(pix as IntPTR, x as Integer, y as Integer, pval as UInteger) as Integer
End Function

' SRC\pix2.c (251, 1)
' pixSetPixel()
' pixSetPixel(PIX *, l_int32, l_int32, l_uint32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Warning: the input value is not checked for overflow with respect
'''  * the the depth of %pix, and the sign bit (if any) is ignored.
'''  * * For d == 1, %val > 0 sets the bit on.
'''  * * For d == 2, 4, 8 and 16, %val is masked to the maximum allowable
'''  *   pixel value, and any (invalid) higher order bits are discarded.
'''  *   (2) See pixGetPixel() for information on performance.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="x"> \param[in]    x,y   pixel coords</param>
''' <param name="y"> \param[in]    val   value to be inserted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetPixel")> _
Friend Shared Function pixSetPixel(pix as IntPTR, x as Integer, y as Integer, val as UInteger) as Integer
End Function

' SRC\pix2.c (314, 1)
' pixGetRGBPixel()
' pixGetRGBPixel(PIX *, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix    32 bpp rgb, not colormapped</param>
''' <param name="x"> \param[in]    x,y    pixel coords</param>
''' <param name="y"> \param[out]   prval  [optional] red component</param>
''' <param name="prval"> \param[out]   pgval  [optional] green component</param>
''' <param name="pgval"> \param[out]   pbval  [optional] blue component</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRGBPixel")> _
Friend Shared Function pixGetRGBPixel(pix as IntPTR, x as Integer, y as Integer, prval as Integer, pgval as Integer, pbval as Integer) as Integer
End Function

' SRC\pix2.c (362, 1)
' pixSetRGBPixel()
' pixSetRGBPixel(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix    32 bpp rgb</param>
''' <param name="x"> \param[in]    x,y    pixel coords</param>
''' <param name="y"> \param[in]    rval   red component</param>
''' <param name="rval"> \param[in]    gval   green component</param>
''' <param name="gval"> \param[in]    bval   blue component</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetRGBPixel")> _
Friend Shared Function pixSetRGBPixel(pix as IntPTR, x as Integer, y as Integer, rval as Integer, gval as Integer, bval as Integer) as Integer
End Function

' SRC\pix2.c (409, 1)
' pixGetRandomPixel()
' pixGetRandomPixel(PIX *, l_uint32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If the pix is colormapped, it returns the rgb value.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix    any depth; can be colormapped</param>
''' <param name="pval"> \param[out]   pval   [optional] pixel value</param>
''' <param name="px"> \param[out]   px     [optional] x coordinate chosen; can be null</param>
''' <param name="py"> \param[out]   py     [optional] y coordinate chosen; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRandomPixel")> _
Friend Shared Function pixGetRandomPixel(pix as IntPTR, pval as UInteger, px as Integer, py as Integer) as Integer
End Function

' SRC\pix2.c (455, 1)
' pixClearPixel()
' pixClearPixel(PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error.</returns>
''' <param name="pix"> \param[in]    pix   any depth; warning if colormapped</param>
''' <param name="x"> \param[in]    x,y   pixel coords</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixClearPixel")> _
Friend Shared Function pixClearPixel(pix as IntPTR, x as Integer, y as Integer) as Integer
End Function

' SRC\pix2.c (513, 1)
' pixFlipPixel()
' pixFlipPixel(PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix   any depth, warning if colormapped</param>
''' <param name="x"> \param[in]    x,y   pixel coords</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFlipPixel")> _
Friend Shared Function pixFlipPixel(pix as IntPTR, x as Integer, y as Integer) as Integer
End Function

' SRC\pix2.c (592, 1)
' setPixelLow()
' setPixelLow(l_uint32 *, l_int32, l_int32, l_uint32) as void
''' <summary>
''' * Notes:
'''  *   (1) Caution: input variables are not checked!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="line"> \param[in]    line    ptr to beginning of line,</param>
''' <param name="x"> \param[in]    x       pixel location in line</param>
''' <param name="depth"> \param[in]    depth   bpp</param>
''' <param name="val"> \param[in]    val     to be inserted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="setPixelLow")> _
Friend Shared Function setPixelLow(line as UInteger, x as Integer, depth as Integer, val as UInteger) as Boolean ' Org. Void
End Function

' SRC\pix2.c (648, 1)
' pixGetBlackOrWhiteVal()
' pixGetBlackOrWhiteVal(PIX *, l_int32, l_uint32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Side effect.  For a colormapped image, if the requested
'''  * color is not present and there is room to add it in the cmap,
'''  * it is added and the new index is returned.  If there is no room,
'''  * the index of the closest color in intensity is returned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs    all depths; cmap ok</param>
''' <param name="op"> \param[in]    op      L_GET_BLACK_VAL, L_GET_WHITE_VAL</param>
''' <param name="pval"> \param[out]   pval    pixel value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetBlackOrWhiteVal")> _
Friend Shared Function pixGetBlackOrWhiteVal(pixs as IntPTR, op as Integer, pval as UInteger) as Integer
End Function

' SRC\pix2.c (704, 1)
' pixClearAll()
' pixClearAll(PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Clears all data to 0.  For 1 bpp, this is white; for grayscale
'''  * or color, this is black.
'''  *   (2) Caution: for colormapped pix, this sets the color to the first
'''  * one in the colormap.  Be sure that this is the intended color!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix    all depths; use cmapped with caution</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixClearAll")> _
Friend Shared Function pixClearAll(pix as IntPTR) as Integer
End Function

' SRC\pix2.c (733, 1)
' pixSetAll()
' pixSetAll(PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Sets all data to 1.  For 1 bpp, this is black; for grayscale
'''  * or color, this is white.
'''  *   (2) Caution: for colormapped pix, this sets the pixel value to the
'''  * maximum value supported by the colormap: 2^d - 1.  However, this
'''  * color may not be defined, because the colormap may not be full.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix     all depths; use cmapped with caution</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetAll")> _
Friend Shared Function pixSetAll(pix as IntPTR) as Integer
End Function

' SRC\pix2.c (776, 1)
' pixSetAllGray()
' pixSetAllGray(PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) N.B.  For all images, %grayval == 0 represents black and
'''  * %grayval == 255 represents white.
'''  *   (2) For depth  8, we do our best to approximate the gray level.
'''  * For 1 bpp images, any %grayval  128 is black; >= 128 is white.
'''  * For 32 bpp images, each r,g,b component is set to %grayval,
'''  * and the alpha component is preserved.
'''  *   (3) If pix is colormapped, it adds the gray value, replicated in
'''  * all components, to the colormap if it's not there and there
'''  * is room.  If the colormap is full, it finds the closest color in
'''  * L2 distance of components.  This index is written to all pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix       all depths, cmap ok</param>
''' <param name="grayval"> \param[in]    grayval   in range 0 ... 255</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetAllGray")> _
Friend Shared Function pixSetAllGray(pix as IntPTR, grayval as Integer) as Integer
End Function

' SRC\pix2.c (868, 1)
' pixSetAllArbitrary()
' pixSetAllArbitrary(PIX *, l_uint32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Caution 1!  For colormapped pix, %val is used as an index
'''  * into a colormap.  Be sure that index refers to the intended color.
'''  * If the color is not in the colormap, you should first add it
'''  * and then call this function.
'''  *   (2) Caution 2!  For 32 bpp pix, the interpretation of the LSB
'''  * of %val depends on whether spp == 3 (RGB) or spp == 4 (RGBA).
'''  * For RGB, the LSB is ignored in image transformations.
'''  * For RGBA, the LSB is interpreted as the alpha (transparency)
'''  * component; full transparency has alpha == 0x0, whereas
'''  * full opacity has alpha = 0xff.  An RGBA image with full
'''  * opacity behaves like an RGB image.
'''  *   (3) As an example of (2), suppose you want to initialize a 32 bpp
'''  * pix with partial opacity, say 0xee337788.  If the pix is 3 spp,
'''  * the 0x88 alpha component will be ignored and may be changed
'''  * in subsequent processing.  However, if the pix is 4 spp, the
'''  * alpha component will be retained and used. The function
'''  * pixCreate(w, h, 32) makes an RGB image by default, and
'''  * pixSetSpp(pix, 4) can be used to promote an RGB image to RGBA.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix    all depths; use cmapped with caution</param>
''' <param name="val"> \param[in]    val    value to set all pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetAllArbitrary")> _
Friend Shared Function pixSetAllArbitrary(pix as IntPTR, val as UInteger) as Integer
End Function

' SRC\pix2.c (938, 1)
' pixSetBlackOrWhite()
' pixSetBlackOrWhite(PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Function for setting all pixels in an image to either black
'''  * or white.
'''  *   (2) If pixs is colormapped, it adds black or white to the
'''  * colormap if it's not there and there is room.  If the colormap
'''  * is full, it finds the closest color in intensity.
'''  * This index is written to all pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs    all depths; cmap ok</param>
''' <param name="op"> \param[in]    op      L_SET_BLACK, L_SET_WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetBlackOrWhite")> _
Friend Shared Function pixSetBlackOrWhite(pixs as IntPTR, op as Integer) as Integer
End Function

' SRC\pix2.c (985, 1)
' pixSetComponentArbitrary()
' pixSetComponentArbitrary(PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For example, this can be used to set the alpha component to opaque:
'''  *  pixSetComponentArbitrary(pix, L_ALPHA_CHANNEL, 255)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix    32 bpp</param>
''' <param name="comp"> \param[in]    comp   COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL</param>
''' <param name="val"> \param[in]    val    value to set this component</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetComponentArbitrary")> _
Friend Shared Function pixSetComponentArbitrary(pix as IntPTR, comp as Integer, val as Integer) as Integer
End Function

' SRC\pix2.c (1035, 1)
' pixClearInRect()
' pixClearInRect(PIX *, BOX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Clears all data in rect to 0.  For 1 bpp, this is white;
'''  * for grayscale or color, this is black.
'''  *   (2) Caution: for colormapped pix, this sets the color to the first
'''  * one in the colormap.  Be sure that this is the intended color!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix   all depths; can be cmapped</param>
''' <param name="box"> \param[in]    box   in which all pixels will be cleared</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixClearInRect")> _
Friend Shared Function pixClearInRect(pix as IntPTR, box as IntPTR) as Integer
End Function

' SRC\pix2.c (1070, 1)
' pixSetInRect()
' pixSetInRect(PIX *, BOX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Sets all data in rect to 1.  For 1 bpp, this is black;
'''  * for grayscale or color, this is white.
'''  *   (2) Caution: for colormapped pix, this sets the pixel value to the
'''  * maximum value supported by the colormap: 2^d - 1.  However, this
'''  * color may not be defined, because the colormap may not be full.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix   all depths, can be cmapped</param>
''' <param name="box"> \param[in]    box   in which all pixels will be set</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetInRect")> _
Friend Shared Function pixSetInRect(pix as IntPTR, box as IntPTR) as Integer
End Function

' SRC\pix2.c (1112, 1)
' pixSetInRectArbitrary()
' pixSetInRectArbitrary(PIX *, BOX *, l_uint32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For colormapped pix, be sure the value is the intended
'''  * one in the colormap.
'''  *   (2) Caution: for colormapped pix, this sets each pixel in the
'''  * rect to the color at the index equal to val.  Be sure that
'''  * this index exists in the colormap and that it is the intended one!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix   all depths; can be cmapped</param>
''' <param name="box"> \param[in]    box   in which all pixels will be set to val</param>
''' <param name="val"> \param[in]    val   value to set all pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetInRectArbitrary")> _
Friend Shared Function pixSetInRectArbitrary(pix as IntPTR, box as IntPTR, val as UInteger) as Integer
End Function

' SRC\pix2.c (1213, 1)
' pixBlendInRect()
' pixBlendInRect(PIX *, BOX *, l_uint32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place function.  It blends the input color %val
'''  * with the pixels in pixs in the specified rectangle.
'''  * If no rectangle is specified, it blends over the entire image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs   32 bpp rgb</param>
''' <param name="box"> \param[in]    box    [optional] in which all pixels will be blended</param>
''' <param name="val"> \param[in]    val    blend value; 0xrrggbb00</param>
''' <param name="fract"> \param[in]    fract  fraction of color to be blended with each pixel in pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixBlendInRect")> _
Friend Shared Function pixBlendInRect(pixs as IntPTR, box as IntPTR, val as UInteger, fract as single) as Integer
End Function

' SRC\pix2.c (1299, 1)
' pixSetPadBits()
' pixSetPadBits(PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The pad bits are the bits that expand each scanline to a
'''  * multiple of 32 bits.  They are usually not used in
'''  * image processing operations.  When boundary conditions
'''  * are important, as in seedfill, they must be set properly.
'''  *   (2) This sets the value of the pad bits (if any) in the last
'''  * 32-bit word in each scanline.
'''  *   (3) For 32 bpp pix, there are no pad bits, so this is a no-op.
'''  *   (4) When writing formatted output, such as tiff, png or jpeg,
'''  * the pad bits have no effect on the raster image that is
'''  * generated by reading back from the file.  However, in some
'''  * cases, the compressed file itself will depend on the pad
'''  * bits.  This is seen, for example, in Windows with 2 and 4 bpp
'''  * tiff-compressed images that have pad bits on each scanline.
'''  * It is sometimes convenient to use a golden file with a
'''  * byte-by-byte check to verify invariance.  Consequently,
'''  * and because setting the pad bits is cheap, the pad bits are
'''  * set to 0 before writing these compressed files.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix   1, 2, 4, 8, 16, 32 bpp</param>
''' <param name="val"> \param[in]    val   0 or 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetPadBits")> _
Friend Shared Function pixSetPadBits(pix as IntPTR, val as Integer) as Integer
End Function

' SRC\pix2.c (1359, 1)
' pixSetPadBitsBand()
' pixSetPadBitsBand(PIX *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The pad bits are the bits that expand each scanline to a
'''  * multiple of 32 bits.  They are usually not used in
'''  * image processing operations.  When boundary conditions
'''  * are important, as in seedfill, they must be set properly.
'''  *   (2) This sets the value of the pad bits (if any) in the last
'''  * 32-bit word in each scanline, within the specified
'''  * band of raster lines.
'''  *   (3) For 32 bpp pix, there are no pad bits, so this is a no-op.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix   1, 2, 4, 8, 16, 32 bpp</param>
''' <param name="by"> \param[in]    by    starting y value of band</param>
''' <param name="bh"> \param[in]    bh    height of band</param>
''' <param name="val"> \param[in]    val   0 or 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetPadBitsBand")> _
Friend Shared Function pixSetPadBitsBand(pix as IntPTR, by as Integer, bh as Integer, val as Integer) as Integer
End Function

' SRC\pix2.c (1431, 1)
' pixSetOrClearBorder()
' pixSetOrClearBorder(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The border region is defined to be the region in the
'''  * image within a specific distance of each edge.  Here, we
'''  * allow the pixels within a specified distance of each
'''  * edge to be set independently.  This either sets or
'''  * clears all pixels in the border region.
'''  *   (2) For binary images, use PIX_SET for black and PIX_CLR for white.
'''  *   (3) For grayscale or color images, use PIX_SET for white
'''  * and PIX_CLR for black.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs   all depths</param>
''' <param name="left"> \param[in]    left,  right, top, bot amount to set or clear</param>
''' <param name="right"> \param[in]    op     operation PIX_SET or PIX_CLR</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetOrClearBorder")> _
Friend Shared Function pixSetOrClearBorder(pixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer, op as Integer) as Integer
End Function

' SRC\pix2.c (1480, 1)
' pixSetBorderVal()
' pixSetBorderVal(PIX *, l_int32, l_int32, l_int32, l_int32, l_uint32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The border region is defined to be the region in the
'''  * image within a specific distance of each edge.  Here, we
'''  * allow the pixels within a specified distance of each
'''  * edge to be set independently.  This sets the pixels
'''  * in the border region to the given input value.
'''  *   (2) For efficiency, use pixSetOrClearBorder() if
'''  * you're setting the border to either black or white.
'''  *   (3) If d != 32, the input value should be masked off
'''  * to the appropriate number of least significant bits.
'''  *   (4) The code is easily generalized for 2 or 4 bpp.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs                   8, 16 or 32 bpp</param>
''' <param name="left"> \param[in]    left, right, top, bot  amount to set</param>
''' <param name="right"> \param[in]    val                    value to set at each border pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetBorderVal")> _
Friend Shared Function pixSetBorderVal(pixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer, val as UInteger) as Integer
End Function

' SRC\pix2.c (1584, 1)
' pixSetBorderRingVal()
' pixSetBorderRingVal(PIX *, l_int32, l_uint32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The rings are single-pixel-wide rectangular sets of
'''  * pixels at a given distance from the edge of the pix.
'''  * This sets all pixels in a given ring to a value.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs    any depth; cmap OK</param>
''' <param name="dist"> \param[in]    dist    distance from outside; must be > 0; first ring is 1</param>
''' <param name="val"> \param[in]    val     value to set at each border pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetBorderRingVal")> _
Friend Shared Function pixSetBorderRingVal(pixs as IntPTR, dist as Integer, val as UInteger) as Integer
End Function

' SRC\pix2.c (1635, 1)
' pixSetMirroredBorder()
' pixSetMirroredBorder(PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This applies what is effectively mirror boundary conditions
'''  * to a border region in the image.  It is in-place.
'''  *   (2) This is useful for setting pixels near the border to a
'''  * value representative of the near pixels to the interior.
'''  *   (3) The general pixRasterop() is used for an in-place operation here
'''  * because there is no overlap between the src and dest rectangles.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs                   all depths; colormap ok</param>
''' <param name="left"> \param[in]    left, right, top, bot  number of pixels to set</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetMirroredBorder")> _
Friend Shared Function pixSetMirroredBorder(pixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer) as Integer
End Function

' SRC\pix2.c (1686, 1)
' pixCopyBorder()
' pixCopyBorder(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pixd can be null, but otherwise it must be the same size
'''  * and depth as pixs.  Always returns pixd.
'''  *   (2) This is useful in situations where by setting a few border
'''  * pixels we can avoid having to copy all pixels in pixs into
'''  * pixd as an initialization step for some operation.
'''  * Nevertheless, for safety, if making a new pixd, all the
'''  * non-border pixels are initialized to 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error if pixd is not defined</returns>
''' <param name="pixd"> \param[in]    pixd                   all depths; colormap ok; can be NULL</param>
''' <param name="pixs"> \param[in]    pixs                   same depth and size as pixd</param>
''' <param name="left"> \param[in]    left, right, top, bot  number of pixels to copy</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCopyBorder")> _
Friend Shared Function pixCopyBorder(pixd as IntPTR, pixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer) as IntPTR
End Function

' SRC\pix2.c (1740, 1)
' pixAddBorder()
' pixAddBorder(PIX *, l_int32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixGetBlackOrWhiteVal() for values of black and white pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with the added exterior pixels, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   all depths; colormap ok</param>
''' <param name="npix"> \param[in]    npix   number of pixels to be added to each side</param>
''' <param name="val"> \param[in]    val    value of added border pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddBorder")> _
Friend Shared Function pixAddBorder(pixs as IntPTR, npix as Integer, val as UInteger) as IntPTR
End Function

' SRC\pix2.c (1780, 1)
' pixAddBlackOrWhiteBorder()
' pixAddBlackOrWhiteBorder(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixGetBlackOrWhiteVal() for possible side effect (adding
'''  * a color to a colormap).
'''  *   (2) The only complication is that pixs may have a colormap.
'''  * There are two ways to add the black or white border:
'''  * (a) As done here (simplest, most efficient)
'''  * (b) l_int32 ws, hs, d;
'''  *  pixGetDimensions(pixs, &ws, &hs, &d);
'''  *  Pix *pixd = pixCreate(ws + left + right, hs + top + bot, d);
'''  *  PixColormap *cmap = pixGetColormap(pixs);
'''  *  if (cmap != NULL)
'''  *   pixSetColormap(pixd, pixcmapCopy(cmap));
'''  *  pixSetBlackOrWhite(pixd, L_SET_WHITE);  // uses cmap
'''  *  pixRasterop(pixd, left, top, ws, hs, PIX_SET, pixs, 0, 0);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with the added exterior pixels, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths; colormap ok</param>
''' <param name="left"> \param[in]    left, right, top, bot  number of pixels added</param>
''' <param name="right"> \param[in]    op L_GET_BLACK_VAL, L_GET_WHITE_VAL</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddBlackOrWhiteBorder")> _
Friend Shared Function pixAddBlackOrWhiteBorder(pixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer, op as Integer) as IntPTR
End Function

' SRC\pix2.c (1834, 1)
' pixAddBorderGeneral()
' pixAddBorderGeneral(PIX *, l_int32, l_int32, l_int32, l_int32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For binary images:
'''  * white:  val = 0
'''  * black:  val = 1
'''  * For grayscale images:
'''  * white:  val = 2 ** d - 1
'''  * black:  val = 0
'''  * For rgb color images:
'''  * white:  val = 0xffffff00
'''  * black:  val = 0
'''  * For colormapped images, set val to the appropriate colormap index.
'''  *   (2) If the added border is either black or white, you can use
'''  * pixAddBlackOrWhiteBorder()
'''  * The black and white values for all images can be found with
'''  * pixGetBlackOrWhiteVal()
'''  * which, if pixs is cmapped, may add an entry to the colormap.
'''  * Alternatively, if pixs has a colormap, you can find the index
'''  * of the pixel whose intensity is closest to white or black:
'''  * white: pixcmapGetRankIntensity(cmap, 1.0, &index);
'''  * black: pixcmapGetRankIntensity(cmap, 0.0, &index);
'''  * and use that for val.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with the added exterior pixels, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs                   all depths; colormap ok</param>
''' <param name="left"> \param[in]    left, right, top, bot  number of pixels added</param>
''' <param name="right"> \param[in]    val                    value of added border pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddBorderGeneral")> _
Friend Shared Function pixAddBorderGeneral(pixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer, val as UInteger) as IntPTR
End Function

' SRC\pix2.c (1889, 1)
' pixRemoveBorder()
' pixRemoveBorder(PIX *, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with pixels removed around border, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   all depths; colormap ok</param>
''' <param name="npix"> \param[in]    npix   number to be removed from each of the 4 sides</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRemoveBorder")> _
Friend Shared Function pixRemoveBorder(pixs as IntPTR, npix as Integer) as IntPTR
End Function

' SRC\pix2.c (1910, 1)
' pixRemoveBorderGeneral()
' pixRemoveBorderGeneral(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with pixels removed around border, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs                   all depths; colormap ok</param>
''' <param name="left"> \param[in]    left, right, top, bot  number of pixels removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRemoveBorderGeneral")> _
Friend Shared Function pixRemoveBorderGeneral(pixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer) as IntPTR
End Function

' SRC\pix2.c (1963, 1)
' pixRemoveBorderToSize()
' pixRemoveBorderToSize(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Removes pixels as evenly as possible from the sides of the
'''  * image, leaving the central part.
'''  *   (2) Returns clone if no pixels requested removed, or the target
'''  * sizes are larger than the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with pixels removed around border, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   all depths; colormap ok</param>
''' <param name="wd"> \param[in]    wd     target width; use 0 if only removing from height</param>
''' <param name="hd"> \param[in]    hd     target height; use 0 if only removing from width</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRemoveBorderToSize")> _
Friend Shared Function pixRemoveBorderToSize(pixs as IntPTR, wd as Integer, hd as Integer) as IntPTR
End Function

' SRC\pix2.c (2018, 1)
' pixAddMirroredBorder()
' pixAddMirroredBorder(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This applies what is effectively mirror boundary conditions.
'''  * For the added border pixels in pixd, the pixels in pixs
'''  * near the border are mirror-copied into the border region.
'''  *   (2) This is useful for avoiding special operations near
'''  * boundaries when doing image processing operations
'''  * such as rank filters and convolution.  In use, one first
'''  * adds mirrored pixels to each side of the image.  The number
'''  * of pixels added on each side is half the filter dimension.
'''  * Then the image processing operations proceed over a
'''  * region equal to the size of the original image, and
'''  * write directly into a dest pix of the same size as pixs.
'''  *   (3) The general pixRasterop() is used for an in-place operation here
'''  * because there is no overlap between the src and dest rectangles.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs                   all depths; colormap ok</param>
''' <param name="left"> \param[in]    left, right, top, bot  number of pixels added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddMirroredBorder")> _
Friend Shared Function pixAddMirroredBorder(pixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer) as IntPTR
End Function

' SRC\pix2.c (2071, 1)
' pixAddRepeatedBorder()
' pixAddRepeatedBorder(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This applies a repeated border, as if the central part of
'''  * the image is tiled over the plane.  So, for example, the
'''  * pixels in the left border come from the right side of the image.
'''  *   (2) The general pixRasterop() is used for an in-place operation here
'''  * because there is no overlap between the src and dest rectangles.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs                   all depths; colormap ok</param>
''' <param name="left"> \param[in]    left, right, top, bot  number of pixels added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddRepeatedBorder")> _
Friend Shared Function pixAddRepeatedBorder(pixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer) as IntPTR
End Function

' SRC\pix2.c (2127, 1)
' pixAddMixedBorder()
' pixAddMixedBorder(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This applies mirrored boundary conditions horizontally
'''  * and repeated b.c. vertically.
'''  *   (2) It is specifically used for avoiding special operations
'''  * near boundaries when convolving a hue-saturation histogram
'''  * with a given window size.  The repeated b.c. are used
'''  * vertically for hue, and the mirrored b.c. are used
'''  * horizontally for saturation.  The number of pixels added
'''  * on each side is approximately (but not quite) half the
'''  * filter dimension.  The image processing operations can
'''  * then proceed over a region equal to the size of the original
'''  * image, and write directly into a dest pix of the same
'''  * size as pixs.
'''  *   (3) The general pixRasterop() can be used for an in-place
'''  * operation here because there is no overlap between the
'''  * src and dest rectangles.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs                   all depths; colormap ok</param>
''' <param name="left"> \param[in]    left, right, top, bot  number of pixels added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddMixedBorder")> _
Friend Shared Function pixAddMixedBorder(pixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer) as IntPTR
End Function

' SRC\pix2.c (2174, 1)
' pixAddContinuedBorder()
' pixAddContinuedBorder(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This adds pixels on each side whose values are equal to
'''  * the value on the closest boundary pixel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs                   all depths; colormap ok</param>
''' <param name="left"> \param[in]    left, right, top, bot  pixels on each side to be added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddContinuedBorder")> _
Friend Shared Function pixAddContinuedBorder(pixs as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer) as IntPTR
End Function

' SRC\pix2.c (2217, 1)
' pixShiftAndTransferAlpha()
' pixShiftAndTransferAlpha(PIX *, PIX *, l_float32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]    pixd            32 bpp</param>
''' <param name="pixs"> \param[in]    pixs            32 bpp</param>
''' <param name="shiftx"> \param[in]    shiftx, shifty</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixShiftAndTransferAlpha")> _
Friend Shared Function pixShiftAndTransferAlpha(pixd as IntPTR, pixs as IntPTR, shiftx as single, shifty as single) as Integer
End Function

' SRC\pix2.c (2268, 1)
' pixDisplayLayersRGBA()
' pixDisplayLayersRGBA(PIX *, l_uint32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Use %val == 0xffffff00 for white background.
'''  *   (2) Three views are given:
'''  *  ~ the image with a fully opaque alpha
'''  *  ~ the alpha layer
'''  *  ~ the image as it would appear with a white background.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd showing various image views, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   cmap or 32 bpp rgba</param>
''' <param name="val"> \param[in]    val    32 bit unsigned color to use as background</param>
''' <param name="maxw"> \param[in]    maxw   max output image width; 0 for no scaling</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDisplayLayersRGBA")> _
Friend Shared Function pixDisplayLayersRGBA(pixs as IntPTR, val as UInteger, maxw as Integer) as IntPTR
End Function

' SRC\pix2.c (2340, 1)
' pixCreateRGBImage()
' pixCreateRGBImage(PIX *, PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) the 4th byte, sometimes called the "alpha channel",
'''  * and which is often used for blending between different
'''  * images, is left with 0 value.
'''  *   (2) see Note (4) in pix.h for details on storage of
'''  * 8-bit samples within each 32-bit word.
'''  *   (3) This implementation, setting the r, g and b components
'''  * sequentially, is much faster than setting them in parallel
'''  * by constructing an RGB dest pixel and writing it to dest.
'''  * The reason is there are many more cache misses when reading
'''  * from 3 input images simultaneously.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  32 bpp pix, interleaved with 4 samples/pixel,</returns>
''' <param name="pixr"> \param[in]   pixr   8 bpp red pix</param>
''' <param name="pixg"> \param[in]   pixg   8 bpp green pix</param>
''' <param name="pixb"> \param[in]   pixb   8 bpp blue pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCreateRGBImage")> _
Friend Shared Function pixCreateRGBImage(pixr as IntPTR, pixg as IntPTR, pixb as IntPTR) as IntPTR
End Function

' SRC\pix2.c (2396, 1)
' pixGetRGBComponent()
' pixGetRGBComponent(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Three calls to this function generate the r, g and b 8 bpp
'''  * component images.  This is much faster than generating the
'''  * three images in parallel, by extracting a src pixel and setting
'''  * the pixels of each component image from it.  The reason is
'''  * there are many more cache misses when writing to three
'''  * output images simultaneously.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd the selected 8 bpp component image of the</returns>
''' <param name="pixs"> \param[in]   pixs   32 bpp, or colormapped</param>
''' <param name="comp"> \param[in]   comp   one of {COLOR_RED, COLOR_GREEN, COLOR_BLUE,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRGBComponent")> _
Friend Shared Function pixGetRGBComponent(pixs as IntPTR, comp as Integer) as IntPTR
End Function

' SRC\pix2.c (2455, 1)
' pixSetRGBComponent()
' pixSetRGBComponent(PIX *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This places the 8 bpp pixel in pixs into the
'''  * specified component (properly interleaved) in pixd,
'''  *   (2) The two images are registered to the UL corner; the sizes
'''  * need not be the same, but a warning is issued if they differ.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]   pixd   32 bpp</param>
''' <param name="pixs"> \param[in]   pixs   8 bpp</param>
''' <param name="comp"> \param[in]   comp   one of the set: {COLOR_RED, COLOR_GREEN,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetRGBComponent")> _
Friend Shared Function pixSetRGBComponent(pixd as IntPTR, pixs as IntPTR, comp as Integer) as Integer
End Function

' SRC\pix2.c (2517, 1)
' pixGetRGBComponentCmap()
' pixGetRGBComponentCmap(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) In leptonica, we do not support alpha in colormaps.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd  the selected 8 bpp component image of the</returns>
''' <param name="pixs"> \param[in]   pixs   colormapped</param>
''' <param name="comp"> \param[in]   comp   one of the set: {COLOR_RED, COLOR_GREEN, COLOR_BLUE}</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRGBComponentCmap")> _
Friend Shared Function pixGetRGBComponentCmap(pixs as IntPTR, comp as Integer) as IntPTR
End Function

' SRC\pix2.c (2602, 1)
' pixCopyRGBComponent()
' pixCopyRGBComponent(PIX *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The two images are registered to the UL corner.  The sizes
'''  * are usually the same, and a warning is issued if they differ.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]   pixd   32 bpp</param>
''' <param name="pixs"> \param[in]   pixs   32 bpp</param>
''' <param name="comp"> \param[in]   comp   one of the set: {COLOR_RED, COLOR_GREEN,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCopyRGBComponent")> _
Friend Shared Function pixCopyRGBComponent(pixd as IntPTR, pixs as IntPTR, comp as Integer) as Integer
End Function

' SRC\pix2.c (2663, 1)
' composeRGBPixel()
' composeRGBPixel(l_int32, l_int32, l_int32, l_uint32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) All channels are 8 bits: the input values must be between
'''  * 0 and 255.  For speed, this is not enforced by masking
'''  * with 0xff before shifting.
'''  *   (2) A slower implementation uses macros:
'''  *   SET_DATA_BYTE(ppixel, COLOR_RED, rval);
'''  *   SET_DATA_BYTE(ppixel, COLOR_GREEN, gval);
'''  *   SET_DATA_BYTE(ppixel, COLOR_BLUE, bval);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="rval"> \param[in]    rval, gval, bval</param>
''' <param name="gval"> \param[out]   ppixel             32-bit pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="composeRGBPixel")> _
Friend Shared Function composeRGBPixel(rval as Integer, gval as Integer, bval as Integer, ppixel as UInteger) as Integer
End Function

' SRC\pix2.c (2694, 1)
' composeRGBAPixel()
' composeRGBAPixel(l_int32, l_int32, l_int32, l_int32, l_uint32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) All channels are 8 bits: the input values must be between
'''  * 0 and 255.  For speed, this is not enforced by masking
'''  * with 0xff before shifting.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="rval"> \param[in]    rval, gval, bval, aval</param>
''' <param name="gval"> \param[out]   ppixel                  32-bit pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="composeRGBAPixel")> _
Friend Shared Function composeRGBAPixel(rval as Integer, gval as Integer, bval as Integer, aval as Integer, ppixel as UInteger) as Integer
End Function

' SRC\pix2.c (2729, 1)
' extractRGBValues()
' extractRGBValues(l_uint32, l_int32 *, l_int32 *, l_int32 *) as void
''' <summary>
''' * Notes:
'''  *   (1) A slower implementation uses macros:
'''  * *prval = GET_DATA_BYTE(&pixel, COLOR_RED);
'''  * *pgval = GET_DATA_BYTE(&pixel, COLOR_GREEN);
'''  * *pbval = GET_DATA_BYTE(&pixel, COLOR_BLUE);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pixel"> \param[in]    pixel   32 bit</param>
''' <param name="prval"> \param[out]   prval   [optional] red component</param>
''' <param name="pgval"> \param[out]   pgval   [optional] green component</param>
''' <param name="pbval"> \param[out]   pbval   [optional] blue component</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="extractRGBValues")> _
Friend Shared Function extractRGBValues(pixel as UInteger, prval as Integer, pgval as Integer, pbval as Integer) as Boolean ' Org. Void
End Function

' SRC\pix2.c (2752, 1)
' extractRGBAValues()
' extractRGBAValues(l_uint32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pixel"> \param[in]    pixel   32 bit</param>
''' <param name="prval"> \param[out]   prval   [optional] red component</param>
''' <param name="pgval"> \param[out]   pgval   [optional] green component</param>
''' <param name="pbval"> \param[out]   pbval   [optional] blue component</param>
''' <param name="paval"> \param[out]   paval   [optional] alpha component</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="extractRGBAValues")> _
Friend Shared Function extractRGBAValues(pixel as UInteger, prval as Integer, pgval as Integer, pbval as Integer, paval as Integer) as Boolean ' Org. Void
End Function

' SRC\pix2.c (2774, 1)
' extractMinMaxComponent()
' extractMinMaxComponent(l_uint32, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  component in range [0 ... 255], or NULL on error</returns>
''' <param name="pixel"> \param[in]   pixel   32 bpp RGB</param>
''' <param name="type"> \param[in]   type    L_CHOOSE_MIN or L_CHOOSE_MAX</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="extractMinMaxComponent")> _
Friend Shared Function extractMinMaxComponent(pixel as UInteger, type as Integer) as Integer
End Function

' SRC\pix2.c (2808, 1)
' pixGetRGBLine()
' pixGetRGBLine(PIX *, l_int32, l_uint8 *, l_uint8 *, l_uint8 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This puts rgb components from the input line in pixs
'''  * into the given buffers.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]   pixs   32 bpp</param>
''' <param name="row"> \param[in]   row</param>
''' <param name="bufr"> \param[in]   bufr   array of red samples; size w bytes</param>
''' <param name="bufg"> \param[in]   bufg   array of green samples; size w bytes</param>
''' <param name="bufb"> \param[in]   bufb   array of blue samples; size w bytes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRGBLine")> _
Friend Shared Function pixGetRGBLine(pixs as IntPTR, row as Integer, bufr as Byte, bufg as Byte, bufb as Byte) as Integer
End Function

' SRC\pix2.c (2871, 1)
' pixEndianByteSwapNew()
' pixEndianByteSwapNew(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is used to convert the data in a pix to a
'''  * serialized byte buffer in raster order, and, for RGB,
'''  * in order RGBA.  This requires flipping bytes within
'''  * each 32-bit word for little-endian platforms, because the
'''  * words have a MSB-to-the-left rule, whereas byte raster-order
'''  * requires the left-most byte in each word to be byte 0.
'''  * For big-endians, no swap is necessary, so this returns a clone.
'''  *   (2) Unlike pixEndianByteSwap(), which swaps the bytes in-place,
'''  * this returns a new pix (or a clone).  We provide this
'''  * because often when serialization is done, the source
'''  * pix needs to be restored to canonical little-endian order,
'''  * and this requires a second byte swap.  In such a situation,
'''  * it is twice as fast to make a new pix in big-endian order,
'''  * use it, and destroy it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixEndianByteSwapNew")> _
Friend Shared Function pixEndianByteSwapNew(pixs as IntPTR) as IntPTR
End Function

' SRC\pix2.c (2934, 1)
' pixEndianByteSwap()
' pixEndianByteSwap(PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is used on little-endian platforms to swap
'''  * the bytes within a word; bytes 0 and 3 are swapped,
'''  * and bytes 1 and 2 are swapped.
'''  *   (2) This is required for little-endians in situations
'''  * where we convert from a serialized byte order that is
'''  * in raster order, as one typically has in file formats,
'''  * to one with MSB-to-the-left in each 32-bit word, or v.v.
'''  * See pix.h for a description of the canonical format
'''  * (MSB-to-the left) that is used for both little-endian
'''  * and big-endian platforms.   For big-endians, the
'''  * MSB-to-the-left word order has the bytes in raster
'''  * order when serialized, so no byte flipping is required.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]   pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixEndianByteSwap")> _
Friend Shared Function pixEndianByteSwap(pixs as IntPTR) as Integer
End Function

' SRC\pix2.c (2992, 1)
' lineEndianByteSwap()
' lineEndianByteSwap(l_uint32 *, l_uint32 *, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This is used on little-endian platforms to swap
'''  * the bytes within each word in the line of image data.
'''  * Bytes 0 ==> 3 and 1 ==> 2 are swapped in the dest
'''  * byte array data8d, relative to the pix data in datas.
'''  *   (2) The bytes represent 8 bit pixel values.  They are swapped
'''  * for little endians so that when the dest array datad
'''  * is addressed by bytes, the pixels are chosen sequentially
'''  * from left to right in the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="datad"> \param[in]  datad   dest byte array data, reordered on little-endians</param>
''' <param name="datas"> \param[in]  datas   a src line of pix data)</param>
''' <param name="wpl"> \param[in]  wpl     number of 32 bit words in the line</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lineEndianByteSwap")> _
Friend Shared Function lineEndianByteSwap(datad as UInteger, datas as UInteger, wpl as Integer) as Integer
End Function

' SRC\pix2.c (3045, 1)
' pixEndianTwoByteSwapNew()
' pixEndianTwoByteSwapNew(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is used on little-endian platforms to swap the
'''  * 2-byte entities within a 32-bit word.
'''  *   (2) This is equivalent to a full byte swap, as performed
'''  * by pixEndianByteSwap(), followed by byte swaps in
'''  * each of the 16-bit entities separately.
'''  *   (3) Unlike pixEndianTwoByteSwap(), which swaps the shorts in-place,
'''  * this returns a new pix (or a clone).  We provide this
'''  * to avoid having to swap twice in situations where the input
'''  * pix must be restored to canonical little-endian order.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixEndianTwoByteSwapNew")> _
Friend Shared Function pixEndianTwoByteSwapNew(pixs as IntPTR) as IntPTR
End Function

' SRC\pix2.c (3098, 1)
' pixEndianTwoByteSwap()
' pixEndianTwoByteSwap(PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is used on little-endian platforms to swap the
'''  * 2-byte entities within a 32-bit word.
'''  *   (2) This is equivalent to a full byte swap, as performed
'''  * by pixEndianByteSwap(), followed by byte swaps in
'''  * each of the 16-bit entities separately.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixEndianTwoByteSwap")> _
Friend Shared Function pixEndianTwoByteSwap(pixs as IntPTR) as Integer
End Function

' SRC\pix2.c (3152, 1)
' pixGetRasterData()
' pixGetRasterData(PIX *, l_uint8 **, size_t *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This returns the raster data as a byte string, padded to the
'''  * byte.  For 1 bpp, the first pixel is the MSbit in the first byte.
'''  * For rgb, the bytes are in (rgb) order.  This is the format
'''  * required for flate encoding of pixels in a PostScript file.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     1, 8, 32 bpp</param>
''' <param name="pdata"> \param[out]   pdata    raster data in memory</param>
''' <param name="pnbytes"> \param[out]   pnbytes  number of bytes in data string</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRasterData")> _
Friend Shared Function pixGetRasterData(pixs as IntPTR, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\pix2.c (3226, 1)
' pixAlphaIsOpaque()
' pixAlphaIsOpaque(PIX *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix       32 bpp, spp == 4</param>
''' <param name="popaque"> \param[out]   popaque   1 if spp == 4 and all alpha component</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAlphaIsOpaque")> _
Friend Shared Function pixAlphaIsOpaque(pix as IntPTR, popaque as Integer) as Integer
End Function

' SRC\pix2.c (3291, 1)
' pixSetupByteProcessing()
' pixSetupByteProcessing(PIX *, l_int32 *, l_int32 *) as l_uint8 **
''' <summary>
''' * Notes:
'''  *   (1) This is a simple helper for processing 8 bpp images with
'''  * direct byte access.  It can swap byte order within each word.
'''  *   (2) After processing, you must call pixCleanupByteProcessing(),
'''  * which frees the lineptr array and restores byte order.
'''  *   (3) Usage:
'''  *  l_uint8 **lineptrs = pixSetupByteProcessing(pix, &w, &h);
'''  *  for (i = 0; i  h; i++) {
'''  *   l_uint8 *line = lineptrs[i];
'''  *   for (j = 0; j  w; j++) {
'''  *    val = line[j];
'''  *    ...
'''  *   }
'''  *  }
'''  *  pixCleanupByteProcessing(pix, lineptrs);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  line ptr array, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix   8 bpp, no colormap</param>
''' <param name="pw"> \param[out]   pw    [optional] width</param>
''' <param name="ph"> \param[out]   ph    [optional] height</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetupByteProcessing")> _
Friend Shared Function pixSetupByteProcessing(pix as IntPTR, pw as Integer, ph as Integer) as String
End Function

' SRC\pix2.c (3329, 1)
' pixCleanupByteProcessing()
' pixCleanupByteProcessing(PIX *, l_uint8 **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This must be called after processing that was initiated
'''  * by pixSetupByteProcessing() has finished.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]   pix        8 bpp, no colormap</param>
''' <param name="lineptrs"> \param[in]   lineptrs   ptrs to the beginning of each raster line of data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCleanupByteProcessing")> _
Friend Shared Function pixCleanupByteProcessing(pix as IntPTR, lineptrs as Object) as Integer
End Function

' SRC\pix2.c (3371, 1)
' l_setAlphaMaskBorder()
' l_setAlphaMaskBorder(l_float32, l_float32) as void
''' <summary>
''' * Notes:
'''  *   (1) This sets the opacity values used to generate the two outer
'''  * boundary rings in the alpha mask associated with geometric
'''  * transforms such as pixRotateWithAlpha().
'''  *   (2) The default values are val1 = 0.0 (completely transparent
'''  * in the outermost ring) and val2 = 0.5 (half transparent
'''  * in the second ring).  When the image is blended, this
'''  * completely removes the outer ring (shrinking the image by
'''  * 2 in each direction), and alpha-blends with 0.5 the second ring.
'''  * Using val1 = 0.25 and val2 = 0.75 gives a slightly more
'''  * blurred border, with no perceptual difference at screen resolution.
'''  *   (3) The actual mask values are found by multiplying these
'''  * normalized opacity values by 255.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="val1"> \param[in]    val1, val2     in [0.0 ... 1.0]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_setAlphaMaskBorder")> _
Friend Shared Function l_setAlphaMaskBorder(val1 as single, val2 as single) as Boolean ' Org. Void
End Function

#End Region
#Region "SRC\pix3.c"
' SRC\pix3.c (111, 14)
' findTileRegionsForSearch()
' findTileRegionsForSearch(BOX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) See calling function pixfindRepCloseTile().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa if OK, or NULL on error</returns>
''' <param name="box"> \param[in]   box        region of Pix to search around</param>
''' <param name="w"> \param[in]   w, h       dimensions of Pix</param>
''' <param name="h"> \param[in]   searchdir  L_HORIZ or L_VERT; direction to search</param>
''' <param name="searchdir"> \param[in]   mindist    min distance of selected tile edge from box; >= 0</param>
''' <param name="mindist"> \param[in]   tsize      tile size; > 1; even; typically ~50</param>
''' <param name="tsize"> \param[in]   ntiles     number of tiles tested in each row/column</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="findTileRegionsForSearch")> _
Friend Shared Function findTileRegionsForSearch(box as IntPTR, w as Integer, h as Integer, searchdir as Integer, mindist as Integer, tsize as Integer, ntiles as Integer) as IntPTR
End Function

' SRC\pix3.c (155, 1)
' pixSetMasked()
' pixSetMasked(PIX *, PIX *, l_uint32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) In-place operation.
'''  *   (2) NOTE: For cmapped images, this calls pixSetMaskedCmap().
'''  * %val must be the 32-bit color representation of the RGB pixel.
'''  * It is not the index into the colormap!
'''  *   (2) If pixm == NULL, a warning is given.
'''  *   (3) This is an implicitly aligned operation, where the UL
'''  * corners of pixd and pixm coincide.  A warning is
'''  * issued if the two image sizes differ significantly,
'''  * but the operation proceeds.
'''  *   (4) Each pixel in pixd that co-locates with an ON pixel
'''  * in pixm is set to the specified input value.
'''  * Other pixels in pixd are not changed.
'''  *   (5) You can visualize this as painting the color through
'''  * the mask, as a stencil.
'''  *   (6) If you do not want to have the UL corners aligned,
'''  * use the function pixSetMaskedGeneral(), which requires
'''  * you to input the UL corner of pixm relative to pixd.
'''  *   (7) Implementation details: see comments in pixPaintThroughMask()
'''  * for when we use rasterop to do the painting.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]   pixd   1, 2, 4, 8, 16 or 32 bpp; or colormapped</param>
''' <param name="pixm"> \param[in]   pixm   [optional] 1 bpp mask; no operation if NULL</param>
''' <param name="val"> \param[in]   val    value to set at each masked pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetMasked")> _
Friend Shared Function pixSetMasked(pixd as IntPTR, pixm as IntPTR, val as UInteger) as Integer
End Function

' SRC\pix3.c (294, 1)
' pixSetMaskedGeneral()
' pixSetMaskedGeneral(PIX *, PIX *, l_uint32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place operation.
'''  *   (2) Alignment is explicit.  If you want the UL corners of
'''  * the two images to be aligned, use pixSetMasked().
'''  *   (3) A typical use would be painting through the foreground
'''  * of a small binary mask pixm, located somewhere on a
'''  * larger pixd.  Other pixels in pixd are not changed.
'''  *   (4) You can visualize this as painting the color through
'''  * the mask, as a stencil.
'''  *   (5) This uses rasterop to handle clipping and different depths of pixd.
'''  *   (6) If pixd has a colormap, you should call pixPaintThroughMask().
'''  *   (7) Why is this function here, if pixPaintThroughMask() does the
'''  * same thing, and does it more generally?  I've retained it here
'''  * to show how one can paint through a mask using only full
'''  * image rasterops, rather than pixel peeking in pixm and poking
'''  * in pixd.  It's somewhat baroque, but I found it amusing.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]   pixd    8, 16 or 32 bpp</param>
''' <param name="pixm"> \param[in]   pixm    [optional] 1 bpp mask; no operation if null</param>
''' <param name="val"> \param[in]   val     value to set at each masked pixel</param>
''' <param name="x"> \param[in]   x, y    location of UL corner of pixm relative to pixd;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetMaskedGeneral")> _
Friend Shared Function pixSetMaskedGeneral(pixd as IntPTR, pixm as IntPTR, val as UInteger, x as Integer, y as Integer) as Integer
End Function

' SRC\pix3.c (374, 1)
' pixCombineMasked()
' pixCombineMasked(PIX *, PIX *, PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) In-place operation; pixd is changed.
'''  *   (2) This sets each pixel in pixd that co-locates with an ON
'''  * pixel in pixm to the corresponding value of pixs.
'''  *   (3) pixs and pixd must be the same depth and not colormapped.
'''  *   (4) All three input pix are aligned at the UL corner, and the
'''  * operation is clipped to the intersection of all three images.
'''  *   (5) If pixm == NULL, it's a no-op.
'''  *   (6) Implementation: see notes in pixCombineMaskedGeneral().
'''  * For 8 bpp selective masking, you might guess that it
'''  * would be faster to generate an 8 bpp version of pixm,
'''  * using pixConvert1To8(pixm, 0, 255), and then use a
'''  * general combine operation
'''  *   d = (d & ~m) | (s & m)
'''  * on a word-by-word basis.  Not always.  The word-by-word
'''  * combine takes a time that is independent of the mask data.
'''  * If the mask is relatively sparse, the byte-check method
'''  * is actually faster!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]   pixd   1 bpp, 8 bpp gray or 32 bpp rgb; no cmap</param>
''' <param name="pixs"> \param[in]   pixs   1 bpp, 8 bpp gray or 32 bpp rgb; no cmap</param>
''' <param name="pixm"> \param[in]   pixm   [optional] 1 bpp mask; no operation if NULL</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCombineMasked")> _
Friend Shared Function pixCombineMasked(pixd as IntPTR, pixs as IntPTR, pixm as IntPTR) as Integer
End Function

' SRC\pix3.c (493, 1)
' pixCombineMaskedGeneral()
' pixCombineMaskedGeneral(PIX *, PIX *, PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) In-place operation; pixd is changed.
'''  *   (2) This is a generalized version of pixCombinedMasked(), where
'''  * the source and mask can be placed at the same (arbitrary)
'''  * location relative to pixd.
'''  *   (3) pixs and pixd must be the same depth and not colormapped.
'''  *   (4) The UL corners of both pixs and pixm are aligned with
'''  * the point (x, y) of pixd, and the operation is clipped to
'''  * the intersection of all three images.
'''  *   (5) If pixm == NULL, it's a no-op.
'''  *   (6) Implementation.  There are two ways to do these.  In the first,
'''  * we use rasterop, ORing the part of pixs under the mask
'''  * with pixd (which has been appropriately cleared there first).
'''  * In the second, the mask is used one pixel at a time to
'''  * selectively replace pixels of pixd with those of pixs.
'''  * Here, we use rasterop for 1 bpp and pixel-wise replacement
'''  * for 8 and 32 bpp.  To use rasterop for 8 bpp, for example,
'''  * we must first generate an 8 bpp version of the mask.
'''  * The code is simple:
'''  *
'''  * Pix *pixm8 = pixConvert1To8(NULL, pixm, 0, 255);
'''  * Pix *pixt = pixAnd(NULL, pixs, pixm8);
'''  * pixRasterop(pixd, x, y, wmin, hmin, PIX_DST & PIX_NOT(PIX_SRC),
'''  *    pixm8, 0, 0);
'''  * pixRasterop(pixd, x, y, wmin, hmin, PIX_SRC | PIX_DST,
'''  *    pixt, 0, 0);
'''  * pixDestroy(&pixt);
'''  * pixDestroy(&pixm8);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]   pixd   1 bpp, 8 bpp gray or 32 bpp rgb</param>
''' <param name="pixs"> \param[in]   pixs   1 bpp, 8 bpp gray or 32 bpp rgb</param>
''' <param name="pixm"> \param[in]   pixm   [optional] 1 bpp mask</param>
''' <param name="x"> \param[in]   x, y   origin of pixs and pixm relative to pixd; can be negative</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCombineMaskedGeneral")> _
Friend Shared Function pixCombineMaskedGeneral(pixd as IntPTR, pixs as IntPTR, pixm as IntPTR, x as Integer, y as Integer) as Integer
End Function

' SRC\pix3.c (618, 1)
' pixPaintThroughMask()
' pixPaintThroughMask(PIX *, PIX *, l_int32, l_int32, l_uint32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) In-place operation.  Calls pixSetMaskedCmap() for colormapped
'''  * images.
'''  *   (2) For 1, 2, 4, 8 and 16 bpp gray, we take the appropriate
'''  * number of least significant bits of val.
'''  *   (3) If pixm == NULL, it's a no-op.
'''  *   (4) The mask origin is placed at (x,y) on pixd, and the
'''  * operation is clipped to the intersection of rectangles.
'''  *   (5) For rgb, the components in val are in the canonical locations,
'''  * with red in location COLOR_RED, etc.
'''  *   (6) Implementation detail 1:
'''  * For painting with val == 0 or val == maxval, you can use rasterop.
'''  * If val == 0, invert the mask so that it's 0 over the region
'''  * into which you want to write, and use PIX_SRC & PIX_DST to
'''  * clear those pixels.  To write with val = maxval (all 1's),
'''  * use PIX_SRC | PIX_DST to set all bits under the mask.
'''  *   (7) Implementation detail 2:
'''  * The rasterop trick can be used for depth > 1 as well.
'''  * For val == 0, generate the mask for depth d from the binary
'''  * mask using
'''  *  pixmd = pixUnpackBinary(pixm, d, 1);
'''  * and use pixRasterop() with PIX_MASK.  For val == maxval,
'''  *  pixmd = pixUnpackBinary(pixm, d, 0);
'''  * and use pixRasterop() with PIX_PAINT.
'''  * But note that if d == 32 bpp, it is about 3x faster to use
'''  * the general implementation (not pixRasterop()).
'''  *   (8) Implementation detail 3:
'''  * It might be expected that the switch in the inner loop will
'''  * cause large branching delays and should be avoided.
'''  * This is not the case, because the entrance is always the
'''  * same and the compiler can correctly predict the jump.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]   pixd   1, 2, 4, 8, 16 or 32 bpp; or colormapped</param>
''' <param name="pixm"> \param[in]   pixm   [optional] 1 bpp mask</param>
''' <param name="x"> \param[in]   x, y   origin of pixm relative to pixd; can be negative</param>
''' <param name="y"> \param[in]   val    pixel value to set at each masked pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixPaintThroughMask")> _
Friend Shared Function pixPaintThroughMask(pixd as IntPTR, pixm as IntPTR, x as Integer, y as Integer, val as UInteger) as Integer
End Function

' SRC\pix3.c (786, 1)
' pixPaintSelfThroughMask()
' pixPaintSelfThroughMask(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) In-place operation; pixd is changed.
'''  *   (2) If pixm == NULL, it's a no-op.
'''  *   (3) The mask origin is placed at (x,y) on pixd, and the
'''  * operation is clipped to the intersection of pixd and the
'''  * fg of the mask.
'''  *   (4) %tsize is the the requested size for tiling.  The actual
'''  * actual size for each c.c. will be bounded by the minimum
'''  * dimension of the c.c.
'''  *   (5) For %mindist, %searchdir and %ntiles, see pixFindRepCloseTile().
'''  * They determine the set of possible tiles that can be used
'''  * to build a larger mirrored tile to paint onto pixd through
'''  * the c.c. of pixm.
'''  *   (6) %distblend is used for alpha blending.  It is only applied
'''  * if there is exactly one c.c. in the mask.  Use distblend == 0
'''  * to skip blending and just paint through the 1 bpp mask.
'''  *   (7) To apply blending to more than 1 component, call this function
'''  * repeatedly with %pixm, %x and %y representing one component of
'''  * the mask each time.  This would be done as follows, for an
'''  * underlying image pixs and mask pixm of components to fill:
'''  *  Boxa *boxa = pixConnComp(pixm, &pixa, 8);
'''  *  n = boxaGetCount(boxa);
'''  *  for (i = 0; i  n; i++) {
'''  *   Pix *pix = pixaGetPix(pixa, i, L_CLONE);
'''  *   Box *box = pixaGetBox(pixa, i, L_CLONE);
'''  *   boxGetGeometry(box, &bx, &by, &bw, &bh);
'''  *   pixPaintSelfThroughMask(pixs, pix, bx, by, searchdir,
'''  *    mindist, tilesize, ntiles, distblend);
'''  *   pixDestroy(&pix);
'''  *   boxDestroy(&box);
'''  *  }
'''  *  pixaDestroy(&pixa);
'''  *  boxaDestroy(&boxa);
'''  *   (8) If no tiles can be found, this falls back to estimating the
'''  * color near the boundary of the region to be textured.
'''  *   (9) This can be used to replace the pixels in some regions of
'''  * an image by selected neighboring pixels.  The mask represents
'''  * the pixels to be replaced.  For each connected component in
'''  * the mask, this function selects up to two tiles of neighboring
'''  * pixels to be used for replacement of pixels represented by
'''  * the component (i.e., under the FG of that component in the mask).
'''  * After selection, mirror replication is used to generate an
'''  * image that is large enough to cover the component.  Alpha
'''  * blending can also be used outside of the component, but near the
'''  * edge, to blur the transition between painted and original pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]   pixd       8 bpp gray or 32 bpp rgb; not colormapped</param>
''' <param name="pixm"> \param[in]   pixm       1 bpp mask</param>
''' <param name="x"> \param[in]   x, y       origin of pixm relative to pixd; must not be negative</param>
''' <param name="y"> \param[in]   searchdir  L_HORIZ, L_VERT or L_BOTH_DIRECTIONS</param>
''' <param name="searchdir"> \param[in]   mindist    min distance of nearest tile edge to box; >= 0</param>
''' <param name="mindist"> \param[in]   tilesize   requested size for tiling; may be reduced</param>
''' <param name="tilesize"> \param[in]   ntiles     number of tiles tested in each row/column</param>
''' <param name="ntiles"> \param[in]   distblend  distance outside the fg used for blending with pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixPaintSelfThroughMask")> _
Friend Shared Function pixPaintSelfThroughMask(pixd as IntPTR, pixm as IntPTR, x as Integer, y as Integer, searchdir as Integer, mindist as Integer, tilesize as Integer, ntiles as Integer, distblend as Integer) as Integer
End Function

' SRC\pix3.c (943, 1)
' pixMakeMaskFromVal()
' pixMakeMaskFromVal(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This generates a 1 bpp mask image, where a 1 is written in
'''  * the mask for each pixel in pixs that has a value %val.
'''  *   (2) If no pixels have the value, an empty mask is generated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp mask, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs   2, 4 or 8 bpp; can be colormapped</param>
''' <param name="val"> \param[in]   val    pixel value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMakeMaskFromVal")> _
Friend Shared Function pixMakeMaskFromVal(pixs as IntPTR, val as Integer) as IntPTR
End Function

' SRC\pix3.c (1000, 1)
' pixMakeMaskFromLUT()
' pixMakeMaskFromLUT(PIX *, l_int32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This generates a 1 bpp mask image, where a 1 is written in
'''  * the mask for each pixel in pixs that has a value corresponding
'''  * to a 1 in the LUT.
'''  *   (2) The LUT should be of size 256.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp mask, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs   2, 4 or 8 bpp; can be colormapped</param>
''' <param name="tab"> \param[in]   tab    256-entry LUT; 1 means to write to mask</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMakeMaskFromLUT")> _
Friend Shared Function pixMakeMaskFromLUT(pixs as IntPTR, tab as Integer) as IntPTR
End Function

' SRC\pix3.c (1069, 1)
' pixMakeArbMaskFromRGB()
' pixMakeArbMaskFromRGB(PIX *, l_float32, l_float32, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This generates a 1 bpp mask image, where a 1 is written in
'''  * the mask for each pixel in pixs that satisfies
'''  *   rc * rval + gc * gval + bc * bval > thresh
'''  * where rval is the red component, etc.
'''  *   (2) Unlike with pixConvertToGray(), there are no constraints
'''  * on the color coefficients, which can be negative.  For
'''  * example, a mask that discriminates against red and in favor
'''  * of blue will have rc  0.0 and bc > 0.0.
'''  *   (3) To make the result independent of intensity (the 'V' in HSV),
'''  * select coefficients so that %thresh = 0.  Then the result
'''  * is not changed when all components are multiplied by the
'''  * same constant (as long as nothing saturates).  This can be
'''  * useful if, for example, the illumination is not uniform.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp mask, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs         32 bpp RGB</param>
''' <param name="rc"> \param[in]   rc, gc, bc   arithmetic factors; can be negative</param>
''' <param name="gc"> \param[in]   thresh       lower threshold on weighted sum of components</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMakeArbMaskFromRGB")> _
Friend Shared Function pixMakeArbMaskFromRGB(pixs as IntPTR, rc as single, gc as single, bc as single, thresh as single) as IntPTR
End Function

' SRC\pix3.c (1146, 1)
' pixSetUnderTransparency()
' pixSetUnderTransparency(PIX *, l_uint32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This sets the r, g and b components under every fully
'''  * transparent alpha component to %val.  The alpha components
'''  * are unchanged.
'''  *   (2) Full transparency is denoted by alpha == 0.  Setting
'''  * all pixels to a constant %val where alpha is transparent
'''  * can improve compressibility by reducing the entropy.
'''  *   (3) The visual result depends on how the image is displayed.
'''  * (a) For display devices that respect the use of the alpha
'''  *  layer, this will not affect the appearance.
'''  * (b) For typical leptonica operations, alpha is ignored,
'''  *  so there will be a change in appearance because this
'''  *  resets the rgb values in the fully transparent region.
'''  *   (4) pixRead() and pixWrite() will, by default, read and write
'''  * 4-component (rgba) pix in png format.  To ignore the alpha
'''  * component after reading, or omit it on writing, pixSetSpp(..., 3).
'''  *   (5) Here are some examples:
'''  * * To convert all fully transparent pixels in a 4 component
'''  *   (rgba) png file to white:
'''  *  pixs = pixRead(infile>);
'''  *  pixd = pixSetUnderTransparency(pixs, 0xffffff00, 0);
'''  * * To write pixd with the alpha component:
'''  *  pixWrite(outfile>, pixd, IFF_PNG);
'''  * * To write and rgba image without the alpha component, first do:
'''  *  pixSetSpp(pixd, 3);
'''  *   If you later want to use the alpha, spp must be reset to 4.
'''  * * (fancier) To remove the alpha by blending the image over
'''  *   a white background:
'''  *  pixRemoveAlpha()
'''  *   This changes all pixel values where the alpha component is
'''  *   not opaque (255).
'''  *   (6) Caution.  rgb images in leptonica typically have value 0 in
'''  * the alpha channel, which is fully transparent.  If spp for
'''  * such an image were changed from 3 to 4, the image becomes
'''  * fully transparent, and this function will set each pixel to %val.
'''  * If you really want to set every pixel to the same value,
'''  * use pixSetAllArbitrary().
'''  *   (7) This is useful for compressing an RGBA image where the part
'''  * of the image that is fully transparent is random junk; compression
'''  * is typically improved by setting that region to a constant.
'''  * For rendering as a 3 component RGB image over a uniform
'''  * background of arbitrary color, use pixAlphaBlendUniform().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp rgba, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs    32 bpp rgba</param>
''' <param name="val"> \param[in]   val     32 bit unsigned color to use where alpha == 0</param>
''' <param name="debug"> \param[in]   debug   displays layers of pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetUnderTransparency")> _
Friend Shared Function pixSetUnderTransparency(pixs as IntPTR, val as UInteger, debug as Integer) as IntPTR
End Function

' SRC\pix3.c (1222, 1)
' pixMakeAlphaFromMask()
' pixMakeAlphaFromMask(PIX *, l_int32, BOX **) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This generates a 8 bpp alpha layer that is opaque (256)
'''  * over the FG of pixs, and goes transparent linearly away
'''  * from the FG pixels, decaying to 0 (transparent) is an
'''  * 8-connected distance given by %dist.  If %dist == 0,
'''  * this does a simple conversion from 1 to 8 bpp.
'''  *   (2) If &box == NULL, this returns an alpha mask that is the
'''  * full size of pixs.  Otherwise, the returned mask pixd covers
'''  * just the FG pixels of pixs, expanded by %dist in each
'''  * direction (if possible), and the returned box gives the
'''  * location of the returned mask relative to pixs.
'''  *   (3) This is useful for painting through a mask and allowing
'''  * blending of the painted image with an underlying image
'''  * in the mask background for pixels near foreground mask pixels.
'''  * For example, with an underlying rgb image pix1, an overlaying
'''  * image rgb pix2, binary mask pixm, and dist > 0, this
'''  * blending is achieved with:
'''  *  pix3 = pixMakeAlphaFromMask(pixm, dist, &box);
'''  *  boxGetGeometry(box, &x, &y, NULL, NULL);
'''  *  pix4 = pixBlendWithGrayMask(pix1, pix2, pix3, x, y);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd (8 bpp gray, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   1 bpp</param>
''' <param name="dist"> \param[in]    dist   blending distance; typically 10 - 30</param>
''' <param name="pbox"> \param[out]   pbox   [optional] use NULL to get the full size</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMakeAlphaFromMask")> _
Friend Shared Function pixMakeAlphaFromMask(pixs as IntPTR, dist as Integer, pbox as Object) as IntPTR
End Function

' SRC\pix3.c (1291, 1)
' pixGetColorNearMaskBoundary()
' pixGetColorNearMaskBoundary(PIX *, PIX *, BOX *, l_int32, l_uint32 *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds the average color in a set of pixels that are
'''  * roughly a distance %dist from the c.c. boundary and in the
'''  * background of the mask image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="pixs"> \param[in]    pixs    32 bpp rgb</param>
''' <param name="pixm"> \param[in]    pixm    1 bpp mask, full image</param>
''' <param name="box"> \param[in]    box     region of mask; typically b.b. of a component</param>
''' <param name="dist"> \param[in]    dist    distance into BG from mask boundary to use</param>
''' <param name="pval"> \param[out]   pval    average pixel value</param>
''' <param name="debug"> \param[in]    debug   1 to output mask images</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetColorNearMaskBoundary")> _
Friend Shared Function pixGetColorNearMaskBoundary(pixs as IntPTR, pixm as IntPTR, box as IntPTR, dist as Integer, pval as UInteger, debug as Integer) as Integer
End Function

' SRC\pix3.c (1395, 1)
' pixInvert()
' pixInvert(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This inverts pixs, for all pixel depths.
'''  *   (2) There are 3 cases:
'''  *  (a) pixd == null,   ~src --> new pixd
'''  *  (b) pixd == pixs,   ~src --> src  (in-place)
'''  *  (c) pixd != pixs,   ~src --> input pixd
'''  *   (3) For clarity, if the case is known, use these patterns:
'''  *  (a) pixd = pixInvert(NULL, pixs);
'''  *  (b) pixInvert(pixs, pixs);
'''  *  (c) pixInvert(pixd, pixs);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]   pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]   pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixInvert")> _
Friend Shared Function pixInvert(pixd as IntPTR, pixs as IntPTR) as IntPTR
End Function

' SRC\pix3.c (1446, 1)
' pixOr()
' pixOr(PIX *, PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This gives the union of two images with equal depth,
'''  * aligning them to the the UL corner.  pixs1 and pixs2
'''  * need not have the same width and height.
'''  *   (2) There are 3 cases:
'''  *   (a) pixd == null,   (src1 | src2) --> new pixd
'''  *   (b) pixd == pixs1,  (src1 | src2) --> src1  (in-place)
'''  *   (c) pixd != pixs1,  (src1 | src2) --> input pixd
'''  *   (3) For clarity, if the case is known, use these patterns:
'''  *   (a) pixd = pixOr(NULL, pixs1, pixs2);
'''  *   (b) pixOr(pixs1, pixs1, pixs2);
'''  *   (c) pixOr(pixd, pixs1, pixs2);
'''  *   (4) The size of the result is determined by pixs1.
'''  *   (5) The depths of pixs1 and pixs2 must be equal.
'''  *   (6) Note carefully that the order of pixs1 and pixs2 only matters
'''  * for the in-place case.  For in-place, you must have
'''  * pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
'''  * result: the copy puts pixs1 image data in pixs2, and
'''  * the rasterop is then between pixs2 and pixs2 (a no-op).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]   pixd    [optional]; this can be null, equal to pixs1,</param>
''' <param name="pixs1"> \param[in]   pixs1   can be == pixd</param>
''' <param name="pixs2"> \param[in]   pixs2   must be != pixd</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixOr")> _
Friend Shared Function pixOr(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR) as IntPTR
End Function

' SRC\pix3.c (1510, 1)
' pixAnd()
' pixAnd(PIX *, PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This gives the intersection of two images with equal depth,
'''  * aligning them to the the UL corner.  pixs1 and pixs2
'''  * need not have the same width and height.
'''  *   (2) There are 3 cases:
'''  *   (a) pixd == null,   (src1 & src2) --> new pixd
'''  *   (b) pixd == pixs1,  (src1 & src2) --> src1  (in-place)
'''  *   (c) pixd != pixs1,  (src1 & src2) --> input pixd
'''  *   (3) For clarity, if the case is known, use these patterns:
'''  *   (a) pixd = pixAnd(NULL, pixs1, pixs2);
'''  *   (b) pixAnd(pixs1, pixs1, pixs2);
'''  *   (c) pixAnd(pixd, pixs1, pixs2);
'''  *   (4) The size of the result is determined by pixs1.
'''  *   (5) The depths of pixs1 and pixs2 must be equal.
'''  *   (6) Note carefully that the order of pixs1 and pixs2 only matters
'''  * for the in-place case.  For in-place, you must have
'''  * pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
'''  * result: the copy puts pixs1 image data in pixs2, and
'''  * the rasterop is then between pixs2 and pixs2 (a no-op).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]   pixd    [optional]; this can be null, equal to pixs1,</param>
''' <param name="pixs1"> \param[in]   pixs1   can be == pixd</param>
''' <param name="pixs2"> \param[in]   pixs2   must be != pixd</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAnd")> _
Friend Shared Function pixAnd(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR) as IntPTR
End Function

' SRC\pix3.c (1574, 1)
' pixXor()
' pixXor(PIX *, PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This gives the XOR of two images with equal depth,
'''  * aligning them to the the UL corner.  pixs1 and pixs2
'''  * need not have the same width and height.
'''  *   (2) There are 3 cases:
'''  *   (a) pixd == null,   (src1 ^ src2) --> new pixd
'''  *   (b) pixd == pixs1,  (src1 ^ src2) --> src1  (in-place)
'''  *   (c) pixd != pixs1,  (src1 ^ src2) --> input pixd
'''  *   (3) For clarity, if the case is known, use these patterns:
'''  *   (a) pixd = pixXor(NULL, pixs1, pixs2);
'''  *   (b) pixXor(pixs1, pixs1, pixs2);
'''  *   (c) pixXor(pixd, pixs1, pixs2);
'''  *   (4) The size of the result is determined by pixs1.
'''  *   (5) The depths of pixs1 and pixs2 must be equal.
'''  *   (6) Note carefully that the order of pixs1 and pixs2 only matters
'''  * for the in-place case.  For in-place, you must have
'''  * pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
'''  * result: the copy puts pixs1 image data in pixs2, and
'''  * the rasterop is then between pixs2 and pixs2 (a no-op).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]   pixd    [optional]; this can be null, equal to pixs1,</param>
''' <param name="pixs1"> \param[in]   pixs1   can be == pixd</param>
''' <param name="pixs2"> \param[in]   pixs2   must be != pixd</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixXor")> _
Friend Shared Function pixXor(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR) as IntPTR
End Function

' SRC\pix3.c (1639, 1)
' pixSubtract()
' pixSubtract(PIX *, PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This gives the set subtraction of two images with equal depth,
'''  * aligning them to the the UL corner.  pixs1 and pixs2
'''  * need not have the same width and height.
'''  *   (2) Source pixs2 is always subtracted from source pixs1.
'''  * The result is
'''  *   pixs1 \ pixs2 = pixs1 & (~pixs2)
'''  *   (3) There are 4 cases:
'''  *   (a) pixd == null,   (src1 - src2) --> new pixd
'''  *   (b) pixd == pixs1,  (src1 - src2) --> src1  (in-place)
'''  *   (c) pixd == pixs2,  (src1 - src2) --> src2  (in-place)
'''  *   (d) pixd != pixs1 && pixd != pixs2),
'''  *   (src1 - src2) --> input pixd
'''  *   (4) For clarity, if the case is known, use these patterns:
'''  *   (a) pixd = pixSubtract(NULL, pixs1, pixs2);
'''  *   (b) pixSubtract(pixs1, pixs1, pixs2);
'''  *   (c) pixSubtract(pixs2, pixs1, pixs2);
'''  *   (d) pixSubtract(pixd, pixs1, pixs2);
'''  *   (5) The size of the result is determined by pixs1.
'''  *   (6) The depths of pixs1 and pixs2 must be equal.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]   pixd    [optional]; this can be null, equal to pixs1,</param>
''' <param name="pixs1"> \param[in]   pixs1   can be == pixd</param>
''' <param name="pixs2"> \param[in]   pixs2   can be == pixd</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSubtract")> _
Friend Shared Function pixSubtract(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR) as IntPTR
End Function

' SRC\pix3.c (1701, 1)
' pixZero()
' pixZero(PIX *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For a binary image, if there are no fg (black) pixels, empty = 1.
'''  *   (2) For a grayscale image, if all pixels are black (0), empty = 1.
'''  *   (3) For an RGB image, if all 4 components in every pixel is 0,
'''  * empty = 1.
'''  *   (4) For a colormapped image, pixel values are 0.  The colormap
'''  * is ignored.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix     all depths; colormap OK</param>
''' <param name="pempty"> \param[out]   pempty  1 if all bits in image data field are 0; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixZero")> _
Friend Shared Function pixZero(pix as IntPTR, pempty as Integer) as Integer
End Function

' SRC\pix3.c (1751, 1)
' pixForegroundFraction()
' pixForegroundFraction(PIX *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix      1 bpp</param>
''' <param name="pfract"> \param[out]   pfract   fraction of ON pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixForegroundFraction")> _
Friend Shared Function pixForegroundFraction(pix as IntPTR, pfract as single) as Integer
End Function

' SRC\pix3.c (1778, 1)
' pixaCountPixels()
' pixaCountPixels(PIXA *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of ON pixels in each pix, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa    array of 1 bpp pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaCountPixels")> _
Friend Shared Function pixaCountPixels(pixa as IntPTR) as IntPTR
End Function

' SRC\pix3.c (1823, 1)
' pixCountPixels()
' pixCountPixels(PIX *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     1 bpp</param>
''' <param name="pcount"> \param[out]   pcount   count of ON pixels</param>
''' <param name="tab8"> \param[in]    tab8     [optional] 8-bit pixel lookup table</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCountPixels")> _
Friend Shared Function pixCountPixels(pixs as IntPTR, pcount as Integer, tab8 as Integer) as Integer
End Function

' SRC\pix3.c (1887, 1)
' pixCountPixelsInRect()
' pixCountPixelsInRect(PIX *, BOX *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     1 bpp</param>
''' <param name="box"> \param[in]    box      (can be null)</param>
''' <param name="pcount"> \param[out]   pcount   count of ON pixels</param>
''' <param name="tab8"> \param[in]    tab8     [optional] 8-bit pixel lookup table</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCountPixelsInRect")> _
Friend Shared Function pixCountPixelsInRect(pixs as IntPTR, box as IntPTR, pcount as Integer, tab8 as Integer) as Integer
End Function

' SRC\pix3.c (1931, 1)
' pixCountByRow()
' pixCountByRow(PIX *, BOX *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) To resample for a bin size different from 1, use
'''  * numaUniformSampling() on the result of this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of number of ON pixels by row, or NULL on error</returns>
''' <param name="pix"> \param[in]   pix   1 bpp</param>
''' <param name="box"> \param[in]   box   [optional] clipping box for count; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCountByRow")> _
Friend Shared Function pixCountByRow(pix as IntPTR, box as IntPTR) as IntPTR
End Function

' SRC\pix3.c (1983, 1)
' pixCountByColumn()
' pixCountByColumn(PIX *, BOX *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) To resample for a bin size different from 1, use
'''  * numaUniformSampling() on the result of this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of number of ON pixels by column, or NULL on error</returns>
''' <param name="pix"> \param[in]   pix   1 bpp</param>
''' <param name="box"> \param[in]   box   [optional] clipping box for count; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCountByColumn")> _
Friend Shared Function pixCountByColumn(pix as IntPTR, box as IntPTR) as IntPTR
End Function

' SRC\pix3.c (2029, 1)
' pixCountPixelsByRow()
' pixCountPixelsByRow(PIX *, l_int32 *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of counts, or NULL on error</returns>
''' <param name="pix"> \param[in]   pix   1 bpp</param>
''' <param name="tab8"> \param[in]   tab8  [optional] 8-bit pixel lookup table</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCountPixelsByRow")> _
Friend Shared Function pixCountPixelsByRow(pix as IntPTR, tab8 as Integer) as IntPTR
End Function

' SRC\pix3.c (2063, 1)
' pixCountPixelsByColumn()
' pixCountPixelsByColumn(PIX *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of counts in each column, or NULL on error</returns>
''' <param name="pix"> \param[in]   pix   1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCountPixelsByColumn")> _
Friend Shared Function pixCountPixelsByColumn(pix as IntPTR) as IntPTR
End Function

' SRC\pix3.c (2104, 1)
' pixCountPixelsInRow()
' pixCountPixelsInRow(PIX *, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix     1 bpp</param>
''' <param name="row"> \param[in]    row     number</param>
''' <param name="pcount"> \param[out]   pcount  sum of ON pixels in raster line</param>
''' <param name="tab8"> \param[in]    tab8    [optional] 8-bit pixel lookup table</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCountPixelsInRow")> _
Friend Shared Function pixCountPixelsInRow(pix as IntPTR, row as Integer, pcount as Integer, tab8 as Integer) as Integer
End Function

' SRC\pix3.c (2167, 1)
' pixGetMomentByColumn()
' pixGetMomentByColumn(PIX *, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of first moment of fg pixels, by column, or NULL on error</returns>
''' <param name="pix"> \param[in]   pix     1 bpp</param>
''' <param name="order"> \param[in]   order   of moment, either 1 or 2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetMomentByColumn")> _
Friend Shared Function pixGetMomentByColumn(pix as IntPTR, order as Integer) as IntPTR
End Function

' SRC\pix3.c (2225, 1)
' pixThresholdPixelSum()
' pixThresholdPixelSum(PIX *, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This sums the ON pixels and returns immediately if the count
'''  * goes above threshold.  It is therefore more efficient
'''  * for matching images (by running this function on the xor of
'''  * the 2 images) than using pixCountPixels(), which counts all
'''  * pixels before returning.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix      1 bpp</param>
''' <param name="thresh"> \param[in]    thresh   threshold</param>
''' <param name="pabove"> \param[out]   pabove   1 if above threshold;</param>
''' <param name="tab8"> \param[in]    tab8     [optional] 8-bit pixel lookup table</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixThresholdPixelSum")> _
Friend Shared Function pixThresholdPixelSum(pix as IntPTR, thresh as Integer, pabove as Integer, tab8 as Integer) as Integer
End Function

' SRC\pix3.c (2297, 1)
' makePixelSumTab8()
' makePixelSumTab8() as l_int32 *
''' <summary>
''' * Notes:
'''  *   (1) This table of integers gives the number of 1 bits
'''  * in the 8 bit index.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  table of 256 l_int32, or NULL on error</returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makePixelSumTab8")> _
Friend Shared Function makePixelSumTab8() as String
End Function

' SRC\pix3.c (2342, 1)
' makePixelCentroidTab8()
' makePixelCentroidTab8() as l_int32 *
''' <summary>
''' * Notes:
'''  *   (1) This table of integers gives the centroid weight of the 1 bits
'''  * in the 8 bit index.  In other words, if sumtab is obtained by
'''  * makePixelSumTab8, and centroidtab is obtained by
'''  * makePixelCentroidTab8, then, for 1 = i = 255,
'''  * centroidtab[i] / (float)sumtab[i]
'''  * is the centroid of the 1 bits in the 8-bit index i, where the
'''  * MSB is considered to have position 0 and the LSB is considered
'''  * to have position 7.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  table of 256 l_int32, or NULL on error</returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makePixelCentroidTab8")> _
Friend Shared Function makePixelCentroidTab8() as String
End Function

' SRC\pix3.c (2400, 1)
' pixAverageByRow()
' pixAverageByRow(PIX *, BOX *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) To resample for a bin size different from 1, use
'''  * numaUniformSampling() on the result of this function.
'''  *   (2) If type == L_BLACK_IS_MAX, black pixels get the maximum
'''  * value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of pixel averages by row, or NULL on error</returns>
''' <param name="pix"> \param[in]   pix    8 or 16 bpp; no colormap</param>
''' <param name="box"> \param[in]   box    [optional] clipping box for sum; can be null</param>
''' <param name="type"> \param[in]   type   L_WHITE_IS_MAX, L_BLACK_IS_MAX</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAverageByRow")> _
Friend Shared Function pixAverageByRow(pix as IntPTR, box as IntPTR, type as Integer) as IntPTR
End Function

' SRC\pix3.c (2469, 1)
' pixAverageByColumn()
' pixAverageByColumn(PIX *, BOX *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) To resample for a bin size different from 1, use
'''  * numaUniformSampling() on the result of this function.
'''  *   (2) If type == L_BLACK_IS_MAX, black pixels get the maximum
'''  * value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of pixel averages by column, or NULL on error</returns>
''' <param name="pix"> \param[in]   pix   8 or 16 bpp; no colormap</param>
''' <param name="box"> \param[in]   box   [optional] clipping box for sum; can be null</param>
''' <param name="type"> \param[in]   type  L_WHITE_IS_MAX, L_BLACK_IS_MAX</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAverageByColumn")> _
Friend Shared Function pixAverageByColumn(pix as IntPTR, box as IntPTR, type as Integer) as IntPTR
End Function

' SRC\pix3.c (2534, 1)
' pixAverageInRect()
' pixAverageInRect(PIX *, BOX *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix   1, 2, 4, 8 bpp; not cmapped</param>
''' <param name="box"> \param[in]    box   [optional] if null, use entire image</param>
''' <param name="pave"> \param[out]   pave  average of pixel values in region</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAverageInRect")> _
Friend Shared Function pixAverageInRect(pix as IntPTR, box as IntPTR, pave as single) as Integer
End Function

' SRC\pix3.c (2600, 1)
' pixVarianceByRow()
' pixVarianceByRow(PIX *, BOX *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) To resample for a bin size different from 1, use
'''  * numaUniformSampling() on the result of this function.
'''  *   (2) We are actually computing the RMS deviation in each row.
'''  * This is the square root of the variance.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of rmsdev by row, or NULL on error</returns>
''' <param name="pix"> \param[in]   pix   8 or 16 bpp; no colormap</param>
''' <param name="box"> \param[in]   box   [optional] clipping box for variance; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixVarianceByRow")> _
Friend Shared Function pixVarianceByRow(pix as IntPTR, box as IntPTR) as IntPTR
End Function

' SRC\pix3.c (2665, 1)
' pixVarianceByColumn()
' pixVarianceByColumn(PIX *, BOX *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) To resample for a bin size different from 1, use
'''  * numaUniformSampling() on the result of this function.
'''  *   (2) We are actually computing the RMS deviation in each row.
'''  * This is the square root of the variance.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of rmsdev by column, or NULL on error</returns>
''' <param name="pix"> \param[in]   pix   8 or 16 bpp; no colormap</param>
''' <param name="box"> \param[in]   box   [optional] clipping box for variance; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixVarianceByColumn")> _
Friend Shared Function pixVarianceByColumn(pix as IntPTR, box as IntPTR) as IntPTR
End Function

' SRC\pix3.c (2723, 1)
' pixVarianceInRect()
' pixVarianceInRect(PIX *, BOX *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix       1, 2, 4, 8 bpp; not cmapped</param>
''' <param name="box"> \param[in]    box       [optional] if null, use entire image</param>
''' <param name="prootvar"> \param[out]   prootvar  sqrt variance of pixel values in region</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixVarianceInRect")> _
Friend Shared Function pixVarianceInRect(pix as IntPTR, box as IntPTR, prootvar as single) as Integer
End Function

' SRC\pix3.c (2800, 1)
' pixAbsDiffByRow()
' pixAbsDiffByRow(PIX *, BOX *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This is an average over differences of adjacent pixels along
'''  * each row.
'''  *   (2) To resample for a bin size different from 1, use
'''  * numaUniformSampling() on the result of this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of abs val pixel difference averages by row, or NULL on error</returns>
''' <param name="pix"> \param[in]   pix   8 bpp; no colormap</param>
''' <param name="box"> \param[in]   box   [optional] clipping box for region; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAbsDiffByRow")> _
Friend Shared Function pixAbsDiffByRow(pix as IntPTR, box as IntPTR) as IntPTR
End Function

' SRC\pix3.c (2861, 1)
' pixAbsDiffByColumn()
' pixAbsDiffByColumn(PIX *, BOX *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This is an average over differences of adjacent pixels along
'''  * each column.
'''  *   (2) To resample for a bin size different from 1, use
'''  * numaUniformSampling() on the result of this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of abs val pixel difference averages by column,</returns>
''' <param name="pix"> \param[in]   pix   8 bpp; no colormap</param>
''' <param name="box"> \param[in]   box   [optional] clipping box for region; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAbsDiffByColumn")> _
Friend Shared Function pixAbsDiffByColumn(pix as IntPTR, box as IntPTR) as IntPTR
End Function

' SRC\pix3.c (2924, 1)
' pixAbsDiffInRect()
' pixAbsDiffInRect(PIX *, BOX *, l_int32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This gives the average over the abs val of differences of
'''  * adjacent pixels values, along either each
'''  * row:  dir == L_HORIZONTAL_LINE
'''  * column:  dir == L_VERTICAL_LINE
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]   pix       8 bpp; not cmapped</param>
''' <param name="box"> \param[in]   box       [optional] if null, use entire image</param>
''' <param name="dir"> \param[in]   dir       differences along L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
''' <param name="pabsdiff"> \param[out]  pabsdiff  average of abs diff pixel values in region</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAbsDiffInRect")> _
Friend Shared Function pixAbsDiffInRect(pix as IntPTR, box as IntPTR, dir as Integer, pabsdiff as single) as Integer
End Function

' SRC\pix3.c (3001, 1)
' pixAbsDiffOnLine()
' pixAbsDiffOnLine(PIX *, l_int32, l_int32, l_int32, l_int32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This gives the average over the abs val of differences of
'''  * adjacent pixels values, along a line that is either horizontal
'''  * or vertical.
'''  *   (2) If horizontal, require x1  x2; if vertical, require y1  y2.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix        8 bpp; not cmapped</param>
''' <param name="x1"> \param[in]    x1, y1     first point; x1 <= x2, y1 <= y2</param>
''' <param name="y1"> \param[in]    x2, y2     first point</param>
''' <param name="x2"> \param[out]   pabsdiff   average of abs diff pixel values on line</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAbsDiffOnLine")> _
Friend Shared Function pixAbsDiffOnLine(pix as IntPTR, x1 as Integer, y1 as Integer, x2 as Integer, y2 as Integer, pabsdiff as single) as Integer
End Function

' SRC\pix3.c (3083, 1)
' pixCountArbInRect()
' pixCountArbInRect(PIX *, BOX *, l_int32, l_int32, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) If pixs is cmapped, %val is compared to the colormap index;
'''  * otherwise, %val is compared to the grayscale value.
'''  *   (2) Set the subsampling %factor > 1 to reduce the amount of computation.
'''  * If %factor > 1, multiply the count by %factor * %factor.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na histogram, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     8 bpp, or colormapped</param>
''' <param name="box"> \param[in]    box      [optional] over which count is made;</param>
''' <param name="val"> \param[in]    val      pixel value to count</param>
''' <param name="factor"> \param[in]    factor   subsampling factor; integer >= 1</param>
''' <param name="pcount"> \param[out]   pcount   count; estimate it if factor > 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCountArbInRect")> _
Friend Shared Function pixCountArbInRect(pixs as IntPTR, box as IntPTR, val as Integer, factor as Integer, pcount as Integer) as Integer
End Function

' SRC\pix3.c (3161, 1)
' pixMirroredTiling()
' pixMirroredTiling(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This uses mirrored tiling, where each row alternates
'''  * with LR flips and every column alternates with TB
'''  * flips, such that the result is a tiling with identical
'''  * 2 x 2 tiles, each of which is composed of these transforms:
'''  *   -----------------
'''  *   | 1 |  LR |
'''  *   -----------------
'''  *   | TB   |  LR/TB |
'''  *   -----------------
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd usually larger pix, mirror-tiled with pixs,</returns>
''' <param name="pixs"> \param[in]   pixs   8 or 32 bpp, small tile; to be replicated</param>
''' <param name="w"> \param[in]   w, h   dimensions of output pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMirroredTiling")> _
Friend Shared Function pixMirroredTiling(pixs as IntPTR, w as Integer, h as Integer) as IntPTR
End Function

' SRC\pix3.c (3236, 1)
' pixFindRepCloseTile()
' pixFindRepCloseTile(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, BOX **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This looks for one or two square tiles with conforming median
'''  * intensity and low variance, that is outside but near the input box.
'''  *   (2) %mindist specifies the gap between the box and the
'''  * potential tiles.  The tiles are given an overlap of 50%.
'''  * %ntiles specifies the number of tiles that are tested
'''  * beyond %mindist for each row or column.
'''  *   (3) For example, if %mindist = 20, %tilesize = 50 and %ntiles = 3,
'''  * a horizontal search to the right will have 3 tiles in each row,
'''  * with left edges at 20, 45 and 70 from the right edge of the
'''  * input %box.  The number of rows of tiles is determined by
'''  * the height of %box and %tsize, with the 50% overlap..
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs       32 bpp rgb</param>
''' <param name="box"> \param[in]    box        region of pixs to search around</param>
''' <param name="searchdir"> \param[in]    searchdir  L_HORIZ or L_VERT; direction to search</param>
''' <param name="mindist"> \param[in]    mindist    min distance of selected tile edge from box; >= 0</param>
''' <param name="tsize"> \param[in]    tsize      tile size; > 1; even; typically ~50</param>
''' <param name="ntiles"> \param[in]    ntiles     number of tiles tested in each row/column</param>
''' <param name="pboxtile"> \param[out]   pboxtile   region of best tile</param>
''' <param name="debug"> \param[in]    debug 1    for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindRepCloseTile")> _
Friend Shared Function pixFindRepCloseTile(pixs as IntPTR, box as IntPTR, searchdir as Integer, mindist as Integer, tsize as Integer, ntiles as Integer, pboxtile as Object, debug as Integer) as Integer
End Function

#End Region
#Region "SRC\pix4.c"
' SRC\pix4.c (109, 1)
' pixGetGrayHistogram()
' pixGetGrayHistogram(PIX *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) If pixs has a colormap, it is converted to 8 bpp gray.
'''  * If you want a histogram of the colormap indices, use
'''  * pixGetCmapHistogram().
'''  *   (2) If pixs does not have a colormap, the output histogram is
'''  * of size 2^d, where d is the depth of pixs.
'''  *   (3) Set the subsampling factor > 1 to reduce the amount of computation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na histogram, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs     1, 2, 4, 8, 16 bpp; can be colormapped</param>
''' <param name="factor"> \param[in]   factor   subsampling factor; integer >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetGrayHistogram")> _
Friend Shared Function pixGetGrayHistogram(pixs as IntPTR, factor as Integer) as IntPTR
End Function

' SRC\pix4.c (205, 1)
' pixGetGrayHistogramMasked()
' pixGetGrayHistogramMasked(PIX *, PIX *, l_int32, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) If pixs is cmapped, it is converted to 8 bpp gray.
'''  * If you want a histogram of the colormap indices, use
'''  * pixGetCmapHistogramMasked().
'''  *   (2) This always returns a 256-value histogram of pixel values.
'''  *   (3) Set the subsampling factor > 1 to reduce the amount of computation.
'''  *   (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
'''  *   (5) Input x,y are ignored unless pixm exists.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na histogram, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs     8 bpp, or colormapped</param>
''' <param name="pixm"> \param[in]   pixm     [optional] 1 bpp mask over which histogram is</param>
''' <param name="x"> \param[in]   x, y     UL corner of pixm relative to the UL corner of pixs;</param>
''' <param name="y"> \param[in]   factor   subsampling factor; integer >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetGrayHistogramMasked")> _
Friend Shared Function pixGetGrayHistogramMasked(pixs as IntPTR, pixm as IntPTR, x as Integer, y as Integer, factor as Integer) as IntPTR
End Function

' SRC\pix4.c (285, 1)
' pixGetGrayHistogramInRect()
' pixGetGrayHistogramInRect(PIX *, BOX *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) If pixs is cmapped, it is converted to 8 bpp gray.
'''  * If you want a histogram of the colormap indices, use
'''  * pixGetCmapHistogramInRect().
'''  *   (2) This always returns a 256-value histogram of pixel values.
'''  *   (3) Set the subsampling %factor > 1 to reduce the amount of computation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na histogram, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs    8 bpp, or colormapped</param>
''' <param name="box"> \param[in]   box     [optional] over which histogram is to be computed;</param>
''' <param name="factor"> \param[in]   factor  subsampling factor; integer >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetGrayHistogramInRect")> _
Friend Shared Function pixGetGrayHistogramInRect(pixs as IntPTR, box as IntPTR, factor as Integer) as IntPTR
End Function

' SRC\pix4.c (353, 1)
' pixGetGrayHistogramTiled()
' pixGetGrayHistogramTiled(PIX *, l_int32, l_int32, l_int32) as NUMAA *
''' <summary>
''' * Notes:
'''  *   (1) If pixs is cmapped, it is converted to 8 bpp gray.
'''  *   (2) This returns a set of 256-value histograms of pixel values.
'''  *   (3) Set the subsampling factor > 1 to reduce the amount of computation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  naa set of histograms, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs     any depth, colormap OK</param>
''' <param name="factor"> \param[in]   factor   subsampling factor; integer >= 1</param>
''' <param name="nx"> \param[in]   nx, ny   tiling; >= 1; typically small</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetGrayHistogramTiled")> _
Friend Shared Function pixGetGrayHistogramTiled(pixs as IntPTR, factor as Integer, nx as Integer, ny as Integer) as IntPTR
End Function

' SRC\pix4.c (410, 1)
' pixGetColorHistogram()
' pixGetColorHistogram(PIX *, l_int32, NUMA **, NUMA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This generates a set of three 256 entry histograms,
'''  * one for each color component (r,g,b).
'''  *   (2) Set the subsampling %factor > 1 to reduce the amount of computation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     rgb or colormapped</param>
''' <param name="factor"> \param[in]    factor   subsampling factor; integer >= 1</param>
''' <param name="pnar"> \param[out]   pnar     red histogram</param>
''' <param name="pnag"> \param[out]   pnag     green histogram</param>
''' <param name="pnab"> \param[out]   pnab     blue histogram</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetColorHistogram")> _
Friend Shared Function pixGetColorHistogram(pixs as IntPTR, factor as Integer, pnar as Object, pnag as Object, pnab as Object) as Integer
End Function

' SRC\pix4.c (512, 1)
' pixGetColorHistogramMasked()
' pixGetColorHistogramMasked(PIX *, PIX *, l_int32, l_int32, l_int32, NUMA **, NUMA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This generates a set of three 256 entry histograms,
'''  *   (2) Set the subsampling %factor > 1 to reduce the amount of computation.
'''  *   (3) Clipping of pixm (if it exists) to pixs is done in the inner loop.
'''  *   (4) Input x,y are ignored unless pixm exists.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     32 bpp rgb, or colormapped</param>
''' <param name="pixm"> \param[in]    pixm     [optional] 1 bpp mask over which histogram is</param>
''' <param name="x"> \param[in]    x, y     UL corner of pixm relative to the UL corner of pixs;</param>
''' <param name="y"> \param[in]    factor   subsampling factor; integer >= 1</param>
''' <param name="factor"> \param[out]   pnar     red histogram</param>
''' <param name="pnar"> \param[out]   pnag     green histogram</param>
''' <param name="pnag"> \param[out]   pnab     blue histogram</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetColorHistogramMasked")> _
Friend Shared Function pixGetColorHistogramMasked(pixs as IntPTR, pixm as IntPTR, x as Integer, y as Integer, factor as Integer, pnar as Object, pnag as Object, pnab as Object) as Integer
End Function

' SRC\pix4.c (627, 1)
' pixGetCmapHistogram()
' pixGetCmapHistogram(PIX *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This generates a histogram of colormap pixel indices,
'''  * and is of size 2^d.
'''  *   (2) Set the subsampling %factor > 1 to reduce the amount of computation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na histogram of cmap indices, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs    colormapped: d = 2, 4 or 8</param>
''' <param name="factor"> \param[in]   factor  subsampling factor; integer >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetCmapHistogram")> _
Friend Shared Function pixGetCmapHistogram(pixs as IntPTR, factor as Integer) as IntPTR
End Function

' SRC\pix4.c (692, 1)
' pixGetCmapHistogramMasked()
' pixGetCmapHistogramMasked(PIX *, PIX *, l_int32, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This generates a histogram of colormap pixel indices,
'''  * and is of size 2^d.
'''  *   (2) Set the subsampling %factor > 1 to reduce the amount of computation.
'''  *   (3) Clipping of pixm to pixs is done in the inner loop.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na histogram, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs     colormapped: d = 2, 4 or 8</param>
''' <param name="pixm"> \param[in]   pixm     [optional] 1 bpp mask over which histogram is</param>
''' <param name="x"> \param[in]   x, y     UL corner of pixm relative to the UL corner of pixs;</param>
''' <param name="y"> \param[in]   factor   subsampling factor; integer >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetCmapHistogramMasked")> _
Friend Shared Function pixGetCmapHistogramMasked(pixs as IntPTR, pixm as IntPTR, x as Integer, y as Integer, factor as Integer) as IntPTR
End Function

' SRC\pix4.c (772, 1)
' pixGetCmapHistogramInRect()
' pixGetCmapHistogramInRect(PIX *, BOX *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This generates a histogram of colormap pixel indices,
'''  * and is of size 2^d.
'''  *   (2) Set the subsampling %factor > 1 to reduce the amount of computation.
'''  *   (3) Clipping to the box is done in the inner loop.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na histogram, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs     colormapped: d = 2, 4 or 8</param>
''' <param name="box"> \param[in]   box      [optional] over which histogram is to be computed;</param>
''' <param name="factor"> \param[in]   factor   subsampling factor; integer >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetCmapHistogramInRect")> _
Friend Shared Function pixGetCmapHistogramInRect(pixs as IntPTR, box as IntPTR, factor as Integer) as IntPTR
End Function

' SRC\pix4.c (831, 1)
' pixCountRGBColors()
' pixCountRGBColors(PIX *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ncolors, or -1 on error</returns>
''' <param name="pixs"> \param[in]    pixs    rgb or rgba</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCountRGBColors")> _
Friend Shared Function pixCountRGBColors(pixs as IntPTR) as Integer
End Function

' SRC\pix4.c (861, 1)
' pixGetColorAmapHistogram()
' pixGetColorAmapHistogram(PIX *, l_int32) as L_AMAP *
''' <summary>
''' * Notes:
'''  *   (1) This generates an ordered map from pixel value to histogram count.
'''  *   (2) Use amapGetCountForColor() to use the map to look up a count.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  amap, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs    rgb or rgba</param>
''' <param name="factor"> \param[in]   factor  subsampling factor; integer >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetColorAmapHistogram")> _
Friend Shared Function pixGetColorAmapHistogram(pixs as IntPTR, factor as Integer) as IntPTR
End Function

' SRC\pix4.c (910, 1)
' amapGetCountForColor()
' amapGetCountForColor(L_AMAP *, l_uint32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) The ordered map is made by pixGetColorAmapHistogram().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or -1 on error</returns>
''' <param name="amap"> \param[in]   amap   map from pixel value to count</param>
''' <param name="val"> \param[in]   val    rgb or rgba pixel value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="amapGetCountForColor")> _
Friend Shared Function amapGetCountForColor(amap as IntPTR, val as UInteger) as Integer
End Function

' SRC\pix4.c (945, 1)
' pixGetRankValue()
' pixGetRankValue(PIX *, l_int32, l_float32, l_uint32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Simple function to get rank values of an image.
'''  * For a color image, the median value (rank = 0.5) can be
'''  * used to linearly remap the colors based on the median
'''  * of a target image, using pixLinearMapToTargetColor().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     8 bpp, 32 bpp or colormapped</param>
''' <param name="factor"> \param[in]    factor   subsampling factor; integer >= 1</param>
''' <param name="rank"> \param[in]    rank     between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest</param>
''' <param name="pvalue"> \param[out]   pvalue   pixel value corresponding to input rank</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRankValue")> _
Friend Shared Function pixGetRankValue(pixs as IntPTR, factor as Integer, rank as single, pvalue as UInteger) as Integer
End Function

' SRC\pix4.c (1015, 1)
' pixGetRankValueMaskedRGB()
' pixGetRankValueMaskedRGB(PIX *, PIX *, l_int32, l_int32, l_int32, l_float32, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Computes the rank component values of pixels in pixs that
'''  * are under the fg of the optional mask.  If the mask is null, it
'''  * computes the average of the pixels in pixs.
'''  *   (2) Set the subsampling %factor > 1 to reduce the amount of
'''  * computation.
'''  *   (4) Input x,y are ignored unless pixm exists.
'''  *   (5) The rank must be in [0.0 ... 1.0], where the brightest pixel
'''  * has rank 1.0.  For the median pixel value, use 0.5.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     32 bpp</param>
''' <param name="pixm"> \param[in]    pixm     [optional] 1 bpp mask over which rank val is to be taken;</param>
''' <param name="x"> \param[in]    x, y     UL corner of pixm relative to the UL corner of pixs;</param>
''' <param name="y"> \param[in]    factor   subsampling factor; integer >= 1</param>
''' <param name="factor"> \param[in]    rank     between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest</param>
''' <param name="rank"> \param[out]   prval    [optional] red component val for input rank</param>
''' <param name="prval"> \param[out]   pgval    [optional] green component val for input rank</param>
''' <param name="pgval"> \param[out]   pbval    [optional] blue component val for input rank</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRankValueMaskedRGB")> _
Friend Shared Function pixGetRankValueMaskedRGB(pixs as IntPTR, pixm as IntPTR, x as Integer, y as Integer, factor as Integer, rank as single, prval as single, pgval as single, pbval as single) as Integer
End Function

' SRC\pix4.c (1107, 1)
' pixGetRankValueMasked()
' pixGetRankValueMasked(PIX *, PIX *, l_int32, l_int32, l_int32, l_float32, l_float32 *, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Computes the rank value of pixels in pixs that are under
'''  * the fg of the optional mask.  If the mask is null, it
'''  * computes the average of the pixels in pixs.
'''  *   (2) Set the subsampling %factor > 1 to reduce the amount of
'''  * computation.
'''  *   (3) Clipping of pixm (if it exists) to pixs is done in the inner loop.
'''  *   (4) Input x,y are ignored unless pixm exists.
'''  *   (5) The rank must be in [0.0 ... 1.0], where the brightest pixel
'''  * has rank 1.0.  For the median pixel value, use 0.5.
'''  *   (6) The histogram can optionally be returned, so that other rank
'''  * values can be extracted without recomputing the histogram.
'''  * In that case, just use
'''  *  numaHistogramGetValFromRank(na, rank, &val);
'''  * on the returned Numa for additional rank values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     8 bpp, or colormapped</param>
''' <param name="pixm"> \param[in]    pixm     [optional] 1 bpp mask, over which the rank val</param>
''' <param name="x"> \param[in]    x, y     UL corner of pixm relative to the UL corner of pixs;</param>
''' <param name="y"> \param[in]    factor   subsampling factor; integer >= 1</param>
''' <param name="factor"> \param[in]    rank     between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest</param>
''' <param name="rank"> \param[out]   pval     pixel value corresponding to input rank</param>
''' <param name="pval"> \param[out]   pna     [optional] of histogram</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRankValueMasked")> _
Friend Shared Function pixGetRankValueMasked(pixs as IntPTR, pixm as IntPTR, x as Integer, y as Integer, factor as Integer, rank as single, pval as single, pna as Object) as Integer
End Function

' SRC\pix4.c (1176, 1)
' pixGetPixelAverage()
' pixGetPixelAverage(PIX *, PIX *, l_int32, l_int32, l_int32, l_uint32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For rgb pix, this is a more direct computation of the
'''  * average value of the pixels in %pixs that are under the
'''  * mask %pixm. It is faster than pixGetPixelStats(), which
'''  * calls pixGetAverageMaskedRGB() and has the overhead of
'''  * generating a temporary pix of each of the three components;
'''  * this can take most of the time if %factor > 1.
'''  *   (2) If %pixm is null, this gives the average value of all
'''  * pixels in %pixs.  The returned value is an integer.
'''  *   (3) For color %pixs, the returned pixel value is in the standard
'''  * uint32 RGBA packing.
'''  *   (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
'''  *   (5) Input x,y are ignored if %pixm does not exist.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     8 or 32 bpp, or colormapped</param>
''' <param name="pixm"> \param[in]    pixm     [optional] 1 bpp mask over which average is</param>
''' <param name="x"> \param[in]    x, y     UL corner of pixm relative to the UL corner of pixs;</param>
''' <param name="y"> \param[in]    factor   subsampling factor; >= 1</param>
''' <param name="factor"> \param[out]   pval     average pixel value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetPixelAverage")> _
Friend Shared Function pixGetPixelAverage(pixs as IntPTR, pixm as IntPTR, x as Integer, y as Integer, factor as Integer, pval as UInteger) as Integer
End Function

' SRC\pix4.c (1294, 1)
' pixGetPixelStats()
' pixGetPixelStats(PIX *, l_int32, l_int32, l_uint32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Simple function to get one of four statistical values of an image.
'''  *   (2) It does not take a mask: it uses the entire image.
'''  *   (3) To get the average pixel value of an RGB image, suggest using
'''  * pixGetPixelAverage(), which is considerably faster.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     8 bpp, 32 bpp or colormapped</param>
''' <param name="factor"> \param[in]    factor   subsampling factor; integer >= 1</param>
''' <param name="type"> \param[in]    type     L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE,</param>
''' <param name="pvalue"> \param[out]   pvalue   pixel value corresponding to input type</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetPixelStats")> _
Friend Shared Function pixGetPixelStats(pixs as IntPTR, factor as Integer, type as Integer, pvalue as UInteger) as Integer
End Function

' SRC\pix4.c (1361, 1)
' pixGetAverageMaskedRGB()
' pixGetAverageMaskedRGB(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For usage, see pixGetAverageMasked().
'''  *   (2) If there is a colormap, it is removed before the 8 bpp
'''  * component images are extracted.
'''  *   (3) A better name for this would be: pixGetPixelStatsRGB()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     32 bpp, or colormapped</param>
''' <param name="pixm"> \param[in]    pixm     [optional] 1 bpp mask over which average is</param>
''' <param name="x"> \param[in]    x, y     UL corner of pixm relative to the UL corner of pixs;</param>
''' <param name="y"> \param[in]    factor   subsampling factor; >= 1</param>
''' <param name="factor"> \param[in]    type     L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE,</param>
''' <param name="type"> \param[out]   prval    [optional] measured red value of given 'type'</param>
''' <param name="prval"> \param[out]   pgval    [optional] measured green value of given 'type'</param>
''' <param name="pgval"> \param[out]   pbval    [optional] measured blue value of given 'type'</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetAverageMaskedRGB")> _
Friend Shared Function pixGetAverageMaskedRGB(pixs as IntPTR, pixm as IntPTR, x as Integer, y as Integer, factor as Integer, type as Integer, prval as single, pgval as single, pbval as single) as Integer
End Function

' SRC\pix4.c (1457, 1)
' pixGetAverageMasked()
' pixGetAverageMasked(PIX *, PIX *, l_int32, l_int32, l_int32, l_int32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Use L_MEAN_ABSVAL to get the average value of pixels in pixs
'''  * that are under the fg of the optional mask.  If the mask
'''  * is null, it finds the average of the pixels in pixs.
'''  *   (2) Likewise, use L_ROOT_MEAN_SQUARE to get the rms value of
'''  * pixels in pixs, either masked or not; L_STANDARD_DEVIATION
'''  * to get the standard deviation from the mean of the pixels;
'''  * L_VARIANCE to get the average squared difference from the
'''  * expected value.  The variance is the square of the stdev.
'''  * For the standard deviation, we use
'''  *  sqrt([([x] - x)]^2) = sqrt([x^2] - [x]^2)
'''  *   (3) Set the subsampling %factor > 1 to reduce the amount of
'''  * computation.
'''  *   (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
'''  *   (5) Input x,y are ignored unless pixm exists.
'''  *   (6) A better name for this would be: pixGetPixelStatsGray()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]   pixs     8 or 16 bpp, or colormapped</param>
''' <param name="pixm"> \param[in]   pixm     [optional] 1 bpp mask over which average is</param>
''' <param name="x"> \param[in]   x, y     UL corner of pixm relative to the UL corner of pixs;</param>
''' <param name="y"> \param[in]   factor   subsampling factor; >= 1</param>
''' <param name="factor"> \param[in]   type     L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE,</param>
''' <param name="type"> \param[out]  pval     measured value of given 'type'</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetAverageMasked")> _
Friend Shared Function pixGetAverageMasked(pixs as IntPTR, pixm as IntPTR, x as Integer, y as Integer, factor as Integer, type as Integer, pval as single) as Integer
End Function

' SRC\pix4.c (1576, 1)
' pixGetAverageTiledRGB()
' pixGetAverageTiledRGB(PIX *, l_int32, l_int32, l_int32, PIX **, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For usage, see pixGetAverageTiled().
'''  *   (2) If there is a colormap, it is removed before the 8 bpp
'''  * component images are extracted.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]   pixs     32 bpp, or colormapped</param>
''' <param name="sx"> \param[in]   sx, sy   tile size; must be at least 2 x 2</param>
''' <param name="sy"> \param[in]   type     L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION</param>
''' <param name="type"> \param[out]  ppixr    [optional] tiled 'average' of red component</param>
''' <param name="ppixr"> \param[out]  ppixg    [optional] tiled 'average' of green component</param>
''' <param name="ppixg"> \param[out]  ppixb    [optional] tiled 'average' of blue component</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetAverageTiledRGB")> _
Friend Shared Function pixGetAverageTiledRGB(pixs as IntPTR, sx as Integer, sy as Integer, type as Integer, ppixr as Object, ppixg as Object, ppixb as Object) as Integer
End Function

' SRC\pix4.c (1653, 1)
' pixGetAverageTiled()
' pixGetAverageTiled(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Only computes for tiles that are entirely contained in pixs.
'''  *   (2) Use L_MEAN_ABSVAL to get the average abs value within the tile;
'''  * L_ROOT_MEAN_SQUARE to get the rms value within each tile;
'''  * L_STANDARD_DEVIATION to get the standard dev. from the average
'''  * within each tile.
'''  *   (3) If colormapped, converts to 8 bpp gray.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd average values in each tile, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs    8 bpp, or colormapped</param>
''' <param name="sx"> \param[in]   sx, sy  tile size; must be at least 2 x 2</param>
''' <param name="sy"> \param[in]   type    L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetAverageTiled")> _
Friend Shared Function pixGetAverageTiled(pixs as IntPTR, sx as Integer, sy as Integer, type as Integer) as IntPTR
End Function

' SRC\pix4.c (1756, 1)
' pixRowStats()
' pixRowStats(PIX *, BOX *, NUMA **, NUMA **, NUMA **, NUMA **, NUMA **, NUMA **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This computes numas that represent column vectors of statistics,
'''  * with each of its values derived from the corresponding row of a Pix.
'''  *   (2) Use NULL on input to prevent computation of any of the 5 numas.
'''  *   (3) Other functions that compute pixel row statistics are:
'''  * pixCountPixelsByRow()
'''  * pixAverageByRow()
'''  * pixVarianceByRow()
'''  * pixGetRowStats()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na numa of requested statistic for each row, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs          8 bpp; not cmapped</param>
''' <param name="box"> \param[in]    box           [optional] clipping box; can be null</param>
''' <param name="pnamean"> \param[out]   pnamean       [optional] numa of mean values</param>
''' <param name="pnamedian"> \param[out]   pnamedian     [optional] numa of median values</param>
''' <param name="pnamode"> \param[out]   pnamode       [optional] numa of mode intensity values</param>
''' <param name="pnamodecount"> \param[out]   pnamodecount  [optional] numa of mode counts</param>
''' <param name="pnavar"> \param[out]   pnavar        [optional] numa of variance</param>
''' <param name="pnarootvar"> \param[out]   pnarootvar    [optional] numa of square root of variance</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRowStats")> _
Friend Shared Function pixRowStats(pixs as IntPTR, box as IntPTR, pnamean as Object, pnamedian as Object, pnamode as Object, pnamodecount as Object, pnavar as Object, pnarootvar as Object) as Integer
End Function

' SRC\pix4.c (1916, 1)
' pixColumnStats()
' pixColumnStats(PIX *, BOX *, NUMA **, NUMA **, NUMA **, NUMA **, NUMA **, NUMA **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This computes numas that represent row vectors of statistics,
'''  * with each of its values derived from the corresponding col of a Pix.
'''  *   (2) Use NULL on input to prevent computation of any of the 5 numas.
'''  *   (3) Other functions that compute pixel column statistics are:
'''  * pixCountPixelsByColumn()
'''  * pixAverageByColumn()
'''  * pixVarianceByColumn()
'''  * pixGetColumnStats()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na numa of requested statistic for each column,</returns>
''' <param name="pixs"> \param[in]    pixs          8 bpp; not cmapped</param>
''' <param name="box"> \param[in]    box           [optional] clipping box; can be null</param>
''' <param name="pnamean"> \param[out]   pnamean       [optional] numa of mean values</param>
''' <param name="pnamedian"> \param[out]   pnamedian     [optional] numa of median values</param>
''' <param name="pnamode"> \param[out]   pnamode       [optional] numa of mode intensity values</param>
''' <param name="pnamodecount"> \param[out]   pnamodecount  [optional] numa of mode counts</param>
''' <param name="pnavar"> \param[out]   pnavar        [optional] numa of variance</param>
''' <param name="pnarootvar"> \param[out]   pnarootvar    [optional] numa of square root of variance</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColumnStats")> _
Friend Shared Function pixColumnStats(pixs as IntPTR, box as IntPTR, pnamean as Object, pnamedian as Object, pnamode as Object, pnamodecount as Object, pnavar as Object, pnarootvar as Object) as Integer
End Function

' SRC\pix4.c (2063, 1)
' pixGetRangeValues()
' pixGetRangeValues(PIX *, l_int32, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If pixs is 8 bpp grayscale, the color selection type is ignored.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     8 bpp grayscale, 32 bpp rgb, or colormapped</param>
''' <param name="factor"> \param[in]    factor   subsampling factor; >= 1; ignored if colormapped</param>
''' <param name="color"> \param[in]    color    L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE</param>
''' <param name="pminval"> \param[out]   pminval  [optional] minimum value of component</param>
''' <param name="pmaxval"> \param[out]   pmaxval  [optional] maximum value of component</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRangeValues")> _
Friend Shared Function pixGetRangeValues(pixs as IntPTR, factor as Integer, color as Integer, pminval as Integer, pmaxval as Integer) as Integer
End Function

' SRC\pix4.c (2141, 1)
' pixGetExtremeValue()
' pixGetExtremeValue(PIX *, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If pixs is grayscale, the result is returned in &grayval.
'''  * Otherwise, if there is a colormap or d == 32,
'''  * each requested color component is returned.  At least
'''  * one color component (address) must be input.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs      8 bpp grayscale, 32 bpp rgb, or colormapped</param>
''' <param name="factor"> \param[in]    factor    subsampling factor; >= 1; ignored if colormapped</param>
''' <param name="type"> \param[in]    type      L_SELECT_MIN or L_SELECT_MAX</param>
''' <param name="prval"> \param[out]   prval     [optional] red component</param>
''' <param name="pgval"> \param[out]   pgval     [optional] green component</param>
''' <param name="pbval"> \param[out]   pbval     [optional] blue component</param>
''' <param name="pgrayval"> \param[out]   pgrayval  [optional] min or max gray value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetExtremeValue")> _
Friend Shared Function pixGetExtremeValue(pixs as IntPTR, factor as Integer, type as Integer, prval as Integer, pgval as Integer, pbval as Integer, pgrayval as Integer) as Integer
End Function

' SRC\pix4.c (2278, 1)
' pixGetMaxValueInRect()
' pixGetMaxValueInRect(PIX *, BOX *, l_uint32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This can be used to find the maximum and its location
'''  * in a 2-dimensional histogram, where the x and y directions
'''  * represent two color components (e.g., saturation and hue).
'''  *   (2) Note that here a 32 bpp pixs has pixel values that are simply
'''  * numbers.  They are not 8 bpp components in a colorspace.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     8, 16 or 32 bpp grayscale; no color space components</param>
''' <param name="box"> \param[in]    box      [optional] region; set box = NULL to use entire pixs</param>
''' <param name="pmaxval"> \param[out]   pmaxval  [optional] max value in region</param>
''' <param name="pxmax"> \param[out]   pxmax    [optional] x location of max value</param>
''' <param name="pymax"> \param[out]   pymax    [optional] y location of max value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetMaxValueInRect")> _
Friend Shared Function pixGetMaxValueInRect(pixs as IntPTR, box as IntPTR, pmaxval as UInteger, pxmax as Integer, pymax as Integer) as Integer
End Function

' SRC\pix4.c (2367, 1)
' pixGetBinnedComponentRange()
' pixGetBinnedComponentRange(PIX *, l_int32, l_int32, l_int32, l_int32 *, l_int32 *, l_uint32 **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This returns the min and max average values of the
'''  * selected color component in the set of rank bins,
'''  * where the ranking is done using the specified component.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs      32 bpp rgb</param>
''' <param name="nbins"> \param[in]    nbins     number of equal population bins; must be > 1</param>
''' <param name="factor"> \param[in]    factor    subsampling factor; >= 1</param>
''' <param name="color"> \param[in]    color     L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE</param>
''' <param name="pminval"> \param[out]   pminval   [optional] minimum value of component</param>
''' <param name="pmaxval"> \param[out]   pmaxval   [optional] maximum value of component</param>
''' <param name="pcarray"> \param[out]   pcarray   [optional] color array of bins</param>
''' <param name="fontsize"> \param[in]    fontsize  [optional] 0 for no debug; for debug, valid set</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetBinnedComponentRange")> _
Friend Shared Function pixGetBinnedComponentRange(pixs as IntPTR, nbins as Integer, factor as Integer, color as Integer, pminval as Integer, pmaxval as Integer, pcarray as Object, fontsize as Integer) as Integer
End Function

' SRC\pix4.c (2467, 1)
' pixGetRankColorArray()
' pixGetRankColorArray(PIX *, l_int32, l_int32, l_int32, l_uint32 **, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The color selection flag is one of: L_SELECT_RED, L_SELECT_GREEN,
'''  * L_SELECT_BLUE, L_SELECT_MIN, L_SELECT_MAX, L_SELECT_AVERAGE,
'''  * L_SELECT_HUE, L_SELECT_SATURATION.
'''  *   (2) Then it finds the histogram of the selected color type in each
'''  * RGB pixel.  For each of the %nbins sets of pixels,
'''  * ordered by this color type value, find the average RGB color,
'''  * and return this as a "rank color" array.  The output array
'''  * has %nbins colors.
'''  *   (3) Set the subsampling factor > 1 to reduce the amount of
'''  * computation.  Typically you want at least 10,000 pixels
'''  * for reasonable statistics.
'''  *   (4) The rank color as a function of rank can then be found from
'''  * rankint = (l_int32)(rank * (nbins - 1) + 0.5);
'''  * extractRGBValues(array[rankint], &rval, &gval, &bval);
'''  * where the rank is in [0.0 ... 1.0].
'''  * This function is meant to be simple and approximate.
'''  *   (5) Compare this with pixGetBinnedColor(), which generates equal
'''  * width intensity bins and finds the average color in each bin.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs       32 bpp or cmapped</param>
''' <param name="nbins"> \param[in]    nbins      number of equal population bins; must be > 1</param>
''' <param name="type"> \param[in]    type       color selection flag</param>
''' <param name="factor"> \param[in]    factor     subsampling factor; integer >= 1</param>
''' <param name="pcarray"> \param[out]   pcarray    array of colors, ranked by intensity</param>
''' <param name="debugflag"> \param[in]    debugflag  1 to display color squares and plots of color</param>
''' <param name="fontsize"> \param[in]    fontsize   [optional] 0 for no debug; for debug, valid set</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRankColorArray")> _
Friend Shared Function pixGetRankColorArray(pixs as IntPTR, nbins as Integer, type as Integer, factor as Integer, pcarray as Object, debugflag as Integer, fontsize as Integer) as Integer
End Function

' SRC\pix4.c (2629, 1)
' pixGetBinnedColor()
' pixGetBinnedColor(PIX *, PIX *, l_int32, l_int32, NUMA *, l_uint32 **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This takes a color image, a grayscale (intensity) version,
'''  * a LUT from intensity to bin number, and the number of bins.
'''  * It computes the average color for pixels whose intensity
'''  * is in each bin.  This is returned as an array of l_uint32
'''  * colors in our standard RGBA ordering.
'''  *   (2) This function generates equal width intensity bins and
'''  * finds the average color in each bin.  Compare this with
'''  * pixGetRankColorArray(), which rank orders the pixels
'''  * by the value of the selected component in each pixel,
'''  * sets up bins with equal population (not intensity width!),
'''  * and gets the average color in each bin.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs       32 bpp</param>
''' <param name="pixg"> \param[in]    pixg       8 bpp grayscale version of pixs</param>
''' <param name="factor"> \param[in]    factor     sampling factor along pixel counting direction</param>
''' <param name="nbins"> \param[in]    nbins      number of intensity bins</param>
''' <param name="nalut"> \param[in]    nalut      LUT for mapping from intensity to bin number</param>
''' <param name="pcarray"> \param[out]   pcarray    array of average color values in each bin</param>
''' <param name="debugflag"> \param[in]    debugflag  1 to display output debug plots of color</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetBinnedColor")> _
Friend Shared Function pixGetBinnedColor(pixs as IntPTR, pixg as IntPTR, factor as Integer, nbins as Integer, nalut as IntPTR, pcarray as Object, debugflag as Integer) as Integer
End Function

' SRC\pix4.c (2759, 1)
' pixDisplayColorArray()
' pixDisplayColorArray(l_uint32 *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd color array, or NULL on error</returns>
''' <param name="carray"> \param[in]   carray    array of colors: 0xrrggbb00</param>
''' <param name="ncolors"> \param[in]   ncolors   size of array</param>
''' <param name="side"> \param[in]   side      size of each color square; suggest 200</param>
''' <param name="ncols"> \param[in]   ncols     number of columns in output color matrix</param>
''' <param name="fontsize"> \param[in]   fontsize  to label each square with text.  Valid set is</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDisplayColorArray")> _
Friend Shared Function pixDisplayColorArray(carray as UInteger, ncolors as Integer, side as Integer, ncols as Integer, fontsize as Integer) as IntPTR
End Function

' SRC\pix4.c (2831, 1)
' pixRankBinByStrip()
' pixRankBinByStrip(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This generates a pix where each column represents a strip of
'''  * the input image.  If %direction == L_SCAN_HORIZONTAL, the
'''  * input impage is tiled into vertical strips of width %size,
'''  * where %size is a compromise between getting better spatial
'''  * columnwise resolution (small %size) and getting better
'''  * columnwise statistical information (larger %size).  Likewise
'''  * with rows of the image if %direction == L_SCAN_VERTICAL.
'''  *   (2) For L_HORIZONTAL_SCAN, the output pix contains rank binned
'''  * median colors in each column that correspond to a vertical
'''  * strip of width %size in the input image.
'''  *   (3) The color selection flag is one of: L_SELECT_RED, L_SELECT_GREEN,
'''  * L_SELECT_BLUE, L_SELECT_MIN, L_SELECT_MAX, L_SELECT_AVERAGE.
'''  * It determines how the rank ordering is done.
'''  *   (4) Typical input values might be %size = 5, %nbins = 10.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd result, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs       32 bpp or cmapped</param>
''' <param name="direction"> \param[in]   direction  L_SCAN_HORIZONTAL or L_SCAN_VERTICAL</param>
''' <param name="size"> \param[in]   size       of strips in scan direction</param>
''' <param name="nbins"> \param[in]   nbins      number of equal population bins; must be > 1</param>
''' <param name="type"> \param[in]   type       color selection flag</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRankBinByStrip")> _
Friend Shared Function pixRankBinByStrip(pixs as IntPTR, direction as Integer, size as Integer, nbins as Integer, type as Integer) as IntPTR
End Function

' SRC\pix4.c (2928, 1)
' pixaGetAlignedStats()
' pixaGetAlignedStats(PIXA *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Each pixel in the returned pix represents an average
'''  * (or median, or mode) over the corresponding pixels in each
'''  * pix in the pixa.
'''  *   (2) The %thresh parameter works with L_MODE_VAL only, and
'''  * sets a minimum occupancy of the mode bin.
'''  * If the occupancy of the mode bin is less than %thresh, the
'''  * mode value is returned as 0.  To always return the actual
'''  * mode value, set %thresh = 0.  See pixGetRowStats().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix with pixelwise aligned stats, or NULL on error.</returns>
''' <param name="pixa"> \param[in]   pixa    of identically sized, 8 bpp pix; not cmapped</param>
''' <param name="type"> \param[in]   type    L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT</param>
''' <param name="nbins"> \param[in]   nbins   of histogram for median and mode; ignored for mean</param>
''' <param name="thresh"> \param[in]   thresh  on histogram for mode val; ignored for all other types</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGetAlignedStats")> _
Friend Shared Function pixaGetAlignedStats(pixa as IntPTR, type as Integer, nbins as Integer, thresh as Integer) as IntPTR
End Function

' SRC\pix4.c (2975, 1)
' pixaExtractColumnFromEachPix()
' pixaExtractColumnFromEachPix(PIXA *, l_int32, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]   pixa   of identically sized, 8 bpp; not cmapped</param>
''' <param name="col"> \param[in]   col    column index</param>
''' <param name="pixd"> \param[in]   pixd   pix into which each column is inserted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaExtractColumnFromEachPix")> _
Friend Shared Function pixaExtractColumnFromEachPix(pixa as IntPTR, col as Integer, pixd as IntPTR) as Integer
End Function

' SRC\pix4.c (3050, 1)
' pixGetRowStats()
' pixGetRowStats(PIX *, l_int32, l_int32, l_int32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This computes a column vector of statistics using each
'''  * row of a Pix.  The result is put in %colvect.
'''  *   (2) The %thresh parameter works with L_MODE_VAL only, and
'''  * sets a minimum occupancy of the mode bin.
'''  * If the occupancy of the mode bin is less than %thresh, the
'''  * mode value is returned as 0.  To always return the actual
'''  * mode value, set %thresh = 0.
'''  *   (3) What is the meaning of this %thresh parameter?
'''  * For each row, the total count in the histogram is w, the
'''  * image width.  So %thresh, relative to w, gives a measure
'''  * of the ratio of the bin width to the width of the distribution.
'''  * The larger %thresh, the narrower the distribution must be
'''  * for the mode value to be returned (instead of returning 0).
'''  *   (4) If the Pix consists of a set of corresponding columns,
'''  * one for each Pix in a Pixa, the width of the Pix is the
'''  * number of Pix in the Pixa and the column vector can
'''  * be stored as a column in a Pix of the same size as
'''  * each Pix in the Pixa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]   pixs     8 bpp; not cmapped</param>
''' <param name="type"> \param[in]   type     L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT</param>
''' <param name="nbins"> \param[in]   nbins    of histogram for median and mode; ignored for mean</param>
''' <param name="thresh"> \param[in]   thresh   on histogram for mode; ignored for mean and median</param>
''' <param name="colvect"> \param[in]   colvect  vector of results gathered across the rows of pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRowStats")> _
Friend Shared Function pixGetRowStats(pixs as IntPTR, type as Integer, nbins as Integer, thresh as Integer, colvect as single) as Integer
End Function

' SRC\pix4.c (3172, 1)
' pixGetColumnStats()
' pixGetColumnStats(PIX *, l_int32, l_int32, l_int32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This computes a row vector of statistics using each
'''  * column of a Pix.  The result is put in %rowvect.
'''  *   (2) The %thresh parameter works with L_MODE_VAL only, and
'''  * sets a minimum occupancy of the mode bin.
'''  * If the occupancy of the mode bin is less than %thresh, the
'''  * mode value is returned as 0.  To always return the actual
'''  * mode value, set %thresh = 0.
'''  *   (3) What is the meaning of this %thresh parameter?
'''  * For each column, the total count in the histogram is h, the
'''  * image height.  So %thresh, relative to h, gives a measure
'''  * of the ratio of the bin width to the width of the distribution.
'''  * The larger %thresh, the narrower the distribution must be
'''  * for the mode value to be returned (instead of returning 0).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]   pixs     8 bpp; not cmapped</param>
''' <param name="type"> \param[in]   type     L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT</param>
''' <param name="nbins"> \param[in]   nbins    of histogram for median and mode; ignored for mean</param>
''' <param name="thresh"> \param[in]   thresh   on histogram for mode val; ignored for all other types</param>
''' <param name="rowvect"> \param[in]   rowvect  vector of results gathered down the columns of pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetColumnStats")> _
Friend Shared Function pixGetColumnStats(pixs as IntPTR, type as Integer, nbins as Integer, thresh as Integer, rowvect as single) as Integer
End Function

' SRC\pix4.c (3273, 1)
' pixSetPixelColumn()
' pixSetPixelColumn(PIX *, l_int32, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]   pix      8 bpp; not cmapped</param>
''' <param name="col"> \param[in]   col      column index</param>
''' <param name="colvect"> \param[in]   colvect  vector of floats</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetPixelColumn")> _
Friend Shared Function pixSetPixelColumn(pix as IntPTR, col as Integer, colvect as single) as Integer
End Function

' SRC\pix4.c (3313, 1)
' pixThresholdForFgBg()
' pixThresholdForFgBg(PIX *, l_int32, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs    any depth; cmapped ok</param>
''' <param name="factor"> \param[in]    factor  subsampling factor; integer >= 1</param>
''' <param name="thresh"> \param[in]    thresh  threshold for generating foreground mask</param>
''' <param name="pfgval"> \param[out]   pfgval  [optional] average foreground value</param>
''' <param name="pbgval"> \param[out]   pbgval  [optional] average background value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixThresholdForFgBg")> _
Friend Shared Function pixThresholdForFgBg(pixs as IntPTR, factor as Integer, thresh as Integer, pfgval as Integer, pbgval as Integer) as Integer
End Function

' SRC\pix4.c (3372, 1)
' pixSplitDistributionFgBg()
' pixSplitDistributionFgBg(PIX *, l_float32, l_int32, l_int32 *, l_int32 *, l_int32 *, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See numaSplitDistribution() for details on the underlying
'''  * method of choosing a threshold.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs        any depth; cmapped ok</param>
''' <param name="scorefract"> \param[in]    scorefract  fraction of the max score, used to determine</param>
''' <param name="factor"> \param[in]    factor      subsampling factor; integer >= 1</param>
''' <param name="pthresh"> \param[out]   pthresh     [optional] best threshold for separating</param>
''' <param name="pfgval"> \param[out]   pfgval      [optional] average foreground value</param>
''' <param name="pbgval"> \param[out]   pbgval      [optional] average background value</param>
''' <param name="ppixdb"> \param[out]   ppixdb      [optional] plot of distribution and split point</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSplitDistributionFgBg")> _
Friend Shared Function pixSplitDistributionFgBg(pixs as IntPTR, scorefract as single, factor as Integer, pthresh as Integer, pfgval as Integer, pbgval as Integer, ppixdb as Object) as Integer
End Function

#End Region
#Region "SRC\pix5.c"
' SRC\pix5.c (130, 1)
' pixaFindDimensions()
' pixaFindDimensions(PIXA *, NUMA **, NUMA **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="pnaw"> \param[out]   pnaw [optional] numa of pix widths</param>
''' <param name="pnah"> \param[out]   pnah [optional] numa of pix heights</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaFindDimensions")> _
Friend Shared Function pixaFindDimensions(pixa as IntPTR, pnaw as Object, pnah as Object) as Integer
End Function

' SRC\pix5.c (180, 1)
' pixFindAreaPerimRatio()
' pixFindAreaPerimRatio(PIX *, l_int32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The area is the number of fg pixels that are not on the
'''  * boundary (i.e., are not 8-connected to a bg pixel), and the
'''  * perimeter is the number of fg boundary pixels.  Returns
'''  * 0.0 if there are no fg pixels.
'''  *   (2) This function is retained because clients are using it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
''' <param name="tab"> \param[in]    tab     [optional] pixel sum table, can be NULL</param>
''' <param name="pfract"> \param[out]   pfract  area/perimeter ratio</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindAreaPerimRatio")> _
Friend Shared Function pixFindAreaPerimRatio(pixs as IntPTR, tab as Integer, pfract as single) as Integer
End Function

' SRC\pix5.c (231, 1)
' pixaFindPerimToAreaRatio()
' pixaFindPerimToAreaRatio(PIXA *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This is typically used for a pixa consisting of
'''  * 1 bpp connected components.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na   of perimeter/arear ratio for each pix, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa   of 1 bpp pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaFindPerimToAreaRatio")> _
Friend Shared Function pixaFindPerimToAreaRatio(pixa as IntPTR) as IntPTR
End Function

' SRC\pix5.c (281, 1)
' pixFindPerimToAreaRatio()
' pixFindPerimToAreaRatio(PIX *, l_int32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The perimeter is the number of fg boundary pixels, and the
'''  * area is the number of fg pixels.  This returns 0.0 if
'''  * there are no fg pixels.
'''  *   (2) Unlike pixFindAreaPerimRatio(), this uses the full set of
'''  * fg pixels for the area, and the ratio is taken in the opposite
'''  * order.
'''  *   (3) This is typically used for a single connected component.
'''  * This always has a value = 1.0, and if the average distance
'''  * of a fg pixel from the nearest bg pixel is d, this has
'''  * a value ~1/d.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
''' <param name="tab"> \param[in]    tab     [optional] pixel sum table, can be NULL</param>
''' <param name="pfract"> \param[out]   pfract  perimeter/area ratio</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindPerimToAreaRatio")> _
Friend Shared Function pixFindPerimToAreaRatio(pixs as IntPTR, tab as Integer, pfract as single) as Integer
End Function

' SRC\pix5.c (335, 1)
' pixaFindPerimSizeRatio()
' pixaFindPerimSizeRatio(PIXA *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This is typically used for a pixa consisting of
'''  * 1 bpp connected components.
'''  *   (2) This has a minimum value for a circle of pi/4; a value for
'''  * a rectangle component of approx. 1.0; and a value much larger
'''  * than 1.0 for a component with a highly irregular boundary.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na   of fg perimeter/(2(w+h)) ratio for each pix,</returns>
''' <param name="pixa"> \param[in]    pixa   of 1 bpp pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaFindPerimSizeRatio")> _
Friend Shared Function pixaFindPerimSizeRatio(pixa as IntPTR) as IntPTR
End Function

' SRC\pix5.c (385, 1)
' pixFindPerimSizeRatio()
' pixFindPerimSizeRatio(PIX *, l_int32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) We take the 'size' as twice the sum of the width and
'''  * height of pixs, and the perimeter is the number of fg
'''  * boundary pixels.  We use the fg pixels of the boundary
'''  * because the pix may be clipped to the boundary, so an
'''  * erosion is required to count all boundary pixels.
'''  *   (2) This has a large value for dendritic, fractal-like components
'''  * with highly irregular boundaries.
'''  *   (3) This is typically used for a single connected component.
'''  * It has a value of about 1.0 for rectangular components with
'''  * relatively smooth boundaries.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
''' <param name="tab"> \param[in]    tab     [optional] pixel sum table, can be NULL</param>
''' <param name="pratio"> \param[out]   pratio  perimeter/size ratio</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindPerimSizeRatio")> _
Friend Shared Function pixFindPerimSizeRatio(pixs as IntPTR, tab as Integer, pratio as single) as Integer
End Function

' SRC\pix5.c (431, 1)
' pixaFindAreaFraction()
' pixaFindAreaFraction(PIXA *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This is typically used for a pixa consisting of
'''  * 1 bpp connected components.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na  of area fractions for each pix, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa   of 1 bpp pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaFindAreaFraction")> _
Friend Shared Function pixaFindAreaFraction(pixa as IntPTR) as IntPTR
End Function

' SRC\pix5.c (474, 1)
' pixFindAreaFraction()
' pixFindAreaFraction(PIX *, l_int32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds the ratio of the number of fg pixels to the
'''  * size of the pix (w * h).  It is typically used for a
'''  * single connected component.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
''' <param name="tab"> \param[in]    tab     [optional] pixel sum table, can be NULL</param>
''' <param name="pfract"> \param[out]   pfract  fg area/size ratio</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindAreaFraction")> _
Friend Shared Function pixFindAreaFraction(pixs as IntPTR, tab as Integer, pfract as single) as Integer
End Function

' SRC\pix5.c (522, 1)
' pixaFindAreaFractionMasked()
' pixaFindAreaFractionMasked(PIXA *, PIX *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This is typically used for a pixa consisting of
'''  * 1 bpp connected components, which has an associated
'''  * boxa giving the location of the components relative
'''  * to the mask origin.
'''  *   (2) The debug flag displays in green and red the masked and
'''  * unmasked parts of the image from which pixa was derived.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of ratio masked/total fractions for each pix,</returns>
''' <param name="pixa"> \param[in]    pixa    of 1 bpp pix</param>
''' <param name="pixm"> \param[in]    pixm    mask image</param>
''' <param name="debug"> \param[in]    debug   1 for output, 0 to suppress</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaFindAreaFractionMasked")> _
Friend Shared Function pixaFindAreaFractionMasked(pixa as IntPTR, pixm as IntPTR, debug as Integer) as IntPTR
End Function

' SRC\pix5.c (601, 1)
' pixFindAreaFractionMasked()
' pixFindAreaFractionMasked(PIX *, BOX *, PIX *, l_int32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds the ratio of the number of masked fg pixels
'''  * in pixs to the total number of fg pixels in pixs.
'''  * It is typically used for a single connected component.
'''  * If there are no fg pixels, this returns a ratio of 0.0.
'''  *   (2) The box gives the location of the pix relative to that
'''  * of the UL corner of the mask.  Therefore, the rasterop
'''  * is performed with the pix translated to its location
'''  * (x, y) in the mask before ANDing.
'''  * If box == NULL, the UL corners of pixs and pixm are aligned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs    1 bpp, typically a single component</param>
''' <param name="box"> \param[in]    box     [optional] for pixs relative to pixm</param>
''' <param name="pixm"> \param[in]    pixm    1 bpp mask, typically over the entire image from</param>
''' <param name="tab"> \param[in]    tab     [optional] pixel sum table, can be NULL</param>
''' <param name="pfract"> \param[out]   pfract  fg area/size ratio</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindAreaFractionMasked")> _
Friend Shared Function pixFindAreaFractionMasked(pixs as IntPTR, box as IntPTR, pixm as IntPTR, tab as Integer, pfract as single) as Integer
End Function

' SRC\pix5.c (660, 1)
' pixaFindWidthHeightRatio()
' pixaFindWidthHeightRatio(PIXA *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This is typically used for a pixa consisting of
'''  * 1 bpp connected components.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of width/height ratios for each pix, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa   of 1 bpp pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaFindWidthHeightRatio")> _
Friend Shared Function pixaFindWidthHeightRatio(pixa as IntPTR) as IntPTR
End Function

' SRC\pix5.c (696, 1)
' pixaFindWidthHeightProduct()
' pixaFindWidthHeightProduct(PIXA *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This is typically used for a pixa consisting of
'''  * 1 bpp connected components.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of widthheight products for each pix, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa   of 1 bpp pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaFindWidthHeightProduct")> _
Friend Shared Function pixaFindWidthHeightProduct(pixa as IntPTR) as IntPTR
End Function

' SRC\pix5.c (736, 1)
' pixFindOverlapFraction()
' pixFindOverlapFraction(PIX *, PIX *, l_int32, l_int32, l_int32 *, l_float32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The UL corner of pixs2 is placed at (x2, y2) in pixs1.
'''  *   (2) This measure is similar to the correlation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs1"> \param[in]    pixs1, pixs2   1 bpp</param>
''' <param name="pixs2"> \param[in]    x2, y2         location in pixs1 of UL corner of pixs2</param>
''' <param name="x2"> \param[in]    tab            [optional] pixel sum table, can be null</param>
''' <param name="y2"> \param[out]   pratio         ratio fg intersection to fg union</param>
''' <param name="tab"> \param[out]   pnoverlap      [optional] number of overlapping pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindOverlapFraction")> _
Friend Shared Function pixFindOverlapFraction(pixs1 as IntPTR, pixs2 as IntPTR, x2 as Integer, y2 as Integer, tab as Integer, pratio as single, pnoverlap as Integer) as Integer
End Function

' SRC\pix5.c (803, 1)
' pixFindRectangleComps()
' pixFindRectangleComps(PIX *, l_int32, l_int32, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) This applies the function pixConformsToRectangle() to
'''  * each 8-c.c. in pixs, and returns a boxa containing the
'''  * regions of all components that are conforming.
'''  *   (2) Conforming components must satisfy both the size constraint
'''  * given by %minsize and the slop in conforming to a rectangle
'''  * determined by %dist.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa of components that conform, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs        1 bpp</param>
''' <param name="dist"> \param[in]    dist        max distance allowed between bounding box</param>
''' <param name="minw"> \param[in]    minw, minh  minimum size in each direction as a requirement</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindRectangleComps")> _
Friend Shared Function pixFindRectangleComps(pixs as IntPTR, dist as Integer, minw as Integer, minh as Integer) as IntPTR
End Function

' SRC\pix5.c (883, 1)
' pixConformsToRectangle()
' pixConformsToRectangle(PIX *, BOX *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) There are several ways to test if a connected component has
'''  * an essentially rectangular boundary, such as:
'''  *  a. Fraction of fill into the bounding box
'''  *  b. Max-min distance of fg pixel from periphery of bounding box
'''  *  c. Max depth of bg intrusions into component within bounding box
'''  * The weakness of (a) is that it is highly sensitive to holes
'''  * within the c.c.  The weakness of (b) is that it can have
'''  * arbitrarily large intrusions into the c.c.  Method (c) tests
'''  * the integrity of the outer boundary of the c.c., with respect
'''  * to the enclosing bounding box, so we use it.
'''  *   (2) This tests if the connected component within the box conforms
'''  * to the box at all points on the periphery within %dist.
'''  * Inside, at a distance from the box boundary that is greater
'''  * than %dist, we don't care about the pixels in the c.c.
'''  *   (3) We can think of the conforming condition as follows:
'''  * No pixel inside a distance %dist from the boundary
'''  * can connect to the boundary through a path through the bg.
'''  * To implement this, we need to do a flood fill.  We can go
'''  * either from inside toward the boundary, or the other direction.
'''  * It's easiest to fill from the boundary, and then verify that
'''  * there are no filled pixels farther than %dist from the boundary.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs       1 bpp</param>
''' <param name="box"> \param[in]    box        [optional] if null, use the entire pixs</param>
''' <param name="dist"> \param[in]    dist       max distance allowed between bounding box and</param>
''' <param name="pconforms"> \param[out]   pconforms  0 (false) if not conforming;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConformsToRectangle")> _
Friend Shared Function pixConformsToRectangle(pixs as IntPTR, box as IntPTR, dist as Integer, pconforms as Integer) as Integer
End Function

' SRC\pix5.c (950, 1)
' pixClipRectangles()
' pixClipRectangles(PIX *, BOXA *) as PIXA *
''' <summary>
''' * Notes:
'''  *  (1) The returned pixa includes the actual regions clipped out from
'''  *   the input pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa consisting of requested regions, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="boxa"> \param[in]    boxa  requested clipping regions</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixClipRectangles")> _
Friend Shared Function pixClipRectangles(pixs as IntPTR, boxa as IntPTR) as IntPTR
End Function

' SRC\pix5.c (1016, 1)
' pixClipRectangle()
' pixClipRectangle(PIX *, BOX *, BOX **) as PIX *
''' <summary>
''' * Notes:
'''  *
'''  *  This should be simple, but there are choices to be made.
'''  *  The box is defined relative to the pix coordinates.  However,
'''  *  if the box is not contained within the pix, we have two choices:
'''  *
'''  *   (1) clip the box to the pix
'''  *   (2) make a new pix equal to the full box dimensions,
'''  * but let rasterop do the clipping and positioning
'''  * of the src with respect to the dest
'''  *
'''  *  Choice (2) immediately brings up the problem of what pixel values
'''  *  to use that were not taken from the src.  For example, on a grayscale
'''  *  image, do you want the pixels not taken from the src to be black
'''  *  or white or something else?  To implement choice 2, one needs to
'''  *  specify the color of these extra pixels.
'''  *
'''  *  So we adopt (1), and clip the box first, if necessary,
'''  *  before making the dest pix and doing the rasterop.  But there
'''  *  is another issue to consider.  If you want to paste the
'''  *  clipped pix back into pixs, it must be properly aligned, and
'''  *  it is necessary to use the clipped box for alignment.
'''  *  Accordingly, this function has a third (optional) argument, which is
'''  *  the input box clipped to the src pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  clipped pix, or NULL on error or if rectangle</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="box"> \param[in]    box    requested clipping region; const</param>
''' <param name="pboxc"> \param[out]   pboxc  [optional] actual box of clipped region</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixClipRectangle")> _
Friend Shared Function pixClipRectangle(pixs as IntPTR, box as IntPTR, pboxc as Object) as IntPTR
End Function

' SRC\pix5.c (1089, 1)
' pixClipMasked()
' pixClipMasked(PIX *, PIX *, l_int32, l_int32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixs has a colormap, it is preserved in pixd.
'''  *   (2) The depth of pixd is the same as that of pixs.
'''  *   (3) If the depth of pixs is 1, use %outval = 0 for white background
'''  * and 1 for black; otherwise, use the max value for white
'''  * and 0 for black.  If pixs has a colormap, the max value for
'''  * %outval is 0xffffffff; otherwise, it is 2^d - 1.
'''  *   (4) When using 1 bpp pixs, this is a simple clip and
'''  * blend operation.  For example, if both pix1 and pix2 are
'''  * black text on white background, and you want to OR the
'''  * fg on the two images, let pixm be the inverse of pix2.
'''  * Then the operation takes all of pix1 that's in the bg of
'''  * pix2, and for the remainder (which are the pixels
'''  * corresponding to the fg of the pix2), paint them black
'''  * (1) in pix1.  The function call looks like
'''  * pixClipMasked(pix2, pixInvert(pix1, pix1), x, y, 1);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, clipped pix or NULL on error or if pixm doesn't</returns>
''' <param name="pixs"> \param[in]    pixs    1, 2, 4, 8, 16, 32 bpp; colormap ok</param>
''' <param name="pixm"> \param[in]    pixm    clipping mask, 1 bpp</param>
''' <param name="x"> \param[in]    x, y    origin of clipping mask relative to pixs</param>
''' <param name="y"> \param[in]    outval  val to use for pixels that are outside the mask</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixClipMasked")> _
Friend Shared Function pixClipMasked(pixs as IntPTR, pixm as IntPTR, x as Integer, y as Integer, outval as UInteger) as IntPTR
End Function

' SRC\pix5.c (1151, 1)
' pixCropToMatch()
' pixCropToMatch(PIX *, PIX *, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This resizes pixs1 and/or pixs2 by cropping at the right
'''  * and bottom, so that they're the same size.
'''  *   (2) If a pix doesn't need to be cropped, a clone is returned.
'''  *   (3) Note: the images are implicitly aligned to the UL corner.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs1"> \param[in]    pixs1   any depth, colormap OK</param>
''' <param name="pixs2"> \param[in]    pixs2   any depth, colormap OK</param>
''' <param name="ppixd1"> \param[out]   ppixd1  may be a clone</param>
''' <param name="ppixd2"> \param[out]   ppixd2  may be a clone</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCropToMatch")> _
Friend Shared Function pixCropToMatch(pixs1 as IntPTR, pixs2 as IntPTR, ppixd1 as Object, ppixd2 as Object) as Integer
End Function

' SRC\pix5.c (1194, 1)
' pixCropToSize()
' pixCropToSize(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If either w or h is smaller than the corresponding dimension
'''  * of pixs, this returns a cropped image; otherwise it returns
'''  * a clone of pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd cropped if necessary or NULL on error.</returns>
''' <param name="pixs"> \param[in]    pixs   any depth, colormap OK</param>
''' <param name="w"> \param[in]    w, h   max dimensions of cropped image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCropToSize")> _
Friend Shared Function pixCropToSize(pixs as IntPTR, w as Integer, h as Integer) as IntPTR
End Function

' SRC\pix5.c (1248, 1)
' pixResizeToMatch()
' pixResizeToMatch(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This resizes pixs to make pixd, without scaling, by either
'''  * cropping or extending separately in both width and height.
'''  * Extension is done by replicating the last row or column.
'''  * This is useful in a situation where, due to scaling
'''  * operations, two images that are expected to be the
'''  * same size can differ slightly in each dimension.
'''  *   (2) You can use either an existing pixt or specify
'''  * both %w and %h.  If pixt is defined, the values
'''  * in %w and %h are ignored.
'''  *   (3) If pixt is larger than pixs (or if w and/or d is larger
'''  * than the dimension of pixs, replicate the outer row and
'''  * column of pixels in pixs into pixd.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd resized to match or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   1, 2, 4, 8, 16, 32 bpp; colormap ok</param>
''' <param name="pixt"> \param[in]    pixt   can be null; we use only the size</param>
''' <param name="w"> \param[in]    w, h   ignored if pixt is defined</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixResizeToMatch")> _
Friend Shared Function pixResizeToMatch(pixs as IntPTR, pixt as IntPTR, w as Integer, h as Integer) as IntPTR
End Function

' SRC\pix5.c (1329, 1)
' pixMakeFrameMask()
' pixMakeFrameMask(l_int32, l_int32, l_float32, l_float32, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This makes an arbitrary 1-component mask with a centered fg
'''  * frame, which can have both an inner and an outer boundary.
'''  * All input fractional distances are measured from the image
'''  * border to the frame boundary, in units of the image half-width
'''  * for hf1 and hf2 and the image half-height for vf1 and vf2.
'''  * The distances to the outer frame boundary are given by hf1
'''  * and vf1; to the inner frame boundary, by hf2 and vf2.
'''  * Input fractions are thus in [0.0 ... 1.0], with hf1 = hf2
'''  * and vf1 = vf2.  Horizontal and vertical frame widths are
'''  * thus independently specified.
'''  *   (2) Special cases:
'''  *  * full fg mask: hf1 = vf1 = 0.0, hf2 = vf2 = 1.0.
'''  *  * empty fg (zero width) mask: set  hf1 = hf2  and vf1 = vf2.
'''  *  * fg rectangle with no hole: set hf2 = vf2 = 1.0.
'''  *  * frame touching outer boundary: set hf1 = vf1 = 0.0.
'''  *   (3) The vertical thickness of the horizontal mask parts
'''  * is 0.5 * (vf2 - vf1) * h.  The horizontal thickness of the
'''  * vertical mask parts is 0.5 * (hf2 - hf1) * w.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error.</returns>
''' <param name="w"> \param[in]    w, h  dimensions of output 1 bpp pix</param>
''' <param name="h"> \param[in]    hf1   horizontal fraction of half-width at outer frame bdry</param>
''' <param name="hf1"> \param[in]    hf2   horizontal fraction of half-width at inner frame bdry</param>
''' <param name="hf2"> \param[in]    vf1   vertical fraction of half-width at outer frame bdry</param>
''' <param name="vf1"> \param[in]    vf2   vertical fraction of half-width at inner frame bdry</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMakeFrameMask")> _
Friend Shared Function pixMakeFrameMask(w as Integer, h as Integer, hf1 as single, hf2 as single, vf1 as single, vf2 as single) as IntPTR
End Function

' SRC\pix5.c (1395, 1)
' pixMakeCoveringOfRectangles()
' pixMakeCoveringOfRectangles(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This iteratively finds the bounding boxes of the connected
'''  * components and generates a mask from them.  Two iterations
'''  * should suffice for most situations.
'''  *   (2) Returns an empty pix if %pixs is empty.
'''  *   (3) If there are many small components in proximity, it may
'''  * be useful to merge them with a morphological closing before
'''  * calling this one.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs       1 bpp</param>
''' <param name="maxiters"> \param[in]   maxiters   max iterations: use 0 to iterate to completion</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMakeCoveringOfRectangles")> _
Friend Shared Function pixMakeCoveringOfRectangles(pixs as IntPTR, maxiters as Integer) as IntPTR
End Function

' SRC\pix5.c (1468, 1)
' pixFractionFgInMask()
' pixFractionFgInMask(PIX *, PIX *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This gives the fraction of fg pixels in pix1 that are in
'''  * the intersection (i.e., under the fg) of pix2:
'''  * |1 & 2|/|1|, where |...| means the number of fg pixels.
'''  * Note that this is different from the situation where
'''  * pix1 and pix2 are reversed.
'''  *   (2) Both pix1 and pix2 are registered to the UL corners.  A warning
'''  * is issued if pix1 and pix2 have different sizes.
'''  *   (3) This can also be used to find the fraction of fg pixels in pix1
'''  * that are NOT under the fg of pix2: 1.0 - |1 & 2|/|1|
'''  *   (4) If pix1 or pix2 are empty, this returns %fract = 0.0.
'''  *   (5) For example, pix2 could be a frame around the outside of the
'''  * image, made from pixMakeFrameMask().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="pix1"> \param[in]    pix1    1 bpp</param>
''' <param name="pix2"> \param[in]    pix2    1 bpp</param>
''' <param name="pfract"> \param[out]   pfract  fraction of fg pixels in 1 that are</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFractionFgInMask")> _
Friend Shared Function pixFractionFgInMask(pix1 as IntPTR, pix2 as IntPTR, pfract as single) as Integer
End Function

' SRC\pix5.c (1524, 1)
' pixClipToForeground()
' pixClipToForeground(PIX *, PIX **, BOX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) At least one of {&pixd, &box} must be specified.
'''  *   (2) If there are no fg pixels, the returned ptrs are null.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error or if there are no fg pixels</returns>
''' <param name="pixs"> \param[in]    pixs   1 bpp</param>
''' <param name="ppixd"> \param[out]   ppixd  [optional] clipped pix returned</param>
''' <param name="pbox"> \param[out]   pbox   [optional] bounding box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixClipToForeground")> _
Friend Shared Function pixClipToForeground(pixs as IntPTR, ppixd as Object, pbox as Object) as Integer
End Function

' SRC\pix5.c (1624, 1)
' pixTestClipToForeground()
' pixTestClipToForeground(PIX *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a lightweight test to determine if a 1 bpp image
'''  * can be further cropped without loss of fg pixels.
'''  * If it cannot, canclip is set to 0.
'''  *   (2) It does not test for the existence of any fg pixels.
'''  * If there are no fg pixels, it will return %canclip = 1.
'''  * Check the output of the subsequent call to pixClipToForeground().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs      1 bpp</param>
''' <param name="pcanclip"> \param[out]   pcanclip  1 if fg does not extend to all four edges</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTestClipToForeground")> _
Friend Shared Function pixTestClipToForeground(pixs as IntPTR, pcanclip as Integer) as Integer
End Function

' SRC\pix5.c (1696, 1)
' pixClipBoxToForeground()
' pixClipBoxToForeground(PIX *, BOX *, PIX **, BOX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) At least one of {&pixd, &boxd} must be specified.
'''  *   (2) If there are no fg pixels, the returned ptrs are null.
'''  *   (3) Do not use &pixs for the 3rd arg or &boxs for the 4th arg;
'''  * this will leak memory.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error or if there are no fg pixels</returns>
''' <param name="pixs"> \param[in]    pixs   1 bpp</param>
''' <param name="boxs"> \param[in]    boxs   [optional] use full image if null</param>
''' <param name="ppixd"> \param[out]   ppixd  [optional] clipped pix returned</param>
''' <param name="pboxd"> \param[out]   pboxd  [optional] bounding box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixClipBoxToForeground")> _
Friend Shared Function pixClipBoxToForeground(pixs as IntPTR, boxs as IntPTR, ppixd as Object, pboxd as Object) as Integer
End Function

' SRC\pix5.c (1762, 1)
' pixScanForForeground()
' pixScanForForeground(PIX *, BOX *, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If there are no fg pixels, the position is set to 0.
'''  * Caller must check the return value!
'''  *   (2) Use %box == NULL to scan from edge of pixs
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error or if no fg pixels are found</returns>
''' <param name="pixs"> \param[in]    pixs      1 bpp</param>
''' <param name="box"> \param[in]    box       [optional] within which the search is conducted</param>
''' <param name="scanflag"> \param[in]    scanflag  direction of scan; e.g., L_FROM_LEFT</param>
''' <param name="ploc"> \param[out]   ploc      location in scan direction of first black pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScanForForeground")> _
Friend Shared Function pixScanForForeground(pixs as IntPTR, box as IntPTR, scanflag as Integer, ploc as Integer) as Integer
End Function

' SRC\pix5.c (1878, 1)
' pixClipBoxToEdges()
' pixClipBoxToEdges(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, PIX **, BOX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) At least one of {&pixd, &boxd} must be specified.
'''  *   (2) If there are no fg pixels, the returned ptrs are null.
'''  *   (3) This function attempts to locate rectangular "image" regions
'''  * of high-density fg pixels, that have well-defined edges
'''  * on the four sides.
'''  *   (4) Edges are searched for on each side, iterating in order
'''  * from left, right, top and bottom.  As each new edge is
'''  * found, the search box is resized to use that location.
'''  * Once an edge is found, it is held.  If no more edges
'''  * are found in one iteration, the search fails.
'''  *   (5) See pixScanForEdge() for usage of the thresholds and %maxwidth.
'''  *   (6) The thresholds must be at least 1, and the low threshold
'''  * cannot be larger than the high threshold.
'''  *   (7) If the low and high thresholds are both 1, this is equivalent
'''  * to pixClipBoxToForeground().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error or if a fg edge is not found from</returns>
''' <param name="pixs"> \param[in]    pixs        1 bpp</param>
''' <param name="boxs"> \param[in]    boxs        [optional] ; use full image if null</param>
''' <param name="lowthresh"> \param[in]    lowthresh   threshold to choose clipping location</param>
''' <param name="highthresh"> \param[in]    highthresh  threshold required to find an edge</param>
''' <param name="maxwidth"> \param[in]    maxwidth    max allowed width between low and high thresh locs</param>
''' <param name="factor"> \param[in]    factor      sampling factor along pixel counting direction</param>
''' <param name="ppixd"> \param[out]   ppixd       [optional] clipped pix returned</param>
''' <param name="pboxd"> \param[out]   pboxd       [optional] bounding box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixClipBoxToEdges")> _
Friend Shared Function pixClipBoxToEdges(pixs as IntPTR, boxs as IntPTR, lowthresh as Integer, highthresh as Integer, maxwidth as Integer, factor as Integer, ppixd as Object, pboxd as Object) as Integer
End Function

' SRC\pix5.c (2008, 1)
' pixScanForEdge()
' pixScanForEdge(PIX *, BOX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If there are no fg pixels, the position is set to 0.
'''  * Caller must check the return value!
'''  *   (2) Use %box == NULL to scan from edge of pixs
'''  *   (3) As the scan progresses, the location where the sum of
'''  * pixels equals or excees %lowthresh is noted (loc).  The
'''  * scan is stopped when the sum of pixels equals or exceeds
'''  * %highthresh.  If the scan distance between loc and that
'''  * point does not exceed %maxwidth, an edge is found and
'''  * its position is taken to be loc.  %maxwidth implicitly
'''  * sets a minimum on the required gradient of the edge.
'''  *   (4) The thresholds must be at least 1, and the low threshold
'''  * cannot be larger than the high threshold.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error or if the edge is not found</returns>
''' <param name="pixs"> \param[in]    pixs        1 bpp</param>
''' <param name="box"> \param[in]    box         [optional] within which the search is conducted</param>
''' <param name="lowthresh"> \param[in]    lowthresh   threshold to choose clipping location</param>
''' <param name="highthresh"> \param[in]    highthresh  threshold required to find an edge</param>
''' <param name="maxwidth"> \param[in]    maxwidth    max allowed width between low and high thresh locs</param>
''' <param name="factor"> \param[in]    factor      sampling factor along pixel counting direction</param>
''' <param name="scanflag"> \param[in]    scanflag    direction of scan; e.g., L_FROM_LEFT</param>
''' <param name="ploc"> \param[out]   ploc        location in scan direction of first black pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScanForEdge")> _
Friend Shared Function pixScanForEdge(pixs as IntPTR, box as IntPTR, lowthresh as Integer, highthresh as Integer, maxwidth as Integer, factor as Integer, scanflag as Integer, ploc as Integer) as Integer
End Function

' SRC\pix5.c (2189, 1)
' pixExtractOnLine()
' pixExtractOnLine(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) Input end points are clipped to the pix.
'''  *   (2) If the line is either horizontal, or closer to horizontal
'''  * than to vertical, the points will be extracted from left
'''  * to right in the pix.  Likewise, if the line is vertical,
'''  * or closer to vertical than to horizontal, the points will
'''  * be extracted from top to bottom.
'''  *   (3) Can be used with numaCountReverals(), for example, to
'''  * characterize the intensity smoothness along a line.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of pixel values along line, or NULL on error.</returns>
''' <param name="pixs"> \param[in]    pixs     1 bpp or 8 bpp; no colormap</param>
''' <param name="x1"> \param[in]    x1, y1   one end point for line</param>
''' <param name="y1"> \param[in]    x2, y2   another end pt for line</param>
''' <param name="x2"> \param[in]    factor   sampling; >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExtractOnLine")> _
Friend Shared Function pixExtractOnLine(pixs as IntPTR, x1 as Integer, y1 as Integer, x2 as Integer, y2 as Integer, factor as Integer) as IntPTR
End Function

' SRC\pix5.c (2309, 1)
' pixAverageOnLine()
' pixAverageOnLine(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_float32
''' <summary>
''' * Notes:
'''  *   (1) The line must be either horizontal or vertical, so either
'''  * y1 == y2 (horizontal) or x1 == x2 (vertical).
'''  *   (2) If horizontal, x1 must be = x2.
'''  * If vertical, y1 must be = y2.
'''  * characterize the intensity smoothness along a line.
'''  *   (3) Input end points are clipped to the pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  average of pixel values along line, or NULL on error.</returns>
''' <param name="pixs"> \param[in]    pixs     1 bpp or 8 bpp; no colormap</param>
''' <param name="x1"> \param[in]    x1, y1   starting pt for line</param>
''' <param name="y1"> \param[in]    x2, y2   end pt for line</param>
''' <param name="x2"> \param[in]    factor   sampling; >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAverageOnLine")> _
Friend Shared Function pixAverageOnLine(pixs as IntPTR, x1 as Integer, y1 as Integer, x2 as Integer, y2 as Integer, factor as Integer) as single
End Function

' SRC\pix5.c (2408, 1)
' pixAverageIntensityProfile()
' pixAverageIntensityProfile(PIX *, l_float32, l_int32, l_int32, l_int32, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) If d != 1 bpp, colormaps are removed and the result
'''  * is converted to 8 bpp.
'''  *   (2) If %dir == L_HORIZONTAL_LINE, the intensity is averaged
'''  * along each horizontal raster line (sampled by %factor1),
'''  * and the profile is the array of these averages in the
'''  * vertical direction between %first and %last raster lines,
'''  * and sampled by %factor2.
'''  *   (3) If %dir == L_VERTICAL_LINE, the intensity is averaged
'''  * along each vertical line (sampled by %factor1),
'''  * and the profile is the array of these averages in the
'''  * horizontal direction between %first and %last columns,
'''  * and sampled by %factor2.
'''  *   (4) The averages are measured over the central %fract of the image.
'''  * Use %fract == 1.0 to average across the entire width or height.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of reversal profile, or NULL on error.</returns>
''' <param name="pixs"> \param[in]    pixs      any depth; colormap OK</param>
''' <param name="fract"> \param[in]    fract     fraction of image width or height to be used</param>
''' <param name="dir"> \param[in]    dir       averaging direction: L_HORIZONTAL_LINE or</param>
''' <param name="first"> \param[in]    first,    last span of rows or columns to measure</param>
''' <param name="last"> \param[in]    factor1   sampling along fast scan direction; >= 1</param>
''' <param name="factor1"> \param[in]    factor2   sampling along slow scan direction; >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAverageIntensityProfile")> _
Friend Shared Function pixAverageIntensityProfile(pixs as IntPTR, fract as single, dir as Integer, first as Integer, last as Integer, factor1 as Integer, factor2 as Integer) as IntPTR
End Function

' SRC\pix5.c (2523, 1)
' pixReversalProfile()
' pixReversalProfile(PIX *, l_float32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) If d != 1 bpp, colormaps are removed and the result
'''  * is converted to 8 bpp.
'''  *   (2) If %dir == L_HORIZONTAL_LINE, the the reversals are counted
'''  * along each horizontal raster line (sampled by %factor1),
'''  * and the profile is the array of these sums in the
'''  * vertical direction between %first and %last raster lines,
'''  * and sampled by %factor2.
'''  *   (3) If %dir == L_VERTICAL_LINE, the the reversals are counted
'''  * along each vertical column (sampled by %factor1),
'''  * and the profile is the array of these sums in the
'''  * horizontal direction between %first and %last columns,
'''  * and sampled by %factor2.
'''  *   (4) For each row or column, the reversals are summed over the
'''  * central %fract of the image.  Use %fract == 1.0 to sum
'''  * across the entire width (of row) or height (of column).
'''  *   (5) %minreversal is the relative change in intensity that is
'''  * required to resolve peaks and valleys.  A typical number for
'''  * locating text in 8 bpp might be 50.  For 1 bpp, minreversal
'''  * must be 1.
'''  *   (6) The reversal profile is simply the number of reversals
'''  * in a row or column, vs the row or column index.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of reversal profile, or NULL on error.</returns>
''' <param name="pixs"> \param[in]    pixs          any depth; colormap OK</param>
''' <param name="fract"> \param[in]    fract         fraction of image width or height to be used</param>
''' <param name="dir"> \param[in]    dir           profile direction: L_HORIZONTAL_LINE or</param>
''' <param name="first"> \param[in]    first, last   span of rows or columns to measure</param>
''' <param name="last"> \param[in]    minreversal   minimum change in intensity to trigger a reversal</param>
''' <param name="minreversal"> \param[in]    factor1       sampling along raster line (fast scan); >= 1</param>
''' <param name="factor1"> \param[in]    factor2       sampling of raster lines (slow scan); >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReversalProfile")> _
Friend Shared Function pixReversalProfile(pixs as IntPTR, fract as single, dir as Integer, first as Integer, last as Integer, minreversal as Integer, factor1 as Integer, factor2 as Integer) as IntPTR
End Function

' SRC\pix5.c (2632, 1)
' pixWindowedVarianceOnLine()
' pixWindowedVarianceOnLine(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The returned variance array traverses the line starting
'''  * from the smallest coordinate, min(c1,c2).
'''  *   (2) Line end points are clipped to pixs.
'''  *   (3) The reference point for the variance calculation is the center of
'''  * the window.  Therefore, the numa start parameter from
'''  * pixExtractOnLine() is incremented by %size/2,
'''  * to align the variance values with the pixel coordinate.
'''  *   (4) The square root of the variance is the RMS deviation from the mean.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     8 bpp; no colormap</param>
''' <param name="dir"> \param[in]    dir      L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
''' <param name="loc"> \param[in]    loc      location of the constant coordinate for the line</param>
''' <param name="c1"> \param[in]    c1, c2   end point coordinates for the line</param>
''' <param name="c2"> \param[in]    size     window size; must be > 1</param>
''' <param name="size"> \param[out]   pnad     windowed square root of variance</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWindowedVarianceOnLine")> _
Friend Shared Function pixWindowedVarianceOnLine(pixs as IntPTR, dir as Integer, loc as Integer, c1 as Integer, c2 as Integer, size as Integer, pnad as Object) as Integer
End Function

' SRC\pix5.c (2750, 1)
' pixMinMaxNearLine()
' pixMinMaxNearLine(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, NUMA **, NUMA **, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If the line is more horizontal than vertical, the values
'''  * are computed for [x1, x2], and the pixels are taken
'''  * below and/or above the local y-value.  Otherwise, the
'''  * values are computed for [y1, y2] and the pixels are taken
'''  * to the left and/or right of the local x value.
'''  *   (2) %direction specifies which side (or both sides) of the
'''  * line are scanned for min and max values.
'''  *   (3) There are two ways to tell if the returned values of min
'''  * and max averages are valid: the returned values cannot be
'''  * negative and the function must return 0.
'''  *   (4) All accessed pixels are clipped to the pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error or if there are no sampled points</returns>
''' <param name="pixs"> \param[in]    pixs        8 bpp; no colormap</param>
''' <param name="x1"> \param[in]    x1, y1      starting pt for line</param>
''' <param name="y1"> \param[in]    x2, y2      end pt for line</param>
''' <param name="x2"> \param[in]    dist        distance to search from line in each direction</param>
''' <param name="y2"> \param[in]    direction   L_SCAN_NEGATIVE, L_SCAN_POSITIVE, L_SCAN_BOTH</param>
''' <param name="dist"> \param[out]   pnamin      [optional] minimum values</param>
''' <param name="direction"> \param[out]   pnamax      [optional] maximum values</param>
''' <param name="pnamin"> \param[out]   pminave     [optional] average of minimum values</param>
''' <param name="pnamax"> \param[out]   pmaxave     [optional] average of maximum values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMinMaxNearLine")> _
Friend Shared Function pixMinMaxNearLine(pixs as IntPTR, x1 as Integer, y1 as Integer, x2 as Integer, y2 as Integer, dist as Integer, direction as Integer, pnamin as Object, pnamax as Object, pminave as single, pmaxave as single) as Integer
End Function

' SRC\pix5.c (2873, 1)
' pixRankRowTransform()
' pixRankRowTransform(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *  (1) The time is O(n) in the number of pixels and runs about
'''  *   100 Mpixels/sec on a 3 GHz machine.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with pixels sorted in each row, from</returns>
''' <param name="pixs"> \param[in]    pixs   8 bpp; no colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRankRowTransform")> _
Friend Shared Function pixRankRowTransform(pixs as IntPTR) as IntPTR
End Function

' SRC\pix5.c (2926, 1)
' pixRankColumnTransform()
' pixRankColumnTransform(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *  (1) The time is O(n) in the number of pixels and runs about
'''  *   50 Mpixels/sec on a 3 GHz machine.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with pixels sorted in each column, from</returns>
''' <param name="pixs"> \param[in]    pixs   8 bpp; no colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRankColumnTransform")> _
Friend Shared Function pixRankColumnTransform(pixs as IntPTR) as IntPTR
End Function

#End Region
#Region "SRC\pixabasic.c"
' SRC\pixabasic.c (144, 16)
' pixaExtendArray()
' pixaExtendArray(PIXA *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Doubles the size of the pixa and boxa ptr arrays.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaExtendArray")> _
Friend Shared Function pixaExtendArray(pixa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (162, 1)
' pixaCreate()
' pixaCreate(l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This creates an empty boxa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa, or NULL on error</returns>
''' <param name="n"> \param[in]    n  initial number of ptrs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaCreate")> _
Friend Shared Function pixaCreate(n as Integer) as IntPTR
End Function

' SRC\pixabasic.c (201, 1)
' pixaCreateFromPix()
' pixaCreateFromPix(PIX *, l_int32, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) For bpp = 1, we truncate each retrieved pix to the ON
'''  * pixels, which we assume for now start at (0,0)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  with individual components on a lattice</param>
''' <param name="n"> \param[in]    n   number of components</param>
''' <param name="cellw"> \param[in]    cellw   width of each cell</param>
''' <param name="cellh"> \param[in]    cellh   height of each cell</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaCreateFromPix")> _
Friend Shared Function pixaCreateFromPix(pixs as IntPTR, n as Integer, cellw as Integer, cellh as Integer) as IntPTR
End Function

' SRC\pixabasic.c (264, 1)
' pixaCreateFromBoxa()
' pixaCreateFromBoxa(PIX *, BOXA *, l_int32 *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This simply extracts from pixs the region corresponding to each
'''  * box in the boxa.
'''  *   (2) The 3rd arg is optional.  If the extent of the boxa exceeds the
'''  * size of the pixa, so that some boxes are either clipped
'''  * or entirely outside the pix, a warning is returned as TRUE.
'''  *   (3) pixad will have only the properly clipped elements, and
'''  * the internal boxa will be correct.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="pcropwarn"> \param[out]   pcropwarn [optional] TRUE if the boxa extent</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaCreateFromBoxa")> _
Friend Shared Function pixaCreateFromBoxa(pixs as IntPTR, boxa as IntPTR, pcropwarn as Integer) as IntPTR
End Function

' SRC\pixabasic.c (337, 1)
' pixaSplitPix()
' pixaSplitPix(PIX *, l_int32, l_int32, l_int32, l_uint32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This is a variant on pixaCreateFromPix(), where we
'''  * simply divide the image up into (approximately) equal
'''  * subunits.  If you want the subimages to have essentially
'''  * the same aspect ratio as the input pix, use nx = ny.
'''  *   (2) If borderwidth is 0, we ignore the input bordercolor and
'''  * redefine it to white.
'''  *   (3) The bordercolor is always used to initialize each tiled pix,
'''  * so that if the src is clipped, the unblitted part will
'''  * be this color.  This avoids 1 pixel wide black stripes at the
'''  * left and lower edges.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  with individual components on a lattice</param>
''' <param name="nx"> \param[in]    nx   number of mosaic cells horizontally</param>
''' <param name="ny"> \param[in]    ny   number of mosaic cells vertically</param>
''' <param name="borderwidth"> \param[in]    borderwidth  of added border on all sides</param>
''' <param name="bordercolor"> \param[in]    bordercolor  in our RGBA format: 0xrrggbbaa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSplitPix")> _
Friend Shared Function pixaSplitPix(pixs as IntPTR, nx as Integer, ny as Integer, borderwidth as Integer, bordercolor as UInteger) as IntPTR
End Function

' SRC\pixabasic.c (399, 1)
' pixaDestroy()
' pixaDestroy(PIXA **) as void
''' <summary>
''' * Notes:
'''  *   (1) Decrements the ref count and, if 0, destroys the pixa.
'''  *   (2) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="ppixa"> \param[in,out]  ppixa can be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDestroy")> _
Friend Shared Function pixaDestroy(ppixa as Object) as Boolean ' Org. Void
End Function

' SRC\pixabasic.c (441, 1)
' pixaCopy()
' pixaCopy(PIXA *, l_int32) as PIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  new pixa, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="copyflag"> \param[in]    copyflag see pix.h for details:</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaCopy")> _
Friend Shared Function pixaCopy(pixa as IntPTR, copyflag as Integer) as IntPTR
End Function

' SRC\pixabasic.c (494, 1)
' pixaAddPix()
' pixaAddPix(PIXA *, PIX *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="pix"> \param[in]    pix  to be added</param>
''' <param name="copyflag"> \param[in]    copyflag L_INSERT, L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaAddPix")> _
Friend Shared Function pixaAddPix(pixa as IntPTR, pix as IntPTR, copyflag as Integer) as Integer
End Function

' SRC\pixabasic.c (538, 1)
' pixaAddBox()
' pixaAddBox(PIXA *, BOX *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="box"> \param[in]    box</param>
''' <param name="copyflag"> \param[in]    copyflag L_INSERT, L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaAddBox")> _
Friend Shared Function pixaAddBox(pixa as IntPTR, box as IntPTR, copyflag as Integer) as Integer
End Function

' SRC\pixabasic.c (593, 1)
' pixaExtendArrayToSize()
' pixaExtendArrayToSize(PIXA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If necessary, reallocs new pixa and boxa ptrs arrays to %size.
'''  * The pixa and boxa ptr arrays must always be equal in size.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="size"> \param[in]    size</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaExtendArrayToSize")> _
Friend Shared Function pixaExtendArrayToSize(pixa as IntPTR, size as Integer) as Integer
End Function

' SRC\pixabasic.c (622, 1)
' pixaGetCount()
' pixaGetCount(PIXA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 if no pixa</returns>
''' <param name="pixa"> \param[in]    pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGetCount")> _
Friend Shared Function pixaGetCount(pixa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (641, 1)
' pixaChangeRefcount()
' pixaChangeRefcount(PIXA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="delta"> \param[in]    delta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaChangeRefcount")> _
Friend Shared Function pixaChangeRefcount(pixa as IntPTR, delta as Integer) as Integer
End Function

' SRC\pixabasic.c (663, 1)
' pixaGetPix()
' pixaGetPix(PIXA *, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="index"> \param[in]    index  to the index-th pix</param>
''' <param name="accesstype"> \param[in]    accesstype  L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGetPix")> _
Friend Shared Function pixaGetPix(pixa as IntPTR, index as Integer, accesstype as Integer) as IntPTR
End Function

' SRC\pixabasic.c (698, 1)
' pixaGetPixDimensions()
' pixaGetPixDimensions(PIXA *, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="index"> \param[in]    index  to the index-th box</param>
''' <param name="pw"> \param[out]   pw, ph, pd [optional]  each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGetPixDimensions")> _
Friend Shared Function pixaGetPixDimensions(pixa as IntPTR, index as Integer, pw as Integer, ph as Integer, pd as Integer) as Integer
End Function

' SRC\pixabasic.c (732, 1)
' pixaGetBoxa()
' pixaGetBoxa(PIXA *, l_int32) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="accesstype"> \param[in]    accesstype  L_COPY, L_CLONE, L_COPY_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGetBoxa")> _
Friend Shared Function pixaGetBoxa(pixa as IntPTR, accesstype as Integer) as IntPTR
End Function

' SRC\pixabasic.c (756, 1)
' pixaGetBoxaCount()
' pixaGetBoxaCount(PIXA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGetBoxaCount")> _
Friend Shared Function pixaGetBoxaCount(pixa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (788, 1)
' pixaGetBox()
' pixaGetBox(PIXA *, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) There is always a boxa with a pixa, and it is initialized so
'''  * that each box ptr is NULL.
'''  *   (2) In general, we expect that there is either a box associated
'''  * with each pix, or no boxes at all in the boxa.
'''  *   (3) Having no boxes is thus not an automatic error.  Whether it
'''  * is an actual error is determined by the calling program.
'''  * If the caller expects to get a box, it is an error; see, e.g.,
'''  * pixaGetBoxGeometry().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box if null, not automatically an error, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="index"> \param[in]    index  to the index-th pix</param>
''' <param name="accesstype"> \param[in]    accesstype  L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGetBox")> _
Friend Shared Function pixaGetBox(pixa as IntPTR, index as Integer, accesstype as Integer) as IntPTR
End Function

' SRC\pixabasic.c (826, 1)
' pixaGetBoxGeometry()
' pixaGetBoxGeometry(PIXA *, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="index"> \param[in]    index  to the index-th box</param>
''' <param name="px"> \param[out]   px, py, pw, ph [optional]  each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGetBoxGeometry")> _
Friend Shared Function pixaGetBoxGeometry(pixa as IntPTR, index as Integer, px as Integer, py as Integer, pw as Integer, ph as Integer) as Integer
End Function

' SRC\pixabasic.c (868, 1)
' pixaSetBoxa()
' pixaSetBoxa(PIXA *, BOXA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This destroys the existing boxa in the pixa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="boxa"> \param[in]    boxa</param>
''' <param name="accesstype"> \param[in]    accesstype  L_INSERT, L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSetBoxa")> _
Friend Shared Function pixaSetBoxa(pixa as IntPTR, boxa as IntPTR, accesstype as Integer) as Integer
End Function

' SRC\pixabasic.c (907, 1)
' pixaGetPixArray()
' pixaGetPixArray(PIXA *) as PIX **
''' <summary>
''' * Notes:
'''  *   (1) This returns a ptr to the actual array.  The array is
'''  * owned by the pixa, so it must not be destroyed.
'''  *   (2) The caller should always check if the return value is NULL
'''  * before accessing any of the pix ptrs in this array!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix array, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGetPixArray")> _
Friend Shared Function pixaGetPixArray(pixa as IntPTR) as String
End Function

' SRC\pixabasic.c (932, 1)
' pixaVerifyDepth()
' pixaVerifyDepth(PIXA *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) It is considered to be an error if there are no pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="psame"> \param[out]   psame   1 if depth is the same for all pix; 0 otherwise</param>
''' <param name="pmaxd"> \param[out]   pmaxd   [optional] max depth of all pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaVerifyDepth")> _
Friend Shared Function pixaVerifyDepth(pixa as IntPTR, psame as Integer, pmaxd as Integer) as Integer
End Function

' SRC\pixabasic.c (978, 1)
' pixaVerifyDimensions()
' pixaVerifyDimensions(PIXA *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) It is considered to be an error if there are no pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="psame"> \param[out]   psame   1 if dimensions are the same for all pix; 0 otherwise</param>
''' <param name="pmaxw"> \param[out]   pmaxw   [optional] max width of all pix</param>
''' <param name="pmaxh"> \param[out]   pmaxh   [optional] max height of all pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaVerifyDimensions")> _
Friend Shared Function pixaVerifyDimensions(pixa as IntPTR, psame as Integer, pmaxw as Integer, pmaxh as Integer) as Integer
End Function

' SRC\pixabasic.c (1029, 1)
' pixaIsFull()
' pixaIsFull(PIXA *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) A pixa is "full" if the array of pix is fully
'''  * occupied from index 0 to index (pixa->n - 1).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="pfullpa"> \param[out]   pfullpa [optional] 1 if pixa is full</param>
''' <param name="pfullba"> \param[out]   pfullba [optional] 1 if boxa is full</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaIsFull")> _
Friend Shared Function pixaIsFull(pixa as IntPTR, pfullpa as Integer, pfullba as Integer) as Integer
End Function

' SRC\pixabasic.c (1079, 1)
' pixaCountText()
' pixaCountText(PIXA *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) All pix have non-empty text strings if the returned value %ntext
'''  * equals the pixa count.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="pntext"> \param[out]   pntext number of pix with non-empty text strings</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaCountText")> _
Friend Shared Function pixaCountText(pixa as IntPTR, pntext as Integer) as Integer
End Function

' SRC\pixabasic.c (1122, 1)
' pixaSetText()
' pixaSetText(PIXA *, SARRAY *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) To clear all the text fields, use sa == NULL;
'''  *   (2) If sa is defined, it must be the same size as %pixa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="sa"> \param[in]    sa  [optional] array of text strings, to insert in each pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSetText")> _
Friend Shared Function pixaSetText(pixa as IntPTR, sa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (1180, 1)
' pixaGetLinePtrs()
' pixaGetLinePtrs(PIXA *, l_int32 *) as void ***
''' <summary>
''' * Notes:
'''  *   (1) See pixGetLinePtrs() for details.
'''  *   (2) It is best if all pix in the pixa are the same size.
'''  * The size of each line ptr array is equal to the height
'''  * of the pix that it refers to.
'''  *   (3) This is an array of arrays.  To destroy it:
'''  *   for (i = 0; i  size; i++)
'''  * LEPT_FREE(lineset[i]);
'''  *   LEPT_FREE(lineset);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  array of array of line ptrs, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa of pix that all have the same depth</param>
''' <param name="psize"> \param[out]   psize [optional] number of pix in the pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGetLinePtrs")> _
Friend Shared Function pixaGetLinePtrs(pixa as IntPTR, psize as Integer) as String
End Function

' SRC\pixabasic.c (1228, 1)
' pixaWriteStreamInfo()
' pixaWriteStreamInfo(FILE *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For each pix in the pixa, write out the pix dimensions, spp,
'''  * text string (if it exists), and cmap info.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="pixa"> \param[in]    pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaWriteStreamInfo")> _
Friend Shared Function pixaWriteStreamInfo(fp as Object, pixa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (1286, 1)
' pixaReplacePix()
' pixaReplacePix(PIXA *, l_int32, PIX *, BOX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) In-place replacement of one pix.
'''  *   (2) The previous pix at that location is destroyed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="index"> \param[in]    index  to the index-th pix</param>
''' <param name="pix"> \param[in]    pix insert to replace existing one</param>
''' <param name="box"> \param[in]    box [optional] insert to replace existing</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaReplacePix")> _
Friend Shared Function pixaReplacePix(pixa as IntPTR, index as Integer, pix as IntPTR, box as IntPTR) as Integer
End Function

' SRC\pixabasic.c (1336, 1)
' pixaInsertPix()
' pixaInsertPix(PIXA *, l_int32, PIX *, BOX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This shifts pixa[i] --> pixa[i + 1] for all i >= index,
'''  * and then inserts at pixa[index].
'''  *   (2) To insert at the beginning of the array, set index = 0.
'''  *   (3) It should not be used repeatedly on large arrays,
'''  * because the function is O(n).
'''  *   (4) To append a pix to a pixa, it's easier to use pixaAddPix().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="index"> \param[in]    index at which pix is to be inserted</param>
''' <param name="pixs"> \param[in]    pixs new pix to be inserted</param>
''' <param name="box"> \param[in]    box [optional] new box to be inserted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaInsertPix")> _
Friend Shared Function pixaInsertPix(pixa as IntPTR, index as Integer, pixs as IntPTR, box as IntPTR) as Integer
End Function

' SRC\pixabasic.c (1386, 1)
' pixaRemovePix()
' pixaRemovePix(PIXA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This shifts pixa[i] --> pixa[i - 1] for all i > index.
'''  *   (2) It should not be used repeatedly on large arrays,
'''  * because the function is O(n).
'''  *   (3) The corresponding box is removed as well, if it exists.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="index"> \param[in]    index of pix to be removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaRemovePix")> _
Friend Shared Function pixaRemovePix(pixa as IntPTR, index as Integer) as Integer
End Function

' SRC\pixabasic.c (1438, 1)
' pixaRemovePixAndSave()
' pixaRemovePixAndSave(PIXA *, l_int32, PIX **, BOX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This shifts pixa[i] --> pixa[i - 1] for all i > index.
'''  *   (2) It should not be used repeatedly on large arrays,
'''  * because the function is O(n).
'''  *   (3) The corresponding box is removed as well, if it exists.
'''  *   (4) The removed pix and box can either be retained or destroyed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="index"> \param[in]    index of pix to be removed</param>
''' <param name="ppix"> \param[out]   ppix [optional] removed pix</param>
''' <param name="pbox"> \param[out]   pbox [optional] removed box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaRemovePixAndSave")> _
Friend Shared Function pixaRemovePixAndSave(pixa as IntPTR, index as Integer, ppix as Object, pbox as Object) as Integer
End Function

' SRC\pixabasic.c (1513, 1)
' pixaInitFull()
' pixaInitFull(PIXA *, PIX *, BOX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This initializes a pixa by filling up the entire pix ptr array
'''  * with copies of %pix.  If %pix == NULL, we use a tiny placeholder
'''  * pix (w = h = d = 1).  Any existing pix are destroyed.
'''  * It also optionally fills the boxa with copies of %box.
'''  * After this operation, the numbers of pix and (optionally)
'''  * boxes are equal to the number of allocated ptrs.
'''  *   (2) Note that we use pixaReplacePix() instead of pixaInsertPix().
'''  * They both have the same effect when inserting into a NULL ptr
'''  * in the pixa ptr array:
'''  *   (3) If the boxa is not initialized (i.e., filled with boxes),
'''  * later insertion of boxes will cause an error, because the
'''  * 'n' field is 0.
'''  *   (4) Example usage.  This function is useful to prepare for a
'''  * random insertion (or replacement) of pix into a pixa.
'''  * To randomly insert pix into a pixa, without boxes, up to
'''  * some index "max":
'''  * Pixa *pixa = pixaCreate(max);
'''  * pixaInitFull(pixa, NULL, NULL);
'''  * An existing pixa with a smaller ptr array can also be reused:
'''  * pixaExtendArrayToSize(pixa, max);
'''  * pixaInitFull(pixa, NULL, NULL);
'''  * The initialization allows the pixa to always be properly
'''  * filled, even if all pix (and boxes) are not later replaced.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa typically empty</param>
''' <param name="pix"> \param[in]    pix [optional] to be replicated into the entire pixa ptr array</param>
''' <param name="box"> \param[in]    box [optional] to be replicated into the entire boxa ptr array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaInitFull")> _
Friend Shared Function pixaInitFull(pixa as IntPTR, pix as IntPTR, box as IntPTR) as Integer
End Function

' SRC\pixabasic.c (1555, 1)
' pixaClear()
' pixaClear(PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This destroys all pix in the pixa, as well as
'''  * all boxes in the boxa.  The ptrs in the pix ptr array
'''  * are all null'd.  The number of allocated pix, n, is set to 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaClear")> _
Friend Shared Function pixaClear(pixa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (1593, 1)
' pixaJoin()
' pixaJoin(PIXA *, PIXA *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This appends a clone of each indicated pix in pixas to pixad
'''  *   (2) istart  0 is taken to mean 'read from the start' (istart = 0)
'''  *   (3) iend  0 means 'read to the end'
'''  *   (4) If pixas is NULL or contains no pix, this is a no-op.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixad"> \param[in]    pixad  dest pixa; add to this one</param>
''' <param name="pixas"> \param[in]    pixas  [optional] source pixa; add from this one</param>
''' <param name="istart"> \param[in]    istart  starting index in pixas</param>
''' <param name="iend"> \param[in]    iend  ending index in pixas; use -1 to cat all</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaJoin")> _
Friend Shared Function pixaJoin(pixad as IntPTR, pixas as IntPTR, istart as Integer, iend as Integer) as Integer
End Function

' SRC\pixabasic.c (1649, 1)
' pixaInterleave()
' pixaInterleave(PIXA *, PIXA *, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) %copyflag determines if the pix are copied or cloned.
'''  * The boxes, if they exist, are copied.
'''  *   (2) If the two pixa have different sizes, a warning is issued,
'''  * and the number of pairs returned is the minimum size.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa  interleaved from sources, or NULL on error.</returns>
''' <param name="pixa1"> \param[in]    pixa1  first src pixa</param>
''' <param name="pixa2"> \param[in]    pixa2  second src pixa</param>
''' <param name="copyflag"> \param[in]    copyflag L_CLONE, L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaInterleave")> _
Friend Shared Function pixaInterleave(pixa1 as IntPTR, pixa2 as IntPTR, copyflag as Integer) as IntPTR
End Function

' SRC\pixabasic.c (1714, 1)
' pixaaJoin()
' pixaaJoin(PIXAA *, PIXAA *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This appends a clone of each indicated pixa in paas to pixaad
'''  *   (2) istart  0 is taken to mean 'read from the start' (istart = 0)
'''  *   (3) iend  0 means 'read to the end'
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="paad"> \param[in]    paad  dest pixaa; add to this one</param>
''' <param name="paas"> \param[in]    paas  [optional] source pixaa; add from this one</param>
''' <param name="istart"> \param[in]    istart  starting index in pixaas</param>
''' <param name="iend"> \param[in]    iend  ending index in pixaas; use -1 to cat all</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaJoin")> _
Friend Shared Function pixaaJoin(paad as IntPTR, paas as IntPTR, istart as Integer, iend as Integer) as Integer
End Function

' SRC\pixabasic.c (1772, 1)
' pixaaCreate()
' pixaaCreate(l_int32) as PIXAA *
''' <summary>
''' * Notes:
'''  *   (1) A pixaa provides a 2-level hierarchy of images.
'''  * A common use is for segmentation masks, which are
'''  * inexpensive to store in png format.
'''  *   (2) For example, suppose you want a mask for each textline
'''  * in a two-column page.  The textline masks for each column
'''  * can be represented by a pixa, of which there are 2 in the pixaa.
'''  * The boxes for the textline mask components within a column
'''  * can have their origin referred to the column rather than the page.
'''  * Then the boxa field can be used to represent the two box (regions)
'''  * for the columns, and the (x,y) components of each box can
'''  * be used to get the absolute position of the textlines on
'''  * the page.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  paa, or NULL on error</returns>
''' <param name="n"> \param[in]    n  initial number of pixa ptrs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaCreate")> _
Friend Shared Function pixaaCreate(n as Integer) as IntPTR
End Function

' SRC\pixabasic.c (1817, 1)
' pixaaCreateFromPixa()
' pixaaCreateFromPixa(PIXA *, l_int32, l_int32, l_int32) as PIXAA *
''' <summary>
''' * Notes:
'''  *   (1) This subdivides a pixa into a set of smaller pixa that
'''  * are accumulated into a pixaa.
'''  *   (2) If type == L_CHOOSE_CONSECUTIVE, the first 'n' pix are
'''  * put in a pixa and added to pixaa, then the next 'n', etc.
'''  * If type == L_CHOOSE_SKIP_BY, the first pixa is made by
'''  * aggregating pix[0], pix[n], pix[2*n], etc.
'''  *   (3) The copyflag specifies if each new pix is a copy or a clone.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  paa, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="n"> \param[in]    n number specifying subdivision of pixa</param>
''' <param name="type"> \param[in]    type L_CHOOSE_CONSECUTIVE, L_CHOOSE_SKIP_BY</param>
''' <param name="copyflag"> \param[in]    copyflag L_CLONE, L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaCreateFromPixa")> _
Friend Shared Function pixaaCreateFromPixa(pixa as IntPTR, n as Integer, type as Integer, copyflag as Integer) as IntPTR
End Function

' SRC\pixabasic.c (1879, 1)
' pixaaDestroy()
' pixaaDestroy(PIXAA **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="ppaa"> \param[in,out]   ppaa to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaDestroy")> _
Friend Shared Function pixaaDestroy(ppaa as Object) as Boolean ' Org. Void
End Function

' SRC\pixabasic.c (1923, 1)
' pixaaAddPixa()
' pixaaAddPixa(PIXAA *, PIXA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="pixa"> \param[in]    pixa  to be added</param>
''' <param name="copyflag"> \param[in]    copyflag:</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaAddPixa")> _
Friend Shared Function pixaaAddPixa(paa as IntPTR, pixa as IntPTR, copyflag as Integer) as Integer
End Function

' SRC\pixabasic.c (1964, 1)
' pixaaExtendArray()
' pixaaExtendArray(PIXAA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="paa"> \param[in]    paa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaExtendArray")> _
Friend Shared Function pixaaExtendArray(paa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (1992, 1)
' pixaaAddPix()
' pixaaAddPix(PIXAA *, l_int32, PIX *, BOX *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="paa"> \param[in]    paa  input paa</param>
''' <param name="index"> \param[in]    index index of pixa in paa</param>
''' <param name="pix"> \param[in]    pix to be added</param>
''' <param name="box"> \param[in]    box [optional] to be added</param>
''' <param name="copyflag"> \param[in]    copyflag L_INSERT, L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaAddPix")> _
Friend Shared Function pixaaAddPix(paa as IntPTR, index as Integer, pix as IntPTR, box as IntPTR, copyflag as Integer) as Integer
End Function

' SRC\pixabasic.c (2031, 1)
' pixaaAddBox()
' pixaaAddBox(PIXAA *, BOX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The box can be used, for example, to hold the support region
'''  * of a pixa that is being added to the pixaa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="box"> \param[in]    box</param>
''' <param name="copyflag"> \param[in]    copyflag L_INSERT, L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaAddBox")> _
Friend Shared Function pixaaAddBox(paa as IntPTR, box as IntPTR, copyflag as Integer) as Integer
End Function

' SRC\pixabasic.c (2066, 1)
' pixaaGetCount()
' pixaaGetCount(PIXAA *, NUMA **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) If paa is empty, a returned na will also be empty.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 if no pixaa</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="pna"> \param[out]   pna [optional] number of pix in each pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaGetCount")> _
Friend Shared Function pixaaGetCount(paa as IntPTR, pna as Object) as Integer
End Function

' SRC\pixabasic.c (2115, 1)
' pixaaGetPixa()
' pixaaGetPixa(PIXAA *, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) L_COPY makes a new pixa with a copy of every pix
'''  *   (2) L_CLONE just makes a new reference to the pixa,
'''  * and bumps the counter.  You would use this, for example,
'''  * when you need to extract some data from a pix within a
'''  * pixa within a pixaa.
'''  *   (3) L_COPY_CLONE makes a new pixa with a clone of every pix
'''  * and box
'''  *   (4) In all cases, you must invoke pixaDestroy() on the returned pixa
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa, or NULL on error</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="index"> \param[in]    index  to the index-th pixa</param>
''' <param name="accesstype"> \param[in]    accesstype  L_COPY, L_CLONE, L_COPY_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaGetPixa")> _
Friend Shared Function pixaaGetPixa(paa as IntPTR, index as Integer, accesstype as Integer) as IntPTR
End Function

' SRC\pixabasic.c (2153, 1)
' pixaaGetBoxa()
' pixaaGetBoxa(PIXAA *, l_int32) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) L_COPY returns a copy; L_CLONE returns a new reference to the boxa.
'''  *   (2) In both cases, invoke boxaDestroy() on the returned boxa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="accesstype"> \param[in]    accesstype  L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaGetBoxa")> _
Friend Shared Function pixaaGetBoxa(paa as IntPTR, accesstype as Integer) as IntPTR
End Function

' SRC\pixabasic.c (2177, 1)
' pixaaGetPix()
' pixaaGetPix(PIXAA *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="index"> \param[in]    index  index into the pixa array in the pixaa</param>
''' <param name="ipix"> \param[in]    ipix  index into the pix array in the pixa</param>
''' <param name="accessflag"> \param[in]    accessflag  L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaGetPix")> _
Friend Shared Function pixaaGetPix(paa as IntPTR, index as Integer, ipix as Integer, accessflag as Integer) as IntPTR
End Function

' SRC\pixabasic.c (2210, 1)
' pixaaVerifyDepth()
' pixaaVerifyDepth(PIXAA *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) It is considered to be an error if any pixa have no pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   0 if OK; 1 on error</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="psame"> \param[out]   psame   1 if all pix have the same depth; 0 otherwise</param>
''' <param name="pmaxd"> \param[out]   pmaxd   [optional] max depth of all pix in pixaa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaVerifyDepth")> _
Friend Shared Function pixaaVerifyDepth(paa as IntPTR, psame as Integer, pmaxd as Integer) as Integer
End Function

' SRC\pixabasic.c (2260, 1)
' pixaaVerifyDimensions()
' pixaaVerifyDimensions(PIXAA *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) It is considered to be an error if any pixa have no pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   0 if OK; 1 on error</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="psame"> \param[out]   psame   1 if all pix have the same depth; 0 otherwise</param>
''' <param name="pmaxw"> \param[out]   pmaxw   [optional] max width of all pix in pixaa</param>
''' <param name="pmaxh"> \param[out]   pmaxh   [optional] max height of all pix in pixaa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaVerifyDimensions")> _
Friend Shared Function pixaaVerifyDimensions(paa as IntPTR, psame as Integer, pmaxw as Integer, pmaxh as Integer) as Integer
End Function

' SRC\pixabasic.c (2314, 1)
' pixaaIsFull()
' pixaaIsFull(PIXAA *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Does not require boxa associated with each pixa to be full.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  return 0 if OK, 1 on error</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="pfull"> \param[out]   pfull 1 if all pixa in the paa have full pix arrays</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaIsFull")> _
Friend Shared Function pixaaIsFull(paa as IntPTR, pfull as Integer) as Integer
End Function

' SRC\pixabasic.c (2366, 1)
' pixaaInitFull()
' pixaaInitFull(PIXAA *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This initializes a pixaa by filling up the entire pixa ptr array
'''  * with copies of %pixa.  Any existing pixa are destroyed.
'''  *   (2) Example usage.  This function is useful to prepare for a
'''  * random insertion (or replacement) of pixa into a pixaa.
'''  * To randomly insert pixa into a pixaa, up to some index "max":
'''  * Pixaa *paa = pixaaCreate(max);
'''  * Pixa *pixa = pixaCreate(1);  // if you want little memory
'''  * pixaaInitFull(paa, pixa);  // copy it to entire array
'''  * pixaDestroy(&pixa);  // no longer needed
'''  * The initialization allows the pixaa to always be properly filled.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="paa"> \param[in]    paa typically empty</param>
''' <param name="pixa"> \param[in]    pixa to be replicated into the entire pixa ptr array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaInitFull")> _
Friend Shared Function pixaaInitFull(paa as IntPTR, pixa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (2408, 1)
' pixaaReplacePixa()
' pixaaReplacePixa(PIXAA *, l_int32, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This allows random insertion of a pixa into a pixaa, with
'''  * destruction of any existing pixa at that location.
'''  * The input pixa is now owned by the pixaa.
'''  *   (2) No other pixa in the array are affected.
'''  *   (3) The index must be within the allowed set.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="index"> \param[in]    index  to the index-th pixa</param>
''' <param name="pixa"> \param[in]    pixa insert to replace existing one</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaReplacePixa")> _
Friend Shared Function pixaaReplacePixa(paa as IntPTR, index as Integer, pixa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (2441, 1)
' pixaaClear()
' pixaaClear(PIXAA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This destroys all pixa in the pixaa, and nulls the ptrs
'''  * in the pixa ptr array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="paa"> \param[in]    paa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaClear")> _
Friend Shared Function pixaaClear(paa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (2472, 1)
' pixaaTruncate()
' pixaaTruncate(PIXAA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This identifies the largest index containing a pixa that
'''  * has any pix within it, destroys all pixa above that index,
'''  * and resets the count.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="paa"> \param[in]    paa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaTruncate")> _
Friend Shared Function pixaaTruncate(paa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (2519, 1)
' pixaRead()
' pixaRead(const char *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) The pix are stored in the file as png.
'''  * If the png library is not linked, this will fail.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaRead")> _
Friend Shared Function pixaRead(filename as String) as IntPTR
End Function

' SRC\pixabasic.c (2556, 1)
' pixaReadStream()
' pixaReadStream(FILE *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) The pix are stored in the file as png.
'''  * If the png library is not linked, this will fail.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaReadStream")> _
Friend Shared Function pixaReadStream(fp as Object) as IntPTR
End Function

' SRC\pixabasic.c (2615, 1)
' pixaReadMem()
' pixaReadMem(const l_uint8 *, size_t) as PIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa, or NULL on error</returns>
''' <param name="data"> \param[in]    data  of serialized pixa</param>
''' <param name="size"> \param[in]    size  of data in bytes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaReadMem")> _
Friend Shared Function pixaReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\pixabasic.c (2652, 1)
' pixaWriteDebug()
' pixaWriteDebug(const char *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Debug version, intended for use in the library when writing
'''  * to files in a temp directory with names that are compiled in.
'''  * This is used instead of pixaWrite() for all such library calls.
'''  *   (2) The global variable LeptDebugOK defaults to 0, and can be set
'''  * or cleared by the function setLeptDebugOK().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fname"> \param[in]    fname</param>
''' <param name="pixa"> \param[in]    pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaWriteDebug")> _
Friend Shared Function pixaWriteDebug(fname as String, pixa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (2680, 1)
' pixaWrite()
' pixaWrite(const char *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The pix are stored in the file as png.
'''  * If the png library is not linked, this will fail.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pixa"> \param[in]    pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaWrite")> _
Friend Shared Function pixaWrite(filename as String, pixa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (2721, 1)
' pixaWriteStream()
' pixaWriteStream(FILE *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The pix are stored in the file as png.
'''  * If the png library is not linked, this will fail.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream opened for "wb"</param>
''' <param name="pixa"> \param[in]    pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaWriteStream")> _
Friend Shared Function pixaWriteStream(fp as Object, pixa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (2768, 1)
' pixaWriteMem()
' pixaWriteMem(l_uint8 **, size_t *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a pixa in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of serialized pixa</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="pixa"> \param[in]    pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaWriteMem")> _
Friend Shared Function pixaWriteMem(pdata as Object, psize as ULong, pixa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (2821, 1)
' pixaReadBoth()
' pixaReadBoth(const char *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This reads serialized files of either a pixa or a pixacomp,
'''  * and returns a pixa in memory.  It requires png and jpeg libraries.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaReadBoth")> _
Friend Shared Function pixaReadBoth(filename as String) as IntPTR
End Function

' SRC\pixabasic.c (2878, 1)
' pixaaReadFromFiles()
' pixaaReadFromFiles(const char *, const char *, l_int32, l_int32) as PIXAA *
''' <summary>
''' * Notes:
'''  *   (1) The files must be serialized pixa files (e.g., *.pa)
'''  * If some files cannot be read, warnings are issued.
'''  *   (2) Use %substr to filter filenames in the directory.  If
'''  * %substr == NULL, this takes all files.
'''  *   (3) After filtering, use %first and %nfiles to select
'''  * a contiguous set of files, that have been lexically
'''  * sorted in increasing order.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  paa, or NULL on error or if no pixa files are found.</returns>
''' <param name="dirname"> \param[in]    dirname directory</param>
''' <param name="substr"> \param[in]    substr [optional] substring filter on filenames; can be NULL</param>
''' <param name="first"> \param[in]    first 0-based</param>
''' <param name="nfiles"> \param[in]    nfiles use 0 for everything from %first to the end</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaReadFromFiles")> _
Friend Shared Function pixaaReadFromFiles(dirname as String, substr as String, first as Integer, nfiles as Integer) as IntPTR
End Function

' SRC\pixabasic.c (2928, 1)
' pixaaRead()
' pixaaRead(const char *) as PIXAA *
''' <summary>
''' * Notes:
'''  *   (1) The pix are stored in the file as png.
'''  * If the png library is not linked, this will fail.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  paa, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaRead")> _
Friend Shared Function pixaaRead(filename as String) as IntPTR
End Function

' SRC\pixabasic.c (2965, 1)
' pixaaReadStream()
' pixaaReadStream(FILE *) as PIXAA *
''' <summary>
''' * Notes:
'''  *   (1) The pix are stored in the file as png.
'''  * If the png library is not linked, this will fail.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  paa, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaReadStream")> _
Friend Shared Function pixaaReadStream(fp as Object) as IntPTR
End Function

' SRC\pixabasic.c (3023, 1)
' pixaaReadMem()
' pixaaReadMem(const l_uint8 *, size_t) as PIXAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  paa, or NULL on error</returns>
''' <param name="data"> \param[in]    data  of serialized pixaa</param>
''' <param name="size"> \param[in]    size  of data in bytes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaReadMem")> _
Friend Shared Function pixaaReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\pixabasic.c (3057, 1)
' pixaaWrite()
' pixaaWrite(const char *, PIXAA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The pix are stored in the file as png.
'''  * If the png library is not linked, this will fail.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="paa"> \param[in]    paa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaWrite")> _
Friend Shared Function pixaaWrite(filename as String, paa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (3098, 1)
' pixaaWriteStream()
' pixaaWriteStream(FILE *, PIXAA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The pix are stored in the file as png.
'''  * If the png library is not linked, this will fail.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream opened for "wb"</param>
''' <param name="paa"> \param[in]    paa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaWriteStream")> _
Friend Shared Function pixaaWriteStream(fp as Object, paa as IntPTR) as Integer
End Function

' SRC\pixabasic.c (3144, 1)
' pixaaWriteMem()
' pixaaWriteMem(l_uint8 **, size_t *, PIXAA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a pixaa in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of serialized pixaa</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="paa"> \param[in]    paa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaWriteMem")> _
Friend Shared Function pixaaWriteMem(pdata as Object, psize as ULong, paa as IntPTR) as Integer
End Function

#End Region
#Region "SRC\pixacc.c"
' SRC\pixacc.c (90, 1)
' pixaccCreate()
' pixaccCreate(l_int32, l_int32, l_int32) as PIXACC *
''' <summary>
''' * Notes:
'''  *   (1) Use %negflag = 1 for safety if any negative numbers are going
'''  * to be used in the chain of operations.  Negative numbers
'''  * arise, e.g., by subtracting a pix, or by adding a pix
'''  * that has been pre-multiplied by a negative number.
'''  *   (2) Initializes the internal 32 bpp pix, similarly to the
'''  * initialization in pixInitAccumulate().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixacc, or NULL on error</returns>
''' <param name="w"> \param[in]    w, h of 32 bpp internal Pix</param>
''' <param name="h"> \param[in]    negflag 0 if only positive numbers are involved;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaccCreate")> _
Friend Shared Function pixaccCreate(w as Integer, h as Integer, negflag as Integer) as IntPTR
End Function

' SRC\pixacc.c (131, 1)
' pixaccCreateFromPix()
' pixaccCreateFromPix(PIX *, l_int32) as PIXACC *
''' <summary>
''' * Notes:
'''  *   (1) See pixaccCreate()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixacc, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="negflag"> \param[in]    negflag 0 if only positive numbers are involved;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaccCreateFromPix")> _
Friend Shared Function pixaccCreateFromPix(pix as IntPTR, negflag as Integer) as IntPTR
End Function

' SRC\pixacc.c (160, 1)
' pixaccDestroy()
' pixaccDestroy(PIXACC **) as void
''' <summary>
''' * Notes:
'''  *   (1) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="ppixacc"> \param[in,out] ppixacc to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaccDestroy")> _
Friend Shared Function pixaccDestroy(ppixacc as Object) as Boolean ' Org. Void
End Function

' SRC\pixacc.c (192, 1)
' pixaccFinal()
' pixaccFinal(PIXACC *, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 , 16 or 32 bpp, or NULL on error</returns>
''' <param name="pixacc"> \param[in]    pixacc</param>
''' <param name="outdepth"> \param[in]    outdepth 8, 16 or 32 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaccFinal")> _
Friend Shared Function pixaccFinal(pixacc as IntPTR, outdepth as Integer) as IntPTR
End Function

' SRC\pixacc.c (215, 1)
' pixaccGetPix()
' pixaccGetPix(PIXACC *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="pixacc"> \param[in]    pixacc</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaccGetPix")> _
Friend Shared Function pixaccGetPix(pixacc as IntPTR) as IntPTR
End Function

' SRC\pixacc.c (232, 1)
' pixaccGetOffset()
' pixaccGetOffset(PIXACC *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  offset, or -1 on error</returns>
''' <param name="pixacc"> \param[in]    pixacc</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaccGetOffset")> _
Friend Shared Function pixaccGetOffset(pixacc as IntPTR) as Integer
End Function

' SRC\pixacc.c (253, 1)
' pixaccAdd()
' pixaccAdd(PIXACC *, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixacc"> \param[in]    pixacc</param>
''' <param name="pix"> \param[in]    pix to be added</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaccAdd")> _
Friend Shared Function pixaccAdd(pixacc as IntPTR, pix as IntPTR) as Integer
End Function

' SRC\pixacc.c (275, 1)
' pixaccSubtract()
' pixaccSubtract(PIXACC *, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixacc"> \param[in]    pixacc</param>
''' <param name="pix"> \param[in]    pix to be subtracted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaccSubtract")> _
Friend Shared Function pixaccSubtract(pixacc as IntPTR, pix as IntPTR) as Integer
End Function

' SRC\pixacc.c (297, 1)
' pixaccMultConst()
' pixaccMultConst(PIXACC *, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixacc"> \param[in]    pixacc</param>
''' <param name="factor"> \param[in]    factor</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaccMultConst")> _
Friend Shared Function pixaccMultConst(pixacc as IntPTR, factor as single) as Integer
End Function

' SRC\pixacc.c (325, 1)
' pixaccMultConstAccumulate()
' pixaccMultConstAccumulate(PIXACC *, PIX *, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This creates a temp pix that is %pix multiplied by the
'''  * constant %factor.  It then adds that into %pixacc.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixacc"> \param[in]    pixacc</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="factor"> \param[in]    factor</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaccMultConstAccumulate")> _
Friend Shared Function pixaccMultConstAccumulate(pixacc as IntPTR, pix as IntPTR, factor as single) as Integer
End Function

#End Region
#Region "SRC\pixafunc1.c"
' SRC\pixafunc1.c (212, 1)
' pixSelectBySize()
' pixSelectBySize(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The args specify constraints on the size of the
'''  * components that are kept.
'''  *   (2) If unchanged, returns a copy of pixs.  Otherwise,
'''  * returns a new pix with the filtered components.
'''  *   (3) If the selection type is L_SELECT_WIDTH, the input
'''  * height is ignored, and v.v.
'''  *   (4) To keep small components, use relation = L_SELECT_IF_LT or
'''  * L_SELECT_IF_LTE.
'''  * To keep large components, use relation = L_SELECT_IF_GT or
'''  * L_SELECT_IF_GTE.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  filtered pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs           1 bpp</param>
''' <param name="width"> \param[in]    width, height  threshold dimensions</param>
''' <param name="height"> \param[in]    connectivity   4 or 8</param>
''' <param name="connectivity"> \param[in]    type           L_SELECT_WIDTH, L_SELECT_HEIGHT,</param>
''' <param name="type"> \param[in]    relation       L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
''' <param name="relation"> \param[out]   pchanged       [optional] 1 if changed; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSelectBySize")> _
Friend Shared Function pixSelectBySize(pixs as IntPTR, width as Integer, height as Integer, connectivity as Integer, type as Integer, relation as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (299, 1)
' pixaSelectBySize()
' pixaSelectBySize(PIXA *, l_int32, l_int32, l_int32, l_int32, l_int32 *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) The args specify constraints on the size of the
'''  * components that are kept.
'''  *   (2) Uses pix and box clones in the new pixa.
'''  *   (3) If the selection type is L_SELECT_WIDTH, the input
'''  * height is ignored, and v.v.
'''  *   (4) To keep small components, use relation = L_SELECT_IF_LT or
'''  * L_SELECT_IF_LTE.
'''  * To keep large components, use relation = L_SELECT_IF_GT or
'''  * L_SELECT_IF_GTE.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="width"> \param[in]    width, height  threshold dimensions</param>
''' <param name="height"> \param[in]    type           L_SELECT_WIDTH, L_SELECT_HEIGHT,</param>
''' <param name="type"> \param[in]    relation       L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
''' <param name="relation"> \param[out]   pchanged       [optional] 1 if changed; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSelectBySize")> _
Friend Shared Function pixaSelectBySize(pixas as IntPTR, width as Integer, height as Integer, type as Integer, relation as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (355, 1)
' pixaMakeSizeIndicator()
' pixaMakeSizeIndicator(PIXA *, l_int32, l_int32, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The args specify constraints on the size of the
'''  * components that are kept.
'''  *   (2) If the selection type is L_SELECT_WIDTH, the input
'''  * height is ignored, and v.v.
'''  *   (3) To keep small components, use relation = L_SELECT_IF_LT or
'''  * L_SELECT_IF_LTE.
'''  * To keep large components, use relation = L_SELECT_IF_GT or
'''  * L_SELECT_IF_GTE.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na indicator array, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="width"> \param[in]    width, height  threshold dimensions</param>
''' <param name="height"> \param[in]    type           L_SELECT_WIDTH, L_SELECT_HEIGHT,</param>
''' <param name="type"> \param[in]    relation       L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaMakeSizeIndicator")> _
Friend Shared Function pixaMakeSizeIndicator(pixa as IntPTR, width as Integer, height as Integer, type as Integer, relation as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (446, 1)
' pixSelectByPerimToAreaRatio()
' pixSelectByPerimToAreaRatio(PIX *, l_float32, l_int32, l_int32, l_int32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The args specify constraints on the size of the
'''  * components that are kept.
'''  *   (2) If unchanged, returns a copy of pixs.  Otherwise,
'''  * returns a new pix with the filtered components.
'''  *   (3) This filters "thick" components, where a thick component
'''  * is defined to have a ratio of boundary to interior pixels
'''  * that is smaller than a given threshold value.
'''  *   (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the thicker
'''  * components, and L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs          1 bpp</param>
''' <param name="thresh"> \param[in]    thresh        threshold ratio of fg boundary to fg pixels</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
''' <param name="type"> \param[in]    type          L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
''' <param name="pchanged"> \param[out]   pchanged      [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSelectByPerimToAreaRatio")> _
Friend Shared Function pixSelectByPerimToAreaRatio(pixs as IntPTR, thresh as single, connectivity as Integer, type as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (520, 1)
' pixaSelectByPerimToAreaRatio()
' pixaSelectByPerimToAreaRatio(PIXA *, l_float32, l_int32, l_int32 *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Returns a pixa clone if no components are removed.
'''  *   (2) Uses pix and box clones in the new pixa.
'''  *   (3) See pixSelectByPerimToAreaRatio().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="thresh"> \param[in]    thresh     threshold ratio of fg boundary to fg pixels</param>
''' <param name="type"> \param[in]    type       L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
''' <param name="pchanged"> \param[out]   pchanged   [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSelectByPerimToAreaRatio")> _
Friend Shared Function pixaSelectByPerimToAreaRatio(pixas as IntPTR, thresh as single, type as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (577, 1)
' pixSelectByPerimSizeRatio()
' pixSelectByPerimSizeRatio(PIX *, l_float32, l_int32, l_int32, l_int32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The args specify constraints on the size of the
'''  * components that are kept.
'''  *   (2) If unchanged, returns a copy of pixs.  Otherwise,
'''  * returns a new pix with the filtered components.
'''  *   (3) This filters components with smooth vs. dendritic shape, using
'''  * the ratio of the fg boundary pixels to the circumference of
'''  * the bounding box, and comparing it to a threshold value.
'''  *   (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the smooth
'''  * boundary components, and L_SELECT_IF_GT or L_SELECT_IF_GTE
'''  * to remove them.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs          1 bpp</param>
''' <param name="thresh"> \param[in]    thresh        threshold ratio of fg boundary to fg pixels</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
''' <param name="type"> \param[in]    type          L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
''' <param name="pchanged"> \param[out]   pchanged      [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSelectByPerimSizeRatio")> _
Friend Shared Function pixSelectByPerimSizeRatio(pixs as IntPTR, thresh as single, connectivity as Integer, type as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (651, 1)
' pixaSelectByPerimSizeRatio()
' pixaSelectByPerimSizeRatio(PIXA *, l_float32, l_int32, l_int32 *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Returns a pixa clone if no components are removed.
'''  *   (2) Uses pix and box clones in the new pixa.
'''  *   (3) See pixSelectByPerimSizeRatio().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="thresh"> \param[in]    thresh    threshold ratio of fg boundary to b.b. circumference</param>
''' <param name="type"> \param[in]    type      L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
''' <param name="pchanged"> \param[out]   pchanged  [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSelectByPerimSizeRatio")> _
Friend Shared Function pixaSelectByPerimSizeRatio(pixas as IntPTR, thresh as single, type as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (707, 1)
' pixSelectByAreaFraction()
' pixSelectByAreaFraction(PIX *, l_float32, l_int32, l_int32, l_int32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The args specify constraints on the amount of foreground
'''  * coverage of the components that are kept.
'''  *   (2) If unchanged, returns a copy of pixs.  Otherwise,
'''  * returns a new pix with the filtered components.
'''  *   (3) This filters components based on the fraction of fg pixels
'''  * of the component in its bounding box.
'''  *   (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
'''  * with less than the threshold fraction of foreground, and
'''  * L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs          1 bpp</param>
''' <param name="thresh"> \param[in]    thresh        threshold ratio of fg pixels to (w  h)</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
''' <param name="type"> \param[in]    type          L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
''' <param name="pchanged"> \param[out]   pchanged      [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSelectByAreaFraction")> _
Friend Shared Function pixSelectByAreaFraction(pixs as IntPTR, thresh as single, connectivity as Integer, type as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (785, 1)
' pixaSelectByAreaFraction()
' pixaSelectByAreaFraction(PIXA *, l_float32, l_int32, l_int32 *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Returns a pixa clone if no components are removed.
'''  *   (2) Uses pix and box clones in the new pixa.
'''  *   (3) This filters components based on the fraction of fg pixels
'''  * of the component in its bounding box.
'''  *   (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
'''  * with less than the threshold fraction of foreground, and
'''  * L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="thresh"> \param[in]    thresh      threshold ratio of fg pixels to (w  h)</param>
''' <param name="type"> \param[in]    type        L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
''' <param name="pchanged"> \param[out]   pchanged    [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSelectByAreaFraction")> _
Friend Shared Function pixaSelectByAreaFraction(pixas as IntPTR, thresh as single, type as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (840, 1)
' pixSelectByWidthHeightRatio()
' pixSelectByWidthHeightRatio(PIX *, l_float32, l_int32, l_int32, l_int32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The args specify constraints on the width-to-height ratio
'''  * for components that are kept.
'''  *   (2) If unchanged, returns a copy of pixs.  Otherwise,
'''  * returns a new pix with the filtered components.
'''  *   (3) This filters components based on the width-to-height ratios.
'''  *   (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
'''  * with less than the threshold ratio, and
'''  * L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs          1 bpp</param>
''' <param name="thresh"> \param[in]    thresh        threshold ratio of width/height</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
''' <param name="type"> \param[in]    type          L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
''' <param name="pchanged"> \param[out]   pchanged      [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSelectByWidthHeightRatio")> _
Friend Shared Function pixSelectByWidthHeightRatio(pixs as IntPTR, thresh as single, connectivity as Integer, type as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (918, 1)
' pixaSelectByWidthHeightRatio()
' pixaSelectByWidthHeightRatio(PIXA *, l_float32, l_int32, l_int32 *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Returns a pixa clone if no components are removed.
'''  *   (2) Uses pix and box clones in the new pixa.
'''  *   (3) This filters components based on the width-to-height ratio
'''  * of each pix.
'''  *   (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
'''  * with less than the threshold ratio, and
'''  * L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="thresh"> \param[in]    thresh      threshold ratio of width/height</param>
''' <param name="type"> \param[in]    type        L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
''' <param name="pchanged"> \param[out]   pchanged    [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSelectByWidthHeightRatio")> _
Friend Shared Function pixaSelectByWidthHeightRatio(pixas as IntPTR, thresh as single, type as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (968, 1)
' pixaSelectByNumConnComp()
' pixaSelectByNumConnComp(PIXA *, l_int32, l_int32, l_int32, l_int32 *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Returns a pixa clone if no components are removed.
'''  *   (2) Uses pix and box clones in the new pixa.
'''  *   (3) This filters by the number of connected components in
'''  * a given range.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="nmin"> \param[in]    nmin          minimum number of components</param>
''' <param name="nmax"> \param[in]    nmax          maximum number of components</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
''' <param name="pchanged"> \param[out]   pchanged      [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSelectByNumConnComp")> _
Friend Shared Function pixaSelectByNumConnComp(pixas as IntPTR, nmin as Integer, nmax as Integer, connectivity as Integer, pchanged as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (1027, 1)
' pixaSelectWithIndicator()
' pixaSelectWithIndicator(PIXA *, NUMA *, l_int32 *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Returns a pixa clone if no components are removed.
'''  *   (2) Uses pix and box clones in the new pixa.
'''  *   (3) The indicator numa has values 0 (ignore) and 1 (accept).
'''  *   (4) If the source boxa is not fully populated, it is left
'''  * empty in the dest pixa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="na"> \param[in]    na         indicator numa</param>
''' <param name="pchanged"> \param[out]   pchanged   [optional] 1 if changed; 0 if clone returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSelectWithIndicator")> _
Friend Shared Function pixaSelectWithIndicator(pixas as IntPTR, na as IntPTR, pchanged as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (1087, 1)
' pixRemoveWithIndicator()
' pixRemoveWithIndicator(PIX *, PIXA *, NUMA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This complements pixAddWithIndicator().   Here, the selected
'''  * components are set subtracted from pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     1 bpp pix from which components are removed; in-place</param>
''' <param name="pixa"> \param[in]    pixa     of connected components in pixs</param>
''' <param name="na"> \param[in]    na       numa indicator: remove components corresponding to 1s</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRemoveWithIndicator")> _
Friend Shared Function pixRemoveWithIndicator(pixs as IntPTR, pixa as IntPTR, na as IntPTR) as Integer
End Function

' SRC\pixafunc1.c (1140, 1)
' pixAddWithIndicator()
' pixAddWithIndicator(PIX *, PIXA *, NUMA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This complements pixRemoveWithIndicator().   Here, the selected
'''  * components are added to pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     1 bpp pix from which components are added; in-place</param>
''' <param name="pixa"> \param[in]    pixa     of connected components, some of which will be put</param>
''' <param name="na"> \param[in]    na       numa indicator: add components corresponding to 1s</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddWithIndicator")> _
Friend Shared Function pixAddWithIndicator(pixs as IntPTR, pixa as IntPTR, na as IntPTR) as Integer
End Function

' SRC\pixafunc1.c (1193, 1)
' pixaSelectWithString()
' pixaSelectWithString(PIXA *, const char *, l_int32 *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Returns a pixa with copies of selected pix.
'''  *   (2) Associated boxes are also copied, if fully populated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="str"> \param[in]    str      string of indices into pixa, giving the pix to</param>
''' <param name="perror"> \param[out]   perror   [optional] 1 if any indices are invalid;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSelectWithString")> _
Friend Shared Function pixaSelectWithString(pixas as IntPTR, str as String, perror as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (1264, 1)
' pixaRenderComponent()
' pixaRenderComponent(PIX *, PIXA *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixs is null, this generates an empty pix of a size determined
'''  * by union of the component bounding boxes, and including the origin.
'''  *   (2) The selected component is blitted into pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    [optional] 1 bpp pix</param>
''' <param name="pixa"> \param[in]    pixa    of 1 bpp connected components, one of which will</param>
''' <param name="index"> \param[in]    index   of component to be rendered</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaRenderComponent")> _
Friend Shared Function pixaRenderComponent(pixs as IntPTR, pixa as IntPTR, index as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (1334, 1)
' pixaSort()
' pixaSort(PIXA *, l_int32, l_int32, NUMA **, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This sorts based on the data in the boxa.  If the boxa
'''  * count is not the same as the pixa count, this returns an error.
'''  *   (2) If the boxa is empty, it makes one corresponding to the
'''  * dimensions of each pix, which allows meaningful sorting on
'''  * all types except x and y.
'''  *   (3) The copyflag refers to the pix and box copies that are
'''  * inserted into the sorted pixa.  These are either L_COPY
'''  * or L_CLONE.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad sorted version of pixas, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="sorttype"> \param[in]    sorttype   L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH,</param>
''' <param name="sortorder"> \param[in]    sortorder  L_SORT_INCREASING, L_SORT_DECREASING</param>
''' <param name="pnaindex"> \param[out]   pnaindex   [optional] index of sorted order into</param>
''' <param name="copyflag"> \param[in]    copyflag   L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSort")> _
Friend Shared Function pixaSort(pixas as IntPTR, sorttype as Integer, sortorder as Integer, pnaindex as Object, copyflag as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (1474, 1)
' pixaBinSort()
' pixaBinSort(PIXA *, l_int32, l_int32, NUMA **, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This sorts based on the data in the boxa.  If the boxa
'''  * count is not the same as the pixa count, this returns an error.
'''  *   (2) The copyflag refers to the pix and box copies that are
'''  * inserted into the sorted pixa.  These are either L_COPY
'''  * or L_CLONE.
'''  *   (3) For a large number of boxes (say, greater than 1000), this
'''  * O(n) binsort is much faster than the O(nlogn) shellsort.
'''  * For 5000 components, this is over 20x faster than boxaSort().
'''  *   (4) Consequently, pixaSort() calls this function if it will
'''  * likely go much faster.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad sorted version of pixas, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="sorttype"> \param[in]    sorttype    L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH,</param>
''' <param name="sortorder"> \param[in]    sortorder   L_SORT_INCREASING, L_SORT_DECREASING</param>
''' <param name="pnaindex"> \param[out]   pnaindex    [optional] index of sorted order into</param>
''' <param name="copyflag"> \param[in]    copyflag    L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaBinSort")> _
Friend Shared Function pixaBinSort(pixas as IntPTR, sorttype as Integer, sortorder as Integer, pnaindex as Object, copyflag as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (1562, 1)
' pixaSortByIndex()
' pixaSortByIndex(PIXA *, NUMA *, l_int32) as PIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad sorted, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="naindex"> \param[in]    naindex    na that maps from the new pixa to the input pixa</param>
''' <param name="copyflag"> \param[in]    copyflag   L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSortByIndex")> _
Friend Shared Function pixaSortByIndex(pixas as IntPTR, naindex as IntPTR, copyflag as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (1603, 1)
' pixaSort2dByIndex()
' pixaSort2dByIndex(PIXA *, NUMAA *, l_int32) as PIXAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  paa sorted, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="naa"> \param[in]    naa       numaa that maps from the new pixaa to the input pixas</param>
''' <param name="copyflag"> \param[in]    copyflag  L_CLONE or L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSort2dByIndex")> _
Friend Shared Function pixaSort2dByIndex(pixas as IntPTR, naa as IntPTR, copyflag as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (1668, 1)
' pixaSelectRange()
' pixaSelectRange(PIXA *, l_int32, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) The copyflag specifies what we do with each pix from pixas.
'''  * Specifically, L_CLONE inserts a clone into pixad of each
'''  * selected pix from pixas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="first"> \param[in]    first     use 0 to select from the beginning</param>
''' <param name="last"> \param[in]    last      use 0 to select to the end</param>
''' <param name="copyflag"> \param[in]    copyflag  L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSelectRange")> _
Friend Shared Function pixaSelectRange(pixas as IntPTR, first as Integer, last as Integer, copyflag as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (1718, 1)
' pixaaSelectRange()
' pixaaSelectRange(PIXAA *, l_int32, l_int32, l_int32) as PIXAA *
''' <summary>
''' * Notes:
'''  *   (1) The copyflag specifies what we do with each pixa from paas.
'''  * Specifically, L_CLONE inserts a clone into paad of each
'''  * selected pixa from paas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  paad, or NULL on error</returns>
''' <param name="paas"> \param[in]    paas</param>
''' <param name="first"> \param[in]    first    use 0 to select from the beginning</param>
''' <param name="last"> \param[in]    last     use 0 to select to the end</param>
''' <param name="copyflag"> \param[in]    copyflag L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaSelectRange")> _
Friend Shared Function pixaaSelectRange(paas as IntPTR, first as Integer, last as Integer, copyflag as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (1774, 1)
' pixaaScaleToSize()
' pixaaScaleToSize(PIXAA *, l_int32, l_int32) as PIXAA *
''' <summary>
''' * Notes:
'''  *   (1) This guarantees that each output scaled image has the
'''  * dimension(s) you specify.
'''  *  ~ To specify the width with isotropic scaling, set %hd = 0.
'''  *  ~ To specify the height with isotropic scaling, set %wd = 0.
'''  *  ~ If both %wd and %hd are specified, the image is scaled
'''  * (in general, anisotropically) to that size.
'''  *  ~ It is an error to set both %wd and %hd to 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  paad, or NULL on error</returns>
''' <param name="paas"> \param[in]    paas</param>
''' <param name="wd"> \param[in]    wd    target width; use 0 if using height as target</param>
''' <param name="hd"> \param[in]    hd    target height; use 0 if using width as target</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaScaleToSize")> _
Friend Shared Function pixaaScaleToSize(paas as IntPTR, wd as Integer, hd as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (1823, 1)
' pixaaScaleToSizeVar()
' pixaaScaleToSizeVar(PIXAA *, NUMA *, NUMA *) as PIXAA *
''' <summary>
''' * Notes:
'''  *   (1) This guarantees that the scaled images in each pixa have the
'''  * dimension(s) you specify in the numas.
'''  *  ~ To specify the width with isotropic scaling, set %nahd = NULL.
'''  *  ~ To specify the height with isotropic scaling, set %nawd = NULL.
'''  *  ~ If both %nawd and %nahd are specified, the image is scaled
'''  * (in general, anisotropically) to that size.
'''  *  ~ It is an error to set both %nawd and %nahd to NULL.
'''  *   (2) If either nawd and/or nahd is defined, it must have the same
'''  * count as the number of pixa in paas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  paad, or NULL on error</returns>
''' <param name="paas"> \param[in]    paas</param>
''' <param name="nawd"> \param[in]    nawd  [optional] target widths; use NULL if using height</param>
''' <param name="nahd"> \param[in]    nahd  [optional] target height; use NULL if using width</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaScaleToSizeVar")> _
Friend Shared Function pixaaScaleToSizeVar(paas as IntPTR, nawd as IntPTR, nahd as IntPTR) as IntPTR
End Function

' SRC\pixafunc1.c (1871, 1)
' pixaScaleToSize()
' pixaScaleToSize(PIXA *, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) See pixaaScaleToSize()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="wd"> \param[in]    wd    target width; use 0 if using height as target</param>
''' <param name="hd"> \param[in]    hd    target height; use 0 if using width as target</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaScaleToSize")> _
Friend Shared Function pixaScaleToSize(pixas as IntPTR, wd as Integer, hd as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (1916, 1)
' pixaScaleToSizeRel()
' pixaScaleToSizeRel(PIXA *, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) If a requested change in a pix is not possible because
'''  * either the requested width or height is = 0, issue a
'''  * warning and return a copy.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="delw"> \param[in]    delw   change in width, in pixels; 0 means no change</param>
''' <param name="delh"> \param[in]    delh   change in height, in pixels; 0 means no change</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaScaleToSizeRel")> _
Friend Shared Function pixaScaleToSizeRel(pixas as IntPTR, delw as Integer, delh as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (1960, 1)
' pixaScale()
' pixaScale(PIXA *, l_float32, l_float32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) If pixas has a full boxes, it is scaled as well.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="scalex"> \param[in]    scalex</param>
''' <param name="scaley"> \param[in]    scaley</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaScale")> _
Friend Shared Function pixaScale(pixas as IntPTR, scalex as single, scaley as single) as IntPTR
End Function

' SRC\pixafunc1.c (2011, 1)
' pixaScaleBySampling()
' pixaScaleBySampling(PIXA *, l_float32, l_float32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) If pixas has a full boxes, it is scaled as well.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="scalex"> \param[in]    scalex</param>
''' <param name="scaley"> \param[in]    scaley</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaScaleBySampling")> _
Friend Shared Function pixaScaleBySampling(pixas as IntPTR, scalex as single, scaley as single) as IntPTR
End Function

' SRC\pixafunc1.c (2076, 1)
' pixaRotate()
' pixaRotate(PIXA *, l_float32, l_int32, l_int32, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Each pix is rotated about its center.  See pixRotate() for details.
'''  *   (2) The boxa array is copied.  Why is it not rotated?
'''  * If a boxa exists, the array of boxes is in 1-to-1
'''  * correspondence with the array of pix, and each box typically
'''  * represents the location of the pix relative to an image from
'''  * which it has been extracted.  Like the pix, we could rotate
'''  * each box around its center, and then generate a box that
'''  * contains all four corners, as is done in boxaRotate(), but
'''  * this seems unnecessary.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas    1, 2, 4, 8, 32 bpp rgb</param>
''' <param name="angle"> \param[in]    angle    rotation angle in radians; clockwise is positive</param>
''' <param name="type"> \param[in]    type     L_ROTATE_AREA_MAP, L_ROTATE_SHEAR, L_ROTATE_SAMPLING</param>
''' <param name="incolor"> \param[in]    incolor  L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
''' <param name="width"> \param[in]    width    original width; use 0 to avoid embedding</param>
''' <param name="height"> \param[in]    height   original height; use 0 to avoid embedding</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaRotate")> _
Friend Shared Function pixaRotate(pixas as IntPTR, angle as single, type as Integer, incolor as Integer, width as Integer, height as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (2134, 1)
' pixaRotateOrth()
' pixaRotateOrth(PIXA *, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Rotates each pix in the pixa.  Rotates and saves the boxes in
'''  * the boxa if the boxa is full.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="rotation"> \param[in]    rotation    0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaRotateOrth")> _
Friend Shared Function pixaRotateOrth(pixas as IntPTR, rotation as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (2186, 1)
' pixaTranslate()
' pixaTranslate(PIXA *, l_int32, l_int32, l_int32) as PIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error.</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="hshift"> \param[in]    hshift   horizontal shift; hshift > 0 is to right</param>
''' <param name="vshift"> \param[in]    vshift   vertical shift; vshift > 0 is down</param>
''' <param name="incolor"> \param[in]    incolor  L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaTranslate")> _
Friend Shared Function pixaTranslate(pixas as IntPTR, hshift as Integer, vshift as Integer, incolor as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (2260, 1)
' pixaAddBorderGeneral()
' pixaAddBorderGeneral(PIXA *, PIXA *, l_int32, l_int32, l_int32, l_int32, l_uint32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) For binary images:
'''  * white:  val = 0
'''  * black:  val = 1
'''  * For grayscale images:
'''  * white:  val = 2 ** d - 1
'''  * black:  val = 0
'''  * For rgb color images:
'''  * white:  val = 0xffffff00
'''  * black:  val = 0
'''  * For colormapped images, use 'index' found this way:
'''  * white: pixcmapGetRankIntensity(cmap, 1.0, &index);
'''  * black: pixcmapGetRankIntensity(cmap, 0.0, &index);
'''  *   (2) For in-place replacement of each pix with a bordered version,
'''  * use %pixad = %pixas.  To make a new pixa, use %pixad = NULL.
'''  *   (3) In both cases, the boxa has sides adjusted as if it were
'''  * expanded by the border.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad with border added to each pix, including on error</returns>
''' <param name="pixad"> \param[in]    pixad    can be null or equal to pixas</param>
''' <param name="pixas"> \param[in]    pixas    containing pix of all depths; colormap ok</param>
''' <param name="left"> \param[in]    left, right, top, bot     number of pixels added</param>
''' <param name="right"> \param[in]    val      value of added border pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaAddBorderGeneral")> _
Friend Shared Function pixaAddBorderGeneral(pixad as IntPTR, pixas as IntPTR, left as Integer, right as Integer, top as Integer, bot as Integer, val as UInteger) as IntPTR
End Function

' SRC\pixafunc1.c (2331, 1)
' pixaaFlattenToPixa()
' pixaaFlattenToPixa(PIXAA *, NUMA **, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This 'flattens' the pixaa to a pixa, taking the pix in
'''  * order in the first pixa, then the second, etc.
'''  *   (2) If &naindex is defined, we generate a Numa that gives, for
'''  * each pix in the pixaa, the index of the pixa to which it belongs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa, or NULL on error</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="pnaindex"> \param[out]   pnaindex  [optional] the pixa index in the pixaa</param>
''' <param name="copyflag"> \param[in]    copyflag  L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaFlattenToPixa")> _
Friend Shared Function pixaaFlattenToPixa(paa as IntPTR, pnaindex as Object, copyflag as Integer) as IntPTR
End Function

' SRC\pixafunc1.c (2386, 1)
' pixaaSizeRange()
' pixaaSizeRange(PIXAA *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="pminw"> \param[out]   pminw, pminh, pmaxw, pmaxh   [optional] range of</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaSizeRange")> _
Friend Shared Function pixaaSizeRange(paa as IntPTR, pminw as Integer, pminh as Integer, pmaxw as Integer, pmaxh as Integer) as Integer
End Function

' SRC\pixafunc1.c (2440, 1)
' pixaSizeRange()
' pixaSizeRange(PIXA *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="pminw"> \param[out]   pminw, pminh, pmaxw, pmaxh   [optional] range of</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSizeRange")> _
Friend Shared Function pixaSizeRange(pixa as IntPTR, pminw as Integer, pminh as Integer, pmaxw as Integer, pmaxh as Integer) as Integer
End Function

' SRC\pixafunc1.c (2510, 1)
' pixaClipToPix()
' pixaClipToPix(PIXA *, PIX *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This is intended for use in situations where pixas
'''  * was originally generated from the input pixs.
'''  *   (2) Returns a pixad where each pix in pixas is ANDed
'''  * with its associated region of the input pixs.  This
'''  * region is specified by the the box that is associated
'''  * with the pix.
'''  *   (3) In a typical application of this function, pixas has
'''  * a set of region masks, so this generates a pixa of
'''  * the parts of pixs that correspond to each region
'''  * mask component, along with the bounding box for
'''  * the region.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="pixs"> \param[in]    pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaClipToPix")> _
Friend Shared Function pixaClipToPix(pixas as IntPTR, pixs as IntPTR) as IntPTR
End Function

' SRC\pixafunc1.c (2559, 1)
' pixaClipToForeground()
' pixaClipToForeground(PIXA *, PIXA **, BOXA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) At least one of [&pixd, &boxa] must be specified.
'''  *   (2) Any pix with no fg pixels is skipped.
'''  *   (3) See pixClipToForeground().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="ppixad"> \param[out]   ppixad   [optional] pixa of clipped pix returned</param>
''' <param name="pboxa"> \param[out]   pboxa    [optional] clipping boxes returned</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaClipToForeground")> _
Friend Shared Function pixaClipToForeground(pixas as IntPTR, ppixad as Object, pboxa as Object) as Integer
End Function

' SRC\pixafunc1.c (2605, 1)
' pixaGetRenderingDepth()
' pixaGetRenderingDepth(PIXA *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="pdepth"> \param[out]   pdepth   depth required to render if all colormaps are removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGetRenderingDepth")> _
Friend Shared Function pixaGetRenderingDepth(pixa as IntPTR, pdepth as Integer) as Integer
End Function

' SRC\pixafunc1.c (2642, 1)
' pixaHasColor()
' pixaHasColor(PIXA *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="phascolor"> \param[out]   phascolor   1 if any pix is rgb or has a colormap with color;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaHasColor")> _
Friend Shared Function pixaHasColor(pixa as IntPTR, phascolor as Integer) as Integer
End Function

' SRC\pixafunc1.c (2683, 1)
' pixaAnyColormaps()
' pixaAnyColormaps(PIXA *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="phascmap"> \param[out]   phascmap    1 if any pix has a colormap; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaAnyColormaps")> _
Friend Shared Function pixaAnyColormaps(pixa as IntPTR, phascmap as Integer) as Integer
End Function

' SRC\pixafunc1.c (2722, 1)
' pixaGetDepthInfo()
' pixaGetDepthInfo(PIXA *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="pmaxdepth"> \param[out]   pmaxdepth  [optional] max pixel depth of pix in pixa</param>
''' <param name="psame"> \param[out]   psame      [optional] true if all depths are equal</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaGetDepthInfo")> _
Friend Shared Function pixaGetDepthInfo(pixa as IntPTR, pmaxdepth as Integer, psame as Integer) as Integer
End Function

' SRC\pixafunc1.c (2771, 1)
' pixaConvertToSameDepth()
' pixaConvertToSameDepth(PIXA *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) If any pix has a colormap, they are all converted to rgb.
'''  * Otherwise, they are all converted to the maximum depth of
'''  * all the pix.
'''  *   (2) This can be used to allow lossless rendering onto a single pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaConvertToSameDepth")> _
Friend Shared Function pixaConvertToSameDepth(pixas as IntPTR) as IntPTR
End Function

' SRC\pixafunc1.c (2851, 1)
' pixaEqual()
' pixaEqual(PIXA *, PIXA *, l_int32, NUMA **, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The two pixa are the "same" if they contain the same
'''  * boxa and the same ordered set of pix.  However, if they
'''  * have boxa, the pix in each pixa can differ in ordering
'''  * by an amount given by the parameter %maxdist.  If they
'''  * don't have a boxa, the %maxdist parameter is ignored,
'''  * and the ordering must be identical.
'''  *   (2) This applies only to boxa geometry, pixels and ordering;
'''  * other fields in the pix are ignored.
'''  *   (3) naindex[i] gives the position of the box in pixa2 that
'''  * corresponds to box i in pixa1.  It is only returned if the
'''  * pixa have boxa and the boxa are equal.
'''  *   (4) In situations where the ordering is very different, so that
'''  * a large %maxdist is required for "equality", this should be
'''  * implemented with a hash function for efficiency.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa1"> \param[in]    pixa1</param>
''' <param name="pixa2"> \param[in]    pixa2</param>
''' <param name="maxdist"> \param[in]    maxdist</param>
''' <param name="pnaindex"> \param[out]   pnaindex  [optional] index array of correspondences</param>
''' <param name="psame"> \param[out]   psame     1 if equal; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaEqual")> _
Friend Shared Function pixaEqual(pixa1 as IntPTR, pixa2 as IntPTR, maxdist as Integer, pnaindex as Object, psame as Integer) as Integer
End Function

' SRC\pixafunc1.c (2936, 1)
' pixaSetFullSizeBoxa()
' pixaSetFullSizeBoxa(PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Replaces the existing boxa.  Each box gives the dimensions
'''  * of the corresponding pix.  This is needed for functions
'''  * like pixaSort() that sort based on the boxes.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSetFullSizeBoxa")> _
Friend Shared Function pixaSetFullSizeBoxa(pixa as IntPTR) as Integer
End Function

#End Region
#Region "SRC\pixafunc2.c"
' SRC\pixafunc2.c (179, 1)
' pixaDisplay()
' pixaDisplay(PIXA *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This uses the boxes to place each pix in the rendered composite.
'''  *   (2) Set w = h = 0 to use the b.b. of the components to determine
'''  * the size of the returned pix.
'''  *   (3) Uses the first pix in pixa to determine the depth.
'''  *   (4) The background is written "white".  On 1 bpp, each successive
'''  * pix is "painted" (adding foreground), whereas for grayscale
'''  * or color each successive pix is blitted with just the src.
'''  *   (5) If the pixa is empty, returns an empty 1 bpp pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="w"> \param[in]    w, h    if set to 0, the size is determined from the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplay")> _
Friend Shared Function pixaDisplay(pixa as IntPTR, w as Integer, h as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (259, 1)
' pixaDisplayOnColor()
' pixaDisplayOnColor(PIXA *, l_int32, l_int32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This uses the boxes to place each pix in the rendered composite.
'''  *   (2) Set w = h = 0 to use the b.b. of the components to determine
'''  * the size of the returned pix.
'''  *   (3) If any pix in %pixa are colormapped, or if the pix have
'''  * different depths, it returns a 32 bpp pix.  Otherwise,
'''  * the depth of the returned pixa equals that of the pix in %pixa.
'''  *   (4) If the pixa is empty, return null.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="w"> \param[in]    w, h     if set to 0, the size is determined from the</param>
''' <param name="h"> \param[in]    bgcolor  background color to use</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplayOnColor")> _
Friend Shared Function pixaDisplayOnColor(pixa as IntPTR, w as Integer, h as Integer, bgcolor as UInteger) as IntPTR
End Function

' SRC\pixafunc2.c (354, 1)
' pixaDisplayRandomCmap()
' pixaDisplayRandomCmap(PIXA *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This uses the boxes to place each pix in the rendered composite.
'''  * The fg of each pix in %pixa, such as a single connected
'''  * component or a line of text, is given a random color.
'''  *   (2) By default, the background color is black (cmap index 0).
'''  * This can be changed by pixcmapResetColor()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix   8 bpp, cmapped, with random colors assigned to each region,</returns>
''' <param name="pixa"> \param[in]    pixa    1 bpp regions, with boxa delineating those regions</param>
''' <param name="w"> \param[in]    w, h    if set to 0, the size is determined from the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplayRandomCmap")> _
Friend Shared Function pixaDisplayRandomCmap(pixa as IntPTR, w as Integer, h as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (428, 1)
' pixaDisplayLinearly()
' pixaDisplayLinearly(PIXA *, l_int32, l_float32, l_int32, l_int32, l_int32, BOXA **) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This puts each pix, sequentially, in a line, either horizontally
'''  * or vertically.
'''  *   (2) If any pix has a colormap, all pix are rendered in rgb.
'''  *   (3) The boxa gives the location of each image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix of composite images, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="direction"> \param[in]    direction    L_HORIZ or L_VERT</param>
''' <param name="scalefactor"> \param[in]    scalefactor  applied to every pix; use 1.0 for no scaling</param>
''' <param name="background"> \param[in]    background   0 for white, 1 for black; this is the color</param>
''' <param name="spacing"> \param[in]    spacing      between images, and on outside</param>
''' <param name="border"> \param[in]    border       width of black border added to each image;</param>
''' <param name="pboxa"> \param[out]   pboxa        [optional] location of images in output pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplayLinearly")> _
Friend Shared Function pixaDisplayLinearly(pixas as IntPTR, direction as Integer, scalefactor as single, background as Integer, spacing as Integer, border as Integer, pboxa as Object) as IntPTR
End Function

' SRC\pixafunc2.c (522, 1)
' pixaDisplayOnLattice()
' pixaDisplayOnLattice(PIXA *, l_int32, l_int32, l_int32 *, BOXA **) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This places each pix on sequentially on a regular lattice
'''  * in the rendered composite.  If a pix is too large to fit in the
'''  * allocated lattice space, it is not rendered.
'''  *   (2) If any pix has a colormap, all pix are rendered in rgb.
'''  *   (3) This is useful when putting bitmaps of components,
'''  * such as characters, into a single image.
'''  *   (4) The boxa gives the location of each image.  The UL corner
'''  * of each image is on a lattice cell corner.  Omitted images
'''  * (due to size) are assigned an invalid width and height of 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix of composite images, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="cellw"> \param[in]    cellw    lattice cell width</param>
''' <param name="cellh"> \param[in]    cellh    lattice cell height</param>
''' <param name="pncols"> \param[out]   pncols   [optional] number of columns in output lattice</param>
''' <param name="pboxa"> \param[out]   pboxa    [optional] location of images in lattice</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplayOnLattice")> _
Friend Shared Function pixaDisplayOnLattice(pixa as IntPTR, cellw as Integer, cellh as Integer, pncols as Integer, pboxa as Object) as IntPTR
End Function

' SRC\pixafunc2.c (633, 1)
' pixaDisplayUnsplit()
' pixaDisplayUnsplit(PIXA *, l_int32, l_int32, l_int32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a logical inverse of pixaSplitPix().  It
'''  * constructs a pix from a mosaic of tiles, all of equal size.
'''  *   (2) For added generality, a border of arbitrary color can
'''  * be added to each of the tiles.
'''  *   (3) In use, pixa will typically have either been generated
'''  * from pixaSplitPix() or will derived from a pixa that
'''  * was so generated.
'''  *   (4) All pix in the pixa must be of equal depth, and, if
'''  * colormapped, have the same colormap.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix of tiled images, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="nx"> \param[in]    nx           number of mosaic cells horizontally</param>
''' <param name="ny"> \param[in]    ny           number of mosaic cells vertically</param>
''' <param name="borderwidth"> \param[in]    borderwidth  of added border on all sides</param>
''' <param name="bordercolor"> \param[in]    bordercolor  in our RGBA format: 0xrrggbbaa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplayUnsplit")> _
Friend Shared Function pixaDisplayUnsplit(pixa as IntPTR, nx as Integer, ny as Integer, borderwidth as Integer, bordercolor as UInteger) as IntPTR
End Function

' SRC\pixafunc2.c (708, 1)
' pixaDisplayTiled()
' pixaDisplayTiled(PIXA *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This renders a pixa to a single image of width not to
'''  * exceed maxwidth, with background color either white or black,
'''  * and with each subimage spaced on a regular lattice.
'''  *   (2) The lattice size is determined from the largest width and height,
'''  * separately, of all pix in the pixa.
'''  *   (3) All pix in the pixa must be of equal depth.
'''  *   (4) If any pix has a colormap, all pix are rendered in rgb.
'''  *   (5) Careful: because no components are omitted, this is
'''  * dangerous if there are thousands of small components and
'''  * one or more very large one, because the size of the
'''  * resulting pix can be huge!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix of tiled images, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="maxwidth"> \param[in]    maxwidth     of output image</param>
''' <param name="background"> \param[in]    background   0 for white, 1 for black</param>
''' <param name="spacing"> \param[in]    spacing</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplayTiled")> _
Friend Shared Function pixaDisplayTiled(pixa as IntPTR, maxwidth as Integer, background as Integer, spacing as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (822, 1)
' pixaDisplayTiledInRows()
' pixaDisplayTiledInRows(PIXA *, l_int32, l_int32, l_float32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This renders a pixa to a single image of width not to
'''  * exceed maxwidth, with background color either white or black,
'''  * and with each row tiled such that the top of each pix is
'''  * aligned and separated by 'spacing' from the next one.
'''  * A black border can be added to each pix.
'''  *   (2) All pix are converted to outdepth; existing colormaps are removed.
'''  *   (3) This does a reasonably spacewise-efficient job of laying
'''  * out the individual pix images into a tiled composite.
'''  *   (4) A serialized boxa giving the location in pixd of each input
'''  * pix (without added border) is stored in the text string of pixd.
'''  * This allows, e.g., regeneration of a pixa from pixd, using
'''  * pixaCreateFromBoxa().  If there is no scaling and the depth of
'''  * each input pix in the pixa is the same, this tiling operation
'''  * can be inverted using the boxa (except for loss of text in
'''  * each of the input pix):
'''  *   pix1 = pixaDisplayTiledInRows(pixa1, 1, 1500, 1.0, 0, 30, 0);
'''  *   char *boxatxt = pixGetText(pix1);
'''  *   boxa1 = boxaReadMem((l_uint8 *)boxatxt, strlen(boxatxt));
'''  *   pixa2 = pixaCreateFromBoxa(pix1, boxa1, NULL);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd of tiled images, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="outdepth"> \param[in]    outdepth     output depth: 1, 8 or 32 bpp</param>
''' <param name="maxwidth"> \param[in]    maxwidth     of output image</param>
''' <param name="scalefactor"> \param[in]    scalefactor  applied to every pix; use 1.0 for no scaling</param>
''' <param name="background"> \param[in]    background   0 for white, 1 for black; this is the color</param>
''' <param name="spacing"> \param[in]    spacing      between images, and on outside</param>
''' <param name="border"> \param[in]    border       width of black border added to each image;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplayTiledInRows")> _
Friend Shared Function pixaDisplayTiledInRows(pixa as IntPTR, outdepth as Integer, maxwidth as Integer, scalefactor as single, background as Integer, spacing as Integer, border as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (1006, 1)
' pixaDisplayTiledInColumns()
' pixaDisplayTiledInColumns(PIXA *, l_int32, l_float32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This renders a pixa to a single image with &nx columns of
'''  * subimages.  The background color is white, and each row
'''  * is tiled such that the top of each pix is aligned and
'''  * each pix is separated by 'spacing' from the next one.
'''  * A black border can be added to each pix.
'''  *   (2) The output depth is determined by the largest depth
'''  * required by the pix in the pixa.  Colormaps are removed.
'''  *   (3) A serialized boxa giving the location in pixd of each input
'''  * pix (without added border) is stored in the text string of pixd.
'''  * This allows, e.g., regeneration of a pixa from pixd, using
'''  * pixaCreateFromBoxa().  If there is no scaling and the depth of
'''  * each input pix in the pixa is the same, this tiling operation
'''  * can be inverted using the boxa (except for loss of text in
'''  * each of the input pix):
'''  *   pix1 = pixaDisplayTiledInColumns(pixa1, 3, 1.0, 0, 30, 2);
'''  *   char *boxatxt = pixGetText(pix1);
'''  *   boxa1 = boxaReadMem((l_uint8 *)boxatxt, strlen(boxatxt));
'''  *   pixa2 = pixaCreateFromBoxa(pix1, boxa1, NULL);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd of tiled images, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="nx"> \param[in]    nx           number of columns in output image</param>
''' <param name="scalefactor"> \param[in]    scalefactor  applied to every pix; use 1.0 for no scaling</param>
''' <param name="spacing"> \param[in]    spacing      between images, and on outside</param>
''' <param name="border"> \param[in]    border       width of black border added to each image;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplayTiledInColumns")> _
Friend Shared Function pixaDisplayTiledInColumns(pixas as IntPTR, nx as Integer, scalefactor as single, spacing as Integer, border as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (1123, 1)
' pixaDisplayTiledAndScaled()
' pixaDisplayTiledAndScaled(PIXA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This can be used to tile a number of renderings of
'''  * an image that are at different scales and depths.
'''  *   (2) Each image, after scaling and optionally adding the
'''  * black border, has width 'tilewidth'.  Thus, the border does
'''  * not affect the spacing between the image tiles.  The
'''  * maximum allowed border width is tilewidth / 5.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix of tiled images, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="outdepth"> \param[in]    outdepth    output depth: 1, 8 or 32 bpp</param>
''' <param name="tilewidth"> \param[in]    tilewidth   each pix is scaled to this width</param>
''' <param name="ncols"> \param[in]    ncols       number of tiles in each row</param>
''' <param name="background"> \param[in]    background  0 for white, 1 for black; this is the color</param>
''' <param name="spacing"> \param[in]    spacing     between images, and on outside</param>
''' <param name="border"> \param[in]    border      width of additional black border on each image;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplayTiledAndScaled")> _
Friend Shared Function pixaDisplayTiledAndScaled(pixa as IntPTR, outdepth as Integer, tilewidth as Integer, ncols as Integer, background as Integer, spacing as Integer, border as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (1278, 1)
' pixaDisplayTiledWithText()
' pixaDisplayTiledWithText(PIXA *, l_int32, l_float32, l_int32, l_int32, l_int32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a version of pixaDisplayTiledInRows() that prints, below
'''  * each pix, the text in the pix text field.  Up to 127 chars
'''  * of text in the pix text field are rendered below each pix.
'''  *   (2) It renders a pixa to a single image of width not to
'''  * exceed %maxwidth, with white background color, with each row
'''  * tiled such that the top of each pix is aligned and separated
'''  * by %spacing from the next one.
'''  *   (3) All pix are converted to 32 bpp.
'''  *   (4) This does a reasonably spacewise-efficient job of laying
'''  * out the individual pix images into a tiled composite.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd of tiled images, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="maxwidth"> \param[in]    maxwidth     of output image</param>
''' <param name="scalefactor"> \param[in]    scalefactor  applied to every pix; use 1.0 for no scaling</param>
''' <param name="spacing"> \param[in]    spacing      between images, and on outside</param>
''' <param name="border"> \param[in]    border       width of black border added to each image;</param>
''' <param name="fontsize"> \param[in]    fontsize     4, 6, ... 20</param>
''' <param name="textcolor"> \param[in]    textcolor    0xrrggbb00</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplayTiledWithText")> _
Friend Shared Function pixaDisplayTiledWithText(pixa as IntPTR, maxwidth as Integer, scalefactor as single, spacing as Integer, border as Integer, fontsize as Integer, textcolor as UInteger) as IntPTR
End Function

' SRC\pixafunc2.c (1377, 1)
' pixaDisplayTiledByIndex()
' pixaDisplayTiledByIndex(PIXA *, NUMA *, l_int32, l_int32, l_int32, l_int32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This renders a pixa to a single image with white
'''  * background color, where the pix are placed in columns
'''  * given by the index value in the numa.  Each pix
'''  * is separated by %spacing from the adjacent ones, and
'''  * an optional border is placed around them.
'''  *   (2) Up to 127 chars of text in the pix text field are rendered
'''  * below each pix.  Use newlines in the text field to write
'''  * the text in multiple lines that fit within the pix width.
'''  *   (3) To avoid having empty columns, if there are N different
'''  * index values, they should be in [0 ... N-1].
'''  *   (4) All pix are converted to 32 bpp.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd of tiled images, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="na"> \param[in]    na         numa with indices corresponding to the pix in pixa</param>
''' <param name="width"> \param[in]    width      each pix is scaled to this width</param>
''' <param name="spacing"> \param[in]    spacing    between images, and on outside</param>
''' <param name="border"> \param[in]    border     width of black border added to each image;</param>
''' <param name="fontsize"> \param[in]    fontsize   4, 6, ... 20</param>
''' <param name="textcolor"> \param[in]    textcolor  0xrrggbb00</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplayTiledByIndex")> _
Friend Shared Function pixaDisplayTiledByIndex(pixa as IntPTR, na as IntPTR, width as Integer, spacing as Integer, border as Integer, fontsize as Integer, textcolor as UInteger) as IntPTR
End Function

' SRC\pixafunc2.c (1480, 1)
' pixaaDisplay()
' pixaaDisplay(PIXAA *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Each pix of the paa is displayed at the location given by
'''  * its box, translated by the box of the containing pixa
'''  * if it exists.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="w"> \param[in]    w, h   if set to 0, the size is determined from the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaDisplay")> _
Friend Shared Function pixaaDisplay(paa as IntPTR, w as Integer, h as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (1574, 1)
' pixaaDisplayByPixa()
' pixaaDisplayByPixa(PIXAA *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Displays each pixa on a line (or set of lines),
'''  * in order from top to bottom.  Within each pixa,
'''  * the pix are displayed in order from left to right.
'''  *   (2) The sizes and depths of each pix can differ.  The output pix
'''  * has a depth equal to the max depth of all the pix.
'''  *   (3) This ignores the boxa of the paa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="paa"> \param[in]    paa     with pix that may have different depths</param>
''' <param name="xspace"> \param[in]    xspace  between pix in pixa</param>
''' <param name="yspace"> \param[in]    yspace  between pixa</param>
''' <param name="maxw"> \param[in]    maxw    max width of output pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaDisplayByPixa")> _
Friend Shared Function pixaaDisplayByPixa(paa as IntPTR, xspace as Integer, yspace as Integer, maxw as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (1711, 1)
' pixaaDisplayTiledAndScaled()
' pixaaDisplayTiledAndScaled(PIXAA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) For each pixa, this generates from all the pix a
'''  * tiled/scaled output pix, and puts it in the output pixa.
'''  *   (2) See comments in pixaDisplayTiledAndScaled().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa of tiled images, one image for each pixa in</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="outdepth"> \param[in]    outdepth    output depth: 1, 8 or 32 bpp</param>
''' <param name="tilewidth"> \param[in]    tilewidth   each pix is scaled to this width</param>
''' <param name="ncols"> \param[in]    ncols       number of tiles in each row</param>
''' <param name="background"> \param[in]    background  0 for white, 1 for black; this is the color</param>
''' <param name="spacing"> \param[in]    spacing     between images, and on outside</param>
''' <param name="border"> \param[in]    border      width of additional black border on each image;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaaDisplayTiledAndScaled")> _
Friend Shared Function pixaaDisplayTiledAndScaled(paa as IntPTR, outdepth as Integer, tilewidth as Integer, ncols as Integer, background as Integer, spacing as Integer, border as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (1761, 1)
' pixaConvertTo1()
' pixaConvertTo1(PIXA *, l_int32) as PIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="thresh"> \param[in]    thresh    threshold for final binarization from 8 bpp gray</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaConvertTo1")> _
Friend Shared Function pixaConvertTo1(pixas as IntPTR, thresh as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (1802, 1)
' pixaConvertTo8()
' pixaConvertTo8(PIXA *, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) See notes for pixConvertTo8(), applied to each pix in pixas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad each pix is 8 bpp, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="cmapflag"> \param[in]    cmapflag   1 to give pixd a colormap; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaConvertTo8")> _
Friend Shared Function pixaConvertTo8(pixas as IntPTR, cmapflag as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (1843, 1)
' pixaConvertTo8Colormap()
' pixaConvertTo8Colormap(PIXA *, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) See notes for pixConvertTo8Colormap(), applied to each pix in pixas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad each pix is 8 bpp, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="dither"> \param[in]    dither   1 to dither if necessary; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaConvertTo8Colormap")> _
Friend Shared Function pixaConvertTo8Colormap(pixas as IntPTR, dither as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (1885, 1)
' pixaConvertTo32()
' pixaConvertTo32(PIXA *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) See notes for pixConvertTo32(), applied to each pix in pixas.
'''  *   (2) This can be used to allow 1 bpp pix in a pixa to be displayed
'''  * with color.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad 32 bpp rgb, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaConvertTo32")> _
Friend Shared Function pixaConvertTo32(pixas as IntPTR) as IntPTR
End Function

' SRC\pixafunc2.c (1938, 1)
' pixaConstrainedSelect()
' pixaConstrainedSelect(PIXA *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *  (1) See notes in genConstrainedNumaInRange() for how selection
'''  *   is made.
'''  *  (2) This returns a selection of the pix in the input pixa.
'''  *  (3) Use copyflag == L_COPY if you don't want changes in the pix
'''  *   in the returned pixa to affect those in the input pixa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad if OK, NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="first"> \param[in]    first      first index to choose; >= 0</param>
''' <param name="last"> \param[in]    last       biggest possible index to reach;</param>
''' <param name="nmax"> \param[in]    nmax       maximum number of pix to select; > 0</param>
''' <param name="use_pairs"> \param[in]    use_pairs  1 = select pairs of adjacent pix;</param>
''' <param name="copyflag"> \param[in]    copyflag   L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaConstrainedSelect")> _
Friend Shared Function pixaConstrainedSelect(pixas as IntPTR, first as Integer, last as Integer, nmax as Integer, use_pairs as Integer, copyflag as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (2006, 1)
' pixaSelectToPdf()
' pixaSelectToPdf(PIXA *, l_int32, l_int32, l_int32, l_float32, l_int32, l_int32, l_uint32, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This writes a pdf of the selected images from %pixas, one to
'''  * a page.  They are optionally scaled and annotated with the
'''  * index printed to the left of the image.
'''  *   (2) If the input images are 1 bpp and you want the numbers to be
'''  * in color, first promote each pix to 8 bpp with a colormap:
'''  * pixa1 = pixaConvertTo8(pixas, 1);
'''  * and then call this function with the specified color
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="first"> \param[in]    first     first index to choose; >= 0</param>
''' <param name="last"> \param[in]    last      biggest possible index to reach;</param>
''' <param name="res"> \param[in]    res       override the resolution of each input image, in ppi;</param>
''' <param name="scalefactor"> \param[in]    scalefactor   scaling factor applied to each image; > 0.0</param>
''' <param name="type"> \param[in]    type      encoding type (L_JPEG_ENCODE, L_G4_ENCODE,</param>
''' <param name="quality"> \param[in]    quality   used for JPEG only; 0 for default (75)</param>
''' <param name="color"> \param[in]    color     of numbers added to each image (e.g., 0xff000000)</param>
''' <param name="fontsize"> \param[in]    fontsize  to print number below each image.  The valid set</param>
''' <param name="fileout"> \param[in]    fileout   pdf file of all images</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSelectToPdf")> _
Friend Shared Function pixaSelectToPdf(pixas as IntPTR, first as Integer, last as Integer, res as Integer, scalefactor as single, type as Integer, quality as Integer, color as UInteger, fontsize as Integer, fileout as String) as Integer
End Function

' SRC\pixafunc2.c (2086, 1)
' pixaDisplayMultiTiled()
' pixaDisplayMultiTiled(PIXA *, l_int32, l_int32, l_int32, l_int32, l_float32, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Each set of %nx * %ny images is optionally scaled and saved
'''  * into a new pix, and then aggregated.
'''  *   (2) Set %maxw = %maxh = 0 if you want to include all pix from %pixs.
'''  *   (3) This is useful for generating a pdf from the output pixa, where
'''  * each page is a tile of (%nx * %ny) images from the input pixa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad if OK, NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="nx"> \param[in]    nx, ny       in [1, ... 50], tiling factors in each direction</param>
''' <param name="ny"> \param[in]    maxw, maxh   max sizes to keep</param>
''' <param name="maxw"> \param[in]    scalefactor  scale each image by this</param>
''' <param name="maxh"> \param[in]    spacing      between images, and on outside</param>
''' <param name="scalefactor"> \param[in]    border       width of additional black border on each image;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaDisplayMultiTiled")> _
Friend Shared Function pixaDisplayMultiTiled(pixas as IntPTR, nx as Integer, ny as Integer, maxw as Integer, maxh as Integer, scalefactor as single, spacing as Integer, border as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (2165, 1)
' pixaSplitIntoFiles()
' pixaSplitIntoFiles(PIXA *, l_int32, l_float32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For each requested output, %nsplit files are written into
'''  * directory /tmp/lept/split/.
'''  *   (2) This is useful when a pixa is so large that the images
'''  * are not conveniently displayed as a single tiled image at
'''  * full resolution.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="nsplit"> \param[in]    nsplit       split pixas into this number of pixa; >= 2</param>
''' <param name="scale"> \param[in]    scale        scalefactor applied to each pix</param>
''' <param name="outwidth"> \param[in]    outwidth     the maxwidth parameter of tiled images</param>
''' <param name="write_pixa"> \param[in]    write_pixa  1 to write the split pixa as separate files</param>
''' <param name="write_pix"> \param[in]    write_pix   1 to write tiled images of the split pixa</param>
''' <param name="write_pdf"> \param[in]    write_pdf   1 to write pdfs of the split pixa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSplitIntoFiles")> _
Friend Shared Function pixaSplitIntoFiles(pixas as IntPTR, nsplit as Integer, scale as single, outwidth as Integer, write_pixa as Integer, write_pix as Integer, write_pdf as Integer) as Integer
End Function

' SRC\pixafunc2.c (2254, 1)
' convertToNUpFiles()
' convertToNUpFiles(const char *, const char *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Each set of %nx * %ny images is scaled and tiled into a single
'''  * image, that is written out to %outdir.
'''  *   (2) All images in each %nx * %ny set are scaled to the same
'''  * width, %tw.  This is typically used when all images are
'''  * roughly the same size.
'''  *   (3) This is useful for generating a pdf from the set of input
'''  * files, where each page is a tile of (%nx * %ny) input images.
'''  * Typical values for %nx and %ny are in the range [2 ... 5].
'''  *   (4) If %fontsize != 0, each image has the tail of its filename
'''  * rendered below it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dir"> \param[in]    dir        full path to directory of images</param>
''' <param name="substr"> \param[in]    substr     [optional] can be null</param>
''' <param name="nx"> \param[in]    nx, ny     in [1, ... 50], tiling factors in each direction</param>
''' <param name="ny"> \param[in]    tw         target width, in pixels; must be >= 20</param>
''' <param name="tw"> \param[in]    spacing    between images, and on outside</param>
''' <param name="spacing"> \param[in]    border     width of additional black border on each image;</param>
''' <param name="border"> \param[in]    fontsize   to print tail of filename with image.  Valid set is</param>
''' <param name="fontsize"> \param[in]    outdir     subdirectory of /tmp to put N-up tiled images</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertToNUpFiles")> _
Friend Shared Function convertToNUpFiles(dir as String, substr as String, nx as Integer, ny as Integer, tw as Integer, spacing as Integer, border as Integer, fontsize as Integer, outdir as String) as Integer
End Function

' SRC\pixafunc2.c (2316, 1)
' convertToNUpPixa()
' convertToNUpPixa(const char *, const char *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) See notes for convertToNUpFiles()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="dir"> \param[in]    dir       full path to directory of images</param>
''' <param name="substr"> \param[in]    substr    [optional] can be null</param>
''' <param name="nx"> \param[in]    nx, ny    in [1, ... 50], tiling factors in each direction</param>
''' <param name="ny"> \param[in]    tw        target width, in pixels; must be >= 20</param>
''' <param name="tw"> \param[in]    spacing   between images, and on outside</param>
''' <param name="spacing"> \param[in]    border    width of additional black border on each image;</param>
''' <param name="border"> \param[in]    fontsize  to print tail of filename with image.  Valid set is</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertToNUpPixa")> _
Friend Shared Function convertToNUpPixa(dir as String, substr as String, nx as Integer, ny as Integer, tw as Integer, spacing as Integer, border as Integer, fontsize as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (2382, 1)
' pixaConvertToNUpPixa()
' pixaConvertToNUpPixa(PIXA *, SARRAY *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This takes an input pixa and an optional array of strings, and
'''  * generates a pixa of NUp tiles from the input, labeled with
'''  * the strings if they exist and %fontsize != 0.
'''  *   (2) See notes for convertToNUpFiles()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas</param>
''' <param name="sa"> \param[in]    sa        [optional] array of strings associated with each pix</param>
''' <param name="nx"> \param[in]    nx, ny    in [1, ... 50], tiling factors in each direction</param>
''' <param name="ny"> \param[in]    tw        target width, in pixels; must be >= 20</param>
''' <param name="tw"> \param[in]    spacing   between images, and on outside</param>
''' <param name="spacing"> \param[in]    border    width of additional black border on each image;</param>
''' <param name="border"> \param[in]    fontsize  to print string with each image.  Valid set is</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaConvertToNUpPixa")> _
Friend Shared Function pixaConvertToNUpPixa(pixas as IntPTR, sa as IntPTR, nx as Integer, ny as Integer, tw as Integer, spacing as Integer, border as Integer, fontsize as Integer) as IntPTR
End Function

' SRC\pixafunc2.c (2495, 1)
' pixaCompareInPdf()
' pixaCompareInPdf(PIXA *, PIXA *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This takes two pixa and renders them interleaved, side-by-side
'''  * in a pdf.  A warning is issued if the input pixa arrays
'''  * have different lengths.
'''  *   (2) %nx and %ny specify how many side-by-side pairs are displayed
'''  * on each pdf page.  For example, if %nx = 1 and %ny = 2, then
'''  * two pairs are shown, one above the other, on each page.
'''  *   (3) The input pix are scaled to a target width of %tw, and
'''  * then paired with optional %spacing between and optional
'''  * black border of width %border.
'''  *   (4) After a pixa is generated of these tiled images, it is
'''  * written to %fileout as a pdf.
'''  *   (5) Typical numbers for the input parameters are:
'''  *   %nx = small integer (1 - 4)
'''  *   %ny = 2 * %nx
'''  *   %tw = 200 - 500 pixels
'''  *   %spacing = 10
'''  *   %border = 2
'''  *   %fontsize = 10
'''  *   (6) If %fontsize != 0, the index of the pix pair in their pixa
'''  * is printed out below each pair.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa1"> \param[in]    pixa1</param>
''' <param name="pixa2"> \param[in]    pixa2</param>
''' <param name="nx"> \param[in]    nx, ny     in [1, ... 20], tiling factors in each direction</param>
''' <param name="ny"> \param[in]    tw         target width, in pixels; must be >= 20</param>
''' <param name="tw"> \param[in]    spacing    between images, and on outside</param>
''' <param name="spacing"> \param[in]    border     width of additional black border on each image</param>
''' <param name="border"> \param[in]    fontsize   to print index of each pair of images.  Valid set</param>
''' <param name="fontsize"> \param[in]    fileout    output pdf file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaCompareInPdf")> _
Friend Shared Function pixaCompareInPdf(pixa1 as IntPTR, pixa2 as IntPTR, nx as Integer, ny as Integer, tw as Integer, spacing as Integer, border as Integer, fontsize as Integer, fileout as String) as Integer
End Function

#End Region
#Region "SRC\pixalloc.c"
' SRC\pixalloc.c (168, 1)
' pmsCreate()
' pmsCreate(size_t, size_t, NUMA *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This computes the size of the block of memory required
'''  * and allocates it.  Each chunk starts on a 32-bit word boundary.
'''  * The chunk sizes are in powers of 2, starting at %smallest,
'''  * and the number of levels and chunks at each level is
'''  * specified by %numalloc.
'''  *   (2) This is intended to manage the image data for a small number
'''  * of relatively large pix.  The system malloc is expected to
'''  * handle very large numbers of small chunks efficiently.
'''  *   (3) Important: set the allocators and call this function
'''  * before any pix have been allocated.  Destroy all the pix
'''  * in the normal way before calling pmsDestroy().
'''  *   (4) The pms struct is stored in a static global, so this function
'''  * is not thread-safe.  When used, there must be only one thread
'''  * per process.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="minsize"> \param[in]    minsize of data chunk that can be supplied by pms</param>
''' <param name="smallest"> \param[in]    smallest bytes of the smallest pre-allocated data chunk.</param>
''' <param name="numalloc"> \param[in]    numalloc array with the number of data chunks for each</param>
''' <param name="logfile"> \param[in]    logfile use for debugging; null otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pmsCreate")> _
Friend Shared Function pmsCreate(minsize as ULong, smallest as ULong, numalloc as IntPTR, logfile as String) as Integer
End Function

' SRC\pixalloc.c (267, 1)
' pmsDestroy()
' pmsDestroy() as void
''' <summary>
''' * Notes:
'''  *   (1) Important: call this function at the end of the program, after
'''  * the last pix has been destroyed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pmsDestroy")> _
Friend Shared Function pmsDestroy() as Boolean ' Org. Void
End Function

' SRC\pixalloc.c (311, 1)
' pmsCustomAlloc()
' pmsCustomAlloc(size_t) as void *
''' <summary>
''' * Notes:
'''  *   (1) This attempts to find a suitable pre-allocated chunk.
'''  * If not found, it dynamically allocates the chunk.
'''  *   (2) If logging is turned on, the allocations that are not taken
'''  * from the memory store, and are at least as large as the
'''  * minimum size the store can handle, are logged to file.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data ptr to chunk</returns>
''' <param name="nbytes"> \param[in]   nbytes min number of bytes in the chunk to be retrieved</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pmsCustomAlloc")> _
Friend Shared Function pmsCustomAlloc(nbytes as ULong) as String
End Function

' SRC\pixalloc.c (355, 1)
' pmsCustomDealloc()
' pmsCustomDealloc(void *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="data"> \param[in]   data to be freed or returned to the storage</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pmsCustomDealloc")> _
Friend Shared Function pmsCustomDealloc(data as Object) as Boolean ' Org. Void
End Function

' SRC\pixalloc.c (406, 1)
' pmsGetAlloc()
' pmsGetAlloc(size_t) as void *
''' <summary>
''' * Notes:
'''  *   (1) This is called when a request for pix data cannot be
'''  * obtained from the preallocated memory store.  After use it
'''  * is freed like normal memory.
'''  *   (2) If logging is on, only write out allocs that are as large as
'''  * the minimum size handled by the memory store.
'''  *   (3) size_t is %lu on 64 bit platforms and %u on 32 bit platforms.
'''  * The C99 platform-independent format specifier for size_t is %zu,
'''  * but windows hasn't conformed, so we are forced to go back to
'''  * C89, use %lu, and cast to get platform-independence.  Ugh.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data</returns>
''' <param name="nbytes"> \param[in]    nbytes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pmsGetAlloc")> _
Friend Shared Function pmsGetAlloc(nbytes as ULong) as String
End Function

' SRC\pixalloc.c (437, 1)
' pmsGetLevelForAlloc()
' pmsGetLevelForAlloc(size_t, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nbytes"> \param[in]   nbytes min number of bytes in the chunk to be retrieved</param>
''' <param name="plevel"> \param[out]  plevel  -1 if either too small or too large</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pmsGetLevelForAlloc")> _
Friend Shared Function pmsGetLevelForAlloc(nbytes as ULong, plevel as Integer) as Integer
End Function

' SRC\pixalloc.c (476, 1)
' pmsGetLevelForDealloc()
' pmsGetLevelForDealloc(void *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="data"> \param[in]   data ptr to memory chunk</param>
''' <param name="plevel"> \param[out]  plevel level in memory store; -1 if allocated</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pmsGetLevelForDealloc")> _
Friend Shared Function pmsGetLevelForDealloc(data as Object, plevel as Integer) as Integer
End Function

' SRC\pixalloc.c (511, 1)
' pmsLogInfo()
' pmsLogInfo() as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pmsLogInfo")> _
Friend Shared Function pmsLogInfo() as Boolean ' Org. Void
End Function

#End Region
#Region "SRC\pixarith.c"
' SRC\pixarith.c (115, 1)
' pixAddConstantGray()
' pixAddConstantGray(PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) In-place operation.
'''  *   (2) No clipping for 32 bpp.
'''  *   (3) For 8 and 16 bpp, if val > 0 the result is clipped
'''  * to 0xff and 0xffff, rsp.
'''  *   (4) For 8 and 16 bpp, if val  0 the result is clipped to 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8, 16 or 32 bpp</param>
''' <param name="val"> \param[in]    val  amount to add to each pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddConstantGray")> _
Friend Shared Function pixAddConstantGray(pixs as IntPTR, val as Integer) as Integer
End Function

' SRC\pixarith.c (186, 1)
' pixMultConstantGray()
' pixMultConstantGray(PIX *, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) In-place operation; val must be >= 0.
'''  *   (2) No clipping for 32 bpp.
'''  *   (3) For 8 and 16 bpp, the result is clipped to 0xff and 0xffff, rsp.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 8, 16 or 32 bpp</param>
''' <param name="val"> \param[in]    val  >= 0.0; amount to multiply by each pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMultConstantGray")> _
Friend Shared Function pixMultConstantGray(pixs as IntPTR, val as single) as Integer
End Function

' SRC\pixarith.c (261, 1)
' pixAddGray()
' pixAddGray(PIX *, PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Arithmetic addition of two 8, 16 or 32 bpp images.
'''  *   (2) For 8 and 16 bpp, we do explicit clipping to 0xff and 0xffff,
'''  * respectively.
'''  *   (3) Alignment is to UL corner.
'''  *   (4) There are 3 cases.  The result can go to a new dest,
'''  * in-place to pixs1, or to an existing input dest:
'''  * * pixd == null:   (src1 + src2) --> new pixd
'''  * * pixd == pixs1:  (src1 + src2) --> src1  (in-place)
'''  * * pixd != pixs1:  (src1 + src2) --> input pixd
'''  *   (5) pixs2 must be different from both pixd and pixs1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; this can be null, equal to pixs1, or</param>
''' <param name="pixs1"> \param[in]    pixs1 can be == to pixd</param>
''' <param name="pixs2"> \param[in]    pixs2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddGray")> _
Friend Shared Function pixAddGray(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR) as IntPTR
End Function

' SRC\pixarith.c (353, 1)
' pixSubtractGray()
' pixSubtractGray(PIX *, PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Arithmetic subtraction of two 8, 16 or 32 bpp images.
'''  *   (2) Source pixs2 is always subtracted from source pixs1.
'''  *   (3) Do explicit clipping to 0.
'''  *   (4) Alignment is to UL corner.
'''  *   (5) There are 3 cases.  The result can go to a new dest,
'''  * in-place to pixs1, or to an existing input dest:
'''  * (a) pixd == null   (src1 - src2) --> new pixd
'''  * (b) pixd == pixs1  (src1 - src2) --> src1  (in-place)
'''  * (d) pixd != pixs1  (src1 - src2) --> input pixd
'''  *   (6) pixs2 must be different from both pixd and pixs1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; this can be null, equal to pixs1, or</param>
''' <param name="pixs1"> \param[in]    pixs1 can be == to pixd</param>
''' <param name="pixs2"> \param[in]    pixs2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSubtractGray")> _
Friend Shared Function pixSubtractGray(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR) as IntPTR
End Function

' SRC\pixarith.c (442, 1)
' pixThresholdToValue()
' pixThresholdToValue(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  * ~ operation can be in-place (pixs == pixd) or to a new pixd
'''  * ~ if setval > threshval, sets pixels with a value >= threshval to setval
'''  * ~ if setval  threshval, sets pixels with a value = threshval to setval
'''  * ~ if setval == threshval, no-op
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd [optional]; if not null, must be equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs 8, 16, 32 bpp</param>
''' <param name="threshval"> \param[in]    threshval</param>
''' <param name="setval"> \param[in]    setval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixThresholdToValue")> _
Friend Shared Function pixThresholdToValue(pixd as IntPTR, pixs as IntPTR, threshval as Integer, setval as Integer) as IntPTR
End Function

' SRC\pixarith.c (551, 1)
' pixInitAccumulate()
' pixInitAccumulate(l_int32, l_int32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The offset must be >= 0.
'''  *   (2) The offset is used so that we can do arithmetic
'''  * with negative number results on l_uint32 data; it
'''  * prevents the l_uint32 data from going negative.
'''  *   (3) Because we use l_int32 intermediate data results,
'''  * these should never exceed the max of l_int32 (0x7fffffff).
'''  * We do not permit the offset to be above 0x40000000,
'''  * which is half way between 0 and the max of l_int32.
'''  *   (4) The same offset should be used for initialization,
'''  * multiplication by a constant, and final extraction!
'''  *   (5) If you're only adding positive values, offset can be 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp, or NULL on error</returns>
''' <param name="w"> \param[in]    w, h of accumulate array</param>
''' <param name="h"> \param[in]    offset initialize the 32 bpp to have this</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixInitAccumulate")> _
Friend Shared Function pixInitAccumulate(w as Integer, h as Integer, offset as UInteger) as IntPTR
End Function

' SRC\pixarith.c (585, 1)
' pixFinalAccumulate()
' pixFinalAccumulate(PIX *, l_uint32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The offset must be >= 0 and should not exceed 0x40000000.
'''  *   (2) The offset is subtracted from the src 32 bpp image
'''  *   (3) For 8 bpp dest, the result is clipped to [0, 0xff]
'''  *   (4) For 16 bpp dest, the result is clipped to [0, 0xffff]
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8, 16 or 32 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="offset"> \param[in]    offset same as used for initialization</param>
''' <param name="depth"> \param[in]    depth  8, 16 or 32 bpp, of destination</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFinalAccumulate")> _
Friend Shared Function pixFinalAccumulate(pixs as IntPTR, offset as UInteger, depth as Integer) as IntPTR
End Function

' SRC\pixarith.c (662, 1)
' pixFinalAccumulateThreshold()
' pixFinalAccumulateThreshold(PIX *, l_uint32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The offset must be >= 0 and should not exceed 0x40000000.
'''  *   (2) The offset is subtracted from the src 32 bpp image
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="offset"> \param[in]    offset same as used for initialization</param>
''' <param name="threshold"> \param[in]    threshold values less than this are set in the destination</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFinalAccumulateThreshold")> _
Friend Shared Function pixFinalAccumulateThreshold(pixs as IntPTR, offset as UInteger, threshold as UInteger) as IntPTR
End Function

' SRC\pixarith.c (719, 1)
' pixAccumulate()
' pixAccumulate(PIX *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This adds or subtracts each pixs value from pixd.
'''  *   (2) This clips to the minimum of pixs and pixd, so they
'''  * do not need to be the same size.
'''  *   (3) The alignment is to the origin [UL corner] of pixs & pixd.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]    pixd 32 bpp</param>
''' <param name="pixs"> \param[in]    pixs 1, 8, 16 or 32 bpp</param>
''' <param name="op"> \param[in]    op  L_ARITH_ADD or L_ARITH_SUBTRACT</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAccumulate")> _
Friend Shared Function pixAccumulate(pixd as IntPTR, pixs as IntPTR, op as Integer) as Integer
End Function

' SRC\pixarith.c (818, 1)
' pixMultConstAccumulate()
' pixMultConstAccumulate(PIX *, l_float32, l_uint32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The offset must be >= 0 and should not exceed 0x40000000.
'''  *   (2) This multiplies each pixel, relative to offset, by the input factor
'''  *   (3) The result is returned with the offset back in place.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="factor"> \param[in]    factor</param>
''' <param name="offset"> \param[in]    offset same as used for initialization</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMultConstAccumulate")> _
Friend Shared Function pixMultConstAccumulate(pixs as IntPTR, factor as single, offset as UInteger) as Integer
End Function

' SRC\pixarith.c (872, 1)
' pixAbsDifference()
' pixAbsDifference(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The depth of pixs1 and pixs2 must be equal.
'''  *   (2) Clips computation to the min size, aligning the UL corners
'''  *   (3) For 8 and 16 bpp, assumes one gray component.
'''  *   (4) For 32 bpp, assumes 3 color components, and ignores the
'''  * LSB of each word (the alpha channel)
'''  *   (5) Computes the absolute value of the difference between
'''  * each component value.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs1"> \param[in]    pixs1, pixs2  both either 8 or 16 bpp gray, or 32 bpp RGB</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAbsDifference")> _
Friend Shared Function pixAbsDifference(pixs1 as IntPTR, pixs2 as IntPTR) as IntPTR
End Function

' SRC\pixarith.c (969, 1)
' pixAddRGB()
' pixAddRGB(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Clips computation to the minimum size, aligning the UL corners.
'''  *   (2) Removes any colormap to RGB, and ignores the LSB of each
'''  * pixel word (the alpha channel).
'''  *   (3) Adds each component value, pixelwise, clipping to 255.
'''  *   (4) This is useful to combine two images where most of the
'''  * pixels are essentially black, such as in pixPerceptualDiff().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs1"> \param[in]    pixs1, pixs2  32 bpp RGB, or colormapped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddRGB")> _
Friend Shared Function pixAddRGB(pixs1 as IntPTR, pixs2 as IntPTR) as IntPTR
End Function

' SRC\pixarith.c (1054, 1)
' pixMinOrMax()
' pixMinOrMax(PIX *, PIX *, PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This gives the min or max of two images, component-wise.
'''  *   (2) The depth can be 8 or 16 bpp for 1 component, and 32 bpp
'''  * for a 3 component image.  For 32 bpp, ignore the LSB
'''  * of each word (the alpha channel)
'''  *   (3) There are 3 cases:
'''  * ~  if pixd == null,   Min(src1, src2) --> new pixd
'''  * ~  if pixd == pixs1,  Min(src1, src2) --> src1  (in-place)
'''  * ~  if pixd != pixs1,  Min(src1, src2) --> input pixd
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd  [optional] destination: this can be null,</param>
''' <param name="pixs1"> \param[in]    pixs1 can be == to pixd</param>
''' <param name="pixs2"> \param[in]    pixs2</param>
''' <param name="type"> \param[in]    type L_CHOOSE_MIN, L_CHOOSE_MAX</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMinOrMax")> _
Friend Shared Function pixMinOrMax(pixd as IntPTR, pixs1 as IntPTR, pixs2 as IntPTR, type as Integer) as IntPTR
End Function

' SRC\pixarith.c (1155, 1)
' pixMaxDynamicRange()
' pixMaxDynamicRange(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Scales pixel values to fit maximally within the dest 8 bpp pixd
'''  *   (2) Assumes the source 'pixels' are a 1-component scalar.  For
'''  * a 32 bpp source, each pixel is treated as a single number --
'''  * not as a 3-component rgb pixel value.
'''  *   (3) Uses a LUT for log scaling.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  4, 8, 16 or 32 bpp source</param>
''' <param name="type"> \param[in]    type  L_LINEAR_SCALE or L_LOG_SCALE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMaxDynamicRange")> _
Friend Shared Function pixMaxDynamicRange(pixs as IntPTR, type as Integer) as IntPTR
End Function

' SRC\pixarith.c (1343, 1)
' pixMaxDynamicRangeRGB()
' pixMaxDynamicRangeRGB(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Scales pixel values to fit maximally within a 32 bpp dest pixd
'''  *   (2) All color components are scaled with the same factor, based
'''  * on the maximum r,g or b component in the image.  This should
'''  * not be used if the 32-bit value is a single number (e.g., a
'''  * count in a histogram generated by pixMakeHistoHS()).
'''  *   (3) Uses a LUT for log scaling.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp rgb source</param>
''' <param name="type"> \param[in]    type  L_LINEAR_SCALE or L_LOG_SCALE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMaxDynamicRangeRGB")> _
Friend Shared Function pixMaxDynamicRangeRGB(pixs as IntPTR, type as Integer) as IntPTR
End Function

' SRC\pixarith.c (1430, 1)
' linearScaleRGBVal()
' linearScaleRGBVal(l_uint32, l_float32) as l_uint32
''' <summary>
''' * Notes:
'''  *   (1) %factor must be chosen to be not greater than (255 / maxcomp),
'''  * where maxcomp is the maximum value of the pixel components.
'''  * Otherwise, the product will overflow a uint8.  In use, factor
'''  * is the same for all pixels in a pix.
'''  *   (2) No scaling is performed on the transparency ("A") component.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dval  linearly scaled version of %sval</returns>
''' <param name="sval"> \param[in]    sval   32-bit rgb pixel value</param>
''' <param name="factor"> \param[in]    factor multiplication factor on each component</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="linearScaleRGBVal")> _
Friend Shared Function linearScaleRGBVal(sval as UInteger, factor as single) as UInteger
End Function

' SRC\pixarith.c (1463, 1)
' logScaleRGBVal()
' logScaleRGBVal(l_uint32, l_float32 *, l_float32) as l_uint32
''' <summary>
''' * Notes:
'''  *   (1) %tab is made with makeLogBase2Tab().
'''  *   (2) %factor must be chosen to be not greater than
'''  * 255.0 / log[base2](maxcomp), where maxcomp is the maximum
'''  * value of the pixel components.  Otherwise, the product
'''  * will overflow a uint8.  In use, factor is the same for
'''  * all pixels in a pix.
'''  *   (3) No scaling is performed on the transparency ("A") component.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dval  log scaled version of %sval</returns>
''' <param name="sval"> \param[in]    sval   32-bit rgb pixel value</param>
''' <param name="tab"> \param[in]    tab  256 entry log-base-2 table</param>
''' <param name="factor"> \param[in]    factor multiplication factor on each component</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="logScaleRGBVal")> _
Friend Shared Function logScaleRGBVal(sval as UInteger, tab as single, factor as single) as UInteger
End Function

' SRC\pixarith.c (1488, 1)
' 
' makeLogBase2Tab() as l_float32 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeLogBase2Tab")> _
Friend Shared Function makeLogBase2Tab() as String
End Function

' SRC\pixarith.c (1515, 1)
' 
' getLogBase2(l_int32, l_float32 *) as l_float32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getLogBase2")> _
Friend Shared Function getLogBase2(val as Integer, logtab as single) as single
End Function

#End Region
#Region "SRC\pixcomp.c"
' SRC\pixcomp.c (161, 16)
' pixacompExtendArray()
' pixacompExtendArray(PIXAC *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) We extend the boxa array simultaneously.  This is
'''  * necessary in case we are NOT adding boxes simultaneously
'''  * with adding pixc.  We always want the sizes of the
'''  * pixac and boxa ptr arrays to be equal.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompExtendArray")> _
Friend Shared Function pixacompExtendArray(pixac as IntPTR) as Integer
End Function

' SRC\pixcomp.c (162, 16)
' pixcompFastConvertToPdfData()
' pixcompFastConvertToPdfData(PIXC *, const char *, l_uint8 **, size_t *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This generates the pdf without transcoding.
'''  *   (2) It assumes all images are jpeg encoded, have the same
'''  * resolution, and that the resolution embedded in each
'''  * jpeg file is correct.  (It is transferred to the pdf
'''  * via the cid.)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixc"> \param[in]    pixc   containing images all at the same resolution</param>
''' <param name="title"> \param[in]    title [optional] pdf title</param>
''' <param name="pdata"> \param[out]   pdata output pdf data (of all images</param>
''' <param name="pnbytes"> \param[out]   pnbytes size of output pdf data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcompFastConvertToPdfData")> _
Friend Shared Function pixcompFastConvertToPdfData(pixc as IntPTR, title as String, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\pixcomp.c (185, 1)
' pixcompCreateFromPix()
' pixcompCreateFromPix(PIX *, l_int32) as PIXC *
''' <summary>
''' * Notes:
'''  *   (1) Use %comptype == IFF_DEFAULT to have the compression
'''  * type automatically determined.
'''  *   (2) To compress jpeg with a quality other than the default (75), use
'''  * l_jpegSetQuality()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixc, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="comptype"> \param[in]    comptype IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcompCreateFromPix")> _
Friend Shared Function pixcompCreateFromPix(pix as IntPTR, comptype as Integer) as IntPTR
End Function

' SRC\pixcomp.c (242, 1)
' pixcompCreateFromString()
' pixcompCreateFromString(l_uint8 *, size_t, l_int32) as PIXC *
''' <summary>
''' * Notes:
'''  *   (1) This works when the compressed string is png, jpeg or tiffg4.
'''  *   (2) The copyflag determines if the data in the new Pixcomp is
'''  * a copy of the input data.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixc, or NULL on error</returns>
''' <param name="data"> \param[in]    data compressed string</param>
''' <param name="size"> \param[in]    size number of bytes</param>
''' <param name="copyflag"> \param[in]    copyflag L_INSERT or L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcompCreateFromString")> _
Friend Shared Function pixcompCreateFromString(data as Byte, size as ULong, copyflag as Integer) as IntPTR
End Function

' SRC\pixcomp.c (291, 1)
' pixcompCreateFromFile()
' pixcompCreateFromFile(const char *, l_int32) as PIXC *
''' <summary>
''' * Notes:
'''  *   (1) Use %comptype == IFF_DEFAULT to have the compression
'''  * type automatically determined.
'''  *   (2) If the comptype is invalid for this file, the default will
'''  * be substituted.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixc, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="comptype"> \param[in]    comptype IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcompCreateFromFile")> _
Friend Shared Function pixcompCreateFromFile(filename as String, comptype as Integer) as IntPTR
End Function

' SRC\pixcomp.c (354, 1)
' pixcompDestroy()
' pixcompDestroy(PIXC **) as void
''' <summary>
''' * Notes:
'''  *   (1) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="ppixc"> \param[in,out]   ppixc will be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcompDestroy")> _
Friend Shared Function pixcompDestroy(ppixc as Object) as Boolean ' Org. Void
End Function

' SRC\pixcomp.c (384, 1)
' pixcompCopy()
' pixcompCopy(PIXC *) as PIXC *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixcd, or NULL on error</returns>
''' <param name="pixcs"> \param[in]    pixcs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcompCopy")> _
Friend Shared Function pixcompCopy(pixcs as IntPTR) as IntPTR
End Function

' SRC\pixcomp.c (429, 1)
' pixcompGetDimensions()
' pixcompGetDimensions(PIXC *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixc"> \param[in]    pixc</param>
''' <param name="pw"> \param[out]   pw, ph, pd [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcompGetDimensions")> _
Friend Shared Function pixcompGetDimensions(pixc as IntPTR, pw as Integer, ph as Integer, pd as Integer) as Integer
End Function

' SRC\pixcomp.c (453, 1)
' pixcompGetParameters()
' pixcompGetParameters(PIXC *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixc"> \param[in]    pixc</param>
''' <param name="pxres"> \param[out]   pxres, pyres, pcomptype, pcmapflag [all optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcompGetParameters")> _
Friend Shared Function pixcompGetParameters(pixc as IntPTR, pxres as Integer, pyres as Integer, pcomptype as Integer, pcmapflag as Integer) as Integer
End Function

' SRC\pixcomp.c (495, 1)
' pixcompDetermineFormat()
' pixcompDetermineFormat(l_int32, l_int32, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This determines the best format for a pix, given both
'''  * the request (%comptype) and the image characteristics.
'''  *   (2) If %comptype == IFF_DEFAULT, this does not necessarily result
'''  * in png encoding.  Instead, it returns one of the three formats
'''  * that is both valid and most likely to give best compression.
'''  *   (3) If the pix cannot be compressed by the input value of
'''  * %comptype, this selects IFF_PNG, which can compress all pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="comptype"> \param[in]    comptype IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
''' <param name="d"> \param[in]    d pix depth</param>
''' <param name="cmapflag"> \param[in]    cmapflag 1 if pix to be compressed as a colormap; 0 otherwise</param>
''' <param name="pformat"> \param[out]   pformat return IFF_TIFF, IFF_PNG or IFF_JFIF_JPEG</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcompDetermineFormat")> _
Friend Shared Function pixcompDetermineFormat(comptype as Integer, d as Integer, cmapflag as Integer, pformat as Integer) as Integer
End Function

' SRC\pixcomp.c (537, 1)
' pixCreateFromPixcomp()
' pixCreateFromPixcomp(PIXC *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="pixc"> \param[in]    pixc</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCreateFromPixcomp")> _
Friend Shared Function pixCreateFromPixcomp(pixc as IntPTR) as IntPTR
End Function

' SRC\pixcomp.c (590, 1)
' pixacompCreate()
' pixacompCreate(l_int32) as PIXAC *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixac, or NULL on error</returns>
''' <param name="n"> \param[in]    n  initial number of ptrs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompCreate")> _
Friend Shared Function pixacompCreate(n as Integer) as IntPTR
End Function

' SRC\pixcomp.c (657, 1)
' pixacompCreateWithInit()
' pixacompCreateWithInit(l_int32, l_int32, PIX *, l_int32) as PIXAC *
''' <summary>
''' * Notes:
'''  *   (1) Initializes a pixacomp to be fully populated with %pix,
'''  * compressed using %comptype.  If %pix == NULL, %comptype
'''  * is ignored.
'''  *   (2) Typically, the array is initialized with a tiny pix.
'''  * This is most easily done by setting %pix == NULL, causing
'''  * initialization of each array element with a tiny placeholder
'''  * pix (w = h = d = 1), using comptype = IFF_TIFF_G4 .
'''  *   (3) Example usage:
'''  *   // Generate pixacomp for pages 30 - 49.  This has an array
'''  *   // size of 20 and the page number offset is 30.
'''  *   PixaComp *pixac = pixacompCreateWithInit(20, 30, NULL,
'''  *     IFF_TIFF_G4);
'''  *   // Now insert png-compressed images into the initialized array
'''  *   for (pageno = 30; pageno  50; pageno++) {
'''  * Pix *pixt = ...   // derived from image[pageno]
'''  * if (pixt)
'''  *  pixacompReplacePix(pixac, pageno, pixt, IFF_PNG);
'''  * pixDestroy(&pixt);
'''  *   }
'''  * The result is a pixac with 20 compressed strings, and with
'''  * selected pixt replacing the placeholders.
'''  * To extract the image for page 38, which is decompressed
'''  * from element 8 in the array, use:
'''  *   pixt = pixacompGetPix(pixac, 38);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixac, or NULL on error</returns>
''' <param name="n"> \param[in]    n  initial number of ptrs</param>
''' <param name="offset"> \param[in]    offset difference: accessor index - pixacomp array index</param>
''' <param name="pix"> \param[in]    pix [optional] initialize each ptr in pixacomp to this pix;</param>
''' <param name="comptype"> \param[in]    comptype IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompCreateWithInit")> _
Friend Shared Function pixacompCreateWithInit(n as Integer, offset as Integer, pix as IntPTR, comptype as Integer) as IntPTR
End Function

' SRC\pixcomp.c (721, 1)
' pixacompCreateFromPixa()
' pixacompCreateFromPixa(PIXA *, l_int32, l_int32) as PIXAC *
''' <summary>
''' * Notes:
'''  *   (1) If %format == IFF_DEFAULT, the conversion format for each
'''  * image is chosen automatically.  Otherwise, we use the
'''  * specified format unless it can't be done (e.g., jpeg
'''  * for a 1, 2 or 4 bpp pix, or a pix with a colormap),
'''  * in which case we use the default (assumed best) compression.
'''  *   (2) %accesstype is used to extract a boxa from %pixa.
'''  *   (3) To compress jpeg with a quality other than the default (75), use
'''  * l_jpegSetQuality()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="comptype"> \param[in]    comptype IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
''' <param name="accesstype"> \param[in]    accesstype L_COPY, L_CLONE, L_COPY_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompCreateFromPixa")> _
Friend Shared Function pixacompCreateFromPixa(pixa as IntPTR, comptype as Integer, accesstype as Integer) as IntPTR
End Function

' SRC\pixcomp.c (780, 1)
' pixacompCreateFromFiles()
' pixacompCreateFromFiles(const char *, const char *, l_int32) as PIXAC *
''' <summary>
''' * Notes:
'''  *   (1) %dirname is the full path for the directory.
'''  *   (2) %substr is the part of the file name (excluding
'''  * the directory) that is to be matched.  All matching
'''  * filenames are read into the Pixa.  If substr is NULL,
'''  * all filenames are read into the Pixa.
'''  *   (3) Use %comptype == IFF_DEFAULT to have the compression
'''  * type automatically determined for each file.
'''  *   (4) If the comptype is invalid for a file, the default will
'''  * be substituted.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixac, or NULL on error</returns>
''' <param name="dirname"> \param[in]    dirname</param>
''' <param name="substr"> \param[in]    substr [optional] substring filter on filenames; can be null</param>
''' <param name="comptype"> \param[in]    comptype IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompCreateFromFiles")> _
Friend Shared Function pixacompCreateFromFiles(dirname as String, substr as String, comptype as Integer) as IntPTR
End Function

' SRC\pixcomp.c (819, 1)
' pixacompCreateFromSA()
' pixacompCreateFromSA(SARRAY *, l_int32) as PIXAC *
''' <summary>
''' * Notes:
'''  *   (1) Use %comptype == IFF_DEFAULT to have the compression
'''  * type automatically determined for each file.
'''  *   (2) If the comptype is invalid for a file, the default will
'''  * be substituted.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixac, or NULL on error</returns>
''' <param name="sa"> \param[in]    sa full pathnames for all files</param>
''' <param name="comptype"> \param[in]    comptype IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompCreateFromSA")> _
Friend Shared Function pixacompCreateFromSA(sa as IntPTR, comptype as Integer) as IntPTR
End Function

' SRC\pixcomp.c (861, 1)
' pixacompDestroy()
' pixacompDestroy(PIXAC **) as void
''' <summary>
''' * Notes:
'''  *   (1) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="ppixac"> \param[in,out]   ppixac to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompDestroy")> _
Friend Shared Function pixacompDestroy(ppixac as Object) as Boolean ' Org. Void
End Function

' SRC\pixcomp.c (908, 1)
' pixacompAddPix()
' pixacompAddPix(PIXAC *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The array is filled up to the (n-1)-th element, and this
'''  * converts the input pix to a pixc and adds it at
'''  * the n-th position.
'''  *   (2) The pixc produced from the pix is owned by the pixac.
'''  * The input pix is not affected.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="pix"> \param[in]    pix  to be added</param>
''' <param name="comptype"> \param[in]    comptype IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompAddPix")> _
Friend Shared Function pixacompAddPix(pixac as IntPTR, pix as IntPTR, comptype as Integer) as Integer
End Function

' SRC\pixcomp.c (950, 1)
' pixacompAddPixcomp()
' pixacompAddPixcomp(PIXAC *, PIXC *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Anything added to a pixac is owned by the pixac.
'''  * So do not L_INSERT a pixc that is owned by another pixac,
'''  * or destroy a pixc that has been L_INSERTed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="pixc"> \param[in]    pixc  to be added by insertion</param>
''' <param name="copyflag"> \param[in]    copyflag L_INSERT, L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompAddPixcomp")> _
Friend Shared Function pixacompAddPixcomp(pixac as IntPTR, pixc as IntPTR, copyflag as Integer) as Integer
End Function

' SRC\pixcomp.c (1028, 1)
' pixacompReplacePix()
' pixacompReplacePix(PIXAC *, l_int32, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The %index includes the offset, which must be subtracted
'''  * to get the actual index into the ptr array.
'''  *   (2) The input %pix is converted to a pixc, which is then inserted
'''  * into the pixac.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="index"> \param[in]    index caller's view of index within pixac; includes offset</param>
''' <param name="pix"> \param[in]    pix  owned by the caller</param>
''' <param name="comptype"> \param[in]    comptype IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompReplacePix")> _
Friend Shared Function pixacompReplacePix(pixac as IntPTR, index as Integer, pix as IntPTR, comptype as Integer) as Integer
End Function

' SRC\pixcomp.c (1073, 1)
' pixacompReplacePixcomp()
' pixacompReplacePixcomp(PIXAC *, l_int32, PIXC *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The %index includes the offset, which must be subtracted
'''  * to get the actual index into the ptr array.
'''  *   (2) The inserted %pixc is now owned by the pixac.  The caller
'''  * must not destroy it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="index"> \param[in]    index caller's view of index within pixac; includes offset</param>
''' <param name="pixc"> \param[in]    pixc  to replace existing one, which is destroyed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompReplacePixcomp")> _
Friend Shared Function pixacompReplacePixcomp(pixac as IntPTR, index as Integer, pixc as IntPTR) as Integer
End Function

' SRC\pixcomp.c (1108, 1)
' pixacompAddBox()
' pixacompAddBox(PIXAC *, BOX *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="box"> \param[in]    box</param>
''' <param name="copyflag"> \param[in]    copyflag L_INSERT, L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompAddBox")> _
Friend Shared Function pixacompAddBox(pixac as IntPTR, box as IntPTR, copyflag as Integer) as Integer
End Function

' SRC\pixcomp.c (1136, 1)
' pixacompGetCount()
' pixacompGetCount(PIXAC *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 if no pixa</returns>
''' <param name="pixac"> \param[in]    pixac</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompGetCount")> _
Friend Shared Function pixacompGetCount(pixac as IntPTR) as Integer
End Function

' SRC\pixcomp.c (1164, 1)
' pixacompGetPixcomp()
' pixacompGetPixcomp(PIXAC *, l_int32, l_int32) as PIXC *
''' <summary>
''' * Notes:
'''  *   (1) The %index includes the offset, which must be subtracted
'''  * to get the actual index into the ptr array.
'''  *   (2) If copyflag == L_NOCOPY, the pixc is owned by %pixac; do
'''  * not destroy.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixc, or NULL on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="index"> \param[in]    index caller's view of index within pixac; includes offset</param>
''' <param name="copyflag"> \param[in]    copyflag L_NOCOPY, L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompGetPixcomp")> _
Friend Shared Function pixacompGetPixcomp(pixac as IntPTR, index as Integer, copyflag as Integer) as IntPTR
End Function

' SRC\pixcomp.c (1201, 1)
' pixacompGetPix()
' pixacompGetPix(PIXAC *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The %index includes the offset, which must be subtracted
'''  * to get the actual index into the ptr array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="index"> \param[in]    index caller's view of index within pixac; includes offset</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompGetPix")> _
Friend Shared Function pixacompGetPix(pixac as IntPTR, index as Integer) as IntPTR
End Function

' SRC\pixcomp.c (1235, 1)
' pixacompGetPixDimensions()
' pixacompGetPixDimensions(PIXAC *, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The %index includes the offset, which must be subtracted
'''  * to get the actual index into the ptr array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="index"> \param[in]    index caller's view of index within pixac; includes offset</param>
''' <param name="pw"> \param[out]   pw, ph, pd [optional]  each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompGetPixDimensions")> _
Friend Shared Function pixacompGetPixDimensions(pixac as IntPTR, index as Integer, pw as Integer, ph as Integer, pd as Integer) as Integer
End Function

' SRC\pixcomp.c (1267, 1)
' pixacompGetBoxa()
' pixacompGetBoxa(PIXAC *, l_int32) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa, or NULL on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="accesstype"> \param[in]    accesstype  L_COPY, L_CLONE, L_COPY_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompGetBoxa")> _
Friend Shared Function pixacompGetBoxa(pixac as IntPTR, accesstype as Integer) as IntPTR
End Function

' SRC\pixcomp.c (1291, 1)
' pixacompGetBoxaCount()
' pixacompGetBoxaCount(PIXAC *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompGetBoxaCount")> _
Friend Shared Function pixacompGetBoxaCount(pixac as IntPTR) as Integer
End Function

' SRC\pixcomp.c (1325, 1)
' pixacompGetBox()
' pixacompGetBox(PIXAC *, l_int32, l_int32) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) The %index includes the offset, which must be subtracted
'''  * to get the actual index into the ptr array.
'''  *   (2) There is always a boxa with a pixac, and it is initialized so
'''  * that each box ptr is NULL.
'''  *   (3) In general, we expect that there is either a box associated
'''  * with each pixc, or no boxes at all in the boxa.
'''  *   (4) Having no boxes is thus not an automatic error.  Whether it
'''  * is an actual error is determined by the calling program.
'''  * If the caller expects to get a box, it is an error; see, e.g.,
'''  * pixacGetBoxGeometry().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box if null, not automatically an error, or NULL on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="index"> \param[in]    index caller's view of index within pixac; includes offset</param>
''' <param name="accesstype"> \param[in]    accesstype  L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompGetBox")> _
Friend Shared Function pixacompGetBox(pixac as IntPTR, index as Integer, accesstype as Integer) as IntPTR
End Function

' SRC\pixcomp.c (1371, 1)
' pixacompGetBoxGeometry()
' pixacompGetBoxGeometry(PIXAC *, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The %index includes the offset, which must be subtracted
'''  * to get the actual index into the ptr array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="index"> \param[in]    index caller's view of index within pixac; includes offset</param>
''' <param name="px"> \param[out]   px, py, pw, ph [optional]  each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompGetBoxGeometry")> _
Friend Shared Function pixacompGetBoxGeometry(pixac as IntPTR, index as Integer, px as Integer, py as Integer, pw as Integer, ph as Integer) as Integer
End Function

' SRC\pixcomp.c (1411, 1)
' pixacompGetOffset()
' pixacompGetOffset(PIXAC *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) The offset is the difference between the caller's view of
'''  * the index into the array and the actual array index.
'''  * By default it is 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  offset, or 0 on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompGetOffset")> _
Friend Shared Function pixacompGetOffset(pixac as IntPTR) as Integer
End Function

' SRC\pixcomp.c (1436, 1)
' pixacompSetOffset()
' pixacompSetOffset(PIXAC *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The offset is the difference between the caller's view of
'''  * the index into the array and the actual array index.
'''  * By default it is 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="offset"> \param[in]    offset non-negative</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompSetOffset")> _
Friend Shared Function pixacompSetOffset(pixac as IntPTR, offset as Integer) as Integer
End Function

' SRC\pixcomp.c (1466, 1)
' pixaCreateFromPixacomp()
' pixaCreateFromPixacomp(PIXAC *, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Because the pixa has no notion of offset, the offset must
'''  * be set to 0 before the conversion, so that pixacompGetPix()
'''  * fetches all the pixcomps.  It is reset at the end.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa if OK, or NULL on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="accesstype"> \param[in]    accesstype L_COPY, L_CLONE, L_COPY_CLONE; for boxa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaCreateFromPixacomp")> _
Friend Shared Function pixaCreateFromPixacomp(pixac as IntPTR, accesstype as Integer) as IntPTR
End Function

' SRC\pixcomp.c (1524, 1)
' pixacompJoin()
' pixacompJoin(PIXAC *, PIXAC *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This appends a clone of each indicated pixc in pixcas to pixcad
'''  *   (2) istart  0 is taken to mean 'read from the start' (istart = 0)
'''  *   (3) iend  0 means 'read to the end'
'''  *   (4) If pixacs is NULL or contains no pixc, this is a no-op.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixacd"> \param[in]    pixacd  dest pixac; add to this one</param>
''' <param name="pixacs"> \param[in]    pixacs  [optional] source pixac; add from this one</param>
''' <param name="istart"> \param[in]    istart  starting index in pixacs</param>
''' <param name="iend"> \param[in]    iend  ending index in pixacs; use -1 to cat all</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompJoin")> _
Friend Shared Function pixacompJoin(pixacd as IntPTR, pixacs as IntPTR, istart as Integer, iend as Integer) as Integer
End Function

' SRC\pixcomp.c (1577, 1)
' pixacompInterleave()
' pixacompInterleave(PIXAC *, PIXAC *) as PIXAC *
''' <summary>
''' * Notes:
'''  *   (1) If the two pixac have different sizes, a warning is issued,
'''  * and the number of pairs returned is the minimum size.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixacd  interleaved from sources, or NULL on error.</returns>
''' <param name="pixac1"> \param[in]    pixac1  first src pixac</param>
''' <param name="pixac2"> \param[in]    pixac2  second src pixac</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompInterleave")> _
Friend Shared Function pixacompInterleave(pixac1 as IntPTR, pixac2 as IntPTR) as IntPTR
End Function

' SRC\pixcomp.c (1639, 1)
' pixacompRead()
' pixacompRead(const char *) as PIXAC *
''' <summary>
''' * Notes:
'''  *   (1) Unlike the situation with serialized Pixa, where the image
'''  * data is stored in png format, the Pixacomp image data
'''  * can be stored in tiffg4, png and jpg formats.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixac, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompRead")> _
Friend Shared Function pixacompRead(filename as String) as IntPTR
End Function

' SRC\pixcomp.c (1666, 1)
' pixacompReadStream()
' pixacompReadStream(FILE *) as PIXAC *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixac, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompReadStream")> _
Friend Shared Function pixacompReadStream(fp as Object) as IntPTR
End Function

' SRC\pixcomp.c (1764, 1)
' pixacompReadMem()
' pixacompReadMem(const l_uint8 *, size_t) as PIXAC *
''' <summary>
''' * Notes:
'''  *   (1) Deseralizes a buffer of pixacomp data into a pixac in memory.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixac, or NULL on error</returns>
''' <param name="data"> \param[in]    data const; pixacomp format</param>
''' <param name="size"> \param[in]    size of data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompReadMem")> _
Friend Shared Function pixacompReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\pixcomp.c (1799, 1)
' pixacompWrite()
' pixacompWrite(const char *, PIXAC *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Unlike the situation with serialized Pixa, where the image
'''  * data is stored in png format, the Pixacomp image data
'''  * can be stored in tiffg4, png and jpg formats.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pixac"> \param[in]    pixac</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompWrite")> _
Friend Shared Function pixacompWrite(filename as String, pixac as IntPTR) as Integer
End Function

' SRC\pixcomp.c (1830, 1)
' pixacompWriteStream()
' pixacompWriteStream(FILE *, PIXAC *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="pixac"> \param[in]    pixac</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompWriteStream")> _
Friend Shared Function pixacompWriteStream(fp as Object, pixac as IntPTR) as Integer
End Function

' SRC\pixcomp.c (1878, 1)
' pixacompWriteMem()
' pixacompWriteMem(l_uint8 **, size_t *, PIXAC *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a pixac in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata  serialized data of pixac</param>
''' <param name="psize"> \param[out]   psize  size of serialized data</param>
''' <param name="pixac"> \param[in]    pixac</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompWriteMem")> _
Friend Shared Function pixacompWriteMem(pdata as Object, psize as ULong, pixac as IntPTR) as Integer
End Function

' SRC\pixcomp.c (1952, 1)
' pixacompConvertToPdf()
' pixacompConvertToPdf(PIXAC *, l_int32, l_float32, l_int32, l_int32, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This follows closely the function pixaConvertToPdf() in pdfio.c.
'''  *   (2) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without
'''  * colormap and many colors, or 32 bpp; FLATE for anything else.
'''  *   (3) The scalefactor must be > 0.0; otherwise it is set to 1.0.
'''  *   (4) Specifying one of the three encoding types for %type forces
'''  * all images to be compressed with that type.  Use 0 to have
'''  * the type determined for each image based on depth and whether
'''  * or not it has a colormap.
'''  *   (5) If all images are jpeg compressed, don't require scaling
'''  * and have the same resolution, it is much faster to skip
'''  * transcoding with pixacompFastConvertToPdfData(), and then
'''  * write the data out to file.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixac"> \param[in]    pixac containing images all at the same resolution</param>
''' <param name="res"> \param[in]    res override the resolution of each input image, in ppi;</param>
''' <param name="scalefactor"> \param[in]    scalefactor scaling factor applied to each image; > 0.0</param>
''' <param name="type"> \param[in]    type encoding type (L_JPEG_ENCODE, L_G4_ENCODE,</param>
''' <param name="quality"> \param[in]    quality used for JPEG only; 0 for default (75)</param>
''' <param name="title"> \param[in]    title [optional] pdf title</param>
''' <param name="fileout"> \param[in]    fileout pdf file of all images</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompConvertToPdf")> _
Friend Shared Function pixacompConvertToPdf(pixac as IntPTR, res as Integer, scalefactor as single, type as Integer, quality as Integer, title as String, fileout as String) as Integer
End Function

' SRC\pixcomp.c (2004, 1)
' pixacompConvertToPdfData()
' pixacompConvertToPdfData(PIXAC *, l_int32, l_float32, l_int32, l_int32, const char *, l_uint8 **, size_t *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See pixacompConvertToPdf().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixac"> \param[in]    pixac containing images all at the same resolution</param>
''' <param name="res"> \param[in]    res input resolution of all images</param>
''' <param name="scalefactor"> \param[in]    scalefactor scaling factor applied to each image; > 0.0</param>
''' <param name="type"> \param[in]    type encoding type (L_JPEG_ENCODE, L_G4_ENCODE,</param>
''' <param name="quality"> \param[in]    quality used for JPEG only; 0 for default (75)</param>
''' <param name="title"> \param[in]    title [optional] pdf title</param>
''' <param name="pdata"> \param[out]   pdata output pdf data (of all images</param>
''' <param name="pnbytes"> \param[out]   pnbytes size of output pdf data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompConvertToPdfData")> _
Friend Shared Function pixacompConvertToPdfData(pixac as IntPTR, res as Integer, scalefactor as single, type as Integer, quality as Integer, title as String, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\pixcomp.c (2115, 1)
' pixacompFastConvertToPdfData()
' pixacompFastConvertToPdfData(PIXAC *, const char *, l_uint8 **, size_t *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This generates the pdf without transcoding if all the
'''  * images in %pixac are compressed with jpeg.
'''  * Images not jpeg compressed are skipped.
'''  *   (2) It assumes all images have the same resolution, and that
'''  * the resolution embedded in each jpeg file is correct.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixac"> \param[in]    pixac containing images all at the same resolution</param>
''' <param name="title"> \param[in]    title [optional] pdf title</param>
''' <param name="pdata"> \param[out]   pdata output pdf data (of all images</param>
''' <param name="pnbytes"> \param[out]   pnbytes size of output pdf data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompFastConvertToPdfData")> _
Friend Shared Function pixacompFastConvertToPdfData(pixac as IntPTR, title as String, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\pixcomp.c (2240, 1)
' pixacompWriteStreamInfo()
' pixacompWriteStreamInfo(FILE *, PIXAC *, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="text"> \param[in]    text [optional] identifying string; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompWriteStreamInfo")> _
Friend Shared Function pixacompWriteStreamInfo(fp as Object, pixac as IntPTR, text as String) as Integer
End Function

' SRC\pixcomp.c (2284, 1)
' pixcompWriteStreamInfo()
' pixcompWriteStreamInfo(FILE *, PIXC *, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="pixc"> \param[in]    pixc</param>
''' <param name="text"> \param[in]    text [optional] identifying string; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcompWriteStreamInfo")> _
Friend Shared Function pixcompWriteStreamInfo(fp as Object, pixc as IntPTR, text as String) as Integer
End Function

' SRC\pixcomp.c (2340, 1)
' pixacompDisplayTiledAndScaled()
' pixacompDisplayTiledAndScaled(PIXAC *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is the same function as pixaDisplayTiledAndScaled(),
'''  * except it works on a Pixacomp instead of a Pix.  It is particularly
'''  * useful for showing the images in a Pixacomp at reduced resolution.
'''  *   (2) See pixaDisplayTiledAndScaled() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix of tiled images, or NULL on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="outdepth"> \param[in]    outdepth output depth: 1, 8 or 32 bpp</param>
''' <param name="tilewidth"> \param[in]    tilewidth each pix is scaled to this width</param>
''' <param name="ncols"> \param[in]    ncols number of tiles in each row</param>
''' <param name="background"> \param[in]    background 0 for white, 1 for black; this is the color</param>
''' <param name="spacing"> \param[in]    spacing  between images, and on outside</param>
''' <param name="border"> \param[in]    border width of additional black border on each image;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompDisplayTiledAndScaled")> _
Friend Shared Function pixacompDisplayTiledAndScaled(pixac as IntPTR, outdepth as Integer, tilewidth as Integer, ncols as Integer, background as Integer, spacing as Integer, border as Integer) as IntPTR
End Function

' SRC\pixcomp.c (2374, 1)
' pixacompWriteFiles()
' pixacompWriteFiles(PIXAC *, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixac"> \param[in]    pixac</param>
''' <param name="subdir"> \param[in]    subdir (subdirectory of /tmp)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixacompWriteFiles")> _
Friend Shared Function pixacompWriteFiles(pixac as IntPTR, subdir as String) as Integer
End Function

' SRC\pixcomp.c (2414, 1)
' pixcompWriteFile()
' pixcompWriteFile(const char *, PIXC *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The compressed data is written to file, and the filename is
'''  * generated by appending the format extension to %rootname.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="rootname"> \param[in]    rootname</param>
''' <param name="pixc"> \param[in]    pixc</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixcompWriteFile")> _
Friend Shared Function pixcompWriteFile(rootname as String, pixc as IntPTR) as Integer
End Function

#End Region
#Region "SRC\pixconv.c"
' SRC\pixconv.c (204, 1)
' pixThreshold8()
' pixThreshold8(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This uses, by default, equally spaced "target" values
'''  * that depend on the number of levels, with thresholds
'''  * halfway between.  For N levels, with separation (N-1)/255,
'''  * there are N-1 fixed thresholds.
'''  *   (2) For 1 bpp destination, the number of levels can only be 2
'''  * and if a cmap is made, black is (0,0,0) and white
'''  * is (255,255,255), which is opposite to the convention
'''  * without a colormap.
'''  *   (3) For 1, 2 and 4 bpp, the nlevels arg is used if a colormap
'''  * is made; otherwise, we take the most significant bits
'''  * from the src that will fit in the dest.
'''  *   (4) For 8 bpp, the input pixs is quantized to nlevels.  The
'''  * dest quantized with that mapping, either through a colormap
'''  * table or directly with 8 bit values.
'''  *   (5) Typically you should not use make a colormap for 1 bpp dest.
'''  *   (6) This is not dithering.  Each pixel is treated independently.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd thresholded with standard dest thresholds,</returns>
''' <param name="pixs"> \param[in]    pixs       8 bpp grayscale</param>
''' <param name="d"> \param[in]    d          destination depth: 1, 2, 4 or 8</param>
''' <param name="nlevels"> \param[in]    nlevels    number of levels to be used for colormap</param>
''' <param name="cmapflag"> \param[in]    cmapflag   1 if makes colormap; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixThreshold8")> _
Friend Shared Function pixThreshold8(pixs as IntPTR, d as Integer, nlevels as Integer, cmapflag as Integer) as IntPTR
End Function

' SRC\pixconv.c (272, 1)
' pixRemoveColormapGeneral()
' pixRemoveColormapGeneral(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Convenience function that allows choice between returning
'''  * a clone or a copy if pixs does not have a colormap.
'''  *   (2) See pixRemoveColormap().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always a new pix; without colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs      any depth, with or without colormap</param>
''' <param name="type"> \param[in]    type      REMOVE_CMAP_TO_BINARY,</param>
''' <param name="ifnocmap"> \param[in]    ifnocmap  L_CLONE, L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRemoveColormapGeneral")> _
Friend Shared Function pixRemoveColormapGeneral(pixs as IntPTR, type as Integer, ifnocmap as Integer) as IntPTR
End Function

' SRC\pixconv.c (322, 1)
' pixRemoveColormap()
' pixRemoveColormap(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixs does not have a colormap, a clone is returned.
'''  *   (2) Otherwise, the input pixs is restricted to 1, 2, 4 or 8 bpp.
'''  *   (3) Use REMOVE_CMAP_TO_BINARY only on 1 bpp pix.
'''  *   (4) For grayscale conversion from RGB, use a weighted average
'''  * of RGB values, and always return an 8 bpp pix, regardless
'''  * of whether the input pixs depth is 2, 4 or 8 bpp.
'''  *   (5) REMOVE_CMAP_TO_FULL_COLOR ignores the alpha component and
'''  * returns a 32 bpp pix with spp == 3 and the alpha bytes are 0.
'''  *   (6) For REMOVE_CMAP_BASED_ON_SRC, if there is no color, this
'''  * returns either a 1 bpp or 8 bpp grayscale pix.
'''  * If there is color, this returns a 32 bpp pix, with either:
'''  *  * 3 spp, if the alpha values are all 255 (opaque), or
'''  *  * 4 spp (preserving the alpha), if any alpha values are not 255.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd without colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   see restrictions below</param>
''' <param name="type"> \param[in]    type   REMOVE_CMAP_TO_BINARY,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRemoveColormap")> _
Friend Shared Function pixRemoveColormap(pixs as IntPTR, type as Integer) as IntPTR
End Function

' SRC\pixconv.c (613, 1)
' pixAddGrayColormap8()
' pixAddGrayColormap8(PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If pixs has a colormap, this is a no-op.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs   8 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddGrayColormap8")> _
Friend Shared Function pixAddGrayColormap8(pixs as IntPTR) as Integer
End Function

' SRC\pixconv.c (644, 1)
' pixAddMinimalGrayColormap8()
' pixAddMinimalGrayColormap8(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This generates a colormapped version of the input image
'''  * that has the same number of colormap entries as the
'''  * input image has unique gray levels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs   8 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddMinimalGrayColormap8")> _
Friend Shared Function pixAddMinimalGrayColormap8(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (733, 1)
' pixConvertRGBToLuminance()
' pixConvertRGBToLuminance(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Use a standard luminance conversion.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  8 bpp pix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   32 bpp RGB</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToLuminance")> _
Friend Shared Function pixConvertRGBToLuminance(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (753, 1)
' pixConvertRGBToGray()
' pixConvertRGBToGray(PIX *, l_float32, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Use a weighted average of the RGB values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  8 bpp pix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs           32 bpp RGB</param>
''' <param name="rwt"> \param[in]    rwt, gwt, bwt  non-negative; these should add to 1.0,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToGray")> _
Friend Shared Function pixConvertRGBToGray(pixs as IntPTR, rwt as single, gwt as single, bwt as single) as IntPTR
End Function

' SRC\pixconv.c (831, 1)
' pixConvertRGBToGrayFast()
' pixConvertRGBToGrayFast(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function should be used if speed of conversion
'''  * is paramount, and the green channel can be used as
'''  * a fair representative of the RGB intensity.  It is
'''  * several times faster than pixConvertRGBToGray().
'''  *   (2) To combine RGB to gray conversion with subsampling,
'''  * use pixScaleRGBToGrayFast() instead.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  8 bpp pix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    32 bpp RGB</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToGrayFast")> _
Friend Shared Function pixConvertRGBToGrayFast(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (887, 1)
' pixConvertRGBToGrayMinMax()
' pixConvertRGBToGrayMinMax(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This chooses various components or combinations of them,
'''  * from the three RGB sample values.  In addition to choosing
'''  * the min, max, and maxdiff (difference between max and min),
'''  * this also allows boosting the min and max about a reference
'''  * value.
'''  *   (2) The default reference value for boosting the min and max
'''  * is 200.  This can be changed with l_setNeutralBoostVal()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  8 bpp pix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   32 bpp RGB</param>
''' <param name="type"> \param[in]    type   L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToGrayMinMax")> _
Friend Shared Function pixConvertRGBToGrayMinMax(pixs as IntPTR, type as Integer) as IntPTR
End Function

' SRC\pixconv.c (974, 1)
' pixConvertRGBToGraySatBoost()
' pixConvertRGBToGraySatBoost(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This returns the max component value, boosted by
'''  * the saturation. The maximum boost occurs where
'''  * the maximum component value is equal to some reference value.
'''  * This particular weighting is due to Dany Qumsiyeh.
'''  *   (2) For gray pixels (zero saturation), this returns
'''  * the intensity of any component.
'''  *   (3) For fully saturated pixels ('fullsat'), this rises linearly
'''  * with the max value and has a slope equal to 255 divided
'''  * by the reference value; for a max value greater than
'''  * the reference value, it is clipped to 255.
'''  *   (4) For saturation values in between, the output is a linear
'''  * combination of (2) and (3), weighted by saturation.
'''  * It falls between these two curves, and does not exceed 255.
'''  *   (5) This can be useful for distinguishing an object that has nonzero
'''  * saturation from a gray background.  For this, the refval
'''  * should be chosen near the expected value of the background,
'''  * to achieve maximum saturation boost there.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    32 bpp rgb</param>
''' <param name="refval"> \param[in]    refval  between 1 and 255; typ. less than 128</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToGraySatBoost")> _
Friend Shared Function pixConvertRGBToGraySatBoost(pixs as IntPTR, refval as Integer) as IntPTR
End Function

' SRC\pixconv.c (1052, 1)
' pixConvertRGBToGrayArb()
' pixConvertRGBToGrayArb(PIX *, l_float32, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This converts to gray using an arbitrary linear combination
'''  * of the rgb color components.  It differs from pixConvertToGray(),
'''  * which uses only positive coefficients that sum to 1.
'''  *   (2) The gray output values are clipped to 0 and 255.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  8 bpp pix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs        32 bpp RGB</param>
''' <param name="rc"> \param[in]    rc, gc, bc  arithmetic factors; can be negative</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToGrayArb")> _
Friend Shared Function pixConvertRGBToGrayArb(pixs as IntPTR, rc as single, gc as single, bc as single) as IntPTR
End Function

' SRC\pixconv.c (1114, 1)
' pixConvertRGBToBinaryArb()
' pixConvertRGBToBinaryArb(PIX *, l_float32, l_float32, l_float32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This makes a 1 bpp mask from an RGB image, using an arbitrary
'''  * linear combination of the rgb color components, along with
'''  * a threshold and a selection choice of the gray value relative
'''  * to %thresh.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 bpp pix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs        32 bpp RGB</param>
''' <param name="rc"> \param[in]    rc, gc, bc  arithmetic factors; can be negative</param>
''' <param name="gc"> \param[in]    thresh      binarization threshold</param>
''' <param name="bc"> \param[in]    relation    L_SELECT_IF_LT, L_SELECT_IF_GT</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToBinaryArb")> _
Friend Shared Function pixConvertRGBToBinaryArb(pixs as IntPTR, rc as single, gc as single, bc as single, thresh as Integer, relation as Integer) as IntPTR
End Function

' SRC\pixconv.c (1171, 1)
' pixConvertGrayToColormap()
' pixConvertGrayToColormap(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a simple interface for adding a colormap to a
'''  * 2, 4 or 8 bpp grayscale image without causing any
'''  * quantization.  There is some similarity to operations
'''  * in grayquant.c, such as pixThresholdOn8bpp(), where
'''  * the emphasis is on quantization with an arbitrary number
'''  * of levels, and a colormap is an option.
'''  *   (2) Returns a copy if pixs already has a colormap.
'''  *   (3) For 8 bpp src, this is a lossless transformation.
'''  *   (4) For 2 and 4 bpp src, this generates a colormap that
'''  * assumes full coverage of the gray space, with equally spaced
'''  * levels: 4 levels for d = 2 and 16 levels for d = 4.
'''  *   (5) In all cases, the depth of the dest is the same as the src.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    2, 4 or 8 bpp grayscale</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertGrayToColormap")> _
Friend Shared Function pixConvertGrayToColormap(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (1226, 1)
' pixConvertGrayToColormap8()
' pixConvertGrayToColormap8(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Returns a copy if pixs already has a colormap.
'''  *   (2) This is a lossless transformation; there is no quantization.
'''  * We compute the number of different gray values in pixs,
'''  * and construct a colormap that has exactly these values.
'''  *   (3) 'mindepth' is the minimum depth of pixd.  If mindepth == 8,
'''  * pixd will always be 8 bpp.  Let the number of different
'''  * gray values in pixs be ngray.  If mindepth == 4, we attempt
'''  * to save pixd as a 4 bpp image, but if ngray > 16,
'''  * pixd must be 8 bpp.  Likewise, if mindepth == 2,
'''  * the depth of pixd will be 2 if ngray = 4 and 4 if ngray > 4
'''  * but = 16.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs       8 bpp grayscale</param>
''' <param name="mindepth"> \param[in]    mindepth   of pixd; valid values are 2, 4 and 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertGrayToColormap8")> _
Friend Shared Function pixConvertGrayToColormap8(pixs as IntPTR, mindepth as Integer) as IntPTR
End Function

' SRC\pixconv.c (1323, 1)
' pixColorizeGray()
' pixColorizeGray(PIX *, l_uint32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This applies the specific color to the grayscale image.
'''  *   (2) If pixs already has a colormap, it is removed to gray
'''  * before colorizing.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp colormapped or 32 bpp rgb, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs      8 bpp gray; 2, 4 or 8 bpp colormapped</param>
''' <param name="color"> \param[in]    color     32 bit rgba pixel</param>
''' <param name="cmapflag"> \param[in]    cmapflag  1 for result to have colormap; 0 for RGB</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixColorizeGray")> _
Friend Shared Function pixColorizeGray(pixs as IntPTR, color as UInteger, cmapflag as Integer) as IntPTR
End Function

' SRC\pixconv.c (1412, 1)
' pixConvertRGBToColormap()
' pixConvertRGBToColormap(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function has two relatively simple modes of color
'''  * quantization:
'''  *   (a) If the image is made orthographically and has not more
'''  * than 256 'colors' at the level 4 octcube leaves,
'''  * it is quantized nearly exactly.  The ditherflag
'''  * is ignored.
'''  *   (b) Most natural images have more than 256 different colors;
'''  * in that case we use adaptive octree quantization,
'''  * with dithering if requested.
'''  *   (2) If there are not more than 256 occupied level 4 octcubes,
'''  * the color in the colormap that represents all pixels in
'''  * one of those octcubes is given by the first pixel that
'''  * falls into that octcube.
'''  *   (3) If there are more than 256 colors, we use adaptive octree
'''  * color quantization.
'''  *   (4) Dithering gives better visual results on images where
'''  * there is a color wash (a slow variation of color), but it
'''  * is about twice as slow and results in significantly larger
'''  * files when losslessly compressed (e.g., into png).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs       32 bpp rgb</param>
''' <param name="ditherflag"> \param[in]    ditherflag  1 to dither, 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertRGBToColormap")> _
Friend Shared Function pixConvertRGBToColormap(pixs as IntPTR, ditherflag as Integer) as IntPTR
End Function

' SRC\pixconv.c (1477, 1)
' pixConvertCmapTo1()
' pixConvertCmapTo1(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is an extreme color quantizer.  It decides which
'''  * colors map to FG (black) and which to BG (white).
'''  *   (2) This uses two heuristics to make the decision:
'''  * (a) colors similar to each other are likely to be in the same class
'''  * (b) there is usually much less FG than BG.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   cmapped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertCmapTo1")> _
Friend Shared Function pixConvertCmapTo1(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (1588, 1)
' pixQuantizeIfFewColors()
' pixQuantizeIfFewColors(PIX *, l_int32, l_int32, l_int32, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a wrapper that tests if the pix can be quantized
'''  * with good quality using a small number of colors.  If so,
'''  * it does the quantization, defining a colormap and using
'''  * pixels whose value is an index into the colormap.
'''  *   (2) If the image has color, it is quantized with 8 bpp pixels.
'''  * If the image is essentially grayscale, the pixels are
'''  * either 4 or 8 bpp, depending on the size of the required
'''  * colormap.
'''  *   (3) %octlevel = 4 generates a larger colormap and larger
'''  * compressed image than %octlevel = 3.  If image quality is
'''  * important, you should use %octlevel = 4.
'''  *   (4) If the image already has a colormap, it returns a clone.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if pixs can't be quantized into</returns>
''' <param name="pixs"> \param[in]    pixs           8 bpp gray or 32 bpp rgb</param>
''' <param name="maxcolors"> \param[in]    maxcolors      max number of colors allowed to be returned</param>
''' <param name="mingraycolors"> \param[in]    mingraycolors  min number of gray levels that a grayscale</param>
''' <param name="octlevel"> \param[in]    octlevel       for octcube quantization: 3 or 4</param>
''' <param name="ppixd"> \param[out]   ppixd          2,4 or 8 bpp quantized; null if too many colors</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixQuantizeIfFewColors")> _
Friend Shared Function pixQuantizeIfFewColors(pixs as IntPTR, maxcolors as Integer, mingraycolors as Integer, octlevel as Integer, ppixd as Object) as Integer
End Function

' SRC\pixconv.c (1689, 1)
' pixConvert16To8()
' pixConvert16To8(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) With L_AUTO_BYTE, if the max pixel value is greater than 255,
'''  * use the MSB; otherwise, use the LSB.
'''  *   (2) With L_CLIP_TO_FF, use min(pixel-value, 0xff) for each
'''  * 16-bit src pixel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     16 bpp</param>
''' <param name="type"> \param[in]    type     L_LS_BYTE, L_MS_BYTE, L_AUTO_BYTE, L_CLIP_TO_FF</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert16To8")> _
Friend Shared Function pixConvert16To8(pixs as IntPTR, type as Integer) as IntPTR
End Function

' SRC\pixconv.c (1786, 1)
' pixConvertGrayToFalseColor()
' pixConvertGrayToFalseColor(PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For 8 bpp input, this simply adds a colormap to the input image.
'''  *   (2) For 16 bpp input, it first converts to 8 bpp, using the MSB,
'''  * and then adds the colormap.
'''  *   (3) The colormap is modeled after the Matlab "jet" configuration.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp with colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    8 or 16 bpp grayscale</param>
''' <param name="gamma"> \param[in]    gamma   (factor) 0.0 or 1.0 for default; > 1.0 for brighter;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertGrayToFalseColor")> _
Friend Shared Function pixConvertGrayToFalseColor(pixs as IntPTR, gamma as single) as IntPTR
End Function

' SRC\pixconv.c (1878, 1)
' pixUnpackBinary()
' pixUnpackBinary(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function calls special cases of pixConvert1To*(),
'''  * for 2, 4, 8, 16 and 32 bpp destinations.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 2, 4, 8, 16 or 32 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     1 bpp</param>
''' <param name="depth"> \param[in]    depth    of destination: 2, 4, 8, 16 or 32 bpp</param>
''' <param name="invert"> \param[in]    invert   0:  binary 0 --> grayscale 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixUnpackBinary")> _
Friend Shared Function pixUnpackBinary(pixs as IntPTR, depth as Integer, invert as Integer) as IntPTR
End Function

' SRC\pixconv.c (1943, 1)
' pixConvert1To16()
' pixConvert1To16(PIX *, PIX *, l_uint16, l_uint16) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixd is null, a new pix is made.
'''  *   (2) If pixd is not null, it must be of equal width and height
'''  * as pixs.  It is always returned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 16 bpp</returns>
''' <param name="pixd"> \param[in]    pixd    [optional] 16 bpp, can be null</param>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
''' <param name="val0"> \param[in]    val0    16 bit value to be used for 0s in pixs</param>
''' <param name="val1"> \param[in]    val1    16 bit value to be used for 1s in pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert1To16")> _
Friend Shared Function pixConvert1To16(pixd as IntPTR, pixs as IntPTR, val0 as UShort, val1 as UShort) as IntPTR
End Function

' SRC\pixconv.c (2017, 1)
' pixConvert1To32()
' pixConvert1To32(PIX *, PIX *, l_uint32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixd is null, a new pix is made.
'''  *   (2) If pixd is not null, it must be of equal width and height
'''  * as pixs.  It is always returned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp</returns>
''' <param name="pixd"> \param[in]    pixd    [optional] 32 bpp, can be null</param>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
''' <param name="val0"> \param[in]    val0    32 bit value to be used for 0s in pixs</param>
''' <param name="val1"> \param[in]    val1    32 bit value to be used for 1s in pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert1To32")> _
Friend Shared Function pixConvert1To32(pixd as IntPTR, pixs as IntPTR, val0 as UInteger, val1 as UInteger) as IntPTR
End Function

' SRC\pixconv.c (2080, 1)
' pixConvert1To2Cmap()
' pixConvert1To2Cmap(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 2 bpp, cmapped</returns>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert1To2Cmap")> _
Friend Shared Function pixConvert1To2Cmap(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (2123, 1)
' pixConvert1To2()
' pixConvert1To2(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixd is null, a new pix is made.
'''  *   (2) If pixd is not null, it must be of equal width and height
'''  * as pixs.  It is always returned.
'''  *   (3) A simple unpacking might use val0 = 0 and val1 = 3.
'''  *   (4) If you want a colormapped pixd, use pixConvert1To2Cmap().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 2 bpp</returns>
''' <param name="pixd"> \param[in]    pixd    [optional] 2 bpp, can be null</param>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
''' <param name="val0"> \param[in]    val0    2 bit value to be used for 0s in pixs</param>
''' <param name="val1"> \param[in]    val1    2 bit value to be used for 1s in pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert1To2")> _
Friend Shared Function pixConvert1To2(pixd as IntPTR, pixs as IntPTR, val0 as Integer, val1 as Integer) as IntPTR
End Function

' SRC\pixconv.c (2202, 1)
' pixConvert1To4Cmap()
' pixConvert1To4Cmap(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 4 bpp, cmapped</returns>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert1To4Cmap")> _
Friend Shared Function pixConvert1To4Cmap(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (2245, 1)
' pixConvert1To4()
' pixConvert1To4(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixd is null, a new pix is made.
'''  *   (2) If pixd is not null, it must be of equal width and height
'''  * as pixs.  It is always returned.
'''  *   (3) A simple unpacking might use val0 = 0 and val1 = 15, or v.v.
'''  *   (4) If you want a colormapped pixd, use pixConvert1To4Cmap().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 4 bpp</returns>
''' <param name="pixd"> \param[in]    pixd    [optional] 4 bpp, can be null</param>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
''' <param name="val0"> \param[in]    val0    4 bit value to be used for 0s in pixs</param>
''' <param name="val1"> \param[in]    val1    4 bit value to be used for 1s in pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert1To4")> _
Friend Shared Function pixConvert1To4(pixd as IntPTR, pixs as IntPTR, val0 as Integer, val1 as Integer) as IntPTR
End Function

' SRC\pixconv.c (2323, 1)
' pixConvert1To8Cmap()
' pixConvert1To8Cmap(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, cmapped</returns>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert1To8Cmap")> _
Friend Shared Function pixConvert1To8Cmap(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (2366, 1)
' pixConvert1To8()
' pixConvert1To8(PIX *, PIX *, l_uint8, l_uint8) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixd is null, a new pix is made.
'''  *   (2) If pixd is not null, it must be of equal width and height
'''  * as pixs.  It is always returned.
'''  *   (3) A simple unpacking might use val0 = 0 and val1 = 255, or v.v.
'''  *   (4) To have a colormap associated with the 8 bpp pixd,
'''  * use pixConvert1To8Cmap().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp</returns>
''' <param name="pixd"> \param[in]    pixd    [optional] 8 bpp, can be null</param>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
''' <param name="val0"> \param[in]    val0    8 bit value to be used for 0s in pixs</param>
''' <param name="val1"> \param[in]    val1    8 bit value to be used for 1s in pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert1To8")> _
Friend Shared Function pixConvert1To8(pixd as IntPTR, pixs as IntPTR, val0 as Byte, val1 as Byte) as IntPTR
End Function

' SRC\pixconv.c (2456, 1)
' pixConvert2To8()
' pixConvert2To8(PIX *, l_uint8, l_uint8, l_uint8, l_uint8, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   ~ A simple unpacking might use val0 = 0,
'''  *  val1 = 85 (0x55), val2 = 170 (0xaa), val3 = 255.
'''  *   ~ If cmapflag is TRUE:
'''  * ~ The 8 bpp image is made with a colormap.
'''  * ~ If pixs has a colormap, the input values are ignored and
'''  *   the 8 bpp image is made using the colormap
'''  * ~ If pixs does not have a colormap, the input values are
'''  *   used to build the colormap.
'''  *   ~ If cmapflag is FALSE:
'''  * ~ The 8 bpp image is made without a colormap.
'''  * ~ If pixs has a colormap, the input values are ignored,
'''  *   the colormap is removed, and the values stored in the 8 bpp
'''  *   image are from the colormap.
'''  * ~ If pixs does not have a colormap, the input values are
'''  *   used to populate the 8 bpp image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs      2 bpp</param>
''' <param name="val0"> \param[in]    val0      8 bit value to be used for 00 in pixs</param>
''' <param name="val1"> \param[in]    val1      8 bit value to be used for 01 in pixs</param>
''' <param name="val2"> \param[in]    val2      8 bit value to be used for 10 in pixs</param>
''' <param name="val3"> \param[in]    val3      8 bit value to be used for 11 in pixs</param>
''' <param name="cmapflag"> \param[in]    cmapflag  TRUE if pixd is to have a colormap; FALSE otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert2To8")> _
Friend Shared Function pixConvert2To8(pixs as IntPTR, val0 as Byte, val1 as Byte, val2 as Byte, val3 as Byte, cmapflag as Integer) as IntPTR
End Function

' SRC\pixconv.c (2567, 1)
' pixConvert4To8()
' pixConvert4To8(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   ~ If cmapflag is TRUE:
'''  * ~ pixd is made with a colormap.
'''  * ~ If pixs has a colormap, it is copied and the colormap
'''  *   index values are placed in pixd.
'''  * ~ If pixs does not have a colormap, a colormap with linear
'''  *   trc is built and the pixel values in pixs are placed in
'''  *   pixd as colormap index values.
'''  *   ~ If cmapflag is FALSE:
'''  * ~ pixd is made without a colormap.
'''  * ~ If pixs has a colormap, it is removed and the values stored
'''  *   in pixd are from the colormap (converted to gray).
'''  * ~ If pixs does not have a colormap, the pixel values in pixs
'''  *   are used, with shift replication, to populate pixd.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs      4 bpp</param>
''' <param name="cmapflag"> \param[in]    cmapflag  TRUE if pixd is to have a colormap; FALSE otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert4To8")> _
Friend Shared Function pixConvert4To8(pixs as IntPTR, cmapflag as Integer) as IntPTR
End Function

' SRC\pixconv.c (2652, 1)
' pixConvert8To16()
' pixConvert8To16(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For left shift of 8, the 8 bit value is replicated in both
'''  * the MSB and the LSB of the pixels in pixd.  That way, we get
'''  * proportional mapping, with a correct map from 8 bpp white
'''  * (0xff) to 16 bpp white (0xffff).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 16 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs       8 bpp; colormap removed to gray</param>
''' <param name="leftshift"> \param[in]    leftshift  number of bits: 0 is no shift;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert8To16")> _
Friend Shared Function pixConvert8To16(pixs as IntPTR, leftshift as Integer) as IntPTR
End Function

' SRC\pixconv.c (2718, 1)
' pixConvertTo2()
' pixConvertTo2(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a top-level function, with simple default values
'''  * used in pixConvertTo8() if unpacking is necessary.
'''  *   (2) Any existing colormap is removed; the result is always gray.
'''  *   (3) If the input image has 2 bpp and no colormap, the operation is
'''  * lossless and a copy is returned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd   2 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   1, 2, 4, 8, 32 bpp; colormap OK but will be removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertTo2")> _
Friend Shared Function pixConvertTo2(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (2770, 1)
' pixConvert8To2()
' pixConvert8To2(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Any existing colormap is removed to gray.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd  2 bpp, or NULL on error</returns>
''' <param name="pix"> \param[in]     pix     8 bpp; colormap OK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert8To2")> _
Friend Shared Function pixConvert8To2(pix as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (2826, 1)
' pixConvertTo4()
' pixConvertTo4(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a top-level function, with simple default values
'''  * used in pixConvertTo8() if unpacking is necessary.
'''  *   (2) Any existing colormap is removed; the result is always gray.
'''  *   (3) If the input image has 4 bpp and no colormap, the operation is
'''  * lossless and a copy is returned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd   4 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   1, 2, 4, 8, 32 bpp; colormap OK but will be removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertTo4")> _
Friend Shared Function pixConvertTo4(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (2878, 1)
' pixConvert8To4()
' pixConvert8To4(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Any existing colormap is removed to gray.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd  4 bpp, or NULL on error</returns>
''' <param name="pix"> \param[in]     pix     8 bpp; colormap OK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert8To4")> _
Friend Shared Function pixConvert8To4(pix as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (2933, 1)
' pixConvertTo1()
' pixConvertTo1(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a top-level function, with simple default values
'''  * used in pixConvertTo8() if unpacking is necessary.
'''  *   (2) Any existing colormap is removed.
'''  *   (3) If the input image has 1 bpp and no colormap, the operation is
'''  * lossless and a copy is returned.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs       1, 2, 4, 8, 16 or 32 bpp</param>
''' <param name="threshold"> \param[in]    threshold  for final binarization, relative to 8 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertTo1")> _
Friend Shared Function pixConvertTo1(pixs as IntPTR, threshold as Integer) as IntPTR
End Function

' SRC\pixconv.c (2989, 1)
' pixConvertTo1BySampling()
' pixConvertTo1BySampling(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a quick and dirty, top-level converter.
'''  *   (2) See pixConvertTo1() for default values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs       1, 2, 4, 8, 16 or 32 bpp</param>
''' <param name="factor"> \param[in]    factor     submsampling factor; integer >= 1</param>
''' <param name="threshold"> \param[in]    threshold  for final binarization, relative to 8 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertTo1BySampling")> _
Friend Shared Function pixConvertTo1BySampling(pixs as IntPTR, factor as Integer, threshold as Integer) as IntPTR
End Function

' SRC\pixconv.c (3041, 1)
' pixConvertTo8()
' pixConvertTo8(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a top-level function, with simple default values
'''  * for unpacking.
'''  *   (2) The result, pixd, is made with a colormap if specified.
'''  * It is always a new image -- never a clone.  For example,
'''  * if d == 8, and cmapflag matches the existence of a cmap
'''  * in pixs, the operation is lossless and it returns a copy.
'''  *   (3) The default values used are:
'''  * ~ 1 bpp: val0 = 255, val1 = 0
'''  * ~ 2 bpp: 4 bpp:  even increments over dynamic range
'''  * ~ 8 bpp: lossless if cmap matches cmapflag
'''  * ~ 16 bpp: use most significant byte
'''  *   (4) If 32 bpp RGB, this is converted to gray.  If you want
'''  * to do color quantization, you must specify the type
'''  * explicitly, using the color quantization code.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs      1, 2, 4, 8, 16 or 32 bpp</param>
''' <param name="cmapflag"> \param[in]    cmapflag  TRUE if pixd is to have a colormap; FALSE otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertTo8")> _
Friend Shared Function pixConvertTo8(pixs as IntPTR, cmapflag as Integer) as IntPTR
End Function

' SRC\pixconv.c (3105, 1)
' pixConvertTo8BySampling()
' pixConvertTo8BySampling(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a fast, quick/dirty, top-level converter.
'''  *   (2) See pixConvertTo8() for default values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs      1, 2, 4, 8, 16 or 32 bpp</param>
''' <param name="factor"> \param[in]    factor    submsampling factor; integer >= 1</param>
''' <param name="cmapflag"> \param[in]    cmapflag  TRUE if pixd is to have a colormap; FALSE otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertTo8BySampling")> _
Friend Shared Function pixConvertTo8BySampling(pixs as IntPTR, factor as Integer, cmapflag as Integer) as IntPTR
End Function

' SRC\pixconv.c (3149, 1)
' pixConvertTo8Colormap()
' pixConvertTo8Colormap(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a top-level function, with simple default values
'''  * for unpacking.
'''  *   (2) The result, pixd, is always made with a colormap.
'''  *   (3) If d == 8, the operation is lossless and it returns a copy.
'''  *   (4) The default values used for increasing depth are:
'''  * ~ 1 bpp: val0 = 255, val1 = 0
'''  * ~ 2 bpp: 4 bpp:  even increments over dynamic range
'''  *   (5) For 16 bpp, use the most significant byte.
'''  *   (6) For 32 bpp RGB, use octcube quantization with optional dithering.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, cmapped, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    1, 2, 4, 8, 16 or 32 bpp</param>
''' <param name="dither"> \param[in]    dither  1 to dither if necessary; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertTo8Colormap")> _
Friend Shared Function pixConvertTo8Colormap(pixs as IntPTR, dither as Integer) as IntPTR
End Function

' SRC\pixconv.c (3184, 1)
' pixConvertTo16()
' pixConvertTo16(PIX *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 16 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    1, 8 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertTo16")> _
Friend Shared Function pixConvertTo16(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (3233, 1)
' pixConvertTo32()
' pixConvertTo32(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Never returns a clone of pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    1, 2, 4, 8, 16 or 32 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertTo32")> _
Friend Shared Function pixConvertTo32(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (3288, 1)
' pixConvertTo32BySampling()
' pixConvertTo32BySampling(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a fast, quick/dirty, top-level converter.
'''  *   (2) See pixConvertTo32() for default values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    1, 2, 4, 8, 16 or 32 bpp</param>
''' <param name="factor"> \param[in]    factor  submsampling factor; integer >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertTo32BySampling")> _
Friend Shared Function pixConvertTo32BySampling(pixs as IntPTR, factor as Integer) as IntPTR
End Function

' SRC\pixconv.c (3323, 1)
' pixConvert8To32()
' pixConvert8To32(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If there is no colormap, replicates the gray value
'''  * into the 3 MSB of the dest pixel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  32 bpp rgb pix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    8 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert8To32")> _
Friend Shared Function pixConvert8To32(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (3393, 1)
' pixConvertTo8Or32()
' pixConvertTo8Or32(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If there is a colormap, the colormap is removed to 8 or 32 bpp,
'''  * depending on whether the colors in the colormap are all gray.
'''  *   (2) If the input is either rgb or 8 bpp without a colormap,
'''  * this returns either a clone or a copy, depending on %copyflag.
'''  *   (3) Otherwise, the pix is converted to 8 bpp grayscale.
'''  * In all cases, pixd does not have a colormap.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp grayscale or 32 bpp rgb, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs      1, 2, 4, 8, 16, with or without colormap;</param>
''' <param name="copyflag"> \param[in]    copyflag  L_CLONE or L_COPY</param>
''' <param name="warnflag"> \param[in]    warnflag  1 to issue warning if colormap is removed; else 0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertTo8Or32")> _
Friend Shared Function pixConvertTo8Or32(pixs as IntPTR, copyflag as Integer, warnflag as Integer) as IntPTR
End Function

' SRC\pixconv.c (3456, 1)
' pixConvert24To32()
' pixConvert24To32(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) 24 bpp rgb pix are not supported in leptonica, except for a small
'''  * number of formatted write operations.  The data is a byte array,
'''  * with pixels in order r,g,b, and padded to 32 bit boundaries
'''  * in each line.
'''  *   (2) Because 24 bpp rgb pix are conveniently generated by programs
'''  * such as xpdf (which has SplashBitmaps that store the raster
'''  * data in consecutive 24-bit rgb pixels), it is useful to provide
'''  * 24 bpp pix that simply incorporate that data.  The only things
'''  * we can do with these are:
'''  *   (a) write them to file in png, jpeg, tiff and pnm
'''  *   (b) interconvert between 24 and 32 bpp in memory (for testing).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp rgb, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    24 bpp rgb</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert24To32")> _
Friend Shared Function pixConvert24To32(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (3506, 1)
' pixConvert32To24()
' pixConvert32To24(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixconvert24To32().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 24 bpp rgb, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    32 bpp rgb</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert32To24")> _
Friend Shared Function pixConvert32To24(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (3559, 1)
' pixConvert32To16()
' pixConvert32To16(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The data in pixs is typically used for labelling.
'''  * It is an array of l_uint32 values, not rgb or rgba.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 16 bpp , or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   32 bpp, single component</param>
''' <param name="type"> \param[in]    type   L_LS_TWO_BYTES, L_MS_TWO_BYTES, L_CLIP_TO_FFFF</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert32To16")> _
Friend Shared Function pixConvert32To16(pixs as IntPTR, type as Integer) as IntPTR
End Function

' SRC\pixconv.c (3623, 1)
' pixConvert32To8()
' pixConvert32To8(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    32 bpp, single component</param>
''' <param name="type16"> \param[in]    type16  L_LS_TWO_BYTES, L_MS_TWO_BYTES, L_CLIP_TO_FFFF</param>
''' <param name="type8"> \param[in]    type8   L_LS_BYTE, L_MS_BYTE, L_CLIP_TO_FF</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvert32To8")> _
Friend Shared Function pixConvert32To8(pixs as IntPTR, type16 as Integer, type8 as Integer) as IntPTR
End Function

' SRC\pixconv.c (3662, 1)
' pixRemoveAlpha()
' pixRemoveAlpha(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a wrapper on pixAlphaBlendUniform()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd        if 32 bpp rgba, pixs blended over a white background;</returns>
''' <param name="pixs"> \param[in]    pixs   any depth</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRemoveAlpha")> _
Friend Shared Function pixRemoveAlpha(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (3699, 1)
' pixAddAlphaTo1bpp()
' pixAddAlphaTo1bpp(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) We don't use 1 bpp colormapped images with alpha in leptonica,
'''  * but we support generating them (here), writing to png, and reading
'''  * the png.  On reading, they are converted to 32 bpp RGBA.
'''  *   (2) The background (0) pixels in pixs become fully transparent, and the
'''  * foreground (1) pixels are fully opaque.  Thus, pixd is a 1 bpp
'''  * representation of a stencil, that can be used to paint over pixels
'''  * of a backing image that are masked by the foreground in pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp with colormap and non-opaque alpha,</returns>
''' <param name="pixd"> \param[in]    pixd    [optional] 1 bpp, can be null or equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs    1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddAlphaTo1bpp")> _
Friend Shared Function pixAddAlphaTo1bpp(pixd as IntPTR, pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (3741, 1)
' pixConvertLossless()
' pixConvertLossless(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a lossless unpacking (depth-increasing)
'''  * conversion.  If ds is the depth of pixs, then
'''  *  ~ if d  ds, returns NULL
'''  *  ~ if d == ds, returns a copy
'''  *  ~ if d > ds, does the unpacking conversion
'''  *   (2) If pixs has a colormap, this is an error.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 2, 4 or 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    1, 2, 4, 8 bpp, not cmapped</param>
''' <param name="d"> \param[in]    d       destination depth: 2, 4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertLossless")> _
Friend Shared Function pixConvertLossless(pixs as IntPTR, d as Integer) as IntPTR
End Function

' SRC\pixconv.c (3832, 1)
' pixConvertForPSWrap()
' pixConvertForPSWrap(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For wrapping in PostScript, we convert pixs to
'''  * 1 bpp, 8 bpp (gray) and 32 bpp (RGB color).
'''  *   (2) Colormaps are removed.  For pixs with colormaps, the
'''  * images are converted to either 8 bpp gray or 32 bpp
'''  * RGB, depending on whether the colormap has color content.
'''  *   (3) Images without colormaps, that are not 1 bpp or 32 bpp,
'''  * are converted to 8 bpp gray.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd    1, 8, or 32 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    1, 2, 4, 8, 16, 32 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertForPSWrap")> _
Friend Shared Function pixConvertForPSWrap(pixs as IntPTR) as IntPTR
End Function

' SRC\pixconv.c (3911, 1)
' pixConvertToSubpixelRGB()
' pixConvertToSubpixelRGB(PIX *, l_float32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixs has a colormap, it is removed based on its contents
'''  * to either 8 bpp gray or rgb.
'''  *   (2) For horizontal subpixel splitting, the input image
'''  * is rescaled by %scaley vertically and by 3.0 times
'''  * %scalex horizontally.  Then each horizontal triplet
'''  * of pixels is mapped back to a single rgb pixel, with the
'''  * r, g and b values being assigned based on the pixel triplet.
'''  * For gray triplets, the r, g, and b values are set equal to
'''  * the three gray values.  For color triplets, the r, g and b
'''  * values are set equal to the components from the appropriate
'''  * subpixel.  Vertical subpixel splitting is handled similarly.
'''  *   (3) See pixConvertGrayToSubpixelRGB() and
'''  * pixConvertColorToSubpixelRGB() for further details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs            8 bpp grayscale, 32 bpp rgb, or colormapped</param>
''' <param name="scalex"> \param[in]    scalex, scaley  anisotropic scaling permitted between</param>
''' <param name="scaley"> \param[in]    order           of subpixel rgb color components in</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertToSubpixelRGB")> _
Friend Shared Function pixConvertToSubpixelRGB(pixs as IntPTR, scalex as single, scaley as single, order as Integer) as IntPTR
End Function

' SRC\pixconv.c (3981, 1)
' pixConvertGrayToSubpixelRGB()
' pixConvertGrayToSubpixelRGB(PIX *, l_float32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixs has a colormap, it is removed to 8 bpp.
'''  *   (2) For horizontal subpixel splitting, the input gray image
'''  * is rescaled by %scaley vertically and by 3.0 times
'''  * %scalex horizontally.  Then each horizontal triplet
'''  * of pixels is mapped back to a single rgb pixel, with the
'''  * r, g and b values being assigned from the triplet of gray values.
'''  * Similar operations are used for vertical subpixel splitting.
'''  *   (3) This is a form of subpixel rendering that tends to give the
'''  * resulting text a sharper and somewhat chromatic display.
'''  * For horizontal subpixel splitting, the observable difference
'''  * between %order=L_SUBPIXEL_ORDER_RGB and
'''  * %order=L_SUBPIXEL_ORDER_BGR is reduced by optical diffusers
'''  * in the display that make the pixel color appear to emerge
'''  * from the entire pixel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs            8 bpp or colormapped</param>
''' <param name="scalex"> \param[in]    scalex, scaley</param>
''' <param name="scaley"> \param[in]    order           of subpixel rgb color components in</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertGrayToSubpixelRGB")> _
Friend Shared Function pixConvertGrayToSubpixelRGB(pixs as IntPTR, scalex as single, scaley as single, order as Integer) as IntPTR
End Function

' SRC\pixconv.c (4086, 1)
' pixConvertColorToSubpixelRGB()
' pixConvertColorToSubpixelRGB(PIX *, l_float32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If pixs has a colormap, it is removed to 32 bpp rgb.
'''  * If the colormap has no color, pixConvertGrayToSubpixelRGB()
'''  * should be called instead, because it will give the same result
'''  * more efficiently.  The function pixConvertToSubpixelRGB()
'''  * will do the best thing for all cases.
'''  *   (2) For horizontal subpixel splitting, the input rgb image
'''  * is rescaled by %scaley vertically and by 3.0 times
'''  * %scalex horizontally.  Then for each horizontal triplet
'''  * of pixels, the r component of the final pixel is selected
'''  * from the r component of the appropriate pixel in the triplet,
'''  * and likewise for g and b.  Vertical subpixel splitting is
'''  * handled similarly.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs            32 bpp or colormapped</param>
''' <param name="scalex"> \param[in]    scalex, scaley</param>
''' <param name="scaley"> \param[in]    order           of subpixel rgb color components in</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConvertColorToSubpixelRGB")> _
Friend Shared Function pixConvertColorToSubpixelRGB(pixs as IntPTR, scalex as single, scaley as single, order as Integer) as IntPTR
End Function

' SRC\pixconv.c (4189, 1)
' l_setNeutralBoostVal()
' l_setNeutralBoostVal(l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) This raises or lowers the selected min or max RGB component value,
'''  * depending on if that component is above or below this value.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="val"> \param[in]    val    between 1 and 255; typical value is 180</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_setNeutralBoostVal")> _
Friend Shared Function l_setNeutralBoostVal(val as Integer) as Boolean ' Org. Void
End Function

#End Region
#Region "SRC\pixlabel.c"
' SRC\pixlabel.c (114, 1)
' pixConnCompTransform()
' pixConnCompTransform(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pixd is 8, 16 or 32 bpp, and the pixel values label the
'''  * fg component, starting with 1.  Pixels in the bg are labelled 0.
'''  *   (2) If %depth = 0, the depth of pixd is 8 if the number of c.c.
'''  * is less than 254, 16 if the number of c.c is less than 0xfffe,
'''  * and 32 otherwise.
'''  *   (3) If %depth = 8, the assigned label for the n-th component is
'''  * 1 + n % 254.  We use mod 254 because 0 is uniquely assigned
'''  * to black: e.g., see pixcmapCreateRandom().  Likewise,
'''  * if %depth = 16, the assigned label uses mod(2^16 - 2), and
'''  * if %depth = 32, no mod is taken.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   pixd 8, 16 or 32 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]     pixs 1 bpp</param>
''' <param name="connect"> \param[in]     connect connectivity: 4 or 8</param>
''' <param name="depth"> \param[in]     depth of pixd: 8 or 16 bpp; use 0 for auto determination</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConnCompTransform")> _
Friend Shared Function pixConnCompTransform(pixs as IntPTR, connect as Integer, depth as Integer) as IntPTR
End Function

' SRC\pixlabel.c (194, 1)
' pixConnCompAreaTransform()
' pixConnCompAreaTransform(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The pixel values in pixd label the area of the fg component
'''  * to which the pixel belongs.  Pixels in the bg are labelled 0.
'''  *   (2) For purposes of visualization, the output can be converted
'''  * to 8 bpp, using pixConvert32To8() or pixMaxDynamicRange().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   pixd 32 bpp, 1 spp, or NULL on error</returns>
''' <param name="pixs"> \param[in]     pixs 1 bpp</param>
''' <param name="connect"> \param[in]     connect connectivity: 4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConnCompAreaTransform")> _
Friend Shared Function pixConnCompAreaTransform(pixs as IntPTR, connect as Integer) as IntPTR
End Function

' SRC\pixlabel.c (267, 1)
' pixConnCompIncrInit()
' pixConnCompIncrInit(PIX *, l_int32, PIX **, PTAA **, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This labels the connected components in a 1 bpp pix, and
'''  * additionally sets up a ptaa that lists the locations of pixels
'''  * in each of the components.
'''  *   (2) It can be used to initialize the output image and arrays for
'''  * an application that maintains information about connected
'''  * components incrementally as pixels are added.
'''  *   (3) pixs can be empty or have some foreground pixels.
'''  *   (4) The connectivity is stored in pixd->special.
'''  *   (5) Always initialize with the first pta in ptaa being empty
'''  * and representing the background value (index 0) in the pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]     pixs 1 bpp</param>
''' <param name="conn"> \param[in]     conn connectivity: 4 or 8</param>
''' <param name="ppixd"> \param[out]    ppixd 32 bpp, with c.c. labelled</param>
''' <param name="pptaa"> \param[out]    pptaa with pixel locations indexed by c.c.</param>
''' <param name="pncc"> \param[out]    pncc initial number of c.c.</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConnCompIncrInit")> _
Friend Shared Function pixConnCompIncrInit(pixs as IntPTR, conn as Integer, ppixd as Object, pptaa as Object, pncc as Integer) as Integer
End Function

' SRC\pixlabel.c (351, 1)
' pixConnCompIncrAdd()
' pixConnCompIncrAdd(PIX *, PTAA *, l_int32 *, l_float32, l_float32, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This adds a pixel and updates the labeled connected components.
'''  * Before calling this function, initialize the process using
'''  * pixConnCompIncrInit().
'''  *   (2) As a result of adding a pixel, one of the following can happen,
'''  * depending on the number of neighbors with non-zero value:
'''  * (a) nothing: the pixel is already a member of a c.c.
'''  * (b) no neighbors: a new component is added, increasing the
'''  *  number of c.c.
'''  * (c) one neighbor: the pixel is added to an existing c.c.
'''  * (d) more than one neighbor: the added pixel causes joining of
'''  *  two or more c.c., reducing the number of c.c.  A maximum
'''  *  of 4 c.c. can be joined.
'''  *   (3) When two c.c. are joined, the pixels in the larger index are
'''  * relabeled to those of the smaller in pixs, and their locations
'''  * are transferred to the pta with the smaller index in the ptaa.
'''  * The pta corresponding to the larger index is then deleted.
'''  *   (4) This is an efficient implementation of a "union-find" operation,
'''  * which supports the generation and merging of disjoint sets
'''  * of pixels.  This function can be called about 1.3 million times
'''  * per second.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   -1 if nothing happens; 0 if a pixel is added; 1 on error</returns>
''' <param name="pixs"> \param[in]     pixs 32 bpp, with pixels labeled by c.c.</param>
''' <param name="ptaa"> \param[in]     ptaa with each pta of pixel locations indexed by c.c.</param>
''' <param name="pncc"> \param[out]    pncc number of c.c</param>
''' <param name="x"> \param[in]     x,y location of added pixel</param>
''' <param name="y"> \param[in]     debug 0 for no output; otherwise output whenever</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixConnCompIncrAdd")> _
Friend Shared Function pixConnCompIncrAdd(pixs as IntPTR, ptaa as IntPTR, pncc as Integer, x as single, y as single, debug as Integer) as Integer
End Function

' SRC\pixlabel.c (481, 1)
' pixGetSortedNeighborValues()
' pixGetSortedNeighborValues(PIX *, l_int32, l_int32, l_int32, l_int32 **, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The returned %neigh array is the unique set of neighboring
'''  * pixel values, of size nvals, sorted from smallest to largest.
'''  * The value 0, which represents background pixels that do
'''  * not belong to any set of connected components, is discarded.
'''  *   (2) If there are no neighbors, this returns %neigh = NULL; otherwise,
'''  * the caller must free the array.
'''  *   (3) For either 4 or 8 connectivity, the maximum number of unique
'''  * neighbor values is 4.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]     pixs 8, 16 or 32 bpp, with pixels labeled by c.c.</param>
''' <param name="x"> \param[in]     x, y location of pixel</param>
''' <param name="y"> \param[in]     conn 4 or 8 connected neighbors</param>
''' <param name="conn"> \param[out]    pneigh array of integers, to be filled with</param>
''' <param name="pneigh"> \param[out]    pnvals the number of unique neighbor values found</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetSortedNeighborValues")> _
Friend Shared Function pixGetSortedNeighborValues(pixs as IntPTR, x as Integer, y as Integer, conn as Integer, pneigh as Object, pnvals as Integer) as Integer
End Function

' SRC\pixlabel.c (567, 1)
' pixLocToColorTransform()
' pixLocToColorTransform(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This generates an RGB image where each component value
'''  * is coded depending on the (x.y) location and the size
'''  * of the fg connected component that the pixel in pixs belongs to.
'''  * It is independent of the 4-fold orthogonal orientation, and
'''  * only weakly depends on translations and small angle rotations.
'''  * Background pixels are black.
'''  *   (2) Such encodings can be compared between two 1 bpp images
'''  * by performing this transform and calculating the
'''  * "earth-mover" distance on the resulting R,G,B histograms.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   pixd 32 bpp rgb, or NULL on error</returns>
''' <param name="pixs"> \param[in]     pixs 1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixLocToColorTransform")> _
Friend Shared Function pixLocToColorTransform(pixs as IntPTR) as IntPTR
End Function

#End Region
#Region "SRC\pixtiling.c"
' SRC\pixtiling.c (121, 1)
' pixTilingCreate()
' pixTilingCreate(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIXTILING *
''' <summary>
''' * Notes:
'''  *   (1) We put a clone of pixs in the PixTiling.
'''  *   (2) The input to pixTilingCreate() for horizontal tiling can be
'''  * either the number of tiles across the image or the approximate
'''  * width of the tiles.  If the latter, the actual width will be
'''  * determined by making all tiles but the last of equal width, and
'''  * making the last as close to the others as possible.  The same
'''  * consideration is applied independently to the vertical tiling.
'''  * To specify tile width, set nx = 0; to specify the number of
'''  * tiles horizontally across the image, set w = 0.
'''  *   (3) If pixs is to be tiled in one-dimensional strips, use ny = 1 for
'''  * vertical strips and nx = 1 for horizontal strips.
'''  *   (4) The overlap must not be larger than the width or height of
'''  * the leftmost or topmost tile(s).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixtiling, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  pix to be tiled; any depth; colormap OK</param>
''' <param name="nx"> \param[in]    nx    number of tiles across image</param>
''' <param name="ny"> \param[in]    ny    number of tiles down image</param>
''' <param name="w"> \param[in]    w     desired width of each tile</param>
''' <param name="h"> \param[in]    h     desired height of each tile</param>
''' <param name="xoverlap"> \param[in]    xoverlap overlap into neighboring tiles on each side</param>
''' <param name="yoverlap"> \param[in]    yoverlap overlap into neighboring tiles above and below</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTilingCreate")> _
Friend Shared Function pixTilingCreate(pixs as IntPTR, nx as Integer, ny as Integer, w as Integer, h as Integer, xoverlap as Integer, yoverlap as Integer) as IntPTR
End Function

' SRC\pixtiling.c (178, 1)
' pixTilingDestroy()
' pixTilingDestroy(PIXTILING **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="ppt"> \param[in,out]   ppt will be set to null before returning</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTilingDestroy")> _
Friend Shared Function pixTilingDestroy(ppt as Object) as Boolean ' Org. Void
End Function

' SRC\pixtiling.c (208, 1)
' pixTilingGetCount()
' pixTilingGetCount(PIXTILING *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pt"> \param[in]    pt pixtiling</param>
''' <param name="pnx"> \param[out]   pnx [optional] nx; can be null</param>
''' <param name="pny"> \param[out]   pny [optional] ny; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTilingGetCount")> _
Friend Shared Function pixTilingGetCount(pt as IntPTR, pnx as Integer, pny as Integer) as Integer
End Function

' SRC\pixtiling.c (231, 1)
' pixTilingGetSize()
' pixTilingGetSize(PIXTILING *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pt"> \param[in]    pt pixtiling</param>
''' <param name="pw"> \param[out]   pw [optional] tile width; can be null</param>
''' <param name="ph"> \param[out]   ph [optional] tile height; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTilingGetSize")> _
Friend Shared Function pixTilingGetSize(pt as IntPTR, pw as Integer, ph as Integer) as Integer
End Function

' SRC\pixtiling.c (255, 1)
' pixTilingGetTile()
' pixTilingGetTile(PIXTILING *, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd tile with appropriate boundary (overlap) pixels added,</returns>
''' <param name="pt"> \param[in]    pt pixtiling</param>
''' <param name="i"> \param[in]    i tile row index</param>
''' <param name="j"> \param[in]    j tile column index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTilingGetTile")> _
Friend Shared Function pixTilingGetTile(pt as IntPTR, i as Integer, j as Integer) as IntPTR
End Function

' SRC\pixtiling.c (368, 1)
' pixTilingNoStripOnPaint()
' pixTilingNoStripOnPaint(PIXTILING *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The default for paint is to strip out the overlap pixels
'''  * that are added by pixTilingGetTile().  However, some
'''  * operations will generate an image with these pixels
'''  * stripped off.  This tells the paint operation not
'''  * to strip the added boundary pixels when painting.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pt"> \param[in]    pt pixtiling</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTilingNoStripOnPaint")> _
Friend Shared Function pixTilingNoStripOnPaint(pt as IntPTR) as Integer
End Function

' SRC\pixtiling.c (390, 1)
' pixTilingPaintTile()
' pixTilingPaintTile(PIX *, l_int32, l_int32, PIX *, PIXTILING *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixd"> \param[in]    pixd dest: paint tile onto this, without overlap</param>
''' <param name="i"> \param[in]    i tile row index</param>
''' <param name="j"> \param[in]    j tile column index</param>
''' <param name="pixs"> \param[in]    pixs source: tile to be painted from</param>
''' <param name="pt"> \param[in]    pt pixtiling struct</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTilingPaintTile")> _
Friend Shared Function pixTilingPaintTile(pixd as IntPTR, i as Integer, j as Integer, pixs as IntPTR, pt as IntPTR) as Integer
End Function

#End Region
#Region "SRC\pngio.c"
' SRC\pngio.c (185, 1)
' pixReadStreamPng()
' pixReadStreamPng(FILE *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If called from pixReadStream(), the stream is positioned
'''  * at the beginning of the file.
'''  *   (2) To do sequential reads of png format images from a stream,
'''  * use pixReadStreamPng()
'''  *   (3) Any image with alpha is converted to RGBA (spp = 4, with
'''  * equal red, green and blue channels) on reading.
'''  * There are three important cases with alpha:
'''  * (a) grayscale-with-alpha (spp = 2), where bpp = 8, and each
'''  *  pixel has an associated alpha (transparency) value
'''  *  in the second component of the image data.
'''  * (b) spp = 1, d = 1 with colormap and alpha in the trans array.
'''  *  Transparency is usually associated with the white background.
'''  * (c) spp = 1, d = 8 with colormap and alpha in the trans array.
'''  *  Each color in the colormap has a separate transparency value.
'''  *   (4) We use the high level png interface, where the transforms are set
'''  * up in advance and the header and image are read with a single
'''  * call.  The more complicated interface, where the header is
'''  * read first and the buffers for the raster image are user-
'''  * allocated before reading the image, works for single images,
'''  * but I could not get it to work properly for the successive
'''  * png reads that are required by pixaReadStream().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadStreamPng")> _
Friend Shared Function pixReadStreamPng(fp as Object) as IntPTR
End Function

' SRC\pngio.c (517, 1)
' readHeaderPng()
' readHeaderPng(const char *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If there is a colormap, iscmap is returned as 1; else 0.
'''  *   (2) For gray+alpha, although the png records bps = 16, we
'''  * consider this as two 8 bpp samples (gray and alpha).
'''  * When a gray+alpha is read, it is converted to 32 bpp RGBA.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pw"> \param[out]   pw      [optional]</param>
''' <param name="ph"> \param[out]   ph      [optional]</param>
''' <param name="pbps"> \param[out]   pbps    [optional]  bits/sample</param>
''' <param name="pspp"> \param[out]   pspp    [optional]  samples/pixel</param>
''' <param name="piscmap"> \param[out]   piscmap [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readHeaderPng")> _
Friend Shared Function readHeaderPng(filename as String, pw as Integer, ph as Integer, pbps as Integer, pspp as Integer, piscmap as Integer) as Integer
End Function

' SRC\pngio.c (561, 1)
' freadHeaderPng()
' freadHeaderPng(FILE *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See readHeaderPng().  We only need the first 40 bytes in the file.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp       file stream</param>
''' <param name="pw"> \param[out]   pw       [optional]</param>
''' <param name="ph"> \param[out]   ph       [optional]</param>
''' <param name="pbps"> \param[out]   pbps     [optional]  bits/sample</param>
''' <param name="pspp"> \param[out]   pspp     [optional]  samples/pixel</param>
''' <param name="piscmap"> \param[out]   piscmap  [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="freadHeaderPng")> _
Friend Shared Function freadHeaderPng(fp as Object, pw as Integer, ph as Integer, pbps as Integer, pspp as Integer, piscmap as Integer) as Integer
End Function

' SRC\pngio.c (618, 1)
' readHeaderMemPng()
' readHeaderMemPng(const l_uint8 *, size_t, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See readHeaderPng().
'''  *   (2) png colortypes (see png.h: PNG_COLOR_TYPE_*):
'''  * 0:  gray; fully transparent (with tRNS) (1 spp)
'''  * 2:  RGB (3 spp)
'''  * 3:  colormap; colormap+alpha (with tRNS) (1 spp)
'''  * 4:  gray + alpha (2 spp)
'''  * 6:  RGBA (4 spp)
'''  * Note:
'''  *   0 and 3 have the alpha information in a tRNS chunk
'''  *   4 and 6 have separate alpha samples with each pixel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="data"> \param[in]    data</param>
''' <param name="size"> \param[in]    size    40 bytes is sufficient</param>
''' <param name="pw"> \param[out]   pw      [optional]</param>
''' <param name="ph"> \param[out]   ph      [optional]</param>
''' <param name="pbps"> \param[out]   pbps    [optional]  bits/sample</param>
''' <param name="pspp"> \param[out]   pspp    [optional]  samples/pixel</param>
''' <param name="piscmap"> \param[out]   piscmap [optional]  input NULL to ignore</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readHeaderMemPng")> _
Friend Shared Function readHeaderMemPng(data as Byte, size as ULong, pw as Integer, ph as Integer, pbps as Integer, pspp as Integer, piscmap as Integer) as Integer
End Function

' SRC\pngio.c (704, 1)
' 
' fgetPngResolution(FILE *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fgetPngResolution")> _
Friend Shared Function fgetPngResolution(fp as Object, pxres as Integer, pyres as Integer) as Integer
End Function

' SRC\pngio.c (761, 1)
' isPngInterlaced()
' isPngInterlaced(const char *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pinterlaced"> \param[out]   pinterlaced 1 if interlaced png; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="isPngInterlaced")> _
Friend Shared Function isPngInterlaced(filename as String, pinterlaced as Integer) as Integer
End Function

' SRC\pngio.c (805, 1)
' 
' fgetPngColormapInfo(FILE *, PIXCMAP **, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fgetPngColormapInfo")> _
Friend Shared Function fgetPngColormapInfo(fp as Object, pcmap as Object, ptransparency as Integer) as Integer
End Function

' SRC\pngio.c (906, 1)
' pixWritePng()
' pixWritePng(const char *, PIX *, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Special version for writing png with a specified gamma.
'''  * When using pixWrite(), no field is given for gamma.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="gamma"> \param[in]    gamma</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWritePng")> _
Friend Shared Function pixWritePng(filename as String, pix as IntPTR, gamma as single) as Integer
End Function

' SRC\pngio.c (1006, 1)
' pixWriteStreamPng()
' pixWriteStreamPng(FILE *, PIX *, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If called from pixWriteStream(), the stream is positioned
'''  * at the beginning of the file.
'''  *   (2) To do sequential writes of png format images to a stream,
'''  * use pixWriteStreamPng() directly.
'''  *   (3) gamma is an optional png chunk.  If no gamma value is to be
'''  * placed into the file, use gamma = 0.0.  Otherwise, if
'''  * gamma > 0.0, its value is written into the header.
'''  *   (4) The use of gamma in png is highly problematic.  For an illuminating
'''  * discussion, see:  http://hsivonen.iki.fi/png-gamma/
'''  *   (5) What is the effect/meaning of gamma in the png file?  This
'''  * gamma, which we can call the 'source' gamma, is the
'''  * inverse of the gamma that was used in enhance.c to brighten
'''  * or darken images.  The 'source' gamma is supposed to indicate
'''  * the intensity mapping that was done at the time the
'''  * image was captured.  Display programs typically apply a
'''  * 'display' gamma of 2.2 to the output, which is intended
'''  * to linearize the intensity based on the response of
'''  * thermionic tubes (CRTs).  Flat panel LCDs have typically
'''  * been designed to give a similar response as CRTs (call it
'''  * "backward compatibility").  The 'display' gamma is
'''  * in some sense the inverse of the 'source' gamma.
'''  * jpeg encoders attached to scanners and cameras will lighten
'''  * the pixels, applying a gamma corresponding to approximately
'''  * a square-root relation of output vs input:
'''  * output = input^(gamma)
'''  * where gamma is often set near 0.4545  (1/gamma is 2.2).
'''  * This is stored in the image file.  Then if the display
'''  * program reads the gamma, it will apply a display gamma,
'''  * typically about 2.2; the product is 1.0, and the
'''  * display program produces a linear output.  This works because
'''  * the dark colors were appropriately boosted by the scanner,
'''  * as described by the 'source' gamma, so they should not
'''  * be further boosted by the display program.
'''  *   (6) As an example, with xv and display, if no gamma is stored,
'''  * the program acts as if gamma were 0.4545, multiplies this by 2.2,
'''  * and does a linear rendering.  Taking this as a baseline
'''  * brightness, if the stored gamma is:
'''  *  > 0.4545, the image is rendered lighter than baseline
'''  *   0.4545, the image is rendered darker than baseline
'''  * In contrast, gqview seems to ignore the gamma chunk in png.
'''  *   (7) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16
'''  * and 32.  However, it is possible, and in some cases desirable,
'''  * to write out a png file using an rgb pix that has 24 bpp.
'''  * For example, the open source xpdf SplashBitmap class generates
'''  * 24 bpp rgb images.  Consequently, we enable writing 24 bpp pix.
'''  * To generate such a pix, you can make a 24 bpp pix without data
'''  * and assign the data array to the pix; e.g.,
'''  *  pix = pixCreateHeader(w, h, 24);
'''  *  pixSetData(pix, rgbdata);
'''  * See pixConvert32To24() for an example, where we get rgbdata
'''  * from the 32 bpp pix.  Caution: do not call pixSetPadBits(),
'''  * because the alignment is wrong and you may erase part of the
'''  * last pixel on each line.
'''  *   (8) If the pix has a colormap, it is written to file.  In most
'''  * situations, the alpha component is 255 for each colormap entry,
'''  * which is opaque and indicates that it should be ignored.
'''  * However, if any alpha component is not 255, it is assumed that
'''  * the alpha values are valid, and they are written to the png
'''  * file in a tRNS segment.  On readback, the tRNS segment is
'''  * identified, and the colormapped image with alpha is converted
'''  * to a 4 spp rgba image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="gamma"> \param[in]    gamma use 0.0 if gamma is not defined</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamPng")> _
Friend Shared Function pixWriteStreamPng(fp as Object, pix as IntPTR, gamma as single) as Integer
End Function

' SRC\pngio.c (1250, 1)
' pixSetZlibCompression()
' pixSetZlibCompression(PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Valid zlib compression values are in the interval [0 ... 9],
'''  * where, as defined in zlib.h:
'''  *   0   Z_NO_COMPRESSION
'''  *   1   Z_BEST_SPEED (poorest compression)
'''  *   9   Z_BEST_COMPRESSION
'''  * For the default value, use either of these:
'''  *   6   Z_DEFAULT_COMPRESSION
'''  *  -1   (resolves to Z_DEFAULT_COMPRESSION)
'''  *   (2) If you use the defined constants in zlib.h instead of the
'''  * compression integers given above, you must include zlib.h.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="compval"> \param[in]    compval zlib compression value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetZlibCompression")> _
Friend Shared Function pixSetZlibCompression(pix as IntPTR, compval as Integer) as Integer
End Function

' SRC\pngio.c (1277, 1)
' l_pngSetReadStrip16To8()
' l_pngSetReadStrip16To8(l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="flag"> \param[in]    flag 1 for stripping 16 bpp to 8 bpp on reading;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_pngSetReadStrip16To8")> _
Friend Shared Function l_pngSetReadStrip16To8(flag as Integer) as Boolean ' Org. Void
End Function

' SRC\pngio.c (1306, 13)
' 
' memio_png_write_data(int, int, int) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="memio_png_write_data")> _
Friend Shared Function memio_png_write_data(png_ptr as Object, data as Object, length as Object) as Boolean ' Org. Void
End Function

' SRC\pngio.c (1308, 13)
' 
' memio_png_flush(MEMIODATA *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="memio_png_flush")> _
Friend Shared Function memio_png_flush(pthing as IntPTR) as Boolean ' Org. Void
End Function

' SRC\pngio.c (1309, 13)
' 
' memio_png_read_data(int, int, int) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="memio_png_read_data")> _
Friend Shared Function memio_png_read_data(png_ptr as Object, outBytes as Object, byteCountToRead as Object) as Boolean ' Org. Void
End Function

' SRC\pngio.c (1311, 13)
' 
' memio_free(MEMIODATA *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="memio_free")> _
Friend Shared Function memio_free(pthing as IntPTR) as Boolean ' Org. Void
End Function

' SRC\pngio.c (1520, 1)
' pixReadMemPng()
' pixReadMemPng(const l_uint8 *, size_t) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixReastreamPng().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="filedata"> \param[in]    filedata   png compressed data in memory</param>
''' <param name="filesize"> \param[in]    filesize   number of bytes in data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadMemPng")> _
Friend Shared Function pixReadMemPng(filedata as Byte, filesize as ULong) as IntPTR
End Function

' SRC\pngio.c (1858, 1)
' pixWriteMemPng()
' pixWriteMemPng(l_uint8 **, size_t *, PIX *, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See pixWriteStreamPng()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pfiledata"> \param[out]   pfiledata     png encoded data of pix</param>
''' <param name="pfilesize"> \param[out]   pfilesize     size of png encoded data</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="gamma"> \param[in]    gamma         use 0.0 if gamma is not defined</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMemPng")> _
Friend Shared Function pixWriteMemPng(pfiledata as Object, pfilesize as ULong, pix as IntPTR, gamma as single) as Integer
End Function

#End Region
#Region "SRC\pnmio.c"
' SRC\pnmio.c (125, 16)
' pnmReadNextAsciiValue()
' pnmReadNextAsciiValue(FILE *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pnmReadNextAsciiValue")> _
Friend Shared Function pnmReadNextAsciiValue(fp as Object, pval as Integer) as Integer
End Function

' SRC\pnmio.c (126, 16)
' pnmReadNextNumber()
' pnmReadNextNumber(FILE *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This reads the next set of numeric chars, returning
'''  * the value and swallowing the trailing whitespace character.
'''  * This is needed to read the maxval in the header, which
'''  * precedes the binary data.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or EOF.</returns>
''' <param name="fp"> \param[in]    fp    file stream</param>
''' <param name="pval"> \param[out]   pval  value as an integer</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pnmReadNextNumber")> _
Friend Shared Function pnmReadNextNumber(fp as Object, pval as Integer) as Integer
End Function

' SRC\pnmio.c (127, 16)
' pnmReadNextString()
' pnmReadNextString(FILE *, char *, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This reads the next set of alphanumeric chars,
'''  * returning the string and swallowing the trailing
'''  * whitespace characters.
'''  * This is needed to read header lines, which precede
'''  * the P7 format binary data.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or EOF.</returns>
''' <param name="fp"> \param[in]    fp    file stream</param>
''' <param name="buff"> \param[out]   buff  pointer to the string buffer</param>
''' <param name="size"> \param[in]    size  max. number of charactes in buffer</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pnmReadNextString")> _
Friend Shared Function pnmReadNextString(fp as Object, buff as Object, size as Integer) as Integer
End Function

' SRC\pnmio.c (128, 16)
' pnmSkipCommentLines()
' pnmSkipCommentLines(FILE *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pnmSkipCommentLines")> _
Friend Shared Function pnmSkipCommentLines(fp as Object) as Integer
End Function

' SRC\pnmio.c (145, 1)
' pixReadStreamPnm()
' pixReadStreamPnm(FILE *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp   file stream opened for read</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadStreamPnm")> _
Friend Shared Function pixReadStreamPnm(fp as Object) as IntPTR
End Function

' SRC\pnmio.c (447, 1)
' readHeaderPnm()
' readHeaderPnm(const char *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pw"> \param[out]   pw       [optional]</param>
''' <param name="ph"> \param[out]   ph       [optional]</param>
''' <param name="pd"> \param[out]   pd       [optional]</param>
''' <param name="ptype"> \param[out]   ptype    [optional] pnm type</param>
''' <param name="pbps"> \param[out]   pbps     [optional] bits/sample</param>
''' <param name="pspp"> \param[out]   pspp     [optional] samples/pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readHeaderPnm")> _
Friend Shared Function readHeaderPnm(filename as String, pw as Integer, ph as Integer, pd as Integer, ptype as Integer, pbps as Integer, pspp as Integer) as Integer
End Function

' SRC\pnmio.c (490, 1)
' freadHeaderPnm()
' freadHeaderPnm(FILE *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp     file stream opened for read</param>
''' <param name="pw"> \param[out]   pw     [optional]</param>
''' <param name="ph"> \param[out]   ph     [optional]</param>
''' <param name="pd"> \param[out]   pd     [optional]</param>
''' <param name="ptype"> \param[out]   ptype  [optional] pnm type</param>
''' <param name="pbps"> \param[out]   pbps   [optional]  bits/sample</param>
''' <param name="pspp"> \param[out]   pspp   [optional]  samples/pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="freadHeaderPnm")> _
Friend Shared Function freadHeaderPnm(fp as Object, pw as Integer, ph as Integer, pd as Integer, ptype as Integer, pbps as Integer, pspp as Integer) as Integer
End Function

' SRC\pnmio.c (667, 1)
' pixWriteStreamPnm()
' pixWriteStreamPnm(FILE *, PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This writes "raw" packed format only:
'''  * 1 bpp --> pbm (P4)
'''  * 2, 4, 8, 16 bpp, no colormap or grayscale colormap --> pgm (P5)
'''  * 2, 4, 8 bpp with color-valued colormap, or rgb --> rgb ppm (P6)
'''  *   (2) 24 bpp rgb are not supported in leptonica, but this will
'''  * write them out as a packed array of bytes (3 to a pixel).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]   fp    file stream opened for write</param>
''' <param name="pix"> \param[in]   pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamPnm")> _
Friend Shared Function pixWriteStreamPnm(fp as Object, pix as IntPTR) as Integer
End Function

' SRC\pnmio.c (786, 1)
' pixWriteStreamAsciiPnm()
' pixWriteStreamAsciiPnm(FILE *, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]   fp    file stream opened for write</param>
''' <param name="pix"> \param[in]   pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamAsciiPnm")> _
Friend Shared Function pixWriteStreamAsciiPnm(fp as Object, pix as IntPTR) as Integer
End Function

' SRC\pnmio.c (908, 1)
' pixWriteStreamPam()
' pixWriteStreamPam(FILE *, PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This writes arbitrary PAM (P7) packed format.
'''  *   (2) 24 bpp rgb are not supported in leptonica, but this will
'''  * write them out as a packed array of bytes (3 to a pixel).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]   fp    file stream opened for write</param>
''' <param name="pix"> \param[in]   pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamPam")> _
Friend Shared Function pixWriteStreamPam(fp as Object, pix as IntPTR) as Integer
End Function

' SRC\pnmio.c (1084, 1)
' pixReadMemPnm()
' pixReadMemPnm(const l_uint8 *, size_t) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The %size byte of %data must be a null character.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="data"> \param[in]   data   const; pnm-encoded</param>
''' <param name="size"> \param[in]   size   of data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadMemPnm")> _
Friend Shared Function pixReadMemPnm(data as Byte, size as ULong) as IntPTR
End Function

' SRC\pnmio.c (1117, 1)
' readHeaderMemPnm()
' readHeaderMemPnm(const l_uint8 *, size_t, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="data"> \param[in]    data    const; pnm-encoded</param>
''' <param name="size"> \param[in]    size    of data</param>
''' <param name="pw"> \param[out]   pw      [optional]</param>
''' <param name="ph"> \param[out]   ph      [optional]</param>
''' <param name="pd"> \param[out]   pd      [optional]</param>
''' <param name="ptype"> \param[out]   ptype   [optional] pnm type</param>
''' <param name="pbps"> \param[out]   pbps    [optional] bits/sample</param>
''' <param name="pspp"> \param[out]   pspp    [optional] samples/pixel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readHeaderMemPnm")> _
Friend Shared Function readHeaderMemPnm(data as Byte, size as ULong, pw as Integer, ph as Integer, pd as Integer, ptype as Integer, pbps as Integer, pspp as Integer) as Integer
End Function

' SRC\pnmio.c (1159, 1)
' pixWriteMemPnm()
' pixWriteMemPnm(l_uint8 **, size_t *, PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See pixWriteStreamPnm() for usage.  This version writes to
'''  * memory instead of to a file stream.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata   data of PNM image</param>
''' <param name="psize"> \param[out]   psize   size of returned data</param>
''' <param name="pix"> \param[in]    pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMemPnm")> _
Friend Shared Function pixWriteMemPnm(pdata as Object, psize as ULong, pix as IntPTR) as Integer
End Function

' SRC\pnmio.c (1214, 1)
' pixWriteMemPam()
' pixWriteMemPam(l_uint8 **, size_t *, PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See pixWriteStreamPnm() for usage.  This version writes to
'''  * memory instead of to a file stream.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata   data of PAM image</param>
''' <param name="psize"> \param[out]   psize   size of returned data</param>
''' <param name="pix"> \param[in]    pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMemPam")> _
Friend Shared Function pixWriteMemPam(pdata as Object, psize as ULong, pix as IntPTR) as Integer
End Function

#End Region
#Region "SRC\projective.c"
' SRC\projective.c (141, 1)
' pixProjectiveSampledPta()
' pixProjectiveSampledPta(PIX *, PTA *, PTA *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Brings in either black or white pixels from the boundary.
'''  *   (2) Retains colormap, which you can do for a sampled transform..
'''  *   (3) No 3 of the 4 points may be collinear.
'''  *   (4) For 8 and 32 bpp pix, better quality is obtained by the
'''  * somewhat slower pixProjectivePta().  See that
'''  * function for relative timings between sampled and interpolated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths</param>
''' <param name="ptad"> \param[in]    ptad  4 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  4 pts of initial coordinate space</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixProjectiveSampledPta")> _
Friend Shared Function pixProjectiveSampledPta(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, incolor as Integer) as IntPTR
End Function

' SRC\projective.c (191, 1)
' pixProjectiveSampled()
' pixProjectiveSampled(PIX *, l_float32 *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Brings in either black or white pixels from the boundary.
'''  *   (2) Retains colormap, which you can do for a sampled transform..
'''  *   (3) For 8 or 32 bpp, much better quality is obtained by the
'''  * somewhat slower pixProjective().  See that function
'''  * for relative timings between sampled and interpolated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths</param>
''' <param name="vc"> \param[in]    vc  vector of 8 coefficients for projective transformation</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixProjectiveSampled")> _
Friend Shared Function pixProjectiveSampled(pixs as IntPTR, vc as single, incolor as Integer) as IntPTR
End Function

' SRC\projective.c (284, 1)
' pixProjectivePta()
' pixProjectivePta(PIX *, PTA *, PTA *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Brings in either black or white pixels from the boundary
'''  *   (2) Removes any existing colormap, if necessary, before transforming
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths; colormap ok</param>
''' <param name="ptad"> \param[in]    ptad  4 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  4 pts of initial coordinate space</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixProjectivePta")> _
Friend Shared Function pixProjectivePta(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, incolor as Integer) as IntPTR
End Function

' SRC\projective.c (354, 1)
' pixProjective()
' pixProjective(PIX *, l_float32 *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Brings in either black or white pixels from the boundary
'''  *   (2) Removes any existing colormap, if necessary, before transforming
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths; colormap ok</param>
''' <param name="vc"> \param[in]    vc  vector of 8 coefficients for projective transformation</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixProjective")> _
Friend Shared Function pixProjective(pixs as IntPTR, vc as single, incolor as Integer) as IntPTR
End Function

' SRC\projective.c (410, 1)
' pixProjectivePtaColor()
' pixProjectivePtaColor(PIX *, PTA *, PTA *, l_uint32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="ptad"> \param[in]    ptad  4 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  4 pts of initial coordinate space</param>
''' <param name="colorval"> \param[in]    colorval e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixProjectivePtaColor")> _
Friend Shared Function pixProjectivePtaColor(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, colorval as UInteger) as IntPTR
End Function

' SRC\projective.c (451, 1)
' pixProjectiveColor()
' pixProjectiveColor(PIX *, l_float32 *, l_uint32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="vc"> \param[in]    vc  vector of 8 coefficients for projective transformation</param>
''' <param name="colorval"> \param[in]    colorval e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixProjectiveColor")> _
Friend Shared Function pixProjectiveColor(pixs as IntPTR, vc as single, colorval as UInteger) as IntPTR
End Function

' SRC\projective.c (513, 1)
' pixProjectivePtaGray()
' pixProjectivePtaGray(PIX *, PTA *, PTA *, l_uint8) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="ptad"> \param[in]    ptad  4 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  4 pts of initial coordinate space</param>
''' <param name="grayval"> \param[in]    grayval 0 to bring in BLACK, 255 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixProjectivePtaGray")> _
Friend Shared Function pixProjectivePtaGray(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, grayval as Byte) as IntPTR
End Function

' SRC\projective.c (555, 1)
' pixProjectiveGray()
' pixProjectiveGray(PIX *, l_float32 *, l_uint8) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="vc"> \param[in]    vc  vector of 8 coefficients for projective transformation</param>
''' <param name="grayval"> \param[in]    grayval 0 to bring in BLACK, 255 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixProjectiveGray")> _
Friend Shared Function pixProjectiveGray(pixs as IntPTR, vc as single, grayval as Byte) as IntPTR
End Function

' SRC\projective.c (644, 1)
' pixProjectivePtaWithAlpha()
' pixProjectivePtaWithAlpha(PIX *, PTA *, PTA *, PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The alpha channel is transformed separately from pixs,
'''  * and aligns with it, being fully transparent outside the
'''  * boundary of the transformed pixs.  For pixels that are fully
'''  * transparent, a blending function like pixBlendWithGrayMask()
'''  * will give zero weight to corresponding pixels in pixs.
'''  *   (2) If pixg is NULL, it is generated as an alpha layer that is
'''  * partially opaque, using %fract.  Otherwise, it is cropped
'''  * to pixs if required and %fract is ignored.  The alpha channel
'''  * in pixs is never used.
'''  *   (3) Colormaps are removed.
'''  *   (4) When pixs is transformed, it doesn't matter what color is brought
'''  * in because the alpha channel will be transparent (0) there.
'''  *   (5) To avoid losing source pixels in the destination, it may be
'''  * necessary to add a border to the source pix before doing
'''  * the projective transformation.  This can be any non-negative
'''  * number.
'''  *   (6) The input %ptad and %ptas are in a coordinate space before
'''  * the border is added.  Internally, we compensate for this
'''  * before doing the projective transform on the image after
'''  * the border is added.
'''  *   (7) The default setting for the border values in the alpha channel
'''  * is 0 (transparent) for the outermost ring of pixels and
'''  * (0.5 * fract * 255) for the second ring.  When blended over
'''  * a second image, this
'''  * (a) shrinks the visible image to make a clean overlap edge
'''  *  with an image below, and
'''  * (b) softens the edges by weakening the aliasing there.
'''  * Use l_setAlphaMaskBorder() to change these values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="ptad"> \param[in]    ptad  4 pts of final coordinate space</param>
''' <param name="ptas"> \param[in]    ptas  4 pts of initial coordinate space</param>
''' <param name="pixg"> \param[in]    pixg [optional] 8 bpp, for alpha channel, can be null</param>
''' <param name="fract"> \param[in]    fract between 0.0 and 1.0, with 0.0 fully transparent</param>
''' <param name="border"> \param[in]    border of pixels added to capture transformed source pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixProjectivePtaWithAlpha")> _
Friend Shared Function pixProjectivePtaWithAlpha(pixs as IntPTR, ptad as IntPTR, ptas as IntPTR, pixg as IntPTR, fract as single, border as Integer) as IntPTR
End Function

' SRC\projective.c (775, 1)
' getProjectiveXformCoeffs()
' getProjectiveXformCoeffs(PTA *, PTA *, l_float32 **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="ptas"> \param[in]    ptas  source 4 points; unprimed</param>
''' <param name="ptad"> \param[in]    ptad  transformed 4 points; primed</param>
''' <param name="pvc"> \param[out]   pvc   vector of coefficients of transform</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getProjectiveXformCoeffs")> _
Friend Shared Function getProjectiveXformCoeffs(ptas as IntPTR, ptad as IntPTR, pvc as Object) as Integer
End Function

' SRC\projective.c (876, 1)
' projectiveXformSampledPt()
' projectiveXformSampledPt(l_float32 *, l_int32, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds the nearest pixel coordinates of the transformed point.
'''  *   (2) It does not check ptrs for returned data!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="vc"> \param[in]    vc vector of 8 coefficients</param>
''' <param name="x"> \param[in]    x, y  initial point</param>
''' <param name="y"> \param[out]   pxp, pyp   transformed point</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="projectiveXformSampledPt")> _
Friend Shared Function projectiveXformSampledPt(vc as single, x as Integer, y as Integer, pxp as Integer, pyp as Integer) as Integer
End Function

' SRC\projective.c (911, 1)
' projectiveXformPt()
' projectiveXformPt(l_float32 *, l_int32, l_int32, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This computes the floating point location of the transformed point.
'''  *   (2) It does not check ptrs for returned data!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="vc"> \param[in]    vc vector of 8 coefficients</param>
''' <param name="x"> \param[in]    x, y  initial point</param>
''' <param name="y"> \param[out]   pxp, pyp   transformed point</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="projectiveXformPt")> _
Friend Shared Function projectiveXformPt(vc as single, x as Integer, y as Integer, pxp as single, pyp as single) as Integer
End Function

#End Region
#Region "SRC\psio1.c"
' SRC\psio1.c (154, 1)
' 
' convertFilesToPS(const char *, const char *, l_int32, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertFilesToPS")> _
Friend Shared Function convertFilesToPS(dirin as String, substr as String, res as Integer, fileout as String) as Integer
End Function

' SRC\psio1.c (201, 1)
' 
' sarrayConvertFilesToPS(SARRAY *, l_int32, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayConvertFilesToPS")> _
Friend Shared Function sarrayConvertFilesToPS(sa as IntPTR, res as Integer, fileout as String) as Integer
End Function

' SRC\psio1.c (269, 1)
' 
' convertFilesFittedToPS(const char *, const char *, l_float32, l_float32, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertFilesFittedToPS")> _
Friend Shared Function convertFilesFittedToPS(dirin as String, substr as String, xpts as single, ypts as single, fileout as String) as Integer
End Function

' SRC\psio1.c (321, 1)
' 
' sarrayConvertFilesFittedToPS(SARRAY *, l_float32, l_float32, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayConvertFilesFittedToPS")> _
Friend Shared Function sarrayConvertFilesFittedToPS(sa as IntPTR, xpts as single, ypts as single, fileout as String) as Integer
End Function

' SRC\psio1.c (391, 1)
' 
' writeImageCompressedToPSFile(const char *, const char *, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="writeImageCompressedToPSFile")> _
Friend Shared Function writeImageCompressedToPSFile(filein as String, fileout as String, res as Integer, pfirstfile as Integer, pindex as Integer) as Integer
End Function

' SRC\psio1.c (498, 1)
' 
' convertSegmentedPagesToPS(const char *, const char *, l_int32, const char *, const char *, l_int32, l_int32, l_int32, l_float32, l_float32, l_int32, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertSegmentedPagesToPS")> _
Friend Shared Function convertSegmentedPagesToPS(pagedir as String, pagestr as String, page_numpre as Integer, maskdir as String, maskstr as String, mask_numpre as Integer, numpost as Integer, maxnum as Integer, textscale as single, imagescale as single, threshold as Integer, fileout as String) as Integer
End Function

' SRC\psio1.c (596, 1)
' 
' pixWriteSegmentedPageToPS(PIX *, PIX *, l_float32, l_float32, l_int32, l_int32, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteSegmentedPageToPS")> _
Friend Shared Function pixWriteSegmentedPageToPS(pixs as IntPTR, pixm as IntPTR, textscale as single, imagescale as single, threshold as Integer, pageno as Integer, fileout as String) as Integer
End Function

' SRC\psio1.c (747, 1)
' 
' pixWriteMixedToPS(PIX *, PIX *, l_float32, l_int32, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMixedToPS")> _
Friend Shared Function pixWriteMixedToPS(pixb as IntPTR, pixc as IntPTR, scale as single, pageno as Integer, fileout as String) as Integer
End Function

' SRC\psio1.c (834, 1)
' 
' convertToPSEmbed(const char *, const char *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertToPSEmbed")> _
Friend Shared Function convertToPSEmbed(filein as String, fileout as String, level as Integer) as Integer
End Function

' SRC\psio1.c (935, 1)
' 
' pixaWriteCompressedToPS(PIXA *, const char *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaWriteCompressedToPS")> _
Friend Shared Function pixaWriteCompressedToPS(pixa as IntPTR, fileout as String, res as Integer, level as Integer) as Integer
End Function

#End Region
#Region "SRC\psio2.c"
' SRC\psio2.c (152, 1)
' pixWritePSEmbed()
' pixWritePSEmbed(const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a simple wrapper function that generates an
'''  * uncompressed PS file, with a bounding box.
'''  *   (2) The bounding box is required when a program such as TeX
'''  * (through epsf) places and rescales the image.
'''  *   (3) The bounding box is sized for fitting the image to an
'''  * 8.5 x 11.0 inch page.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein input file, all depths, colormap OK</param>
''' <param name="fileout"> \param[in]    fileout output ps file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWritePSEmbed")> _
Friend Shared Function pixWritePSEmbed(filein as String, fileout as String) as Integer
End Function

' SRC\psio2.c (205, 1)
' pixWriteStreamPS()
' pixWriteStreamPS(FILE *, PIX *, BOX *, l_int32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This writes image in PS format, optionally scaled,
'''  * adjusted for the printer resolution, and with
'''  * a bounding box.
'''  *   (2) For details on use of parameters, see pixWriteStringPS().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="box"> \param[in]    box  [optional]</param>
''' <param name="res"> \param[in]    res  can use 0 for default of 300 ppi</param>
''' <param name="scale"> \param[in]    scale to prevent scaling, use either 1.0 or 0.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamPS")> _
Friend Shared Function pixWriteStreamPS(fp as Object, pix as IntPTR, box as IntPTR, res as Integer, scale as single) as Integer
End Function

' SRC\psio2.c (303, 1)
' pixWriteStringPS()
' pixWriteStringPS(PIX *, BOX *, l_int32, l_float32) as char *
''' <summary>
''' * a) If %box == NULL, image is placed, optionally scaled,
'''  *   in a standard b.b. at the center of the page.
'''  *   This is to be used when another program like
'''  *   TeX through epsf places the image.
'''  * b) If %box != NULL, image is placed without a
'''  *   b.b. at the specified page location and with
'''  *   optional scaling.  This is to be used when
'''  *   you want to specify exactly where and optionally
'''  *   how big you want the image to be.
'''  *   Note that all coordinates are in PS convention,
'''  *   with 0,0 at LL corner of the page:
'''  * x,y location of LL corner of image, in mils.
'''  * w,h scaled size, in mils.  Use 0 to
'''  *  scale with "scale" and "res" input.
'''  *
'''  * %scale: If no scaling is desired, use either 1.0 or 0.0.
'''  * Scaling just resets the resolution parameter; the actual
'''  * scaling is done in the interpreter at rendering time.
'''  * This is important: * it allows you to scale the image up
'''  * without increasing the file size.
'''  *
'''  * Notes:
'''  *   (1) OK, this seems a bit complicated, because there are various
'''  * ways to scale and not to scale.  Here's a summary:
'''  *   (2) If you don't want any scaling at all:
'''  *  * if you are using a box:
'''  *   set w = 0, h = 0, and use scale = 1.0; it will print
'''  *   each pixel unscaled at printer resolution
'''  *  * if you are not using a box:
'''  *   set scale = 1.0; it will print at printer resolution
'''  *   (3) If you want the image to be a certain size in inches:
'''  *  * you must use a box and set the box (w,h) in mils
'''  *   (4) If you want the image to be scaled by a scale factor != 1.0:
'''  *  * if you are using a box:
'''  *   set w = 0, h = 0, and use the desired scale factor;
'''  *   the higher the printer resolution, the smaller the
'''  *   image will actually appear.
'''  *  * if you are not using a box:
'''  *   set the desired scale factor; the higher the printer
'''  *   resolution, the smaller the image will actually appear.
'''  *   (5) Another complication is the proliferation of distance units:
'''  *  * The interface distances are in milli-inches.
'''  *  * Three different units are used internally:
'''  *  ~ pixels  (units of 1/res inch)
'''  *  ~ printer pts (units of 1/72 inch)
'''  *  ~ inches
'''  *  * Here is a quiz on volume units from a reviewer:
'''  * How many UK milli-cups in a US kilo-teaspoon?
'''  *   (Hint: 1.0 US cup = 0.75 UK cup + 0.2 US gill;
'''  *    1.0 US gill = 24.0 US teaspoons)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ps string if OK, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   all depths, colormap OK</param>
''' <param name="box"> \param[in]    box    bounding box; can be NULL</param>
''' <param name="res"> \param[in]    res    resolution, in printer ppi.  Use 0 for default 300 ppi.</param>
''' <param name="scale"> \param[in]    scale  scale factor.  If no scaling is desired, use</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStringPS")> _
Friend Shared Function pixWriteStringPS(pixs as IntPTR, box as IntPTR, res as Integer, scale as single) as String
End Function

' SRC\psio2.c (413, 1)
' generateUncompressedPS()
' generateUncompressedPS(char *, l_int32, l_int32, l_int32, l_int32, l_int32, l_float32, l_float32, l_float32, l_float32, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) Low-level function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  PS string, or NULL on error</returns>
''' <param name="hexdata"> \param[in]    hexdata</param>
''' <param name="w"> \param[in]    w, h  raster image size in pixels</param>
''' <param name="h"> \param[in]    d image depth in bpp; rgb is 32</param>
''' <param name="d"> \param[in]    psbpl raster bytes/line, when packed to the byte boundary</param>
''' <param name="psbpl"> \param[in]    bps bits/sample: either 1 or 8</param>
''' <param name="bps"> \param[in]    xpt, ypt location of LL corner of image, in pts, relative</param>
''' <param name="xpt"> \param[in]    wpt, hpt rendered image size in pts</param>
''' <param name="ypt"> \param[in]    boxflag 1 to print out bounding box hint; 0 to skip</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generateUncompressedPS")> _
Friend Shared Function generateUncompressedPS(hexdata as Object, w as Integer, h as Integer, d as Integer, psbpl as Integer, bps as Integer, xpt as single, ypt as single, wpt as single, hpt as single, boxflag as Integer) as String
End Function

' SRC\psio2.c (522, 1)
' getScaledParametersPS()
' getScaledParametersPS(BOX *, l_int32, l_int32, l_int32, l_float32, l_float32 *, l_float32 *, l_float32 *, l_float32 *) as void
''' <summary>
''' * Notes:
'''  *   (1) The image is always scaled, depending on res and scale.
'''  *   (2) If no box, the image is centered on the page.
'''  *   (3) If there is a box, the image is placed within it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void no arg checking</returns>
''' <param name="box"> \param[in]    box [optional] location of image in mils; with</param>
''' <param name="wpix"> \param[in]    wpix pix width in pixels</param>
''' <param name="hpix"> \param[in]    hpix pix height in pixels</param>
''' <param name="res"> \param[in]    res of printer; use 0 for default</param>
''' <param name="scale"> \param[in]    scale use 1.0 or 0.0 for no scaling</param>
''' <param name="pxpt"> \param[out]   pxpt location of llx in pts</param>
''' <param name="pypt"> \param[out]   pypt location of lly in pts</param>
''' <param name="pwpt"> \param[out]   pwpt image width in pts</param>
''' <param name="phpt"> \param[out]   phpt image height in pts</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getScaledParametersPS")> _
Friend Shared Function getScaledParametersPS(box as IntPTR, wpix as Integer, hpix as Integer, res as Integer, scale as single, pxpt as single, pypt as single, pwpt as single, phpt as single) as Boolean ' Org. Void
End Function

' SRC\psio2.c (601, 1)
' convertByteToHexAscii()
' convertByteToHexAscii(l_uint8, char *, char *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="byteval"> \param[in]    byteval  input byte</param>
''' <param name="pnib1"> \param[out]   pnib1, pnib2  two hex ascii characters</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertByteToHexAscii")> _
Friend Shared Function convertByteToHexAscii(byteval as Byte, pnib1 as Object, pnib2 as Object) as Boolean ' Org. Void
End Function

' SRC\psio2.c (643, 1)
' convertJpegToPSEmbed()
' convertJpegToPSEmbed(const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function takes a jpeg file as input and generates a DCT
'''  * compressed, ascii85 encoded PS file, with a bounding box.
'''  *   (2) The bounding box is required when a program such as TeX
'''  * (through epsf) places and rescales the image.
'''  *   (3) The bounding box is sized for fitting the image to an
'''  * 8.5 x 11.0 inch page.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein input jpeg file</param>
''' <param name="fileout"> \param[in]    fileout output ps file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertJpegToPSEmbed")> _
Friend Shared Function convertJpegToPSEmbed(filein as String, fileout as String) as Integer
End Function

' SRC\psio2.c (758, 1)
' convertJpegToPS()
' convertJpegToPS(const char *, const char *, const char *, l_int32, l_int32, l_int32, l_float32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is simpler to use than pixWriteStringPS(), and
'''  * it outputs in level 2 PS as compressed DCT (overlaid
'''  * with ascii85 encoding).
'''  *   (2) An output file can contain multiple pages, each with
'''  * multiple images.  The arguments to convertJpegToPS()
'''  * allow you to control placement of jpeg images on multiple
'''  * pages within a PostScript file.
'''  *   (3) For the first image written to a file, use "w", which
'''  * opens for write and clears the file.  For all subsequent
'''  * images written to that file, use "a".
'''  *   (4) The (x, y) parameters give the LL corner of the image
'''  * relative to the LL corner of the page.  They are in
'''  * units of pixels if scale = 1.0.  If you use (e.g.)
'''  * scale = 2.0, the image is placed at (2x, 2y) on the page,
'''  * and the image dimensions are also doubled.
'''  *   (5) Display vs printed resolution:
'''  *  * If your display is 75 ppi and your image was created
'''  * at a resolution of 300 ppi, you can get the image
'''  * to print at the same size as it appears on your display
'''  * by either setting scale = 4.0 or by setting  res = 75.
'''  * Both tell the printer to make a 4x enlarged image.
'''  *  * If your image is generated at 150 ppi and you use scale = 1,
'''  * it will be rendered such that 150 pixels correspond
'''  * to 72 pts (1 inch on the printer).  This function does
'''  * the conversion from pixels (with or without scaling) to
'''  * pts, which are the units that the printer uses.
'''  *  * The printer will choose its own resolution to use
'''  * in rendering the image, which will not affect the size
'''  * of the rendered image.  That is because the output
'''  * PostScript file describes the geometry in terms of pts,
'''  * which are defined to be 1/72 inch.  The printer will
'''  * only see the size of the image in pts, through the
'''  * scale and translate parameters and the affine
'''  * transform (the ImageMatrix) of the image.
'''  *   (6) To render multiple images on the same page, set
'''  * endpage = FALSE for each image until you get to the
'''  * last, for which you set endpage = TRUE.  This causes the
'''  * "showpage" command to be invoked.  Showpage outputs
'''  * the entire page and clears the raster buffer for the
'''  * next page to be added.  Without a "showpage",
'''  * subsequent images from the next page will overlay those
'''  * previously put down.
'''  *   (7) For multiple pages, increment the page number, starting
'''  * with page 1.  This allows PostScript (and PDF) to build
'''  * a page directory, which viewers use for navigation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein input jpeg file</param>
''' <param name="fileout"> \param[in]    fileout output ps file</param>
''' <param name="operation"> \param[in]    operation "w" for write; "a" for append</param>
''' <param name="x"> \param[in]    x, y location of LL corner of image, in pixels, relative</param>
''' <param name="y"> \param[in]    res resolution of the input image, in ppi; use 0 for default</param>
''' <param name="res"> \param[in]    scale scaling by printer; use 0.0 or 1.0 for no scaling</param>
''' <param name="scale"> \param[in]    pageno page number; must start with 1; you can use 0</param>
''' <param name="pageno"> \param[in]    endpage boolean: use TRUE if this is the last image to be</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertJpegToPS")> _
Friend Shared Function convertJpegToPS(filein as String, fileout as String, operation as String, x as Integer, y as Integer, res as Integer, scale as single, pageno as Integer, endpage as Integer) as Integer
End Function

' SRC\psio2.c (817, 1)
' convertJpegToPSString()
' convertJpegToPSString(const char *, char **, l_int32 *, l_int32, l_int32, l_int32, l_float32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For usage, see convertJpegToPS()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein input jpeg file</param>
''' <param name="poutstr"> \param[out]   poutstr PS string</param>
''' <param name="pnbytes"> \param[out]   pnbytes number of bytes in PS string</param>
''' <param name="x"> \param[in]    x, y location of LL corner of image, in pixels, relative</param>
''' <param name="y"> \param[in]    res resolution of the input image, in ppi; use 0 for default</param>
''' <param name="res"> \param[in]    scale scaling by printer; use 0.0 or 1.0 for no scaling</param>
''' <param name="scale"> \param[in]    pageno page number; must start with 1; you can use 0</param>
''' <param name="pageno"> \param[in]    endpage boolean: use TRUE if this is the last image to be</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertJpegToPSString")> _
Friend Shared Function convertJpegToPSString(filein as String, poutstr as String, pnbytes as Integer, x as Integer, y as Integer, res as Integer, scale as single, pageno as Integer, endpage as Integer) as Integer
End Function

' SRC\psio2.c (911, 1)
' generateJpegPS()
' generateJpegPS(const char *, L_COMP_DATA *, l_float32, l_float32, l_float32, l_float32, l_int32, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) Low-level function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  PS string, or NULL on error</returns>
''' <param name="filein"> \param[in]    filein [optional] input jpeg filename; can be null</param>
''' <param name="cid"> \param[in]    cid jpeg compressed image data</param>
''' <param name="xpt"> \param[in]    xpt, ypt location of LL corner of image, in pts, relative</param>
''' <param name="ypt"> \param[in]    wpt, hpt rendered image size in pts</param>
''' <param name="wpt"> \param[in]    pageno page number; must start with 1; you can use 0</param>
''' <param name="hpt"> \param[in]    endpage boolean: use TRUE if this is the last image to be</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generateJpegPS")> _
Friend Shared Function generateJpegPS(filein as String, cid as IntPTR, xpt as single, ypt as single, wpt as single, hpt as single, pageno as Integer, endpage as Integer) as String
End Function

' SRC\psio2.c (1039, 1)
' convertG4ToPSEmbed()
' convertG4ToPSEmbed(const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function takes a g4 compressed tif file as input and
'''  * generates a g4 compressed, ascii85 encoded PS file, with
'''  * a bounding box.
'''  *   (2) The bounding box is required when a program such as TeX
'''  * (through epsf) places and rescales the image.
'''  *   (3) The bounding box is sized for fitting the image to an
'''  * 8.5 x 11.0 inch page.
'''  *   (4) We paint this through a mask, over whatever is below.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein input tiff file</param>
''' <param name="fileout"> \param[in]    fileout output ps file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertG4ToPSEmbed")> _
Friend Shared Function convertG4ToPSEmbed(filein as String, fileout as String) as Integer
End Function

' SRC\psio2.c (1145, 1)
' convertG4ToPS()
' convertG4ToPS(const char *, const char *, const char *, l_int32, l_int32, l_int32, l_float32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See the usage comments in convertJpegToPS(), some of
'''  * which are repeated here.
'''  *   (2) This is a wrapper for tiff g4.  The PostScript that
'''  * is generated is expanded by about 5/4 (due to the
'''  * ascii85 encoding.  If you convert to pdf (ps2pdf), the
'''  * ascii85 decoder is automatically invoked, so that the
'''  * pdf wrapped g4 file is essentially the same size as
'''  * the original g4 file.  It's useful to have the PS
'''  * file ascii85 encoded, because many printers will not
'''  * print binary PS files.
'''  *   (3) For the first image written to a file, use "w", which
'''  * opens for write and clears the file.  For all subsequent
'''  * images written to that file, use "a".
'''  *   (4) To render multiple images on the same page, set
'''  * endpage = FALSE for each image until you get to the
'''  * last, for which you set endpage = TRUE.  This causes the
'''  * "showpage" command to be invoked.  Showpage outputs
'''  * the entire page and clears the raster buffer for the
'''  * next page to be added.  Without a "showpage",
'''  * subsequent images from the next page will overlay those
'''  * previously put down.
'''  *   (5) For multiple images to the same page, where you are writing
'''  * both jpeg and tiff-g4, you have two options:
'''  *  (a) write the g4 first, as either image (maskflag == FALSE)
'''  *   or imagemask (maskflag == TRUE), and then write the
'''  *   jpeg over it.
'''  *  (b) write the jpeg first and as the last item, write
'''  *   the g4 as an imagemask (maskflag == TRUE), to paint
'''  *   through the foreground only.
'''  * We have this flexibility with the tiff-g4 because it is 1 bpp.
'''  *   (6) For multiple pages, increment the page number, starting
'''  * with page 1.  This allows PostScript (and PDF) to build
'''  * a page directory, which viewers use for navigation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein input tiff g4 file</param>
''' <param name="fileout"> \param[in]    fileout output ps file</param>
''' <param name="operation"> \param[in]    operation "w" for write; "a" for append</param>
''' <param name="x"> \param[in]    x, y location of LL corner of image, in pixels, relative</param>
''' <param name="y"> \param[in]    res resolution of the input image, in ppi; typ. values</param>
''' <param name="res"> \param[in]    scale scaling by printer; use 0.0 or 1.0 for no scaling</param>
''' <param name="scale"> \param[in]    pageno page number; must start with 1; you can use 0</param>
''' <param name="pageno"> \param[in]    maskflag boolean: use TRUE if just painting through fg;</param>
''' <param name="maskflag"> \param[in]    endpage boolean: use TRUE if this is the last image to be</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertG4ToPS")> _
Friend Shared Function convertG4ToPS(filein as String, fileout as String, operation as String, x as Integer, y as Integer, res as Integer, scale as single, pageno as Integer, maskflag as Integer, endpage as Integer) as Integer
End Function

' SRC\psio2.c (1208, 1)
' convertG4ToPSString()
' convertG4ToPSString(const char *, char **, l_int32 *, l_int32, l_int32, l_int32, l_float32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Generates PS string in G4 compressed tiff format from G4 tiff file.
'''  *   (2) For usage, see convertG4ToPS().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein input tiff g4 file</param>
''' <param name="poutstr"> \param[out]   poutstr PS string</param>
''' <param name="pnbytes"> \param[out]   pnbytes number of bytes in PS string</param>
''' <param name="x"> \param[in]    x, y location of LL corner of image, in pixels, relative</param>
''' <param name="y"> \param[in]    res resolution of the input image, in ppi; typ. values</param>
''' <param name="res"> \param[in]    scale scaling by printer; use 0.0 or 1.0 for no scaling</param>
''' <param name="scale"> \param[in]    pageno page number; must start with 1; you can use 0</param>
''' <param name="pageno"> \param[in]    maskflag boolean: use TRUE if just painting through fg;</param>
''' <param name="maskflag"> \param[in]    endpage boolean: use TRUE if this is the last image to be</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertG4ToPSString")> _
Friend Shared Function convertG4ToPSString(filein as String, poutstr as String, pnbytes as Integer, x as Integer, y as Integer, res as Integer, scale as single, pageno as Integer, maskflag as Integer, endpage as Integer) as Integer
End Function

' SRC\psio2.c (1304, 1)
' generateG4PS()
' generateG4PS(const char *, L_COMP_DATA *, l_float32, l_float32, l_float32, l_float32, l_int32, l_int32, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) Low-level function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  PS string, or NULL on error</returns>
''' <param name="filein"> \param[in]    filein [optional] input tiff g4 file; can be null</param>
''' <param name="cid"> \param[in]    cid g4 compressed image data</param>
''' <param name="xpt"> \param[in]    xpt, ypt location of LL corner of image, in pts, relative</param>
''' <param name="ypt"> \param[in]    wpt, hpt rendered image size in pts</param>
''' <param name="wpt"> \param[in]    maskflag boolean: use TRUE if just painting through fg;</param>
''' <param name="hpt"> \param[in]    pageno page number; must start with 1; you can use 0</param>
''' <param name="maskflag"> \param[in]    endpage boolean: use TRUE if this is the last image to be</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generateG4PS")> _
Friend Shared Function generateG4PS(filein as String, cid as IntPTR, xpt as single, ypt as single, wpt as single, hpt as single, maskflag as Integer, pageno as Integer, endpage as Integer) as String
End Function

' SRC\psio2.c (1438, 1)
' convertTiffMultipageToPS()
' convertTiffMultipageToPS(const char *, const char *, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This converts a multipage tiff file of binary page images
'''  * into a ccitt g4 compressed PS file.
'''  *   (2) If the images are generated from a standard resolution fax,
'''  * the vertical resolution is doubled to give a normal-looking
'''  * aspect ratio.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein input tiff multipage file</param>
''' <param name="fileout"> \param[in]    fileout output ps file</param>
''' <param name="fillfract"> \param[in]    fillfract factor for filling 8.5 x 11 inch page;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertTiffMultipageToPS")> _
Friend Shared Function convertTiffMultipageToPS(filein as String, fileout as String, fillfract as single) as Integer
End Function

' SRC\psio2.c (1518, 1)
' convertFlateToPSEmbed()
' convertFlateToPSEmbed(const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function takes any image file as input and generates a
'''  * flate-compressed, ascii85 encoded PS file, with a bounding box.
'''  *   (2) The bounding box is required when a program such as TeX
'''  * (through epsf) places and rescales the image.
'''  *   (3) The bounding box is sized for fitting the image to an
'''  * 8.5 x 11.0 inch page.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein input file -- any format</param>
''' <param name="fileout"> \param[in]    fileout output ps file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertFlateToPSEmbed")> _
Friend Shared Function convertFlateToPSEmbed(filein as String, fileout as String) as Integer
End Function

' SRC\psio2.c (1631, 1)
' convertFlateToPS()
' convertFlateToPS(const char *, const char *, const char *, l_int32, l_int32, l_int32, l_float32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This outputs level 3 PS as flate compressed (overlaid
'''  * with ascii85 encoding).
'''  *   (2) An output file can contain multiple pages, each with
'''  * multiple images.  The arguments to convertFlateToPS()
'''  * allow you to control placement of png images on multiple
'''  * pages within a PostScript file.
'''  *   (3) For the first image written to a file, use "w", which
'''  * opens for write and clears the file.  For all subsequent
'''  * images written to that file, use "a".
'''  *   (4) The (x, y) parameters give the LL corner of the image
'''  * relative to the LL corner of the page.  They are in
'''  * units of pixels if scale = 1.0.  If you use (e.g.)
'''  * scale = 2.0, the image is placed at (2x, 2y) on the page,
'''  * and the image dimensions are also doubled.
'''  *   (5) Display vs printed resolution:
'''  *  * If your display is 75 ppi and your image was created
'''  * at a resolution of 300 ppi, you can get the image
'''  * to print at the same size as it appears on your display
'''  * by either setting scale = 4.0 or by setting  res = 75.
'''  * Both tell the printer to make a 4x enlarged image.
'''  *  * If your image is generated at 150 ppi and you use scale = 1,
'''  * it will be rendered such that 150 pixels correspond
'''  * to 72 pts (1 inch on the printer).  This function does
'''  * the conversion from pixels (with or without scaling) to
'''  * pts, which are the units that the printer uses.
'''  *  * The printer will choose its own resolution to use
'''  * in rendering the image, which will not affect the size
'''  * of the rendered image.  That is because the output
'''  * PostScript file describes the geometry in terms of pts,
'''  * which are defined to be 1/72 inch.  The printer will
'''  * only see the size of the image in pts, through the
'''  * scale and translate parameters and the affine
'''  * transform (the ImageMatrix) of the image.
'''  *   (6) To render multiple images on the same page, set
'''  * endpage = FALSE for each image until you get to the
'''  * last, for which you set endpage = TRUE.  This causes the
'''  * "showpage" command to be invoked.  Showpage outputs
'''  * the entire page and clears the raster buffer for the
'''  * next page to be added.  Without a "showpage",
'''  * subsequent images from the next page will overlay those
'''  * previously put down.
'''  *   (7) For multiple pages, increment the page number, starting
'''  * with page 1.  This allows PostScript (and PDF) to build
'''  * a page directory, which viewers use for navigation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein input file -- any format</param>
''' <param name="fileout"> \param[in]    fileout output ps file</param>
''' <param name="operation"> \param[in]    operation "w" for write; "a" for append</param>
''' <param name="x"> \param[in]    x, y location of LL corner of image, in pixels, relative</param>
''' <param name="y"> \param[in]    res resolution of the input image, in ppi; use 0 for default</param>
''' <param name="res"> \param[in]    scale scaling by printer; use 0.0 or 1.0 for no scaling</param>
''' <param name="scale"> \param[in]    pageno page number; must start with 1; you can use 0</param>
''' <param name="pageno"> \param[in]    endpage boolean: use TRUE if this is the last image to be</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertFlateToPS")> _
Friend Shared Function convertFlateToPS(filein as String, fileout as String, operation as String, x as Integer, y as Integer, res as Integer, scale as single, pageno as Integer, endpage as Integer) as Integer
End Function

' SRC\psio2.c (1697, 1)
' convertFlateToPSString()
' convertFlateToPSString(const char *, char **, l_int32 *, l_int32, l_int32, l_int32, l_float32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The returned PS character array is a null-terminated
'''  * ascii string.  All the raster data is ascii85 encoded, so
'''  * there are no null bytes embedded in it.
'''  *   (2) The raster encoding is made with gzip, the same as that
'''  * in a png file that is compressed without prediction.
'''  * The raster data itself is 25% larger than that in the
'''  * binary form, due to the ascii85 encoding.
'''  *
'''  *  Usage:  See convertFlateToPS()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein input image file</param>
''' <param name="poutstr"> \param[out]   poutstr PS string</param>
''' <param name="pnbytes"> \param[out]   pnbytes number of bytes in PS string</param>
''' <param name="x"> \param[in]    x, y location of LL corner of image, in pixels, relative</param>
''' <param name="y"> \param[in]    res resolution of the input image, in ppi; use 0 for default</param>
''' <param name="res"> \param[in]    scale scaling by printer; use 0.0 or 1.0 for no scaling</param>
''' <param name="scale"> \param[in]    pageno page number; must start with 1; you can use 0</param>
''' <param name="pageno"> \param[in]    endpage boolean: use TRUE if this is the last image to be</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertFlateToPSString")> _
Friend Shared Function convertFlateToPSString(filein as String, poutstr as String, pnbytes as Integer, x as Integer, y as Integer, res as Integer, scale as single, pageno as Integer, endpage as Integer) as Integer
End Function

' SRC\psio2.c (1781, 1)
' generateFlatePS()
' generateFlatePS(const char *, L_COMP_DATA *, l_float32, l_float32, l_float32, l_float32, l_int32, l_int32) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  PS string, or NULL on error</returns>
''' <param name="filein"> \param[in]    filein [optional] input filename; can be null</param>
''' <param name="cid"> \param[in]    cid flate compressed image data</param>
''' <param name="xpt"> \param[in]    xpt, ypt location of LL corner of image, in pts, relative</param>
''' <param name="ypt"> \param[in]    wpt, hpt rendered image size in pts</param>
''' <param name="wpt"> \param[in]    pageno page number; must start with 1; you can use 0</param>
''' <param name="hpt"> \param[in]    endpage boolean: use TRUE if this is the last image to be</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generateFlatePS")> _
Friend Shared Function generateFlatePS(filein as String, cid as IntPTR, xpt as single, ypt as single, wpt as single, hpt as single, pageno as Integer, endpage as Integer) as String
End Function

' SRC\psio2.c (1922, 1)
' pixWriteMemPS()
' pixWriteMemPS(l_uint8 **, size_t *, PIX *, BOX *, l_int32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See pixWriteStringPS() for usage.
'''  *   (2) This is just a wrapper for pixWriteStringPS(), which
'''  * writes uncompressed image data to memory.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of tiff compressed image</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="box"> \param[in]    box  [optional]</param>
''' <param name="res"> \param[in]    res  can use 0 for default of 300 ppi</param>
''' <param name="scale"> \param[in]    scale to prevent scaling, use either 1.0 or 0.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMemPS")> _
Friend Shared Function pixWriteMemPS(pdata as Object, psize as ULong, pix as IntPTR, box as IntPTR, res as Integer, scale as single) as Integer
End Function

' SRC\psio2.c (1957, 1)
' getResLetterPage()
' getResLetterPage(l_int32, l_int32, l_float32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  resolution</returns>
''' <param name="w"> \param[in]    w image width, pixels</param>
''' <param name="h"> \param[in]    h image height, pixels</param>
''' <param name="fillfract"> \param[in]    fillfract fraction in linear dimension of full page, not</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getResLetterPage")> _
Friend Shared Function getResLetterPage(w as Integer, h as Integer, fillfract as single) as Integer
End Function

' SRC\psio2.c (1982, 1)
' getResA4Page()
' getResA4Page(l_int32, l_int32, l_float32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  resolution</returns>
''' <param name="w"> \param[in]    w image width, pixels</param>
''' <param name="h"> \param[in]    h image height, pixels</param>
''' <param name="fillfract"> \param[in]    fillfract fraction in linear dimension of full page, not</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getResA4Page")> _
Friend Shared Function getResA4Page(w as Integer, h as Integer, fillfract as single) as Integer
End Function

' SRC\psio2.c (2001, 1)
' 
' l_psWriteBoundingBox(l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_psWriteBoundingBox")> _
Friend Shared Function l_psWriteBoundingBox(flag as Integer) as Boolean ' Org. Void
End Function

#End Region
#Region "SRC\ptabasic.c"
' SRC\ptabasic.c (102, 16)
' ptaExtendArrays()
' ptaExtendArrays(PTA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaExtendArrays")> _
Friend Shared Function ptaExtendArrays(pta as IntPTR) as Integer
End Function

' SRC\ptabasic.c (103, 16)
' ptaaExtendArray()
' ptaaExtendArray(PTAA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ptaa"> \param[in]    ptaa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaExtendArray")> _
Friend Shared Function ptaaExtendArray(ptaa as IntPTR) as Integer
End Function

' SRC\ptabasic.c (116, 1)
' ptaCreate()
' ptaCreate(l_int32) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error.</returns>
''' <param name="n"> \param[in]    n  initial array sizes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaCreate")> _
Friend Shared Function ptaCreate(n as Integer) as IntPTR
End Function

' SRC\ptabasic.c (149, 1)
' ptaCreateFromNuma()
' ptaCreateFromNuma(NUMA *, NUMA *) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error.</returns>
''' <param name="nax"> \param[in]    nax [optional] can be null</param>
''' <param name="nay"> \param[in]    nay</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaCreateFromNuma")> _
Friend Shared Function ptaCreateFromNuma(nax as IntPTR, nay as IntPTR) as IntPTR
End Function

' SRC\ptabasic.c (192, 1)
' ptaDestroy()
' ptaDestroy(PTA **) as void
''' <summary>
''' * Notes:
'''  *   (1) Decrements the ref count and, if 0, destroys the pta.
'''  *   (2) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="ppta"> \param[in,out]   ppta to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaDestroy")> _
Friend Shared Function ptaDestroy(ppta as Object) as Boolean ' Org. Void
End Function

' SRC\ptabasic.c (225, 1)
' ptaCopy()
' ptaCopy(PTA *) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  copy of pta, or NULL on error</returns>
''' <param name="pta"> \param[in]    pta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaCopy")> _
Friend Shared Function ptaCopy(pta as IntPTR) as IntPTR
End Function

' SRC\ptabasic.c (257, 1)
' ptaCopyRange()
' ptaCopyRange(PTA *, l_int32, l_int32) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ptas"> \param[in]    ptas</param>
''' <param name="istart"> \param[in]    istart  starting index in ptas</param>
''' <param name="iend"> \param[in]    iend  ending index in ptas; use 0 to copy to end</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaCopyRange")> _
Friend Shared Function ptaCopyRange(ptas as IntPTR, istart as Integer, iend as Integer) as IntPTR
End Function

' SRC\ptabasic.c (296, 1)
' ptaClone()
' ptaClone(PTA *) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to same pta, or NULL on error</returns>
''' <param name="pta"> \param[in]    pta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaClone")> _
Friend Shared Function ptaClone(pta as IntPTR) as IntPTR
End Function

' SRC\ptabasic.c (320, 1)
' ptaEmpty()
' ptaEmpty(PTA *) as l_ok
''' <summary>
''' * Notes:
'''  *   This only resets the Pta::n field, for reuse
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaEmpty")> _
Friend Shared Function ptaEmpty(pta as IntPTR) as Integer
End Function

' SRC\ptabasic.c (342, 1)
' ptaAddPt()
' ptaAddPt(PTA *, l_float32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="x"> \param[in]    x, y</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaAddPt")> _
Friend Shared Function ptaAddPt(pta as IntPTR, x as single, y as single) as Integer
End Function

' SRC\ptabasic.c (404, 1)
' ptaInsertPt()
' ptaInsertPt(PTA *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="index"> \param[in]    index at which pt is to be inserted</param>
''' <param name="x"> \param[in]    x, y point values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaInsertPt")> _
Friend Shared Function ptaInsertPt(pta as IntPTR, index as Integer, x as Integer, y as Integer) as Integer
End Function

' SRC\ptabasic.c (447, 1)
' ptaRemovePt()
' ptaRemovePt(PTA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This shifts pta[i] --> pta[i - 1] for all i > index.
'''  *   (2) It should not be used repeatedly on large arrays,
'''  * because the function is O(n).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="index"> \param[in]    index of point to be removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaRemovePt")> _
Friend Shared Function ptaRemovePt(pta as IntPTR, index as Integer) as Integer
End Function

' SRC\ptabasic.c (474, 1)
' 
' ptaGetRefcount(PTA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetRefcount")> _
Friend Shared Function ptaGetRefcount(pta as IntPTR) as Integer
End Function

' SRC\ptabasic.c (485, 1)
' 
' ptaChangeRefcount(PTA *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaChangeRefcount")> _
Friend Shared Function ptaChangeRefcount(pta as IntPTR, delta as Integer) as Integer
End Function

' SRC\ptabasic.c (504, 1)
' ptaGetCount()
' ptaGetCount(PTA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 if no pta</returns>
''' <param name="pta"> \param[in]    pta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetCount")> _
Friend Shared Function ptaGetCount(pta as IntPTR) as Integer
End Function

' SRC\ptabasic.c (525, 1)
' ptaGetPt()
' ptaGetPt(PTA *, l_int32, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="index"> \param[in]    index  into arrays</param>
''' <param name="px"> \param[out]   px [optional] float x value</param>
''' <param name="py"> \param[out]   py [optional] float y value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetPt")> _
Friend Shared Function ptaGetPt(pta as IntPTR, index as Integer, px as single, py as single) as Integer
End Function

' SRC\ptabasic.c (555, 1)
' ptaGetIPt()
' ptaGetIPt(PTA *, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="index"> \param[in]    index  into arrays</param>
''' <param name="px"> \param[out]   px [optional] integer x value</param>
''' <param name="py"> \param[out]   py [optional] integer y value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetIPt")> _
Friend Shared Function ptaGetIPt(pta as IntPTR, index as Integer, px as Integer, py as Integer) as Integer
End Function

' SRC\ptabasic.c (584, 1)
' ptaSetPt()
' ptaSetPt(PTA *, l_int32, l_float32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="index"> \param[in]    index  into arrays</param>
''' <param name="x"> \param[in]    x, y</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaSetPt")> _
Friend Shared Function ptaSetPt(pta as IntPTR, index as Integer, x as single, y as single) as Integer
End Function

' SRC\ptabasic.c (616, 1)
' ptaGetArrays()
' ptaGetArrays(PTA *, NUMA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This copies the internal arrays into new Numas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error or if pta is empty</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="pnax"> \param[out]   pnax [optional] numa of x array</param>
''' <param name="pnay"> \param[out]   pnay [optional] numa of y array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetArrays")> _
Friend Shared Function ptaGetArrays(pta as IntPTR, pnax as Object, pnay as Object) as Integer
End Function

' SRC\ptabasic.c (664, 1)
' ptaRead()
' ptaRead(const char *) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaRead")> _
Friend Shared Function ptaRead(filename as String) as IntPTR
End Function

' SRC\ptabasic.c (691, 1)
' ptaReadStream()
' ptaReadStream(FILE *) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaReadStream")> _
Friend Shared Function ptaReadStream(fp as Object) as IntPTR
End Function

' SRC\ptabasic.c (744, 1)
' ptaReadMem()
' ptaReadMem(const l_uint8 *, size_t) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="data"> \param[in]    data  serialization in ascii</param>
''' <param name="size"> \param[in]    size  of data in bytes; can use strlen to get it</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaReadMem")> _
Friend Shared Function ptaReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\ptabasic.c (782, 1)
' ptaWriteDebug()
' ptaWriteDebug(const char *, PTA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Debug version, intended for use in the library when writing
'''  * to files in a temp directory with names that are compiled in.
'''  * This is used instead of ptaWrite() for all such library calls.
'''  *   (2) The global variable LeptDebugOK defaults to 0, and can be set
'''  * or cleared by the function setLeptDebugOK().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="type"> \param[in]    type  0 for float values; 1 for integer values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaWriteDebug")> _
Friend Shared Function ptaWriteDebug(filename as String, pta as IntPTR, type as Integer) as Integer
End Function

' SRC\ptabasic.c (806, 1)
' ptaWrite()
' ptaWrite(const char *, PTA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="type"> \param[in]    type  0 for float values; 1 for integer values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaWrite")> _
Friend Shared Function ptaWrite(filename as String, pta as IntPTR, type as Integer) as Integer
End Function

' SRC\ptabasic.c (839, 1)
' ptaWriteStream()
' ptaWriteStream(FILE *, PTA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="type"> \param[in]    type  0 for float values; 1 for integer values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaWriteStream")> _
Friend Shared Function ptaWriteStream(fp as Object, pta as IntPTR, type as Integer) as Integer
End Function

' SRC\ptabasic.c (888, 1)
' ptaWriteMem()
' ptaWriteMem(l_uint8 **, size_t *, PTA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a pta in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of serialized pta; ascii</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="type"> \param[in]    type  0 for float values; 1 for integer values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaWriteMem")> _
Friend Shared Function ptaWriteMem(pdata as Object, psize as ULong, pta as IntPTR, type as Integer) as Integer
End Function

' SRC\ptabasic.c (939, 1)
' ptaaCreate()
' ptaaCreate(l_int32) as PTAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptaa, or NULL on error</returns>
''' <param name="n"> \param[in]    n  initial number of ptrs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaCreate")> _
Friend Shared Function ptaaCreate(n as Integer) as IntPTR
End Function

' SRC\ptabasic.c (967, 1)
' ptaaDestroy()
' ptaaDestroy(PTAA **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pptaa"> \param[in,out]   pptaa to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaDestroy")> _
Friend Shared Function ptaaDestroy(pptaa as Object) as Boolean ' Org. Void
End Function

' SRC\ptabasic.c (1004, 1)
' ptaaAddPta()
' ptaaAddPta(PTAA *, PTA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ptaa"> \param[in]    ptaa</param>
''' <param name="pta"> \param[in]    pta  to be added</param>
''' <param name="copyflag"> \param[in]    copyflag  L_INSERT, L_COPY, L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaAddPta")> _
Friend Shared Function ptaaAddPta(ptaa as IntPTR, pta as IntPTR, copyflag as Integer) as Integer
End Function

' SRC\ptabasic.c (1074, 1)
' ptaaGetCount()
' ptaaGetCount(PTAA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 if no ptaa</returns>
''' <param name="ptaa"> \param[in]    ptaa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaGetCount")> _
Friend Shared Function ptaaGetCount(ptaa as IntPTR) as Integer
End Function

' SRC\ptabasic.c (1094, 1)
' ptaaGetPta()
' ptaaGetPta(PTAA *, l_int32, l_int32) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="ptaa"> \param[in]    ptaa</param>
''' <param name="index"> \param[in]    index  to the i-th pta</param>
''' <param name="accessflag"> \param[in]    accessflag  L_COPY or L_CLONE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaGetPta")> _
Friend Shared Function ptaaGetPta(ptaa as IntPTR, index as Integer, accessflag as Integer) as IntPTR
End Function

' SRC\ptabasic.c (1125, 1)
' ptaaGetPt()
' ptaaGetPt(PTAA *, l_int32, l_int32, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="ptaa"> \param[in]    ptaa</param>
''' <param name="ipta"> \param[in]    ipta  to the i-th pta</param>
''' <param name="jpt"> \param[in]    jpt index to the j-th pt in the pta</param>
''' <param name="px"> \param[out]   px [optional] float x value</param>
''' <param name="py"> \param[out]   py [optional] float y value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaGetPt")> _
Friend Shared Function ptaaGetPt(ptaa as IntPTR, ipta as Integer, jpt as Integer, px as single, py as single) as Integer
End Function

' SRC\ptabasic.c (1165, 1)
' ptaaInitFull()
' ptaaInitFull(PTAA *, PTA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="ptaa"> \param[in]    ptaa can have non-null ptrs in the ptr array</param>
''' <param name="pta"> \param[in]    pta to be replicated into the entire ptr array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaInitFull")> _
Friend Shared Function ptaaInitFull(ptaa as IntPTR, pta as IntPTR) as Integer
End Function

' SRC\ptabasic.c (1204, 1)
' ptaaReplacePta()
' ptaaReplacePta(PTAA *, l_int32, PTA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Any existing pta is destroyed, and the input one
'''  * is inserted in its place.
'''  *   (2) If the index is invalid, return 1 (error)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ptaa"> \param[in]    ptaa</param>
''' <param name="index"> \param[in]    index  to the index-th pta</param>
''' <param name="pta"> \param[in]    pta insert and replace any existing one</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaReplacePta")> _
Friend Shared Function ptaaReplacePta(ptaa as IntPTR, index as Integer, pta as IntPTR) as Integer
End Function

' SRC\ptabasic.c (1235, 1)
' ptaaAddPt()
' ptaaAddPt(PTAA *, l_int32, l_float32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="ptaa"> \param[in]    ptaa</param>
''' <param name="ipta"> \param[in]    ipta  to the i-th pta</param>
''' <param name="x"> \param[in]    x,y point coordinates</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaAddPt")> _
Friend Shared Function ptaaAddPt(ptaa as IntPTR, ipta as Integer, x as single, y as single) as Integer
End Function

' SRC\ptabasic.c (1270, 1)
' ptaaTruncate()
' ptaaTruncate(PTAA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This identifies the largest index containing a pta that
'''  * has any points within it, destroys all pta above that index,
'''  * and resets the count.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ptaa"> \param[in]    ptaa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaTruncate")> _
Friend Shared Function ptaaTruncate(ptaa as IntPTR) as Integer
End Function

' SRC\ptabasic.c (1310, 1)
' ptaaRead()
' ptaaRead(const char *) as PTAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptaa, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaRead")> _
Friend Shared Function ptaaRead(filename as String) as IntPTR
End Function

' SRC\ptabasic.c (1337, 1)
' ptaaReadStream()
' ptaaReadStream(FILE *) as PTAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptaa, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaReadStream")> _
Friend Shared Function ptaaReadStream(fp as Object) as IntPTR
End Function

' SRC\ptabasic.c (1377, 1)
' ptaaReadMem()
' ptaaReadMem(const l_uint8 *, size_t) as PTAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptaa, or NULL on error</returns>
''' <param name="data"> \param[in]    data  serialization in ascii</param>
''' <param name="size"> \param[in]    size  of data in bytes; can use strlen to get it</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaReadMem")> _
Friend Shared Function ptaaReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\ptabasic.c (1415, 1)
' ptaaWriteDebug()
' ptaaWriteDebug(const char *, PTAA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Debug version, intended for use in the library when writing
'''  * to files in a temp directory with names that are compiled in.
'''  * This is used instead of ptaaWrite() for all such library calls.
'''  *   (2) The global variable LeptDebugOK defaults to 0, and can be set
'''  * or cleared by the function setLeptDebugOK().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="ptaa"> \param[in]    ptaa</param>
''' <param name="type"> \param[in]    type  0 for float values; 1 for integer values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaWriteDebug")> _
Friend Shared Function ptaaWriteDebug(filename as String, ptaa as IntPTR, type as Integer) as Integer
End Function

' SRC\ptabasic.c (1439, 1)
' ptaaWrite()
' ptaaWrite(const char *, PTAA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="ptaa"> \param[in]    ptaa</param>
''' <param name="type"> \param[in]    type  0 for float values; 1 for integer values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaWrite")> _
Friend Shared Function ptaaWrite(filename as String, ptaa as IntPTR, type as Integer) as Integer
End Function

' SRC\ptabasic.c (1472, 1)
' ptaaWriteStream()
' ptaaWriteStream(FILE *, PTAA *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="ptaa"> \param[in]    ptaa</param>
''' <param name="type"> \param[in]    type  0 for float values; 1 for integer values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaWriteStream")> _
Friend Shared Function ptaaWriteStream(fp as Object, ptaa as IntPTR, type as Integer) as Integer
End Function

' SRC\ptabasic.c (1514, 1)
' ptaaWriteMem()
' ptaaWriteMem(l_uint8 **, size_t *, PTAA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a ptaa in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of serialized ptaa; ascii</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="ptaa"> \param[in]    ptaa</param>
''' <param name="type"> \param[in]    type  0 for float values; 1 for integer values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaWriteMem")> _
Friend Shared Function ptaaWriteMem(pdata as Object, psize as ULong, ptaa as IntPTR, type as Integer) as Integer
End Function

#End Region
#Region "SRC\ptafunc1.c"
' SRC\ptafunc1.c (111, 1)
' ptaSubsample()
' ptaSubsample(PTA *, l_int32) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad evenly sampled pt values from ptas, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas</param>
''' <param name="subfactor"> \param[in]    subfactor subsample factor, >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaSubsample")> _
Friend Shared Function ptaSubsample(ptas as IntPTR, subfactor as Integer) as IntPTR
End Function

' SRC\ptafunc1.c (154, 1)
' ptaJoin()
' ptaJoin(PTA *, PTA *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) istart  0 is taken to mean 'read from the start' (istart = 0)
'''  *   (2) iend  0 means 'read to the end'
'''  *   (3) if ptas == NULL, this is a no-op
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ptad"> \param[in]    ptad  dest pta; add to this one</param>
''' <param name="ptas"> \param[in]    ptas  source pta; add from this one</param>
''' <param name="istart"> \param[in]    istart  starting index in ptas</param>
''' <param name="iend"> \param[in]    iend  ending index in ptas; use -1 to cat all</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaJoin")> _
Friend Shared Function ptaJoin(ptad as IntPTR, ptas as IntPTR, istart as Integer, iend as Integer) as Integer
End Function

' SRC\ptafunc1.c (202, 1)
' ptaaJoin()
' ptaaJoin(PTAA *, PTAA *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) istart  0 is taken to mean 'read from the start' (istart = 0)
'''  *   (2) iend  0 means 'read to the end'
'''  *   (3) if ptas == NULL, this is a no-op
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ptaad"> \param[in]    ptaad  dest ptaa; add to this one</param>
''' <param name="ptaas"> \param[in]    ptaas  source ptaa; add from this one</param>
''' <param name="istart"> \param[in]    istart  starting index in ptaas</param>
''' <param name="iend"> \param[in]    iend  ending index in ptaas; use -1 to cat all</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaJoin")> _
Friend Shared Function ptaaJoin(ptaad as IntPTR, ptaas as IntPTR, istart as Integer, iend as Integer) as Integer
End Function

' SRC\ptafunc1.c (242, 1)
' ptaReverse()
' ptaReverse(PTA *, l_int32) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad reversed pta, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas</param>
''' <param name="type"> \param[in]    type  0 for float values; 1 for integer values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaReverse")> _
Friend Shared Function ptaReverse(ptas as IntPTR, type as Integer) as IntPTR
End Function

' SRC\ptafunc1.c (278, 1)
' ptaTranspose()
' ptaTranspose(PTA *) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad with x and y values swapped, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaTranspose")> _
Friend Shared Function ptaTranspose(ptas as IntPTR) as IntPTR
End Function

' SRC\ptafunc1.c (318, 1)
' ptaCyclicPerm()
' ptaCyclicPerm(PTA *, l_int32, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) Check to insure that (a) ptas is a closed path where
'''  * the first and last points are identical, and (b) the
'''  * resulting pta also starts and ends on the same point
'''  * (which in this case is (xs, ys).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad cyclic permutation, starting and ending at (xs, ys,</returns>
''' <param name="ptas"> \param[in]    ptas</param>
''' <param name="xs"> \param[in]    xs, ys  start point; must be in ptas</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaCyclicPerm")> _
Friend Shared Function ptaCyclicPerm(ptas as IntPTR, xs as Integer, ys as Integer) as IntPTR
End Function

' SRC\ptafunc1.c (374, 1)
' ptaSelectRange()
' ptaSelectRange(PTA *, l_int32, l_int32) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas</param>
''' <param name="first"> \param[in]    first    use 0 to select from the beginning</param>
''' <param name="last"> \param[in]    last     use 0 to select to the end</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaSelectRange")> _
Friend Shared Function ptaSelectRange(ptas as IntPTR, first as Integer, last as Integer) as IntPTR
End Function

' SRC\ptafunc1.c (424, 1)
' ptaGetBoundingRegion()
' ptaGetBoundingRegion(PTA *) as BOX *
''' <summary>
''' * Notes:
'''  *   (1) This is used when the pta represents a set of points in
'''  * a two-dimensional image.  It returns the box of minimum
'''  * size containing the pts in the pta.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  box, or NULL on error</returns>
''' <param name="pta"> \param[in]    pta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetBoundingRegion")> _
Friend Shared Function ptaGetBoundingRegion(pta as IntPTR) as IntPTR
End Function

' SRC\ptafunc1.c (468, 1)
' ptaGetRange()
' ptaGetRange(PTA *, l_float32 *, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) We can use pts to represent pairs of floating values, that
'''  * are not necessarily tied to a two-dimension region.  For
'''  * example, the pts can represent a general function y(x).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="pminx"> \param[out]   pminx [optional] min value of x</param>
''' <param name="pmaxx"> \param[out]   pmaxx [optional] max value of x</param>
''' <param name="pminy"> \param[out]   pminy [optional] min value of y</param>
''' <param name="pmaxy"> \param[out]   pmaxy [optional] max value of y</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetRange")> _
Friend Shared Function ptaGetRange(pta as IntPTR, pminx as single, pmaxx as single, pminy as single, pmaxy as single) as Integer
End Function

' SRC\ptafunc1.c (518, 1)
' ptaGetInsideBox()
' ptaGetInsideBox(PTA *, BOX *) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad of pts in ptas that are inside the box, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas input pts</param>
''' <param name="box"> \param[in]    box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetInsideBox")> _
Friend Shared Function ptaGetInsideBox(ptas as IntPTR, box as IntPTR) as IntPTR
End Function

' SRC\ptafunc1.c (558, 1)
' pixFindCornerPixels()
' pixFindCornerPixels(PIX *) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) Finds the 4 corner-most pixels, as defined by a search
'''  * inward from each corner, using a 45 degree line.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindCornerPixels")> _
Friend Shared Function pixFindCornerPixels(pixs as IntPTR) as IntPTR
End Function

' SRC\ptafunc1.c (650, 1)
' ptaContainsPt()
' ptaContainsPt(PTA *, l_int32, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if contained, 0 otherwise or on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="x"> \param[in]    x, y  point</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaContainsPt")> _
Friend Shared Function ptaContainsPt(pta as IntPTR, x as Integer, y as Integer) as Integer
End Function

' SRC\ptafunc1.c (679, 1)
' ptaTestIntersection()
' ptaTestIntersection(PTA *, PTA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  bval which is 1 if they have any elements in common;</returns>
''' <param name="pta1"> \param[in]    pta1, pta2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaTestIntersection")> _
Friend Shared Function ptaTestIntersection(pta1 as IntPTR, pta2 as IntPTR) as Integer
End Function

' SRC\ptafunc1.c (720, 1)
' ptaTransform()
' ptaTransform(PTA *, l_int32, l_int32, l_float32, l_float32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) Shift first, then scale.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas</param>
''' <param name="shiftx"> \param[in]    shiftx, shifty</param>
''' <param name="shifty"> \param[in]    scalex, scaley</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaTransform")> _
Friend Shared Function ptaTransform(ptas as IntPTR, shiftx as Integer, shifty as Integer, scalex as single, scaley as single) as IntPTR
End Function

' SRC\ptafunc1.c (760, 1)
' ptaPtInsidePolygon()
' ptaPtInsidePolygon(PTA *, l_float32, l_float32, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if OK, 0 on error</returns>
''' <param name="pta"> \param[in]    pta vertices of a polygon</param>
''' <param name="x"> \param[in]    x, y point to be tested</param>
''' <param name="y"> \param[out]   pinside 1 if inside; 0 if outside or on boundary</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaPtInsidePolygon")> _
Friend Shared Function ptaPtInsidePolygon(pta as IntPTR, x as single, y as single, pinside as Integer) as Integer
End Function

' SRC\ptafunc1.c (812, 1)
' l_angleBetweenVectors()
' l_angleBetweenVectors(l_float32, l_float32, l_float32, l_float32) as l_float32
''' <summary>
''' * Notes:
'''  *   (1) This gives the angle between two vectors, going between
'''  * vector1 (x1,y1) and vector2 (x2,y2).  The angle is swept
'''  * out from 1 --> 2.  If this is clockwise, the angle is
'''  * positive, but the result is folded into the interval [-pi, pi].
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  angle radians, or 0.0 on error</returns>
''' <param name="x1"> \param[in]    x1, y1 end point of first vector</param>
''' <param name="y1"> \param[in]    x2, y2 end point of second vector</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_angleBetweenVectors")> _
Friend Shared Function l_angleBetweenVectors(x1 as single, y1 as single, x2 as single, y2 as single) as single
End Function

' SRC\ptafunc1.c (841, 1)
' ptaGetMinMax()
' ptaGetMinMax(PTA *, l_float32 *, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.  If pta is empty, requested</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="pxmin"> \param[out]   pxmin  [optional] min of x</param>
''' <param name="pymin"> \param[out]   pymin  [optional] min of y</param>
''' <param name="pxmax"> \param[out]   pxmax  [optional] max of x</param>
''' <param name="pymax"> \param[out]   pymax  [optional] max of y</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetMinMax")> _
Friend Shared Function ptaGetMinMax(pta as IntPTR, pxmin as single, pymin as single, pxmax as single, pymax as single) as Integer
End Function

' SRC\ptafunc1.c (894, 1)
' ptaSelectByValue()
' ptaSelectByValue(PTA *, l_float32, l_float32, l_int32, l_int32) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad filtered set, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas</param>
''' <param name="xth"> \param[in]    xth, yth threshold values</param>
''' <param name="yth"> \param[in]    type L_SELECT_XVAL, L_SELECT_YVAL,</param>
''' <param name="type"> \param[in]    relation L_SELECT_IF_LT, L_SELECT_IF_GT,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaSelectByValue")> _
Friend Shared Function ptaSelectByValue(ptas as IntPTR, xth as single, yth as single, type as Integer, relation as Integer) as IntPTR
End Function

' SRC\ptafunc1.c (962, 1)
' ptaCropToMask()
' ptaCropToMask(PTA *, PIX *) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad  with only pts under the mask fg, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas  input pta</param>
''' <param name="pixm"> \param[in]    pixm  1 bpp mask</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaCropToMask")> _
Friend Shared Function ptaCropToMask(ptas as IntPTR, pixm as IntPTR) as IntPTR
End Function

' SRC\ptafunc1.c (1029, 1)
' ptaGetLinearLSF()
' ptaGetLinearLSF(PTA *, l_float32 *, l_float32 *, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Either or both &a and &b must be input.  They determine the
'''  * type of line that is fit.
'''  *   (2) If both &a and &b are defined, this returns a and b that minimize:
'''  *
'''  *  sum (yi - axi -b)^2
'''  *   i
'''  *
'''  * The method is simple: differentiate this expression w/rt a and b,
'''  * and solve the resulting two equations for a and b in terms of
'''  * various sums over the input data (xi, yi).
'''  *   (3) We also allow two special cases, where either a = 0 or b = 0:
'''  *  (a) If &a is given and &b = null, find the linear LSF that
'''  *   goes through the origin (b = 0).
'''  *  (b) If &b is given and &a = null, find the linear LSF with
'''  *   zero slope (a = 0).
'''  *   (4) If &nafit is defined, this returns an array of fitted values,
'''  * corresponding to the two implicit Numa arrays (nax and nay) in pta.
'''  * Thus, just as you can plot the data in pta as nay vs. nax,
'''  * you can plot the linear least square fit as nafit vs. nax.
'''  * Get the nax array using ptaGetArrays(pta, &nax, NULL);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="pa"> \param[out]   pa  [optional] slope a of least square fit: y = ax + b</param>
''' <param name="pb"> \param[out]   pb  [optional] intercept b of least square fit</param>
''' <param name="pnafit"> \param[out]   pnafit [optional] numa of least square fit</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetLinearLSF")> _
Friend Shared Function ptaGetLinearLSF(pta as IntPTR, pa as single, pb as single, pnafit as Object) as Integer
End Function

' SRC\ptafunc1.c (1130, 1)
' ptaGetQuadraticLSF()
' ptaGetQuadraticLSF(PTA *, l_float32 *, l_float32 *, l_float32 *, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does a quadratic least square fit to the set of points
'''  * in %pta.  That is, it finds coefficients a, b and c that minimize:
'''  *
'''  *  sum (yi - a*xi*xi -b*xi -c)^2
'''  *   i
'''  *
'''  * The method is simple: differentiate this expression w/rt
'''  * a, b and c, and solve the resulting three equations for these
'''  * coefficients in terms of various sums over the input data (xi, yi).
'''  * The three equations are in the form:
'''  * f[0][0]a + f[0][1]b + f[0][2]c = g[0]
'''  * f[1][0]a + f[1][1]b + f[1][2]c = g[1]
'''  * f[2][0]a + f[2][1]b + f[2][2]c = g[2]
'''  *   (2) If &nafit is defined, this returns an array of fitted values,
'''  * corresponding to the two implicit Numa arrays (nax and nay) in pta.
'''  * Thus, just as you can plot the data in pta as nay vs. nax,
'''  * you can plot the linear least square fit as nafit vs. nax.
'''  * Get the nax array using ptaGetArrays(pta, &nax, NULL);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="pa"> \param[out]   pa  [optional] coeff a of LSF: y = ax^2 + bx + c</param>
''' <param name="pb"> \param[out]   pb  [optional] coeff b of LSF: y = ax^2 + bx + c</param>
''' <param name="pc"> \param[out]   pc  [optional] coeff c of LSF: y = ax^2 + bx + c</param>
''' <param name="pnafit"> \param[out]   pnafit [optional] numa of least square fit</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetQuadraticLSF")> _
Friend Shared Function ptaGetQuadraticLSF(pta as IntPTR, pa as single, pb as single, pc as single, pnafit as Object) as Integer
End Function

' SRC\ptafunc1.c (1243, 1)
' ptaGetCubicLSF()
' ptaGetCubicLSF(PTA *, l_float32 *, l_float32 *, l_float32 *, l_float32 *, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does a cubic least square fit to the set of points
'''  * in %pta.  That is, it finds coefficients a, b, c and d
'''  * that minimize:
'''  *
'''  *  sum (yi - a*xi*xi*xi -b*xi*xi -c*xi - d)^2
'''  *   i
'''  *
'''  * Differentiate this expression w/rt a, b, c and d, and solve
'''  * the resulting four equations for these coefficients in
'''  * terms of various sums over the input data (xi, yi).
'''  * The four equations are in the form:
'''  * f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] = g[0]
'''  * f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] = g[1]
'''  * f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] = g[2]
'''  * f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] = g[3]
'''  *   (2) If &nafit is defined, this returns an array of fitted values,
'''  * corresponding to the two implicit Numa arrays (nax and nay) in pta.
'''  * Thus, just as you can plot the data in pta as nay vs. nax,
'''  * you can plot the linear least square fit as nafit vs. nax.
'''  * Get the nax array using ptaGetArrays(pta, &nax, NULL);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="pa"> \param[out]   pa  [optional] coeff a of LSF: y = ax^3 + bx^2 + cx + d</param>
''' <param name="pb"> \param[out]   pb  [optional] coeff b of LSF</param>
''' <param name="pc"> \param[out]   pc  [optional] coeff c of LSF</param>
''' <param name="pd"> \param[out]   pd  [optional] coeff d of LSF</param>
''' <param name="pnafit"> \param[out]   pnafit [optional] numa of least square fit</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetCubicLSF")> _
Friend Shared Function ptaGetCubicLSF(pta as IntPTR, pa as single, pb as single, pc as single, pd as single, pnafit as Object) as Integer
End Function

' SRC\ptafunc1.c (1373, 1)
' ptaGetQuarticLSF()
' ptaGetQuarticLSF(PTA *, l_float32 *, l_float32 *, l_float32 *, l_float32 *, l_float32 *, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does a quartic least square fit to the set of points
'''  * in %pta.  That is, it finds coefficients a, b, c, d and 3
'''  * that minimize:
'''  *
'''  *  sum (yi - a*xi*xi*xi*xi -b*xi*xi*xi -c*xi*xi - d*xi - e)^2
'''  *   i
'''  *
'''  * Differentiate this expression w/rt a, b, c, d and e, and solve
'''  * the resulting five equations for these coefficients in
'''  * terms of various sums over the input data (xi, yi).
'''  * The five equations are in the form:
'''  * f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] + f[0][4] = g[0]
'''  * f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] + f[1][4] = g[1]
'''  * f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] + f[2][4] = g[2]
'''  * f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] + f[3][4] = g[3]
'''  * f[4][0]a + f[4][1]b + f[4][2]c + f[4][3] + f[4][4] = g[4]
'''  *   (2) If &nafit is defined, this returns an array of fitted values,
'''  * corresponding to the two implicit Numa arrays (nax and nay) in pta.
'''  * Thus, just as you can plot the data in pta as nay vs. nax,
'''  * you can plot the linear least square fit as nafit vs. nax.
'''  * Get the nax array using ptaGetArrays(pta, &nax, NULL);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="pa"> \param[out]   pa  [optional] coeff a of LSF:</param>
''' <param name="pb"> \param[out]   pb  [optional] coeff b of LSF</param>
''' <param name="pc"> \param[out]   pc  [optional] coeff c of LSF</param>
''' <param name="pd"> \param[out]   pd  [optional] coeff d of LSF</param>
''' <param name="pe"> \param[out]   pe  [optional] coeff e of LSF</param>
''' <param name="pnafit"> \param[out]   pnafit [optional] numa of least square fit</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetQuarticLSF")> _
Friend Shared Function ptaGetQuarticLSF(pta as IntPTR, pa as single, pb as single, pc as single, pd as single, pe as single, pnafit as Object) as Integer
End Function

' SRC\ptafunc1.c (1509, 1)
' ptaNoisyLinearLSF()
' ptaNoisyLinearLSF(PTA *, l_float32, PTA **, l_float32 *, l_float32 *, l_float32 *, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does a linear least square fit to the set of points
'''  * in %pta.  It then evaluates the errors and removes points
'''  * whose error is >= factor * median_error.  It then re-runs
'''  * the linear LSF on the resulting points.
'''  *   (2) Either or both &a and &b must be input.  They determine the
'''  * type of line that is fit.
'''  *   (3) The median error can give an indication of how good the fit
'''  * is likely to be.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="factor"> \param[in]    factor reject outliers with error greater than this</param>
''' <param name="pptad"> \param[out]   pptad [optional] with outliers removed</param>
''' <param name="pa"> \param[out]   pa  [optional] slope a of least square fit: y = ax + b</param>
''' <param name="pb"> \param[out]   pb  [optional] intercept b of least square fit</param>
''' <param name="pmederr"> \param[out]   pmederr [optional] median error</param>
''' <param name="pnafit"> \param[out]   pnafit [optional] numa of least square fit to ptad</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaNoisyLinearLSF")> _
Friend Shared Function ptaNoisyLinearLSF(pta as IntPTR, factor as single, pptad as Object, pa as single, pb as single, pmederr as single, pnafit as Object) as Integer
End Function

' SRC\ptafunc1.c (1596, 1)
' ptaNoisyQuadraticLSF()
' ptaNoisyQuadraticLSF(PTA *, l_float32, PTA **, l_float32 *, l_float32 *, l_float32 *, l_float32 *, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does a quadratic least square fit to the set of points
'''  * in %pta.  It then evaluates the errors and removes points
'''  * whose error is >= factor * median_error.  It then re-runs
'''  * a quadratic LSF on the resulting points.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="factor"> \param[in]    factor reject outliers with error greater than this</param>
''' <param name="pptad"> \param[out]   pptad [optional] with outliers removed</param>
''' <param name="pa"> \param[out]   pa  [optional] coeff a of LSF: y = ax^2 + bx + c</param>
''' <param name="pb"> \param[out]   pb  [optional] coeff b of LSF: y = ax^2 + bx + c</param>
''' <param name="pc"> \param[out]   pc  [optional] coeff c of LSF: y = ax^2 + bx + c</param>
''' <param name="pmederr"> \param[out]   pmederr [optional] median error</param>
''' <param name="pnafit"> \param[out]   pnafit [optional] numa of least square fit to ptad</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaNoisyQuadraticLSF")> _
Friend Shared Function ptaNoisyQuadraticLSF(pta as IntPTR, factor as single, pptad as Object, pa as single, pb as single, pc as single, pmederr as single, pnafit as Object) as Integer
End Function

' SRC\ptafunc1.c (1676, 1)
' applyLinearFit()
' applyLinearFit(l_float32, l_float32, l_float32, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="a"> \param[in]   a, b linear fit coefficients</param>
''' <param name="b"> \param[in]   x</param>
''' <param name="x"> \param[out]  py y = a  x + b</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="applyLinearFit")> _
Friend Shared Function applyLinearFit(a as single, b as single, x as single, py as single) as Integer
End Function

' SRC\ptafunc1.c (1700, 1)
' applyQuadraticFit()
' applyQuadraticFit(l_float32, l_float32, l_float32, l_float32, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="a"> \param[in]   a, b, c quadratic fit coefficients</param>
''' <param name="b"> \param[in]   x</param>
''' <param name="c"> \param[out]  py y = a  x^2 + b  x + c</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="applyQuadraticFit")> _
Friend Shared Function applyQuadraticFit(a as single, b as single, c as single, x as single, py as single) as Integer
End Function

' SRC\ptafunc1.c (1725, 1)
' applyCubicFit()
' applyCubicFit(l_float32, l_float32, l_float32, l_float32, l_float32, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="a"> \param[in]   a, b, c, d cubic fit coefficients</param>
''' <param name="b"> \param[in]   x</param>
''' <param name="c"> \param[out]  py y = a  x^3 + b  x^2  + c  x + d</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="applyCubicFit")> _
Friend Shared Function applyCubicFit(a as single, b as single, c as single, d as single, x as single, py as single) as Integer
End Function

' SRC\ptafunc1.c (1751, 1)
' applyQuarticFit()
' applyQuarticFit(l_float32, l_float32, l_float32, l_float32, l_float32, l_float32, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="a"> \param[in]   a, b, c, d, e quartic fit coefficients</param>
''' <param name="b"> \param[in]   x</param>
''' <param name="c"> \param[out]  py y = a  x^4 + b  x^3  + c  x^2 + d  x + e</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="applyQuarticFit")> _
Friend Shared Function applyQuarticFit(a as single, b as single, c as single, d as single, e as single, x as single, py as single) as Integer
End Function

' SRC\ptafunc1.c (1792, 1)
' pixPlotAlongPta()
' pixPlotAlongPta(PIX *, PTA *, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a debugging function.
'''  *   (2) Removes existing colormaps and clips the pta to the input %pixs.
'''  *   (3) If the image is RGB, three separate plots are generated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]   pixs any depth</param>
''' <param name="pta"> \param[in]   pta set of points on which to plot</param>
''' <param name="outformat"> \param[in]   outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
''' <param name="title"> \param[in]   title [optional] for plot; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixPlotAlongPta")> _
Friend Shared Function pixPlotAlongPta(pixs as IntPTR, pta as IntPTR, outformat as Integer, title as String) as Integer
End Function

' SRC\ptafunc1.c (1893, 1)
' ptaGetPixelsFromPix()
' ptaGetPixelsFromPix(PIX *, BOX *) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) Generates a pta of fg pixels in the pix, within the box.
'''  * If box == NULL, it uses the entire pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="box"> \param[in]    box [optional] can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetPixelsFromPix")> _
Friend Shared Function ptaGetPixelsFromPix(pixs as IntPTR, box as IntPTR) as IntPTR
End Function

' SRC\ptafunc1.c (1946, 1)
' pixGenerateFromPta()
' pixGenerateFromPta(PTA *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Points are rounded to nearest ints.
'''  *   (2) Any points outside (w,h) are silently discarded.
'''  *   (3) Output 1 bpp pix has values 1 for each point in the pta.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix 1 bpp, or NULL on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="w"> \param[in]    w, h of pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateFromPta")> _
Friend Shared Function pixGenerateFromPta(pta as IntPTR, w as Integer, h as Integer) as IntPTR
End Function

' SRC\ptafunc1.c (1987, 1)
' ptaGetBoundaryPixels()
' ptaGetBoundaryPixels(PIX *, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) This generates a pta of either fg or bg boundary pixels.
'''  *   (2) See also pixGeneratePtaBoundary() for rendering of
'''  * fg boundary pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="type"> \param[in]    type L_BOUNDARY_FG, L_BOUNDARY_BG</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetBoundaryPixels")> _
Friend Shared Function ptaGetBoundaryPixels(pixs as IntPTR, type as Integer) as IntPTR
End Function

' SRC\ptafunc1.c (2036, 1)
' ptaaGetBoundaryPixels()
' ptaaGetBoundaryPixels(PIX *, l_int32, l_int32, BOXA **, PIXA **) as PTAA *
''' <summary>
''' * Notes:
'''  *   (1) This generates a ptaa of either fg or bg boundary pixels,
'''  * where each pta has the boundary pixels for a connected
'''  * component.
'''  *   (2) We can't simply find all the boundary pixels and then select
'''  * those within the bounding box of each component, because
'''  * bounding boxes can overlap.  It is necessary to extract and
'''  * dilate or erode each component separately.  Note also that
'''  * special handling is required for bg pixels when the
'''  * component touches the pix boundary.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptaa, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="type"> \param[in]    type L_BOUNDARY_FG, L_BOUNDARY_BG</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
''' <param name="pboxa"> \param[out]   pboxa [optional] bounding boxes of the c.c.</param>
''' <param name="ppixa"> \param[out]   ppixa [optional] pixa of the c.c.</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaGetBoundaryPixels")> _
Friend Shared Function ptaaGetBoundaryPixels(pixs as IntPTR, type as Integer, connectivity as Integer, pboxa as Object, ppixa as Object) as IntPTR
End Function

' SRC\ptafunc1.c (2119, 1)
' ptaaIndexLabeledPixels()
' ptaaIndexLabeledPixels(PIX *, l_int32 *) as PTAA *
''' <summary>
''' * Notes:
'''  *   (1) The pixel values in %pixs are the index of the connected component
'''  * to which the pixel belongs; %pixs is typically generated from
'''  * a 1 bpp pix by pixConnCompTransform().  Background pixels in
'''  * the generating 1 bpp pix are represented in %pixs by 0.
'''  * We do not check that the pixel values are correctly labelled.
'''  *   (2) Each pta in the returned ptaa gives the pixel locations
'''  * correspnding to a connected component, with the label of each
'''  * given by the index of the pta into the ptaa.
'''  *   (3) Initialize with the first pta in ptaa being empty and
'''  * representing the background value (index 0) in the pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptaa, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp, of indices of c.c.</param>
''' <param name="pncc"> \param[out]   pncc [optional] number of connected components</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaIndexLabeledPixels")> _
Friend Shared Function ptaaIndexLabeledPixels(pixs as IntPTR, pncc as Integer) as IntPTR
End Function

' SRC\ptafunc1.c (2176, 1)
' ptaGetNeighborPixLocs()
' ptaGetNeighborPixLocs(PIX *, l_int32, l_int32, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) Generates a pta of all valid neighbor pixel locations,
'''  * or NULL on error.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs    any depth</param>
''' <param name="x"> \param[in]    x, y    pixel from which we search for nearest neighbors</param>
''' <param name="y"> \param[in]    conn    4 or 8 connectivity</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetNeighborPixLocs")> _
Friend Shared Function ptaGetNeighborPixLocs(pixs as IntPTR, x as Integer, y as Integer, conn as Integer) as IntPTR
End Function

' SRC\ptafunc1.c (2232, 1)
' numaConvertToPta1()
' numaConvertToPta1(NUMA *) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta if OK; null on error</returns>
''' <param name="na"> \param[in]   na    numa with implicit y(x)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaConvertToPta1")> _
Friend Shared Function numaConvertToPta1(na as IntPTR) as IntPTR
End Function

' SRC\ptafunc1.c (2262, 1)
' numaConvertToPta2()
' numaConvertToPta2(NUMA *, NUMA *) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta if OK; null on error</returns>
''' <param name="nax"> \param[in]   nax</param>
''' <param name="nay"> \param[in]   nay</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaConvertToPta2")> _
Friend Shared Function numaConvertToPta2(nax as IntPTR, nay as IntPTR) as IntPTR
End Function

' SRC\ptafunc1.c (2298, 1)
' ptaConvertToNuma()
' ptaConvertToNuma(PTA *, NUMA **, NUMA **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pta"> \param[in]   pta</param>
''' <param name="pnax"> \param[out]  pnax    addr of nax</param>
''' <param name="pnay"> \param[out]  pnay    addr of nay</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaConvertToNuma")> _
Friend Shared Function ptaConvertToNuma(pta as IntPTR, pnax as Object, pnay as Object) as Integer
End Function

' SRC\ptafunc1.c (2349, 1)
' pixDisplayPta()
' pixDisplayPta(PIX *, PIX *, PTA *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) To write on an existing pixs, pixs must be 32 bpp and
'''  * call with pixd == pixs:
'''  * pixDisplayPta(pixs, pixs, pta);
'''  * To write to a new pix, use pixd == NULL and call:
'''  * pixd = pixDisplayPta(NULL, pixs, pta);
'''  *   (2) On error, returns pixd to avoid losing pixs if called as
'''  * pixs = pixDisplayPta(pixs, pixs, pta);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp RGB version of pixs, with path in green.</returns>
''' <param name="pixd"> \param[in]    pixd can be same as pixs or NULL; 32 bpp if in-place</param>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 16 or 32 bpp</param>
''' <param name="pta"> \param[in]    pta of path to be plotted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDisplayPta")> _
Friend Shared Function pixDisplayPta(pixd as IntPTR, pixs as IntPTR, pta as IntPTR) as IntPTR
End Function

' SRC\ptafunc1.c (2415, 1)
' pixDisplayPtaaPattern()
' pixDisplayPtaaPattern(PIX *, PIX *, PTAA *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) To write on an existing pixs, pixs must be 32 bpp and
'''  * call with pixd == pixs:
'''  * pixDisplayPtaPattern(pixs, pixs, pta, ...);
'''  * To write to a new pix, use pixd == NULL and call:
'''  * pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...);
'''  *   (2) Puts a random color on each pattern associated with a pta.
'''  *   (3) On error, returns pixd to avoid losing pixs if called as
'''  * pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...);
'''  *   (4) A typical pattern to be used is a circle, generated with
'''  * generatePtaFilledCircle()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp RGB version of pixs.</returns>
''' <param name="pixd"> \param[in]    pixd 32 bpp</param>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 16 or 32 bpp; 32 bpp if in place</param>
''' <param name="ptaa"> \param[in]    ptaa giving locations at which the pattern is displayed</param>
''' <param name="pixp"> \param[in]    pixp 1 bpp pattern to be placed such that its reference</param>
''' <param name="cx"> \param[in]    cx, cy reference point in pattern</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDisplayPtaaPattern")> _
Friend Shared Function pixDisplayPtaaPattern(pixd as IntPTR, pixs as IntPTR, ptaa as IntPTR, pixp as IntPTR, cx as Integer, cy as Integer) as IntPTR
End Function

' SRC\ptafunc1.c (2482, 1)
' pixDisplayPtaPattern()
' pixDisplayPtaPattern(PIX *, PIX *, PTA *, PIX *, l_int32, l_int32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) To write on an existing pixs, pixs must be 32 bpp and
'''  * call with pixd == pixs:
'''  * pixDisplayPtaPattern(pixs, pixs, pta, ...);
'''  * To write to a new pix, use pixd == NULL and call:
'''  * pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...);
'''  *   (2) On error, returns pixd to avoid losing pixs if called as
'''  * pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...);
'''  *   (3) A typical pattern to be used is a circle, generated with
'''  * generatePtaFilledCircle()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp RGB version of pixs.</returns>
''' <param name="pixd"> \param[in]    pixd can be same as pixs or NULL; 32 bpp if in-place</param>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 16 or 32 bpp</param>
''' <param name="pta"> \param[in]    pta giving locations at which the pattern is displayed</param>
''' <param name="pixp"> \param[in]    pixp 1 bpp pattern to be placed such that its reference</param>
''' <param name="cx"> \param[in]    cx, cy reference point in pattern</param>
''' <param name="cy"> \param[in]    color in 0xrrggbb00 format</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDisplayPtaPattern")> _
Friend Shared Function pixDisplayPtaPattern(pixd as IntPTR, pixs as IntPTR, pta as IntPTR, pixp as IntPTR, cx as Integer, cy as Integer, color as UInteger) as IntPTR
End Function

' SRC\ptafunc1.c (2542, 1)
' ptaReplicatePattern()
' ptaReplicatePattern(PTA *, PIX *, PTA *, l_int32, l_int32, l_int32, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) You can use either the image %pixp or the set of pts %ptap.
'''  *   (2) The pattern is placed with its reference point at each point
'''  * in ptas, and all the fg pixels are colleced into ptad.
'''  * For %pixp, this is equivalent to blitting pixp at each point
'''  * in ptas, and then converting the resulting pix to a pta.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad with all points of replicated pattern, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas "sparse" input pta</param>
''' <param name="pixp"> \param[in]    pixp [optional] 1 bpp pattern, to be replicated in output pta</param>
''' <param name="ptap"> \param[in]    ptap [optional] set of pts, to be replicated in output pta</param>
''' <param name="cx"> \param[in]    cx, cy reference point in pattern</param>
''' <param name="cy"> \param[in]    w, h clipping sizes for output pta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaReplicatePattern")> _
Friend Shared Function ptaReplicatePattern(ptas as IntPTR, pixp as IntPTR, ptap as IntPTR, cx as Integer, cy as Integer, w as Integer, h as Integer) as IntPTR
End Function

' SRC\ptafunc1.c (2594, 1)
' pixDisplayPtaa()
' pixDisplayPtaa(PIX *, PTAA *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp RGB version of pixs, with paths plotted</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 16 or 32 bpp</param>
''' <param name="ptaa"> \param[in]    ptaa array of paths to be plotted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDisplayPtaa")> _
Friend Shared Function pixDisplayPtaa(pixs as IntPTR, ptaa as IntPTR) as IntPTR
End Function

#End Region
#Region "SRC\ptafunc2.c"
' SRC\ptafunc2.c (89, 1)
' ptaSort()
' ptaSort(PTA *, l_int32, l_int32, NUMA **) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad sorted version of ptas, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas</param>
''' <param name="sorttype"> \param[in]    sorttype L_SORT_BY_X, L_SORT_BY_Y</param>
''' <param name="sortorder"> \param[in]    sortorder  L_SORT_INCREASING, L_SORT_DECREASING</param>
''' <param name="pnaindex"> \param[out]   pnaindex [optional] index of sorted order into</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaSort")> _
Friend Shared Function ptaSort(ptas as IntPTR, sorttype as Integer, sortorder as Integer, pnaindex as Object) as IntPTR
End Function

' SRC\ptafunc2.c (132, 1)
' ptaGetSortIndex()
' ptaGetSortIndex(PTA *, l_int32, l_int32, NUMA **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ptas"> \param[in]    ptas</param>
''' <param name="sorttype"> \param[in]    sorttype L_SORT_BY_X, L_SORT_BY_Y</param>
''' <param name="sortorder"> \param[in]    sortorder  L_SORT_INCREASING, L_SORT_DECREASING</param>
''' <param name="pnaindex"> \param[out]   pnaindex index of sorted order into</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetSortIndex")> _
Friend Shared Function ptaGetSortIndex(ptas as IntPTR, sorttype as Integer, sortorder as Integer, pnaindex as Object) as Integer
End Function

' SRC\ptafunc2.c (182, 1)
' ptaSortByIndex()
' ptaSortByIndex(PTA *, NUMA *) as PTA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad sorted, or NULL on  error</returns>
''' <param name="ptas"> \param[in]    ptas</param>
''' <param name="naindex"> \param[in]    naindex na that maps from the new pta to the input pta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaSortByIndex")> _
Friend Shared Function ptaSortByIndex(ptas as IntPTR, naindex as IntPTR) as IntPTR
End Function

' SRC\ptafunc2.c (218, 1)
' ptaaSortByIndex()
' ptaaSortByIndex(PTAA *, NUMA *) as PTAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptaad sorted, or NULL on error</returns>
''' <param name="ptaas"> \param[in]    ptaas</param>
''' <param name="naindex"> \param[in]    naindex na that maps from the new ptaa to the input ptaa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaaSortByIndex")> _
Friend Shared Function ptaaSortByIndex(ptaas as IntPTR, naindex as IntPTR) as IntPTR
End Function

' SRC\ptafunc2.c (257, 1)
' ptaGetRankValue()
' ptaGetRankValue(PTA *, l_float32, PTA *, l_int32, l_float32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="fract"> \param[in]    fract    use 0.0 for smallest, 1.0 for largest</param>
''' <param name="ptasort"> \param[in]    ptasort  [optional] version of %pta sorted by %sorttype</param>
''' <param name="sorttype"> \param[in]    sorttype L_SORT_BY_X, L_SORT_BY_Y</param>
''' <param name="pval"> \param[out]   pval     &rankval: the x or y value at %fract</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaGetRankValue")> _
Friend Shared Function ptaGetRankValue(pta as IntPTR, fract as single, ptasort as IntPTR, sorttype as Integer, pval as single) as Integer
End Function

' SRC\ptafunc2.c (317, 1)
' ptaUnionByAset()
' ptaUnionByAset(PTA *, PTA *) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) See sarrayRemoveDupsByAset() for the approach.
'''  *   (2) The key is a 64-bit hash from the (x,y) pair.
'''  *   (3) This is slower than ptaUnionByHash(), mostly because of the
'''  * nlogn sort to build up the rbtree.  Do not use for large
'''  * numbers of points (say, > 1M).
'''  *   (4) The *Aset() functions use the sorted l_Aset, which is just
'''  * an rbtree in disguise.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad with the union of the set of points, or NULL on error</returns>
''' <param name="pta1"> \param[in]    pta1, pta2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaUnionByAset")> _
Friend Shared Function ptaUnionByAset(pta1 as IntPTR, pta2 as IntPTR) as IntPTR
End Function

' SRC\ptafunc2.c (354, 1)
' ptaRemoveDupsByAset()
' ptaRemoveDupsByAset(PTA *) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) This is slower than ptaRemoveDupsByHash(), mostly because
'''  * of the nlogn sort to build up the rbtree.  Do not use for
'''  * large numbers of points (say, > 1M).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad with duplicates removed, or NULL on error</returns>
''' <param name="ptas"> \param[in]    ptas assumed to be integer values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaRemoveDupsByAset")> _
Friend Shared Function ptaRemoveDupsByAset(ptas as IntPTR) as IntPTR
End Function

' SRC\ptafunc2.c (401, 1)
' ptaIntersectionByAset()
' ptaIntersectionByAset(PTA *, PTA *) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) See sarrayIntersectionByAset() for the approach.
'''  *   (2) The key is a 64-bit hash from the (x,y) pair.
'''  *   (3) This is slower than ptaIntersectionByHash(), mostly because
'''  * of the nlogn sort to build up the rbtree.  Do not use for
'''  * large numbers of points (say, > 1M).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad intersection of the point sets, or NULL on error</returns>
''' <param name="pta1"> \param[in]    pta1, pta2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaIntersectionByAset")> _
Friend Shared Function ptaIntersectionByAset(pta1 as IntPTR, pta2 as IntPTR) as IntPTR
End Function

' SRC\ptafunc2.c (451, 1)
' l_asetCreateFromPta()
' l_asetCreateFromPta(PTA *) as L_ASET *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  set using a 64-bit hash of (x,y) as the key</returns>
''' <param name="pta"> \param[in]    pta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_asetCreateFromPta")> _
Friend Shared Function l_asetCreateFromPta(pta as IntPTR) as IntPTR
End Function

' SRC\ptafunc2.c (493, 1)
' ptaUnionByHash()
' ptaUnionByHash(PTA *, PTA *) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) This is faster than ptaUnionByAset(), because the
'''  * bucket lookup is O(n).  It should be used if the pts are
'''  * integers (e.g., representing pixel positions).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad with the union of the set of points, or NULL on error</returns>
''' <param name="pta1"> \param[in]    pta1, pta2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaUnionByHash")> _
Friend Shared Function ptaUnionByHash(pta1 as IntPTR, pta2 as IntPTR) as IntPTR
End Function

' SRC\ptafunc2.c (543, 1)
' ptaRemoveDupsByHash()
' ptaRemoveDupsByHash(PTA *, PTA **, L_DNAHASH **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Generates a pta with unique values.
'''  *   (2) The dnahash is built up with ptad to assure uniqueness.
'''  * It can be used to find if a point is in the set:
'''  *  ptaFindPtByHash(ptad, dahash, x, y, &index)
'''  *   (3) The hash of the (x,y) location is simple and fast.  It scales
'''  * up with the number of buckets to insure a fairly random
'''  * bucket selection for adjacent points.
'''  *   (4) A Dna is used rather than a Numa because we need accurate
'''  * representation of 32-bit integers that are indices into ptas.
'''  * Integer --> float --> integer conversion makes errors for
'''  * integers larger than 10M.
'''  *   (5) This is faster than ptaRemoveDupsByAset(), because the
'''  * bucket lookup is O(n), although there is a double-loop
'''  * lookup within the dna in each bucket.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="ptas"> \param[in]    ptas assumed to be integer values</param>
''' <param name="pptad"> \param[out]   pptad unique set of pts; duplicates removed</param>
''' <param name="pdahash"> \param[out]   pdahash [optional] dnahash used for lookup</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaRemoveDupsByHash")> _
Friend Shared Function ptaRemoveDupsByHash(ptas as IntPTR, pptad as Object, pdahash as Object) as Integer
End Function

' SRC\ptafunc2.c (600, 1)
' ptaIntersectionByHash()
' ptaIntersectionByHash(PTA *, PTA *) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) This is faster than ptaIntersectionByAset(), because the
'''  * bucket lookup is O(n).  It should be used if the pts are
'''  * integers (e.g., representing pixel positions).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptad intersection of the point sets, or NULL on error</returns>
''' <param name="pta1"> \param[in]    pta1, pta2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaIntersectionByHash")> _
Friend Shared Function ptaIntersectionByHash(pta1 as IntPTR, pta2 as IntPTR) as IntPTR
End Function

' SRC\ptafunc2.c (674, 1)
' ptaFindPtByHash()
' ptaFindPtByHash(PTA *, L_DNAHASH *, l_int32, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Fast lookup in dnaHash associated with a pta, to see if a
'''  * random point (x,y) is already stored in the hash table.
'''  *   (2) We use a strong hash function to minimize the chance that
'''  * two different points hash to the same key value.
'''  *   (3) We select the number of buckets to be about 5% of the size
'''  * of the input %pta, so that when fully populated, each
'''  * bucket (dna) will have about 20 entries, each being an index
'''  * into %pta.  In lookup, after hashing to the key, and then
'''  * again to the bucket, we traverse the bucket (dna), using the
'''  * index into %pta to check if the point (x,y) has been found before.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="dahash"> \param[in]    dahash built from pta</param>
''' <param name="x"> \param[in]    x, y  arbitrary points</param>
''' <param name="y"> \param[out]   pindex index into pta if (x,y) is in pta;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptaFindPtByHash")> _
Friend Shared Function ptaFindPtByHash(pta as IntPTR, dahash as IntPTR, x as Integer, y as Integer, pindex as Integer) as Integer
End Function

' SRC\ptafunc2.c (720, 1)
' l_dnaHashCreateFromPta()
' l_dnaHashCreateFromPta(PTA *) as L_DNAHASH *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dahash, or NULL on error</returns>
''' <param name="pta"> \param[in]    pta</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaHashCreateFromPta")> _
Friend Shared Function l_dnaHashCreateFromPta(pta as IntPTR) as IntPTR
End Function

#End Region
#Region "SRC\ptra.c"
' SRC\ptra.c (126, 16)
' ptraExtendArray()
' ptraExtendArray(L_PTRA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pa"> \param[in]    pa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraExtendArray")> _
Friend Shared Function ptraExtendArray(pa as IntPTR) as Integer
End Function

' SRC\ptra.c (139, 1)
' ptraCreate()
' ptraCreate(l_int32) as L_PTRA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pa, or NULL on error</returns>
''' <param name="n"> \param[in]    n size of ptr array to be alloc'd 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraCreate")> _
Friend Shared Function ptraCreate(n as Integer) as IntPTR
End Function

' SRC\ptra.c (185, 1)
' ptraDestroy()
' ptraDestroy(L_PTRA **, l_int32, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) If %freeflag == TRUE, frees each item in the array.
'''  *   (2) If %freeflag == FALSE and %warnflag == TRUE, and there are
'''  * items on the array, this gives a warning and destroys the array.
'''  * If these items are not owned elsewhere, this will cause
'''  * a memory leak of all the items that were on the array.
'''  * So if the items are not owned elsewhere and require their
'''  * own destroy function, they must be destroyed before the ptra.
'''  *   (3) If %warnflag == FALSE, no warnings will be issued.  This is
'''  * useful if the items are owned elsewhere, such as a
'''  * PixMemoryStore().
'''  *   (4) To destroy the ptra, we destroy the ptr array, then
'''  * the ptra, and then null the contents of the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="ppa"> \param[in,out]   ppa ptra to be nulled</param>
''' <param name="freeflag"> \param[in]       freeflag TRUE to free each remaining item in the array</param>
''' <param name="warnflag"> \param[in]       warnflag TRUE to warn if any remaining items are not destroyed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraDestroy")> _
Friend Shared Function ptraDestroy(ppa as Object, freeflag as Integer, warnflag as Integer) as Boolean ' Org. Void
End Function

' SRC\ptra.c (242, 1)
' ptraAdd()
' ptraAdd(L_PTRA *, void *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This adds the element to the next location beyond imax,
'''  * which is the largest occupied ptr in the array.  This is
'''  * what you expect from a stack, where all ptrs up to and
'''  * including imax are occupied, but here the occuption of
'''  * items in the array is entirely arbitrary.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pa"> \param[in]    pa ptra</param>
''' <param name="item"> \param[in]    item  generic ptr to a struct</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraAdd")> _
Friend Shared Function ptraAdd(pa as IntPTR, item as Object) as Integer
End Function

' SRC\ptra.c (336, 1)
' ptraInsert()
' ptraInsert(L_PTRA *, l_int32, void *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This checks first to see if the location is valid, and
'''  * then if there is presently an item there.  If there is not,
'''  * it is simply inserted into that location.
'''  *   (2) If there is an item at the insert location, items must be
'''  * moved down to make room for the insert.  In the downward
'''  * shift there are three options, given by %shiftflag.
'''  *   ~ If %shiftflag == L_AUTO_DOWNSHIFT, a decision is made
'''  *  whether, in a cascade of items, to downshift a minimum
'''  *  amount or for all items above %index.  The decision is
'''  *  based on the expectation of finding holes (null ptrs)
'''  *  between %index and the bottom of the array.
'''  *  Assuming the holes are distributed uniformly, if 2 or more
'''  *  holes are expected, we do a minimum shift.
'''  *   ~ If %shiftflag == L_MIN_DOWNSHIFT, the downward shifting
'''  *  cascade of items progresses a minimum amount, until
'''  *  the first empty slot is reached.  This mode requires
'''  *  some computation before the actual shifting is done.
'''  *   ~ If %shiftflag == L_FULL_DOWNSHIFT, a shifting cascade is
'''  *  performed where pa[i] --> pa[i + 1] for all i >= index.
'''  *  Then, the item is inserted at pa[index].
'''  *   (3) If you are not using L_AUTO_DOWNSHIFT, the rule of thumb is
'''  * to use L_FULL_DOWNSHIFT if the array is compacted (each
'''  * element points to an item), and to use L_MIN_DOWNSHIFT
'''  * if there are a significant number of null pointers.
'''  * There is no penalty to using L_MIN_DOWNSHIFT for a
'''  * compacted array, however, because the full shift is required
'''  * and we don't do the O(n) computation to look for holes.
'''  *   (4) This should not be used repeatedly on large arrays,
'''  * because the function is generally O(n).
'''  *   (5) However, it can be used repeatedly if we start with an empty
'''  * ptr array and insert only once at each location.  For example,
'''  * you can support an array of Numa, where at each ptr location
'''  * you store either 0 or 1 Numa, and the Numa can be added
'''  * randomly to the ptr array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pa"> \param[in]    pa ptra</param>
''' <param name="index"> \param[in]    index location in ptra to insert new value</param>
''' <param name="item"> \param[in]    item  generic ptr to a struct; can be null</param>
''' <param name="shiftflag"> \param[in]    shiftflag L_AUTO_DOWNSHIFT, L_MIN_DOWNSHIFT, L_FULL_DOWNSHIFT</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraInsert")> _
Friend Shared Function ptraInsert(pa as IntPTR, index as Integer, item as Object, shiftflag as Integer) as Integer
End Function

' SRC\ptra.c (434, 1)
' ptraRemove()
' ptraRemove(L_PTRA *, l_int32, l_int32) as void *
''' <summary>
''' * Notes:
'''  *   (1) If flag == L_NO_COMPACTION, this removes the item and
'''  * nulls the ptr on the array.  If it takes the last item
'''  * in the array, pa->n is reduced to the next item.
'''  *   (2) If flag == L_COMPACTION, this compacts the array for
'''  * for all i >= index.  It should not be used repeatedly on
'''  * large arrays, because compaction is O(n).
'''  *   (3) The ability to remove without automatic compaction allows
'''  * removal with cost O(1).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  item, or NULL on error</returns>
''' <param name="pa"> \param[in]    pa ptra</param>
''' <param name="index"> \param[in]    index element to be removed</param>
''' <param name="flag"> \param[in]    flag L_NO_COMPACTION, L_COMPACTION</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraRemove")> _
Friend Shared Function ptraRemove(pa as IntPTR, index as Integer, flag as Integer) as String
End Function

' SRC\ptra.c (483, 1)
' ptraRemoveLast()
' ptraRemoveLast(L_PTRA *) as void *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  item, or NULL on error or if the array is empty</returns>
''' <param name="pa"> \param[in]    pa ptra</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraRemoveLast")> _
Friend Shared Function ptraRemoveLast(pa as IntPTR) as String
End Function

' SRC\ptra.c (512, 1)
' ptraReplace()
' ptraReplace(L_PTRA *, l_int32, void *, l_int32) as void *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  item  old item, if it exists and is not freed,</returns>
''' <param name="pa"> \param[in]    pa ptra</param>
''' <param name="index"> \param[in]    index element to be replaced</param>
''' <param name="item"> \param[in]    item  new generic ptr to a struct; can be null</param>
''' <param name="freeflag"> \param[in]    freeflag TRUE to free old item; FALSE to return it</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraReplace")> _
Friend Shared Function ptraReplace(pa as IntPTR, index as Integer, item as Object, freeflag as Integer) as String
End Function

' SRC\ptra.c (553, 1)
' ptraSwap()
' ptraSwap(L_PTRA *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pa"> \param[in]    pa ptra</param>
''' <param name="index1"> \param[in]    index1</param>
''' <param name="index2"> \param[in]    index2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraSwap")> _
Friend Shared Function ptraSwap(pa as IntPTR, index1 as Integer, index2 as Integer) as Integer
End Function

' SRC\ptra.c (590, 1)
' ptraCompactArray()
' ptraCompactArray(L_PTRA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This compacts the items on the array, filling any empty ptrs.
'''  *   (2) This does not change the size of the array of ptrs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pa"> \param[in]    pa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraCompactArray")> _
Friend Shared Function ptraCompactArray(pa as IntPTR) as Integer
End Function

' SRC\ptra.c (625, 1)
' ptraReverse()
' ptraReverse(L_PTRA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pa"> \param[in]    pa ptra</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraReverse")> _
Friend Shared Function ptraReverse(pa as IntPTR) as Integer
End Function

' SRC\ptra.c (649, 1)
' ptraJoin()
' ptraJoin(L_PTRA *, L_PTRA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pa1"> \param[in]    pa1 add to this one</param>
''' <param name="pa2"> \param[in]    pa2 appended to pa1, and emptied of items; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraJoin")> _
Friend Shared Function ptraJoin(pa1 as IntPTR, pa2 as IntPTR) as Integer
End Function

' SRC\ptra.c (699, 1)
' ptraGetMaxIndex()
' ptraGetMaxIndex(L_PTRA *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The largest index to an item in the array is %maxindex.
'''  * %maxindex is one less than the number of items that would be
'''  * in the array if there were no null pointers between 0
'''  * and %maxindex - 1.  However, because the internal ptr array
'''  * need not be compacted, there may be NULL pointers at
'''  * indices below %maxindex; for example, if items have
'''  * been removed.
'''  *   (2) When an item is added to the end of the array, it goes
'''  * into pa->array[maxindex + 1], and maxindex is then
'''  * incremented by 1.
'''  *   (3) If there are no items in the array, this returns %maxindex = -1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pa"> \param[in]    pa ptra</param>
''' <param name="pmaxindex"> \param[out]   pmaxindex index of last item in the array;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraGetMaxIndex")> _
Friend Shared Function ptraGetMaxIndex(pa as IntPTR, pmaxindex as Integer) as Integer
End Function

' SRC\ptra.c (727, 1)
' ptraGetActualCount()
' ptraGetActualCount(L_PTRA *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The actual number of items on the ptr array, pa->nactual,
'''  * will be smaller than pa->n if the array is not compacted.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pa"> \param[in]    pa ptra</param>
''' <param name="pcount"> \param[out]   pcount actual number of items on the ptr array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraGetActualCount")> _
Friend Shared Function ptraGetActualCount(pa as IntPTR, pcount as Integer) as Integer
End Function

' SRC\ptra.c (759, 1)
' ptraGetPtrToItem()
' ptraGetPtrToItem(L_PTRA *, l_int32) as void *
''' <summary>
''' * Notes:
'''  *   (1) This returns a ptr to the item.  You must cast it to
'''  * the type of item.  Do not destroy it; the item belongs
'''  * to the Ptra.
'''  *   (2) This can access all possible items on the ptr array.
'''  * If an item doesn't exist, it returns null.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  a ptr to the element, or NULL on error</returns>
''' <param name="pa"> \param[in]    pa ptra</param>
''' <param name="index"> \param[in]    index of element to be retrieved</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraGetPtrToItem")> _
Friend Shared Function ptraGetPtrToItem(pa as IntPTR, index as Integer) as String
End Function

' SRC\ptra.c (790, 1)
' ptraaCreate()
' ptraaCreate(l_int32) as L_PTRAA *
''' <summary>
''' * Notes:
'''  *   (1) The ptraa is generated with a fixed size, that can not change.
'''  * The ptra can be generated and inserted randomly into this array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  paa, or NULL on error</returns>
''' <param name="n"> \param[in]    n size of ptr array to be alloc'd</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraaCreate")> _
Friend Shared Function ptraaCreate(n as Integer) as IntPTR
End Function

' SRC\ptra.c (826, 1)
' ptraaDestroy()
' ptraaDestroy(L_PTRAA **, l_int32, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) See ptraDestroy() for use of %freeflag and %warnflag.
'''  *   (2) To destroy the ptraa, we destroy each ptra, then the ptr array,
'''  * then the ptraa, and then null the contents of the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="ppaa"> \param[in,out]   ppaa to be nulled</param>
''' <param name="freeflag"> \param[in]    freeflag TRUE to free each remaining item in each ptra</param>
''' <param name="warnflag"> \param[in]    warnflag TRUE to warn if any remaining items are not destroyed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraaDestroy")> _
Friend Shared Function ptraaDestroy(ppaa as Object, freeflag as Integer, warnflag as Integer) as Boolean ' Org. Void
End Function

' SRC\ptra.c (867, 1)
' ptraaGetSize()
' ptraaGetSize(L_PTRAA *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="paa"> \param[in]    paa</param>
''' <param name="psize"> \param[out]   psize size of ptr array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraaGetSize")> _
Friend Shared Function ptraaGetSize(paa as IntPTR, psize as Integer) as Integer
End Function

' SRC\ptra.c (898, 1)
' ptraaInsertPtra()
' ptraaInsertPtra(L_PTRAA *, l_int32, L_PTRA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Caller should check return value.  On success, the Ptra
'''  * is inserted in the Ptraa and is owned by it.  However,
'''  * on error, the Ptra remains owned by the caller.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="paa"> \param[in]    paa ptraa</param>
''' <param name="index"> \param[in]    index location in array for insertion</param>
''' <param name="pa"> \param[in]    pa to be inserted</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraaInsertPtra")> _
Friend Shared Function ptraaInsertPtra(paa as IntPTR, index as Integer, pa as IntPTR) as Integer
End Function

' SRC\ptra.c (941, 1)
' ptraaGetPtra()
' ptraaGetPtra(L_PTRAA *, l_int32, l_int32) as L_PTRA *
''' <summary>
''' * Notes:
'''  *   (1) This returns the ptra ptr.  If %accessflag == L_HANDLE_ONLY,
'''  * the ptra is left on the ptraa.  If %accessflag == L_REMOVE,
'''  * the ptr in the ptraa is set to NULL, and the caller
'''  * is responsible for disposing of the ptra (either putting it
'''  * back on the ptraa, or destroying it).
'''  *   (2) This returns NULL if there is no Ptra at the index location.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptra at index location, or NULL on error or if there</returns>
''' <param name="paa"> \param[in]    paa ptraa</param>
''' <param name="index"> \param[in]    index location in array</param>
''' <param name="accessflag"> \param[in]    accessflag L_HANDLE_ONLY, L_REMOVE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraaGetPtra")> _
Friend Shared Function ptraaGetPtra(paa as IntPTR, index as Integer, accessflag as Integer) as IntPTR
End Function

' SRC\ptra.c (983, 1)
' ptraaFlattenToPtra()
' ptraaFlattenToPtra(L_PTRAA *) as L_PTRA *
''' <summary>
''' * Notes:
'''  *   (1) This 'flattens' the ptraa to a ptra, taking the items in
'''  * each ptra, in order, starting with the first ptra, etc.
'''  *   (2) As a side-effect, the ptra are all removed from the ptraa
'''  * and destroyed, leaving an empty ptraa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptra, or NULL on error</returns>
''' <param name="paa"> \param[in]    paa ptraa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ptraaFlattenToPtra")> _
Friend Shared Function ptraaFlattenToPtra(paa as IntPTR) as IntPTR
End Function

#End Region
#Region "SRC\quadtree.c"
' SRC\quadtree.c (92, 1)
' pixQuadtreeMean()
' pixQuadtreeMean(PIX *, l_int32, PIX *, FPIXA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The returned fpixa has %nlevels of fpix, each containing
'''  * the mean values at its level.  Level 0 has a
'''  * single value; level 1 has 4 values; level 2 has 16; etc.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     8 bpp, no colormap</param>
''' <param name="nlevels"> \param[in]    nlevels  in quadtree; max allowed depends on image size</param>
''' <param name="pix_ma"> \param[in]   pix_ma   input mean accumulator; can be null</param>
''' <param name="pfpixa"> \param[out]  pfpixa   mean values in quadtree</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixQuadtreeMean")> _
Friend Shared Function pixQuadtreeMean(pixs as IntPTR, nlevels as Integer, pix_ma as IntPTR, pfpixa as Object) as Integer
End Function

' SRC\quadtree.c (169, 1)
' pixQuadtreeVariance()
' pixQuadtreeVariance(PIX *, l_int32, PIX *, DPIX *, FPIXA **, FPIXA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The returned fpixav and fpixarv have %nlevels of fpix,
'''  * each containing at the respective levels the variance
'''  * and root variance values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs        8 bpp, no colormap</param>
''' <param name="nlevels"> \param[in]    nlevels     in quadtree</param>
''' <param name="pix_ma"> \param[in]   pix_ma      input mean accumulator; can be null</param>
''' <param name="dpix_msa"> \param[in]   dpix_msa    input mean square accumulator; can be null</param>
''' <param name="pfpixa_v"> \param[out]  pfpixa_v    [optional] variance values in quadtree</param>
''' <param name="pfpixa_rv"> \param[out]  pfpixa_rv   [optional] root variance values in quadtree</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixQuadtreeVariance")> _
Friend Shared Function pixQuadtreeVariance(pixs as IntPTR, nlevels as Integer, pix_ma as IntPTR, dpix_msa as IntPTR, pfpixa_v as Object, pfpixa_rv as Object) as Integer
End Function

' SRC\quadtree.c (265, 1)
' pixMeanInRectangle()
' pixMeanInRectangle(PIX *, BOX *, PIX *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function is intended to be used for many rectangles
'''  * on the same image.  It can find the mean within a
'''  * rectangle in O(1), independent of the size of the rectangle.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     8 bpp</param>
''' <param name="box"> \param[in]    box      region to compute mean value</param>
''' <param name="pixma"> \param[in]    pixma    mean accumulator</param>
''' <param name="pval"> \param[out]   pval     mean value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMeanInRectangle")> _
Friend Shared Function pixMeanInRectangle(pixs as IntPTR, box as IntPTR, pixma as IntPTR, pval as single) as Integer
End Function

' SRC\quadtree.c (341, 1)
' pixVarianceInRectangle()
' pixVarianceInRectangle(PIX *, BOX *, PIX *, DPIX *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function is intended to be used for many rectangles
'''  * on the same image.  It can find the variance and/or the
'''  * square root of the variance within a rectangle in O(1),
'''  * independent of the size of the rectangle.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs        8 bpp</param>
''' <param name="box"> \param[in]    box         region to compute variance and/or root variance</param>
''' <param name="pix_ma"> \param[in]    pix_ma      mean accumulator</param>
''' <param name="dpix_msa"> \param[in]    dpix_msa    mean square accumulator</param>
''' <param name="pvar"> \param[out]   pvar        [optional] variance</param>
''' <param name="prvar"> \param[out]   prvar       [optional] root variance</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixVarianceInRectangle")> _
Friend Shared Function pixVarianceInRectangle(pixs as IntPTR, box as IntPTR, pix_ma as IntPTR, dpix_msa as IntPTR, pvar as single, prvar as single) as Integer
End Function

' SRC\quadtree.c (449, 1)
' boxaaQuadtreeRegions()
' boxaaQuadtreeRegions(l_int32, l_int32, l_int32) as BOXAA *
''' <summary>
''' * Notes:
'''  *   (1) The returned boxaa has %nlevels of boxa, each containing
'''  * the set of rectangles at that level.  The rectangle at
'''  * level 0 is the entire region; at level 1 the region is
'''  * divided into 4 rectangles, and at level n there are n^4
'''  * rectangles.
'''  *   (2) At each level, the rectangles in the boxa are in "raster"
'''  * order, with LR (fast scan) and TB (slow scan).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  baa for quadtree regions at each level, or NULL on error</returns>
''' <param name="w"> \param[in]    w, h     size of pix that is being quadtree-ized</param>
''' <param name="h"> \param[in]    nlevels  number of levels in quadtree</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="boxaaQuadtreeRegions")> _
Friend Shared Function boxaaQuadtreeRegions(w as Integer, h as Integer, nlevels as Integer) as IntPTR
End Function

' SRC\quadtree.c (530, 1)
' quadtreeGetParent()
' quadtreeGetParent(FPIXA *, l_int32, l_int32, l_int32, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Check return value for error.  On error, val is returned as 0.0.
'''  *   (2) The parent is located at:
'''  * level - 1
'''  * (x/2, y/2)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpixa"> \param[in]    fpixa      mean, variance or root variance</param>
''' <param name="level"> \param[in]    level,     x, y of current pixel</param>
''' <param name="x"> \param[out]   pval       parent pixel value, or 0.0 on error</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="quadtreeGetParent")> _
Friend Shared Function quadtreeGetParent(fpixa as IntPTR, level as Integer, x as Integer, y as Integer, pval as single) as Integer
End Function

' SRC\quadtree.c (573, 1)
' quadtreeGetChildren()
' quadtreeGetChildren(FPIXA *, l_int32, l_int32, l_int32, l_float32 *, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Check return value for error.  On error, all return vals are 0.0.
'''  *   (2) The returned child pixels are located at:
'''  * level + 1
'''  * (2x, 2y), (2x+1, 2y), (2x, 2y+1), (2x+1, 2y+1)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fpixa"> \param[in]    fpixa            mean, variance or root variance</param>
''' <param name="level"> \param[in]    level,           x, y of current pixel</param>
''' <param name="x"> \param[out]   pval00, pval01,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="quadtreeGetChildren")> _
Friend Shared Function quadtreeGetChildren(fpixa as IntPTR, level as Integer, x as Integer, y as Integer, pval00 as single, pval10 as single, pval01 as single, pval11 as single) as Integer
End Function

' SRC\quadtree.c (619, 1)
' quadtreeMaxLevels()
' quadtreeMaxLevels(l_int32, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) The criterion for maxlevels is that the subdivision not
'''  * go down below the single pixel level.  The 1.5 factor
'''  * is intended to keep any rectangle from accidentally
'''  * having zero dimension due to integer truncation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  maxlevels maximum number of levels allowed, or -1 on error</returns>
''' <param name="w"> \param[in]    w, h    dimensions of image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="quadtreeMaxLevels")> _
Friend Shared Function quadtreeMaxLevels(w as Integer, h as Integer) as Integer
End Function

' SRC\quadtree.c (654, 1)
' fpixaDisplayQuadtree()
' fpixaDisplayQuadtree(FPIXA *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The mean and root variance fall naturally in the 8 bpp range,
'''  * but the variance is typically outside the range.  This
'''  * function displays 8 bpp pix clipped to 255, so the image
'''  * pixels will mostly be 255 (white).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, mosaic of quadtree images, or NULL on error</returns>
''' <param name="fpixa"> \param[in]    fpixa     mean, variance or root variance</param>
''' <param name="factor"> \param[in]    factor    replication factor at lowest level</param>
''' <param name="fontsize"> \param[in]    fontsize  4, ... 20</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fpixaDisplayQuadtree")> _
Friend Shared Function fpixaDisplayQuadtree(fpixa as IntPTR, factor as Integer, fontsize as Integer) as IntPTR
End Function

#End Region
#Region "SRC\queue.c"
' SRC\queue.c (72, 16)
' lqueueExtendArray()
' lqueueExtendArray(L_QUEUE *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="lq"> \param[in]    lq lqueue</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lqueueExtendArray")> _
Friend Shared Function lqueueExtendArray(lq as IntPTR) as Integer
End Function

' SRC\queue.c (90, 1)
' lqueueCreate()
' lqueueCreate(l_int32) as L_QUEUE *
''' <summary>
''' * Notes:
'''  *   (1) Allocates a ptr array of given size, and initializes counters.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  lqueue, or NULL on error</returns>
''' <param name="nalloc"> \param[in]    nalloc     size of ptr array to be alloc'd; 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lqueueCreate")> _
Friend Shared Function lqueueCreate(nalloc as Integer) as IntPTR
End Function

' SRC\queue.c (131, 1)
' lqueueDestroy()
' lqueueDestroy(L_QUEUE **, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) If freeflag is TRUE, frees each struct in the array.
'''  *   (2) If freeflag is FALSE but there are elements on the array,
'''  * gives a warning and destroys the array.  This will
'''  * cause a memory leak of all the items that were on the queue.
'''  * So if the items require their own destroy function, they
'''  * must be destroyed before the queue.  The same applies to the
'''  * auxiliary stack, if it is used.
'''  *   (3) To destroy the L_Queue, we destroy the ptr array, then
'''  * the lqueue, and then null the contents of the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="plq"> \param[in,out]   plq to be nulled</param>
''' <param name="freeflag"> \param[in]    freeflag TRUE to free each remaining struct in the array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lqueueDestroy")> _
Friend Shared Function lqueueDestroy(plq as Object, freeflag as Integer) as Boolean ' Org. Void
End Function

' SRC\queue.c (187, 1)
' lqueueAdd()
' lqueueAdd(L_QUEUE *, void *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The algorithm is as follows.  If the queue is populated
'''  * to the end of the allocated array, shift all ptrs toward
'''  * the beginning of the array, so that the head of the queue
'''  * is at the beginning of the array.  Then, if the array is
'''  * more than 0.75 full, realloc with double the array size.
'''  * Finally, add the item to the tail of the queue.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="lq"> \param[in]    lq lqueue</param>
''' <param name="item"> \param[in]    item to be added to the tail of the queue</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lqueueAdd")> _
Friend Shared Function lqueueAdd(lq as IntPTR, item as Object) as Integer
End Function

' SRC\queue.c (254, 1)
' lqueueRemove()
' lqueueRemove(L_QUEUE *) as void *
''' <summary>
''' * Notes:
'''  *   (1) If this is the last item on the queue, so that the queue
'''  * becomes empty, nhead is reset to the beginning of the array.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to item popped from the head of the queue,</returns>
''' <param name="lq"> \param[in]    lq lqueue</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lqueueRemove")> _
Friend Shared Function lqueueRemove(lq as IntPTR) as String
End Function

' SRC\queue.c (283, 1)
' lqueueGetCount()
' lqueueGetCount(L_QUEUE *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 on error</returns>
''' <param name="lq"> \param[in]    lq lqueue</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lqueueGetCount")> _
Friend Shared Function lqueueGetCount(lq as IntPTR) as Integer
End Function

' SRC\queue.c (305, 1)
' lqueuePrint()
' lqueuePrint(FILE *, L_QUEUE *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="lq"> \param[in]    lq lqueue</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lqueuePrint")> _
Friend Shared Function lqueuePrint(fp as Object, lq as IntPTR) as Integer
End Function

#End Region
#Region "SRC\rank.c"
' SRC\rank.c (147, 1)
' pixRankFilter()
' pixRankFilter(PIX *, l_int32, l_int32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This defines, for each pixel in pixs, a neighborhood of
'''  * pixels given by a rectangle "centered" on the pixel.
'''  * This set of wf*hf pixels has a distribution of values.
'''  * For each component, if the values are sorted in increasing
'''  * order, we choose the component such that rank*(wf*hf-1)
'''  * pixels have a lower or equal value and
'''  * (1-rank)*(wf*hf-1) pixels have an equal or greater value.
'''  *   (2) See notes in pixRankFilterGray() for further details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd of rank values, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 or 32 bpp; no colormap</param>
''' <param name="wf"> \param[in]    wf, hf  width and height of filter; each is >= 1</param>
''' <param name="hf"> \param[in]    rank in [0.0 ... 1.0]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRankFilter")> _
Friend Shared Function pixRankFilter(pixs as IntPTR, wf as Integer, hf as Integer, rank as single) as IntPTR
End Function

' SRC\rank.c (199, 1)
' pixRankFilterRGB()
' pixRankFilterRGB(PIX *, l_int32, l_int32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This defines, for each pixel in pixs, a neighborhood of
'''  * pixels given by a rectangle "centered" on the pixel.
'''  * This set of wf*hf pixels has a distribution of values.
'''  * For each component, if the values are sorted in increasing
'''  * order, we choose the component such that rank*(wf*hf-1)
'''  * pixels have a lower or equal value and
'''  * (1-rank)*(wf*hf-1) pixels have an equal or greater value.
'''  *   (2) Apply gray rank filtering to each component independently.
'''  *   (3) See notes in pixRankFilterGray() for further details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd of rank values, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="wf"> \param[in]    wf, hf  width and height of filter; each is >= 1</param>
''' <param name="hf"> \param[in]    rank in [0.0 ... 1.0]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRankFilterRGB")> _
Friend Shared Function pixRankFilterRGB(pixs as IntPTR, wf as Integer, hf as Integer, rank as single) as IntPTR
End Function

' SRC\rank.c (267, 1)
' pixRankFilterGray()
' pixRankFilterGray(PIX *, l_int32, l_int32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This defines, for each pixel in pixs, a neighborhood of
'''  * pixels given by a rectangle "centered" on the pixel.
'''  * This set of wf*hf pixels has a distribution of values,
'''  * and if they are sorted in increasing order, we choose
'''  * the pixel such that rank*(wf*hf-1) pixels have a lower
'''  * or equal value and (1-rank)*(wf*hf-1) pixels have an equal
'''  * or greater value.
'''  *   (2) By this definition, the rank = 0.0 pixel has the lowest
'''  * value, and the rank = 1.0 pixel has the highest value.
'''  *   (3) We add mirrored boundary pixels to avoid boundary effects,
'''  * and put the filter center at (0, 0).
'''  *   (4) This dispatches to grayscale erosion or dilation if the
'''  * filter dimensions are odd and the rank is 0.0 or 1.0, rsp.
'''  *   (5) Returns a copy if both wf and hf are 1.
'''  *   (6) Uses row-major or column-major incremental updates to the
'''  * histograms depending on whether hf > wf or hv = wf, rsp.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd of rank values, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp; no colormap</param>
''' <param name="wf"> \param[in]    wf, hf  width and height of filter; each is >= 1</param>
''' <param name="hf"> \param[in]    rank in [0.0 ... 1.0]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRankFilterGray")> _
Friend Shared Function pixRankFilterGray(pixs as IntPTR, wf as Integer, hf as Integer, rank as single) as IntPTR
End Function

' SRC\rank.c (467, 1)
' pixMedianFilter()
' pixMedianFilter(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd of median values, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 or 32 bpp; no colormap</param>
''' <param name="wf"> \param[in]    wf, hf  width and height of filter; each is >= 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixMedianFilter")> _
Friend Shared Function pixMedianFilter(pixs as IntPTR, wf as Integer, hf as Integer) as IntPTR
End Function

' SRC\rank.c (502, 1)
' pixRankFilterWithScaling()
' pixRankFilterWithScaling(PIX *, l_int32, l_int32, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a convenience function that downscales, does
'''  * the rank filtering, and upscales.  Because the down-
'''  * and up-scaling functions are very fast compared to
'''  * rank filtering, the time it takes is reduced from that
'''  * for the simple rank filtering operation by approximately
'''  * the square of the scaling factor.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd of rank values, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 or 32 bpp; no colormap</param>
''' <param name="wf"> \param[in]    wf, hf  width and height of filter; each is >= 1</param>
''' <param name="hf"> \param[in]    rank in [0.0 ... 1.0]</param>
''' <param name="rank"> \param[in]    scalefactor scale factor; must be >= 0.2 and <= 0.7</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRankFilterWithScaling")> _
Friend Shared Function pixRankFilterWithScaling(pixs as IntPTR, wf as Integer, hf as Integer, rank as single, scalefactor as single) as IntPTR
End Function

#End Region
#Region "SRC\rbtree.c"
' SRC\rbtree.c (86, 13)
' 
' destroy_helper(node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="destroy_helper")> _
Friend Shared Function destroy_helper(n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (87, 13)
' 
' count_helper(node *, l_int32 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="count_helper")> _
Friend Shared Function count_helper(n as  L_Rbtree_Node, pcount as Integer) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (88, 13)
' 
' print_tree_helper(FILE *, node *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="print_tree_helper")> _
Friend Shared Function print_tree_helper(fp as Object, n as  L_Rbtree_Node, keytype as Integer, indent as Integer) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (91, 16)
' 
' compareKeys(l_int32, RB_TYPE, RB_TYPE) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="compareKeys")> _
Friend Shared Function compareKeys(keytype as Integer, left as Rb_Type, right as Rb_Type) as Integer
End Function

' SRC\rbtree.c (93, 14)
' 
' grandparent(node *) as node *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="grandparent")> _
Friend Shared Function grandparent(n as  L_Rbtree_Node) as String
End Function

' SRC\rbtree.c (94, 14)
' 
' sibling(node *) as node *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sibling")> _
Friend Shared Function sibling(n as  L_Rbtree_Node) as String
End Function

' SRC\rbtree.c (95, 14)
' 
' uncle(node *) as node *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="uncle")> _
Friend Shared Function uncle(n as  L_Rbtree_Node) as String
End Function

' SRC\rbtree.c (96, 16)
' 
' node_color(node *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="node_color")> _
Friend Shared Function node_color(n as  L_Rbtree_Node) as Integer
End Function

' SRC\rbtree.c (97, 14)
' 
' new_node(RB_TYPE, RB_TYPE, l_int32, node *, node *) as node *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="new_node")> _
Friend Shared Function new_node(key as Rb_Type, value as Rb_Type, node_color as Integer, left as  L_Rbtree_Node, right as  L_Rbtree_Node) as String
End Function

' SRC\rbtree.c (99, 14)
' 
' lookup_node(L_RBTREE *, RB_TYPE) as node *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lookup_node")> _
Friend Shared Function lookup_node(t as IntPTR, key as Rb_Type) as String
End Function

' SRC\rbtree.c (100, 13)
' 
' rotate_left(L_RBTREE *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rotate_left")> _
Friend Shared Function rotate_left(t as IntPTR, n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (101, 13)
' 
' rotate_right(L_RBTREE *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rotate_right")> _
Friend Shared Function rotate_right(t as IntPTR, n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (102, 13)
' 
' replace_node(L_RBTREE *, node *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="replace_node")> _
Friend Shared Function replace_node(t as IntPTR, oldn as  L_Rbtree_Node, newn as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (103, 13)
' 
' insert_case1(L_RBTREE *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="insert_case1")> _
Friend Shared Function insert_case1(t as IntPTR, n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (104, 13)
' 
' insert_case2(L_RBTREE *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="insert_case2")> _
Friend Shared Function insert_case2(t as IntPTR, n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (105, 13)
' 
' insert_case3(L_RBTREE *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="insert_case3")> _
Friend Shared Function insert_case3(t as IntPTR, n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (106, 13)
' 
' insert_case4(L_RBTREE *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="insert_case4")> _
Friend Shared Function insert_case4(t as IntPTR, n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (107, 13)
' 
' insert_case5(L_RBTREE *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="insert_case5")> _
Friend Shared Function insert_case5(t as IntPTR, n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (108, 14)
' 
' maximum_node(node *) as node *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="maximum_node")> _
Friend Shared Function maximum_node(root as  L_Rbtree_Node) as String
End Function

' SRC\rbtree.c (109, 13)
' 
' delete_case1(L_RBTREE *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="delete_case1")> _
Friend Shared Function delete_case1(t as IntPTR, n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (110, 13)
' 
' delete_case2(L_RBTREE *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="delete_case2")> _
Friend Shared Function delete_case2(t as IntPTR, n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (111, 13)
' 
' delete_case3(L_RBTREE *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="delete_case3")> _
Friend Shared Function delete_case3(t as IntPTR, n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (112, 13)
' 
' delete_case4(L_RBTREE *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="delete_case4")> _
Friend Shared Function delete_case4(t as IntPTR, n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (113, 13)
' 
' delete_case5(L_RBTREE *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="delete_case5")> _
Friend Shared Function delete_case5(t as IntPTR, n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (114, 13)
' 
' delete_case6(L_RBTREE *, node *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="delete_case6")> _
Friend Shared Function delete_case6(t as IntPTR, n as  L_Rbtree_Node) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (115, 13)
' 
' verify_properties(L_RBTREE *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="verify_properties")> _
Friend Shared Function verify_properties(t as IntPTR) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (132, 1)
' l_rbtreeCreate()
' l_rbtreeCreate(l_int32) as L_RBTREE *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return      rbtree    container with empty ptr to the root</returns>
''' <param name="keytype"> \param[in]   keytype   defined by an enum for an RB_TYPE union</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_rbtreeCreate")> _
Friend Shared Function l_rbtreeCreate(keytype as Integer) as IntPTR
End Function

' SRC\rbtree.c (154, 1)
' l_rbtreeLookup()
' l_rbtreeLookup(L_RBTREE *, RB_TYPE) as RB_TYPE *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return    &value     a pointer to a union, if the node exists; else NULL</returns>
''' <param name="t"> \param[in]   t        rbtree, including root node</param>
''' <param name="key"> \param[in]   key      find a node with this key</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_rbtreeLookup")> _
Friend Shared Function l_rbtreeLookup(t as IntPTR, key as Rb_Type) as IntPTR
End Function

' SRC\rbtree.c (181, 1)
' l_rbtreeInsert()
' l_rbtreeInsert(L_RBTREE *, RB_TYPE, RB_TYPE) as void
''' <summary>
''' * Notes:
'''  *   (1) If a node with the key already exists, this just updates the value.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return     void</returns>
''' <param name="t"> \param[in]   t         rbtree, including root node</param>
''' <param name="key"> \param[in]   key       insert a node with this key, if the key does not</param>
''' <param name="value"> \param[in]   value     typically an int, used for an index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_rbtreeInsert")> _
Friend Shared Function l_rbtreeInsert(t as IntPTR, key as Rb_Type, value as Rb_Type) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (235, 1)
' l_rbtreeDelete()
' l_rbtreeDelete(L_RBTREE *, RB_TYPE) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return      void</returns>
''' <param name="t"> \param[in]   t     rbtree, including root node</param>
''' <param name="key"> \param[in]   key  (delete the node with this key</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_rbtreeDelete")> _
Friend Shared Function l_rbtreeDelete(t as IntPTR, key as Rb_Type) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (283, 1)
' l_rbtreeDestroy()
' l_rbtreeDestroy(L_RBTREE **) as void
''' <summary>
''' * Notes:
'''  *   (1) Destroys the tree and nulls the input tree ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return      void</returns>
''' <param name="pt"> \param[in]   pt     ptr to rbtree</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_rbtreeDestroy")> _
Friend Shared Function l_rbtreeDestroy(pt as Object) as Boolean ' Org. Void
End Function

' SRC\rbtree.c (318, 1)
' l_rbtreeGetFirst()
' l_rbtreeGetFirst(L_RBTREE *) as L_RBTREE_NODE *
''' <summary>
''' * Notes:
'''  *   (1) This is the first node in an in-order traversal.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return       void</returns>
''' <param name="t"> \param[in]    t    rbtree, including root node</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_rbtreeGetFirst")> _
Friend Shared Function l_rbtreeGetFirst(t as IntPTR) as IntPTR
End Function

' SRC\rbtree.c (353, 1)
' l_rbtreeGetNext()
' l_rbtreeGetNext(L_RBTREE_NODE *) as L_RBTREE_NODE *
''' <summary>
''' * Notes:
'''  *   (1) This finds the next node, in an in-order traversal, from
'''  * the current node.
'''  *   (2) It is useful as an iterator for a map.
'''  *   (3) Call l_rbtreeGetFirst() to get the first node.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return       next node, or NULL if it's the last node</returns>
''' <param name="n"> \param[in]    n     current node</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_rbtreeGetNext")> _
Friend Shared Function l_rbtreeGetNext(n as IntPTR) as IntPTR
End Function

' SRC\rbtree.c (388, 1)
' l_rbtreeGetLast()
' l_rbtreeGetLast(L_RBTREE *) as L_RBTREE_NODE *
''' <summary>
''' * Notes:
'''  *   (1) This is the last node in an in-order traversal.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return      void</returns>
''' <param name="t"> \param[in]   t      rbtree, including root node</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_rbtreeGetLast")> _
Friend Shared Function l_rbtreeGetLast(t as IntPTR) as IntPTR
End Function

' SRC\rbtree.c (423, 1)
' l_rbtreeGetPrev()
' l_rbtreeGetPrev(L_RBTREE_NODE *) as L_RBTREE_NODE *
''' <summary>
''' * Notes:
'''  *   (1) This finds the previous node, in an in-order traversal, from
'''  * the current node.
'''  *   (2) It is useful as an iterator for a map.
'''  *   (3) Call l_rbtreeGetLast() to get the last node.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return       next node, or NULL if it's the first node</returns>
''' <param name="n"> \param[in]    n     current node</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_rbtreeGetPrev")> _
Friend Shared Function l_rbtreeGetPrev(n as IntPTR) as IntPTR
End Function

' SRC\rbtree.c (453, 1)
' l_rbtreeGetCount()
' l_rbtreeGetCount(L_RBTREE *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return     count  the number of nodes in the tree, or 0 on error</returns>
''' <param name="t"> \param[in]  t      rbtree</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_rbtreeGetCount")> _
Friend Shared Function l_rbtreeGetCount(t as IntPTR) as Integer
End Function

' SRC\rbtree.c (486, 1)
' l_rbtreePrint()
' l_rbtreePrint(FILE *, L_RBTREE *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return       void</returns>
''' <param name="fp"> \param[in]    fp    file stream</param>
''' <param name="t"> \param[in]    t     rbtree</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_rbtreePrint")> _
Friend Shared Function l_rbtreePrint(fp as Object, t as IntPTR) as Boolean ' Org. Void
End Function

#End Region
#Region "SRC\readbarcode.c"
' SRC\readbarcode.c (93, 13)
' pixGenerateBarcodeMask()
' pixGenerateBarcodeMask(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For noise removal, 'width' and 'height' are referred to the
'''  * barcode orientation.
'''  *   (2) If there is skew, the mask will not cover the barcode corners.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixm mask over barcodes, or NULL if none found or on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="maxspace"> \param[in]    maxspace largest space in the barcode, in pixels</param>
''' <param name="nwidth"> \param[in]    nwidth opening 'width' to remove noise</param>
''' <param name="nheight"> \param[in]    nheight opening 'height' to remove noise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateBarcodeMask")> _
Friend Shared Function pixGenerateBarcodeMask(pixs as IntPTR, maxspace as Integer, nwidth as Integer, nheight as Integer) as IntPTR
End Function

' SRC\readbarcode.c (95, 14)
' pixAverageRasterScans()
' pixAverageRasterScans(PIX *, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa of average pixel values across image, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs input image; 8 bpp</param>
''' <param name="nscans"> \param[in]    nscans number of adjacent scans, about the center vertically</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAverageRasterScans")> _
Friend Shared Function pixAverageRasterScans(pixs as IntPTR, nscans as Integer) as IntPTR
End Function

' SRC\readbarcode.c (96, 16)
' numaGetCrossingDistances()
' numaGetCrossingDistances(NUMA *, NUMA **, NUMA **, l_float32 *, l_float32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nas"> \param[in]    nas numa of crossing locations</param>
''' <param name="pnaedist"> \param[out]   pnaedist [optional] even distances between crossings</param>
''' <param name="pnaodist"> \param[out]   pnaodist [optional] odd distances between crossings</param>
''' <param name="pmindist"> \param[out]   pmindist [optional] min distance between crossings</param>
''' <param name="pmaxdist"> \param[out]   pmaxdist [optional] max distance between crossings</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetCrossingDistances")> _
Friend Shared Function numaGetCrossingDistances(nas as IntPTR, pnaedist as Object, pnaodist as Object, pmindist as single, pmaxdist as single) as Integer
End Function

' SRC\readbarcode.c (99, 14)
' numaLocatePeakRanges()
' numaLocatePeakRanges(NUMA *, l_float32, l_float32, l_float32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) Units of %minsep are the index into nas.
'''  * This puts useful constraints on peak-finding.
'''  *   (2) If maxmin == 0.0, the value of nas[i] must go to 0.0 (or less)
'''  * between peaks.
'''  *   (3) All calculations are done in units of the index into nas.
'''  * The resulting ranges are therefore integers.
'''  *   (4) The output nad gives pairs of range values for successive peaks.
'''  * Any location [i] for which maxmin = nas[i] = 0.0 will NOT be
'''  * included in a peak range.  This works fine for histograms where
'''  * if nas[i] == 0.0, it means that there are no samples at [i].
'''  *   (5) For barcodes, when this is used on a histogram of barcode
'''  * widths, use maxmin = 0.0.  This requires that there is at
'''  * least one histogram bin corresponding to a width value between
'''  * adjacent peak ranges that is unpopulated, making the separation
'''  * of the histogram peaks unambiguous.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad ranges for each peak found, in pairs, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas numa of histogram of crossing widths</param>
''' <param name="minfirst"> \param[in]    minfirst min location of center of first peak</param>
''' <param name="minsep"> \param[in]    minsep min separation between peak range centers</param>
''' <param name="maxmin"> \param[in]    maxmin max allowed value for min histo value between peaks</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaLocatePeakRanges")> _
Friend Shared Function numaLocatePeakRanges(nas as IntPTR, minfirst as single, minsep as single, maxmin as single) as IntPTR
End Function

' SRC\readbarcode.c (101, 14)
' numaGetPeakCentroids()
' numaGetPeakCentroids(NUMA *, NUMA *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad centroids for each peak found; max of 4, corresponding</returns>
''' <param name="nahist"> \param[in]    nahist numa of histogram of crossing widths</param>
''' <param name="narange"> \param[in]    narange numa of ranges of x-values for the peaks in %nahist</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetPeakCentroids")> _
Friend Shared Function numaGetPeakCentroids(nahist as IntPTR, narange as IntPTR) as IntPTR
End Function

' SRC\readbarcode.c (102, 14)
' numaGetPeakWidthLUT()
' numaGetPeakWidthLUT(NUMA *, NUMA *) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This generates the lookup table that maps from a sequence of widths
'''  * (in some units) to the integerized barcode units (1, 2, 3, 4),
'''  * which are the output integer widths between transitions.
'''  *   (2) The smallest width can be lost in float roundoff.  To avoid
'''  * losing it, we expand the peak range of the smallest width.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nalut lookup table from the width of a bar to one of the four</returns>
''' <param name="narange"> \param[in]    narange numa of x-val ranges for the histogram width peaks</param>
''' <param name="nacent"> \param[in]    nacent numa of centroids of each peak -- up to 4</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaGetPeakWidthLUT")> _
Friend Shared Function numaGetPeakWidthLUT(narange as IntPTR, nacent as IntPTR) as IntPTR
End Function

' SRC\readbarcode.c (103, 16)
' numaEvalBestWidthAndShift()
' numaEvalBestWidthAndShift(NUMA *, l_int32, l_int32, l_float32, l_float32, l_float32 *, l_float32 *, l_float32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This does a linear sweep of widths, evaluating at %nshift
'''  * shifts for each width, finding the (width, shift) pair that
'''  * gives the minimum score.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nas"> \param[in]    nas numa of crossing locations</param>
''' <param name="nwidth"> \param[in]    nwidth number of widths to consider</param>
''' <param name="nshift"> \param[in]    nshift number of shifts to consider for each width</param>
''' <param name="minwidth"> \param[in]    minwidth smallest width to consider</param>
''' <param name="maxwidth"> \param[in]    maxwidth largest width to consider</param>
''' <param name="pbestwidth"> \param[out]   pbestwidth best size of window</param>
''' <param name="pbestshift"> \param[out]   pbestshift best shift for the window</param>
''' <param name="pbestscore"> \param[out]   pbestscore [optional] average squared error of dist</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaEvalBestWidthAndShift")> _
Friend Shared Function numaEvalBestWidthAndShift(nas as IntPTR, nwidth as Integer, nshift as Integer, minwidth as single, maxwidth as single, pbestwidth as single, pbestshift as single, pbestscore as single) as Integer
End Function

' SRC\readbarcode.c (109, 16)
' numaEvalSyncError()
' numaEvalSyncError(NUMA *, l_int32, l_int32, l_float32, l_float32, l_float32 *, NUMA **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) The score is computed only on the part of the signal from the
'''  * %ifirst to %ilast crossings.  Use 0 for both of these to
'''  * use all the crossings.  The score is normalized for
'''  * the number of crossings and with half-width of the window.
'''  *   (2) The optional return %nad is a sequence of 0s and 1s, where a '1'
'''  * indicates a crossing in the window.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nas"> \param[in]    nas numa of crossing locations</param>
''' <param name="ifirst"> \param[in]    ifirst first crossing to use</param>
''' <param name="ilast"> \param[in]    ilast last crossing to use; use 0 for all crossings</param>
''' <param name="width"> \param[in]    width size of window</param>
''' <param name="shift"> \param[in]    shift of center of window w/rt first crossing</param>
''' <param name="pscore"> \param[out]   pscore [optional] average squared error of dist</param>
''' <param name="pnad"> \param[out]   pnad [optional] numa of 1s and 0s for crossings</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaEvalSyncError")> _
Friend Shared Function numaEvalSyncError(nas as IntPTR, ifirst as Integer, ilast as Integer, width as single, shift as single, pscore as single, pnad as Object) as Integer
End Function

' SRC\readbarcode.c (134, 1)
' pixProcessBarcodes()
' pixProcessBarcodes(PIX *, l_int32, l_int32, SARRAY **, l_int32) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sarray text of barcodes, or NULL if none found or on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth</param>
''' <param name="format"> \param[in]    format L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...</param>
''' <param name="method"> \param[in]    method L_USE_WIDTHS, L_USE_WINDOWS</param>
''' <param name="psaw"> \param[out]   psaw [optional] sarray of bar widths</param>
''' <param name="debugflag"> \param[in]    debugflag use 1 to generate debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixProcessBarcodes")> _
Friend Shared Function pixProcessBarcodes(pixs as IntPTR, format as Integer, method as Integer, psaw as Object, debugflag as Integer) as IntPTR
End Function

' SRC\readbarcode.c (182, 1)
' pixExtractBarcodes()
' pixExtractBarcodes(PIX *, l_int32) as PIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa deskewed and cropped barcodes, or NULL if</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, no colormap</param>
''' <param name="debugflag"> \param[in]    debugflag use 1 to generate debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExtractBarcodes")> _
Friend Shared Function pixExtractBarcodes(pixs as IntPTR, debugflag as Integer) as IntPTR
End Function

' SRC\readbarcode.c (254, 1)
' pixReadBarcodes()
' pixReadBarcodes(PIXA *, l_int32, l_int32, SARRAY **, l_int32) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sa sarray of widths, one string for each barcode found,</returns>
''' <param name="pixa"> \param[in]    pixa of 8 bpp deskewed and cropped barcodes</param>
''' <param name="format"> \param[in]    format L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...</param>
''' <param name="method"> \param[in]    method L_USE_WIDTHS, L_USE_WINDOWS;</param>
''' <param name="psaw"> \param[out]   psaw [optional] sarray of bar widths</param>
''' <param name="debugflag"> \param[in]    debugflag use 1 to generate debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadBarcodes")> _
Friend Shared Function pixReadBarcodes(pixa as IntPTR, format as Integer, method as Integer, psaw as Object, debugflag as Integer) as IntPTR
End Function

' SRC\readbarcode.c (335, 1)
' pixReadBarcodeWidths()
' pixReadBarcodeWidths(PIX *, l_int32, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na numa of widths (each in set {1,2,3,4}, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs of 8 bpp deskewed and cropped barcode</param>
''' <param name="method"> \param[in]    method L_USE_WIDTHS, L_USE_WINDOWS;</param>
''' <param name="debugflag"> \param[in]    debugflag use 1 to generate debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadBarcodeWidths")> _
Friend Shared Function pixReadBarcodeWidths(pixs as IntPTR, method as Integer, debugflag as Integer) as IntPTR
End Function

' SRC\readbarcode.c (384, 1)
' pixLocateBarcodes()
' pixLocateBarcodes(PIX *, l_int32, PIX **, PIX **) as BOXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa location of barcodes, or NULL if none found or on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth</param>
''' <param name="thresh"> \param[in]    thresh for binarization of edge filter output; typ. 20</param>
''' <param name="ppixb"> \param[out]   ppixb [optional] binarized edge filtered input image</param>
''' <param name="ppixm"> \param[out]   ppixm [optional] mask over barcodes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixLocateBarcodes")> _
Friend Shared Function pixLocateBarcodes(pixs as IntPTR, thresh as Integer, ppixb as Object, ppixm as Object) as IntPTR
End Function

' SRC\readbarcode.c (500, 1)
' pixDeskewBarcode()
' pixDeskewBarcode(PIX *, PIX *, BOX *, l_int32, l_int32, l_float32 *, l_float32 *) as PIX *
''' <summary>
''' * Notes:
'''  *  (1) The (optional) angle returned is the angle in degrees (cw positive)
'''  *   necessary to rotate the image so that it is deskewed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd deskewed barcode, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs input image; 8 bpp</param>
''' <param name="pixb"> \param[in]    pixb binarized edge-filtered input image</param>
''' <param name="box"> \param[in]    box identified region containing barcode</param>
''' <param name="margin"> \param[in]    margin of extra pixels around box to extract</param>
''' <param name="threshold"> \param[in]    threshold for binarization; ~20</param>
''' <param name="pangle"> \param[out]   pangle [optional] in degrees, clockwise is positive</param>
''' <param name="pconf"> \param[out]   pconf [optional] confidence</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDeskewBarcode")> _
Friend Shared Function pixDeskewBarcode(pixs as IntPTR, pixb as IntPTR, box as IntPTR, margin as Integer, threshold as Integer, pangle as single, pconf as single) as IntPTR
End Function

' SRC\readbarcode.c (626, 1)
' pixExtractBarcodeWidths1()
' pixExtractBarcodeWidths1(PIX *, l_float32, l_float32, NUMA **, NUMA **, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *  (1) The widths are alternating black/white, starting with black
'''  *   and ending with black.
'''  *  (2) This method uses the widths of the bars directly, in terms
'''  *   of the (float) number of pixels between transitions.
'''  *   The histograms of these widths for black and white bars is
'''  *   generated and interpreted.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad numa of barcode widths in encoded integer units,</returns>
''' <param name="pixs"> \param[in]    pixs input image; 8 bpp</param>
''' <param name="thresh"> \param[in]    thresh estimated pixel threshold for crossing</param>
''' <param name="binfract"> \param[in]    binfract histo binsize as a fraction of minsize; e.g., 0.25</param>
''' <param name="pnaehist"> \param[out]   pnaehist [optional] histogram of black widths; NULL ok</param>
''' <param name="pnaohist"> \param[out]   pnaohist [optional] histogram of white widths; NULL ok</param>
''' <param name="debugflag"> \param[in]    debugflag use 1 to generate debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExtractBarcodeWidths1")> _
Friend Shared Function pixExtractBarcodeWidths1(pixs as IntPTR, thresh as single, binfract as single, pnaehist as Object, pnaohist as Object, debugflag as Integer) as IntPTR
End Function

' SRC\readbarcode.c (679, 1)
' pixExtractBarcodeWidths2()
' pixExtractBarcodeWidths2(PIX *, l_float32, l_float32 *, NUMA **, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The widths are alternating black/white, starting with black
'''  * and ending with black.
'''  *   (2) The optional best decoding window width is the width of the window
'''  * that is used to make a decision about whether a transition occurs.
'''  * It is approximately the average width in pixels of the narrowest
'''  * white and black bars (i.e., those corresponding to unit width).
'''  *   (3) The optional return signal %nac is a sequence of 0s, 1s,
'''  * and perhaps a few 2s, giving the number of crossings in each window.
'''  * On the occasion where there is a '2', it is interpreted as
'''  * as ending two runs: the previous one and another one that has length 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad numa of barcode widths in encoded integer units,</returns>
''' <param name="pixs"> \param[in]    pixs input image; 8 bpp</param>
''' <param name="thresh"> \param[in]    thresh estimated pixel threshold for crossing</param>
''' <param name="pwidth"> \param[out]   pwidth [optional] best decoding window width, in pixels</param>
''' <param name="pnac"> \param[out]   pnac [optional] number of transitions in each window</param>
''' <param name="debugflag"> \param[in]    debugflag use 1 to generate debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExtractBarcodeWidths2")> _
Friend Shared Function pixExtractBarcodeWidths2(pixs as IntPTR, thresh as single, pwidth as single, pnac as Object, debugflag as Integer) as IntPTR
End Function

' SRC\readbarcode.c (713, 1)
' pixExtractBarcodeCrossings()
' pixExtractBarcodeCrossings(PIX *, l_float32, l_int32) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa of crossings, in pixel units, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs input image; 8 bpp</param>
''' <param name="thresh"> \param[in]    thresh estimated pixel threshold for crossing</param>
''' <param name="debugflag"> \param[in]    debugflag use 1 to generate debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExtractBarcodeCrossings")> _
Friend Shared Function pixExtractBarcodeCrossings(pixs as IntPTR, thresh as single, debugflag as Integer) as IntPTR
End Function

' SRC\readbarcode.c (837, 1)
' numaQuantizeCrossingsByWidth()
' numaQuantizeCrossingsByWidth(NUMA *, l_float32, NUMA **, NUMA **, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This first computes the histogram of black and white bar widths,
'''  * binned in appropriate units.  There should be well-defined
'''  * peaks, each corresponding to a specific width.  The sequence
'''  * of barcode widths (namely, the integers from the set {1,2,3,4})
'''  * is returned.
'''  *   (2) The optional returned histograms are binned in width units
'''  * that are inversely proportional to %binfract.  For example,
'''  * if %binfract = 0.25, there are 4.0 bins in the distance of
'''  * the width of the narrowest bar.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad sequence of widths, in unit sizes, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas numa of crossing locations, in pixel units</param>
''' <param name="binfract"> \param[in]    binfract histo binsize as a fraction of minsize; e.g., 0.25</param>
''' <param name="pnaehist"> \param[out]   pnaehist [optional] histo of even (black) bar widths</param>
''' <param name="pnaohist"> \param[out]   pnaohist [optional] histo of odd (white) bar widths</param>
''' <param name="debugflag"> \param[in]    debugflag 1 to generate plots of histograms of bar widths</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaQuantizeCrossingsByWidth")> _
Friend Shared Function numaQuantizeCrossingsByWidth(nas as IntPTR, binfract as single, pnaehist as Object, pnaohist as Object, debugflag as Integer) as IntPTR
End Function

' SRC\readbarcode.c (1267, 1)
' numaQuantizeCrossingsByWindow()
' numaQuantizeCrossingsByWindow(NUMA *, l_float32, l_float32 *, l_float32 *, NUMA **, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) The minimum size of the window is set by the minimum
'''  * distance between zero crossings.
'''  *   (2) The optional return signal %nac is a sequence of 0s, 1s,
'''  * and perhaps a few 2s, giving the number of crossings in each window.
'''  * On the occasion where there is a '2', it is interpreted as
'''  * ending two runs: the previous one and another one that has length 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nad sequence of widths, in unit sizes, or NULL on error</returns>
''' <param name="nas"> \param[in]    nas numa of crossing locations</param>
''' <param name="ratio"> \param[in]    ratio of max window size over min window size in search;</param>
''' <param name="pwidth"> \param[out]   pwidth [optional] best window width</param>
''' <param name="pfirstloc"> \param[out]   pfirstloc [optional] center of window for first xing</param>
''' <param name="pnac"> \param[out]   pnac [optional] array of window crossings (0, 1, 2)</param>
''' <param name="debugflag"> \param[in]    debugflag 1 to generate various plots of intermediate results</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="numaQuantizeCrossingsByWindow")> _
Friend Shared Function numaQuantizeCrossingsByWindow(nas as IntPTR, ratio as single, pwidth as single, pfirstloc as single, pnac as Object, debugflag as Integer) as IntPTR
End Function

#End Region
#Region "SRC\readfile.c"
' SRC\readfile.c (123, 1)
' pixaReadFiles()
' pixaReadFiles(const char *, const char *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) %dirname is the full path for the directory.
'''  *   (2) %substr is the part of the file name (excluding
'''  * the directory) that is to be matched.  All matching
'''  * filenames are read into the Pixa.  If substr is NULL,
'''  * all filenames are read into the Pixa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa, or NULL on error</returns>
''' <param name="dirname"> \param[in]    dirname</param>
''' <param name="substr"> \param[in]    substr [optional] substring filter on filenames; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaReadFiles")> _
Friend Shared Function pixaReadFiles(dirname as String, substr as String) as IntPTR
End Function

' SRC\readfile.c (150, 1)
' pixaReadFilesSA()
' pixaReadFilesSA(SARRAY *) as PIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa, or NULL on error</returns>
''' <param name="sa"> \param[in]    sa full pathnames for all files</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaReadFilesSA")> _
Friend Shared Function pixaReadFilesSA(sa as IntPTR) as IntPTR
End Function

' SRC\readfile.c (189, 1)
' pixRead()
' pixRead(const char *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See at top of file for supported formats.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix if OK; NULL on error</returns>
''' <param name="filename"> \param[in]    filename with full pathname or in local directory</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRead")> _
Friend Shared Function pixRead(filename as String) as IntPTR
End Function

' SRC\readfile.c (225, 1)
' pixReadWithHint()
' pixReadWithHint(const char *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The hint is not binding, but may be used to optimize jpeg decoding.
'''  * Use 0 for no hinting.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix if OK; NULL on error</returns>
''' <param name="filename"> \param[in]    filename with full pathname or in local directory</param>
''' <param name="hint"> \param[in]    hint bitwise OR of L_HINT_ values for jpeg; use 0 for no hint</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadWithHint")> _
Friend Shared Function pixReadWithHint(filename as String, hint as Integer) as IntPTR
End Function

' SRC\readfile.c (276, 1)
' pixReadIndexed()
' pixReadIndexed(SARRAY *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function is useful for selecting image files from a
'''  * directory, where the integer %index is embedded into
'''  * the file name.
'''  *   (2) This is typically done by generating the sarray using
'''  * getNumberedPathnamesInDirectory(), so that the %index
'''  * pathname would have the number %index in it.  The size
'''  * of the sarray should be the largest number (plus 1) appearing
'''  * in the file names, respecting the constraints in the
'''  * call to getNumberedPathnamesInDirectory().
'''  *   (3) Consequently, for some indices into the sarray, there may
'''  * be no pathnames in the directory containing that number.
'''  * By convention, we place empty C strings ("") in those
'''  * locations in the sarray, and it is not an error if such
'''  * a string is encountered and no pix is returned.
'''  * Therefore, the caller must verify that a pix is returned.
'''  *   (4) See convertSegmentedPagesToPS() in src/psio1.c for an
'''  * example of usage.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix if OK; null if not found</returns>
''' <param name="sa"> \param[in]    sa string array of full pathnames</param>
''' <param name="index"> \param[in]    index into pathname array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadIndexed")> _
Friend Shared Function pixReadIndexed(sa as IntPTR, index as Integer) as IntPTR
End Function

' SRC\readfile.c (317, 1)
' pixReadStream()
' pixReadStream(FILE *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The hint only applies to jpeg.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix if OK; NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="hint"> \param[in]    hint bitwise OR of L_HINT_ values for jpeg; use 0 for no hint</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadStream")> _
Friend Shared Function pixReadStream(fp as Object, hint as Integer) as IntPTR
End Function

' SRC\readfile.c (431, 1)
' pixReadHeader()
' pixReadHeader(const char *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This reads the actual headers for jpeg, png, tiff and pnm.
'''  * For bmp and gif, we cheat and read the entire file into a pix,
'''  * from which we extract the "header" information.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename with full pathname or in local directory</param>
''' <param name="pformat"> \param[out]   pformat [optional] file format</param>
''' <param name="pw"> \param[out]   pw, ph [optional] width and height</param>
''' <param name="ph"> \param[out]   pbps [optional] bits/sample</param>
''' <param name="pbps"> \param[out]   pspp [optional] samples/pixel 1, 3 or 4</param>
''' <param name="pspp"> \param[out]   piscmap [optional] 1 if cmap exists; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadHeader")> _
Friend Shared Function pixReadHeader(filename as String, pformat as Integer, pw as Integer, ph as Integer, pbps as Integer, pspp as Integer, piscmap as Integer) as Integer
End Function

' SRC\readfile.c (568, 1)
' findFileFormat()
' findFileFormat(const char *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if format is not recognized</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pformat"> \param[out]   pformat    found format</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="findFileFormat")> _
Friend Shared Function findFileFormat(filename as String, pformat as Integer) as Integer
End Function

' SRC\readfile.c (603, 1)
' findFileFormatStream()
' findFileFormatStream(FILE *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Important: Side effect -- this resets fp to BOF.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if format is not recognized</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="pformat"> \param[out]   pformat found format</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="findFileFormatStream")> _
Friend Shared Function findFileFormatStream(fp as Object, pformat as Integer) as Integer
End Function

' SRC\readfile.c (654, 1)
' findFileFormatBuffer()
' findFileFormatBuffer(const l_uint8 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This determines the file format from the first 12 bytes in
'''  * the compressed data stream, which are stored in memory.
'''  *   (2) For tiff files, this returns IFF_TIFF.  The specific tiff
'''  * compression is then determined using findTiffCompression().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if format is not recognized</returns>
''' <param name="buf"> \param[in]    buf byte buffer at least 12 bytes in size; we can't check</param>
''' <param name="pformat"> \param[out]   pformat found format</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="findFileFormatBuffer")> _
Friend Shared Function findFileFormatBuffer(buf as Byte, pformat as Integer) as Integer
End Function

' SRC\readfile.c (783, 1)
' fileFormatIsTiff()
' fileFormatIsTiff(FILE *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if file is tiff; 0 otherwise or on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fileFormatIsTiff")> _
Friend Shared Function fileFormatIsTiff(fp as Object) as Integer
End Function

' SRC\readfile.c (827, 1)
' pixReadMem()
' pixReadMem(const l_uint8 *, size_t) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a variation of pixReadStream(), where the data is read
'''  * from a memory buffer rather than a file.
'''  *   (2) On windows, this only reads tiff formatted files directly from
'''  * memory.  For other formats, it writes to a temp file and
'''  * decompresses from file.
'''  *   (3) findFileFormatBuffer() requires up to 12 bytes to decide on
'''  * the format.  That determines the constraint here.  But in
'''  * fact the data must contain the entire compressed string for
'''  * the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="data"> \param[in]    data const; encoded</param>
''' <param name="size"> \param[in]    size size of data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadMem")> _
Friend Shared Function pixReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\readfile.c (948, 1)
' pixReadHeaderMem()
' pixReadHeaderMem(const l_uint8 *, size_t, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This reads the actual headers for jpeg, png, tiff, jp2k and pnm.
'''  * For bmp and gif, we cheat and read all the data into a pix,
'''  * from which we extract the "header" information.
'''  *   (2) The amount of data required depends on the format.  For
'''  * png, it requires less than 30 bytes, but for jpeg it can
'''  * require most of the compressed file.  In practice, the data
'''  * is typically the entire compressed file in memory.
'''  *   (3) findFileFormatBuffer() requires up to 8 bytes to decide on
'''  * the format, which we require.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="data"> \param[in]    data const; encoded</param>
''' <param name="size"> \param[in]    size size of data</param>
''' <param name="pformat"> \param[out]   pformat [optional] image format</param>
''' <param name="pw"> \param[out]   pw, ph [optional] width and height</param>
''' <param name="ph"> \param[out]   pbps [optional] bits/sample</param>
''' <param name="pbps"> \param[out]   pspp [optional] samples/pixel 1, 3 or 4</param>
''' <param name="pspp"> \param[out]   piscmap [optional] 1 if cmap exists; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadHeaderMem")> _
Friend Shared Function pixReadHeaderMem(data as Byte, size as ULong, pformat as Integer, pw as Integer, ph as Integer, pbps as Integer, pspp as Integer, piscmap as Integer) as Integer
End Function

' SRC\readfile.c (1094, 1)
' writeImageFileInfo()
' writeImageFileInfo(const char *, FILE *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If headeronly == 0 and the image has spp == 4,this will
'''  * also call pixDisplayLayersRGBA() to display the image
'''  * in three views.
'''  *   (2) This is a debug function that changes the value of
'''  * var_PNG_STRIP_16_TO_8 to 1 (the default).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="filename"> \param[in]    filename    input file</param>
''' <param name="fpout"> \param[in]    fpout       output file stream</param>
''' <param name="headeronly"> \param[in]    headeronly  1 to read only the header; 0 to read both</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="writeImageFileInfo")> _
Friend Shared Function writeImageFileInfo(filename as String, fpout as Object, headeronly as Integer) as Integer
End Function

' SRC\readfile.c (1262, 1)
' ioFormatTest()
' ioFormatTest(const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This writes and reads a set of output files losslessly
'''  * in different formats to /tmp/format/, and tests that the
'''  * result before and after is unchanged.
'''  *   (2) This should work properly on input images of any depth,
'''  * with and without colormaps.
'''  *   (3) All supported formats are tested for bmp, png, tiff and
'''  * non-ascii pnm.  Ascii pnm also works (but who'd ever want
'''  * to use it?)   We allow 2 bpp bmp, although it's not
'''  * supported elsewhere.  And we don't support reading
'''  * 16 bpp png, although this can be turned on in pngio.c.
'''  *   (4) This silently skips png or tiff testing if HAVE_LIBPNG
'''  * or HAVE_LIBTIFF are 0, respectively.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error or if the test fails</returns>
''' <param name="filename"> \param[in]    filename input file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="ioFormatTest")> _
Friend Shared Function ioFormatTest(filename as String) as Integer
End Function

#End Region
#Region "SRC\recogbasic.c"
' SRC\recogbasic.c (204, 16)
' recogGetCharsetSize()
' recogGetCharsetSize(l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  size of charset, or 0 if unknown or on error</returns>
''' <param name="type"> \param[in]    type of charset</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogGetCharsetSize")> _
Friend Shared Function recogGetCharsetSize(type as Integer) as Integer
End Function

' SRC\recogbasic.c (205, 16)
' recogAddCharstrLabels()
' recogAddCharstrLabels(L_RECOG *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogAddCharstrLabels")> _
Friend Shared Function recogAddCharstrLabels(recog as IntPTR) as Integer
End Function

' SRC\recogbasic.c (206, 16)
' recogAddAllSamples()
' recogAddAllSamples(L_RECOG **, PIXAA *, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) On error, the input recog is destroyed.
'''  *   (2) This is used with the serialization routine recogRead(),
'''  * where each pixa in the pixaa represents a set of characters
'''  * in a different class.  Before calling this function, we have
'''  * verified that the number of character classes, given by the
'''  * setsize field in %recog, equals the number of pixa in the paa.
'''  * The character labels for each set are in the sa_text field.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="precog"> \param[in]    precog  addr of recog</param>
''' <param name="paa"> \param[in]    paa     pixaa from previously trained recog</param>
''' <param name="debug"> \param[in]    debug</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogAddAllSamples")> _
Friend Shared Function recogAddAllSamples(precog as Object, paa as IntPTR, debug as Integer) as Integer
End Function

' SRC\recogbasic.c (232, 1)
' recogCreateFromRecog()
' recogCreateFromRecog(L_RECOG *, l_int32, l_int32, l_int32, l_int32, l_int32) as L_RECOG *
''' <summary>
''' * Notes:
'''  *   (1) This is a convenience function that generates a recog using
'''  * the unscaled training data in an existing recog.
'''  *   (2) It is recommended to use %maxyshift = 1 (the default value)
'''  *   (3) See recogCreate() for use of %scalew, %scaleh and %linew.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  recd, or NULL on error</returns>
''' <param name="recs"> \param[in]    recs source recog with arbitrary input parameters</param>
''' <param name="scalew"> \param[in]    scalew  scale all widths to this; use 0 otherwise</param>
''' <param name="scaleh"> \param[in]    scaleh  scale all heights to this; use 0 otherwise</param>
''' <param name="linew"> \param[in]    linew   width of normalized strokes; use 0 to skip</param>
''' <param name="threshold"> \param[in]    threshold for binarization; typically ~128</param>
''' <param name="maxyshift"> \param[in]    maxyshift from nominal centroid alignment; default is 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogCreateFromRecog")> _
Friend Shared Function recogCreateFromRecog(recs as IntPTR, scalew as Integer, scaleh as Integer, linew as Integer, threshold as Integer, maxyshift as Integer) as IntPTR
End Function

' SRC\recogbasic.c (279, 1)
' recogCreateFromPixa()
' recogCreateFromPixa(PIXA *, l_int32, l_int32, l_int32, l_int32, l_int32) as L_RECOG *
''' <summary>
''' * Notes:
'''  *   (1) This is a convenience function for training from labeled data.
'''  * The pixa can be read from file.
'''  *   (2) The pixa should contain the unscaled bitmaps used for training.
'''  *   (3) See recogCreate() for use of %scalew, %scaleh and %linew.
'''  *   (4) It is recommended to use %maxyshift = 1 (the default value)
'''  *   (5) All examples in the same class (i.e., with the same character
'''  * label) should be similar.  They can be made similar by invoking
'''  * recogRemoveOutliers[1,2]() on %pixa before calling this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  recog, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa of labeled, 1 bpp images</param>
''' <param name="scalew"> \param[in]    scalew  scale all widths to this; use 0 otherwise</param>
''' <param name="scaleh"> \param[in]    scaleh  scale all heights to this; use 0 otherwise</param>
''' <param name="linew"> \param[in]    linew   width of normalized strokes; use 0 to skip</param>
''' <param name="threshold"> \param[in]    threshold for binarization; typically ~150</param>
''' <param name="maxyshift"> \param[in]    maxyshift from nominal centroid alignment; default is 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogCreateFromPixa")> _
Friend Shared Function recogCreateFromPixa(pixa as IntPTR, scalew as Integer, scaleh as Integer, linew as Integer, threshold as Integer, maxyshift as Integer) as IntPTR
End Function

' SRC\recogbasic.c (325, 1)
' recogCreateFromPixaNoFinish()
' recogCreateFromPixaNoFinish(PIXA *, l_int32, l_int32, l_int32, l_int32, l_int32) as L_RECOG *
''' <summary>
''' * Notes:
'''  *   (1) See recogCreateFromPixa() for details.
'''  *   (2) This is also used to generate a pixaa with templates
'''  * in each class within a pixa.  For that, all args except for
'''  * %pixa are ignored.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  recog, or NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa of labeled, 1 bpp images</param>
''' <param name="scalew"> \param[in]    scalew  scale all widths to this; use 0 otherwise</param>
''' <param name="scaleh"> \param[in]    scaleh  scale all heights to this; use 0 otherwise</param>
''' <param name="linew"> \param[in]    linew   width of normalized strokes; use 0 to skip</param>
''' <param name="threshold"> \param[in]    threshold for binarization; typically ~150</param>
''' <param name="maxyshift"> \param[in]    maxyshift from nominal centroid alignment; default is 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogCreateFromPixaNoFinish")> _
Friend Shared Function recogCreateFromPixaNoFinish(pixa as IntPTR, scalew as Integer, scaleh as Integer, linew as Integer, threshold as Integer, maxyshift as Integer) as IntPTR
End Function

' SRC\recogbasic.c (406, 1)
' recogCreate()
' recogCreate(l_int32, l_int32, l_int32, l_int32, l_int32) as L_RECOG *
''' <summary>
''' * Notes:
'''  *   (1) If %scalew == 0 and %scaleh == 0, no scaling is done.
'''  * If one of these is 0 and the other is > 0, scaling is isotropic
'''  * to the requested size.  We typically do not set both > 0.
'''  *   (2) Use linew > 0 to convert the templates to images with fixed
'''  * width strokes.  linew == 0 skips the conversion.
'''  *   (3) The only valid values for %maxyshift are 0, 1 and 2.
'''  * It is recommended to use %maxyshift == 1 (default value).
'''  * Using %maxyshift == 0 is much faster than %maxyshift == 1, but
'''  * it is much less likely to find the template with the best
'''  * correlation.  Use of anything but 1 results in a warning.
'''  *   (4) Scaling is used for finding outliers and for training a
'''  * book-adapted recognizer (BAR) from a bootstrap recognizer (BSR).
'''  * Scaling the height to a fixed value and scaling the width
'''  * accordingly (e.g., %scaleh = 40, %scalew = 0) is recommended.
'''  *   (5) The storage for most of the arrays is allocated when training
'''  * is finished.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  recog, or NULL on error</returns>
''' <param name="scalew"> \param[in]    scalew  scale all widths to this; use 0 otherwise</param>
''' <param name="scaleh"> \param[in]    scaleh  scale all heights to this; use 0 otherwise</param>
''' <param name="linew"> \param[in]    linew   width of normalized strokes; use 0 to skip</param>
''' <param name="threshold"> \param[in]    threshold for binarization; typically ~128; 0 for default</param>
''' <param name="maxyshift"> \param[in]    maxyshift from nominal centroid alignment; default is 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogCreate")> _
Friend Shared Function recogCreate(scalew as Integer, scaleh as Integer, linew as Integer, threshold as Integer, maxyshift as Integer) as IntPTR
End Function

' SRC\recogbasic.c (476, 1)
' recogDestroy()
' recogDestroy(L_RECOG **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="precog"> \param[in,out]   precog will be set to null before returning</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogDestroy")> _
Friend Shared Function recogDestroy(precog as Object) as Boolean ' Org. Void
End Function

' SRC\recogbasic.c (529, 1)
' recogGetCount()
' recogGetCount(L_RECOG *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count of classes in recog; 0 if no recog or on error</returns>
''' <param name="recog"> \param[in]    recog</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogGetCount")> _
Friend Shared Function recogGetCount(recog as IntPTR) as Integer
End Function

' SRC\recogbasic.c (567, 1)
' recogSetParams()
' recogSetParams(L_RECOG *, l_int32, l_int32, l_float32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is called when a recog is created.
'''  *   (2) Default %min_nopad value allows for some padding.
'''  * To disable padding, set %min_nopad = 0.  To pad only when
'''  * no samples are available for the class, set %min_nopad = 1.
'''  *   (3) The %max_wh_ratio limits the width/height ratio for components
'''  * that we attempt to split.  Splitting long components is expensive.
'''  *   (4) The %max_ht_ratio is a quality requirement on the training data.
'''  * The recognizer will not run if the averages are computed and
'''  * the templates do not satisfy it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return       0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog         to be padded, if necessary</param>
''' <param name="type"> \param[in]    type          type of char set; -1 for default;</param>
''' <param name="min_nopad"> \param[in]    min_nopad     min number in a class without padding;</param>
''' <param name="max_wh_ratio"> \param[in]    max_wh_ratio  max width/height ratio allowed for splitting;</param>
''' <param name="max_ht_ratio"> \param[in]    max_ht_ratio  max of max/min averaged template height ratio;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogSetParams")> _
Friend Shared Function recogSetParams(recog as IntPTR, type as Integer, min_nopad as Integer, max_wh_ratio as single, max_ht_ratio as single) as Integer
End Function

' SRC\recogbasic.c (650, 1)
' recogGetClassIndex()
' recogGetClassIndex(L_RECOG *, l_int32, char *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This is used during training.  There is one entry in
'''  * recog->dna_tochar (integer value, e.g., ascii) and
'''  * one in recog->sa_text (e.g, ascii letter in a string)
'''  * for each character class.
'''  *   (2) This searches the dna character array for %val.  If it is
'''  * not found, the template represents a character class not
'''  * already seen: it increments setsize (the number of character
'''  * classes) by 1, and augments both the index (dna_tochar)
'''  * and text (sa_text) arrays.
'''  *   (3) Returns the index in &index, except on error.
'''  *   (4) Caller must check the function return value.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if found; 1 if not found and added; 2 on error.</returns>
''' <param name="recog"> \param[in]    recog with LUT's pre-computed</param>
''' <param name="val"> \param[in]    val integer value; can be up to 3 bytes for UTF-8</param>
''' <param name="text"> \param[in]    text text from which %val was derived; used if not found</param>
''' <param name="pindex"> \param[out]   pindex index into dna_tochar</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogGetClassIndex")> _
Friend Shared Function recogGetClassIndex(recog as IntPTR, val as Integer, text as Object, pindex as Integer) as Integer
End Function

' SRC\recogbasic.c (695, 1)
' recogStringToIndex()
' recogStringToIndex(L_RECOG *, char *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error not finding the string is an error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="text"> \param[in]    text text string for some class</param>
''' <param name="pindex"> \param[out]   pindex index for that class; -1 if not found</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogStringToIndex")> _
Friend Shared Function recogStringToIndex(recog as IntPTR, text as Object, pindex as Integer) as Integer
End Function

' SRC\recogbasic.c (748, 1)
' recogGetClassString()
' recogGetClassString(L_RECOG *, l_int32, char **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Extracts a copy of the string from sa_text, which
'''  * the caller must free.
'''  *   (2) Caller must check the function return value.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if found, 1 on error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="index"> \param[in]    index into array of char types</param>
''' <param name="pcharstr"> \param[out]   pcharstr string representation;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogGetClassString")> _
Friend Shared Function recogGetClassString(recog as IntPTR, index as Integer, pcharstr as String) as Integer
End Function

' SRC\recogbasic.c (778, 1)
' l_convertCharstrToInt()
' l_convertCharstrToInt(const char *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="str"> \param[in]    str input string representing one UTF-8 character;</param>
''' <param name="pval"> \param[out]   pval integer value for the input.  Think of it</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_convertCharstrToInt")> _
Friend Shared Function l_convertCharstrToInt(str as String, pval as Integer) as Integer
End Function

' SRC\recogbasic.c (837, 1)
' recogRead()
' recogRead(const char *) as L_RECOG *
''' <summary>
''' * Notes:
'''  *   (1) When a recog is serialized, a pixaa of the templates that are
'''  * actually used for correlation is saved in the pixaa_u array
'''  * of the recog.  These can be different from the templates that
'''  * were used to generate the recog, because those original templates
'''  * can be scaled and turned into normalized lines.  When recog1
'''  * is deserialized to recog2, these templates are put in both the
'''  * unscaled array (pixaa_u) and the modified array (pixaa) in recog2.
'''  * Why not put it in only the unscaled array and let
'''  * recogTrainingFinalized() regenerate the modified templates?
'''  * The reason is that with normalized lines, the operation of
'''  * thinning to a skeleton and dilating back to a fixed width
'''  * is not idempotent.  Thinning to a skeleton saves pixels at
'''  * the end of a line segment, and thickening the skeleton puts
'''  * additional pixels at the end of the lines.  This tends to
'''  * close gaps.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  recog, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogRead")> _
Friend Shared Function recogRead(filename as String) as IntPTR
End Function

' SRC\recogbasic.c (866, 1)
' recogReadStream()
' recogReadStream(FILE *) as L_RECOG *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  recog, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogReadStream")> _
Friend Shared Function recogReadStream(fp as Object) as IntPTR
End Function

' SRC\recogbasic.c (951, 1)
' recogReadMem()
' recogReadMem(const l_uint8 *, size_t) as L_RECOG *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  recog, or NULL on error</returns>
''' <param name="data"> \param[in]    data  serialization of recog (not ascii)</param>
''' <param name="size"> \param[in]    size  of data in bytes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogReadMem")> _
Friend Shared Function recogReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\recogbasic.c (988, 1)
' recogWrite()
' recogWrite(const char *, L_RECOG *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The pixaa of templates that is written is the modified one
'''  * in the pixaa field. It is the pixaa that is actually used
'''  * for correlation. This is not the unscaled array of labeled
'''  * bitmaps, in pixaa_u, that was used to generate the recog in the
'''  * first place.  See the notes in recogRead() for the rationale.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="recog"> \param[in]    recog</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogWrite")> _
Friend Shared Function recogWrite(filename as String, recog as IntPTR) as Integer
End Function

' SRC\recogbasic.c (1019, 1)
' recogWriteStream()
' recogWriteStream(FILE *, L_RECOG *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream opened for "wb"</param>
''' <param name="recog"> \param[in]    recog</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogWriteStream")> _
Friend Shared Function recogWriteStream(fp as Object, recog as IntPTR) as Integer
End Function

' SRC\recogbasic.c (1060, 1)
' recogWriteMem()
' recogWriteMem(l_uint8 **, size_t *, L_RECOG *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a recog in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of serialized recog (not ascii)</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="recog"> \param[in]    recog</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogWriteMem")> _
Friend Shared Function recogWriteMem(pdata as Object, psize as ULong, recog as IntPTR) as Integer
End Function

' SRC\recogbasic.c (1114, 1)
' recogExtractPixa()
' recogExtractPixa(L_RECOG *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This generates a pixa of all the unscaled images in the
'''  * recognizer, where each one has its character class label in
'''  * the pix text field, by flattening pixaa_u to a pixa.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa if OK, NULL on error</returns>
''' <param name="recog"> \param[in]   recog</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogExtractPixa")> _
Friend Shared Function recogExtractPixa(recog as IntPTR) as IntPTR
End Function

#End Region
#Region "SRC\recogdid.c"
' SRC\recogdid.c (160, 16)
' recogPrepareForDecoding()
' recogPrepareForDecoding(L_RECOG *, PIX *, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Binarizes and crops input %pixs.
'''  *   (2) Removes previous L_RDID struct and makes a new one.
'''  *   (3) Generates the bit-and sum arrays for each character template
'''  * at each pixel position in %pixs.  These are used in the
'''  * Viterbi dynamic programming step.
'''  *   (4) The values are saved in the scoring arrays at the left edge
'''  * of the template.  They are used in the Viterbi process
'''  * at the setwidth position (which is near the RHS of the template
'''  * as it is positioned on pixs) in the generated trellis.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog with LUT's pre-computed</param>
''' <param name="pixs"> \param[in]    pixs typically of multiple touching characters, 1 bpp</param>
''' <param name="debug"> \param[in]    debug 1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogPrepareForDecoding")> _
Friend Shared Function recogPrepareForDecoding(recog as IntPTR, pixs as IntPTR, debug as Integer) as Integer
End Function

' SRC\recogdid.c (162, 16)
' recogMakeDecodingArray()
' recogMakeDecodingArray(L_RECOG *, l_int32, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Generates the bit-and sum array for a character template along pixs.
'''  *   (2) The values are saved in the scoring arrays at the left edge
'''  * of the template as it is positioned on pixs.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="index"> \param[in]    index of averaged template</param>
''' <param name="debug"> \param[in]    debug 1 for debug output; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogMakeDecodingArray")> _
Friend Shared Function recogMakeDecodingArray(recog as IntPTR, index as Integer, debug as Integer) as Integer
End Function

' SRC\recogdid.c (164, 16)
' recogRunViterbi()
' recogRunViterbi(L_RECOG *, PIX **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This can be used when the templates are unscaled.  It works by
'''  * matching the average, unscaled templates of each class to
'''  * all positions.
'''  *   (2) It is recursive, in that
'''  * (a) we compute the score successively at all pixel positions x,
'''  * (b) to compute the score at x in the trellis, for each
'''  *  template we look backwards to (x - setwidth) to get the
'''  *  score if that template were to be printed with its
'''  *  setwidth location at x.  We save at x the template and
'''  *  score that maximizes the sum of the score at (x - setwidth)
'''  *  and the log-likelihood for the template to be printed with
'''  *  its LHS there.
'''  *   (3) The primary output is a boxa of the locations for splitting
'''  * the input image.  These locations are used later to split the
'''  * image and send the pieces individually for recognition.
'''  * This can be done in either recogIdentifyMultiple(), or
'''  * for debugging in recogRescoreDidResult().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog with LUT's pre-computed</param>
''' <param name="ppixdb"> \param[out]   ppixdb [optional] debug result; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogRunViterbi")> _
Friend Shared Function recogRunViterbi(recog as IntPTR, ppixdb as Object) as Integer
End Function

' SRC\recogdid.c (165, 16)
' recogRescoreDidResult()
' recogRescoreDidResult(L_RECOG *, PIX **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This does correlation matching with all unscaled templates,
'''  * using the character segmentation determined by the Viterbi path.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog with LUT's pre-computed</param>
''' <param name="ppixdb"> \param[out]   ppixdb [optional] debug result; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogRescoreDidResult")> _
Friend Shared Function recogRescoreDidResult(recog as IntPTR, ppixdb as Object) as Integer
End Function

' SRC\recogdid.c (166, 13)
' recogShowPath()
' recogShowPath(L_RECOG *, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix debug output), or NULL on error</returns>
''' <param name="recog"> \param[in]    recog with LUT's pre-computed</param>
''' <param name="_select_"> \param[in]    select 0 for Viterbi; 1 for rescored</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogShowPath")> _
Friend Shared Function recogShowPath(recog as IntPTR, _select_ as Integer) as IntPTR
End Function

' SRC\recogdid.c (167, 16)
' recogGetWindowedArea()
' recogGetWindowedArea(L_RECOG *, l_int32, l_int32, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This is called after the best path has been found through
'''  * the trellis, in order to produce a correlation that can be used
'''  * to evaluate the confidence we have in the identification.
'''  * The correlation is |1 & 2|^2 / (|1| * |2|).
'''  * |1 & 2| is given by the count array, |2| is found from
'''  * nasum_u[], and |1| is wsum returned from this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="index"> \param[in]    index of template</param>
''' <param name="x"> \param[in]    x pixel position of left hand edge of template</param>
''' <param name="pdely"> \param[out]   pdely y shift of template relative to pix1</param>
''' <param name="pwsum"> \param[out]   pwsum number of fg pixels in window of pixs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogGetWindowedArea")> _
Friend Shared Function recogGetWindowedArea(recog as IntPTR, index as Integer, x as Integer, pdely as Integer, pwsum as Integer) as Integer
End Function

' SRC\recogdid.c (169, 16)
' recogTransferRchToDid()
' recogTransferRchToDid(L_RECOG *, l_int32, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This is used to transfer the results for a single character match
'''  * to the rescored did arrays.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog with rch and did defined</param>
''' <param name="x"> \param[in]    x left edge of extracted region, relative to decoded line</param>
''' <param name="y"> \param[in]    y top edge of extracted region, relative to input image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogTransferRchToDid")> _
Friend Shared Function recogTransferRchToDid(recog as IntPTR, x as Integer, y as Integer) as Integer
End Function

' SRC\recogdid.c (215, 1)
' recogDecode()
' recogDecode(L_RECOG *, PIX *, l_int32, PIX **) as BOXA *
''' <summary>
''' * Notes:
'''  *   (1) The input pixs has been filtered so that it is likely to be
'''  * composed of more than one touching character.  Specifically,
'''  * its height can only slightly exceed that of the tallest
'''  * unscaled template, the width is somewhat larger than the
'''  * width of the widest unscaled template, and the w/h aspect ratio
'''  * is bounded by max_wh_ratio.
'''  *   (2) This uses the DID mechanism with labeled templates to
'''  * segment the input %pixs.  The resulting segmentation is
'''  * returned.  (It is given by did->boxa).
'''  *   (3) In debug mode, the Viterbi path is rescored based on all
'''  * the templates.  In non-debug mode, the same procedure is
'''  * carried out by recogIdentifyPix() on the result of the
'''  * segmentation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  boxa  segmentation of pixs into characters, or NULL on error</returns>
''' <param name="recog"> \param[in]    recog with LUT's pre-computed</param>
''' <param name="pixs"> \param[in]    pixs typically of multiple touching characters, 1 bpp</param>
''' <param name="nlevels"> \param[in]    nlevels of templates; 2 for now</param>
''' <param name="ppixdb"> \param[out]   ppixdb [optional] debug result; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogDecode")> _
Friend Shared Function recogDecode(recog as IntPTR, pixs as IntPTR, nlevels as Integer, ppixdb as Object) as IntPTR
End Function

' SRC\recogdid.c (747, 1)
' recogCreateDid()
' recogCreateDid(L_RECOG *, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="pixs"> \param[in]    pixs of 1 bpp image to match</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogCreateDid")> _
Friend Shared Function recogCreateDid(recog as IntPTR, pixs as IntPTR) as Integer
End Function

' SRC\recogdid.c (818, 1)
' recogDestroyDid()
' recogDestroyDid(L_RECOG *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) As the signature indicates, this is owned by the recog, and can
'''  * only be destroyed using this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogDestroyDid")> _
Friend Shared Function recogDestroyDid(recog as IntPTR) as Integer
End Function

' SRC\recogdid.c (874, 1)
' recogDidExists()
' recogDidExists(L_RECOG *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if recog->did exists; 0 if not or on error.</returns>
''' <param name="recog"> \param[in]    recog</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogDidExists")> _
Friend Shared Function recogDidExists(recog as IntPTR) as Integer
End Function

' SRC\recogdid.c (896, 1)
' recogGetDid()
' recogGetDid(L_RECOG *) as L_RDID *
''' <summary>
''' * Notes:
'''  *   (1) This also makes sure the arrays are defined.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  did still owned by the recog, or NULL on error</returns>
''' <param name="recog"> \param[in]    recog</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogGetDid")> _
Friend Shared Function recogGetDid(recog as IntPTR) as IntPTR
End Function

' SRC\recogdid.c (1005, 1)
' recogSetChannelParams()
' recogSetChannelParams(L_RECOG *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This converts the independent bit-flip probabilities in the
'''  * "channel" into log-likelihood coefficients on image sums.
'''  * These coefficients are only defined for the non-background
'''  * template levels.  Thus for nlevels = 2 (one fg, one bg),
'''  * only beta[1] and gamma[1] are used.  For nlevels = 4 (three
'''  * fg templates), we use beta[1-3] and gamma[1-3].
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="nlevels"> \param[in]    nlevels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogSetChannelParams")> _
Friend Shared Function recogSetChannelParams(recog as IntPTR, nlevels as Integer) as Integer
End Function

#End Region
#Region "SRC\recogident.c"
' SRC\recogident.c (110, 16)
' pixCorrelationBestShift()
' pixCorrelationBestShift(PIX *, PIX *, NUMA *, NUMA *, l_int32, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *, l_float32 *, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This maximizes the correlation score between two 1 bpp images,
'''  * one of which is typically wider.  In a typical example,
'''  * pix1 is a bitmap of 2 or more touching characters and pix2 is
'''  * a single character template.  This finds the location of pix2
'''  * that gives the largest correlation.
'''  *   (2) The windowed area of fg pixels and windowed first moment
'''  * in the y direction are computed from the input sum and moment
'''  * column arrays, %nasum1 and %namoment1
'''  *   (3) This is a brute force operation.  We compute the correlation
'''  * at every x shift for which pix2 fits entirely within pix1,
'''  * and where the centroid of pix2 is aligned, within +-maxyshift,
'''  * with the centroid of a window of pix1 of the same width.
'''  * The correlation is taken over the full height of pix1.
'''  * This can be made more efficient.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix1"> \param[in]    pix1    1 bpp, the unknown image; typically larger</param>
''' <param name="pix2"> \param[in]    pix2    1 bpp, the matching template image)</param>
''' <param name="nasum1"> \param[in]    nasum1  vertical column pixel sums for pix1</param>
''' <param name="namoment1"> \param[in]    namoment1  vertical column first moment of pixels for pix1</param>
''' <param name="area2"> \param[in]    area2   number of on pixels in pix2</param>
''' <param name="ycent2"> \param[in]    ycent2  y component of centroid of pix2</param>
''' <param name="maxyshift"> \param[in]    maxyshift  max y shift of pix2 around the location where</param>
''' <param name="tab8"> \param[in]    tab8    [optional] sum tab for ON pixels in byte; can be NULL</param>
''' <param name="pdelx"> \param[out]   pdelx   [optional] best x shift of pix2 relative to pix1</param>
''' <param name="pdely"> \param[out]   pdely   [optional] best y shift of pix2 relative to pix1</param>
''' <param name="pscore"> \param[out]   pscore  [optional] maximum score found; can be NULL</param>
''' <param name="debugflag"> \param[in]    debugflag <= 0 to skip; positive to generate output.</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixCorrelationBestShift")> _
Friend Shared Function pixCorrelationBestShift(pix1 as IntPTR, pix2 as IntPTR, nasum1 as IntPTR, namoment1 as IntPTR, area2 as Integer, ycent2 as Integer, maxyshift as Integer, tab8 as Integer, pdelx as Integer, pdely as Integer, pscore as single, debugflag as Integer) as Integer
End Function

' SRC\recogident.c (116, 15)
' rchCreate()
' rchCreate(l_int32, l_float32, char *, l_int32, l_int32, l_int32, l_int32) as L_RCH *
''' <summary>
''' * Notes:
'''  *   (1) Be sure to destroy any existing rch before assigning this.
'''  *   (2) This stores the text string, not a copy of it, so the
'''  * caller must not destroy the string.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="index"> \param[in]    index index of best template</param>
''' <param name="score"> \param[in]    score correlation score of best template</param>
''' <param name="text"> \param[in]    text character string of best template</param>
''' <param name="sample"> \param[in]    sample index of best sample; -1 if averages are used</param>
''' <param name="xloc"> \param[in]    xloc x-location of template: delx + shiftx</param>
''' <param name="yloc"> \param[in]    yloc y-location of template: dely + shifty</param>
''' <param name="width"> \param[in]    width width of best template</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rchCreate")> _
Friend Shared Function rchCreate(index as Integer, score as single, text as Object, sample as Integer, xloc as Integer, yloc as Integer, width as Integer) as IntPTR
End Function

' SRC\recogident.c (119, 16)
' rchaCreate()
' rchaCreate() as L_RCHA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rchaCreate")> _
Friend Shared Function rchaCreate() as IntPTR
End Function

' SRC\recogident.c (120, 16)
' transferRchToRcha()
' transferRchToRcha(L_RCH *, L_RCHA *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This is used to transfer the results of a single character
'''  * identification to an rcha array for the array of characters.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="rch"> \param[in]    rch source of data</param>
''' <param name="rcha"> \param[in]    rcha append to arrays in this destination</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="transferRchToRcha")> _
Friend Shared Function transferRchToRcha(rch as IntPTR, rcha as IntPTR) as Integer
End Function

' SRC\recogident.c (121, 13)
' recogPreSplittingFilter()
' recogPreSplittingFilter(L_RECOG *, PIX *, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with filtered components removed or NULL on error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="pixs"> \param[in]    pixs     1 bpp, many connected components</param>
''' <param name="minh"> \param[in]    minh     minimum height of components to be retained</param>
''' <param name="minaf"> \param[in]    minaf    minimum area fraction (|fg|/(wh)) to be retained</param>
''' <param name="debug"> \param[in]    debug    1 to output indicator arrays</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogPreSplittingFilter")> _
Friend Shared Function recogPreSplittingFilter(recog as IntPTR, pixs as IntPTR, minh as Integer, minaf as single, debug as Integer) as IntPTR
End Function

' SRC\recogident.c (123, 16)
' recogSplittingFilter()
' recogSplittingFilter(L_RECOG *, PIX *, l_int32, l_float32, l_int32 *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="pixs"> \param[in]    pixs     1 bpp, single connected component</param>
''' <param name="min"> \param[in]    minh     minimum height of component; 0 for default</param>
''' <param name="minaf"> \param[in]    minaf    minimum area fraction (|fg|/(wh)) to be retained</param>
''' <param name="premove"> \param[out]   premove  0 to save, 1 to remove</param>
''' <param name="debug"> \param[in]    debug    1 to output indicator arrays</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogSplittingFilter")> _
Friend Shared Function recogSplittingFilter(recog as IntPTR, pixs as IntPTR, min as Integer, minaf as single, premove as Integer, debug as Integer) as Integer
End Function

' SRC\recogident.c (126, 13)
' l_showIndicatorSplitValues()
' l_showIndicatorSplitValues(NUMA *, NUMA *, NUMA *, NUMA *, NUMA *, NUMA *) as void
''' <summary>
''' * Notes:
'''  *   (1) The values indicate that specific criteria has been met
'''  * for component removal by pre-splitting filter..
'''  * The 'result' line shows which components have been removed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="na1"> \param[in]  na1, na2, na3, na4, na5, na6  6 indicator array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_showIndicatorSplitValues")> _
Friend Shared Function l_showIndicatorSplitValues(na1 as IntPTR, na2 as IntPTR, na3 as IntPTR, na4 as IntPTR, na5 as IntPTR, na6 as IntPTR) as Boolean ' Org. Void
End Function

' SRC\recogident.c (158, 1)
' recogIdentifyMultiple()
' recogIdentifyMultiple(L_RECOG *, PIX *, l_int32, l_int32, BOXA **, PIXA **, PIX **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This filters the input pixa and calls recogIdentifyPixa()
'''  *   (2) Splitting is relatively slow, because it tries to match all
'''  * character templates to all locations.  This step can be skipped.
'''  *   (3) An attempt is made to order the (optionally) returned images
'''  * and boxes in 2-dimensional sorted order.  These can then
'''  * be used to aggregate identified characters into numbers or words.
'''  * One typically wants the pixa, which contains a boxa of the
'''  * extracted subimages.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 if nothing is found; 2 for other errors.</returns>
''' <param name="recog"> \param[in]    recog      with training finished</param>
''' <param name="pixs"> \param[in]    pixs       containing typically a small number of characters</param>
''' <param name="minh"> \param[in]    minh       remove shorter components; use 0 for default</param>
''' <param name="skipsplit"> \param[in]    skipsplit  1 to skip the splitting step</param>
''' <param name="pboxa"> \param[out]   pboxa [optional] locations of identified components</param>
''' <param name="ppixa"> \param[out]   ppixa [optional] images of identified components</param>
''' <param name="ppixdb"> \param[out]   ppixdb [optional] debug pix: inputs and best fits</param>
''' <param name="debugsplit"> \param[in]    debugsplit 1 returns pix split debugging images</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogIdentifyMultiple")> _
Friend Shared Function recogIdentifyMultiple(recog as IntPTR, pixs as IntPTR, minh as Integer, skipsplit as Integer, pboxa as Object, ppixa as Object, ppixdb as Object, debugsplit as Integer) as Integer
End Function

' SRC\recogident.c (246, 1)
' recogSplitIntoCharacters()
' recogSplitIntoCharacters(L_RECOG *, PIX *, l_int32, l_int32, BOXA **, PIXA **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This can be given an image that has an arbitrary number
'''  * of text characters.  It optionally splits connected
'''  * components based on document image decoding in recogDecode().
'''  * The returned pixa includes the boxes from which the
'''  * (possibly split) components are extracted.
'''  *   (2) After noise filtering, the resulting components are put in
'''  * row-major (2D) order, and the smaller of overlapping
'''  * components are removed if they satisfy conditions of
'''  * relative size and fractional overlap.
'''  *   (3) Note that the splitting function uses unscaled templates
'''  * and does not bother returning the class results and scores.
'''  * These are more accurately found later using the scaled templates.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if no components are returned</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="pixs"> \param[in]    pixs      1 bpp, contains only mostly deskewed text</param>
''' <param name="minh"> \param[in]    minh      remove shorter components; use 0 for default</param>
''' <param name="skipsplit"> \param[in]    skipsplit 1 to skip the splitting step</param>
''' <param name="pboxa"> \param[out]   pboxa     character bounding boxes</param>
''' <param name="ppixa"> \param[out]   ppixa     character images</param>
''' <param name="debug"> \param[in]    debug     1 for results written to pixadb_split</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogSplitIntoCharacters")> _
Friend Shared Function recogSplitIntoCharacters(recog as IntPTR, pixs as IntPTR, minh as Integer, skipsplit as Integer, pboxa as Object, ppixa as Object, debug as Integer) as Integer
End Function

' SRC\recogident.c (401, 1)
' recogCorrelationBestRow()
' recogCorrelationBestRow(L_RECOG *, PIX *, BOXA **, NUMA **, NUMA **, SARRAY **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Supervises character matching for (in general) a c.c with
'''  * multiple touching characters.  Finds the best match greedily.
'''  * Rejects small parts that are left over after splitting.
'''  *   (2) Matching is to the average, and without character scaling.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog with LUT's pre-computed</param>
''' <param name="pixs"> \param[in]    pixs typically of multiple touching characters, 1 bpp</param>
''' <param name="pboxa"> \param[out]   pboxa bounding boxs of best fit character</param>
''' <param name="pnascore"> \param[out]   pnascore [optional] correlation scores</param>
''' <param name="pnaindex"> \param[out]   pnaindex [optional] indices of classes</param>
''' <param name="psachar"> \param[out]   psachar [optional] array of character strings</param>
''' <param name="debug"> \param[in]    debug 1 for results written to pixadb_split</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogCorrelationBestRow")> _
Friend Shared Function recogCorrelationBestRow(recog as IntPTR, pixs as IntPTR, pboxa as Object, pnascore as Object, pnaindex as Object, psachar as Object, debug as Integer) as Integer
End Function

' SRC\recogident.c (583, 1)
' recogCorrelationBestChar()
' recogCorrelationBestChar(L_RECOG *, PIX *, BOX **, l_float32 *, l_int32 *, char **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Basic matching character splitter.  Finds the best match among
'''  * all templates to some region of the image.  This can result
'''  * in splitting the image into two parts.  This is "image decoding"
'''  * without dynamic programming, because we don't use a setwidth
'''  * and compute the best matching score for the entire image.
'''  *   (2) Matching is to the average templates, without character scaling.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog with LUT's pre-computed</param>
''' <param name="pixs"> \param[in]    pixs can be of multiple touching characters, 1 bpp</param>
''' <param name="pbox"> \param[out]   pbox bounding box of best fit character</param>
''' <param name="pscore"> \param[out]   pscore correlation score</param>
''' <param name="pindex"> \param[out]   pindex [optional] index of class</param>
''' <param name="pcharstr"> \param[out]   pcharstr [optional] character string of class</param>
''' <param name="ppixdb"> \param[out]   ppixdb [optional] debug pix showing input and best fit</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogCorrelationBestChar")> _
Friend Shared Function recogCorrelationBestChar(recog as IntPTR, pixs as IntPTR, pbox as Object, pscore as single, pindex as Integer, pcharstr as String, ppixdb as Object) as Integer
End Function

' SRC\recogident.c (878, 1)
' recogIdentifyPixa()
' recogIdentifyPixa(L_RECOG *, PIXA *, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This should be called by recogIdentifyMuliple(), which
'''  * binarizes and splits characters before sending %pixa here.
'''  *   (2) This calls recogIdentifyPix(), which does the same operation
'''  * on each pix in %pixa, and optionally returns the arrays
'''  * of results (scores, class index and character string)
'''  * for the best correlation match.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="pixa"> \param[in]    pixa of 1 bpp images to match</param>
''' <param name="ppixdb"> \param[out]   ppixdb [optional] pix showing inputs and best fits</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogIdentifyPixa")> _
Friend Shared Function recogIdentifyPixa(recog as IntPTR, pixa as IntPTR, ppixdb as Object) as Integer
End Function

' SRC\recogident.c (971, 1)
' recogIdentifyPix()
' recogIdentifyPix(L_RECOG *, PIX *, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Basic recognition function for a single character.
'''  *   (2) If templ_use == L_USE_ALL_TEMPLATES, which is the default
'''  * situation, matching is attempted to every bitmap in the recog,
'''  * and the identify of the best match is returned.
'''  *   (3) For finding outliers, templ_use == L_USE_AVERAGE_TEMPLATES, and
'''  * matching is only attemplted to the averaged bitmaps.  For this
'''  * case, the index of the bestsample is meaningless (0 is returned
'''  * if requested).
'''  *   (4) The score is related to the confidence (probability of correct
'''  * identification), in that a higher score is correlated with
'''  * a higher probability.  However, the actual relation between
'''  * the correlation (score) and the probability is not known;
'''  * we call this a "score" because "confidence" can be misinterpreted
'''  * as an actual probability.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog with LUT's pre-computed</param>
''' <param name="pixs"> \param[in]    pixs of a single character, 1 bpp</param>
''' <param name="ppixdb"> \param[out]   ppixdb [optional] debug pix showing input and best fit</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogIdentifyPix")> _
Friend Shared Function recogIdentifyPix(recog as IntPTR, pixs as IntPTR, ppixdb as Object) as Integer
End Function

' SRC\recogident.c (1120, 1)
' recogSkipIdentify()
' recogSkipIdentify(L_RECOG *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This just writes a "dummy" result with 0 score and empty
'''  * string id into the rch.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogSkipIdentify")> _
Friend Shared Function recogSkipIdentify(recog as IntPTR) as Integer
End Function

' SRC\recogident.c (1168, 1)
' rchaDestroy()
' rchaDestroy(L_RCHA **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="prcha"> \param[in,out]  prcha to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rchaDestroy")> _
Friend Shared Function rchaDestroy(prcha as Object) as Boolean ' Org. Void
End Function

' SRC\recogident.c (1242, 1)
' rchDestroy()
' rchDestroy(L_RCH **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="prch"> \param[in,out] prch to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rchDestroy")> _
Friend Shared Function rchDestroy(prch as Object) as Boolean ' Org. Void
End Function

' SRC\recogident.c (1281, 1)
' rchaExtract()
' rchaExtract(L_RCHA *, NUMA **, NUMA **, SARRAY **, NUMA **, NUMA **, NUMA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This returns clones of the number and string arrays.  They must
'''  * be destroyed by the caller.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="rcha"> \param[in]    rcha</param>
''' <param name="pnaindex"> \param[out]   pnaindex [optional] indices of best templates</param>
''' <param name="pnascore"> \param[out]   pnascore [optional] correl scores of best templates</param>
''' <param name="psatext"> \param[out]   psatext [optional] character strings of best templates</param>
''' <param name="pnasample"> \param[out]   pnasample [optional] indices of best samples</param>
''' <param name="pnaxloc"> \param[out]   pnaxloc [optional] x-locations of templates</param>
''' <param name="pnayloc"> \param[out]   pnayloc [optional] y-locations of templates</param>
''' <param name="pnawidth"> \param[out]   pnawidth [optional] widths of best templates</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rchaExtract")> _
Friend Shared Function rchaExtract(rcha as IntPTR, pnaindex as Object, pnascore as Object, psatext as Object, pnasample as Object, pnaxloc as Object, pnayloc as Object, pnawidth as Object) as Integer
End Function

' SRC\recogident.c (1327, 1)
' rchExtract()
' rchExtract(L_RCH *, l_int32 *, l_float32 *, char **, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="rch"> \param[in]    rch</param>
''' <param name="pindex"> \param[out]   pindex [optional] index of best template</param>
''' <param name="pscore"> \param[out]   pscore [optional] correlation score of best template</param>
''' <param name="ptext"> \param[out]   ptext [optional] character string of best template</param>
''' <param name="psample"> \param[out]   psample [optional] index of best sample</param>
''' <param name="pxloc"> \param[out]   pxloc [optional] x-location of template</param>
''' <param name="pyloc"> \param[out]   pyloc [optional] y-location of template</param>
''' <param name="pwidth"> \param[out]   pwidth [optional] width of best template</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rchExtract")> _
Friend Shared Function rchExtract(rch as IntPTR, pindex as Integer, pscore as single, ptext as String, psample as Integer, pxloc as Integer, pyloc as Integer, pwidth as Integer) as Integer
End Function

' SRC\recogident.c (1415, 1)
' recogProcessToIdentify()
' recogProcessToIdentify(L_RECOG *, PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a lightweight operation to insure that the input
'''  * image is 1 bpp, properly cropped, and padded on each side.
'''  * If bpp > 1, the image is thresholded.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, clipped to foreground, or NULL if there</returns>
''' <param name="recog"> \param[in]    recog with LUT's pre-computed</param>
''' <param name="pixs"> \param[in]    pixs typ. single character, possibly d > 1 and uncropped</param>
''' <param name="pad"> \param[in]    pad extra pixels added to left and right sides</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogProcessToIdentify")> _
Friend Shared Function recogProcessToIdentify(recog as IntPTR, pixs as IntPTR, pad as Integer) as IntPTR
End Function

' SRC\recogident.c (1628, 1)
' recogExtractNumbers()
' recogExtractNumbers(L_RECOG *, BOXA *, l_float32, l_int32, BOXAA **, NUMAA **) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) This extracts digit data after recogaIdentifyMultiple() or
'''  * lower-level identification has taken place.
'''  *   (2) Each string in the returned sa contains a sequence of ascii
'''  * digits in a number.
'''  *   (3) The horizontal distance between boxes (limited by %spacethresh)
'''  * is the negative of the horizontal overlap.
'''  *   (4) Components with a score less than %scorethresh, which may
'''  * be hyphens or other small characters, will signal the
'''  * end of the current sequence of digits in the number.  A typical
'''  * value for %scorethresh is 0.60.
'''  *   (5) We allow two digits to be combined if these conditions apply:
'''  *   (a) the first is to the left of the second
'''  *   (b) the second has a horizontal separation less than %spacethresh
'''  *   (c) the vertical overlap >= 0 (vertical separation  0)
'''  *   (d) both have a score that exceeds %scorethresh
'''  *   (6) Each numa in the optionally returned naa contains the digit
'''  * scores of a number.  Each boxa in the optionally returned baa
'''  * contains the bounding boxes of the digits in the number.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sa of identified numbers, or NULL on error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="boxas"> \param[in]    boxas location of components</param>
''' <param name="scorethresh"> \param[in]    scorethresh min score for which we accept a component</param>
''' <param name="spacethresh"> \param[in]    spacethresh max horizontal distance allowed between digits,</param>
''' <param name="pbaa"> \param[out]   pbaa [optional] bounding boxes of identified numbers</param>
''' <param name="pnaa"> \param[out]   pnaa [optional] scores of identified digits</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogExtractNumbers")> _
Friend Shared Function recogExtractNumbers(recog as IntPTR, boxas as IntPTR, scorethresh as single, spacethresh as Integer, pbaa as Object, pnaa as Object) as IntPTR
End Function

' SRC\recogident.c (1761, 1)
' showExtractNumbers()
' showExtractNumbers(PIX *, SARRAY *, BOXAA *, NUMAA *, PIX **) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This is a debugging routine on digit identification; e.g.:
'''  *   recogIdentifyMultiple(recog, pixs, 0, 1, &boxa, NULL, NULL, 0);
'''  *   sa = recogExtractNumbers(recog, boxa, 0.8, -1, &baa, &naa);
'''  *   pixa = showExtractNumbers(pixs, sa, baa, naa, NULL);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa   of identified strings with text and scores, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs   input 1 bpp image</param>
''' <param name="sa"> \param[in]    sa     recognized text strings</param>
''' <param name="baa"> \param[in]    baa    boxa array for location of characters in each string</param>
''' <param name="naa"> \param[in]    naa    numa array for scores of characters in each string</param>
''' <param name="ppixdb"> \param[out]   ppixdb  [optional] input pixs with identified chars outlined</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="showExtractNumbers")> _
Friend Shared Function showExtractNumbers(pixs as IntPTR, sa as IntPTR, baa as IntPTR, naa as IntPTR, ppixdb as Object) as IntPTR
End Function

#End Region
#Region "SRC\recogtrain.c"
' SRC\recogtrain.c (165, 16)
' recogTemplatesAreOK()
' recogTemplatesAreOK(L_RECOG *, l_int32, l_float32, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This is called by recogTrainingFinished().  A return value of 0
'''  * will cause recogTrainingFinished() to destroy the recog.
'''  *   (2) %minsize is the minimum number of samples required for
'''  * the class; -1 uses the default
'''  *   (3) %minfract is the minimum fraction of classes required for
'''  * the recog to be usable; -1.0 uses the default
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 on error; 0 otherwise.  An invalid template set is not an error.</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="minsize"> \param[in]    minsize     set to -1 for default</param>
''' <param name="minfract"> \param[in]    minfract    set to -1.0 for default</param>
''' <param name="pok"> \param[out]   pok         set to 1 if template set is valid; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogTemplatesAreOK")> _
Friend Shared Function recogTemplatesAreOK(recog as IntPTR, minsize as Integer, minfract as single, pok as Integer) as Integer
End Function

' SRC\recogtrain.c (167, 16)
' recogAddMissingClassStrings()
' recogAddMissingClassStrings(L_RECOG *) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) This returns an empty %sa if there is at least one template
'''  * in each class in %recog.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return       sa  of class string missing in %recog, or NULL on error</returns>
''' <param name="recog"> \param[in]    recog   trained</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogAddMissingClassStrings")> _
Friend Shared Function recogAddMissingClassStrings(recog as IntPTR) as IntPTR
End Function

' SRC\recogtrain.c (168, 16)
' recogCharsetAvailable()
' recogCharsetAvailable(l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if available; 0 if not.</returns>
''' <param name="type"> \param[in]    type of charset for padding</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogCharsetAvailable")> _
Friend Shared Function recogCharsetAvailable(type as Integer) as Integer
End Function

' SRC\recogtrain.c (169, 13)
' pixDisplayOutliers()
' pixDisplayOutliers(PIXA *, NUMA *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This debug routine is called from recogRemoveOutliers2(),
'''  * and takes the saved templates and their scores as input.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix    tiled pixa with text and scores, or NULL on failure</returns>
''' <param name="pixas"> \param[in]    pixas    unscaled labeled templates</param>
''' <param name="nas"> \param[in]    nas      scores of templates (against class averages)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDisplayOutliers")> _
Friend Shared Function pixDisplayOutliers(pixas as IntPTR, nas as IntPTR) as IntPTR
End Function

' SRC\recogtrain.c (170, 13)
' recogDisplayOutlier()
' recogDisplayOutlier(L_RECOG *, l_int32, l_int32, l_int32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This shows three templates, side-by-side:
'''  * - The outlier sample
'''  * - The average template from the same class
'''  * - The average class template that best matched the outlier sample
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix  sample and template images, with score, or NULL on error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="iclass"> \param[in]    iclass     sample is in this class</param>
''' <param name="jsamp"> \param[in]    jsamp      index of sample is class i</param>
''' <param name="maxclass"> \param[in]    maxclass   index of class with closest average to sample</param>
''' <param name="maxscore"> \param[in]    maxscore   score of sample with average of class %maxclass</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogDisplayOutlier")> _
Friend Shared Function recogDisplayOutlier(recog as IntPTR, iclass as Integer, jsamp as Integer, maxclass as Integer, maxscore as single) as IntPTR
End Function

' SRC\recogtrain.c (212, 1)
' recogTrainLabeled()
' recogTrainLabeled(L_RECOG *, PIX *, BOX *, char *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Training is restricted to the addition of a single
'''  * character in an arbitrary (e.g., UTF8) charset
'''  *   (2) If box != null, it should represent the location in %pixs
'''  * of the character image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog in training mode</param>
''' <param name="pixs"> \param[in]    pixs if depth > 1, will be thresholded to 1 bpp</param>
''' <param name="box"> \param[in]    box [optional] cropping box</param>
''' <param name="text"> \param[in]    text [optional] if null, use text field in pix</param>
''' <param name="debug"> \param[in]    debug 1 to display images of samples not captured</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogTrainLabeled")> _
Friend Shared Function recogTrainLabeled(recog as IntPTR, pixs as IntPTR, box as IntPTR, text as Object, debug as Integer) as Integer
End Function

' SRC\recogtrain.c (261, 1)
' recogProcessLabeled()
' recogProcessLabeled(L_RECOG *, PIX *, BOX *, char *, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This crops and binarizes the input image, generating a pix
'''  * of one character where the charval is inserted into the pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog   in training mode</param>
''' <param name="pixs"> \param[in]    pixs    if depth > 1, will be thresholded to 1 bpp</param>
''' <param name="box"> \param[in]    box     [optional] cropping box</param>
''' <param name="text"> \param[in]    text    [optional] if null, use text field in pix</param>
''' <param name="ppix"> \param[out]   ppix    addr of pix, 1 bpp, labeled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogProcessLabeled")> _
Friend Shared Function recogProcessLabeled(recog as IntPTR, pixs as IntPTR, box as IntPTR, text as Object, ppix as Object) as Integer
End Function

' SRC\recogtrain.c (352, 1)
' recogAddSample()
' recogAddSample(L_RECOG *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The pix is 1 bpp, with the character string label embedded.
'''  *   (2) The pixaa_u array of the recog is initialized to accept
'''  * up to 256 different classes.  When training is finished,
'''  * the arrays are truncated to the actual number of classes.
'''  * To pad an existing recog from the boot recognizers, training
'''  * is started again; if samples from a new class are added,
'''  * the pixaa_u array is extended by adding a pixa to hold them.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="pix"> \param[in]    pix         a single character, 1 bpp</param>
''' <param name="debug"> \param[in]    debug</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogAddSample")> _
Friend Shared Function recogAddSample(recog as IntPTR, pix as IntPTR, debug as Integer) as Integer
End Function

' SRC\recogtrain.c (417, 1)
' recogModifyTemplate()
' recogModifyTemplate(L_RECOG *, PIX *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd   modified pix if OK, NULL on error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="pixs"> \param[in]    pixs   1 bpp, to be optionally scaled and turned into</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogModifyTemplate")> _
Friend Shared Function recogModifyTemplate(recog as IntPTR, pixs as IntPTR) as IntPTR
End Function

' SRC\recogtrain.c (486, 1)
' recogAverageSamples()
' recogAverageSamples(L_RECOG **, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This is only called in two situations:
'''  * (a) When splitting characters using either the DID method
'''  *  recogDecode() or the the greedy splitter
'''  *  recogCorrelationBestRow()
'''  * (b) By a special recognizer that is used to remove outliers.
'''  * Both unscaled and scaled inputs are averaged.
'''  *   (2) If the data in any class is nonexistent (no samples), or
'''  * very bad (no fg pixels in the average), or if the ratio
'''  * of max/min average unscaled class template heights is
'''  * greater than max_ht_ratio, this destroys the recog.
'''  * The caller must check the return value of the recog.
'''  *   (3) Set debug = 1 to view the resulting templates and their centroids.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 on success, 1 on failure</returns>
''' <param name="precog"> \param[in]   precog      addr of existing recog; may be destroyed</param>
''' <param name="debug"> \param[in]   debug</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogAverageSamples")> _
Friend Shared Function recogAverageSamples(precog as Object, debug as Integer) as Integer
End Function

' SRC\recogtrain.c (664, 1)
' pixaAccumulateSamples()
' pixaAccumulateSamples(PIXA *, PTA *, PIX **, l_float32 *, l_float32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This generates an aligned (by centroid) sum of the input pix.
'''  *   (2) We use only the first 256 samples; that's plenty.
'''  *   (3) If pta is not input, we generate two tables, and discard
'''  * after use.  If this is called many times, it is better
'''  * to precompute the pta.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 on success, 1 on failure</returns>
''' <param name="pixa"> \param[in]    pixa of samples from the same class, 1 bpp</param>
''' <param name="pta"> \param[in]    pta [optional] of centroids of the samples</param>
''' <param name="ppixd"> \param[out]   ppixd accumulated samples, 8 bpp</param>
''' <param name="px"> \param[out]   px [optional] average x coordinate of centroids</param>
''' <param name="py"> \param[out]   py [optional] average y coordinate of centroids</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaAccumulateSamples")> _
Friend Shared Function pixaAccumulateSamples(pixa as IntPTR, pta as IntPTR, ppixd as Object, px as single, py as single) as Integer
End Function

' SRC\recogtrain.c (783, 1)
' recogTrainingFinished()
' recogTrainingFinished(L_RECOG **, l_int32, l_int32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This must be called after all training samples have been added.
'''  *   (2) If the templates are not good enough, the recog input is destroyed.
'''  *   (3) Usually, %modifyflag == 1, because we want to apply
'''  * recogModifyTemplate() to generate the actual templates
'''  * that will be used.  The one exception is when reading a
'''  * serialized recog: there we want to put the same set of
'''  * templates in both the unscaled and modified pixaa.
'''  * See recogReadStream() to see why we do this.
'''  *   (4) See recogTemplatesAreOK() for %minsize and %minfract usage.
'''  *   (5) The following things are done here:
'''  * (a) Allocate (or reallocate) storage for (possibly) modified
'''  *  bitmaps, centroids, and fg areas.
'''  * (b) Generate the (possibly) modified bitmaps.
'''  * (c) Compute centroid and fg area data for both unscaled and
'''  *  modified bitmaps.
'''  * (d) Truncate the pixaa, ptaa and numaa arrays down from
'''  *  256 to the actual size.
'''  *   (6) Putting these operations here makes it simple to recompute
'''  * the recog with different modifications on the bitmaps.
'''  *   (7) Call recogShowContent() to display the templates, both
'''  * unscaled and modified.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error (input recog will be destroyed)</returns>
''' <param name="precog"> \param[in]    precog       addr of recog</param>
''' <param name="modifyflag"> \param[in]    modifyflag   1 to use recogModifyTemplate(); 0 otherwise</param>
''' <param name="minsize"> \param[in]    minsize      set to -1 for default</param>
''' <param name="minfract"> \param[in]    minfract     set to -1.0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogTrainingFinished")> _
Friend Shared Function recogTrainingFinished(precog as Object, modifyflag as Integer, minsize as Integer, minfract as single) as Integer
End Function

' SRC\recogtrain.c (970, 1)
' recogFilterPixaBySize()
' recogFilterPixaBySize(PIXA *, l_int32, l_int32, l_float32, NUMA **) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) The basic assumption is that the most common and larger
'''  * templates in each class are more likely to represent the
'''  * characters we are interested in.  For example, larger digits
'''  * are more likely to represent page numbers, and smaller digits
'''  * could be data in tables.  Therefore, we bias the first
'''  * stage of filtering toward the larger characters by removing
'''  * very small ones, and select based on proximity of the
'''  * remaining characters to median height.
'''  *   (2) For each of the %setsize classes, order the templates
'''  * increasingly by height.  Take the rank 0.9 height.  Eliminate
'''  * all templates that are shorter by more than %max_ht_ratio.
'''  * Of the remaining ones, select up to %maxkeep that are closest
'''  * in rank order height to the median template.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa   filtered templates, or NULL on error</returns>
''' <param name="pixas"> \param[in]   pixas         labeled templates</param>
''' <param name="setsize"> \param[in]   setsize       size of character set (number of classes)</param>
''' <param name="maxkeep"> \param[in]   maxkeep       max number of templates to keep in a class</param>
''' <param name="max_ht_ratio"> \param[in]   max_ht_ratio  max allowed height ratio (see below)</param>
''' <param name="pna"> \param[out]  pna     [optional] debug output, giving the number in each</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogFilterPixaBySize")> _
Friend Shared Function recogFilterPixaBySize(pixas as IntPTR, setsize as Integer, maxkeep as Integer, max_ht_ratio as single, pna as Object) as IntPTR
End Function

' SRC\recogtrain.c (1041, 1)
' recogSortPixaByClass()
' recogSortPixaByClass(PIXA *, l_int32) as PIXAA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  paa   pixaa where each pixa has templates for one class,</returns>
''' <param name="pixa"> \param[in]   pixa          labeled templates</param>
''' <param name="setsize"> \param[in]   setsize       size of character set (number of classes)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogSortPixaByClass")> _
Friend Shared Function recogSortPixaByClass(pixa as IntPTR, setsize as Integer) as IntPTR
End Function

' SRC\recogtrain.c (1081, 1)
' recogRemoveOutliers1()
' recogRemoveOutliers1(L_RECOG **, l_float32, l_int32, l_int32, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a convenience wrapper when using default parameters
'''  * for the recog.  See pixaRemoveOutliers1() for details.
'''  *   (2) If this succeeds, the new recog replaces the input recog;
'''  * if it fails, the input recog is destroyed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="precog"> \param[in]   precog       addr of recog with unscaled labeled templates</param>
''' <param name="minscore"> \param[in]   minscore     keep everything with at least this score</param>
''' <param name="mintarget"> \param[in]   mintarget    minimum desired number to retain if possible</param>
''' <param name="minsize"> \param[in]   minsize      minimum number of samples required for a class</param>
''' <param name="ppixsave"> \param[out]  ppixsave     [optional debug] saved templates, with scores</param>
''' <param name="ppixrem"> \param[out]  ppixrem      [optional debug] removed templates, with scores</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogRemoveOutliers1")> _
Friend Shared Function recogRemoveOutliers1(precog as Object, minscore as single, mintarget as Integer, minsize as Integer, ppixsave as Object, ppixrem as Object) as Integer
End Function

' SRC\recogtrain.c (1159, 1)
' pixaRemoveOutliers1()
' pixaRemoveOutliers1(PIXA *, l_float32, l_int32, l_int32, PIX **, PIX **) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Removing outliers is particularly important when recognition
'''  * goes against all the samples in the training set, as opposed
'''  * to the averages for each class.  The reason is that we get
'''  * an identification error if a mislabeled template is a best
'''  * match for an input sample.
'''  *   (2) Because the score values depend strongly on the quality
'''  * of the character images, to avoid losing too many samples
'''  * we supplement a minimum score for retention with a score
'''  * necessary to acquire the minimum target number of templates.
'''  * To do this we are willing to use a lower threshold,
'''  * LOWER_SCORE_THRESHOLD, on the score.  Consequently, with
'''  * poor quality templates, we may keep samples with a score
'''  * less than %minscore, but never less than LOWER_SCORE_THRESHOLD.
'''  * And if the number of samples is less than %minsize, we do
'''  * not use any.
'''  *   (3) This is meant to be used on a BAR, where the templates all
'''  * come from the same book; use minscore ~0.75.
'''  *   (4) Method: make a scaled recog from the input %pixas.  Then,
'''  * for each class: generate the averages, match each
'''  * scaled template against the average, and save unscaled
'''  * templates that had a sufficiently good match.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa   of unscaled templates to be kept, or NULL on error</returns>
''' <param name="pixas"> \param[in]   pixas        unscaled labeled templates</param>
''' <param name="minscore"> \param[in]   minscore     keep everything with at least this score;</param>
''' <param name="mintarget"> \param[in]   mintarget    minimum desired number to retain if possible;</param>
''' <param name="minsize"> \param[in]   minsize      minimum number of samples required for a class;</param>
''' <param name="ppixsave"> \param[out]  ppixsave     [optional debug] saved templates, with scores</param>
''' <param name="ppixrem"> \param[out]  ppixrem      [optional debug] removed templates, with scores</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaRemoveOutliers1")> _
Friend Shared Function pixaRemoveOutliers1(pixas as IntPTR, minscore as single, mintarget as Integer, minsize as Integer, ppixsave as Object, ppixrem as Object) as IntPTR
End Function

' SRC\recogtrain.c (1299, 1)
' recogRemoveOutliers2()
' recogRemoveOutliers2(L_RECOG **, l_float32, l_int32, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a convenience wrapper when using default parameters
'''  * for the recog.  See pixaRemoveOutliers2() for details.
'''  *   (2) If this succeeds, the new recog replaces the input recog;
'''  * if it fails, the input recog is destroyed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="precog"> \param[in]   precog       addr of recog with unscaled labeled templates</param>
''' <param name="minscore"> \param[in]   minscore     keep everything with at least this score</param>
''' <param name="minsize"> \param[in]   minsize      minimum number of samples required for a class</param>
''' <param name="ppixsave"> \param[out]  ppixsave     [optional debug] saved templates, with scores</param>
''' <param name="ppixrem"> \param[out]  ppixrem      [optional debug] removed templates, with scores</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogRemoveOutliers2")> _
Friend Shared Function recogRemoveOutliers2(precog as Object, minscore as single, minsize as Integer, ppixsave as Object, ppixrem as Object) as Integer
End Function

' SRC\recogtrain.c (1363, 1)
' pixaRemoveOutliers2()
' pixaRemoveOutliers2(PIXA *, l_float32, l_int32, PIX **, PIX **) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Removing outliers is particularly important when recognition
'''  * goes against all the samples in the training set, as opposed
'''  * to the averages for each class.  The reason is that we get
'''  * an identification error if a mislabeled template is a best
'''  * match for an input sample.
'''  *   (2) This method compares each template against the average templates
'''  * of each class, and discards any template that has a higher
'''  * correlation to a class different from its own.  It also
'''  * sets a lower bound on correlation scores with its class average.
'''  *   (3) This is meant to be used on a BAR, where the templates all
'''  * come from the same book; use minscore ~0.75.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa   of unscaled templates to be kept, or NULL on error</returns>
''' <param name="pixas"> \param[in]   pixas       unscaled labeled templates</param>
''' <param name="minscore"> \param[in]   minscore    keep everything with at least this score;</param>
''' <param name="minsize"> \param[in]   minsize     minimum number of samples required for a class;</param>
''' <param name="ppixsave"> \param[out]  ppixsave    [optional debug] saved templates, with scores</param>
''' <param name="ppixrem"> \param[out]  ppixrem     [optional debug] removed templates, with scores</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaRemoveOutliers2")> _
Friend Shared Function pixaRemoveOutliers2(pixas as IntPTR, minscore as single, minsize as Integer, ppixsave as Object, ppixrem as Object) as IntPTR
End Function

' SRC\recogtrain.c (1488, 1)
' recogTrainFromBoot()
' recogTrainFromBoot(L_RECOG *, PIXA *, l_float32, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This takes %pixas of unscaled single characters and %recboot,
'''  * a bootstrep recognizer (BSR) that has been set up with parameters
'''  *   * scaleh: scale all templates to this height
'''  *   * linew: width of normalized strokes, or 0 if using
'''  *  the input image
'''  * It modifies the pix in %pixas accordingly and correlates
'''  * with the templates in the BSR.  It returns those input
'''  * images in %pixas whose best correlation with the BSR is at
'''  * or above %minscore.  The returned pix have added text labels
'''  * for the text string of the class to which the best
'''  * correlated template belongs.
'''  *   (2) Identification occurs in scaled mode (typically with h = 40),
'''  * optionally using a width-normalized line images derived
'''  * from those in %pixas.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad   labeled version of input pixas, trained on a BSR,</returns>
''' <param name="recogboot"> \param[in]    recogboot  labeled boot recognizer</param>
''' <param name="pixas"> \param[in]    pixas      set of unlabeled input characters</param>
''' <param name="minscore"> \param[in]    minscore   min score for accepting the example; e.g., 0.75</param>
''' <param name="threshold"> \param[in]    threshold  for binarization, if needed</param>
''' <param name="debug"> \param[in]    debug      1 for debug output saved to recogboot; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogTrainFromBoot")> _
Friend Shared Function recogTrainFromBoot(recogboot as IntPTR, pixas as IntPTR, minscore as single, threshold as Integer, debug as Integer) as IntPTR
End Function

' SRC\recogtrain.c (1592, 1)
' recogPadDigitTrainingSet()
' recogPadDigitTrainingSet(L_RECOG **, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a no-op if padding is not needed.  However,
'''  * if it is, this replaces the input recog with a new recog,
'''  * padded appropriately with templates from a boot recognizer,
'''  * and set up with correlation templates derived from
'''  * %scaleh and %linew.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return       0 if OK, 1 on error</returns>
''' <param name="precog"> \param[in,out]   precog   trained; if padding is needed, it is replaced</param>
''' <param name="scaleh"> \param[in]       scaleh   must be > 0; suggest ~40.</param>
''' <param name="linew"> \param[in]       linew    use 0 for original scanned images</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogPadDigitTrainingSet")> _
Friend Shared Function recogPadDigitTrainingSet(precog as Object, scaleh as Integer, linew as Integer) as Integer
End Function

' SRC\recogtrain.c (1650, 1)
' recogIsPaddingNeeded()
' recogIsPaddingNeeded(L_RECOG *, SARRAY **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This returns a string array in &sa containing character values
'''  * for which extra templates are needed; this sarray is
'''  * used by recogGetPadTemplates().  It returns NULL
'''  * if no padding templates are needed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return       1 on error; 0 if OK, whether or not additional padding</returns>
''' <param name="recog"> \param[in]    recog   trained</param>
''' <param name="psa"> \param[out]   psa     addr of returned string containing text value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogIsPaddingNeeded")> _
Friend Shared Function recogIsPaddingNeeded(recog as IntPTR, psa as Object) as Integer
End Function

' SRC\recogtrain.c (1768, 1)
' recogAddDigitPadTemplates()
' recogAddDigitPadTemplates(L_RECOG *, SARRAY *) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Call recogIsPaddingNeeded() first, which returns %sa of
'''  * template text strings for classes where more templates
'''  * are needed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa   of all templates from %recog and the additional pad</returns>
''' <param name="recog"> \param[in]    recog   trained</param>
''' <param name="sa"> \param[in]    sa      set of text strings that need to be padded</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogAddDigitPadTemplates")> _
Friend Shared Function recogAddDigitPadTemplates(recog as IntPTR, sa as IntPTR) as IntPTR
End Function

' SRC\recogtrain.c (1876, 1)
' recogMakeBootDigitRecog()
' recogMakeBootDigitRecog(l_int32, l_int32, l_int32, l_int32) as L_RECOG *
''' <summary>
''' * Notes:
'''  *  (1) This takes a set of pre-computed, labeled pixa of single
'''  *   digits, and generates a recognizer where the character templates
'''  *   that will be used are derived from the boot-generated pixa:
'''  *   - extending by replicating the set with different widths,
'''  *  keeping the height the same
'''  *   - scaling (isotropically to fixed height)
'''  *   - optionally generating a skeleton and thickening so that
'''  *  all strokes have the same width.
'''  *  (2) The resulting templates are scaled versions of either the
'''  *   input bitmaps or images with fixed line widths.  To use the
'''  *   input bitmaps, set %linew = 0; otherwise, set %linew to the
'''  *   desired line width.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  recog, or NULL on error</returns>
''' <param name="scaleh"> \param[in]    scaleh   scale all heights to this; typ. use 40</param>
''' <param name="linew"> \param[in]    linew    normalized line width; typ. use 5; 0 to skip</param>
''' <param name="maxyshift"> \param[in]    maxyshift from nominal centroid alignment; typically 0 or 1</param>
''' <param name="debug"> \param[in]    debug  1 for showing templates; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogMakeBootDigitRecog")> _
Friend Shared Function recogMakeBootDigitRecog(scaleh as Integer, linew as Integer, maxyshift as Integer, debug as Integer) as IntPTR
End Function

' SRC\recogtrain.c (1911, 1)
' recogMakeBootDigitTemplates()
' recogMakeBootDigitTemplates(l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *  (1) See recogMakeBootDigitRecog().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa   of templates; or NULL on error</returns>
''' <param name="debug"> \param[in]    debug  1 for display of templates</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogMakeBootDigitTemplates")> _
Friend Shared Function recogMakeBootDigitTemplates(debug as Integer) as IntPTR
End Function

' SRC\recogtrain.c (1962, 1)
' recogShowContent()
' recogShowContent(FILE *, L_RECOG *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file  stream</param>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="index"> \param[in]    index    for naming of output files of template images</param>
''' <param name="display"> \param[in]    display  1 for showing template images, 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogShowContent")> _
Friend Shared Function recogShowContent(fp as Object, recog as IntPTR, index as Integer, display as Integer) as Integer
End Function

' SRC\recogtrain.c (2045, 1)
' recogDebugAverages()
' recogDebugAverages(L_RECOG **, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Generates an image that pairs each of the input images used
'''  * in training with the average template that it is best
'''  * correlated to.  This is written into the recog.
'''  *   (2) It also generates pixa_tr of all the input training images,
'''  * which can be used, e.g., in recogShowMatchesInRange().
'''  *   (3) Destroys the recog if the averaging function finds any bad classes.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="precog"> \param[in]    precog    addr of recog</param>
''' <param name="debug"> \param[in]    debug     0 no output; 1 for images; 2 for text; 3 for both</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogDebugAverages")> _
Friend Shared Function recogDebugAverages(precog as Object, debug as Integer) as Integer
End Function

' SRC\recogtrain.c (2123, 1)
' recogShowAverageTemplates()
' recogShowAverageTemplates(L_RECOG *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This debug routine generates a display of the averaged templates,
'''  * both scaled and unscaled, with the centroid visible in red.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 on success, 1 on failure</returns>
''' <param name="recog"> \param[in]    recog</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogShowAverageTemplates")> _
Friend Shared Function recogShowAverageTemplates(recog as IntPTR) as Integer
End Function

' SRC\recogtrain.c (2311, 1)
' recogShowMatchesInRange()
' recogShowMatchesInRange(L_RECOG *, PIXA *, l_float32, l_float32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This gives a visual output of the best matches for a given
'''  * range of scores.  Each pair of images can optionally be
'''  * labeled with the index of the best match and the correlation.
'''  *   (2) To use this, save a set of 1 bpp images (labeled or
'''  * unlabeled) that can be given to a recognizer in a pixa.
'''  * Then call this function with the pixa and parameters
'''  * to filter a range of scores.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="pixa"> \param[in]    pixa of 1 bpp images to match</param>
''' <param name="minscore"> \param[in]    minscore, maxscore range to include output</param>
''' <param name="maxscore"> \param[in]    display to display the result</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogShowMatchesInRange")> _
Friend Shared Function recogShowMatchesInRange(recog as IntPTR, pixa as IntPTR, minscore as single, maxscore as single, display as Integer) as Integer
End Function

' SRC\recogtrain.c (2405, 1)
' recogShowMatch()
' recogShowMatch(L_RECOG *, PIX *, PIX *, BOX *, l_int32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pix1 can be one of these:
'''  * (a) The input pix alone, which can be either a single character
'''  *  (box == NULL) or several characters that need to be
'''  *  segmented.  If more than character is present, the box
'''  *  region is displayed with an outline.
'''  * (b) Both the input pix and the matching template.  In this case,
'''  *  pix2 and box will both be null.
'''  *   (2) If the bmf has been made (by a call to recogMakeBmf())
'''  * and the index >= 0, the text field, match score and index
'''  * will be rendered; otherwise their values will be ignored.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd pair of images, showing input pix and best template,</returns>
''' <param name="recog"> \param[in]    recog</param>
''' <param name="pix1"> \param[in]    pix1  input pix; several possibilities</param>
''' <param name="pix2"> \param[in]    pix2  [optional] matching template</param>
''' <param name="box"> \param[in]    box  [optional] region in pix1 for which pix2 matches</param>
''' <param name="index"> \param[in]    index  index of matching template; use -1 to disable printing</param>
''' <param name="score"> \param[in]    score  score of match</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="recogShowMatch")> _
Friend Shared Function recogShowMatch(recog as IntPTR, pix1 as IntPTR, pix2 as IntPTR, box as IntPTR, index as Integer, score as single) as IntPTR
End Function

#End Region
#Region "SRC\regutils.c"
' SRC\regutils.c (74, 14)
' getRootNameFromArgv0()
' getRootNameFromArgv0(const char *) as char *
''' <summary>
''' * Notes:
'''  *   (1) For example, from psioseg_reg, we want to extract
'''  * just 'psioseg' as the root.
'''  *   (2) In unix with autotools, the executable is not X,
'''  * but ./.libs/lt-X.   So in addition to stripping out the
'''  * last 4 characters of the tail, we have to check for
'''  * the '-' and strip out the "lt-" prefix if we find it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  root name without the '_reg', or NULL on error</returns>
''' <param name="argv0"> \param[in]    argv0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getRootNameFromArgv0")> _
Friend Shared Function getRootNameFromArgv0(argv0 as String) as String
End Function

' SRC\regutils.c (119, 1)
' regTestSetup()
' regTestSetup(l_int32, char **, L_REGPARAMS **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Call this function with the args to the reg test.  The first arg
'''  * is the name of the reg test.  There are three cases:
'''  * Case 1:
'''  *  There is either only one arg, or the second arg is "compare".
'''  *  This is the mode in which you run a regression test
'''  *  (or a set of them), looking for failures and logging
'''  *  the results to a file.  The output, which includes
'''  *  logging of all reg test failures plus a SUCCESS or
'''  *  FAILURE summary for each test, is appended to the file
'''  *  "/tmp/lept/reg_results.txt.  For this case, as in Case 2,
'''  *  the display field in rp is set to FALSE, preventing
'''  *  image display.
'''  * Case 2:
'''  *  The second arg is "generate".  This will cause
'''  *  generation of new golden files for the reg test.
'''  *  The results of the reg test are not recorded, and
'''  *  the display field in rp is set to FALSE.
'''  * Case 3:
'''  *  The second arg is "display".  The test will run and
'''  *  files will be written.  Comparisons with golden files
'''  *  will not be carried out, so the only notion of success
'''  *  or failure is with tests that do not involve golden files.
'''  *  The display field in rp is TRUE, and this is used by
'''  *  pixDisplayWithTitle().
'''  *   (2) See regutils.h for examples of usage.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="argc"> \param[in]    argc    from invocation; can be either 1 or 2</param>
''' <param name="argv"> \param[in]    argv    to regtest: %argv[1] is one of these:</param>
''' <param name="prp"> \param[out]   prp     all regression params</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="regTestSetup")> _
Friend Shared Function regTestSetup(argc as Integer, argv as String, prp as Object) as Integer
End Function

' SRC\regutils.c (208, 1)
' regTestCleanup()
' regTestCleanup(L_REGPARAMS *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This copies anything written to the temporary file to the
'''  * output file /tmp/lept/reg_results.txt.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="rp"> \param[in]    rp    regression test parameters</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="regTestCleanup")> _
Friend Shared Function regTestCleanup(rp as IntPTR) as Integer
End Function

' SRC\regutils.c (271, 1)
' regTestCompareValues()
' regTestCompareValues(L_REGPARAMS *, l_float32, l_float32, l_float32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error a failure in comparison is not an error</returns>
''' <param name="rp"> \param[in]    rp      regtest parameters</param>
''' <param name="val1"> \param[in]    val1    typ. the golden value</param>
''' <param name="val2"> \param[in]    val2    typ. the value computed</param>
''' <param name="delta"> \param[in]    delta   allowed max absolute difference</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="regTestCompareValues")> _
Friend Shared Function regTestCompareValues(rp as IntPTR, val1 as single, val2 as single, delta as single) as Integer
End Function

' SRC\regutils.c (315, 1)
' regTestCompareStrings()
' regTestCompareStrings(L_REGPARAMS *, l_uint8 *, size_t, l_uint8 *, size_t) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error a failure in comparison is not an error</returns>
''' <param name="rp"> \param[in]    rp        regtest parameters</param>
''' <param name="string1"> \param[in]    string1   typ. the expected string</param>
''' <param name="bytes1"> \param[in]    bytes1    size of string1</param>
''' <param name="string2"> \param[in]    string2   typ. the computed string</param>
''' <param name="bytes2"> \param[in]    bytes2    size of string2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="regTestCompareStrings")> _
Friend Shared Function regTestCompareStrings(rp as IntPTR, string1 as Byte, bytes1 as ULong, string2 as Byte, bytes2 as ULong) as Integer
End Function

' SRC\regutils.c (381, 1)
' regTestComparePix()
' regTestComparePix(L_REGPARAMS *, PIX *, PIX *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function compares two pix for equality.  On failure,
'''  * this writes to stderr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error a failure in comparison is not an error</returns>
''' <param name="rp"> \param[in]    rp            regtest parameters</param>
''' <param name="pix1"> \param[in]    pix1, pix2    to be tested for equality</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="regTestComparePix")> _
Friend Shared Function regTestComparePix(rp as IntPTR, pix1 as IntPTR, pix2 as IntPTR) as Integer
End Function

' SRC\regutils.c (441, 1)
' regTestCompareSimilarPix()
' regTestCompareSimilarPix(L_REGPARAMS *, PIX *, PIX *, l_int32, l_float32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function compares two pix for near equality.  On failure,
'''  * this writes to stderr.
'''  *   (2) The pix are similar if the fraction of non-conforming pixels
'''  * does not exceed %maxfract.  Pixels are non-conforming if
'''  * the difference in pixel values equals or exceeds %mindiff.
'''  * Typical values might be %mindiff = 15 and %maxfract = 0.01.
'''  *   (3) The input images must have the same size and depth.  The
'''  * pixels for comparison are typically subsampled from the images.
'''  *   (4) Normally, use %printstats = 0.  In debugging mode, to see
'''  * the relation between %mindiff and the minimum value of
'''  * %maxfract for success, set this to 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error a failure in similarity comparison</returns>
''' <param name="rp"> \param[in]    rp           regtest parameters</param>
''' <param name="pix1"> \param[in]    pix1, pix2   to be tested for near equality</param>
''' <param name="pix2"> \param[in]    mindiff      minimum pixel difference to be counted; > 0</param>
''' <param name="mindiff"> \param[in]    maxfract     maximum fraction of pixels allowed to have</param>
''' <param name="maxfract"> \param[in]    printstats   use 1 to print normalized histogram to stderr</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="regTestCompareSimilarPix")> _
Friend Shared Function regTestCompareSimilarPix(rp as IntPTR, pix1 as IntPTR, pix2 as IntPTR, mindiff as Integer, maxfract as single, printstats as Integer) as Integer
End Function

' SRC\regutils.c (504, 1)
' regTestCheckFile()
' regTestCheckFile(L_REGPARAMS *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function does one of three things, depending on the mode:
'''  *  * "generate": makes a "golden" file as a copy %localname.
'''  *  * "compare": compares %localname contents with the golden file
'''  *  * "display": makes the %localname file but does no comparison
'''  *   (2) The canonical format of the golden filenames is:
'''  *   /tmp/lept/golden/[root of main name]_golden.[index].
'''  *    [ext of localname]
'''  * e.g.,
'''  * /tmp/lept/golden/maze_golden.0.png
'''  * It is important to add an extension to the local name, because
'''  * the extension is added to the name of the golden file.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error a failure in comparison is not an error</returns>
''' <param name="rp"> \param[in]    rp         regtest parameters</param>
''' <param name="localname"> \param[in]    localname  name of output file from reg test</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="regTestCheckFile")> _
Friend Shared Function regTestCheckFile(rp as IntPTR, localname as String) as Integer
End Function

' SRC\regutils.c (611, 1)
' regTestCompareFiles()
' regTestCompareFiles(L_REGPARAMS *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This only does something in "compare" mode.
'''  *   (2) The canonical format of the golden filenames is:
'''  *   /tmp/lept/golden/[root of main name]_golden.[index].
'''  *      [ext of localname]
'''  * e.g.,
'''  *   /tmp/lept/golden/maze_golden.0.png
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error a failure in comparison is not an error</returns>
''' <param name="rp"> \param[in]    rp        regtest parameters</param>
''' <param name="index1"> \param[in]    index1    of one output file from reg test</param>
''' <param name="index2"> \param[in]    index2    of another output file from reg test</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="regTestCompareFiles")> _
Friend Shared Function regTestCompareFiles(rp as IntPTR, index1 as Integer, index2 as Integer) as Integer
End Function

' SRC\regutils.c (704, 1)
' regTestWritePixAndCheck()
' regTestWritePixAndCheck(L_REGPARAMS *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function makes it easy to write the pix in a numbered
'''  * sequence of files, and either to:
'''  * (a) write the golden file ("generate" arg to regression test)
'''  * (b) make a local file and "compare" with the golden file
'''  * (c) make a local file and "display" the results
'''  *   (2) The canonical format of the local filename is:
'''  *   /tmp/lept/regout/[root of main name].[count].[format extension]
'''  * e.g., for scale_reg,
'''  *   /tmp/lept/regout/scale.0.png
'''  * The golden file name mirrors this in the usual way.
'''  *   (3) The check is done between the written files, which requires
'''  * the files to be identical. The exception is for GIF, which
'''  * only requires that all pixels in the decoded pix are identical.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error a failure in comparison is not an error</returns>
''' <param name="rp"> \param[in]    rp       regtest parameters</param>
''' <param name="pix"> \param[in]    pix      to be written</param>
''' <param name="format"> \param[in]    format   of output pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="regTestWritePixAndCheck")> _
Friend Shared Function regTestWritePixAndCheck(rp as IntPTR, pix as IntPTR, format as Integer) as Integer
End Function

' SRC\regutils.c (770, 1)
' regTestWriteDataAndCheck()
' regTestWriteDataAndCheck(L_REGPARAMS *, void *, size_t, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function makes it easy to write data in a numbered
'''  * sequence of files, and either to:
'''  * (a) write the golden file ("generate" arg to regression test)
'''  * (b) make a local file and "compare" with the golden file
'''  * (c) make a local file and "display" the results
'''  *   (2) The canonical format of the local filename is:
'''  *   /tmp/lept/regout/[root of main name].[count].[ext]
'''  * e.g., for the first boxaa in quadtree_reg,
'''  *   /tmp/lept/regout/quadtree.0.baa
'''  * The golden file name mirrors this in the usual way.
'''  *   (3) The data can be anything.  It is most useful for serialized
'''  * output of data, such as boxa, pta, etc.
'''  *   (4) The file extension is arbitrary.  It is included simply
'''  * to make the content type obvious when examining written files.
'''  *   (5) The check is done between the written files, which requires
'''  * the files to be identical.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error a failure in comparison is not an error</returns>
''' <param name="rp"> \param[in]    rp      regtest parameters</param>
''' <param name="data"> \param[in]    data    to be written</param>
''' <param name="nbytes"> \param[in]    nbytes  of data to be written</param>
''' <param name="ext"> \param[in]    ext     filename extension (e.g.: "ba", "pta")</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="regTestWriteDataAndCheck")> _
Friend Shared Function regTestWriteDataAndCheck(rp as IntPTR, data as Object, nbytes as ULong, ext as String) as Integer
End Function

' SRC\regutils.c (821, 1)
' regTestGenLocalFilename()
' regTestGenLocalFilename(L_REGPARAMS *, l_int32, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) This is used to get the name of a file in the regout
'''  * subdirectory, that has been made and is used to test against
'''  * the golden file.  You can either specify a particular index
'''  * value, or with %index == -1, this returns the most recently
'''  * written file.  The latter case lets you read a pix from a
'''  * file that has just been written with regTestWritePixAndCheck(),
'''  * which is useful for testing formatted read/write functions.
'''  *
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  filename if OK, or NULL on error</returns>
''' <param name="rp"> \param[in]       rp      regtest parameters</param>
''' <param name="index"> \param[in]       index   use -1 for current index</param>
''' <param name="format"> \param[in]       format  of image; e.g., IFF_PNG</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="regTestGenLocalFilename")> _
Friend Shared Function regTestGenLocalFilename(rp as IntPTR, index as Integer, format as Integer) as String
End Function

#End Region
#Region "SRC\rop.c"
' SRC\rop.c (193, 1)
' pixRasterop()
' pixRasterop(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This has the standard set of 9 args for rasterop.
'''  * This function is your friend; it is worth memorizing!
'''  *   (2) If the operation involves only dest, this calls
'''  * rasteropUniLow().  Otherwise, checks depth of the
'''  * src and dest, and if they match, calls rasteropLow().
'''  *   (3) For the two-image operation, where both pixs and pixd
'''  * are defined, they are typically different images.  However
'''  * there are cases, such as pixSetMirroredBorder(), where
'''  * in-place operations can be done, blitting pixels from
'''  * one part of pixd to another.  Consequently, we permit
'''  * such operations.  If you use them, be sure that there
'''  * is no overlap between the source and destination rectangles
'''  * in pixd (!)
'''  *
'''  *  Background:
'''  *  -----------
'''  *
'''  *  There are 18 operations, described by the op codes in pix.h.
'''  *
'''  *  One, PIX_DST, is a no-op.
'''  *
'''  *  Three, PIX_CLR, PIX_SET, and PIX_NOT(PIX_DST) operate only on the dest.
'''  *  These are handled by the low-level rasteropUniLow().
'''  *
'''  *  The other 14 involve the both the src and the dest, and depend on
'''  *  the bit values of either just the src or the bit values of both
'''  *  src and dest.  They are handled by rasteropLow():
'''  *
'''  * PIX_SRC  s
'''  * PIX_NOT(PIX_SRC)    ~s
'''  * PIX_SRC | PIX_DST    s | d
'''  * PIX_SRC & PIX_DST    s & d
'''  * PIX_SRC ^ PIX_DST    s ^ d
'''  * PIX_NOT(PIX_SRC) | PIX_DST   ~s | d
'''  * PIX_NOT(PIX_SRC) & PIX_DST   ~s & d
'''  * PIX_NOT(PIX_SRC) ^ PIX_DST   ~s ^ d
'''  * PIX_SRC | PIX_NOT(PIX_DST) s | ~d
'''  * PIX_SRC & PIX_NOT(PIX_DST) s & ~d
'''  * PIX_SRC ^ PIX_NOT(PIX_DST) s ^ ~d
'''  * PIX_NOT(PIX_SRC | PIX_DST)   ~(s | d)
'''  * PIX_NOT(PIX_SRC & PIX_DST)   ~(s & d)
'''  * PIX_NOT(PIX_SRC ^ PIX_DST)   ~(s ^ d)
'''  *
'''  *  Each of these is implemented with one of three low-level
'''  *  functions, depending on the alignment of the left edge
'''  *  of the src and dest rectangles:
'''  *   * a fastest implementation if both left edges are
'''  *  (32-bit) word aligned
'''  *   * a very slightly slower implementation if both left
'''  *  edges have the same relative (32-bit) word alignment
'''  *   * the general routine that is invoked when
'''  *  both left edges have different word alignment
'''  *
'''  *  Of the 14 binary rasterops above, only 12 are unique
'''  *  logical combinations (out of a possible 16) of src
'''  *  and dst bits:
'''  *
'''  *  (sd)   (11)   (10)   (01)   (00)
'''  *   -----------------------------------------------
'''  *   s   1   1   0   0
'''  *  ~s   0   1   0   1
'''  * s | d 1   1   1   0
'''  * s & d 1   0   0   0
'''  * s ^ d 0   1   1   0
'''  *   ~s | d 1   0   1   1
'''  *   ~s & d 0   0   1   0
'''  *   ~s ^ d 1   0   0   1
'''  * s | ~d   1   1   0   1
'''  * s & ~d   0   1   0   0
'''  * s ^ ~d   1   0   0   1
'''  *   ~(s | d)  0   0   0   1
'''  *   ~(s & d)  0   1   1   1
'''  *   ~(s ^ d)  1   0   0   1
'''  *
'''  *  Note that the following three operations are equivalent:
'''  *   ~(s ^ d)
'''  *   ~s ^ d
'''  *   s ^ ~d
'''  *  and in the implementation, we call them out with the first form;
'''  *  namely, ~(s ^ d).
'''  *
'''  *  Of the 16 possible binary combinations of src and dest bits,
'''  *  the remaining 4 unique ones are independent of the src bit.
'''  *  They depend on either just the dest bit or on neither
'''  *  the src nor dest bits:
'''  *
'''  *   d   1   0   1   0 (indep. of s)
'''  *  ~d   0   1   0   1 (indep. of s)
'''  *  CLR  0   0   0   0 (indep. of both s & d)
'''  *  SET  1   1   1   1 (indep. of both s & d)
'''  *
'''  *  As mentioned above, three of these are implemented by
'''  *  rasteropUniLow(), and one is a no-op.
'''  *
'''  *  How can these operation codes be represented by bits
'''  *  in such a way that when the basic operations are performed
'''  *  on the bits the results are unique for unique
'''  *  operations, and mimic the logic table given above?
'''  *
'''  *  The answer is to choose a particular order of the pairings:
'''  *   (sd)   (11)   (10)   (01)   (00)
'''  *  (which happens to be the same as in the above table)
'''  *  and to translate the result into 4-bit representations
'''  *  of s and d.  For example, the Sun rasterop choice
'''  *  (omitting the extra bit for clipping) is
'''  *
'''  *   PIX_SRC   0xc
'''  *   PIX_DST   0xa
'''  *
'''  *  This corresponds to our pairing order given above:
'''  *   (sd)   (11)   (10)   (01)   (00)
'''  *  where for s = 1 we get the bit pattern
'''  * PIX_SRC:  1   1   0   0  (0xc)
'''  *  and for d = 1 we get the pattern
'''  * PIX_DST:   1   0   1   0 (0xa)
'''  *
'''  *  OK, that's the pairing order that Sun chose.  How many different
'''  *  ways can we assign bit patterns to PIX_SRC and PIX_DST to get
'''  *  the boolean ops to work out?  Any of the 4 pairs can be put
'''  *  in the first position, any of the remaining 3 pairs can go
'''  *  in the second; and one of the remaining 2 pairs can go the the third.
'''  *  There is a total of 4*3*2 = 24 ways these pairs can be permuted.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error.</returns>
''' <param name="pixd"> \param[in]    pixd   dest pix</param>
''' <param name="dx"> \param[in]    dx     x val of UL corner of dest rectangle</param>
''' <param name="dy"> \param[in]    dy     y val of UL corner of dest rectangle</param>
''' <param name="dw"> \param[in]    dw     width of dest rectangle</param>
''' <param name="dh"> \param[in]    dh     height of dest rectangle</param>
''' <param name="op"> \param[in]    op     op code</param>
''' <param name="pixs"> \param[in]    pixs   src pix</param>
''' <param name="sx"> \param[in]    sx     x val of UL corner of src rectangle</param>
''' <param name="sy"> \param[in]    sy     y val of UL corner of src rectangle</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRasterop")> _
Friend Shared Function pixRasterop(pixd as IntPTR, dx as Integer, dy as Integer, dw as Integer, dh as Integer, op as Integer, pixs as IntPTR, sx as Integer, sy as Integer) as Integer
End Function

' SRC\rop.c (269, 1)
' pixRasteropVip()
' pixRasteropVip(PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This rasterop translates a vertical band of the
'''  * image either up or down, bringing in either white
'''  * or black pixels from outside the image.
'''  *   (2) The vertical band extends the full height of pixd.
'''  *   (3) If a colormap exists, the nearest color to white or black
'''  * is brought in.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]    pixd     in-place</param>
''' <param name="bx"> \param[in]    bx       left edge of vertical band</param>
''' <param name="bw"> \param[in]    bw       width of vertical band</param>
''' <param name="vshift"> \param[in]    vshift   vertical shift of band; vshift > 0 is down</param>
''' <param name="incolor"> \param[in]    incolor  L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRasteropVip")> _
Friend Shared Function pixRasteropVip(pixd as IntPTR, bx as Integer, bw as Integer, vshift as Integer, incolor as Integer) as Integer
End Function

' SRC\rop.c (347, 1)
' pixRasteropHip()
' pixRasteropHip(PIX *, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This rasterop translates a horizontal band of the
'''  * image either left or right, bringing in either white
'''  * or black pixels from outside the image.
'''  *   (2) The horizontal band extends the full width of pixd.
'''  *   (3) If a colormap exists, the nearest color to white or black
'''  * is brought in.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]    pixd     in-place operation</param>
''' <param name="by"> \param[in]    by       top of horizontal band</param>
''' <param name="bh"> \param[in]    bh       height of horizontal band</param>
''' <param name="hshift"> \param[in]    hshift   horizontal shift of band; hshift > 0 is to right</param>
''' <param name="incolor"> \param[in]    incolor  L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRasteropHip")> _
Friend Shared Function pixRasteropHip(pixd as IntPTR, by as Integer, bh as Integer, hshift as Integer, incolor as Integer) as Integer
End Function

' SRC\rop.c (431, 1)
' pixTranslate()
' pixTranslate(PIX *, PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The general pattern is:
'''  *   pixd = pixTranslate(pixd, pixs, ...);
'''  * For clarity, when you know the case, use one of these:
'''  *   pixd = pixTranslate(NULL, pixs, ...);  // new
'''  *   pixTranslate(pixs, pixs, ...);   // in-place
'''  *   pixTranslate(pixd, pixs, ...);   // to existing pixd
'''  *   (2) If an existing pixd is not the same size as pixs, the
'''  * image data will be reallocated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error.</returns>
''' <param name="pixd"> \param[in]    pixd    [optional] destination: this can be null,</param>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="hshift"> \param[in]    hshift   horizontal shift; hshift > 0 is to right</param>
''' <param name="vshift"> \param[in]    vshift   vertical shift; vshift > 0 is down</param>
''' <param name="incolor"> \param[in]    incolor  L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixTranslate")> _
Friend Shared Function pixTranslate(pixd as IntPTR, pixs as IntPTR, hshift as Integer, vshift as Integer, incolor as Integer) as IntPTR
End Function

' SRC\rop.c (461, 1)
' pixRasteropIP()
' pixRasteropIP(PIX *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]    pixd     in-place translation</param>
''' <param name="hshift"> \param[in]    hshift   horizontal shift; hshift > 0 is to right</param>
''' <param name="vshift"> \param[in]    vshift   vertical shift; vshift > 0 is down</param>
''' <param name="incolor"> \param[in]    incolor  L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRasteropIP")> _
Friend Shared Function pixRasteropIP(pixd as IntPTR, hshift as Integer, vshift as Integer, incolor as Integer) as Integer
End Function

' SRC\rop.c (502, 1)
' pixRasteropFullImage()
' pixRasteropFullImage(PIX *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   ~ this is a wrapper for a common 2-image raster operation
'''  *   ~ both pixs and pixd must be defined
'''  *   ~ the operation is performed with aligned UL corners of pixs and pixd
'''  *   ~ the operation clips to the smallest pix; if the width or height
'''  *  of pixd is larger than pixs, some pixels in pixd will be unchanged
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]    pixd</param>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="op"> \param[in]    op     any of the op-codes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRasteropFullImage")> _
Friend Shared Function pixRasteropFullImage(pixd as IntPTR, pixs as IntPTR, op as Integer) as Integer
End Function

#End Region
#Region "SRC\roplow.c"
' SRC\roplow.c (54, 13)
' rasteropUniWordAlignedLow()
' rasteropUniWordAlignedLow(l_uint32 *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="datad"> \param[in]    datad  ptr to dest image data</param>
''' <param name="dwpl"> \param[in]    dwpl   wpl of dest</param>
''' <param name="dx"> \param[in]    dx     x val of UL corner of dest rectangle</param>
''' <param name="dy"> \param[in]    dy     y val of UL corner of dest rectangle</param>
''' <param name="dw"> \param[in]    dw     width of dest rectangle</param>
''' <param name="dh"> \param[in]    dh     height of dest rectangle</param>
''' <param name="op"> \param[in]    op     op code</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rasteropUniWordAlignedLow")> _
Friend Shared Function rasteropUniWordAlignedLow(datad as UInteger, dwpl as Integer, dx as Integer, dy as Integer, dw as Integer, dh as Integer, op as Integer) as Boolean ' Org. Void
End Function

' SRC\roplow.c (57, 13)
' rasteropUniGeneralLow()
' rasteropUniGeneralLow(l_uint32 *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="datad"> \param[in]    datad  ptr to dest image data</param>
''' <param name="dwpl"> \param[in]    dwpl   wpl of dest</param>
''' <param name="dx"> \param[in]    dx     x val of UL corner of dest rectangle</param>
''' <param name="dy"> \param[in]    dy     y val of UL corner of dest rectangle</param>
''' <param name="dw"> \param[in]    dw     width of dest rectangle</param>
''' <param name="dh"> \param[in]    dh     height of dest rectangle</param>
''' <param name="op"> \param[in]    op     op code</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rasteropUniGeneralLow")> _
Friend Shared Function rasteropUniGeneralLow(datad as UInteger, dwpl as Integer, dx as Integer, dy as Integer, dw as Integer, dh as Integer, op as Integer) as Boolean ' Org. Void
End Function

' SRC\roplow.c (60, 13)
' rasteropWordAlignedLow()
' rasteropWordAlignedLow(l_uint32 *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="datad"> \param[in]    datad  ptr to dest image data</param>
''' <param name="dwpl"> \param[in]    dwpl   wpl of dest</param>
''' <param name="dx"> \param[in]    dx     x val of UL corner of dest rectangle</param>
''' <param name="dy"> \param[in]    dy     y val of UL corner of dest rectangle</param>
''' <param name="dw"> \param[in]    dw     width of dest rectangle</param>
''' <param name="dh"> \param[in]    dh     height of dest rectangle</param>
''' <param name="op"> \param[in]    op     op code</param>
''' <param name="datas"> \param[in]    datas  ptr to src image data</param>
''' <param name="swpl"> \param[in]    swpl   wpl of src</param>
''' <param name="sx"> \param[in]    sx     x val of UL corner of src rectangle</param>
''' <param name="sy"> \param[in]    sy     y val of UL corner of src rectangle</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rasteropWordAlignedLow")> _
Friend Shared Function rasteropWordAlignedLow(datad as UInteger, dwpl as Integer, dx as Integer, dy as Integer, dw as Integer, dh as Integer, op as Integer, datas as UInteger, swpl as Integer, sx as Integer, sy as Integer) as Boolean ' Org. Void
End Function

' SRC\roplow.c (64, 13)
' rasteropVAlignedLow()
' rasteropVAlignedLow(l_uint32 *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="datad"> \param[in]    datad  ptr to dest image data</param>
''' <param name="dwpl"> \param[in]    dwpl   wpl of dest</param>
''' <param name="dx"> \param[in]    dx     x val of UL corner of dest rectangle</param>
''' <param name="dy"> \param[in]    dy     y val of UL corner of dest rectangle</param>
''' <param name="dw"> \param[in]    dw     width of dest rectangle</param>
''' <param name="dh"> \param[in]    dh     height of dest rectangle</param>
''' <param name="op"> \param[in]    op     op code</param>
''' <param name="datas"> \param[in]    datas  ptr to src image data</param>
''' <param name="swpl"> \param[in]    swpl   wpl of src</param>
''' <param name="sx"> \param[in]    sx     x val of UL corner of src rectangle</param>
''' <param name="sy"> \param[in]    sy     y val of UL corner of src rectangle</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rasteropVAlignedLow")> _
Friend Shared Function rasteropVAlignedLow(datad as UInteger, dwpl as Integer, dx as Integer, dy as Integer, dw as Integer, dh as Integer, op as Integer, datas as UInteger, swpl as Integer, sx as Integer, sy as Integer) as Boolean ' Org. Void
End Function

' SRC\roplow.c (68, 13)
' rasteropGeneralLow()
' rasteropGeneralLow(l_uint32 *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="datad"> \param[in]    datad  ptr to dest image data</param>
''' <param name="dwpl"> \param[in]    dwpl   wpl of dest</param>
''' <param name="dx"> \param[in]    dx     x val of UL corner of dest rectangle</param>
''' <param name="dy"> \param[in]    dy     y val of UL corner of dest rectangle</param>
''' <param name="dw"> \param[in]    dw     width of dest rectangle</param>
''' <param name="dh"> \param[in]    dh     height of dest rectangle</param>
''' <param name="op"> \param[in]    op     op code</param>
''' <param name="datas"> \param[in]    datas  ptr to src image data</param>
''' <param name="swpl"> \param[in]    swpl   wpl of src</param>
''' <param name="sx"> \param[in]    sx     x val of UL corner of src rectangle</param>
''' <param name="sy"> \param[in]    sy     y val of UL corner of src rectangle</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rasteropGeneralLow")> _
Friend Shared Function rasteropGeneralLow(datad as UInteger, dwpl as Integer, dx as Integer, dy as Integer, dw as Integer, dh as Integer, op as Integer, datas as UInteger, swpl as Integer, sx as Integer, sy as Integer) as Boolean ' Org. Void
End Function

' SRC\roplow.c (72, 13)
' shiftDataHorizontalLow()
' shiftDataHorizontalLow(l_uint32 *, l_int32, l_uint32 *, l_int32, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) This can also be used for in-place operation; see, e.g.,
'''  * rasteropHipLow().
'''  *   (2) We are clearing the pixels that are shifted in from
'''  * outside the image.  This can be overridden by the
'''  * incolor parameter in higher-level functions that call this.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="datad"> \param[in]    datad  ptr to beginning of dest line</param>
''' <param name="wpld"> \param[in]    wpld   wpl of dest</param>
''' <param name="datas"> \param[in]    datas  ptr to beginning of src line</param>
''' <param name="wpls"> \param[in]    wpls   wpl of src</param>
''' <param name="shift"> \param[in]    shift  horizontal shift of block; >0 is to right</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="shiftDataHorizontalLow")> _
Friend Shared Function shiftDataHorizontalLow(datad as UInteger, wpld as Integer, datas as UInteger, wpls as Integer, shift as Integer) as Boolean ' Org. Void
End Function

' SRC\roplow.c (124, 1)
' rasteropUniLow()
' rasteropUniLow(l_uint32 *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="datad"> \param[in]    datad  ptr to dest image data</param>
''' <param name="dpixw"> \param[in]    dpixw  width of dest</param>
''' <param name="dpixh"> \param[in]    dpixh  height of dest</param>
''' <param name="depth"> \param[in]    depth  depth of src and dest</param>
''' <param name="dwpl"> \param[in]    dwpl   wpl of dest</param>
''' <param name="dx"> \param[in]    dx     x val of UL corner of dest rectangle</param>
''' <param name="dy"> \param[in]    dy     y val of UL corner of dest rectangle</param>
''' <param name="dw"> \param[in]    dw     width of dest rectangle</param>
''' <param name="dh"> \param[in]    dh     height of dest rectangle</param>
''' <param name="op"> \param[in]    op     op code</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rasteropUniLow")> _
Friend Shared Function rasteropUniLow(datad as UInteger, dpixw as Integer, dpixh as Integer, depth as Integer, dwpl as Integer, dx as Integer, dy as Integer, dw as Integer, dh as Integer, op as Integer) as Boolean ' Org. Void
End Function

' SRC\roplow.c (481, 1)
' rasteropLow()
' rasteropLow(l_uint32 *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="datad"> \param[in]    datad  ptr to dest image data</param>
''' <param name="dpixw"> \param[in]    dpixw  width of dest</param>
''' <param name="dpixh"> \param[in]    dpixh  height of dest</param>
''' <param name="depth"> \param[in]    depth  depth of src and dest</param>
''' <param name="dwpl"> \param[in]    dwpl   wpl of dest</param>
''' <param name="dx"> \param[in]    dx     x val of UL corner of dest rectangle</param>
''' <param name="dy"> \param[in]    dy     y val of UL corner of dest rectangle</param>
''' <param name="dw"> \param[in]    dw     width of dest rectangle</param>
''' <param name="dh"> \param[in]    dh     height of dest rectangle</param>
''' <param name="op"> \param[in]    op     op code</param>
''' <param name="datas"> \param[in]    datas  ptr to src image data</param>
''' <param name="spixw"> \param[in]    spixw  width of src</param>
''' <param name="spixh"> \param[in]    spixh  height of src</param>
''' <param name="swpl"> \param[in]    swpl   wpl of src</param>
''' <param name="sx"> \param[in]    sx     x val of UL corner of src rectangle</param>
''' <param name="sy"> \param[in]    sy     y val of UL corner of src rectangle</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rasteropLow")> _
Friend Shared Function rasteropLow(datad as UInteger, dpixw as Integer, dpixh as Integer, depth as Integer, dwpl as Integer, dx as Integer, dy as Integer, dw as Integer, dh as Integer, op as Integer, datas as UInteger, spixw as Integer, spixh as Integer, swpl as Integer, sx as Integer, sy as Integer) as Boolean ' Org. Void
End Function

' SRC\roplow.c (2146, 1)
' rasteropVipLow()
' rasteropVipLow(l_uint32 *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) This clears the pixels that are left exposed after the
'''  * translation.  You can consider them as pixels that are
'''  * shifted in from outside the image.  This can be later
'''  * overridden by the incolor parameter in higher-level functions
'''  * that call this.  For example, for images with depth > 1,
'''  * these pixels are cleared to black; to be white they
'''  * must later be SET to white.  See, e.g., pixRasteropVip().
'''  *   (2) This function scales the width to accommodate any depth,
'''  * performs clipping, and then does the in-place rasterop.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error.</returns>
''' <param name="data"> \param[in]    data   ptr to image data</param>
''' <param name="pixw"> \param[in]    pixw   width</param>
''' <param name="pixh"> \param[in]    pixh   height</param>
''' <param name="depth"> \param[in]    depth  depth</param>
''' <param name="wpl"> \param[in]    wpl    wpl</param>
''' <param name="x"> \param[in]    x      x val of UL corner of rectangle</param>
''' <param name="w"> \param[in]    w      width of rectangle</param>
''' <param name="shift"> \param[in]    shift  + shifts data downward in vertical column</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rasteropVipLow")> _
Friend Shared Function rasteropVipLow(data as UInteger, pixw as Integer, pixh as Integer, depth as Integer, wpl as Integer, x as Integer, w as Integer, shift as Integer) as Boolean ' Org. Void
End Function

' SRC\roplow.c (2359, 1)
' rasteropHipLow()
' rasteropHipLow(l_uint32 *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) This clears the pixels that are left exposed after the rasterop.
'''  * Therefore, for Pix with depth > 1, these pixels become black,
'''  * and must be subsequently SET if they are to be white.
'''  * For example, see pixRasteropHip().
'''  *   (2) This function performs clipping and calls shiftDataHorizontalLow()
'''  * to do the in-place rasterop on each line.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error.</returns>
''' <param name="data"> \param[in]    data   ptr to image data</param>
''' <param name="pixh"> \param[in]    pixh   height</param>
''' <param name="depth"> \param[in]    depth  depth</param>
''' <param name="wpl"> \param[in]    wpl    wpl</param>
''' <param name="y"> \param[in]    y      y val of UL corner of rectangle</param>
''' <param name="h"> \param[in]    h      height of rectangle</param>
''' <param name="shift"> \param[in]    shift  + shifts data to the left in a horizontal column</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rasteropHipLow")> _
Friend Shared Function rasteropHipLow(data as UInteger, pixh as Integer, depth as Integer, wpl as Integer, y as Integer, h as Integer, shift as Integer) as Boolean ' Org. Void
End Function

#End Region
#Region "SRC\rotate.c"
' SRC\rotate.c (99, 1)
' pixRotate()
' pixRotate(PIX *, l_float32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a high-level, simple interface for rotating images
'''  * about their center.
'''  *   (2) For very small rotations, just return a clone.
'''  *   (3) Rotation brings either white or black pixels in
'''  * from outside the image.
'''  *   (4) The rotation type is adjusted if necessary for the image
'''  * depth and size of rotation angle.  For 1 bpp images, we
'''  * rotate either by shear or sampling.
'''  *   (5) Colormaps are removed for rotation by area mapping.
'''  *   (6) The dest can be expanded so that no image pixels
'''  * are lost.  To invoke expansion, input the original
'''  * width and height.  For repeated rotation, use of the
'''  * original width and height allows the expansion to
'''  * stop at the maximum required size, which is a square
'''  * with side = sqrt(w*w + h*h).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     1, 2, 4, 8, 32 bpp rgb</param>
''' <param name="angle"> \param[in]    angle    radians; clockwise is positive</param>
''' <param name="type"> \param[in]    type     L_ROTATE_AREA_MAP, L_ROTATE_SHEAR, L_ROTATE_SAMPLING</param>
''' <param name="incolor"> \param[in]    incolor  L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
''' <param name="width"> \param[in]    width    original width; use 0 to avoid embedding</param>
''' <param name="height"> \param[in]    height   original height; use 0 to avoid embedding</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotate")> _
Friend Shared Function pixRotate(pixs as IntPTR, angle as single, type as Integer, incolor as Integer, width as Integer, height as Integer) as IntPTR
End Function

' SRC\rotate.c (241, 1)
' pixEmbedForRotation()
' pixEmbedForRotation(PIX *, l_float32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For very small rotations, just return a clone.
'''  *   (2) Generate larger image to embed pixs if necessary, and
'''  * place the center of the input image in the center.
'''  *   (3) Rotation brings either white or black pixels in
'''  * from outside the image.  For colormapped images where
'''  * there is no white or black, a new color is added if
'''  * possible for these pixels; otherwise, either the
'''  * lightest or darkest color is used.  In most cases,
'''  * the colormap will be removed prior to rotation.
'''  *   (4) The dest is to be expanded so that no image pixels
'''  * are lost after rotation.  Input of the original width
'''  * and height allows the expansion to stop at the maximum
'''  * required size, which is a square with side equal to
'''  * sqrt(w*w + h*h).
'''  *   (5) For an arbitrary angle, the expansion can be found by
'''  * considering the UL and UR corners.  As the image is
'''  * rotated, these move in an arc centered at the center of
'''  * the image.  Normalize to a unit circle by dividing by half
'''  * the image diagonal.  After a rotation of T radians, the UL
'''  * and UR corners are at points T radians along the unit
'''  * circle.  Compute the x and y coordinates of both these
'''  * points and take the max of absolute values; these represent
'''  * the half width and half height of the containing rectangle.
'''  * The arithmetic is done using formulas for sin(a+b) and cos(a+b),
'''  * where b = T.  For the UR corner, sin(a) = h/d and cos(a) = w/d.
'''  * For the UL corner, replace a by (pi - a), and you have
'''  * sin(pi - a) = h/d, cos(pi - a) = -w/d.  The equations
'''  * given below follow directly.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs      1, 2, 4, 8, 32 bpp rgb</param>
''' <param name="angle"> \param[in]    angle     radians; clockwise is positive</param>
''' <param name="incolor"> \param[in]    incolor   L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
''' <param name="width"> \param[in]    width     original width; use 0 to avoid embedding</param>
''' <param name="height"> \param[in]    height    original height; use 0 to avoid embedding</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixEmbedForRotation")> _
Friend Shared Function pixEmbedForRotation(pixs as IntPTR, angle as single, incolor as Integer, width as Integer, height as Integer) as IntPTR
End Function

' SRC\rotate.c (322, 1)
' pixRotateBySampling()
' pixRotateBySampling(PIX *, l_int32, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For very small rotations, just return a clone.
'''  *   (2) Rotation brings either white or black pixels in
'''  * from outside the image.
'''  *   (3) Colormaps are retained.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     1, 2, 4, 8, 16, 32 bpp rgb; can be cmapped</param>
''' <param name="xcen"> \param[in]    xcen     x value of center of rotation</param>
''' <param name="ycen"> \param[in]    ycen     y value of center of rotation</param>
''' <param name="angle"> \param[in]    angle    radians; clockwise is positive</param>
''' <param name="incolor"> \param[in]    incolor  L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateBySampling")> _
Friend Shared Function pixRotateBySampling(pixs as IntPTR, xcen as Integer, ycen as Integer, angle as single, incolor as Integer) as IntPTR
End Function

' SRC\rotate.c (455, 1)
' pixRotateBinaryNice()
' pixRotateBinaryNice(PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) For very small rotations, just return a clone.
'''  *   (2) This does a computationally expensive rotation of 1 bpp images.
'''  * The fastest rotators (using shears or subsampling) leave
'''  * visible horizontal and vertical shear lines across which
'''  * the image shear changes by one pixel.  To ameliorate the
'''  * visual effect one can introduce random dithering.  One
'''  * way to do this in a not-too-random fashion is given here.
'''  * We convert to 8 bpp, do a very small blur, rotate using
'''  * linear interpolation (same as area mapping), do a
'''  * small amount of sharpening to compensate for the initial
'''  * blur, and threshold back to binary.  The shear lines
'''  * are magically removed.
'''  *   (3) This operation is about 5x slower than rotation by sampling.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     1 bpp</param>
''' <param name="angle"> \param[in]    angle    radians; clockwise is positive; about the center</param>
''' <param name="incolor"> \param[in]    incolor  L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateBinaryNice")> _
Friend Shared Function pixRotateBinaryNice(pixs as IntPTR, angle as single, incolor as Integer) as IntPTR
End Function

' SRC\rotate.c (533, 1)
' pixRotateWithAlpha()
' pixRotateWithAlpha(PIX *, l_float32, PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The alpha channel is transformed separately from pixs,
'''  * and aligns with it, being fully transparent outside the
'''  * boundary of the transformed pixs.  For pixels that are fully
'''  * transparent, a blending function like pixBlendWithGrayMask()
'''  * will give zero weight to corresponding pixels in pixs.
'''  *   (2) Rotation is about the center of the image; for very small
'''  * rotations, just return a clone.  The dest is automatically
'''  * expanded so that no image pixels are lost.
'''  *   (3) Rotation is by area mapping.  It doesn't matter what
'''  * color is brought in because the alpha channel will
'''  * be transparent (black) there.
'''  *   (4) If pixg is NULL, it is generated as an alpha layer that is
'''  * partially opaque, using %fract.  Otherwise, it is cropped
'''  * to pixs if required and %fract is ignored.  The alpha
'''  * channel in pixs is never used.
'''  *   (4) Colormaps are removed to 32 bpp.
'''  *   (5) The default setting for the border values in the alpha channel
'''  * is 0 (transparent) for the outermost ring of pixels and
'''  * (0.5 * fract * 255) for the second ring.  When blended over
'''  * a second image, this
'''  * (a) shrinks the visible image to make a clean overlap edge
'''  *  with an image below, and
'''  * (b) softens the edges by weakening the aliasing there.
'''  * Use l_setAlphaMaskBorder() to change these values.
'''  *   (6) A subtle use of gamma correction is to remove gamma correction
'''  * before rotation and restore it afterwards.  This is done
'''  * by sandwiching this function between a gamma/inverse-gamma
'''  * photometric transform:
'''  *  pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);
'''  *  pixd = pixRotateWithAlpha(pixt, angle, NULL, fract);
'''  *  pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);
'''  *  pixDestroy(&pixt);
'''  * This has the side-effect of producing artifacts in the very
'''  * dark regions.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp rgba, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs     32 bpp rgb or cmapped</param>
''' <param name="angle"> \param[in]    angle    radians; clockwise is positive</param>
''' <param name="pixg"> \param[in]    pixg     [optional] 8 bpp, can be null</param>
''' <param name="fract"> \param[in]    fract    between 0.0 and 1.0, with 0.0 fully transparent</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateWithAlpha")> _
Friend Shared Function pixRotateWithAlpha(pixs as IntPTR, angle as single, pixg as IntPTR, fract as single) as IntPTR
End Function

#End Region
#Region "SRC\rotateam.c"
' SRC\rotateam.c (109, 13)
' 
' rotateAMColorLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_float32, l_uint32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rotateAMColorLow")> _
Friend Shared Function rotateAMColorLow(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, angle as single, colorval as UInteger) as Boolean ' Org. Void
End Function

' SRC\rotateam.c (112, 13)
' 
' rotateAMGrayLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_float32, l_uint8) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rotateAMGrayLow")> _
Friend Shared Function rotateAMGrayLow(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, angle as single, grayval as Byte) as Boolean ' Org. Void
End Function

' SRC\rotateam.c (115, 13)
' 
' rotateAMColorCornerLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_float32, l_uint32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rotateAMColorCornerLow")> _
Friend Shared Function rotateAMColorCornerLow(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, angle as single, colorval as UInteger) as Boolean ' Org. Void
End Function

' SRC\rotateam.c (119, 13)
' 
' rotateAMGrayCornerLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_float32, l_uint8) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rotateAMGrayCornerLow")> _
Friend Shared Function rotateAMGrayCornerLow(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, angle as single, grayval as Byte) as Boolean ' Org. Void
End Function

' SRC\rotateam.c (123, 13)
' rotateAMColorFastLow()
' rotateAMColorFastLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_float32, l_uint32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="rotateAMColorFastLow")> _
Friend Shared Function rotateAMColorFastLow(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datas as UInteger, wpls as Integer, angle as single, colorval as UInteger) as Boolean ' Org. Void
End Function

' SRC\rotateam.c (149, 1)
' pixRotateAM()
' pixRotateAM(PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Rotates about image center.
'''  *   (2) A positive angle gives a clockwise rotation.
'''  *   (3) Brings in either black or white pixels from the boundary.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 2, 4, 8 bpp gray or colormapped, or 32 bpp RGB</param>
''' <param name="angle"> \param[in]    angle radians; clockwise is positive</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateAM")> _
Friend Shared Function pixRotateAM(pixs as IntPTR, angle as single, incolor as Integer) as IntPTR
End Function

' SRC\rotateam.c (212, 1)
' pixRotateAMColor()
' pixRotateAMColor(PIX *, l_float32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Rotates about image center.
'''  *   (2) A positive angle gives a clockwise rotation.
'''  *   (3) Specify the color to be brought in from outside the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp</param>
''' <param name="angle"> \param[in]    angle radians; clockwise is positive</param>
''' <param name="colorval"> \param[in]    colorval e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateAMColor")> _
Friend Shared Function pixRotateAMColor(pixs as IntPTR, angle as single, colorval as UInteger) as IntPTR
End Function

' SRC\rotateam.c (266, 1)
' pixRotateAMGray()
' pixRotateAMGray(PIX *, l_float32, l_uint8) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Rotates about image center.
'''  *   (2) A positive angle gives a clockwise rotation.
'''  *   (3) Specify the grayvalue to be brought in from outside the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="angle"> \param[in]    angle radians; clockwise is positive</param>
''' <param name="grayval"> \param[in]    grayval 0 to bring in BLACK, 255 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateAMGray")> _
Friend Shared Function pixRotateAMGray(pixs as IntPTR, angle as single, grayval as Byte) as IntPTR
End Function

' SRC\rotateam.c (447, 1)
' pixRotateAMCorner()
' pixRotateAMCorner(PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Rotates about the UL corner of the image.
'''  *   (2) A positive angle gives a clockwise rotation.
'''  *   (3) Brings in either black or white pixels from the boundary.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8 bpp gray or colormapped, or 32 bpp RGB</param>
''' <param name="angle"> \param[in]    angle radians; clockwise is positive</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateAMCorner")> _
Friend Shared Function pixRotateAMCorner(pixs as IntPTR, angle as single, incolor as Integer) as IntPTR
End Function

' SRC\rotateam.c (508, 1)
' pixRotateAMColorCorner()
' pixRotateAMColorCorner(PIX *, l_float32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Rotates the image about the UL corner.
'''  *   (2) A positive angle gives a clockwise rotation.
'''  *   (3) Specify the color to be brought in from outside the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="angle"> \param[in]    angle radians; clockwise is positive</param>
''' <param name="fillval"> \param[in]    fillval e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateAMColorCorner")> _
Friend Shared Function pixRotateAMColorCorner(pixs as IntPTR, angle as single, fillval as UInteger) as IntPTR
End Function

' SRC\rotateam.c (562, 1)
' pixRotateAMGrayCorner()
' pixRotateAMGrayCorner(PIX *, l_float32, l_uint8) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Rotates the image about the UL corner.
'''  *   (2) A positive angle gives a clockwise rotation.
'''  *   (3) Specify the grayvalue to be brought in from outside the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="angle"> \param[in]    angle radians; clockwise is positive</param>
''' <param name="grayval"> \param[in]    grayval 0 to bring in BLACK, 255 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateAMGrayCorner")> _
Friend Shared Function pixRotateAMGrayCorner(pixs as IntPTR, angle as single, grayval as Byte) as IntPTR
End Function

' SRC\rotateam.c (741, 1)
' pixRotateAMColorFast()
' pixRotateAMColorFast(PIX *, l_float32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This rotates a color image about the image center.
'''  *   (2) A positive angle gives a clockwise rotation.
'''  *   (3) It uses area mapping, dividing each pixel into
'''  * 16 subpixels.
'''  *   (4) It is about 10% to 20% faster than the more accurate linear
'''  * interpolation function pixRotateAMColor(),
'''  * which uses 256 subpixels.
'''  *   (5) For some reason it shifts the image center.
'''  * No attempt is made to rotate the alpha component.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="angle"> \param[in]    angle radians; clockwise is positive</param>
''' <param name="colorval"> \param[in]    colorval e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateAMColorFast")> _
Friend Shared Function pixRotateAMColorFast(pixs as IntPTR, angle as single, colorval as UInteger) as IntPTR
End Function

#End Region
#Region "SRC\rotateorth.c"
' SRC\rotateorth.c (56, 17)
' makeReverseByteTab1()
' makeReverseByteTab1() as l_uint8 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeReverseByteTab1")> _
Friend Shared Function makeReverseByteTab1() as String
End Function

' SRC\rotateorth.c (57, 17)
' makeReverseByteTab2()
' makeReverseByteTab2() as l_uint8 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeReverseByteTab2")> _
Friend Shared Function makeReverseByteTab2() as String
End Function

' SRC\rotateorth.c (58, 17)
' makeReverseByteTab4()
' makeReverseByteTab4() as l_uint8 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeReverseByteTab4")> _
Friend Shared Function makeReverseByteTab4() as String
End Function

' SRC\rotateorth.c (72, 1)
' pixRotateOrth()
' pixRotateOrth(PIX *, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths</param>
''' <param name="quads"> \param[in]    quads 0-3; number of 90 degree cw rotations</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateOrth")> _
Friend Shared Function pixRotateOrth(pixs as IntPTR, quads as Integer) as IntPTR
End Function

' SRC\rotateorth.c (121, 1)
' pixRotate180()
' pixRotate180(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does a 180 rotation of the image about the center,
'''  * which is equivalent to a left-right flip about a vertical
'''  * line through the image center, followed by a top-bottom
'''  * flip about a horizontal line through the image center.
'''  *   (2) There are 3 cases for input:
'''  * (a) pixd == null (creates a new pixd)
'''  * (b) pixd == pixs (in-place operation)
'''  * (c) pixd != pixs (existing pixd)
'''  *   (3) For clarity, use these three patterns, respectively:
'''  * (a) pixd = pixRotate180(NULL, pixs);
'''  * (b) pixRotate180(pixs, pixs);
'''  * (c) pixRotate180(pixd, pixs);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs all depths</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotate180")> _
Friend Shared Function pixRotate180(pixd as IntPTR, pixs as IntPTR) as IntPTR
End Function

' SRC\rotateorth.c (163, 1)
' pixRotate90()
' pixRotate90(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does a 90 degree rotation of the image about the center,
'''  * either cw or ccw, returning a new pix.
'''  *   (2) The direction must be either 1 (cw) or -1 (ccw).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths</param>
''' <param name="direction"> \param[in]    direction 1 = clockwise,  -1 = counter-clockwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotate90")> _
Friend Shared Function pixRotate90(pixs as IntPTR, direction as Integer) as IntPTR
End Function

' SRC\rotateorth.c (423, 1)
' pixFlipLR()
' pixFlipLR(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does a left-right flip of the image, which is
'''  * equivalent to a rotation out of the plane about a
'''  * vertical line through the image center.
'''  *   (2) There are 3 cases for input:
'''  * (a) pixd == null (creates a new pixd)
'''  * (b) pixd == pixs (in-place operation)
'''  * (c) pixd != pixs (existing pixd)
'''  *   (3) For clarity, use these three patterns, respectively:
'''  * (a) pixd = pixFlipLR(NULL, pixs);
'''  * (b) pixFlipLR(pixs, pixs);
'''  * (c) pixFlipLR(pixd, pixs);
'''  *   (4) If an existing pixd is not the same size as pixs, the
'''  * image data will be reallocated.
'''  *   (5) The pixel access routines allow a trivial implementation.
'''  * However, for d  8, it is more efficient to right-justify
'''  * each line to a 32-bit boundary and then extract bytes and
'''  * do pixel reversing.   In those cases, as in the 180 degree
'''  * rotation, we right-shift the data (if necessary) to
'''  * right-justify on the 32 bit boundary, and then read the
'''  * bytes off each raster line in reverse order, reversing
'''  * the pixels in each byte using a table.  These functions
'''  * for 1, 2 and 4 bpp were tested against the "trivial"
'''  * version (shown here for 4 bpp):
'''  *  for (i = 0; i  h; i++) {
'''  *   line = data + i * wpl;
'''  *   memcpy(buffer, line, bpl);
'''  *  for (j = 0; j  w; j++) {
'''  *    val = GET_DATA_QBIT(buffer, w - 1 - j);
'''  *   SET_DATA_QBIT(line, j, val);
'''  *   }
'''  *  }
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs all depths</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFlipLR")> _
Friend Shared Function pixFlipLR(pixd as IntPTR, pixs as IntPTR) as IntPTR
End Function

' SRC\rotateorth.c (601, 1)
' pixFlipTB()
' pixFlipTB(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does a top-bottom flip of the image, which is
'''  * equivalent to a rotation out of the plane about a
'''  * horizontal line through the image center.
'''  *   (2) There are 3 cases for input:
'''  * (a) pixd == null (creates a new pixd)
'''  * (b) pixd == pixs (in-place operation)
'''  * (c) pixd != pixs (existing pixd)
'''  *   (3) For clarity, use these three patterns, respectively:
'''  * (a) pixd = pixFlipTB(NULL, pixs);
'''  * (b) pixFlipTB(pixs, pixs);
'''  * (c) pixFlipTB(pixd, pixs);
'''  *   (4) If an existing pixd is not the same size as pixs, the
'''  * image data will be reallocated.
'''  *   (5) This is simple and fast.  We use the memcpy function
'''  * to do all the work on aligned data, regardless of pixel
'''  * depth.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs all depths</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFlipTB")> _
Friend Shared Function pixFlipTB(pixd as IntPTR, pixs as IntPTR) as IntPTR
End Function

#End Region
#Region "SRC\rotateshear.c"
' SRC\rotateshear.c (196, 1)
' pixRotateShear()
' pixRotateShear(PIX *, l_int32, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This rotates an image about the given point, using
'''  * either 2 or 3 shears.
'''  *   (2) A positive angle gives a clockwise rotation.
'''  *   (3) This brings in 'incolor' pixels from outside the image.
'''  *   (4) For rotation angles larger than about 0.35 radians, we issue
'''  * a warning because you should probably be using another method
'''  * (either sampling or area mapping)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error.</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="xcen"> \param[in]    xcen x value for which there is no horizontal shear</param>
''' <param name="ycen"> \param[in]    ycen y value for which there is no vertical shear</param>
''' <param name="angle"> \param[in]    angle radians</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateShear")> _
Friend Shared Function pixRotateShear(pixs as IntPTR, xcen as Integer, ycen as Integer, angle as single, incolor as Integer) as IntPTR
End Function

' SRC\rotateshear.c (248, 1)
' pixRotate2Shear()
' pixRotate2Shear(PIX *, l_int32, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This rotates the image about the given point, using the 2-shear
'''  * method.  It should only be used for angles smaller than
'''  * MAX_2_SHEAR_ANGLE.  For larger angles, a warning is issued.
'''  *   (2) A positive angle gives a clockwise rotation.
'''  *   (3) 2-shear rotation by a specified angle is equivalent
'''  * to the sequential transformations
'''  * x' = x + tan(angle) * (y - ycen)  for x-shear
'''  * y' = y + tan(angle) * (x - xcen)  for y-shear
'''  *   (4) Computation of tan(angle) is performed within the shear operation.
'''  *   (5) This brings in 'incolor' pixels from outside the image.
'''  *   (6) If the image has an alpha layer, it is rotated separately by
'''  * two shears.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error.</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="xcen"> \param[in]    xcen, ycen center of rotation</param>
''' <param name="ycen"> \param[in]    angle radians</param>
''' <param name="angle"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotate2Shear")> _
Friend Shared Function pixRotate2Shear(pixs as IntPTR, xcen as Integer, ycen as Integer, angle as single, incolor as Integer) as IntPTR
End Function

' SRC\rotateshear.c (319, 1)
' pixRotate3Shear()
' pixRotate3Shear(PIX *, l_int32, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This rotates the image about the given point, using the 3-shear
'''  * method.  It should only be used for angles smaller than
'''  * LIMIT_SHEAR_ANGLE.  For larger angles, a warning is issued.
'''  *   (2) A positive angle gives a clockwise rotation.
'''  *   (3) 3-shear rotation by a specified angle is equivalent
'''  * to the sequential transformations
'''  *   y' = y + tan(angle/2) * (x - xcen)  for first y-shear
'''  *   x' = x + sin(angle) * (y - ycen) for x-shear
'''  *   y' = y + tan(angle/2) * (x - xcen)  for second y-shear
'''  *   (4) Computation of tan(angle) is performed in the shear operations.
'''  *   (5) This brings in 'incolor' pixels from outside the image.
'''  *   (6) If the image has an alpha layer, it is rotated separately by
'''  * two shears.
'''  *   (7) The algorithm was published by Alan Paeth: "A Fast Algorithm
'''  * for General Raster Rotation," Graphics Interface '86,
'''  * pp. 77-81, May 1986.  A description of the method, along with
'''  * an implementation, can be found in Graphics Gems, p. 179,
'''  * edited by Andrew Glassner, published by Academic Press, 1990.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error.</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="xcen"> \param[in]    xcen, ycen center of rotation</param>
''' <param name="ycen"> \param[in]    angle radians</param>
''' <param name="angle"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotate3Shear")> _
Friend Shared Function pixRotate3Shear(pixs as IntPTR, xcen as Integer, ycen as Integer, angle as single, incolor as Integer) as IntPTR
End Function

' SRC\rotateshear.c (395, 1)
' pixRotateShearIP()
' pixRotateShearIP(PIX *, l_int32, l_int32, l_float32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does an in-place rotation of the image about the
'''  * specified point, using the 3-shear method.  It should only
'''  * be used for angles smaller than LIMIT_SHEAR_ANGLE.
'''  * For larger angles, a warning is issued.
'''  *   (2) A positive angle gives a clockwise rotation.
'''  *   (3) 3-shear rotation by a specified angle is equivalent
'''  * to the sequential transformations
'''  *   y' = y + tan(angle/2) * (x - xcen)   for first y-shear
'''  *   x' = x + sin(angle) * (y - ycen)  for x-shear
'''  *   y' = y + tan(angle/2) * (x - xcen)   for second y-shear
'''  *   (4) Computation of tan(angle) is performed in the shear operations.
'''  *   (5) This brings in 'incolor' pixels from outside the image.
'''  *   (6) The pix cannot be colormapped, because the in-place operation
'''  * only blits in 0 or 1 bits, not an arbitrary colormap index.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth; not colormapped</param>
''' <param name="xcen"> \param[in]    xcen, ycen center of rotation</param>
''' <param name="ycen"> \param[in]    angle radians</param>
''' <param name="angle"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateShearIP")> _
Friend Shared Function pixRotateShearIP(pixs as IntPTR, xcen as Integer, ycen as Integer, angle as single, incolor as Integer) as Integer
End Function

' SRC\rotateshear.c (439, 1)
' pixRotateShearCenter()
' pixRotateShearCenter(PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="angle"> \param[in]    angle radians</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateShearCenter")> _
Friend Shared Function pixRotateShearCenter(pixs as IntPTR, angle as single, incolor as Integer) as IntPTR
End Function

' SRC\rotateshear.c (462, 1)
' pixRotateShearCenterIP()
' pixRotateShearCenterIP(PIX *, l_float32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="angle"> \param[in]    angle radians</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRotateShearCenterIP")> _
Friend Shared Function pixRotateShearCenterIP(pixs as IntPTR, angle as single, incolor as Integer) as Integer
End Function

#End Region
#Region "SRC\runlength.c"
' SRC\runlength.c (63, 13)
' pixFindMinRunsOrthogonal()
' pixFindMinRunsOrthogonal(PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This computes, for each fg pixel in pixs, the minimum of
'''  * the runlengths going through that pixel in two orthogonal
'''  * directions: at %angle and at (90 + %angle).
'''  *   (2) We use rotation by shear because the forward and backward
'''  * rotations by the same angle are exact inverse operations.
'''  * As a result, the nonzero pixels in pixd correspond exactly
'''  * to the fg pixels in pixs.  This is not the case with
'''  * sampled rotation, due to spatial quantization.  Nevertheless,
'''  * the result suffers from lack of exact correspondence
'''  * between original and rotated pixels, also due to spatial
'''  * quantization, causing some boundary pixels to be
'''  * shifted from bg to fg or v.v.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   pixd 8 or 16 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]     pixs 1 bpp</param>
''' <param name="angle"> \param[in]     angle in radians</param>
''' <param name="depth"> \param[in]     depth of pixd: 8 or 16 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindMinRunsOrthogonal")> _
Friend Shared Function pixFindMinRunsOrthogonal(pixs as IntPTR, angle as single, depth as Integer) as IntPTR
End Function

' SRC\runlength.c (99, 1)
' pixStrokeWidthTransform()
' pixStrokeWidthTransform(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The dest Pix is 8 or 16 bpp, with the pixel values
'''  * equal to the stroke width in which it is a member.
'''  * The values are clipped to the max pixel value if necessary.
'''  *   (2) The color determines if we're labelling white or black strokes.
'''  *   (3) A pixel that is not a member of the chosen color gets
'''  * value 0; it belongs to a width of length 0 of the
'''  * chosen color.
'''  *   (4) This chooses, for each dest pixel, the minimum of sets
'''  * of runlengths through each pixel.  Here are the sets:
'''  *   nangles increment set
'''  *   ------- --------- --------------------------------
'''  *   2 90 {0, 90}
'''  *   4 45 {0, 45, 90, 135}
'''  *   6 30 {0, 30, 60, 90, 120, 150}
'''  *   8 22.5  {0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5}
'''  *   (5) Runtime scales linearly with (nangles - 2).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   pixd 8 or 16 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]     pixs 1 bpp</param>
''' <param name="color"> \param[in]     color 0 for white runs, 1 for black runs</param>
''' <param name="depth"> \param[in]     depth of pixd: 8 or 16 bpp</param>
''' <param name="nangles"> \param[in]     nangles 2, 4, 6 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixStrokeWidthTransform")> _
Friend Shared Function pixStrokeWidthTransform(pixs as IntPTR, color as Integer, depth as Integer, nangles as Integer) as IntPTR
End Function

' SRC\runlength.c (262, 1)
' pixRunlengthTransform()
' pixRunlengthTransform(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The dest Pix is 8 or 16 bpp, with the pixel values
'''  * equal to the runlength in which it is a member.
'''  * The length is clipped to the max pixel value if necessary.
'''  *   (2) The color determines if we're labelling white or black runs.
'''  *   (3) A pixel that is not a member of the chosen color gets
'''  * value 0; it belongs to a run of length 0 of the
'''  * chosen color.
'''  *   (4) To convert for maximum dynamic range, either linear or
'''  * log, use pixMaxDynamicRange().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   pixd 8 or 16 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]     pixs 1 bpp</param>
''' <param name="color"> \param[in]     color 0 for white runs, 1 for black runs</param>
''' <param name="direction"> \param[in]     direction L_HORIZONTAL_RUNS, L_VERTICAL_RUNS</param>
''' <param name="depth"> \param[in]     depth 8 or 16 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRunlengthTransform")> _
Friend Shared Function pixRunlengthTransform(pixs as IntPTR, color as Integer, direction as Integer, depth as Integer) as IntPTR
End Function

' SRC\runlength.c (372, 1)
' pixFindHorizontalRuns()
' pixFindHorizontalRuns(PIX *, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds foreground horizontal runs on a single scanline.
'''  *   (2) To find background runs, use pixInvert() before applying
'''  * this function.
'''  *   (3) The xstart and xend arrays are input.  They should be
'''  * of size w/2 + 1 to insure that they can hold
'''  * the maximum number of runs in the raster line.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix 1 bpp</param>
''' <param name="y"> \param[in]    y line to traverse</param>
''' <param name="xstart"> \param[in]    xstart returns array of start positions for fg runs</param>
''' <param name="xend"> \param[in]    xend returns array of end positions for fg runs</param>
''' <param name="pn"> \param[out]   pn  the number of runs found</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindHorizontalRuns")> _
Friend Shared Function pixFindHorizontalRuns(pix as IntPTR, y as Integer, xstart as Integer, xend as Integer, pn as Integer) as Integer
End Function

' SRC\runlength.c (449, 1)
' pixFindVerticalRuns()
' pixFindVerticalRuns(PIX *, l_int32, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds foreground vertical runs on a single scanline.
'''  *   (2) To find background runs, use pixInvert() before applying
'''  * this function.
'''  *   (3) The ystart and yend arrays are input.  They should be
'''  * of size h/2 + 1 to insure that they can hold
'''  * the maximum number of runs in the raster line.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix 1 bpp</param>
''' <param name="x"> \param[in]    x line to traverse</param>
''' <param name="ystart"> \param[in]    ystart returns array of start positions for fg runs</param>
''' <param name="yend"> \param[in]    yend returns array of end positions for fg runs</param>
''' <param name="pn"> \param[out]   pn   the number of runs found</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindVerticalRuns")> _
Friend Shared Function pixFindVerticalRuns(pix as IntPTR, x as Integer, ystart as Integer, yend as Integer, pn as Integer) as Integer
End Function

' SRC\runlength.c (525, 1)
' pixFindMaxRuns()
' pixFindMaxRuns(PIX *, l_int32, NUMA **) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) This finds the longest foreground runs by row or column
'''  *   (2) To find background runs, use pixInvert() before applying
'''  * this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na of lengths of runs, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix 1 bpp</param>
''' <param name="direction"> \param[in]    direction L_HORIZONTAL_RUNS or L_VERTICAL_RUNS</param>
''' <param name="pnastart"> \param[out]   pnastart [optional] start locations of longest runs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindMaxRuns")> _
Friend Shared Function pixFindMaxRuns(pix as IntPTR, direction as Integer, pnastart as Object) as IntPTR
End Function

' SRC\runlength.c (578, 1)
' pixFindMaxHorizontalRunOnLine()
' pixFindMaxHorizontalRunOnLine(PIX *, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds the longest foreground horizontal run on a scanline.
'''  *   (2) To find background runs, use pixInvert() before applying
'''  * this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix 1 bpp</param>
''' <param name="y"> \param[in]    y line to traverse</param>
''' <param name="pxstart"> \param[out]   pxstart [optional] start position</param>
''' <param name="psize"> \param[out]   psize  the size of the run</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindMaxHorizontalRunOnLine")> _
Friend Shared Function pixFindMaxHorizontalRunOnLine(pix as IntPTR, y as Integer, pxstart as Integer, psize as Integer) as Integer
End Function

' SRC\runlength.c (652, 1)
' pixFindMaxVerticalRunOnLine()
' pixFindMaxVerticalRunOnLine(PIX *, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds the longest foreground vertical run on a scanline.
'''  *   (2) To find background runs, use pixInvert() before applying
'''  * this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pix"> \param[in]    pix 1 bpp</param>
''' <param name="x"> \param[in]    x column to traverse</param>
''' <param name="pystart"> \param[out]   pystart [optional] start position</param>
''' <param name="psize"> \param[out]   psize  the size of the run</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindMaxVerticalRunOnLine")> _
Friend Shared Function pixFindMaxVerticalRunOnLine(pix as IntPTR, x as Integer, pystart as Integer, psize as Integer) as Integer
End Function

' SRC\runlength.c (733, 1)
' runlengthMembershipOnLine()
' runlengthMembershipOnLine(l_int32 *, l_int32, l_int32, l_int32 *, l_int32 *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Converts a set of runlengths into a buffer of
'''  * runlength membership values.
'''  *   (2) Initialization of the array gives pixels that are
'''  * not within a run the value 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return   0 if OK; 1 on error</returns>
''' <param name="buffer"> \param[in]     buffer into which full line of data is placed</param>
''' <param name="size"> \param[in]     size full size of line; w or h</param>
''' <param name="depth"> \param[in]     depth 8 or 16 bpp</param>
''' <param name="start"> \param[in]     start array of start positions for fg runs</param>
''' <param name="_end_"> \param[in]     end array of end positions for fg runs</param>
''' <param name="n"> \param[in]     n   the number of runs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="runlengthMembershipOnLine")> _
Friend Shared Function runlengthMembershipOnLine(buffer as Integer, size as Integer, depth as Integer, start as Integer, _end_ as Integer, n as Integer) as Integer
End Function

' SRC\runlength.c (791, 1)
' makeMSBitLocTab()
' makeMSBitLocTab(l_int32) as l_int32 *
''' <summary>
''' * Notes:
'''  *   (1) If bitval == 1, it finds the leftmost ON pixel in a byte;
'''  * otherwise if bitval == 0, it finds the leftmost OFF pixel.
'''  *   (2) If there are no pixels of the indicated color in the byte,
'''  * this returns 8.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  table giving, for an input byte, the MS bit location,</returns>
''' <param name="bitval"> \param[in]    bitval either 0 or 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeMSBitLocTab")> _
Friend Shared Function makeMSBitLocTab(bitval as Integer) as String
End Function

#End Region
#Region "SRC\sarray1.c"
' SRC\sarray1.c (149, 16)
' sarrayExtendArray()
' sarrayExtendArray(SARRAY *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa"> \param[in]    sa string array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayExtendArray")> _
Friend Shared Function sarrayExtendArray(sa as IntPTR) as Integer
End Function

' SRC\sarray1.c (163, 1)
' sarrayCreate()
' sarrayCreate(l_int32) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sarray, or NULL on error</returns>
''' <param name="n"> \param[in]    n size of string ptr array to be alloc'd;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayCreate")> _
Friend Shared Function sarrayCreate(n as Integer) as IntPTR
End Function

' SRC\sarray1.c (193, 1)
' sarrayCreateInitialized()
' sarrayCreateInitialized(l_int32, const char *) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sarray, or NULL on error</returns>
''' <param name="n"> \param[in]    n size of string ptr array to be alloc'd</param>
''' <param name="initstr"> \param[in]    initstr string to be initialized on the full array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayCreateInitialized")> _
Friend Shared Function sarrayCreateInitialized(n as Integer, initstr as String) as IntPTR
End Function

' SRC\sarray1.c (226, 1)
' sarrayCreateWordsFromString()
' sarrayCreateWordsFromString(const char *) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) This finds the number of word substrings, creates an sarray
'''  * of this size, and puts copies of each substring into the sarray.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sarray, or NULL on error</returns>
''' <param name="_string_"> \param[in]    string</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayCreateWordsFromString")> _
Friend Shared Function sarrayCreateWordsFromString(_string_ as String) as IntPTR
End Function

' SRC\sarray1.c (276, 1)
' sarrayCreateLinesFromString()
' sarrayCreateLinesFromString(const char *, l_int32) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) This finds the number of line substrings, each of which
'''  * ends with a newline, and puts a copy of each substring
'''  * in a new sarray.
'''  *   (2) The newline characters are removed from each substring.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sarray, or NULL on error</returns>
''' <param name="_string_"> \param[in]    string</param>
''' <param name="blankflag"> \param[in]    blankflag  0 to exclude blank lines; 1 to include</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayCreateLinesFromString")> _
Friend Shared Function sarrayCreateLinesFromString(_string_ as String, blankflag as Integer) as IntPTR
End Function

' SRC\sarray1.c (355, 1)
' sarrayDestroy()
' sarrayDestroy(SARRAY **) as void
''' <summary>
''' * Notes:
'''  *   (1) Decrements the ref count and, if 0, destroys the sarray.
'''  *   (2) Always nulls the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="psa"> \param[in,out]   psa to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayDestroy")> _
Friend Shared Function sarrayDestroy(psa as Object) as Boolean ' Org. Void
End Function

' SRC\sarray1.c (393, 1)
' sarrayCopy()
' sarrayCopy(SARRAY *) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  copy of sarray, or NULL on error</returns>
''' <param name="sa"> \param[in]    sa string array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayCopy")> _
Friend Shared Function sarrayCopy(sa as IntPTR) as IntPTR
End Function

' SRC\sarray1.c (420, 1)
' sarrayClone()
' sarrayClone(SARRAY *) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to same sarray, or NULL on error</returns>
''' <param name="sa"> \param[in]    sa string array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayClone")> _
Friend Shared Function sarrayClone(sa as IntPTR) as IntPTR
End Function

' SRC\sarray1.c (446, 1)
' sarrayAddString()
' sarrayAddString(SARRAY *, const char *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See usage comments at the top of this file.  L_INSERT is
'''  * equivalent to L_NOCOPY.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa"> \param[in]    sa string array</param>
''' <param name="_string_"> \param[in]    string  string to be added</param>
''' <param name="copyflag"> \param[in]    copyflag  L_INSERT, L_NOCOPY or L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayAddString")> _
Friend Shared Function sarrayAddString(sa as IntPTR, _string_ as String, copyflag as Integer) as Integer
End Function

' SRC\sarray1.c (506, 1)
' sarrayRemoveString()
' sarrayRemoveString(SARRAY *, l_int32) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  removed string, or NULL on error</returns>
''' <param name="sa"> \param[in]    sa string array</param>
''' <param name="index"> \param[in]    index of string within sarray</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayRemoveString")> _
Friend Shared Function sarrayRemoveString(sa as IntPTR, index as Integer) as String
End Function

' SRC\sarray1.c (557, 1)
' sarrayReplaceString()
' sarrayReplaceString(SARRAY *, l_int32, char *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This destroys an existing string and replaces it with
'''  * the new string or a copy of it.
'''  *   (2) By design, an sarray is always compacted, so there are
'''  * never any holes (null ptrs) in the ptr array up to the
'''  * current count.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa"> \param[in]    sa string array</param>
''' <param name="index"> \param[in]    index of string within sarray to be replaced</param>
''' <param name="newstr"> \param[in]    newstr string to replace existing one</param>
''' <param name="copyflag"> \param[in]    copyflag  L_INSERT, L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayReplaceString")> _
Friend Shared Function sarrayReplaceString(sa as IntPTR, index as Integer, newstr as Object, copyflag as Integer) as Integer
End Function

' SRC\sarray1.c (594, 1)
' sarrayClear()
' sarrayClear(SARRAY *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="sa"> \param[in]    sa string array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayClear")> _
Friend Shared Function sarrayClear(sa as IntPTR) as Integer
End Function

' SRC\sarray1.c (621, 1)
' sarrayGetCount()
' sarrayGetCount(SARRAY *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 if no strings or on error</returns>
''' <param name="sa"> \param[in]    sa string array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayGetCount")> _
Friend Shared Function sarrayGetCount(sa as IntPTR) as Integer
End Function

' SRC\sarray1.c (646, 1)
' sarrayGetArray()
' sarrayGetArray(SARRAY *, l_int32 *, l_int32 *) as char **
''' <summary>
''' * Notes:
'''  *   (1) Caution: the returned array is not a copy, so caller
'''  * must not destroy it!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to string array, or NULL on error</returns>
''' <param name="sa"> \param[in]    sa string array</param>
''' <param name="pnalloc"> \param[out]   pnalloc  [optional] number allocated string ptrs</param>
''' <param name="pn"> \param[out]   pn  [optional] number allocated strings</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayGetArray")> _
Friend Shared Function sarrayGetArray(sa as IntPTR, pnalloc as Integer, pn as Integer) as String
End Function

' SRC\sarray1.c (681, 1)
' sarrayGetString()
' sarrayGetString(SARRAY *, l_int32, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) See usage comments at the top of this file.
'''  *   (2) To get a pointer to the string itself, use L_NOCOPY.
'''  * To get a copy of the string, use L_COPY.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  string, or NULL on error</returns>
''' <param name="sa"> \param[in]    sa string array</param>
''' <param name="index"> \param[in]    index   to the index-th string</param>
''' <param name="copyflag"> \param[in]    copyflag  L_NOCOPY or L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayGetString")> _
Friend Shared Function sarrayGetString(sa as IntPTR, index as Integer, copyflag as Integer) as String
End Function

' SRC\sarray1.c (708, 1)
' sarrayGetRefCount()
' sarrayGetRefcount(SARRAY *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  refcount, or UNDEF on error</returns>
''' <param name="sa"> \param[in]    sa string array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayGetRefcount")> _
Friend Shared Function sarrayGetRefcount(sa as IntPTR) as Integer
End Function

' SRC\sarray1.c (726, 1)
' sarrayChangeRefCount()
' sarrayChangeRefcount(SARRAY *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa"> \param[in]    sa string array</param>
''' <param name="delta"> \param[in]    delta change to be applied</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayChangeRefcount")> _
Friend Shared Function sarrayChangeRefcount(sa as IntPTR, delta as Integer) as Integer
End Function

' SRC\sarray1.c (763, 1)
' sarrayToString()
' sarrayToString(SARRAY *, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) Concatenates all the strings in the sarray, preserving
'''  * all white space.
'''  *   (2) If addnlflag != 0, adds either a '\n' or a ' ' after
'''  * each substring.
'''  *   (3) This function was NOT implemented as:
'''  *   for (i = 0; i  n; i++)
'''  *   strcat(dest, sarrayGetString(sa, i, L_NOCOPY));
'''  * Do you see why?
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dest string, or NULL on error</returns>
''' <param name="sa"> \param[in]    sa string array</param>
''' <param name="addnlflag"> \param[in]    addnlflag flag: 0 adds nothing to each substring</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayToString")> _
Friend Shared Function sarrayToString(sa as IntPTR, addnlflag as Integer) as String
End Function

' SRC\sarray1.c (798, 1)
' sarrayToStringRange()
' sarrayToStringRange(SARRAY *, l_int32, l_int32, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) Concatenates the specified strings inthe sarray, preserving
'''  * all white space.
'''  *   (2) If addnlflag != 0, adds either a '\n' or a ' ' after
'''  * each substring.
'''  *   (3) If the sarray is empty, this returns a string with just
'''  * the character corresponding to %addnlflag.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dest string, or NULL on error</returns>
''' <param name="sa"> \param[in]   sa string array</param>
''' <param name="first"> \param[in]   first  index of first string to use; starts with 0</param>
''' <param name="nstrings"> \param[in]   nstrings number of strings to append into the result; use</param>
''' <param name="addnlflag"> \param[in]   addnlflag flag: 0 adds nothing to each substring</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayToStringRange")> _
Friend Shared Function sarrayToStringRange(sa as IntPTR, first as Integer, nstrings as Integer, addnlflag as Integer) as String
End Function

' SRC\sarray1.c (880, 1)
' sarrayJoin()
' sarrayJoin(SARRAY *, SARRAY *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Copies of the strings in sarray2 are added to sarray1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa1"> \param[in]    sa1  to be added to</param>
''' <param name="sa2"> \param[in]    sa2  append to sa1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayJoin")> _
Friend Shared Function sarrayJoin(sa1 as IntPTR, sa2 as IntPTR) as Integer
End Function

' SRC\sarray1.c (920, 1)
' sarrayAppendRange()
' sarrayAppendRange(SARRAY *, SARRAY *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Copies of the strings in sarray2 are added to sarray1.
'''  *   (2) The [start ... end] range is truncated if necessary.
'''  *   (3) Use end == -1 to append to the end of sa2.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa1"> \param[in]    sa1  to be added to</param>
''' <param name="sa2"> \param[in]    sa2  append specified range of strings in sa2 to sa1</param>
''' <param name="start"> \param[in]    start index of first string of sa2 to append</param>
''' <param name="_end_"> \param[in]    end index of last string of sa2 to append; -1 to end of array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayAppendRange")> _
Friend Shared Function sarrayAppendRange(sa1 as IntPTR, sa2 as IntPTR, start as Integer, _end_ as Integer) as Integer
End Function

' SRC\sarray1.c (972, 1)
' sarrayPadToSameSize()
' sarrayPadToSameSize(SARRAY *, SARRAY *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If two sarrays have different size, this adds enough
'''  * instances of %padstring to the smaller so that they are
'''  * the same size.  It is useful when two or more sarrays
'''  * are being sequenced in parallel, and it is necessary to
'''  * find a valid string at each index.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa1"> \param[in]    sa1, sa2</param>
''' <param name="sa2"> \param[in]    padstring</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayPadToSameSize")> _
Friend Shared Function sarrayPadToSameSize(sa1 as IntPTR, sa2 as IntPTR, padstring as String) as Integer
End Function

' SRC\sarray1.c (1029, 1)
' sarrayConvertWordsToLines()
' sarrayConvertWordsToLines(SARRAY *, l_int32) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  saout sa of formatted lines, or NULL on error</returns>
''' <param name="sa"> \param[in]    sa  sa of individual words</param>
''' <param name="linesize"> \param[in]    linesize  max num of chars in each line</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayConvertWordsToLines")> _
Friend Shared Function sarrayConvertWordsToLines(sa as IntPTR, linesize as Integer) as IntPTR
End Function

' SRC\sarray1.c (1098, 1)
' 
' sarraySplitString(SARRAY *, const char *, const char *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarraySplitString")> _
Friend Shared Function sarraySplitString(sa as IntPTR, str as String, separators as String) as Integer
End Function

' SRC\sarray1.c (1145, 1)
' sarraySelectBySubstring()
' sarraySelectBySubstring(SARRAY *, const char *) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) This selects all strings in sain that have substr as a substring.
'''  * Note that we can't use strncmp() because we're looking for
'''  * a match to the substring anywhere within each filename.
'''  *   (2) If substr == NULL, returns a copy of the sarray.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  saout output sarray, filtered with substring or NULL on error</returns>
''' <param name="sain"> \param[in]    sain input sarray</param>
''' <param name="substr"> \param[in]    substr [optional] substring for matching; can be NULL</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarraySelectBySubstring")> _
Friend Shared Function sarraySelectBySubstring(sain as IntPTR, substr as String) as IntPTR
End Function

' SRC\sarray1.c (1191, 1)
' sarraySelectByRange()
' sarraySelectByRange(SARRAY *, l_int32, l_int32) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) This makes %saout consisting of copies of all strings in %sain
'''  * in the index set [first ... last].  Use %last == 0 to get all
'''  * strings from %first to the last string in the sarray.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  saout output sarray, or NULL on error</returns>
''' <param name="sain"> \param[in]    sain input sarray</param>
''' <param name="first"> \param[in]    first index of first string to be selected</param>
''' <param name="last"> \param[in]    last index of last string to be selected; use 0 to go to the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarraySelectByRange")> _
Friend Shared Function sarraySelectByRange(sain as IntPTR, first as Integer, last as Integer) as IntPTR
End Function

' SRC\sarray1.c (1260, 1)
' sarrayParseRange()
' sarrayParseRange(SARRAY *, l_int32, l_int32 *, l_int32 *, l_int32 *, const char *, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This finds the range of the next set of strings in SA,
'''  * beginning the search at 'start', that does NOT have
'''  * the substring 'substr' either at the indicated location
'''  * in the string or anywhere in the string.  The input
'''  * variable 'loc' is the specified offset within the string;
'''  * use -1 to indicate 'anywhere in the string'.
'''  *   (2) Always check the return value to verify that a valid range
'''  * was found.
'''  *   (3) If a valid range is not found, the values of actstart,
'''  * end and newstart are all set to the size of sa.
'''  *   (4) If this is the last valid range, newstart returns the value n.
'''  * In use, this should be tested before calling the function.
'''  *   (5) Usage example.  To find all the valid ranges in a file
'''  * where the invalid lines begin with two dashes, copy each
'''  * line in the file to a string in an sarray, and do:
'''  * start = 0;
'''  * while (!sarrayParseRange(sa, start, &actstart, &end, &start,
'''  *  "--", 0))
'''  *  fprintf(stderr, "start = %d, end = %d\n", actstart, end);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if valid range found; 1 otherwise</returns>
''' <param name="sa"> \param[in]    sa input sarray</param>
''' <param name="start"> \param[in]    start index to start range search</param>
''' <param name="pactualstart"> \param[out]  pactualstart index of actual start; may be > 'start'</param>
''' <param name="pend"> \param[out]  pend index of end</param>
''' <param name="pnewstart"> \param[out]  pnewstart index of start of next range</param>
''' <param name="substr"> \param[in]    substr substring for matching at beginning of string</param>
''' <param name="loc"> \param[in]    loc byte offset within the string for the pattern; use</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayParseRange")> _
Friend Shared Function sarrayParseRange(sa as IntPTR, start as Integer, pactualstart as Integer, pend as Integer, pnewstart as Integer, substr as String, loc as Integer) as Integer
End Function

' SRC\sarray1.c (1345, 1)
' sarrayRead()
' sarrayRead(const char *) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sarray, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayRead")> _
Friend Shared Function sarrayRead(filename as String) as IntPTR
End Function

' SRC\sarray1.c (1382, 1)
' sarrayReadStream()
' sarrayReadStream(FILE *) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) We store the size of each string along with the string.
'''  * The limit on the number of strings is 2^24.
'''  * The limit on the size of any string is 2^30 bytes.
'''  *   (2) This allows a string to have embedded newlines.  By reading
'''  * the entire string, as determined by its size, we are
'''  * not affected by any number of embedded newlines.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sarray, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayReadStream")> _
Friend Shared Function sarrayReadStream(fp as Object) as IntPTR
End Function

' SRC\sarray1.c (1449, 1)
' sarrayReadMem()
' sarrayReadMem(const l_uint8 *, size_t) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sarray, or NULL on error</returns>
''' <param name="data"> \param[in]    data  serialization in ascii</param>
''' <param name="size"> \param[in]    size  of data; can use strlen to get it</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayReadMem")> _
Friend Shared Function sarrayReadMem(data as Byte, size as ULong) as IntPTR
End Function

' SRC\sarray1.c (1477, 1)
' sarrayWrite()
' sarrayWrite(const char *, SARRAY *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="sa"> \param[in]    sa string array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayWrite")> _
Friend Shared Function sarrayWrite(filename as String, sa as IntPTR) as Integer
End Function

' SRC\sarray1.c (1514, 1)
' sarrayWriteStream()
' sarrayWriteStream(FILE *, SARRAY *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This appends a '\n' to each string, which is stripped
'''  * off by sarrayReadStream().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="sa"> \param[in]    sa string array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayWriteStream")> _
Friend Shared Function sarrayWriteStream(fp as Object, sa as IntPTR) as Integer
End Function

' SRC\sarray1.c (1553, 1)
' sarrayWriteMem()
' sarrayWriteMem(l_uint8 **, size_t *, SARRAY *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Serializes a sarray in memory and puts the result in a buffer.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of serialized sarray; ascii</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="sa"> \param[in]    sa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayWriteMem")> _
Friend Shared Function sarrayWriteMem(pdata as Object, psize as ULong, sa as IntPTR) as Integer
End Function

' SRC\sarray1.c (1601, 1)
' sarrayAppend()
' sarrayAppend(const char *, SARRAY *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="sa"> \param[in]    sa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayAppend")> _
Friend Shared Function sarrayAppend(filename as String, sa as IntPTR) as Integer
End Function

' SRC\sarray1.c (1669, 1)
' getNumberedPathnamesInDirectory()
' getNumberedPathnamesInDirectory(const char *, const char *, l_int32, l_int32, l_int32) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) Returns the full pathnames of the numbered filenames in
'''  * the directory.  The number in the filename is the index
'''  * into the sarray.  For indices for which there are no filenames,
'''  * an empty string ("") is placed into the sarray.
'''  * This makes reading numbered files very simple.  For example,
'''  * the image whose filename includes number N can be retrieved using
'''  *   pixReadIndexed(sa, N);
'''  *   (2) If %substr is not NULL, only filenames that contain
'''  * the substring can be included.  If %substr is NULL,
'''  * all matching filenames are used.
'''  *   (3) If no numbered files are found, it returns an empty sarray,
'''  * with no initialized strings.
'''  *   (4) It is assumed that the page number is contained within
'''  * the basename (the filename without directory or extension).
'''  * %numpre is the number of characters in the basename
'''  * preceding the actual page number; %numpost is the number
'''  * following the page number, up to either the end of the
'''  * basename or a ".", whichever comes first.
'''  *   (5) This is useful when all filenames contain numbers that are
'''  * not necessarily consecutive.  0-padding is not required.
'''  *   (6) To use a O(n) matching algorithm, the largest page number
'''  * is found and two internal arrays of this size are created.
'''  * This maximum is constrained not to exceed %maxsum,
'''  * to make sure that an unrealistically large number is not
'''  * accidentally used to determine the array sizes.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sarray of numbered pathnames, or NULL on error</returns>
''' <param name="dirname"> \param[in]    dirname directory name</param>
''' <param name="substr"> \param[in]    substr [optional] substring filter on filenames; can be NULL</param>
''' <param name="numpre"> \param[in]    numpre number of characters in name before number</param>
''' <param name="numpost"> \param[in]    numpost number of characters in name after the number,</param>
''' <param name="maxnum"> \param[in]    maxnum only consider page numbers up to this value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getNumberedPathnamesInDirectory")> _
Friend Shared Function getNumberedPathnamesInDirectory(dirname as String, substr as String, numpre as Integer, numpost as Integer, maxnum as Integer) as IntPTR
End Function

' SRC\sarray1.c (1717, 1)
' getSortedPathnamesInDirectory()
' getSortedPathnamesInDirectory(const char *, const char *, l_int32, l_int32) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) Use %substr to filter filenames in the directory.  If
'''  * %substr == NULL, this takes all files.
'''  *   (2) The files in the directory, after optional filtering by
'''  * the substring, are lexically sorted in increasing order.
'''  * Use %first and %nfiles to select a contiguous set of files.
'''  *   (3) The full pathnames are returned for the requested sequence.
'''  * If no files are found after filtering, returns an empty sarray.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sarray of sorted pathnames, or NULL on error</returns>
''' <param name="dirname"> \param[in]    dirname directory name</param>
''' <param name="substr"> \param[in]    substr [optional] substring filter on filenames; can be NULL</param>
''' <param name="first"> \param[in]    first 0-based</param>
''' <param name="nfiles"> \param[in]    nfiles use 0 for all to the end</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getSortedPathnamesInDirectory")> _
Friend Shared Function getSortedPathnamesInDirectory(dirname as String, substr as String, first as Integer, nfiles as Integer) as IntPTR
End Function

' SRC\sarray1.c (1777, 1)
' convertSortedToNumberedPathnames()
' convertSortedToNumberedPathnames(SARRAY *, l_int32, l_int32, l_int32) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) Typically, numpre = numpost = 0; e.g., when the filename
'''  * just has a number followed by an optional extension.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sarray of numbered pathnames, or NULL on error</returns>
''' <param name="sa"> \param[in]    sa sorted pathnames including zero-padded integers</param>
''' <param name="numpre"> \param[in]    numpre number of characters in name before number</param>
''' <param name="numpost"> \param[in]    numpost number of characters in name after the number,</param>
''' <param name="maxnum"> \param[in]    maxnum only consider page numbers up to this value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertSortedToNumberedPathnames")> _
Friend Shared Function convertSortedToNumberedPathnames(sa as IntPTR, numpre as Integer, numpost as Integer, maxnum as Integer) as IntPTR
End Function

' SRC\sarray1.c (1917, 1)
' 
' getFilenamesInDirectory(const char *) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getFilenamesInDirectory")> _
Friend Shared Function getFilenamesInDirectory(dirname as String) as IntPTR
End Function

#End Region
#Region "SRC\sarray2.c"
' SRC\sarray2.c (95, 1)
' sarraySort()
' sarraySort(SARRAY *, SARRAY *, l_int32) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) Set saout = sain for in-place; otherwise, set naout = NULL.
'''  *   (2) Shell sort, modified from K&R, 2nd edition, p.62.
'''  * Slow but simple O(n logn) sort.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  saout output sarray, sorted by ascii value, or NULL on error</returns>
''' <param name="saout"> \param[in]    saout output sarray; can be NULL or equal to sain</param>
''' <param name="sain"> \param[in]    sain input sarray</param>
''' <param name="sortorder"> \param[in]    sortorder L_SORT_INCREASING or L_SORT_DECREASING</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarraySort")> _
Friend Shared Function sarraySort(saout as IntPTR, sain as IntPTR, sortorder as Integer) as IntPTR
End Function

' SRC\sarray2.c (145, 1)
' sarraySortByIndex()
' sarraySortByIndex(SARRAY *, NUMA *) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  saout sorted, or NULL on error</returns>
''' <param name="sain"> \param[in]    sain</param>
''' <param name="naindex"> \param[in]    naindex na that maps from the new sarray to the input sarray</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarraySortByIndex")> _
Friend Shared Function sarraySortByIndex(sain as IntPTR, naindex as IntPTR) as IntPTR
End Function

' SRC\sarray2.c (185, 1)
' stringCompareLexical()
' stringCompareLexical(const char *, const char *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) If the lexical values are identical, return a 0, to
'''  * indicate that no swapping is required to sort the strings.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if str1 > str2 lexically; 0 otherwise</returns>
''' <param name="str1"> \param[in]    str1</param>
''' <param name="str2"> \param[in]    str2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringCompareLexical")> _
Friend Shared Function stringCompareLexical(str1 as String, str2 as String) as Integer
End Function

' SRC\sarray2.c (237, 1)
' sarrayUnionByAset()
' sarrayUnionByAset(SARRAY *, SARRAY *) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) Duplicates are removed from the concatenation of the two arrays.
'''  *   (2) The key for each string is a 64-bit hash.
'''  *   (2) Algorithm: Concatenate the two sarrays.  Then build a set,
'''  * using hashed strings as keys.  As the set is built, first do
'''  * a find; if not found, add the key to the set and add the string
'''  * to the output sarray.  This is O(nlogn).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sad with the union of the string set, or NULL on error</returns>
''' <param name="sa1"> \param[in]    sa1, sa2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayUnionByAset")> _
Friend Shared Function sarrayUnionByAset(sa1 as IntPTR, sa2 as IntPTR) as IntPTR
End Function

' SRC\sarray2.c (277, 1)
' sarrayRemoveDupsByAset()
' sarrayRemoveDupsByAset(SARRAY *) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) This is O(nlogn), considerably slower than
'''  * sarrayRemoveDupsByHash() for large string arrays.
'''  *   (2) The key for each string is a 64-bit hash.
'''  *   (3) Build a set, using hashed strings as keys.  As the set is
'''  * built, first do a find; if not found, add the key to the
'''  * set and add the string to the output sarray.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sad with duplicates removed, or NULL on error</returns>
''' <param name="sas"> \param[in]    sas</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayRemoveDupsByAset")> _
Friend Shared Function sarrayRemoveDupsByAset(sas as IntPTR) as IntPTR
End Function

' SRC\sarray2.c (328, 1)
' sarrayIntersectionByAset()
' sarrayIntersectionByAset(SARRAY *, SARRAY *) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) Algorithm: put the larger sarray into a set, using the string
'''  * hashes as the key values.  Then run through the smaller sarray,
'''  * building an output sarray and a second set from the strings
'''  * in the larger array: if a string is in the first set but
'''  * not in the second, add the string to the output sarray and hash
'''  * it into the second set.  The second set is required to make
'''  * sure only one instance of each string is put into the output sarray.
'''  * This is O(mlogn), {m,n} = sizes of {smaller,larger} input arrays.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sad with the intersection of the string set, or NULL on error</returns>
''' <param name="sa1"> \param[in]    sa1, sa2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayIntersectionByAset")> _
Friend Shared Function sarrayIntersectionByAset(sa1 as IntPTR, sa2 as IntPTR) as IntPTR
End Function

' SRC\sarray2.c (379, 1)
' l_asetCreateFromSarray()
' l_asetCreateFromSarray(SARRAY *) as L_ASET *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  set using a string hash into a uint64 as the key</returns>
''' <param name="sa"> \param[in]    sa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_asetCreateFromSarray")> _
Friend Shared Function l_asetCreateFromSarray(sa as IntPTR) as IntPTR
End Function

' SRC\sarray2.c (431, 1)
' sarrayRemoveDupsByHash()
' sarrayRemoveDupsByHash(SARRAY *, SARRAY **, L_DNAHASH **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Generates a sarray with unique values.
'''  *   (2) The dnahash is built up with sad to assure uniqueness.
'''  * It can be used to find if a string is in the set:
'''  *  sarrayFindValByHash(sad, dahash, str, &index)
'''  *   (3) The hash of the string location is simple and fast.  It scales
'''  * up with the number of buckets to insure a fairly random
'''  * bucket selection input strings.
'''  *   (4) This is faster than sarrayRemoveDupsByAset(), because the
'''  * bucket lookup is O(n), although there is a double-loop
'''  * lookup within the dna in each bucket.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sas"> \param[in]    sas</param>
''' <param name="psad"> \param[out]   psad unique set of strings; duplicates removed</param>
''' <param name="pdahash"> \param[out]   pdahash [optional] dnahash used for lookup</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayRemoveDupsByHash")> _
Friend Shared Function sarrayRemoveDupsByHash(sas as IntPTR, psad as Object, pdahash as Object) as Integer
End Function

' SRC\sarray2.c (488, 1)
' sarrayIntersectionByHash()
' sarrayIntersectionByHash(SARRAY *, SARRAY *) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) This is faster than sarrayIntersectionByAset(), because the
'''  * bucket lookup is O(n).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sad intersection of the strings, or NULL on error</returns>
''' <param name="sa1"> \param[in]    sa1, sa2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayIntersectionByHash")> _
Friend Shared Function sarrayIntersectionByHash(sa1 as IntPTR, sa2 as IntPTR) as IntPTR
End Function

' SRC\sarray2.c (563, 1)
' sarrayFindStringByHash()
' sarrayFindStringByHash(SARRAY *, L_DNAHASH *, const char *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Fast lookup in dnaHash associated with a sarray, to see if a
'''  * random string %str is already stored in the hash table.
'''  *   (2) We use a strong hash function to minimize the chance that
'''  * two different strings hash to the same key value.
'''  *   (3) We select the number of buckets to be about 5% of the size
'''  * of the input sarray, so that when fully populated, each
'''  * bucket (dna) will have about 20 entries, each being an index
'''  * into sa.  In lookup, after hashing to the key, and then
'''  * again to the bucket, we traverse the bucket (dna), using the
'''  * index into sa to check if %str has been found before.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa"> \param[in]    sa</param>
''' <param name="dahash"> \param[in]    dahash built from sa</param>
''' <param name="str"> \param[in]    str  arbitrary string</param>
''' <param name="pindex"> \param[out]   pindex index into %sa if %str is in %sa;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayFindStringByHash")> _
Friend Shared Function sarrayFindStringByHash(sa as IntPTR, dahash as IntPTR, str as String, pindex as Integer) as Integer
End Function

' SRC\sarray2.c (609, 1)
' l_dnaHashCreateFromSarray()
' l_dnaHashCreateFromSarray(SARRAY *) as L_DNAHASH *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dahash, or NULL on error</returns>
''' <param name="sa"> \param[in]    sa</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_dnaHashCreateFromSarray")> _
Friend Shared Function l_dnaHashCreateFromSarray(sa as IntPTR) as IntPTR
End Function

' SRC\sarray2.c (648, 1)
' sarrayGenerateIntegers()
' sarrayGenerateIntegers(l_int32) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sa  (of printed numbers, 1 - n, or NULL on error</returns>
''' <param name="n"> \param[in]   n</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayGenerateIntegers")> _
Friend Shared Function sarrayGenerateIntegers(n as Integer) as IntPTR
End Function

' SRC\sarray2.c (688, 1)
' sarrayLookupCSKV()
' sarrayLookupCSKV(SARRAY *, const char *, char **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The input %sa can have other strings that are not in
'''  * comma-separated key-value format.  These will be ignored.
'''  *   (2) This returns a copy of the first value string in %sa whose
'''  * key string matches the input %keystring.
'''  *   (3) White space is not ignored; all white space before the ','
'''  * is used for the keystring in matching.  This allows the
'''  * key and val strings to have white space (e.g., multiple words).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa"> \param[in]    sa (of strings, each being a comma-separated pair of strings,</param>
''' <param name="keystring"> \param[in]    keystring (an input string to match with each key in %sa</param>
''' <param name="pvalstring"> \param[out]   pvalstring (the returned value string corresponding to the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sarrayLookupCSKV")> _
Friend Shared Function sarrayLookupCSKV(sa as IntPTR, keystring as String, pvalstring as String) as Integer
End Function

#End Region
#Region "SRC\scale1.c"
' SRC\scale1.c (116, 13)
' scaleColorLILow()
' scaleColorLILow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleColorLILow")> _
Friend Shared Function scaleColorLILow(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, ws as Integer, hs as Integer, wpls as Integer) as Boolean ' Org. Void
End Function

' SRC\scale1.c (119, 13)
' scaleGrayLILow()
' scaleGrayLILow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleGrayLILow")> _
Friend Shared Function scaleGrayLILow(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, ws as Integer, hs as Integer, wpls as Integer) as Boolean ' Org. Void
End Function

' SRC\scale1.c (122, 13)
' scaleColor2xLILow()
' scaleColor2xLILow(l_uint32 *, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleColor2xLILow")> _
Friend Shared Function scaleColor2xLILow(datad as UInteger, wpld as Integer, datas as UInteger, ws as Integer, hs as Integer, wpls as Integer) as Boolean ' Org. Void
End Function

' SRC\scale1.c (124, 13)
' scaleColor2xLILineLow()
' scaleColor2xLILineLow(l_uint32 *, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="lined"> \param[in]    lined   ptr to top destline, to be made from current src line</param>
''' <param name="wpld"> \param[in]    wpld</param>
''' <param name="lines"> \param[in]    lines   ptr to current src line</param>
''' <param name="ws"> \param[in]    ws</param>
''' <param name="wpls"> \param[in]    wpls</param>
''' <param name="lastlineflag"> \param[in]    lastlineflag  1 if last src line; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleColor2xLILineLow")> _
Friend Shared Function scaleColor2xLILineLow(lined as UInteger, wpld as Integer, lines as UInteger, ws as Integer, wpls as Integer, lastlineflag as Integer) as Boolean ' Org. Void
End Function

' SRC\scale1.c (127, 13)
' scaleGray2xLILow()
' scaleGray2xLILow(l_uint32 *, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleGray2xLILow")> _
Friend Shared Function scaleGray2xLILow(datad as UInteger, wpld as Integer, datas as UInteger, ws as Integer, hs as Integer, wpls as Integer) as Boolean ' Org. Void
End Function

' SRC\scale1.c (129, 13)
' scaleGray2xLILineLow()
' scaleGray2xLILineLow(l_uint32 *, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="lined"> \param[in]    lined   ptr to top destline, to be made from current src line</param>
''' <param name="wpld"> \param[in]    wpld</param>
''' <param name="lines"> \param[in]    lines   ptr to current src line</param>
''' <param name="ws"> \param[in]    ws</param>
''' <param name="wpls"> \param[in]    wpls</param>
''' <param name="lastlineflag"> \param[in]    lastlineflag  1 if last src line; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleGray2xLILineLow")> _
Friend Shared Function scaleGray2xLILineLow(lined as UInteger, wpld as Integer, lines as UInteger, ws as Integer, wpls as Integer, lastlineflag as Integer) as Boolean ' Org. Void
End Function

' SRC\scale1.c (132, 13)
' scaleGray4xLILow()
' scaleGray4xLILow(l_uint32 *, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleGray4xLILow")> _
Friend Shared Function scaleGray4xLILow(datad as UInteger, wpld as Integer, datas as UInteger, ws as Integer, hs as Integer, wpls as Integer) as Boolean ' Org. Void
End Function

' SRC\scale1.c (134, 13)
' scaleGray4xLILineLow()
' scaleGray4xLILineLow(l_uint32 *, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="lined"> \param[in]    lined   ptr to top destline, to be made from current src line</param>
''' <param name="wpld"> \param[in]    wpld</param>
''' <param name="lines"> \param[in]    lines   ptr to current src line</param>
''' <param name="ws"> \param[in]    ws</param>
''' <param name="wpls"> \param[in]    wpls</param>
''' <param name="lastlineflag"> \param[in]    lastlineflag  1 if last src line; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleGray4xLILineLow")> _
Friend Shared Function scaleGray4xLILineLow(lined as UInteger, wpld as Integer, lines as UInteger, ws as Integer, wpls as Integer, lastlineflag as Integer) as Boolean ' Org. Void
End Function

' SRC\scale1.c (137, 16)
' scaleBySamplingLow()
' scaleBySamplingLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleBySamplingLow")> _
Friend Shared Function scaleBySamplingLow(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, ws as Integer, hs as Integer, d as Integer, wpls as Integer) as Integer
End Function

' SRC\scale1.c (140, 16)
' scaleSmoothLow()
' scaleSmoothLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32, l_int32, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleSmoothLow")> _
Friend Shared Function scaleSmoothLow(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, ws as Integer, hs as Integer, d as Integer, wpls as Integer, size as Integer) as Integer
End Function

' SRC\scale1.c (144, 13)
' scaleRGBToGray2Low()
' scaleRGBToGray2Low(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_float32, l_float32, l_float32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleRGBToGray2Low")> _
Friend Shared Function scaleRGBToGray2Low(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, wpls as Integer, rwt as single, gwt as single, bwt as single) as Boolean ' Org. Void
End Function

' SRC\scale1.c (147, 13)
' scaleColorAreaMapLow()
' scaleColorAreaMapLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleColorAreaMapLow")> _
Friend Shared Function scaleColorAreaMapLow(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, ws as Integer, hs as Integer, wpls as Integer) as Boolean ' Org. Void
End Function

' SRC\scale1.c (150, 13)
' scaleGrayAreaMapLow()
' scaleGrayAreaMapLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleGrayAreaMapLow")> _
Friend Shared Function scaleGrayAreaMapLow(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, ws as Integer, hs as Integer, wpls as Integer) as Boolean ' Org. Void
End Function

' SRC\scale1.c (153, 13)
' scaleAreaMapLow2()
' scaleAreaMapLow2(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleAreaMapLow2")> _
Friend Shared Function scaleAreaMapLow2(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, d as Integer, wpls as Integer) as Boolean ' Org. Void
End Function

' SRC\scale1.c (156, 16)
' 
' scaleBinaryLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleBinaryLow")> _
Friend Shared Function scaleBinaryLow(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, ws as Integer, hs as Integer, wpls as Integer) as Integer
End Function

' SRC\scale1.c (243, 1)
' pixScale()
' pixScale(PIX *, l_float32, l_float32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 16 and 32 bpp</param>
''' <param name="scalex"> \param[in]    scalex, scaley</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScale")> _
Friend Shared Function pixScale(pixs as IntPTR, scalex as single, scaley as single) as IntPTR
End Function

' SRC\scale1.c (273, 1)
' pixScaleToSizeRel()
' pixScaleToSizeRel(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="delw"> \param[in]    delw  change in width, in pixels; 0 means no change</param>
''' <param name="delh"> \param[in]    delh  change in height, in pixels; 0 means no change</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleToSizeRel")> _
Friend Shared Function pixScaleToSizeRel(pixs as IntPTR, delw as Integer, delh as Integer) as IntPTR
End Function

' SRC\scale1.c (316, 1)
' pixScaleToSize()
' pixScaleToSize(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The output scaled image has the dimension(s) you specify:
'''  * * To specify the width with isotropic scaling, set %hd = 0.
'''  * * To specify the height with isotropic scaling, set %wd = 0.
'''  * * If both %wd and %hd are specified, the image is scaled
'''  * (in general, anisotropically) to that size.
'''  * * It is an error to set both %wd and %hd to 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 16 and 32 bpp</param>
''' <param name="wd"> \param[in]    wd  target width; use 0 if using height as target</param>
''' <param name="hd"> \param[in]    hd  target height; use 0 if using width as target</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleToSize")> _
Friend Shared Function pixScaleToSize(pixs as IntPTR, wd as Integer, hd as Integer) as IntPTR
End Function

' SRC\scale1.c (374, 1)
' pixScaleGeneral()
' pixScaleGeneral(PIX *, l_float32, l_float32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixScale() for usage.
'''  *   (2) This interface may change in the future, as other special
'''  * cases are added.
'''  *   (3) The actual sharpening factors used depend on the maximum
'''  * of the two scale factors (maxscale):
'''  *   maxscale = 0.2:  no sharpening
'''  *   0.2  maxscale  1.4:   uses the input parameters
'''  *   maxscale >= 1.4:  no sharpening
'''  *   (4) To avoid sharpening for grayscale and color images with
'''  * scaling factors between 0.2 and 1.4, call this function
'''  * with %sharpfract == 0.0.
'''  *   (5) To use arbitrary sharpening in conjunction with scaling,
'''  * call this function with %sharpfract = 0.0, and follow this
'''  * with a call to pixUnsharpMasking() with your chosen parameters.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 16 and 32 bpp</param>
''' <param name="scalex"> \param[in]    scalex, scaley both > 0.0</param>
''' <param name="scaley"> \param[in]    sharpfract use 0.0 to skip sharpening</param>
''' <param name="sharpfract"> \param[in]    sharpwidth halfwidth of low-pass filter; typ. 1 or 2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleGeneral")> _
Friend Shared Function pixScaleGeneral(pixs as IntPTR, scalex as single, scaley as single, sharpfract as single, sharpwidth as Integer) as IntPTR
End Function

' SRC\scale1.c (458, 1)
' pixScaleLI()
' pixScaleLI(PIX *, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function should only be used when the scale factors are
'''  * greater than or equal to 0.7, and typically greater than 1.
'''  * If either scale factor is larger than 0.7, we issue a warning
'''  * and call pixScaleGeneral(), which will invoke area mapping
'''  * without sharpening.
'''  *   (2) This works on 2, 4, 8, 16 and 32 bpp images, as well as on
'''  * 2, 4 and 8 bpp images that have a colormap.  If there is a
'''  * colormap, it is removed to either gray or RGB, depending
'''  * on the colormap.
'''  *   (3) This does a linear interpolation on the src image.
'''  *   (4) It dispatches to much faster implementations for
'''  * the special cases of 2x and 4x expansion.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 2, 4, 8 or 32 bpp; with or without colormap</param>
''' <param name="scalex"> \param[in]    scalex, scaley must both be >= 0.7</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleLI")> _
Friend Shared Function pixScaleLI(pixs as IntPTR, scalex as single, scaley as single) as IntPTR
End Function

' SRC\scale1.c (519, 1)
' pixScaleColorLI()
' pixScaleColorLI(PIX *, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If either scale factor is larger than 0.7, we issue a warning
'''  * and call pixScaleGeneral(), which will invoke area mapping
'''  * without sharpening.  This is particularly important for
'''  * document images with sharp edges.
'''  *   (2) For the general case, it's about 4x faster to manipulate
'''  * the color pixels directly, rather than to make images
'''  * out of each of the 3 components, scale each component
'''  * using the pixScaleGrayLI(), and combine the results back
'''  * into an rgb image.
'''  *   (3) The speed on intel hardware for the general case (not 2x)
'''  * is about 10 * 10^6 dest-pixels/sec/GHz.  (The special 2x
'''  * case runs at about 80 * 10^6 dest-pixels/sec/GHz.)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp, representing rgb</param>
''' <param name="scalex"> \param[in]    scalex, scaley must both be >= 0.7</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleColorLI")> _
Friend Shared Function pixScaleColorLI(pixs as IntPTR, scalex as single, scaley as single) as IntPTR
End Function

' SRC\scale1.c (585, 1)
' pixScaleColor2xLI()
' pixScaleColor2xLI(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a special case of linear interpolated scaling,
'''  * for 2x upscaling.  It is about 8x faster than using
'''  * the generic pixScaleColorLI(), and about 4x faster than
'''  * using the special 2x scale function pixScaleGray2xLI()
'''  * on each of the three components separately.
'''  *   (2) The speed on intel hardware is about
'''  * 80 * 10^6 dest-pixels/sec/GHz.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp, representing rgb</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleColor2xLI")> _
Friend Shared Function pixScaleColor2xLI(pixs as IntPTR) as IntPTR
End Function

' SRC\scale1.c (634, 1)
' pixScaleColor4xLI()
' pixScaleColor4xLI(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a special case of color linear interpolated scaling,
'''  * for 4x upscaling.  It is about 3x faster than using
'''  * the generic pixScaleColorLI().
'''  *   (2) The speed on intel hardware is about
'''  * 30 * 10^6 dest-pixels/sec/GHz
'''  *   (3) This scales each component separately, using pixScaleGray4xLI().
'''  * It would be about 4x faster to inline the color code properly,
'''  * in analogy to scaleColor4xLILow(), and I leave this as
'''  * an exercise for someone who really needs it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  32 bpp, representing rgb</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleColor4xLI")> _
Friend Shared Function pixScaleColor4xLI(pixs as IntPTR) as IntPTR
End Function

' SRC\scale1.c (738, 1)
' pixScaleGrayLI()
' pixScaleGrayLI(PIX *, l_float32, l_float32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale, no cmap</param>
''' <param name="scalex"> \param[in]    scalex, scaley must both be >= 0.7</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleGrayLI")> _
Friend Shared Function pixScaleGrayLI(pixs as IntPTR, scalex as single, scaley as single) as IntPTR
End Function

' SRC\scale1.c (801, 1)
' pixScaleGray2xLI()
' pixScaleGray2xLI(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a special case of gray linear interpolated scaling,
'''  * for 2x upscaling.  It is about 6x faster than using
'''  * the generic pixScaleGrayLI().
'''  *   (2) The speed on intel hardware is about
'''  * 100 * 10^6 dest-pixels/sec/GHz
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale, not cmapped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleGray2xLI")> _
Friend Shared Function pixScaleGray2xLI(pixs as IntPTR) as IntPTR
End Function

' SRC\scale1.c (844, 1)
' pixScaleGray4xLI()
' pixScaleGray4xLI(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a special case of gray linear interpolated scaling,
'''  * for 4x upscaling.  It is about 12x faster than using
'''  * the generic pixScaleGrayLI().
'''  *   (2) The speed on intel hardware is about
'''  * 160 * 10^6 dest-pixels/sec/GHz.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale, not cmapped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleGray4xLI")> _
Friend Shared Function pixScaleGray4xLI(pixs as IntPTR) as IntPTR
End Function

' SRC\scale1.c (889, 1)
' pixScaleGray2xLIThresh()
' pixScaleGray2xLIThresh(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does 2x upscale on pixs, using linear interpolation,
'''  * followed by thresholding to binary.
'''  *   (2) Buffers are used to avoid making a large grayscale image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
''' <param name="thresh"> \param[in]    thresh  between 0 and 256</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleGray2xLIThresh")> _
Friend Shared Function pixScaleGray2xLIThresh(pixs as IntPTR, thresh as Integer) as IntPTR
End Function

' SRC\scale1.c (968, 1)
' pixScaleGray2xLIDither()
' pixScaleGray2xLIDither(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does 2x upscale on pixs, using linear interpolation,
'''  * followed by Floyd-Steinberg dithering to binary.
'''  *   (2) Buffers are used to avoid making a large grayscale image.
'''  * ~ Two line buffers are used for the src, required for the 2x
'''  *   LI upscale.
'''  * ~ Three line buffers are used for the intermediate image.
'''  *   Two are filled with each 2xLI row operation; the third is
'''  *   needed because the upscale and dithering ops are out of sync.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleGray2xLIDither")> _
Friend Shared Function pixScaleGray2xLIDither(pixs as IntPTR) as IntPTR
End Function

' SRC\scale1.c (1087, 1)
' pixScaleGray4xLIThresh()
' pixScaleGray4xLIThresh(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does 4x upscale on pixs, using linear interpolation,
'''  * followed by thresholding to binary.
'''  *   (2) Buffers are used to avoid making a large grayscale image.
'''  *   (3) If a full 4x expanded grayscale image can be kept in memory,
'''  * this function is only about 10% faster than separately doing
'''  * a linear interpolation to a large grayscale image, followed
'''  * by thresholding to binary.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="thresh"> \param[in]    thresh  between 0 and 256</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleGray4xLIThresh")> _
Friend Shared Function pixScaleGray4xLIThresh(pixs as IntPTR, thresh as Integer) as IntPTR
End Function

' SRC\scale1.c (1175, 1)
' pixScaleGray4xLIDither()
' pixScaleGray4xLIDither(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does 4x upscale on pixs, using linear interpolation,
'''  * followed by Floyd-Steinberg dithering to binary.
'''  *   (2) Buffers are used to avoid making a large grayscale image.
'''  * ~ Two line buffers are used for the src, required for the
'''  *   4xLI upscale.
'''  * ~ Five line buffers are used for the intermediate image.
'''  *   Four are filled with each 4xLI row operation; the fifth
'''  *   is needed because the upscale and dithering ops are
'''  *   out of sync.
'''  *   (3) If a full 4x expanded grayscale image can be kept in memory,
'''  * this function is only about 5% faster than separately doing
'''  * a linear interpolation to a large grayscale image, followed
'''  * by error-diffusion dithering to binary.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleGray4xLIDither")> _
Friend Shared Function pixScaleGray4xLIDither(pixs as IntPTR) as IntPTR
End Function

' SRC\scale1.c (1298, 1)
' pixScaleBySampling()
' pixScaleBySampling(PIX *, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function samples from the source without
'''  * filtering.  As a result, aliasing will occur for
'''  * subsampling (%scalex and/or %scaley  1.0).
'''  *   (2) If %scalex == 1.0 and %scaley == 1.0, returns a copy.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 16, 32 bpp</param>
''' <param name="scalex"> \param[in]    scalex, scaley both > 0.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleBySampling")> _
Friend Shared Function pixScaleBySampling(pixs as IntPTR, scalex as single, scaley as single) as IntPTR
End Function

' SRC\scale1.c (1360, 1)
' pixScaleBySamplingToSize()
' pixScaleBySamplingToSize(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This guarantees that the output scaled image has the
'''  * dimension(s) you specify.
'''  *  ~ To specify the width with isotropic scaling, set %hd = 0.
'''  *  ~ To specify the height with isotropic scaling, set %wd = 0.
'''  *  ~ If both %wd and %hd are specified, the image is scaled
'''  * (in general, anisotropically) to that size.
'''  *  ~ It is an error to set both %wd and %hd to 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 16 and 32 bpp</param>
''' <param name="wd"> \param[in]    wd  target width; use 0 if using height as target</param>
''' <param name="hd"> \param[in]    hd  target height; use 0 if using width as target</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleBySamplingToSize")> _
Friend Shared Function pixScaleBySamplingToSize(pixs as IntPTR, wd as Integer, hd as Integer) as IntPTR
End Function

' SRC\scale1.c (1405, 1)
' pixScaleByIntSampling()
' pixScaleByIntSampling(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Simple interface to pixScaleBySampling(), for
'''  * isotropic integer reduction.
'''  *   (2) If %factor == 1, returns a copy.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 16, 32 bpp</param>
''' <param name="factor"> \param[in]    factor integer subsampling</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleByIntSampling")> _
Friend Shared Function pixScaleByIntSampling(pixs as IntPTR, factor as Integer) as IntPTR
End Function

' SRC\scale1.c (1447, 1)
' pixScaleRGBToGrayFast()
' pixScaleRGBToGrayFast(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does simultaneous subsampling by an integer factor and
'''  * extraction of the color from the RGB pix.
'''  *   (2) It is designed for maximum speed, and is used for quickly
'''  * generating a downsized grayscale image from a higher resolution
'''  * RGB image.  This would typically be used for image analysis.
'''  *   (3) The standard color byte order (RGBA) is assumed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="factor"> \param[in]    factor integer reduction factor >= 1</param>
''' <param name="color"> \param[in]    color one of COLOR_RED, COLOR_GREEN, COLOR_BLUE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleRGBToGrayFast")> _
Friend Shared Function pixScaleRGBToGrayFast(pixs as IntPTR, factor as Integer, color as Integer) as IntPTR
End Function

' SRC\scale1.c (1522, 1)
' pixScaleRGBToBinaryFast()
' pixScaleRGBToBinaryFast(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does simultaneous subsampling by an integer factor and
'''  * conversion from RGB to gray to binary.
'''  *   (2) It is designed for maximum speed, and is used for quickly
'''  * generating a downsized binary image from a higher resolution
'''  * RGB image.  This would typically be used for image analysis.
'''  *   (3) It uses the green channel to represent the RGB pixel intensity.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp RGB</param>
''' <param name="factor"> \param[in]    factor integer reduction factor >= 1</param>
''' <param name="thresh"> \param[in]    thresh binarization threshold</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleRGBToBinaryFast")> _
Friend Shared Function pixScaleRGBToBinaryFast(pixs as IntPTR, factor as Integer, thresh as Integer) as IntPTR
End Function

' SRC\scale1.c (1588, 1)
' pixScaleGrayToBinaryFast()
' pixScaleGrayToBinaryFast(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does simultaneous subsampling by an integer factor and
'''  * thresholding from gray to binary.
'''  *   (2) It is designed for maximum speed, and is used for quickly
'''  * generating a downsized binary image from a higher resolution
'''  * gray image.  This would typically be used for image analysis.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp grayscale</param>
''' <param name="factor"> \param[in]    factor integer reduction factor >= 1</param>
''' <param name="thresh"> \param[in]    thresh binarization threshold</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleGrayToBinaryFast")> _
Friend Shared Function pixScaleGrayToBinaryFast(pixs as IntPTR, factor as Integer, thresh as Integer) as IntPTR
End Function

' SRC\scale1.c (1671, 1)
' pixScaleSmooth()
' pixScaleSmooth(PIX *, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function should only be used when the scale factors are less
'''  * than or equal to 0.7 (i.e., more than about 1.42x reduction).
'''  * If either scale factor is larger than 0.7, we issue a warning
'''  * and call pixScaleGeneral(), which will invoke linear
'''  * interpolation without sharpening.
'''  *   (2) This works only on 2, 4, 8 and 32 bpp images, and if there is
'''  * a colormap, it is removed by converting to RGB.  In other
'''  * cases, we issue a warning and call pixScaleGeneral().
'''  *   (3) It does simple (flat filter) convolution, with a filter size
'''  * commensurate with the amount of reduction, to avoid antialiasing.
'''  *   (4) It does simple subsampling after smoothing, which is appropriate
'''  * for this range of scaling.  Linear interpolation gives essentially
'''  * the same result with more computation for these scale factors,
'''  * so we don't use it.
'''  *   (5) The result is the same as doing a full block convolution followed by
'''  * subsampling, but this is faster because the results of the block
'''  * convolution are only computed at the subsampling locations.
'''  * In fact, the computation time is approximately independent of
'''  * the scale factor, because the convolution kernel is adjusted
'''  * so that each source pixel is summed approximately once.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix 2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
''' <param name="scalex"> \param[in]    scalex, scaley must both be < 0.7</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleSmooth")> _
Friend Shared Function pixScaleSmooth(pix as IntPTR, scalex as single, scaley as single) as IntPTR
End Function

' SRC\scale1.c (1767, 1)
' pixScaleSmoothToSize()
' pixScaleSmoothToSize(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See notes in pixScaleSmooth().
'''  *   (2) The output scaled image has the dimension(s) you specify:
'''  * * To specify the width with isotropic scaling, set %hd = 0.
'''  * * To specify the height with isotropic scaling, set %wd = 0.
'''  * * If both %wd and %hd are specified, the image is scaled
'''  * (in general, anisotropically) to that size.
'''  * * It is an error to set both %wd and %hd to 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
''' <param name="wd"> \param[in]    wd   target width; use 0 if using height as target</param>
''' <param name="hd"> \param[in]    hd   target height; use 0 if using width as target</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleSmoothToSize")> _
Friend Shared Function pixScaleSmoothToSize(pixs as IntPTR, wd as Integer, hd as Integer) as IntPTR
End Function

' SRC\scale1.c (1805, 1)
' pixScaleRGBToGray2()
' pixScaleRGBToGray2(PIX *, l_float32, l_float32, l_float32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, 8 bpp, 2x reduced, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb</param>
''' <param name="rwt"> \param[in]    rwt, gwt, bwt must sum to 1.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleRGBToGray2")> _
Friend Shared Function pixScaleRGBToGray2(pixs as IntPTR, rwt as single, gwt as single, bwt as single) as IntPTR
End Function

' SRC\scale1.c (1872, 1)
' pixScaleAreaMap()
' pixScaleAreaMap(PIX *, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function should only be used when the scale factors are less
'''  * than or equal to 0.7 (i.e., more than about 1.42x reduction).
'''  * If either scale factor is larger than 0.7, we issue a warning
'''  * and call pixScaleGeneral(), which will invoke linear
'''  * interpolation without sharpening.
'''  *   (2) This works only on 2, 4, 8 and 32 bpp images.  If there is
'''  * a colormap, it is removed by converting to RGB.  In other
'''  * cases, we issue a warning and call pixScaleGeneral().
'''  *   (3) This is faster than pixScale() because it does not do sharpening.
'''  *   (4) It does a relatively expensive area mapping computation, to
'''  * avoid antialiasing.  It is about 2x slower than pixScaleSmooth(),
'''  * but the results are much better on fine text.
'''  *   (5) This is typically about 20% faster for the special cases of
'''  * 2x, 4x, 8x and 16x reduction.
'''  *   (6) Surprisingly, there is no speedup (and a slight quality
'''  * impairment) if you do as many successive 2x reductions as
'''  * possible, ending with a reduction with a scale factor larger
'''  * than 0.5.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix 2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
''' <param name="scalex"> \param[in]    scalex, scaley must both be <= 0.7</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleAreaMap")> _
Friend Shared Function pixScaleAreaMap(pix as IntPTR, scalex as single, scaley as single) as IntPTR
End Function

' SRC\scale1.c (1992, 1)
' pixScaleAreaMap2()
' pixScaleAreaMap2(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function does an area mapping (average) for 2x
'''  * reduction.
'''  *   (2) This works only on 2, 4, 8 and 32 bpp images.  If there is
'''  * a colormap, it is removed by converting to RGB.
'''  *   (3) Speed on 3 GHz processor:
'''  * Color: 160 Mpix/sec
'''  * Gray: 700 Mpix/sec
'''  * This contrasts with the speed of the general pixScaleAreaMap():
'''  * Color: 35 Mpix/sec
'''  * Gray: 50 Mpix/sec
'''  *   (4) From (3), we see that this special function is about 4.5x
'''  * faster for color and 14x faster for grayscale
'''  *   (5) Consequently, pixScaleAreaMap2() is incorporated into the
'''  * general area map scaling function, for the special cases
'''  * of 2x, 4x, 8x and 16x reduction.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix 2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleAreaMap2")> _
Friend Shared Function pixScaleAreaMap2(pix as IntPTR) as IntPTR
End Function

' SRC\scale1.c (2057, 1)
' pixScaleAreaMapToSize()
' pixScaleAreaMapToSize(PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See notes in pixScaleAreaMap().
'''  *   (2) The output scaled image has the dimension(s) you specify:
'''  * * To specify the width with isotropic scaling, set %hd = 0.
'''  * * To specify the height with isotropic scaling, set %wd = 0.
'''  * * If both %wd and %hd are specified, the image is scaled
'''  * (in general, anisotropically) to that size.
'''  * * It is an error to set both %wd and %hd to 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
''' <param name="wd"> \param[in]    wd   target width; use 0 if using height as target</param>
''' <param name="hd"> \param[in]    hd   target height; use 0 if using width as target</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleAreaMapToSize")> _
Friend Shared Function pixScaleAreaMapToSize(pixs as IntPTR, wd as Integer, hd as Integer) as IntPTR
End Function

' SRC\scale1.c (2105, 1)
' pixScaleBinary()
' pixScaleBinary(PIX *, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function samples from the source without
'''  * filtering.  As a result, aliasing will occur for
'''  * subsampling (scalex and scaley  1.0).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="scalex"> \param[in]    scalex, scaley both > 0.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleBinary")> _
Friend Shared Function pixScaleBinary(pixs as IntPTR, scalex as single, scaley as single) as IntPTR
End Function

#End Region
#Region "SRC\scale2.c"
' SRC\scale2.c (101, 13)
' scaleToGray2Low()
' scaleToGray2Low(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_uint32 *, l_uint8 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error.</returns>
''' <param name="datad"> \param[in]    datad   dest data</param>
''' <param name="wd"> \param[in]    wd, hd  dest width, height</param>
''' <param name="hd"> \param[in]    wpld    dest words/line</param>
''' <param name="wpld"> \param[in]    datas   src data</param>
''' <param name="datas"> \param[in]    wpls    src words/line</param>
''' <param name="wpls"> \param[in]    sumtab  made from makeSumTabSG2()</param>
''' <param name="sumtab"> \param[in]    valtab  made from makeValTabSG2()</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleToGray2Low")> _
Friend Shared Function scaleToGray2Low(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, wpls as Integer, sumtab as UInteger, valtab as Byte) as Boolean ' Org. Void
End Function

' SRC\scale2.c (104, 18)
' makeSumTabSG2()
' makeSumTabSG2() as l_uint32 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeSumTabSG2")> _
Friend Shared Function makeSumTabSG2() as String
End Function

' SRC\scale2.c (105, 17)
' makeValTabSG2()
' makeValTabSG2() as l_uint8 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeValTabSG2")> _
Friend Shared Function makeValTabSG2() as String
End Function

' SRC\scale2.c (106, 13)
' scaleToGray3Low()
' scaleToGray3Low(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_uint32 *, l_uint8 *) as void
''' <summary>
''' * Notes:
'''  *  Each set of 8 3x3 bit-blocks in the source image, which
'''  *  consist of 72 pixels arranged 24 pixels wide by 3 scanlines,
'''  *  is converted to a row of 8 8-bit pixels in the dest image.
'''  *  These 72 pixels of the input image are runs of 24 pixels
'''  *  in three adjacent scanlines.  Each run of 24 pixels is
'''  *  stored in the 24 LSbits of a 32-bit word.  We use 2 LUTs.
'''  *  The first, sumtab, takes 6 of these bits and stores
'''  *  sum, taken 3 bits at a time, in two bytes.  (See
'''  *  makeSumTabSG3).  This is done for each of the 3 scanlines,
'''  *  and the results are added.  We now have the sum of ON pixels
'''  *  in the first two 3x3 blocks in two bytes.  The valtab LUT
'''  *  then converts these values (which go from 0 to 9) to
'''  *  grayscale values between between 255 and 0.  (See makeValTabSG3).
'''  *  This process is repeated for each of the other 3 sets of
'''  *  6x3 input pixels, giving 8 output pixels in total.
'''  *
'''  *  Note: because the input image is processed in groups of
'''  *  24 x 3 pixels, the process clips the input height to
'''  *  (h - h % 3) and the input width to (w - w % 24).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="datad"> \param[in]    datad   dest data</param>
''' <param name="wd"> \param[in]    wd, hd  dest width, height</param>
''' <param name="hd"> \param[in]    wpld    dest words/line</param>
''' <param name="wpld"> \param[in]    datas   src data</param>
''' <param name="datas"> \param[in]    wpls    src words/line</param>
''' <param name="wpls"> \param[in]    sumtab  made from makeSumTabSG3()</param>
''' <param name="sumtab"> \param[in]    valtab  made from makeValTabSG3()</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleToGray3Low")> _
Friend Shared Function scaleToGray3Low(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, wpls as Integer, sumtab as UInteger, valtab as Byte) as Boolean ' Org. Void
End Function

' SRC\scale2.c (109, 18)
' makeSumTabSG3()
' makeSumTabSG3() as l_uint32 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeSumTabSG3")> _
Friend Shared Function makeSumTabSG3() as String
End Function

' SRC\scale2.c (110, 17)
' makeValTabSG3()
' makeValTabSG3() as l_uint8 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeValTabSG3")> _
Friend Shared Function makeValTabSG3() as String
End Function

' SRC\scale2.c (111, 13)
' scaleToGray4Low()
' scaleToGray4Low(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_uint32 *, l_uint8 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error.</returns>
''' <param name="datad"> \param[in]    datad   dest data</param>
''' <param name="wd"> \param[in]    wd, hd  dest width, height</param>
''' <param name="hd"> \param[in]    wpld    dest words/line</param>
''' <param name="wpld"> \param[in]    datas   src data</param>
''' <param name="datas"> \param[in]    wpls    src words/line</param>
''' <param name="wpls"> \param[in]    sumtab  made from makeSumTabSG4()</param>
''' <param name="sumtab"> \param[in]    valtab  made from makeValTabSG4()</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleToGray4Low")> _
Friend Shared Function scaleToGray4Low(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, wpls as Integer, sumtab as UInteger, valtab as Byte) as Boolean ' Org. Void
End Function

' SRC\scale2.c (114, 18)
' makeSumTabSG4()
' makeSumTabSG4() as l_uint32 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeSumTabSG4")> _
Friend Shared Function makeSumTabSG4() as String
End Function

' SRC\scale2.c (115, 17)
' makeValTabSG4()
' makeValTabSG4() as l_uint8 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeValTabSG4")> _
Friend Shared Function makeValTabSG4() as String
End Function

' SRC\scale2.c (116, 13)
' scaleToGray6Low()
' scaleToGray6Low(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32 *, l_uint8 *) as void
''' <summary>
''' * Notes:
'''  *  Each set of 4 6x6 bit-blocks in the source image, which
'''  *  consist of 144 pixels arranged 24 pixels wide by 6 scanlines,
'''  *  is converted to a row of 4 8-bit pixels in the dest image.
'''  *  These 144 pixels of the input image are runs of 24 pixels
'''  *  in six adjacent scanlines.  Each run of 24 pixels is
'''  *  stored in the 24 LSbits of a 32-bit word.  We use 2 LUTs.
'''  *  The first, tab8, takes 6 of these bits and stores
'''  *  sum in one byte.  This is done for each of the 6 scanlines,
'''  *  and the results are added.
'''  *  We now have the sum of ON pixels in the first 6x6 block.  The
'''  *  valtab LUT then converts these values (which go from 0 to 36) to
'''  *  grayscale values between between 255 and 0.  (See makeValTabSG6).
'''  *  This process is repeated for each of the other 3 sets of
'''  *  6x6 input pixels, giving 4 output pixels in total.
'''  *
'''  *  Note: because the input image is processed in groups of
'''  *  24 x 6 pixels, the process clips the input height to
'''  *  (h - h % 6) and the input width to (w - w % 24).
'''  *
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="datad"> \param[in]    datad   dest data</param>
''' <param name="wd"> \param[in]    wd, hd  dest width, height</param>
''' <param name="hd"> \param[in]    wpld    dest words/line</param>
''' <param name="wpld"> \param[in]    datas   src data</param>
''' <param name="datas"> \param[in]    wpls    src words/line</param>
''' <param name="wpls"> \param[in]    tab8  made from makePixelSumTab8()</param>
''' <param name="tab8"> \param[in]    valtab  made from makeValTabSG6()</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleToGray6Low")> _
Friend Shared Function scaleToGray6Low(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, wpls as Integer, tab8 as Integer, valtab as Byte) as Boolean ' Org. Void
End Function

' SRC\scale2.c (119, 17)
' makeValTabSG6()
' makeValTabSG6() as l_uint8 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeValTabSG6")> _
Friend Shared Function makeValTabSG6() as String
End Function

' SRC\scale2.c (120, 13)
' scaleToGray8Low()
' scaleToGray8Low(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32 *, l_uint8 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error.</returns>
''' <param name="datad"> \param[in]    datad   dest data</param>
''' <param name="wd"> \param[in]    wd, hd  dest width, height</param>
''' <param name="hd"> \param[in]    wpld    dest words/line</param>
''' <param name="wpld"> \param[in]    datas   src data</param>
''' <param name="datas"> \param[in]    wpls    src words/line</param>
''' <param name="wpls"> \param[in]    tab8  made from makePixelSumTab8()</param>
''' <param name="tab8"> \param[in]    valtab  made from makeValTabSG8()</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleToGray8Low")> _
Friend Shared Function scaleToGray8Low(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, wpls as Integer, tab8 as Integer, valtab as Byte) as Boolean ' Org. Void
End Function

' SRC\scale2.c (123, 17)
' makeValTabSG8()
' makeValTabSG8() as l_uint8 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeValTabSG8")> _
Friend Shared Function makeValTabSG8() as String
End Function

' SRC\scale2.c (124, 13)
' scaleToGray16Low()
' scaleToGray16Low(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error.</returns>
''' <param name="datad"> \param[in]    datad   dest data</param>
''' <param name="wd"> \param[in]    wd, hd  dest width, height</param>
''' <param name="hd"> \param[in]    wpld    dest words/line</param>
''' <param name="wpld"> \param[in]    datas   src data</param>
''' <param name="datas"> \param[in]    wpls    src words/line</param>
''' <param name="wpls"> \param[in]    tab8    made from makePixelSumTab8()</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleToGray16Low")> _
Friend Shared Function scaleToGray16Low(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas as UInteger, wpls as Integer, tab8 as Integer) as Boolean ' Org. Void
End Function

' SRC\scale2.c (127, 16)
' scaleMipmapLow()
' scaleMipmapLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_uint32 *, l_int32, l_float32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="scaleMipmapLow")> _
Friend Shared Function scaleMipmapLow(datad as UInteger, wd as Integer, hd as Integer, wpld as Integer, datas1 as UInteger, wpls1 as Integer, datas2 as UInteger, wpls2 as Integer, red as single) as Integer
End Function

' SRC\scale2.c (204, 1)
' pixScaleToGray()
' pixScaleToGray(PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *
'''  *  For faster scaling in the range of scalefactors from 0.0625 to 0.5,
'''  *  with very little difference in quality, use pixScaleToGrayFast().
'''  *
'''  *  Binary images have sharp edges, so they intrinsically have very
'''  *  high frequency content.  To avoid aliasing, they must be low-pass
'''  *  filtered, which tends to blur the edges.  How can we keep relatively
'''  *  crisp edges without aliasing?  The trick is to do binary upscaling
'''  *  followed by a power-of-2 scaleToGray.  For large reductions, where
'''  *  you don't end up with much detail, some corners can be cut.
'''  *
'''  *  The intent here is to get high quality reduced grayscale
'''  *  images with relatively little computation.  We do binary
'''  *  pre-scaling followed by scaleToGrayN() for best results,
'''  *  esp. to avoid excess blur when the scale factor is near
'''  *  an inverse power of 2.  Where a low-pass filter is required,
'''  *  we use simple convolution kernels: either the hat filter for
'''  *  linear interpolation or a flat filter for larger downscaling.
'''  *  Other choices, such as a perfect bandpass filter with infinite extent
'''  *  (the sinc) or various approximations to it (e.g., lanczos), are
'''  *  unnecessarily expensive.
'''  *
'''  *  The choices made are as follows:
'''  *   (1) Do binary upscaling before scaleToGrayN() for scalefactors > 1/8
'''  *   (2) Do binary downscaling before scaleToGray8() for scalefactors
'''  * between 1/16 and 1/8.
'''  *   (3) Use scaleToGray16() before grayscale downscaling for
'''  * scalefactors less than 1/16
'''  *  Another reasonable choice would be to start binary downscaling
'''  *  for scalefactors below 1/4, rather than below 1/8 as we do here.
'''  *
'''  *  The general scaling rules, not all of which are used here, go as follows:
'''  *   (1) For grayscale upscaling, use pixScaleGrayLI().  However,
'''  * note that edges will be visibly blurred for scalefactors
'''  * near (but above) 1.0.  Replication will avoid edge blur,
'''  * and should be considered for factors very near 1.0.
'''  *   (2) For grayscale downscaling with a scale factor larger than
'''  * about 0.7, use pixScaleGrayLI().  For scalefactors near
'''  * (but below) 1.0, you tread between Scylla and Charybdis.
'''  * pixScaleGrayLI() again gives edge blurring, but
'''  * pixScaleBySampling() gives visible aliasing.
'''  *   (3) For grayscale downscaling with a scale factor smaller than
'''  * about 0.7, use pixScaleSmooth()
'''  *   (4) For binary input images, do as much scale to gray as possible
'''  * using the special integer functions (2, 3, 4, 8 and 16).
'''  *   (5) It is better to upscale in binary, followed by scaleToGrayN()
'''  * than to do scaleToGrayN() followed by an upscale using either
'''  * LI or oversampling.
'''  *   (6) It may be better to downscale in binary, followed by
'''  * scaleToGrayN() than to first use scaleToGrayN() followed by
'''  * downscaling.  For downscaling between 8x and 16x, this is
'''  * a reasonable option.
'''  *   (7) For reductions greater than 16x, it's reasonable to use
'''  * scaleToGray16() followed by further grayscale downscaling.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, scaled down by scalefactor in each direction,</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="scalefactor"> \param[in]    scalefactor reduction: must be > 0.0 and < 1.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleToGray")> _
Friend Shared Function pixScaleToGray(pixs as IntPTR, scalefactor as single) as IntPTR
End Function

' SRC\scale2.c (315, 1)
' pixScaleToGrayFast()
' pixScaleToGrayFast(PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See notes in pixScaleToGray() for the basic approach.
'''  *   (2) This function is considerably less expensive than pixScaleToGray()
'''  * for scalefactor in the range (0.0625 ... 0.5), and the
'''  * quality is nearly as good.
'''  *   (3) Unlike pixScaleToGray(), which does binary upscaling before
'''  * downscaling for scale factors >= 0.0625, pixScaleToGrayFast()
'''  * first downscales in binary for all scale factors  0.5, and
'''  * then does a 2x scale-to-gray as the final step.  For
'''  * scale factors  0.0625, both do a 16x scale-to-gray, followed
'''  * by further grayscale reduction.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, scaled down by scalefactor in each direction,</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="scalefactor"> \param[in]    scalefactor reduction: must be > 0.0 and < 1.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleToGrayFast")> _
Friend Shared Function pixScaleToGrayFast(pixs as IntPTR, scalefactor as single) as IntPTR
End Function

' SRC\scale2.c (386, 1)
' pixScaleToGray2()
' pixScaleToGray2(PIX *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, scaled down by 2x in each direction,</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleToGray2")> _
Friend Shared Function pixScaleToGray2(pixs as IntPTR) as IntPTR
End Function

' SRC\scale2.c (443, 1)
' pixScaleToGray3()
' pixScaleToGray3(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Speed is about 100 x 10^6 src-pixels/sec/GHz.
'''  * Another way to express this is it processes 1 src pixel
'''  * in about 10 cycles.
'''  *   (2) The width of pixd is truncated is truncated to a factor of 8.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, scaled down by 3x in each direction,</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleToGray3")> _
Friend Shared Function pixScaleToGray3(pixs as IntPTR) as IntPTR
End Function

' SRC\scale2.c (497, 1)
' pixScaleToGray4()
' pixScaleToGray4(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The width of pixd is truncated is truncated to a factor of 2.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, scaled down by 4x in each direction,</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleToGray4")> _
Friend Shared Function pixScaleToGray4(pixs as IntPTR) as IntPTR
End Function

' SRC\scale2.c (552, 1)
' pixScaleToGray6()
' pixScaleToGray6(PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The width of pixd is truncated is truncated to a factor of 8.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, scaled down by 6x in each direction,</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleToGray6")> _
Friend Shared Function pixScaleToGray6(pixs as IntPTR) as IntPTR
End Function

' SRC\scale2.c (600, 1)
' pixScaleToGray8()
' pixScaleToGray8(PIX *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, scaled down by 8x in each direction,</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleToGray8")> _
Friend Shared Function pixScaleToGray8(pixs as IntPTR) as IntPTR
End Function

' SRC\scale2.c (649, 1)
' pixScaleToGray16()
' pixScaleToGray16(PIX *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, scaled down by 16x in each direction,</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleToGray16")> _
Friend Shared Function pixScaleToGray16(pixs as IntPTR) as IntPTR
End Function

' SRC\scale2.c (722, 1)
' pixScaleToGrayMipmap()
' pixScaleToGrayMipmap(PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *
'''  *  This function is here mainly for pedagogical reasons.
'''  *  Mip-mapping is widely used in graphics for texture mapping, because
'''  *  the texture changes smoothly with scale.  This is accomplished by
'''  *  constructing a multiresolution pyramid and, for each pixel,
'''  *  doing a linear interpolation between corresponding pixels in
'''  *  the two planes of the pyramid that bracket the desired resolution.
'''  *  The computation is very efficient, and is implemented in hardware
'''  *  in high-end graphics cards.
'''  *
'''  *  We can use mip-mapping for scale-to-gray by using two scale-to-gray
'''  *  reduced images (we don't need the entire pyramid) selected from
'''  *  the set {2x, 4x, ... 16x}, and interpolating.  However, we get
'''  *  severe aliasing, probably because we are subsampling from the
'''  *  higher resolution image.  The method is very fast, but the result
'''  *  is very poor.  In fact, the results don't look any better than
'''  *  either subsampling off the higher-res grayscale image or oversampling
'''  *  on the lower-res image.  Consequently, this method should NOT be used
'''  *  for generating reduced images, scale-to-gray or otherwise.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, scaled down by scalefactor in each direction,</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="scalefactor"> \param[in]    scalefactor reduction: must be > 0.0 and < 1.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleToGrayMipmap")> _
Friend Shared Function pixScaleToGrayMipmap(pixs as IntPTR, scalefactor as single) as IntPTR
End Function

' SRC\scale2.c (810, 1)
' pixScaleMipmap()
' pixScaleMipmap(PIX *, PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See notes in pixScaleToGrayMipmap().
'''  *   (2) This function suffers from aliasing effects that are
'''  * easily seen in document images.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  8 bpp pix, scaled down by reduction in each direction,</returns>
''' <param name="pixs1"> \param[in]    pixs1 high res 8 bpp, no cmap</param>
''' <param name="pixs2"> \param[in]    pixs2 low res -- 2x reduced -- 8 bpp, no cmap</param>
''' <param name="scale"> \param[in]    scale reduction with respect to high res image, > 0.5</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleMipmap")> _
Friend Shared Function pixScaleMipmap(pixs1 as IntPTR, pixs2 as IntPTR, scale as single) as IntPTR
End Function

' SRC\scale2.c (867, 1)
' pixExpandReplicate()
' pixExpandReplicate(PIX *, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd scaled up, or NULL on error.</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 16, 32 bpp</param>
''' <param name="factor"> \param[in]    factor integer scale factor for replicative expansion</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExpandReplicate")> _
Friend Shared Function pixExpandReplicate(pixs as IntPTR, factor as Integer) as IntPTR
End Function

' SRC\scale2.c (1014, 1)
' pixScaleGrayMinMax()
' pixScaleGrayMinMax(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The downscaled pixels in pixd are the min, max or (max - min)
'''  * of the corresponding set of xfact * yfact pixels in pixs.
'''  *   (2) Using L_CHOOSE_MIN is equivalent to a grayscale erosion,
'''  * using a brick Sel of size (xfact * yfact), followed by
'''  * subsampling within each (xfact * yfact) cell.  Using
'''  * L_CHOOSE_MAX is equivalent to the corresponding dilation.
'''  *   (3) Using L_CHOOSE_MAXDIFF finds the difference between max
'''  * and min values in each cell.
'''  *   (4) For the special case of downscaling by 2x in both directions,
'''  * pixScaleGrayMinMax2() is about 2x more efficient.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
''' <param name="xfact"> \param[in]    xfact x downscaling factor; integer</param>
''' <param name="yfact"> \param[in]    yfact y downscaling factor; integer</param>
''' <param name="type"> \param[in]    type L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleGrayMinMax")> _
Friend Shared Function pixScaleGrayMinMax(pixs as IntPTR, xfact as Integer, yfact as Integer, type as Integer) as IntPTR
End Function

' SRC\scale2.c (1121, 1)
' pixScaleGrayMinMax2()
' pixScaleGrayMinMax2(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Special version for 2x reduction.  The downscaled pixels
'''  * in pixd are the min, max or (max - min) of the corresponding
'''  * set of 4 pixels in pixs.
'''  *   (2) The max and min operations are a special case (for levels 1
'''  * and 4) of grayscale analog to the binary rank scaling operation
'''  * pixReduceRankBinary2().  Note, however, that because of
'''  * the photometric definition that higher gray values are
'''  * lighter, the erosion-like L_CHOOSE_MIN will darken
'''  * the resulting image, corresponding to a threshold level 1
'''  * in the binary case.  Likewise, L_CHOOSE_MAX will lighten
'''  * the pixd, corresponding to a threshold level of 4.
'''  *   (3) To choose any of the four rank levels in a 2x grayscale
'''  * reduction, use pixScaleGrayRank2().
'''  *   (4) This runs at about 70 MPix/sec/GHz of source data for
'''  * erosion and dilation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp downscaled by 2x</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
''' <param name="type"> \param[in]    type L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleGrayMinMax2")> _
Friend Shared Function pixScaleGrayMinMax2(pixs as IntPTR, type as Integer) as IntPTR
End Function

' SRC\scale2.c (1204, 1)
' pixScaleGrayRankCascade()
' pixScaleGrayRankCascade(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This performs up to four cascaded 2x rank reductions.
'''  *   (2) Use level = 0 to truncate the cascade.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, downscaled by up to 16x</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, not cmapped</param>
''' <param name="level1"> \param[in]    level1, level2, level3, level4 rank thresholds,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleGrayRankCascade")> _
Friend Shared Function pixScaleGrayRankCascade(pixs as IntPTR, level1 as Integer, level2 as Integer, level3 as Integer, level4 as Integer) as IntPTR
End Function

' SRC\scale2.c (1268, 1)
' pixScaleGrayRank2()
' pixScaleGrayRank2(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Rank 2x reduction.  If rank == 1(4), the downscaled pixels
'''  * in pixd are the min(max) of the corresponding set of
'''  * 4 pixels in pixs.  Values 2 and 3 are intermediate.
'''  *   (2) This is the grayscale analog to the binary rank scaling operation
'''  * pixReduceRankBinary2().  Here, because of the photometric
'''  * definition that higher gray values are lighter, rank 1 gives
'''  * the darkest pixel, whereas rank 4 gives the lightest pixel.
'''  * This is opposite to the binary rank operation.
'''  *   (3) For rank = 1 and 4, this calls pixScaleGrayMinMax2(),
'''  * which runs at about 70 MPix/sec/GHz of source data.
'''  * For rank 2 and 3, this runs 3x slower, at about 25 MPix/sec/GHz.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp, downscaled by 2x</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp, no cmap</param>
''' <param name="rank"> \param[in]    rank 1 (darkest), 2, 3, 4 (lightest)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleGrayRank2")> _
Friend Shared Function pixScaleGrayRank2(pixs as IntPTR, rank as Integer) as IntPTR
End Function

' SRC\scale2.c (1358, 1)
' pixScaleAndTransferAlpha()
' pixScaleAndTransferAlpha(PIX *, PIX *, l_float32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This scales the alpha component of pixs and inserts into pixd.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixd"> \param[in]    pixd  32 bpp, scaled image</param>
''' <param name="pixs"> \param[in]    pixs  32 bpp, original unscaled image</param>
''' <param name="scalex"> \param[in]    scalex, scaley both > 0.0</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleAndTransferAlpha")> _
Friend Shared Function pixScaleAndTransferAlpha(pixd as IntPTR, pixs as IntPTR, scalex as single, scaley as single) as Integer
End Function

' SRC\scale2.c (1436, 1)
' pixScaleWithAlpha()
' pixScaleWithAlpha(PIX *, l_float32, l_float32, PIX *, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The alpha channel is transformed separately from pixs,
'''  * and aligns with it, being fully transparent outside the
'''  * boundary of the transformed pixs.  For pixels that are fully
'''  * transparent, a blending function like pixBlendWithGrayMask()
'''  * will give zero weight to corresponding pixels in pixs.
'''  *   (2) Scaling is done with area mapping or linear interpolation,
'''  * depending on the scale factors.  Default sharpening is done.
'''  *   (3) If pixg is NULL, it is generated as an alpha layer that is
'''  * partially opaque, using %fract.  Otherwise, it is cropped
'''  * to pixs if required, and %fract is ignored.  The alpha
'''  * channel in pixs is never used.
'''  *   (4) Colormaps are removed to 32 bpp.
'''  *   (5) The default setting for the border values in the alpha channel
'''  * is 0 (transparent) for the outermost ring of pixels and
'''  * (0.5 * fract * 255) for the second ring.  When blended over
'''  * a second image, this
'''  * (a) shrinks the visible image to make a clean overlap edge
'''  *  with an image below, and
'''  * (b) softens the edges by weakening the aliasing there.
'''  * Use l_setAlphaMaskBorder() to change these values.
'''  *   (6) A subtle use of gamma correction is to remove gamma correction
'''  * before scaling and restore it afterwards.  This is done
'''  * by sandwiching this function between a gamma/inverse-gamma
'''  * photometric transform:
'''  *  pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);
'''  *  pixd = pixScaleWithAlpha(pixt, scalex, scaley, NULL, fract);
'''  *  pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);
'''  *  pixDestroy(&pixt);
'''  * This has the side-effect of producing artifacts in the very
'''  * dark regions.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp rgba, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 32 bpp rgb or cmapped</param>
''' <param name="scalex"> \param[in]    scalex, scaley must be > 0.0</param>
''' <param name="scaley"> \param[in]    pixg [optional] 8 bpp, can be null</param>
''' <param name="pixg"> \param[in]    fract between 0.0 and 1.0, with 0.0 fully transparent</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixScaleWithAlpha")> _
Friend Shared Function pixScaleWithAlpha(pixs as IntPTR, scalex as single, scaley as single, pixg as IntPTR, fract as single) as IntPTR
End Function

#End Region
#Region "SRC\seedfill.c"
' SRC\seedfill.c (177, 13)
' seedfillBinaryLow()
' seedfillBinaryLow(l_uint32 *, l_int32, l_int32, l_uint32 *, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="seedfillBinaryLow")> _
Friend Shared Function seedfillBinaryLow(datas as UInteger, hs as Integer, wpls as Integer, datam as UInteger, hm as Integer, wplm as Integer, connectivity as Integer) as Boolean ' Org. Void
End Function

' SRC\seedfill.c (180, 13)
' seedfillGrayLow()
' seedfillGrayLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="seedfillGrayLow")> _
Friend Shared Function seedfillGrayLow(datas as UInteger, w as Integer, h as Integer, wpls as Integer, datam as UInteger, wplm as Integer, connectivity as Integer) as Boolean ' Org. Void
End Function

' SRC\seedfill.c (183, 13)
' seedfillGrayInvLow()
' seedfillGrayInvLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="seedfillGrayInvLow")> _
Friend Shared Function seedfillGrayInvLow(datas as UInteger, w as Integer, h as Integer, wpls as Integer, datam as UInteger, wplm as Integer, connectivity as Integer) as Boolean ' Org. Void
End Function

' SRC\seedfill.c (186, 13)
' seedfillGrayLowSimple()
' seedfillGrayLowSimple(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="seedfillGrayLowSimple")> _
Friend Shared Function seedfillGrayLowSimple(datas as UInteger, w as Integer, h as Integer, wpls as Integer, datam as UInteger, wplm as Integer, connectivity as Integer) as Boolean ' Org. Void
End Function

' SRC\seedfill.c (189, 13)
' seedfillGrayInvLowSimple()
' seedfillGrayInvLowSimple(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="seedfillGrayInvLowSimple")> _
Friend Shared Function seedfillGrayInvLowSimple(datas as UInteger, w as Integer, h as Integer, wpls as Integer, datam as UInteger, wplm as Integer, connectivity as Integer) as Boolean ' Org. Void
End Function

' SRC\seedfill.c (192, 13)
' distanceFunctionLow()
' distanceFunctionLow(l_uint32 *, l_int32, l_int32, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="distanceFunctionLow")> _
Friend Shared Function distanceFunctionLow(datad as UInteger, w as Integer, h as Integer, d as Integer, wpld as Integer, connectivity as Integer) as Boolean ' Org. Void
End Function

' SRC\seedfill.c (194, 13)
' seedspreadLow()
' seedspreadLow(l_uint32 *, l_int32, l_int32, l_int32, l_uint32 *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="seedspreadLow")> _
Friend Shared Function seedspreadLow(datad as UInteger, w as Integer, h as Integer, wpld as Integer, datat as UInteger, wplt as Integer, connectivity as Integer) as Boolean ' Org. Void
End Function

' SRC\seedfill.c (198, 16)
' pixQualifyLocalMinima()
' pixQualifyLocalMinima(PIX *, PIX *, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This function acts in-place to remove all c.c. in pixm
'''  * that are not true local minima in pixs.  As seen in
'''  * pixLocalExtrema(), the input pixm are found by selecting those
'''  * pixels of pixs whose values do not change with a 3x3
'''  * grayscale erosion.  Here, we require that for each c.c.
'''  * in pixm, all pixels in pixs that correspond to the exterior
'''  * boundary pixels of the c.c. have values that are greater
'''  * than the value within the c.c.
'''  *   (2) The maximum allowed value for each local minimum can be
'''  * bounded with %maxval.  Use 0 for default, which is to have
'''  * no upper bound (equivalent to maxval == 254).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs  8 bpp image from which pixm has been extracted</param>
''' <param name="pixm"> \param[in]    pixm  1 bpp mask of values equal to min in 3x3 neighborhood</param>
''' <param name="maxval"> \param[in]    maxval max allowed for the min in a 3x3 neighborhood;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixQualifyLocalMinima")> _
Friend Shared Function pixQualifyLocalMinima(pixs as IntPTR, pixm as IntPTR, maxval as Integer) as Integer
End Function

' SRC\seedfill.c (243, 1)
' pixSeedfillBinary()
' pixSeedfillBinary(PIX *, PIX *, PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is for binary seedfill (aka "binary reconstruction").
'''  *   (2) There are 3 cases:
'''  *   (a) pixd == null (make a new pixd)
'''  *   (b) pixd == pixs (in-place)
'''  *   (c) pixd != pixs
'''  *   (3) If you know the case, use these patterns for clarity:
'''  *   (a) pixd = pixSeedfillBinary(NULL, pixs, ...);
'''  *   (b) pixSeedfillBinary(pixs, pixs, ...);
'''  *   (c) pixSeedfillBinary(pixd, pixs, ...);
'''  *   (4) The resulting pixd contains the filled seed.  For some
'''  * applications you want to OR it with the inverse of
'''  * the filling mask.
'''  *   (5) The input seed and mask images can be different sizes, but
'''  * in typical use the difference, if any, would be only
'''  * a few pixels in each direction.  If the sizes differ,
'''  * the clipping is handled by the low-level function
'''  * seedfillBinaryLow().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs  1 bpp seed</param>
''' <param name="pixm"> \param[in]    pixm  1 bpp filling mask</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfillBinary")> _
Friend Shared Function pixSeedfillBinary(pixd as IntPTR, pixs as IntPTR, pixm as IntPTR, connectivity as Integer) as IntPTR
End Function

' SRC\seedfill.c (330, 1)
' pixSeedfillBinaryRestricted()
' pixSeedfillBinaryRestricted(PIX *, PIX *, PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See usage for pixSeedfillBinary(), which has unrestricted fill.
'''  * In pixSeedfillBinary(), the filling distance is unrestricted
'''  * and can be larger than pixs, depending on the topology of
'''  * th mask.
'''  *   (2) There are occasions where it is useful not to permit the
'''  * fill to go more than a certain distance into the mask.
'''  * %xmax specifies the maximum horizontal distance allowed
'''  * in the fill; %ymax does likewise in the vertical direction.
'''  *   (3) Operationally, the max "distance" allowed for the fill
'''  * is a linear distance from the original seed, independent
'''  * of the actual mask topology.
'''  *   (4) Another formulation of this problem, not implemented,
'''  * would use the manhattan distance from the seed, as
'''  * determined by a breadth-first search starting at the seed
'''  * boundaries and working outward where the mask fg allows.
'''  * How this might use the constraints of separate xmax and ymax
'''  * is not clear.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd always</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs  1 bpp seed</param>
''' <param name="pixm"> \param[in]    pixm  1 bpp filling mask</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
''' <param name="xmax"> \param[in]    xmax max distance in x direction of fill into the mask</param>
''' <param name="ymax"> \param[in]    ymax max distance in y direction of fill into the mask</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfillBinaryRestricted")> _
Friend Shared Function pixSeedfillBinaryRestricted(pixd as IntPTR, pixs as IntPTR, pixm as IntPTR, connectivity as Integer, xmax as Integer, ymax as Integer) as IntPTR
End Function

' SRC\seedfill.c (605, 1)
' pixHolesByFilling()
' pixHolesByFilling(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *  (1) To get 4-c.c. holes of the 8-c.c. as foreground, use
'''  *   4-connected filling; to get 8-c.c. holes of the 4-c.c.
'''  *   as foreground, use 8-connected filling.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd  inverted image of all holes, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="connectivity"> \param[in]    connectivity 4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixHolesByFilling")> _
Friend Shared Function pixHolesByFilling(pixs as IntPTR, connectivity as Integer) as IntPTR
End Function

' SRC\seedfill.c (656, 1)
' pixFillClosedBorders()
' pixFillClosedBorders(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) Start with 1-pixel black border on otherwise white pixd
'''  *   (2) Subtract input pixs to remove border pixels that were
'''  * also on the closed border
'''  *   (3) Use the inverted pixs as the filling mask to fill in
'''  * all the pixels from the outer border to the closed border
'''  * on pixs
'''  *   (4) Invert the result to get the filled component, including
'''  * the input border
'''  *   (5) If the borders are 4-c.c., use 8-c.c. filling, and v.v.
'''  *   (6) Closed borders within c.c. that represent holes, etc., are filled.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd  all topologically outer closed borders are filled</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="connectivity"> \param[in]    connectivity filling connectivity 4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFillClosedBorders")> _
Friend Shared Function pixFillClosedBorders(pixs as IntPTR, connectivity as Integer) as IntPTR
End Function

' SRC\seedfill.c (694, 1)
' pixExtractBorderConnComps()
' pixExtractBorderConnComps(PIX *, l_int32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd  all pixels in the src that are in connected</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="connectivity"> \param[in]    connectivity filling connectivity 4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixExtractBorderConnComps")> _
Friend Shared Function pixExtractBorderConnComps(pixs as IntPTR, connectivity as Integer) as IntPTR
End Function

' SRC\seedfill.c (733, 1)
' pixRemoveBorderConnComps()
' pixRemoveBorderConnComps(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This removes all fg components touching the border.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd  all pixels in the src that are not touching the</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="connectivity"> \param[in]    connectivity filling connectivity 4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRemoveBorderConnComps")> _
Friend Shared Function pixRemoveBorderConnComps(pixs as IntPTR, connectivity as Integer) as IntPTR
End Function

' SRC\seedfill.c (783, 1)
' pixFillBgFromBorder()
' pixFillBgFromBorder(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This fills all bg components touching the border to fg.
'''  * It is the photometric inverse of pixRemoveBorderConnComps().
'''  *   (2) Invert the result to get the "holes" left after this fill.
'''  * This can be done multiple times, extracting holes within
'''  * holes after each pair of fillings.  Specifically, this code
'''  * peels away n successive embeddings of components:
'''  * \code
'''  *  pix1 = initial image>
'''  *  for (i = 0; i  2 * n; i++) {
'''  *    pix2 = pixFillBgFromBorder(pix1, 8);
'''  *    pixInvert(pix2, pix2);
'''  *    pixDestroy(&pix1);
'''  *    pix1 = pix2;
'''  *  }
'''  * \endcode
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd with the background c.c. touching the border</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="connectivity"> \param[in]    connectivity filling connectivity 4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFillBgFromBorder")> _
Friend Shared Function pixFillBgFromBorder(pixs as IntPTR, connectivity as Integer) as IntPTR
End Function

' SRC\seedfill.c (842, 1)
' pixFillHolesToBoundingRect()
' pixFillHolesToBoundingRect(PIX *, l_int32, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does not fill holes that are smaller in area than 'minsize'.
'''  *   (2) This does not fill holes with an area larger than
'''  * 'maxhfract' times the fg area of the c.c.
'''  *   (3) This does not expand the fg of the c.c. to bounding rect if
'''  * the fg area is less than 'minfgfract' times the area of the
'''  * bounding rect.
'''  *   (4) The decisions are made as follows:
'''  *  ~ Decide if we are filling the holes; if so, when using
'''  * the fg area, include the filled holes.
'''  *  ~ Decide based on the fg area if we are filling to a bounding rect.
'''  * If so, do it.
'''  * If not, fill the holes if the condition is satisfied.
'''  *   (5) The choice of minsize depends on the resolution.
'''  *   (6) For solidifying image mask regions on printed materials,
'''  * which tend to be rectangular, values for maxhfract
'''  * and minfgfract around 0.5 are reasonable.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd pixs, with some holes possibly filled and some c.c.</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="minsize"> \param[in]    minsize min number of pixels in the hole</param>
''' <param name="maxhfract"> \param[in]    maxhfract max hole area as fraction of fg pixels in the cc</param>
''' <param name="minfgfract"> \param[in]    minfgfract min fg area as fraction of bounding rectangle</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFillHolesToBoundingRect")> _
Friend Shared Function pixFillHolesToBoundingRect(pixs as IntPTR, minsize as Integer, maxhfract as single, minfgfract as single) as IntPTR
End Function

' SRC\seedfill.c (923, 1)
' pixSeedfillGray()
' pixSeedfillGray(PIX *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place filling operation on the seed, pixs,
'''  * where the clipping mask is always above or at the level
'''  * of the seed as it is filled.
'''  *   (2) For details of the operation, see the description in
'''  * seedfillGrayLow() and the code there.
'''  *   (3) As an example of use, see the description in pixHDome().
'''  * There, the seed is an image where each pixel is a fixed
'''  * amount smaller than the corresponding mask pixel.
'''  *   (4) Reference paper :
'''  *   L. Vincent, Morphological grayscale reconstruction in image
'''  *   analysis: applications and efficient algorithms, IEEE Transactions
'''  *   on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs  8 bpp seed; filled in place</param>
''' <param name="pixm"> \param[in]    pixm  8 bpp filling mask</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfillGray")> _
Friend Shared Function pixSeedfillGray(pixs as IntPTR, pixm as IntPTR, connectivity as Integer) as Integer
End Function

' SRC\seedfill.c (982, 1)
' pixSeedfillGrayInv()
' pixSeedfillGrayInv(PIX *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place filling operation on the seed, pixs,
'''  * where the clipping mask is always below or at the level
'''  * of the seed as it is filled.  Think of filling up a basin
'''  * to a particular level, given by the maximum seed value
'''  * in the basin.  Outside the filled region, the mask
'''  * is above the filling level.
'''  *   (2) Contrast this with pixSeedfillGray(), where the clipping mask
'''  * is always above or at the level of the fill.  An example
'''  * of its use is the hdome fill, where the seed is an image
'''  * where each pixel is a fixed amount smaller than the
'''  * corresponding mask pixel.
'''  *   (3) The basin fill, pixSeedfillGrayBasin(), is a special case
'''  * where the seed pixel values are generated from the mask,
'''  * and where the implementation uses pixSeedfillGray() by
'''  * inverting both the seed and mask.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs  8 bpp seed; filled in place</param>
''' <param name="pixm"> \param[in]    pixm  8 bpp filling mask</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfillGrayInv")> _
Friend Shared Function pixSeedfillGrayInv(pixs as IntPTR, pixm as IntPTR, connectivity as Integer) as Integer
End Function

' SRC\seedfill.c (1969, 1)
' pixSeedfillGraySimple()
' pixSeedfillGraySimple(PIX *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place filling operation on the seed, pixs,
'''  * where the clipping mask is always above or at the level
'''  * of the seed as it is filled.
'''  *   (2) For details of the operation, see the description in
'''  * seedfillGrayLowSimple() and the code there.
'''  *   (3) As an example of use, see the description in pixHDome().
'''  * There, the seed is an image where each pixel is a fixed
'''  * amount smaller than the corresponding mask pixel.
'''  *   (4) Reference paper :
'''  *   L. Vincent, Morphological grayscale reconstruction in image
'''  *   analysis: applications and efficient algorithms, IEEE Transactions
'''  *   on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs  8 bpp seed; filled in place</param>
''' <param name="pixm"> \param[in]    pixm  8 bpp filling mask</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfillGraySimple")> _
Friend Shared Function pixSeedfillGraySimple(pixs as IntPTR, pixm as IntPTR, connectivity as Integer) as Integer
End Function

' SRC\seedfill.c (2040, 1)
' pixSeedfillGrayInvSimple()
' pixSeedfillGrayInvSimple(PIX *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place filling operation on the seed, pixs,
'''  * where the clipping mask is always below or at the level
'''  * of the seed as it is filled.  Think of filling up a basin
'''  * to a particular level, given by the maximum seed value
'''  * in the basin.  Outside the filled region, the mask
'''  * is above the filling level.
'''  *   (2) Contrast this with pixSeedfillGraySimple(), where the clipping mask
'''  * is always above or at the level of the fill.  An example
'''  * of its use is the hdome fill, where the seed is an image
'''  * where each pixel is a fixed amount smaller than the
'''  * corresponding mask pixel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs  8 bpp seed; filled in place</param>
''' <param name="pixm"> \param[in]    pixm  8 bpp filling mask</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfillGrayInvSimple")> _
Friend Shared Function pixSeedfillGrayInvSimple(pixs as IntPTR, pixm as IntPTR, connectivity as Integer) as Integer
End Function

' SRC\seedfill.c (2442, 1)
' pixSeedfillGrayBasin()
' pixSeedfillGrayBasin(PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This fills from a seed within basins defined by a filling mask.
'''  * The seed value(s) are greater than the corresponding
'''  * filling mask value, and the result has the bottoms of
'''  * the basins raised by the initial seed value.
'''  *   (2) The seed has value 255 except where pixb has fg (1), which
'''  * are the seed 'locations'.  At the seed locations, the seed
'''  * value is the corresponding value of the mask pixel in pixm
'''  * plus %delta.  If %delta == 0, we return a copy of pixm.
'''  *   (3) The actual filling is done using the standard grayscale filling
'''  * operation on the inverse of the mask and using the inverse
'''  * of the seed image.  After filling, we return the inverse of
'''  * the filled seed.
'''  *   (4) As an example of use: pixm can describe a grayscale image
'''  * of text, where the (dark) text pixels are basins of
'''  * low values; pixb can identify the local minima in pixm (say, at
'''  * the bottom of the basins); and delta is the amount that we wish
'''  * to raise (lighten) the basins.  We construct the seed
'''  * (a.k.a marker) image from pixb, pixm and %delta.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd filled seed if OK, NULL on error</returns>
''' <param name="pixb"> \param[in]    pixb  binary mask giving seed locations</param>
''' <param name="pixm"> \param[in]    pixm  8 bpp basin-type filling mask</param>
''' <param name="delta"> \param[in]    delta amount of seed value above mask</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedfillGrayBasin")> _
Friend Shared Function pixSeedfillGrayBasin(pixb as IntPTR, pixm as IntPTR, delta as Integer, connectivity as Integer) as IntPTR
End Function

' SRC\seedfill.c (2533, 1)
' pixDistanceFunction()
' pixDistanceFunction(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This computes the distance of each pixel from the nearest
'''  * background pixel.  All bg pixels therefore have a distance of 0,
'''  * and the fg pixel distances increase linearly from 1 at the
'''  * boundary.  It can also be used to compute the distance of
'''  * each pixel from the nearest fg pixel, by inverting the input
'''  * image before calling this function.  Then all fg pixels have
'''  * a distance 0 and the bg pixel distances increase linearly
'''  * from 1 at the boundary.
'''  *   (2) The algorithm, described in Leptonica on the page on seed
'''  * filling and connected components, is due to Luc Vincent.
'''  * In brief, we generate an 8 or 16 bpp image, initialized
'''  * with the fg pixels of the input pix set to 1 and the
'''  * 1-boundary pixels (i.e., the boundary pixels of width 1 on
'''  * the four sides set as either:
'''  *   * L_BOUNDARY_BG: 0
'''  *   * L_BOUNDARY_FG:  max
'''  * where max = 0xff for 8 bpp and 0xffff for 16 bpp.
'''  * Then do raster/anti-raster sweeps over all pixels interior
'''  * to the 1-boundary, where the value of each new pixel is
'''  * taken to be 1 more than the minimum of the previously-seen
'''  * connected pixels (using either 4 or 8 connectivity).
'''  * Finally, set the 1-boundary pixels using the mirrored method;
'''  * this removes the max values there.
'''  *   (3) Using L_BOUNDARY_BG clamps the distance to 0 at the
'''  * boundary.  Using L_BOUNDARY_FG allows the distance
'''  * at the image boundary to "float".
'''  *   (4) For 4-connected, one could initialize only the left and top
'''  * 1-boundary pixels, and go all the way to the right
'''  * and bottom; then coming back reset left and top.  But we
'''  * instead use a method that works for both 4- and 8-connected.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  1 bpp source</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
''' <param name="outdepth"> \param[in]    outdepth 8 or 16 bits for pixd</param>
''' <param name="boundcond"> \param[in]    boundcond L_BOUNDARY_BG, L_BOUNDARY_FG</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDistanceFunction")> _
Friend Shared Function pixDistanceFunction(pixs as IntPTR, connectivity as Integer, outdepth as Integer, boundcond as Integer) as IntPTR
End Function

' SRC\seedfill.c (2791, 1)
' pixSeedspread()
' pixSeedspread(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The raster/anti-raster method for implementing this filling
'''  * operation was suggested by Ray Smith.
'''  *   (2) This takes an arbitrary set of nonzero pixels in pixs, which
'''  * can be sparse, and spreads (extrapolates) the values to
'''  * fill all the pixels in pixd with the nonzero value it is
'''  * closest to in pixs.  This is similar (though not completely
'''  * equivalent) to doing a Voronoi tiling of the image, with a
'''  * tile surrounding each pixel that has a nonzero value.
'''  * All pixels within a tile are then closer to its "central"
'''  * pixel than to any others.  Then assign the value of the
'''  * "central" pixel to each pixel in the tile.
'''  *   (3) This is implemented by computing a distance function in parallel
'''  * with the fill.  The distance function uses free boundary
'''  * conditions (assumed maxval outside), and it controls the
'''  * propagation of the pixels in pixd away from the nonzero
'''  * (seed) values.  This is done in 2 traversals (raster/antiraster).
'''  * In the raster direction, whenever the distance function
'''  * is nonzero, the spread pixel takes on the value of its
'''  * predecessor that has the minimum distance value.  In the
'''  * antiraster direction, whenever the distance function is nonzero
'''  * and its value is replaced by a smaller value, the spread
'''  * pixel takes the value of the predecessor with the minimum
'''  * distance value.
'''  *   (4) At boundaries where a pixel is equidistant from two
'''  * nearest nonzero (seed) pixels, the decision of which value
'''  * to use is arbitrary (greedy in search for minimum distance).
'''  * This can give rise to strange-looking results, particularly
'''  * for 4-connectivity where the L1 distance is computed from
'''  * steps in N,S,E and W directions (no diagonals).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  8 bpp source</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSeedspread")> _
Friend Shared Function pixSeedspread(pixs as IntPTR, connectivity as Integer) as IntPTR
End Function

' SRC\seedfill.c (3018, 1)
' pixLocalExtrema()
' pixLocalExtrema(PIX *, l_int32, l_int32, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This gives the actual local minima and maxima.
'''  * A local minimum is a pixel whose surrounding pixels all
'''  * have values at least as large, and likewise for a local
'''  * maximum.  For the local minima, %maxmin is the upper
'''  * bound for the value of pixs.  Likewise, for the local maxima,
'''  * %minmax is the lower bound for the value of pixs.
'''  *   (2) The minima are found by starting with the erosion-and-equality
'''  * approach of pixSelectedLocalExtrema().  This is followed
'''  * by a qualification step, where each c.c. in the resulting
'''  * minimum mask is extracted, the pixels bordering it are
'''  * located, and they are queried.  If all of those pixels
'''  * are larger than the value of that minimum, it is a true
'''  * minimum and its c.c. is saved; otherwise the c.c. is
'''  * rejected.  Note that if a bordering pixel has the
'''  * same value as the minimum, it must then have a
'''  * neighbor that is smaller, so the component is not a
'''  * true minimum.
'''  *   (3) The maxima are found by inverting the image and looking
'''  * for the minima there.
'''  *   (4) The generated masks can be used as markers for
'''  * further operations.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs  8 bpp</param>
''' <param name="maxmin"> \param[in]    maxmin max allowed for the min in a 3x3 neighborhood;</param>
''' <param name="minmax"> \param[in]    minmax min allowed for the max in a 3x3 neighborhood;</param>
''' <param name="ppixmin"> \param[out]   ppixmin [optional] mask of local minima</param>
''' <param name="ppixmax"> \param[out]   ppixmax [optional] mask of local maxima</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixLocalExtrema")> _
Friend Shared Function pixLocalExtrema(pixs as IntPTR, maxmin as Integer, minmax as Integer, ppixmin as Object, ppixmax as Object) as Integer
End Function

' SRC\seedfill.c (3190, 1)
' pixSelectedLocalExtrema()
' pixSelectedLocalExtrema(PIX *, l_int32, PIX **, PIX **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This selects those local 3x3 minima that are at least a
'''  * specified distance from the nearest local 3x3 maxima, and v.v.
'''  * for the selected set of local 3x3 maxima.
'''  * The local 3x3 minima is the set of pixels whose value equals
'''  * the value after a 3x3 brick erosion, and the local 3x3 maxima
'''  * is the set of pixels whose value equals the value after
'''  * a 3x3 brick dilation.
'''  *   (2) mindist is the minimum distance allowed between
'''  * local 3x3 minima and local 3x3 maxima, in an 8-connected sense.
'''  * mindist == 1 keeps all pixels found in step 1.
'''  * mindist == 0 removes all pixels from each mask that are
'''  * both a local 3x3 minimum and a local 3x3 maximum.
'''  * mindist == 1 removes any local 3x3 minimum pixel that touches a
'''  * local 3x3 maximum pixel, and likewise for the local maxima.
'''  * To make the decision, visualize each local 3x3 minimum pixel
'''  * as being surrounded by a square of size (2 * mindist + 1)
'''  * on each side, such that no local 3x3 maximum pixel is within
'''  * that square; and v.v.
'''  *   (3) The generated masks can be used as markers for further operations.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs  8 bpp</param>
''' <param name="mindist"> \param[in]    mindist -1 for keeping all pixels; >= 0 specifies distance</param>
''' <param name="ppixmin"> \param[out]   ppixmin mask of local minima</param>
''' <param name="ppixmax"> \param[out]   ppixmax mask of local maxima</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSelectedLocalExtrema")> _
Friend Shared Function pixSelectedLocalExtrema(pixs as IntPTR, mindist as Integer, ppixmin as Object, ppixmax as Object) as Integer
End Function

' SRC\seedfill.c (3250, 1)
' pixFindEqualValues()
' pixFindEqualValues(PIX *, PIX *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) The two images are aligned at the UL corner, and the returned
'''  * image has ON pixels where the pixels in pixs1 and pixs2
'''  * have equal values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 1 bpp mask, or NULL on error</returns>
''' <param name="pixs1"> \param[in]    pixs1 8 bpp</param>
''' <param name="pixs2"> \param[in]    pixs2 8 bpp</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindEqualValues")> _
Friend Shared Function pixFindEqualValues(pixs1 as IntPTR, pixs2 as IntPTR) as IntPTR
End Function

' SRC\seedfill.c (3317, 1)
' pixSelectMinInConnComp()
' pixSelectMinInConnComp(PIX *, PIX *, PTA **, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For each 8 connected component in pixm, this finds
'''  * a pixel in pixs that has the lowest value, and saves
'''  * it in a Pta.  If several pixels in pixs have the same
'''  * minimum value, it picks the first one found.
'''  *   (2) For a mask pixm of true local minima, all pixels in each
'''  * connected component have the same value in pixs, so it is
'''  * fastest to select one of them using a special seedfill
'''  * operation.  Not yet implemented.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp</param>
''' <param name="pixm"> \param[in]    pixm 1 bpp</param>
''' <param name="ppta"> \param[out]   ppta pta of min pixel locations</param>
''' <param name="pnav"> \param[out]   pnav [optional] numa of minima values</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSelectMinInConnComp")> _
Friend Shared Function pixSelectMinInConnComp(pixs as IntPTR, pixm as IntPTR, ppta as Object, pnav as Object) as Integer
End Function

' SRC\seedfill.c (3430, 1)
' pixRemoveSeededComponents()
' pixRemoveSeededComponents(PIX *, PIX *, PIX *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This removes each component in pixm for which there is
'''  * at least one seed in pixs.  If pixd == NULL, this returns
'''  * the result in a new pixd.  Otherwise, it is an in-place
'''  * operation on pixm.  In no situation is pixs altered,
'''  * because we do the filling with a copy of pixs.
'''  *   (2) If bordersize > 0, it also clears all pixels within a
'''  * distance %bordersize of the edge of pixd.  This is here
'''  * because pixLocalExtrema() typically finds local minima
'''  * at the border.  Use %bordersize >= 2 to remove these.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd  [optional]; this can be null or equal to pixm; 1 bpp</param>
''' <param name="pixs"> \param[in]    pixs  1 bpp seed</param>
''' <param name="pixm"> \param[in]    pixm  1 bpp filling mask</param>
''' <param name="connectivity"> \param[in]    connectivity  4 or 8</param>
''' <param name="bordersize"> \param[in]    bordersize amount of border clearing</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRemoveSeededComponents")> _
Friend Shared Function pixRemoveSeededComponents(pixd as IntPTR, pixs as IntPTR, pixm as IntPTR, connectivity as Integer, bordersize as Integer) as IntPTR
End Function

#End Region
#Region "SRC\sel1.c"
' SRC\sel1.c (149, 16)
' selaExtendArray()
' selaExtendArray(SELA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="sela"> \param[in]    sela</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaExtendArray")> _
Friend Shared Function selaExtendArray(sela as IntPTR) as Integer
End Function

' SRC\sel1.c (150, 13)
' selCreateFromSArray()
' selCreateFromSArray(SARRAY *, l_int32, l_int32) as SEL *
''' <summary>
''' * Notes:
'''  *   (1) The Sel contains the following lines:
'''  * ~ The first line is the selname
'''  * ~ The remaining lines contain the Sel data.  They must
'''  *   be formatted similarly to the string format in
'''  *   selCreateFromString(), with each line beginning and
'''  *   ending with a double-quote, and showing the 2D layout.
'''  * ~ 'last' gives the last line in the Sel data.
'''  *   (2) See selCreateFromString() for a description of the string
'''  * format for the Sel data.  As an example, here are the lines
'''  * of is a valid file for a single Sel.  In the file, all lines
'''  * are left-justified:
'''  *  # diagonal sel
'''  *  sel_5diag
'''  *  "x "
'''  *  " x   "
'''  *  "  X  "
'''  *  "   x "
'''  *  " x"
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela, or NULL on error</returns>
''' <param name="sa"> \param[in]    sa</param>
''' <param name="first"> \param[in]    first line of sarray where Sel begins</param>
''' <param name="last"> \param[in]    last line of sarray where Sel ends</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selCreateFromSArray")> _
Friend Shared Function selCreateFromSArray(sa as IntPTR, first as Integer, last as Integer) as IntPTR
End Function

' SRC\sel1.c (239, 1)
' selaCreate()
' selaCreate(l_int32) as SELA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela, or NULL on error</returns>
''' <param name="n"> \param[in]    n initial number of sel ptrs; use 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaCreate")> _
Friend Shared Function selaCreate(n as Integer) as IntPTR
End Function

' SRC\sel1.c (272, 1)
' selaDestroy()
' selaDestroy(SELA **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="psela"> \param[in,out]   psela to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaDestroy")> _
Friend Shared Function selaDestroy(psela as Object) as Boolean ' Org. Void
End Function

' SRC\sel1.c (306, 1)
' selCreate()
' selCreate(l_int32, l_int32, const char *) as SEL *
''' <summary>
''' * Notes:
'''  *   (1) selCreate() initializes all values to 0.
'''  *   (2) After this call, (cy,cx) and nonzero data values must be
'''  * assigned.  If a text name is not assigned here, it will
'''  * be needed later when the sel is put into a sela.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel, or NULL on error</returns>
''' <param name="height"> \param[in]    height, width</param>
''' <param name="width"> \param[in]    name [optional] sel name; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selCreate")> _
Friend Shared Function selCreate(height as Integer, width as Integer, name as String) as IntPTR
End Function

' SRC\sel1.c (337, 1)
' selDestroy()
' selDestroy(SEL **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="psel"> \param[in,out]   psel to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selDestroy")> _
Friend Shared Function selDestroy(psel as Object) as Boolean ' Org. Void
End Function

' SRC\sel1.c (370, 1)
' selCopy()
' selCopy(SEL *) as SEL *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  a copy of the sel, or NULL on error</returns>
''' <param name="sel"> \param[in]    sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selCopy")> _
Friend Shared Function selCopy(sel as IntPTR) as IntPTR
End Function

' SRC\sel1.c (418, 1)
' selCreateBrick()
' selCreateBrick(l_int32, l_int32, l_int32, l_int32, l_int32) as SEL *
''' <summary>
''' * Notes:
'''  *   (1) This is a rectangular sel of all hits, misses or don't cares.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel, or NULL on error</returns>
''' <param name="h"> \param[in]    h, w    height, width</param>
''' <param name="w"> \param[in]    cy, cx  origin, relative to UL corner at 0,0</param>
''' <param name="cy"> \param[in]    type    SEL_HIT, SEL_MISS, or SEL_DONT_CARE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selCreateBrick")> _
Friend Shared Function selCreateBrick(h as Integer, w as Integer, cy as Integer, cx as Integer, type as Integer) as IntPTR
End Function

' SRC\sel1.c (462, 1)
' selCreateComb()
' selCreateComb(l_int32, l_int32, l_int32) as SEL *
''' <summary>
''' * Notes:
'''  *   (1) This generates a comb Sel of hits with the origin as
'''  * near the center as possible.
'''  *   (2) In use, this is complemented by a brick sel of size %factor1,
'''  * Both brick and comb sels are made by selectComposableSels().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel, or NULL on error</returns>
''' <param name="factor1"> \param[in]    factor1 contiguous space between comb tines</param>
''' <param name="factor2"> \param[in]    factor2 number of comb tines</param>
''' <param name="direction"> \param[in]    direction L_HORIZ, L_VERT</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selCreateComb")> _
Friend Shared Function selCreateComb(factor1 as Integer, factor2 as Integer, direction as Integer) as IntPTR
End Function

' SRC\sel1.c (515, 1)
' create2dIntArray()
' create2dIntArray(l_int32, l_int32) as l_int32 **
''' <summary>
''' * Notes:
'''  *   (1) The array[sy][sx] is indexed in standard "matrix notation",
'''  * with the row index first.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  doubly indexed array i.e., an array of sy row pointers,</returns>
''' <param name="sy"> \param[in]    sy rows == height</param>
''' <param name="sx"> \param[in]    sx columns == width</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="create2dIntArray")> _
Friend Shared Function create2dIntArray(sy as Integer, sx as Integer) as String
End Function

' SRC\sel1.c (566, 1)
' selaAddSel()
' selaAddSel(SELA *, SEL *, const char *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This adds a sel, either inserting or making a copy.
'''  *   (2) Because every sel in a sela must have a name, it copies
'''  * the input name if necessary.  You can input NULL for
'''  * selname if the sel already has a name.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="sela"> \param[in]    sela</param>
''' <param name="sel"> \param[in]    sel to be added</param>
''' <param name="selname"> \param[in]    selname ignored if already defined in sel;</param>
''' <param name="copyflag"> \param[in]    copyflag  L_INSERT or L_COPY</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaAddSel")> _
Friend Shared Function selaAddSel(sela as IntPTR, sel as IntPTR, selname as String, copyflag as Integer) as Integer
End Function

' SRC\sel1.c (639, 1)
' selaGetCount()
' selaGetCount(SELA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 on error</returns>
''' <param name="sela"> \param[in]    sela</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaGetCount")> _
Friend Shared Function selaGetCount(sela as IntPTR) as Integer
End Function

' SRC\sel1.c (664, 1)
' selaGetSel()
' selaGetSel(SELA *, l_int32) as SEL *
''' <summary>
''' * Notes:
'''  *   (1) This returns a ptr to the sel, not a copy, so the caller
'''  * must not destroy it!
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel, or NULL on error</returns>
''' <param name="sela"> \param[in]    sela</param>
''' <param name="i"> \param[in]    i index of sel to be retrieved not copied</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaGetSel")> _
Friend Shared Function selaGetSel(sela as IntPTR, i as Integer) as IntPTR
End Function

' SRC\sel1.c (685, 1)
' selGetName()
' selGetName(SEL *) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel name not copied, or NULL if no name or on error</returns>
''' <param name="sel"> \param[in]    sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selGetName")> _
Friend Shared Function selGetName(sel as IntPTR) as String
End Function

' SRC\sel1.c (710, 1)
' selSetName()
' selSetName(SEL *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Always frees the existing sel name, if defined.
'''  *   (2) If name is not defined, just clears any existing sel name.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sel"> \param[in]    sel</param>
''' <param name="name"> \param[in]    name [optional]; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selSetName")> _
Friend Shared Function selSetName(sel as IntPTR, name as String) as Integer
End Function

' SRC\sel1.c (732, 1)
' selaFindSelByName()
' selaFindSelByName(SELA *, const char *, l_int32 *, SEL **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="sela"> \param[in]    sela</param>
''' <param name="name"> \param[in]    name sel name</param>
''' <param name="pindex"> \param[out]   pindex [optional]</param>
''' <param name="psel"> \param[in]    psel   [optional] sel (not a copy)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaFindSelByName")> _
Friend Shared Function selaFindSelByName(sela as IntPTR, name as String, pindex as Integer, psel as Object) as Integer
End Function

' SRC\sel1.c (781, 1)
' selGetElement()
' selGetElement(SEL *, l_int32, l_int32, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="sel"> \param[in]    sel</param>
''' <param name="row"> \param[in]    row</param>
''' <param name="col"> \param[in]    col</param>
''' <param name="ptype"> \param[out]   ptype  SEL_HIT, SEL_MISS, SEL_DONT_CARE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selGetElement")> _
Friend Shared Function selGetElement(sel as IntPTR, row as Integer, col as Integer, ptype as Integer) as Integer
End Function

' SRC\sel1.c (821, 1)
' selSetElement()
' selSetElement(SEL *, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Because we use row and column to index into an array,
'''  * they are always non-negative.  The location of the origin
'''  * (and the type of operation) determine the actual
'''  * direction of the rasterop.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="sel"> \param[in]    sel</param>
''' <param name="row"> \param[in]    row</param>
''' <param name="col"> \param[in]    col</param>
''' <param name="type"> \param[in]    type  SEL_HIT, SEL_MISS, SEL_DONT_CARE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selSetElement")> _
Friend Shared Function selSetElement(sel as IntPTR, row as Integer, col as Integer, type as Integer) as Integer
End Function

' SRC\sel1.c (850, 1)
' selGetParameters()
' selGetParameters(SEL *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sel"> \param[in]    sel</param>
''' <param name="psy"> \param[out]   psy, psx, pcy, pcx [optional]  each can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selGetParameters")> _
Friend Shared Function selGetParameters(sel as IntPTR, psy as Integer, psx as Integer, pcy as Integer, pcx as Integer) as Integer
End Function

' SRC\sel1.c (880, 1)
' selSetOrigin()
' selSetOrigin(SEL *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="sel"> \param[in]    sel</param>
''' <param name="cy"> \param[in]    cy, cx</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selSetOrigin")> _
Friend Shared Function selSetOrigin(sel as IntPTR, cy as Integer, cx as Integer) as Integer
End Function

' SRC\sel1.c (902, 1)
' selGetTypeAtOrigin()
' selGetTypeAtOrigin(SEL *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error or if origin is not found</returns>
''' <param name="sel"> \param[in]    sel</param>
''' <param name="ptype"> \param[out]   ptype  SEL_HIT, SEL_MISS, SEL_DONT_CARE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selGetTypeAtOrigin")> _
Friend Shared Function selGetTypeAtOrigin(sel as IntPTR, ptype as Integer) as Integer
End Function

' SRC\sel1.c (937, 1)
' selaGetBrickName()
' selaGetBrickName(SELA *, l_int32, l_int32) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel name new string, or NULL if no name or on error</returns>
''' <param name="sela"> \param[in]    sela</param>
''' <param name="hsize"> \param[in]    hsize, vsize of brick sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaGetBrickName")> _
Friend Shared Function selaGetBrickName(sela as IntPTR, hsize as Integer, vsize as Integer) as String
End Function

' SRC\sel1.c (976, 1)
' selaGetCombName()
' selaGetCombName(SELA *, l_int32, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) Combs are by definition 1-dimensional, either horiz or vert.
'''  *   (2) Use this with comb Sels; e.g., from selaAddDwaCombs().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel name new string, or NULL if name not found or on error</returns>
''' <param name="sela"> \param[in]    sela</param>
''' <param name="size"> \param[in]    size the product of sizes of the brick and comb parts</param>
''' <param name="direction"> \param[in]    direction L_HORIZ, L_VERT</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaGetCombName")> _
Friend Shared Function selaGetCombName(sela as IntPTR, size as Integer, direction as Integer) as String
End Function

' SRC\sel1.c (1104, 1)
' getCompositeParameters()
' getCompositeParameters(l_int32, l_int32 *, l_int32 *, char **, char **, char **, char **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This uses the big lookup table at the top of this file.
'''  *   (2) All returned strings are copies that must be freed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="size"> \param[in]    size</param>
''' <param name="psize1"> \param[out]   psize1 [optional] brick factor size</param>
''' <param name="psize2"> \param[out]   psize2 [optional] comb factor size</param>
''' <param name="pnameh1"> \param[out]   pnameh1 [optional] name of horiz brick</param>
''' <param name="pnameh2"> \param[out]   pnameh2 [optional] name of horiz comb</param>
''' <param name="pnamev1"> \param[out]   pnamev1 [optional] name of vert brick</param>
''' <param name="pnamev2"> \param[out]   pnamev2 [optional] name of vert comb</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getCompositeParameters")> _
Friend Shared Function getCompositeParameters(size as Integer, psize1 as Integer, psize2 as Integer, pnameh1 as String, pnameh2 as String, pnamev1 as String, pnamev2 as String) as Integer
End Function

' SRC\sel1.c (1148, 1)
' selaGetSelnames()
' selaGetSelnames(SELA *) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sa of all sel names, or NULL on error</returns>
''' <param name="sela"> \param[in]    sela</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaGetSelnames")> _
Friend Shared Function selaGetSelnames(sela as IntPTR) as IntPTR
End Function

' SRC\sel1.c (1193, 1)
' selFindMaxTranslations()
' selFindMaxTranslations(SEL *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  These are the maximum shifts for the erosion operation.
'''  *  For example, when j  cx, the shift of the image
'''  *  is +x to the cx.  This is a positive xp shift.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="sel"> \param[in]    sel</param>
''' <param name="pxp"> \param[out]   pxp, pyp, pxn, pyn  max shifts</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selFindMaxTranslations")> _
Friend Shared Function selFindMaxTranslations(sel as IntPTR, pxp as Integer, pyp as Integer, pxn as Integer, pyn as Integer) as Integer
End Function

' SRC\sel1.c (1243, 1)
' selRotateOrth()
' selRotateOrth(SEL *, l_int32) as SEL *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  seld, or NULL on error</returns>
''' <param name="sel"> \param[in]    sel</param>
''' <param name="quads"> \param[in]    quads 0 - 4; number of 90 degree cw rotations</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selRotateOrth")> _
Friend Shared Function selRotateOrth(sel as IntPTR, quads as Integer) as IntPTR
End Function

' SRC\sel1.c (1310, 1)
' selaRead()
' selaRead(const char *) as SELA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela, or NULL on error</returns>
''' <param name="fname"> \param[in]    fname filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaRead")> _
Friend Shared Function selaRead(fname as String) as IntPTR
End Function

' SRC\sel1.c (1339, 1)
' selaReadStream()
' selaReadStream(FILE *) as SELA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaReadStream")> _
Friend Shared Function selaReadStream(fp as Object) as IntPTR
End Function

' SRC\sel1.c (1380, 1)
' selRead()
' selRead(const char *) as SEL *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel, or NULL on error</returns>
''' <param name="fname"> \param[in]    fname filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selRead")> _
Friend Shared Function selRead(fname as String) as IntPTR
End Function

' SRC\sel1.c (1409, 1)
' selReadStream()
' selReadStream(FILE *) as SEL *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selReadStream")> _
Friend Shared Function selReadStream(fp as Object) as IntPTR
End Function

' SRC\sel1.c (1464, 1)
' selaWrite()
' selaWrite(const char *, SELA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fname"> \param[in]    fname filename</param>
''' <param name="sela"> \param[in]    sela</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaWrite")> _
Friend Shared Function selaWrite(fname as String, sela as IntPTR) as Integer
End Function

' SRC\sel1.c (1493, 1)
' selaWriteStream()
' selaWriteStream(FILE *, SELA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="sela"> \param[in]    sela</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaWriteStream")> _
Friend Shared Function selaWriteStream(fp as Object, sela as IntPTR) as Integer
End Function

' SRC\sel1.c (1526, 1)
' selWrite()
' selWrite(const char *, SEL *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fname"> \param[in]    fname filename</param>
''' <param name="sel"> \param[in]    sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selWrite")> _
Friend Shared Function selWrite(fname as String, sel as IntPTR) as Integer
End Function

' SRC\sel1.c (1555, 1)
' selWriteStream()
' selWriteStream(FILE *, SEL *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="sel"> \param[in]    sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selWriteStream")> _
Friend Shared Function selWriteStream(fp as Object, sel as IntPTR) as Integer
End Function

' SRC\sel1.c (1616, 1)
' selCreateFromString()
' selCreateFromString(const char *, l_int32, l_int32, const char *) as SEL *
''' <summary>
''' * Notes:
'''  *   (1) The text is an array of chars (in row-major order) where
'''  * each char can be one of the following:
'''  * 'x': hit
'''  * 'o': miss
'''  * ' ': don't-care
'''  *   (2) When the origin falls on a hit or miss, use an upper case
'''  * char (e.g., 'X' or 'O') to indicate it.  When the origin
'''  * falls on a don't-care, indicate this with a 'C'.
'''  * The string must have exactly one origin specified.
'''  *   (3) The advantage of this method is that the text can be input
'''  * in a format that shows the 2D layout of the Sel; e.g.,
'''  * \code
'''  *  static const char *seltext = "x "
'''  *    "x Oo "
'''  *    "x "
'''  *    "xxxxx";
'''  * \endcode
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel of the given size, or NULL on error</returns>
''' <param name="text"> \param[in]    text</param>
''' <param name="h"> \param[in]    h, w  height, width</param>
''' <param name="w"> \param[in]    name  [optional] sel name; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selCreateFromString")> _
Friend Shared Function selCreateFromString(text as String, h as Integer, w as Integer, name as String) as IntPTR
End Function

' SRC\sel1.c (1704, 1)
' selPrintToString()
' selPrintToString(SEL *) as char *
''' <summary>
''' * Notes:
'''  *   (1) This is an inverse function of selCreateFromString.
'''  * It prints a textual representation of the SEL to a malloc'd
'''  * string.  The format is the same as selCreateFromString
'''  * except that newlines are inserted into the output
'''  * between rows.
'''  *   (2) This is useful for debugging.  However, if you want to
'''  * save some Sels in a file, put them in a Sela and write
'''  * them out with selaWrite().  They can then be read in
'''  * with selaRead().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  str string; caller must free</returns>
''' <param name="sel"> \param[in]    sel</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selPrintToString")> _
Friend Shared Function selPrintToString(sel as IntPTR) as String
End Function

' SRC\sel1.c (1779, 1)
' selaCreateFromFile()
' selaCreateFromFile(const char *) as SELA *
''' <summary>
''' * Notes:
'''  *   (1) The file contains a sequence of Sel descriptions.
'''  *   (2) Each Sel is formatted as follows:
'''  *  ~ Any number of comment lines starting with '#' are ignored
'''  *  ~ The next line contains the selname
'''  *  ~ The next lines contain the Sel data.  They must be
'''  * formatted similarly to the string format in
'''  * selCreateFromString(), with each line beginning and
'''  * ending with a double-quote, and showing the 2D layout.
'''  *  ~ Each Sel ends when a blank line, a comment line, or
'''  * the end of file is reached.
'''  *   (3) See selCreateFromString() for a description of the string
'''  * format for the Sel data.  As an example, here are the lines
'''  * of is a valid file for a single Sel.  In the file, all lines
'''  * are left-justified:
'''  *  # diagonal sel
'''  *  sel_5diag
'''  *  "x "
'''  *  " x   "
'''  *  "  X  "
'''  *  "   x "
'''  *  " x"
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaCreateFromFile")> _
Friend Shared Function selaCreateFromFile(filename as String) as IntPTR
End Function

' SRC\sel1.c (1959, 1)
' selCreateFromPta()
' selCreateFromPta(PTA *, l_int32, l_int32, const char *) as SEL *
''' <summary>
''' * Notes:
'''  *   (1) The origin and all points in the pta must be positive.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel of minimum required size, or NULL on error</returns>
''' <param name="pta"> \param[in]    pta</param>
''' <param name="cy"> \param[in]    cy, cx origin of sel</param>
''' <param name="cx"> \param[in]    name [optional] sel name; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selCreateFromPta")> _
Friend Shared Function selCreateFromPta(pta as IntPTR, cy as Integer, cx as Integer, name as String) as IntPTR
End Function

' SRC\sel1.c (2009, 1)
' selCreateFromPix()
' selCreateFromPix(PIX *, l_int32, l_int32, const char *) as SEL *
''' <summary>
''' * Notes:
'''  *   (1) The origin must be positive.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel, or NULL on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="cy"> \param[in]    cy, cx origin of sel</param>
''' <param name="cx"> \param[in]    name [optional] sel name; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selCreateFromPix")> _
Friend Shared Function selCreateFromPix(pix as IntPTR, cy as Integer, cx as Integer, name as String) as IntPTR
End Function

' SRC\sel1.c (2060, 1)
' 
' selReadFromColorImage(const char *) as SEL *
''' <summary>
''' * Notes:
'''  *   (1) Loads an image from a file and creates a (hit-miss) sel.
'''  *   (2) The sel name is taken from the pathname without the directory
'''  * and extension.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel if OK; NULL on error</returns>
''' <param name="pathname"> \param[in]    pathname</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selReadFromColorImage")> _
Friend Shared Function selReadFromColorImage(pathname as String) as IntPTR
End Function

' SRC\sel1.c (2109, 1)
' 
' selCreateFromColorPix(PIX *, const char *) as SEL *
''' <summary>
''' * Notes:
'''  *   (1) The sel size is given by the size of pixs.
'''  *   (2) In pixs, hits are represented by green pixels, misses by red
'''  * pixels, and don't-cares by white pixels.
'''  *   (3) In pixs, there may be no misses, but there must be at least 1 hit.
'''  *   (4) At most there can be only one origin pixel, which is optionally
'''  * specified by using a lower-intensity pixel:
'''  *   if a hit:  dark green
'''  *   if a miss: dark red
'''  *   if a don't care: gray
'''  * If there is no such pixel, the origin defaults to the approximate
'''  * center of the sel.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel if OK, NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs cmapped or rgb</param>
''' <param name="selname"> \param[in]    selname [optional] sel name; can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selCreateFromColorPix")> _
Friend Shared Function selCreateFromColorPix(pixs as IntPTR, selname as String) as IntPTR
End Function

' SRC\sel1.c (2200, 1)
' selDisplayInPix()
' selDisplayInPix(SEL *, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This gives a visual representation of a general (hit-miss) sel.
'''  *   (2) The empty sel is represented by a grid of intersecting lines.
'''  *   (3) Three different patterns are generated for the sel elements:
'''  * ~ hit (solid black circle)
'''  * ~ miss (black ring; inner radius is radius2)
'''  * ~ origin (cross, XORed with whatever is there)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix display of sel, or NULL on error</returns>
''' <param name="sel"> \param[in]    sel</param>
''' <param name="size"> \param[in]    size of grid interiors; odd; minimum size of 13 is enforced</param>
''' <param name="gthick"> \param[in]    gthick grid thickness; minimum size of 2 is enforced</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selDisplayInPix")> _
Friend Shared Function selDisplayInPix(sel as IntPTR, size as Integer, gthick as Integer) as IntPTR
End Function

' SRC\sel1.c (2318, 1)
' selaDisplayInPix()
' selaDisplayInPix(SELA *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This gives a visual representation of all the sels in a sela.
'''  *   (2) See notes in selDisplayInPix() for display params of each sel.
'''  *   (3) This gives the nicest results when all sels in the sela
'''  * are the same size.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix display of all sels in sela, or NULL on error</returns>
''' <param name="sela"> \param[in]    sela</param>
''' <param name="size"> \param[in]    size of grid interiors; odd; minimum size of 13 is enforced</param>
''' <param name="gthick"> \param[in]    gthick grid thickness; minimum size of 2 is enforced</param>
''' <param name="spacing"> \param[in]    spacing between sels, both horizontally and vertically</param>
''' <param name="ncols"> \param[in]    ncols number of sels per "line"</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaDisplayInPix")> _
Friend Shared Function selaDisplayInPix(sela as IntPTR, size as Integer, gthick as Integer, spacing as Integer, ncols as Integer) as IntPTR
End Function

#End Region
#Region "SRC\sel2.c"
' SRC\sel2.c (92, 1)
' selaAddBasic()
' selaAddBasic(SELA *) as SELA *
''' <summary>
''' * Notes:
'''  *   (1) Adds the following sels:
'''  *   ~ all linear (horiz, vert) brick sels that are
'''  *  necessary for decomposable sels up to size 63
'''  *   ~ square brick sels up to size 10
'''  *   ~ 4 diagonal sels
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela with additional sels, or NULL on error</returns>
''' <param name="sela"> \param[in]    sela [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaAddBasic")> _
Friend Shared Function selaAddBasic(sela as IntPTR) as IntPTR
End Function

' SRC\sel2.c (181, 1)
' selaAddHitMiss()
' selaAddHitMiss(SELA *) as SELA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela with additional sels, or NULL on error</returns>
''' <param name="sela"> \param[in]    sela  [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaAddHitMiss")> _
Friend Shared Function selaAddHitMiss(sela as IntPTR) as IntPTR
End Function

' SRC\sel2.c (319, 1)
' selaAddDwaLinear()
' selaAddDwaLinear(SELA *) as SELA *
''' <summary>
''' * Notes:
'''  *   (1) Adds all linear (horizontal, vertical) sels from
'''  * 2 to 63 pixels in length, which are the sizes over
'''  * which dwa code can be generated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela with additional sels, or NULL on error</returns>
''' <param name="sela"> \param[in]    sela [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaAddDwaLinear")> _
Friend Shared Function selaAddDwaLinear(sela as IntPTR) as IntPTR
End Function

' SRC\sel2.c (361, 1)
' selaAddDwaCombs()
' selaAddDwaCombs(SELA *) as SELA *
''' <summary>
''' * Notes:
'''  *   (1) Adds all comb (horizontal, vertical) Sels that are
'''  * used in composite linear morphological operations
'''  * up to 63 pixels in length, which are the sizes over
'''  * which dwa code can be generated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela with additional sels, or NULL on error</returns>
''' <param name="sela"> \param[in]    sela [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaAddDwaCombs")> _
Friend Shared Function selaAddDwaCombs(sela as IntPTR) as IntPTR
End Function

' SRC\sel2.c (423, 1)
' selaAddCrossJunctions()
' selaAddCrossJunctions(SELA *, l_float32, l_float32, l_int32, l_int32) as SELA *
''' <summary>
''' * Notes:
'''  *   (1) Adds hitmiss Sels for the intersection of two lines.
'''  * If the lines are very thin, they must be nearly orthogonal
'''  * to register.
'''  *   (2) The number of Sels generated is equal to %norient.
'''  *   (3) If %norient == 2, this generates 2 Sels of crosses, each with
'''  * two perpendicular lines of hits.  One Sel has horizontal and
'''  * vertical hits; the other has hits along lines at +-45 degrees.
'''  * Likewise, if %norient == 3, this generates 3 Sels of crosses
'''  * oriented at 30 degrees with each other.
'''  *   (4) It is suggested that %hlsize be chosen at least 1 greater
'''  * than %mdist.  Try values of (%hlsize, %mdist) such as
'''  * (6,5), (7,6), (8,7), (9,7), etc.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela with additional sels, or NULL on error</returns>
''' <param name="sela"> \param[in]    sela [optional]</param>
''' <param name="hlsize"> \param[in]    hlsize length of each line of hits from origin</param>
''' <param name="mdist"> \param[in]    mdist distance of misses from the origin</param>
''' <param name="norient"> \param[in]    norient number of orientations; max of 8</param>
''' <param name="debugflag"> \param[in]    debugflag 1 for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaAddCrossJunctions")> _
Friend Shared Function selaAddCrossJunctions(sela as IntPTR, hlsize as single, mdist as single, norient as Integer, debugflag as Integer) as IntPTR
End Function

' SRC\sel2.c (548, 1)
' selaAddTJunctions()
' selaAddTJunctions(SELA *, l_float32, l_float32, l_int32, l_int32) as SELA *
''' <summary>
''' * Notes:
'''  *   (1) Adds hitmiss Sels for the T-junction of two lines.
'''  * If the lines are very thin, they must be nearly orthogonal
'''  * to register.
'''  *   (2) The number of Sels generated is 4 * %norient.
'''  *   (3) It is suggested that %hlsize be chosen at least 1 greater
'''  * than %mdist.  Try values of (%hlsize, %mdist) such as
'''  * (6,5), (7,6), (8,7), (9,7), etc.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela with additional sels, or NULL on error</returns>
''' <param name="sela"> \param[in]    sela [optional]</param>
''' <param name="hlsize"> \param[in]    hlsize length of each line of hits from origin</param>
''' <param name="mdist"> \param[in]    mdist distance of misses from the origin</param>
''' <param name="norient"> \param[in]    norient number of orientations; max of 8</param>
''' <param name="debugflag"> \param[in]    debugflag 1 for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="selaAddTJunctions")> _
Friend Shared Function selaAddTJunctions(sela as IntPTR, hlsize as single, mdist as single, norient as Integer, debugflag as Integer) as IntPTR
End Function

' SRC\sel2.c (749, 1)
' sela4ccThin()
' sela4ccThin(SELA *) as SELA *
''' <summary>
''' * Notes:
'''  *   (1) Adds the 9 basic sels for 4-cc thinning.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela with additional sels, or NULL on error</returns>
''' <param name="sela"> \param[in]    sela [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sela4ccThin")> _
Friend Shared Function sela4ccThin(sela as IntPTR) as IntPTR
End Function

' SRC\sel2.c (790, 1)
' sela8ccThin()
' sela8ccThin(SELA *) as SELA *
''' <summary>
''' * Notes:
'''  *   (1) Adds the 9 basic sels for 8-cc thinning.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela with additional sels, or NULL on error</returns>
''' <param name="sela"> \param[in]    sela [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sela8ccThin")> _
Friend Shared Function sela8ccThin(sela as IntPTR) as IntPTR
End Function

' SRC\sel2.c (831, 1)
' sela4and8ccThin()
' sela4and8ccThin(SELA *) as SELA *
''' <summary>
''' * Notes:
'''  *   (1) Adds the 2 basic sels for either 4-cc or 8-cc thinning.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sela with additional sels, or NULL on error</returns>
''' <param name="sela"> \param[in]    sela [optional]</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sela4and8ccThin")> _
Friend Shared Function sela4and8ccThin(sela as IntPTR) as IntPTR
End Function

#End Region
#Region "SRC\selgen.c"
' SRC\selgen.c (146, 1)
' pixGenerateSelWithRuns()
' pixGenerateSelWithRuns(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, PIX **) as SEL *
''' <summary>
''' * Notes:
'''  * (1) The horizontal and vertical lines along which elements are
'''  *  selected are roughly equally spaced.  The actual locations of
'''  *  the hits and misses are the centers of respective run-lengths.
'''  * (2) No elements are selected that are less than 'distance' pixels away
'''  *  from a boundary pixel of the same color.  This makes the
'''  *  match much more robust to edge noise.  Valid inputs of
'''  *  'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or
'''  *  greater than 4, we reset it to the default value.
'''  * (3) The 4 numbers for adding rectangles of pixels outside the fg
'''  *  can be use if the pattern is expected to be surrounded by bg
'''  *  (white) pixels.  On the other hand, if the pattern may be near
'''  *  other fg (black) components on some sides, use 0 for those sides.
'''  * (4) The pixels added to a side allow you to have miss elements there.
'''  *  There is a constraint between distance, minlength, and
'''  *  the added pixels for this to work.  We illustrate using the
'''  *  default values.  If you add 5 pixels to the top, and use a
'''  *  distance of 1, then you end up with a vertical run of at least
'''  *  4 bg pixels along the top edge of the image.  If you use a
'''  *  minimum runlength of 3, each vertical line will always find
'''  *  a miss near the center of its run.  However, if you use a
'''  *  minimum runlength of 5, you will not get a miss on every vertical
'''  *  line.  As another example, if you have 7 added pixels and a
'''  *  distance of 2, you can use a runlength up to 5 to guarantee
'''  *  that the miss element is recorded.  We give a warning if the
'''  *  constraint does not guarantee a miss element outside the
'''  *  image proper.
'''  * (5) The input pix, as extended by the extra pixels on selected sides,
'''  *  can optionally be returned.  For debugging, call
'''  *  pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
'''  *  on the generating bitmap.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel hit-miss for input pattern, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, typically small, to be used as a pattern</param>
''' <param name="nhlines"> \param[in]    nhlines number of hor lines along which elements are found</param>
''' <param name="nvlines"> \param[in]    nvlines number of vert lines along which elements are found</param>
''' <param name="distance"> \param[in]    distance min distance from boundary pixel; use 0 for default</param>
''' <param name="minlength"> \param[in]    minlength min runlength to set hit or miss; use 0 for default</param>
''' <param name="toppix"> \param[in]    toppix number of extra pixels of bg added above</param>
''' <param name="botpix"> \param[in]    botpix number of extra pixels of bg added below</param>
''' <param name="leftpix"> \param[in]    leftpix number of extra pixels of bg added to left</param>
''' <param name="rightpix"> \param[in]    rightpix number of extra pixels of bg added to right</param>
''' <param name="ppixe"> \param[out]   ppixe [optional] input pix expanded by extra pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateSelWithRuns")> _
Friend Shared Function pixGenerateSelWithRuns(pixs as IntPTR, nhlines as Integer, nvlines as Integer, distance as Integer, minlength as Integer, toppix as Integer, botpix as Integer, leftpix as Integer, rightpix as Integer, ppixe as Object) as IntPTR
End Function

' SRC\selgen.c (336, 1)
' pixGenerateSelRandom()
' pixGenerateSelRandom(PIX *, l_float32, l_float32, l_int32, l_int32, l_int32, l_int32, l_int32, PIX **) as SEL *
''' <summary>
''' * Notes:
'''  * (1) Either of hitfract and missfract can be zero.  If both are zero,
'''  *  the sel would be empty, and NULL is returned.
'''  * (2) No elements are selected that are less than 'distance' pixels away
'''  *  from a boundary pixel of the same color.  This makes the
'''  *  match much more robust to edge noise.  Valid inputs of
'''  *  'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or
'''  *  greater than 4, we reset it to the default value.
'''  * (3) The 4 numbers for adding rectangles of pixels outside the fg
'''  *  can be use if the pattern is expected to be surrounded by bg
'''  *  (white) pixels.  On the other hand, if the pattern may be near
'''  *  other fg (black) components on some sides, use 0 for those sides.
'''  * (4) The input pix, as extended by the extra pixels on selected sides,
'''  *  can optionally be returned.  For debugging, call
'''  *  pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
'''  *  on the generating bitmap.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel hit-miss for input pattern, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, typically small, to be used as a pattern</param>
''' <param name="hitfract"> \param[in]    hitfract fraction of allowable fg pixels that are hits</param>
''' <param name="missfract"> \param[in]    missfract fraction of allowable bg pixels that are misses</param>
''' <param name="distance"> \param[in]    distance min distance from boundary pixel; use 0 for default</param>
''' <param name="toppix"> \param[in]    toppix number of extra pixels of bg added above</param>
''' <param name="botpix"> \param[in]    botpix number of extra pixels of bg added below</param>
''' <param name="leftpix"> \param[in]    leftpix number of extra pixels of bg added to left</param>
''' <param name="rightpix"> \param[in]    rightpix number of extra pixels of bg added to right</param>
''' <param name="ppixe"> \param[out]   ppixe [optional] input pix expanded by extra pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateSelRandom")> _
Friend Shared Function pixGenerateSelRandom(pixs as IntPTR, hitfract as single, missfract as single, distance as Integer, toppix as Integer, botpix as Integer, leftpix as Integer, rightpix as Integer, ppixe as Object) as IntPTR
End Function

' SRC\selgen.c (489, 1)
' pixGenerateSelBoundary()
' pixGenerateSelBoundary(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32, PIX **) as SEL *
''' <summary>
''' * Notes:
'''  * (1) All fg elements selected are exactly hitdist pixels away from
'''  *  the nearest fg boundary pixel, and ditto for bg elements.
'''  *  Valid inputs of hitdist and missdist are 0, 1, 2, 3 and 4.
'''  *  For example, a hitdist of 0 puts the hits at the fg boundary.
'''  *  Usually, the distances should be > 0 avoid the effect of
'''  *  noise at the boundary.
'''  * (2) Set hitskip  0 if no hits are to be used.  Ditto for missskip.
'''  *  If both hitskip and missskip are  0, the sel would be empty,
'''  *  and NULL is returned.
'''  * (3) The 4 flags determine whether the sel is increased on that side
'''  *  to allow bg misses to be placed all along that boundary.
'''  *  The increase in sel size on that side is the minimum necessary
'''  *  to allow the misses to be placed at mindist.  For text characters,
'''  *  the topflag and botflag are typically set to 1, and the leftflag
'''  *  and rightflag to 0.
'''  * (4) The input pix, as extended by the extra pixels on selected sides,
'''  *  can optionally be returned.  For debugging, call
'''  *  pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
'''  *  on the generating bitmap.
'''  * (5) This is probably the best of the three sel generators, in the
'''  *  sense that you have the most flexibility with the smallest number
'''  *  of hits and misses.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sel hit-miss for input pattern, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, typically small, to be used as a pattern</param>
''' <param name="hitdist"> \param[in]    hitdist min distance from fg boundary pixel</param>
''' <param name="missdist"> \param[in]    missdist min distance from bg boundary pixel</param>
''' <param name="hitskip"> \param[in]    hitskip number of boundary pixels skipped between hits</param>
''' <param name="missskip"> \param[in]    missskip number of boundary pixels skipped between misses</param>
''' <param name="topflag"> \param[in]    topflag flag for extra pixels of bg added above</param>
''' <param name="botflag"> \param[in]    botflag flag for extra pixels of bg added below</param>
''' <param name="leftflag"> \param[in]    leftflag flag for extra pixels of bg added to left</param>
''' <param name="rightflag"> \param[in]    rightflag flag for extra pixels of bg added to right</param>
''' <param name="ppixe"> \param[out]   ppixe [optional] input pix expanded by extra pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGenerateSelBoundary")> _
Friend Shared Function pixGenerateSelBoundary(pixs as IntPTR, hitdist as Integer, missdist as Integer, hitskip as Integer, missskip as Integer, topflag as Integer, botflag as Integer, leftflag as Integer, rightflag as Integer, ppixe as Object) as IntPTR
End Function

' SRC\selgen.c (636, 1)
' pixGetRunCentersOnLine()
' pixGetRunCentersOnLine(PIX *, l_int32, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) Action: this function computes the fg (black) and bg (white)
'''  * pixel runlengths along the specified horizontal or vertical line,
'''  * and returns a Numa of the "center" pixels of each fg run
'''  * whose length equals or exceeds the minimum length.
'''  *   (2) This only works on horizontal and vertical lines.
'''  *   (3) For horizontal runs, set x = -1 and y to the value
'''  * for all points along the raster line.  For vertical runs,
'''  * set y = -1 and x to the value for all points along the
'''  * pixel column.
'''  *   (4) For horizontal runs, the points in the Numa are the x
'''  * values in the center of fg runs that are of length at
'''  * least 'minlength'.  For vertical runs, the points in the
'''  * Numa are the y values in the center of fg runs, again
'''  * of length 'minlength' or greater.
'''  *   (5) If there are no fg runs along the line that satisfy the
'''  * minlength constraint, the returned Numa is empty.  This
'''  * is not an error.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa of fg runs, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="x"> \param[in]    x, y set one of these to -1; see notes</param>
''' <param name="y"> \param[in]    minlength minimum length of acceptable run</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRunCentersOnLine")> _
Friend Shared Function pixGetRunCentersOnLine(pixs as IntPTR, x as Integer, y as Integer, minlength as Integer) as IntPTR
End Function

' SRC\selgen.c (708, 1)
' pixGetRunsOnLine()
' pixGetRunsOnLine(PIX *, l_int32, l_int32, l_int32, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) Action: this function uses the bresenham algorithm to compute
'''  * the pixels along the specified line.  It returns a Numa of the
'''  * runlengths of the fg (black) and bg (white) runs, always
'''  * starting with a white run.
'''  *   (2) If the first pixel on the line is black, the length of the
'''  * first returned run (which is white) is 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="x1"> \param[in]    x1, y1, x2, y2</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetRunsOnLine")> _
Friend Shared Function pixGetRunsOnLine(pixs as IntPTR, x1 as Integer, y1 as Integer, x2 as Integer, y2 as Integer) as IntPTR
End Function

' SRC\selgen.c (803, 1)
' pixSubsampleBoundaryPixels()
' pixSubsampleBoundaryPixels(PIX *, l_int32) as PTA *
''' <summary>
''' * Notes:
'''  *   (1) If skip = 0, we take all the fg pixels.
'''  *   (2) We try to traverse the boundaries in a regular way.
'''  * Some pixels may be missed, and these are then subsampled
'''  * randomly with a fraction determined by 'skip'.
'''  *   (3) The most natural approach is to use a depth first (stack-based)
'''  * method to find the fg pixels.  However, the pixel runs are
'''  * 4-connected and there are relatively few branches.  So
'''  * instead of doing a proper depth-first search, we get nearly
'''  * the same result using two nested while loops: the outer
'''  * one continues a raster-based search for the next fg pixel,
'''  * and the inner one does a reasonable job running along
'''  * each 4-connected coutour.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pta, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp, with only boundary pixels in fg</param>
''' <param name="skip"> \param[in]    skip number to skip between samples as you traverse boundary</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSubsampleBoundaryPixels")> _
Friend Shared Function pixSubsampleBoundaryPixels(pixs as IntPTR, skip as Integer) as IntPTR
End Function

' SRC\selgen.c (870, 1)
' adjacentOnPixelInRaster()
' adjacentOnPixelInRaster(PIX *, l_int32, l_int32, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Search is in 4-connected directions first; then on diagonals.
'''  * This allows traversal along a 4-connected boundary.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if a pixel is found; 0 otherwise or on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="x"> \param[in]    x, y current pixel</param>
''' <param name="y"> \param[out]   pxa, pya adjacent ON pixel, found by simple CCW search</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="adjacentOnPixelInRaster")> _
Friend Shared Function adjacentOnPixelInRaster(pixs as IntPTR, x as Integer, y as Integer, pxa as Integer, pya as Integer) as Integer
End Function

' SRC\selgen.c (928, 1)
' pixDisplayHitMissSel()
' pixDisplayHitMissSel(PIX *, SEL *, l_int32, l_uint32, l_uint32) as PIX *
''' <summary>
''' * Notes:
'''  * (1) We don't allow scalefactor to be larger than MAX_SEL_SCALEFACTOR
'''  * (2) The colors are conveniently given as 4 bytes in hex format,
'''  *  such as 0xff008800.  The least significant byte is ignored.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd RGB showing both pixs and sel, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="sel"> \param[in]    sel hit-miss in general</param>
''' <param name="scalefactor"> \param[in]    scalefactor an integer >= 1; use 0 for default</param>
''' <param name="hitcolor"> \param[in]    hitcolor RGB0 color for center of hit pixels</param>
''' <param name="misscolor"> \param[in]    misscolor RGB0 color for center of miss pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDisplayHitMissSel")> _
Friend Shared Function pixDisplayHitMissSel(pixs as IntPTR, sel as IntPTR, scalefactor as Integer, hitcolor as UInteger, misscolor as UInteger) as IntPTR
End Function

#End Region
#Region "SRC\shear.c"
' SRC\shear.c (62, 18)
' 
' normalizeAngleForShear(l_float32, l_float32) as l_float32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="normalizeAngleForShear")> _
Friend Shared Function normalizeAngleForShear(radang as single, mindif as single) as single
End Function

' SRC\shear.c (113, 1)
' pixHShear()
' pixHShear(PIX *, PIX *, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) There are 3 cases:
'''  *   (a) pixd == null (make a new pixd)
'''  *   (b) pixd == pixs (in-place)
'''  *   (c) pixd != pixs
'''  *   (2) For these three cases, use these patterns, respectively:
'''  *  pixd = pixHShear(NULL, pixs, ...);
'''  *  pixHShear(pixs, pixs, ...);
'''  *  pixHShear(pixd, pixs, ...);
'''  *   (3) This shear leaves the horizontal line of pixels at y = yloc
'''  * invariant.  For a positive shear angle, pixels above this
'''  * line are shoved to the right, and pixels below this line
'''  * move to the left.
'''  *   (4) With positive shear angle, this can be used, along with
'''  * pixVShear(), to perform a cw rotation, either with 2 shears
'''  * (for small angles) or in the general case with 3 shears.
'''  *   (5) Changing the value of yloc is equivalent to translating
'''  * the result horizontally.
'''  *   (6) This brings in 'incolor' pixels from outside the image.
'''  *   (7) For in-place operation, pixs cannot be colormapped,
'''  * because the in-place operation only blits in 0 or 1 bits,
'''  * not an arbitrary colormap index.
'''  *   (8) The angle is brought into the range [-pi, -pi].  It is
'''  * not permitted to be within MIN_DIFF_FROM_HALF_PI radians
'''  * from either -pi/2 or pi/2.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, always</returns>
''' <param name="pixd"> \param[in]    pixd [optional], this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs no restrictions on depth</param>
''' <param name="yloc"> \param[in]    yloc location of horizontal line, measured from origin</param>
''' <param name="radang"> \param[in]    radang  angle in radians</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixHShear")> _
Friend Shared Function pixHShear(pixd as IntPTR, pixs as IntPTR, yloc as Integer, radang as single, incolor as Integer) as IntPTR
End Function

' SRC\shear.c (230, 1)
' pixVShear()
' pixVShear(PIX *, PIX *, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) There are 3 cases:
'''  *   (a) pixd == null (make a new pixd)
'''  *   (b) pixd == pixs (in-place)
'''  *   (c) pixd != pixs
'''  *   (2) For these three cases, use these patterns, respectively:
'''  *  pixd = pixVShear(NULL, pixs, ...);
'''  *  pixVShear(pixs, pixs, ...);
'''  *  pixVShear(pixd, pixs, ...);
'''  *   (3) This shear leaves the vertical line of pixels at x = xloc
'''  * invariant.  For a positive shear angle, pixels to the right
'''  * of this line are shoved downward, and pixels to the left
'''  * of the line move upward.
'''  *   (4) With positive shear angle, this can be used, along with
'''  * pixHShear(), to perform a cw rotation, either with 2 shears
'''  * (for small angles) or in the general case with 3 shears.
'''  *   (5) Changing the value of xloc is equivalent to translating
'''  * the result vertically.
'''  *   (6) This brings in 'incolor' pixels from outside the image.
'''  *   (7) For in-place operation, pixs cannot be colormapped,
'''  * because the in-place operation only blits in 0 or 1 bits,
'''  * not an arbitrary colormap index.
'''  *   (8) The angle is brought into the range [-pi, -pi].  It is
'''  * not permitted to be within MIN_DIFF_FROM_HALF_PI radians
'''  * from either -pi/2 or pi/2.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error</returns>
''' <param name="pixd"> \param[in]    pixd [optional], this can be null, equal to pixs,</param>
''' <param name="pixs"> \param[in]    pixs no restrictions on depth</param>
''' <param name="xloc"> \param[in]    xloc location of vertical line, measured from origin</param>
''' <param name="radang"> \param[in]    radang  angle in radians; not too close to +-(pi / 2)</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixVShear")> _
Friend Shared Function pixVShear(pixd as IntPTR, pixs as IntPTR, xloc as Integer, radang as single, incolor as Integer) as IntPTR
End Function

' SRC\shear.c (328, 1)
' pixHShearCorner()
' pixHShearCorner(PIX *, PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixHShear() for usage.
'''  *   (2) This does a horizontal shear about the UL corner, with (+) shear
'''  * pushing increasingly leftward (-x) with increasing y.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error.</returns>
''' <param name="pixd"> \param[in]    pixd [optional], if not null, must be equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="radang"> \param[in]    radang  angle in radians</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixHShearCorner")> _
Friend Shared Function pixHShearCorner(pixd as IntPTR, pixs as IntPTR, radang as single, incolor as Integer) as IntPTR
End Function

' SRC\shear.c (359, 1)
' pixVShearCorner()
' pixVShearCorner(PIX *, PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixVShear() for usage.
'''  *   (2) This does a vertical shear about the UL corner, with (+) shear
'''  * pushing increasingly downward (+y) with increasing x.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error.</returns>
''' <param name="pixd"> \param[in]    pixd [optional], if not null, must be equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="radang"> \param[in]    radang  angle in radians</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixVShearCorner")> _
Friend Shared Function pixVShearCorner(pixd as IntPTR, pixs as IntPTR, radang as single, incolor as Integer) as IntPTR
End Function

' SRC\shear.c (390, 1)
' pixHShearCenter()
' pixHShearCenter(PIX *, PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixHShear() for usage.
'''  *   (2) This does a horizontal shear about the center, with (+) shear
'''  * pushing increasingly leftward (-x) with increasing y.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error.</returns>
''' <param name="pixd"> \param[in]    pixd [optional], if not null, must be equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="radang"> \param[in]    radang  angle in radians</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixHShearCenter")> _
Friend Shared Function pixHShearCenter(pixd as IntPTR, pixs as IntPTR, radang as single, incolor as Integer) as IntPTR
End Function

' SRC\shear.c (421, 1)
' pixVShearCenter()
' pixVShearCenter(PIX *, PIX *, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixVShear() for usage.
'''  *   (2) This does a vertical shear about the center, with (+) shear
'''  * pushing increasingly downward (+y) with increasing x.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd, or NULL on error.</returns>
''' <param name="pixd"> \param[in]    pixd [optional], if not null, must be equal to pixs</param>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="radang"> \param[in]    radang  angle in radians</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixVShearCenter")> _
Friend Shared Function pixVShearCenter(pixd as IntPTR, pixs as IntPTR, radang as single, incolor as Integer) as IntPTR
End Function

' SRC\shear.c (459, 1)
' pixHShearIP()
' pixHShearIP(PIX *, l_int32, l_float32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place version of pixHShear(); see comments there.
'''  *   (2) This brings in 'incolor' pixels from outside the image.
'''  *   (3) pixs cannot be colormapped, because the in-place operation
'''  * only blits in 0 or 1 bits, not an arbitrary colormap index.
'''  *   (4) Does a horizontal full-band shear about the line with (+) shear
'''  * pushing increasingly leftward (-x) with increasing y.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="yloc"> \param[in]    yloc location of horizontal line, measured from origin</param>
''' <param name="radang"> \param[in]    radang  angle in radians</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixHShearIP")> _
Friend Shared Function pixHShearIP(pixs as IntPTR, yloc as Integer, radang as single, incolor as Integer) as Integer
End Function

' SRC\shear.c (534, 1)
' pixVShearIP()
' pixVShearIP(PIX *, l_int32, l_float32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is an in-place version of pixVShear(); see comments there.
'''  *   (2) This brings in 'incolor' pixels from outside the image.
'''  *   (3) pixs cannot be colormapped, because the in-place operation
'''  * only blits in 0 or 1 bits, not an arbitrary colormap index.
'''  *   (4) Does a vertical full-band shear about the line with (+) shear
'''  * pushing increasingly downward (+y) with increasing x.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs all depths; not colormapped</param>
''' <param name="xloc"> \param[in]    xloc  location of vertical line, measured from origin</param>
''' <param name="radang"> \param[in]    radang  angle in radians</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixVShearIP")> _
Friend Shared Function pixVShearIP(pixs as IntPTR, xloc as Integer, radang as single, incolor as Integer) as Integer
End Function

' SRC\shear.c (617, 1)
' pixHShearLI()
' pixHShearLI(PIX *, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does horizontal shear with linear interpolation for
'''  * accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.
'''  * It is relatively slow compared to the sampled version
'''  * implemented by rasterop, but the result is much smoother.
'''  *   (2) This shear leaves the horizontal line of pixels at y = yloc
'''  * invariant.  For a positive shear angle, pixels above this
'''  * line are shoved to the right, and pixels below this line
'''  * move to the left.
'''  *   (3) Any colormap is removed.
'''  *   (4) The angle is brought into the range [-pi/2 + del, pi/2 - del],
'''  * where del == MIN_DIFF_FROM_HALF_PI.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd sheared, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp or 32 bpp, or colormapped</param>
''' <param name="yloc"> \param[in]    yloc location of horizontal line, measured from origin</param>
''' <param name="radang"> \param[in]    radang  angle in radians, in range (-pi/2 ... pi/2)</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixHShearLI")> _
Friend Shared Function pixHShearLI(pixs as IntPTR, yloc as Integer, radang as single, incolor as Integer) as IntPTR
End Function

' SRC\shear.c (729, 1)
' pixVShearLI()
' pixVShearLI(PIX *, l_int32, l_float32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This does vertical shear with linear interpolation for
'''  * accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.
'''  * It is relatively slow compared to the sampled version
'''  * implemented by rasterop, but the result is much smoother.
'''  *   (2) This shear leaves the vertical line of pixels at x = xloc
'''  * invariant.  For a positive shear angle, pixels to the right
'''  * of this line are shoved downward, and pixels to the left
'''  * of the line move upward.
'''  *   (3) Any colormap is removed.
'''  *   (4) The angle is brought into the range [-pi/2 + del, pi/2 - del],
'''  * where del == MIN_DIFF_FROM_HALF_PI.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd sheared, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp or 32 bpp, or colormapped</param>
''' <param name="xloc"> \param[in]    xloc  location of vertical line, measured from origin</param>
''' <param name="radang"> \param[in]    radang  angle in radians, in range (-pi/2 ... pi/2)</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixVShearLI")> _
Friend Shared Function pixVShearLI(pixs as IntPTR, xloc as Integer, radang as single, incolor as Integer) as IntPTR
End Function

#End Region
#Region "SRC\skew.c"
' SRC\skew.c (162, 1)
' pixDeskewBoth()
' pixDeskewBoth(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This binarizes if necessary and does both horizontal
'''  * and vertical deskewing, using the default parameters in
'''  * the underlying pixDeskew().  See usage there.
'''  *   (2) This may return a clone.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd deskewed pix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth</param>
''' <param name="redsearch"> \param[in]    redsearch for binary search: reduction factor = 1, 2 or 4;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDeskewBoth")> _
Friend Shared Function pixDeskewBoth(pixs as IntPTR, redsearch as Integer) as IntPTR
End Function

' SRC\skew.c (205, 1)
' pixDeskew()
' pixDeskew(PIX *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This binarizes if necessary and finds the skew angle.  If the
'''  * angle is large enough and there is sufficient confidence,
'''  * it returns a deskewed image; otherwise, it returns a clone.
'''  *   (2) Typical values at 300 ppi for %redsearch are 2 and 4.
'''  * At 75 ppi, one should use %redsearch = 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd deskewed pix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth</param>
''' <param name="redsearch"> \param[in]    redsearch for binary search: reduction factor = 1, 2 or 4;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDeskew")> _
Friend Shared Function pixDeskew(pixs as IntPTR, redsearch as Integer) as IntPTR
End Function

' SRC\skew.c (241, 1)
' pixFindSkewAndDeskew()
' pixFindSkewAndDeskew(PIX *, l_int32, l_float32 *, l_float32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This binarizes if necessary and finds the skew angle.  If the
'''  * angle is large enough and there is sufficient confidence,
'''  * it returns a deskewed image; otherwise, it returns a clone.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd deskewed pix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth</param>
''' <param name="redsearch"> \param[in]    redsearch for binary search: reduction factor = 1, 2 or 4;</param>
''' <param name="pangle"> \param[out]   pangle   [optional] angle required to deskew,</param>
''' <param name="pconf"> \param[out]   pconf    [optional] conf value is ratio</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindSkewAndDeskew")> _
Friend Shared Function pixFindSkewAndDeskew(pixs as IntPTR, redsearch as Integer, pangle as single, pconf as single) as IntPTR
End Function

' SRC\skew.c (285, 1)
' pixDeskewGeneral()
' pixDeskewGeneral(PIX *, l_int32, l_float32, l_float32, l_int32, l_int32, l_float32 *, l_float32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This binarizes if necessary and finds the skew angle.  If the
'''  * angle is large enough and there is sufficient confidence,
'''  * it returns a deskewed image; otherwise, it returns a clone.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd deskewed pix, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  any depth</param>
''' <param name="redsweep"> \param[in]    redsweep  for linear search: reduction factor = 1, 2 or 4;</param>
''' <param name="sweeprange"> \param[in]    sweeprange in degrees in each direction from 0;</param>
''' <param name="sweepdelta"> \param[in]    sweepdelta in degrees; use 0.0 for default</param>
''' <param name="redsearch"> \param[in]    redsearch  for binary search: reduction factor = 1, 2 or 4;</param>
''' <param name="thresh"> \param[in]    thresh for binarizing the image; use 0 for default</param>
''' <param name="pangle"> \param[out]   pangle   [optional] angle required to deskew,</param>
''' <param name="pconf"> \param[out]   pconf    [optional] conf value is ratio</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDeskewGeneral")> _
Friend Shared Function pixDeskewGeneral(pixs as IntPTR, redsweep as Integer, sweeprange as single, sweepdelta as single, redsearch as Integer, thresh as Integer, pangle as single, pconf as single) as IntPTR
End Function

' SRC\skew.c (370, 1)
' pixFindSkew()
' pixFindSkew(PIX *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a simple high-level interface, that uses default
'''  * values of the parameters for reasonable speed and accuracy.
'''  *   (2) The angle returned is the negative of the skew angle of
'''  * the image.  It is the angle required for deskew.
'''  * Clockwise rotations are positive angles.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if angle measurement not valid</returns>
''' <param name="pixs"> \param[in]    pixs  1 bpp</param>
''' <param name="pangle"> \param[out]   pangle   angle required to deskew, in degrees</param>
''' <param name="pconf"> \param[out]   pconf    confidence value is ratio max/min scores</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindSkew")> _
Friend Shared Function pixFindSkew(pixs as IntPTR, pangle as single, pconf as single) as Integer
End Function

' SRC\skew.c (414, 1)
' pixFindSkewSweep()
' pixFindSkewSweep(PIX *, l_float32 *, l_int32, l_float32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This examines the 'score' for skew angles with equal intervals.
'''  *   (2) Caller must check the return value for validity of the result.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if angle measurement not valid</returns>
''' <param name="pixs"> \param[in]    pixs  1 bpp</param>
''' <param name="pangle"> \param[out]   pangle   angle required to deskew, in degrees</param>
''' <param name="reduction"> \param[in]    reduction  factor = 1, 2, 4 or 8</param>
''' <param name="sweeprange"> \param[in]    sweeprange   half the full range; assumed about 0; in degrees</param>
''' <param name="sweepdelta"> \param[in]    sweepdelta   angle increment of sweep; in degrees</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindSkewSweep")> _
Friend Shared Function pixFindSkewSweep(pixs as IntPTR, pangle as single, reduction as Integer, sweeprange as single, sweepdelta as single) as Integer
End Function

' SRC\skew.c (558, 1)
' pixFindSkewSweepAndSearch()
' pixFindSkewSweepAndSearch(PIX *, l_float32 *, l_float32 *, l_int32, l_int32, l_float32, l_float32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds the skew angle, doing first a sweep through a set
'''  * of equal angles, and then doing a binary search until
'''  * convergence.
'''  *   (2) Caller must check the return value for validity of the result.
'''  *   (3) In computing the differential line sum variance score, we sum
'''  * the result over scanlines, but we always skip:
'''  *  ~ at least one scanline
'''  *  ~ not more than 10% of the image height
'''  *  ~ not more than 5% of the image width
'''  *   (4) See also notes in pixFindSkewSweepAndSearchScore()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if angle measurement not valid</returns>
''' <param name="pixs"> \param[in]    pixs  1 bpp</param>
''' <param name="pangle"> \param[out]   pangle   angle required to deskew; in degrees</param>
''' <param name="pconf"> \param[out]   pconf    confidence given by ratio of max/min score</param>
''' <param name="redsweep"> \param[in]    redsweep  sweep reduction factor = 1, 2, 4 or 8</param>
''' <param name="redsearch"> \param[in]    redsearch  binary search reduction factor = 1, 2, 4 or 8;</param>
''' <param name="sweeprange"> \param[in]    sweeprange   half the full range, assumed about 0; in degrees</param>
''' <param name="sweepdelta"> \param[in]    sweepdelta   angle increment of sweep; in degrees</param>
''' <param name="minbsdelta"> \param[in]    minbsdelta   min binary search increment angle; in degrees</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindSkewSweepAndSearch")> _
Friend Shared Function pixFindSkewSweepAndSearch(pixs as IntPTR, pangle as single, pconf as single, redsweep as Integer, redsearch as Integer, sweeprange as single, sweepdelta as single, minbsdelta as single) as Integer
End Function

' SRC\skew.c (612, 1)
' pixFindSkewSweepAndSearchScore()
' pixFindSkewSweepAndSearchScore(PIX *, l_float32 *, l_float32 *, l_float32 *, l_int32, l_int32, l_float32, l_float32, l_float32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This finds the skew angle, doing first a sweep through a set
'''  * of equal angles, and then doing a binary search until convergence.
'''  *   (2) There are two built-in constants that determine if the
'''  * returned confidence is nonzero:
'''  *   ~ MIN_VALID_MAXSCORE (minimum allowed maxscore)
'''  *   ~ MINSCORE_THRESHOLD_CONSTANT (determines minimum allowed
'''  *  minscore, by multiplying by (height * width^2)
'''  * If either of these conditions is not satisfied, the returned
'''  * confidence value will be zero.  The maxscore is optionally
'''  * returned in this function to allow evaluation of the
'''  * resulting angle by a method that is independent of the
'''  * returned confidence value.
'''  *   (3) The larger the confidence value, the greater the probability
'''  * that the proper alignment is given by the angle that maximizes
'''  * variance.  It should be compared to a threshold, which depends
'''  * on the application.  Values between 3.0 and 6.0 are common.
'''  *   (4) By default, the shear is about the UL corner.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if angle measurement not valid</returns>
''' <param name="pixs"> \param[in]    pixs  1 bpp</param>
''' <param name="pangle"> \param[out]   pangle   angle required to deskew; in degrees</param>
''' <param name="pconf"> \param[out]   pconf    confidence given by ratio of max/min score</param>
''' <param name="pendscore"> \param[out]   pendscore [optional] max score; use NULL to ignore</param>
''' <param name="redsweep"> \param[in]    redsweep  sweep reduction factor = 1, 2, 4 or 8</param>
''' <param name="redsearch"> \param[in]    redsearch  binary search reduction factor = 1, 2, 4 or 8;</param>
''' <param name="sweepcenter"> \param[in]    sweepcenter  angle about which sweep is performed; in degrees</param>
''' <param name="sweeprange"> \param[in]    sweeprange   half the full range, taken about sweepcenter;</param>
''' <param name="sweepdelta"> \param[in]    sweepdelta   angle increment of sweep; in degrees</param>
''' <param name="minbsdelta"> \param[in]    minbsdelta   min binary search increment angle; in degrees</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindSkewSweepAndSearchScore")> _
Friend Shared Function pixFindSkewSweepAndSearchScore(pixs as IntPTR, pangle as single, pconf as single, pendscore as single, redsweep as Integer, redsearch as Integer, sweepcenter as single, sweeprange as single, sweepdelta as single, minbsdelta as single) as Integer
End Function

' SRC\skew.c (661, 1)
' pixFindSkewSweepAndSearchScorePivot()
' pixFindSkewSweepAndSearchScorePivot(PIX *, l_float32 *, l_float32 *, l_float32 *, l_int32, l_int32, l_float32, l_float32, l_float32, l_float32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See notes in pixFindSkewSweepAndSearchScore().
'''  *   (2) This allows choice of shear pivoting from either the UL corner
'''  * or the center.  For small angles, the ability to discriminate
'''  * angles is better with shearing from the UL corner.  However,
'''  * for large angles (say, greater than 20 degrees), it is better
'''  * to shear about the center because a shear from the UL corner
'''  * loses too much of the image.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if angle measurement not valid</returns>
''' <param name="pixs"> \param[in]    pixs  1 bpp</param>
''' <param name="pangle"> \param[out]   pangle   angle required to deskew; in degrees</param>
''' <param name="pconf"> \param[out]   pconf    confidence given by ratio of max/min score</param>
''' <param name="pendscore"> \param[out]   pendscore [optional] max score; use NULL to ignore</param>
''' <param name="redsweep"> \param[in]    redsweep  sweep reduction factor = 1, 2, 4 or 8</param>
''' <param name="redsearch"> \param[in]    redsearch  binary search reduction factor = 1, 2, 4 or 8;</param>
''' <param name="sweepcenter"> \param[in]    sweepcenter  angle about which sweep is performed; in degrees</param>
''' <param name="sweeprange"> \param[in]    sweeprange   half the full range, taken about sweepcenter;</param>
''' <param name="sweepdelta"> \param[in]    sweepdelta   angle increment of sweep; in degrees</param>
''' <param name="minbsdelta"> \param[in]    minbsdelta   min binary search increment angle; in degrees</param>
''' <param name="pivot"> \param[in]    pivot  L_SHEAR_ABOUT_CORNER, L_SHEAR_ABOUT_CENTER</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindSkewSweepAndSearchScorePivot")> _
Friend Shared Function pixFindSkewSweepAndSearchScorePivot(pixs as IntPTR, pangle as single, pconf as single, pendscore as single, redsweep as Integer, redsearch as Integer, sweepcenter as single, sweeprange as single, sweepdelta as single, minbsdelta as single, pivot as Integer) as Integer
End Function

' SRC\skew.c (1032, 1)
' 
' pixFindSkewOrthogonalRange(PIX *, l_float32 *, l_float32 *, l_int32, l_int32, l_float32, l_float32, l_float32, l_float32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindSkewOrthogonalRange")> _
Friend Shared Function pixFindSkewOrthogonalRange(pixs as IntPTR, pangle as single, pconf as single, redsweep as Integer, redsearch as Integer, sweeprange as single, sweepdelta as single, minbsdelta as single, confprior as single) as Integer
End Function

' SRC\skew.c (1105, 1)
' pixFindDifferentialSquareSum()
' pixFindDifferentialSquareSum(PIX *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) At the top and bottom, we skip:
'''  *  ~ at least one scanline
'''  *  ~ not more than 10% of the image height
'''  *  ~ not more than 5% of the image width
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="psum"> \param[out]   psum  result</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindDifferentialSquareSum")> _
Friend Shared Function pixFindDifferentialSquareSum(pixs as IntPTR, psum as single) as Integer
End Function

' SRC\skew.c (1178, 1)
' pixFindNormalizedSquareSum()
' pixFindNormalizedSquareSum(PIX *, l_float32 *, l_float32 *, l_float32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Let the image have h scanlines and N fg pixels.
'''  * If the pixels were uniformly distributed on scanlines,
'''  * the sum of squares of fg pixels on each scanline would be
'''  * h * (N / h)^2.  However, if the pixels are not uniformly
'''  * distributed (e.g., for text), the sum of squares of fg
'''  * pixels will be larger.  We return in hratio and vratio the
'''  * ratio of these two values.
'''  *   (2) If there are no fg pixels, hratio and vratio are returned as 0.0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error or if there are no fg pixels</returns>
''' <param name="pixs"> \param[in]    pixs</param>
''' <param name="phratio"> \param[out]   phratio [optional] ratio of normalized horiz square sum</param>
''' <param name="pvratio"> \param[out]   pvratio [optional] ratio of normalized vert square sum</param>
''' <param name="pfract"> \param[out]   pfract  [optional] ratio of fg pixels to total pixels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindNormalizedSquareSum")> _
Friend Shared Function pixFindNormalizedSquareSum(pixs as IntPTR, phratio as single, pvratio as single, pfract as single) as Integer
End Function

#End Region
#Region "SRC\spixio.c"
' SRC\spixio.c (88, 1)
' pixReadStreamSpix()
' pixReadStreamSpix(FILE *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If called from pixReadStream(), the stream is positioned
'''  * at the beginning of the file.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error.</returns>
''' <param name="fp"> \param[in]    fp     file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadStreamSpix")> _
Friend Shared Function pixReadStreamSpix(fp as Object) as IntPTR
End Function

' SRC\spixio.c (126, 1)
' readHeaderSpix()
' readHeaderSpix(const char *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If there is a colormap, iscmap is returned as 1; else 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pwidth"> \param[out]   pwidth     width</param>
''' <param name="pheight"> \param[out]   pheight    height</param>
''' <param name="pbps"> \param[out]   pbps       bits/sample</param>
''' <param name="pspp"> \param[out]   pspp       samples/pixel</param>
''' <param name="piscmap"> \param[out]   piscmap    [optional]  input NULL to ignore</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readHeaderSpix")> _
Friend Shared Function readHeaderSpix(filename as String, pwidth as Integer, pheight as Integer, pbps as Integer, pspp as Integer, piscmap as Integer) as Integer
End Function

' SRC\spixio.c (167, 1)
' freadHeaderSpix()
' freadHeaderSpix(FILE *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If there is a colormap, iscmap is returned as 1; else 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp        file stream</param>
''' <param name="pwidth"> \param[out]   pwidth    width</param>
''' <param name="pheight"> \param[out]   pheight   height</param>
''' <param name="pbps"> \param[out]   pbps      bits/sample</param>
''' <param name="pspp"> \param[out]   pspp      samples/pixel</param>
''' <param name="piscmap"> \param[out]   piscmap   [optional]  input NULL to ignore</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="freadHeaderSpix")> _
Friend Shared Function freadHeaderSpix(fp as Object, pwidth as Integer, pheight as Integer, pbps as Integer, pspp as Integer, piscmap as Integer) as Integer
End Function

' SRC\spixio.c (211, 1)
' sreadHeaderSpix()
' sreadHeaderSpix(const l_uint32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If there is a colormap, iscmap is returned as 1; else 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="data"> \param[in]    data</param>
''' <param name="pwidth"> \param[out]   pwidth    width</param>
''' <param name="pheight"> \param[out]   pheight   height</param>
''' <param name="pbps"> \param[out]   pbps      bits/sample</param>
''' <param name="pspp"> \param[out]   pspp      samples/pixel</param>
''' <param name="piscmap"> \param[out]   piscmap   [optional]  input NULL to ignore</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sreadHeaderSpix")> _
Friend Shared Function sreadHeaderSpix(data as UInteger, pwidth as Integer, pheight as Integer, pbps as Integer, pspp as Integer, piscmap as Integer) as Integer
End Function

' SRC\spixio.c (265, 1)
' pixWriteStreamSpix()
' pixWriteStreamSpix(FILE *, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]    fp     file stream</param>
''' <param name="pix"> \param[in]    pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamSpix")> _
Friend Shared Function pixWriteStreamSpix(fp as Object, pix as IntPTR) as Integer
End Function

' SRC\spixio.c (297, 1)
' pixReadMemSpix()
' pixReadMemSpix(const l_uint8 *, size_t) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="data"> \param[in]    data    const; uncompressed</param>
''' <param name="size"> \param[in]    size    bytes of data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadMemSpix")> _
Friend Shared Function pixReadMemSpix(data as Byte, size as ULong) as IntPTR
End Function

' SRC\spixio.c (313, 1)
' pixWriteMemSpix()
' pixWriteMemSpix(l_uint8 **, size_t *, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata    data of serialized, uncompressed pix</param>
''' <param name="psize"> \param[out]   psize    size of returned data</param>
''' <param name="pix"> \param[in]    pix      all depths; colormap OK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMemSpix")> _
Friend Shared Function pixWriteMemSpix(pdata as Object, psize as ULong, pix as IntPTR) as Integer
End Function

' SRC\spixio.c (346, 1)
' pixSerializeToMemory()
' pixSerializeToMemory(PIX *, l_uint32 **, size_t *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This does a fast serialization of the principal elements
'''  * of the pix, as follows:
'''  *   "spix" (4 bytes) -- ID for file type
'''  *   w   (4 bytes)
'''  *   h   (4 bytes)
'''  *   d   (4 bytes)
'''  *   wpl (4 bytes)
'''  *   ncolors   (4 bytes) -- in colormap; 0 if there is no colormap
'''  *   cdata  (4 * ncolors)  -- size of serialized colormap array
'''  *   rdatasize (4 bytes) -- size of serialized raster data
'''  *     = 4 * wpl * h
'''  *   rdata  (rdatasize)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs     all depths, colormap OK</param>
''' <param name="pdata"> \param[out]   pdata    serialized data in memory</param>
''' <param name="pnbytes"> \param[out]   pnbytes  number of bytes in data string</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSerializeToMemory")> _
Friend Shared Function pixSerializeToMemory(pixs as IntPTR, pdata as Object, pnbytes as ULong) as Integer
End Function

' SRC\spixio.c (424, 1)
' pixDeserializeFromMemory()
' pixDeserializeFromMemory(const l_uint32 *, size_t) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixSerializeToMemory() for the binary format.
'''  *   (2) Note the image size limits.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="data"> \param[in]    data     serialized data in memory</param>
''' <param name="nbytes"> \param[in]    nbytes   number of bytes in data string</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDeserializeFromMemory")> _
Friend Shared Function pixDeserializeFromMemory(data as UInteger, nbytes as ULong) as IntPTR
End Function

#End Region
#Region "SRC\stack.c"
' SRC\stack.c (65, 16)
' lstackExtendArray()
' lstackExtendArray(L_STACK *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="lstack"> \param[in]    lstack</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lstackExtendArray")> _
Friend Shared Function lstackExtendArray(lstack as IntPTR) as Integer
End Function

' SRC\stack.c (78, 1)
' lstackCreate()
' lstackCreate(l_int32) as L_STACK *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  lstack, or NULL on error</returns>
''' <param name="nalloc"> \param[in]    nalloc initial ptr array size; use 0 for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lstackCreate")> _
Friend Shared Function lstackCreate(nalloc as Integer) as IntPTR
End Function

' SRC\stack.c (121, 1)
' lstackDestroy()
' lstackDestroy(L_STACK **, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) If freeflag is TRUE, frees each struct in the array.
'''  *   (2) If freeflag is FALSE but there are elements on the array,
'''  * gives a warning and destroys the array.  This will
'''  * cause a memory leak of all the items that were on the lstack.
'''  * So if the items require their own destroy function, they
'''  * must be destroyed before the lstack.
'''  *   (3) To destroy the lstack, we destroy the ptr array, then
'''  * the lstack, and then null the contents of the input ptr.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="plstack"> \param[in,out]   plstack to be nulled</param>
''' <param name="freeflag"> \param[in]    freeflag TRUE to free each remaining struct in the array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lstackDestroy")> _
Friend Shared Function lstackDestroy(plstack as Object, freeflag as Integer) as Boolean ' Org. Void
End Function

' SRC\stack.c (167, 1)
' lstackAdd()
' lstackAdd(L_STACK *, void *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error.</returns>
''' <param name="lstack"> \param[in]    lstack</param>
''' <param name="item"> \param[in]    item to be added to the lstack</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lstackAdd")> _
Friend Shared Function lstackAdd(lstack as IntPTR, item as Object) as Integer
End Function

' SRC\stack.c (197, 1)
' lstackRemove()
' lstackRemove(L_STACK *) as void *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to item popped from the top of the lstack,</returns>
''' <param name="lstack"> \param[in]    lstack</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lstackRemove")> _
Friend Shared Function lstackRemove(lstack as IntPTR) as String
End Function

' SRC\stack.c (247, 1)
' lstackGetCount()
' lstackGetCount(L_STACK *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  count, or 0 on error</returns>
''' <param name="lstack"> \param[in]    lstack</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lstackGetCount")> _
Friend Shared Function lstackGetCount(lstack as IntPTR) as Integer
End Function

' SRC\stack.c (270, 1)
' lstackPrint()
' lstackPrint(FILE *, L_STACK *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="lstack"> \param[in]    lstack</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lstackPrint")> _
Friend Shared Function lstackPrint(fp as Object, lstack as IntPTR) as Integer
End Function

#End Region
#Region "SRC\stringcode.c"
' SRC\stringcode.c (130, 16)
' l_getIndexFromType()
' l_getIndexFromType(const char *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) For valid type, %found == true and %index > 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if found, 1 if not.</returns>
''' <param name="type"> \param[in]    type e.g., "PIXA"</param>
''' <param name="pindex"> \param[out]   pindex found index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_getIndexFromType")> _
Friend Shared Function l_getIndexFromType(type as String, pindex as Integer) as Integer
End Function

' SRC\stringcode.c (131, 16)
' l_getIndexFromStructname()
' l_getIndexFromStructname(const char *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This is used to identify the type of serialized file;
'''  * the first word in the file is the structname.
'''  *   (2) For valid structname, %found == true and %index > 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if found, 1 if not.</returns>
''' <param name="sn"> \param[in]    sn structname e.g., "Pixa"</param>
''' <param name="pindex"> \param[out]   pindex found index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_getIndexFromStructname")> _
Friend Shared Function l_getIndexFromStructname(sn as String, pindex as Integer) as Integer
End Function

' SRC\stringcode.c (132, 16)
' l_getIndexFromFile()
' l_getIndexFromFile(const char *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if found, 1 on error.</returns>
''' <param name="file"> \param[in]    filename</param>
''' <param name="pindex"> \param[out]   pindex found index</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_getIndexFromFile")> _
Friend Shared Function l_getIndexFromFile(file as String, pindex as Integer) as Integer
End Function

' SRC\stringcode.c (133, 14)
' l_genDataString()
' l_genDataString(const char *, l_int32) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  encoded ascii data string, or NULL on error reading from file</returns>
''' <param name="filein"> \param[in]    filein input file of serialized data</param>
''' <param name="ifunc"> \param[in]    ifunc index into set of functions in output file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_genDataString")> _
Friend Shared Function l_genDataString(filein as String, ifunc as Integer) as String
End Function

' SRC\stringcode.c (134, 14)
' l_genCaseString()
' l_genCaseString(l_int32, l_int32) as char *
''' <summary>
''' * Notes:
'''  *   (1) %ifunc and %itype have been validated, so no error can occur
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  case string for this decoding function</returns>
''' <param name="ifunc"> \param[in]    ifunc index into set of functions in generated file</param>
''' <param name="itype"> \param[in]    itype index into type of function to be used</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_genCaseString")> _
Friend Shared Function l_genCaseString(ifunc as Integer, itype as Integer) as String
End Function

' SRC\stringcode.c (135, 14)
' l_genDescrString()
' l_genDescrString(const char *, l_int32, l_int32) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  description string for this decoding function</returns>
''' <param name="filein"> \param[in]    filein input file of serialized data</param>
''' <param name="ifunc"> \param[in]    ifunc index into set of functions in generated file</param>
''' <param name="itype"> \param[in]    itype index into type of function to be used</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_genDescrString")> _
Friend Shared Function l_genDescrString(filein as String, ifunc as Integer, itype as Integer) as String
End Function

' SRC\stringcode.c (156, 1)
' strcodeCreate()
' strcodeCreate(l_int32) as L_STRCODE *
''' <summary>
''' * Notes:
'''  *   (1) This struct exists to build two files containing code for
'''  * any number of data objects.  The two files are named
'''  * autogen.[fileno].c
'''  * autogen.[fileno].h
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  initialized L_StrCode, or NULL on error</returns>
''' <param name="fileno"> \param[in]    fileno integer that labels the two output files</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="strcodeCreate")> _
Friend Shared Function strcodeCreate(fileno as Integer) as IntPTR
End Function

' SRC\stringcode.c (182, 1)
' strcodeDestroy()
' strcodeDestroy(L_STRCODE **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pstrcode"> \param[out]  pstrcode &strcode is set to null after destroying the sarrays</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="strcodeDestroy")> _
Friend Shared Function strcodeDestroy(pstrcode as Object) as Boolean ' Org. Void
End Function

' SRC\stringcode.c (223, 1)
' strcodeCreateFromFile()
' strcodeCreateFromFile(const char *, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The %filein has one filename on each line.
'''  * Comment lines begin with "#".
'''  *   (2) The output is 2 files:
'''  * autogen.[fileno].c
'''  * autogen.[fileno].h
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein containing filenames of serialized data</param>
''' <param name="fileno"> \param[in]    fileno integer that labels the two output files</param>
''' <param name="outdir"> \param[in]    outdir [optional] if null, files are made in /tmp/lept/auto</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="strcodeCreateFromFile")> _
Friend Shared Function strcodeCreateFromFile(filein as String, fileno as Integer, outdir as String) as Integer
End Function

' SRC\stringcode.c (289, 1)
' strcodeGenerate()
' strcodeGenerate(L_STRCODE *, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The generated function name is
'''  *   l_autodecode_[fileno]()
'''  * where [fileno] is the index label for the pair of output files.
'''  *   (2) To deserialize this data, the function is called with the
'''  * argument 'ifunc', which increments each time strcodeGenerate()
'''  * is called.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="strcode"> \param[in]    strcode for accumulating data</param>
''' <param name="filein"> \param[in]    filein input file with serialized data</param>
''' <param name="type"> \param[in]    type of data; use the typedef string</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="strcodeGenerate")> _
Friend Shared Function strcodeGenerate(strcode as IntPTR, filein as String, type as String) as Integer
End Function

' SRC\stringcode.c (336, 1)
' strcodeFinalize()
' strcodeFinalize(L_STRCODE **, const char *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pstrcode"> \param[in,out]  pstrcode destroys after .c and .h files have been generated</param>
''' <param name="outdir"> \param[in]      outdir [optional] if NULL, files are made in /tmp/lept/auto</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="strcodeFinalize")> _
Friend Shared Function strcodeFinalize(pstrcode as Object, outdir as String) as Integer
End Function

' SRC\stringcode.c (525, 1)
' l_getStructStrFromFile()
' l_getStructStrFromFile(const char *, l_int32, char **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) For example, if %field == L_STR_NAME, and the file is a serialized
'''  * pixa, this will return "Pixa", the name of the struct.
'''  *   (2) Caller must free the returned string.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if found, 1 on error.</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="field"> \param[in]    field  (L_STR_TYPE, L_STR_NAME, L_STR_READER, L_STR_MEMREADER)</param>
''' <param name="pstr"> \param[out]   pstr  struct string for this file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_getStructStrFromFile")> _
Friend Shared Function l_getStructStrFromFile(filename as String, field as Integer, pstr as String) as Integer
End Function

#End Region
#Region "SRC\strokes.c"
' SRC\strokes.c (75, 1)
' pixFindStrokeLength()
' pixFindStrokeLength(PIX *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Returns half the number of fg boundary pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="tab8"> \param[in]    tab8  [optional] table for counting fg pixels; can be NULL</param>
''' <param name="plength"> \param[out]  plength  estimated length of the strokes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindStrokeLength")> _
Friend Shared Function pixFindStrokeLength(pixs as IntPTR, tab8 as Integer, plength as Integer) as Integer
End Function

' SRC\strokes.c (123, 1)
' pixFindStrokeWidth()
' pixFindStrokeWidth(PIX *, l_float32, l_int32 *, l_float32 *, NUMA **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This uses two methods to estimate the stroke width:
'''  * (a) half the fg boundary length
'''  * (b) a value derived from the histogram of the fg distance transform
'''  *   (2) Distance is measured in 8-connected
'''  *   (3) %thresh is the minimum fraction N(dist=d)/N(dist=1) of pixels
'''  * required to determine if the pixels at distance d are above
'''  * the noise. It is typically about 0.15.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs 1 bpp</param>
''' <param name="thresh"> \param[in]    thresh  fractional count threshold relative to distance 1</param>
''' <param name="tab8"> \param[in]    tab8  [optional] table for counting fg pixels; can be NULL</param>
''' <param name="pwidth"> \param[out]  pwidth  estimated width of the strokes</param>
''' <param name="pnahisto"> \param[out]  pnahisto  [optional] histo of pixel distances from bg</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixFindStrokeWidth")> _
Friend Shared Function pixFindStrokeWidth(pixs as IntPTR, thresh as single, tab8 as Integer, pwidth as single, pnahisto as Object) as Integer
End Function

' SRC\strokes.c (208, 1)
' pixaFindStrokeWidth()
' pixaFindStrokeWidth(PIXA *, l_float32, l_int32 *, l_int32) as NUMA *
''' <summary>
''' * Notes:
'''  *   (1) See pixFindStrokeWidth() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  na  array of stroke widths for each pix in %pixa; NULL on error</returns>
''' <param name="pixa"> \param[in]    pixa  of 1 bpp images</param>
''' <param name="thresh"> \param[in]    thresh  fractional count threshold relative to distance 1</param>
''' <param name="tab8"> \param[in]    tab8  [optional] table for counting fg pixels; can be NULL</param>
''' <param name="debug"> \param[in]    debug  1 for debug output; 0 to skip</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaFindStrokeWidth")> _
Friend Shared Function pixaFindStrokeWidth(pixa as IntPTR, thresh as single, tab8 as Integer, debug as Integer) as IntPTR
End Function

' SRC\strokes.c (254, 1)
' pixaModifyStrokeWidth()
' pixaModifyStrokeWidth(PIXA *, l_float32) as PIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa  with modified stroke widths, or NULL on error</returns>
''' <param name="pixas"> \param[in]     pixas  of 1 bpp pix</param>
''' <param name="targetw"> \param[out]    targetw  desired width for strokes in each pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaModifyStrokeWidth")> _
Friend Shared Function pixaModifyStrokeWidth(pixas as IntPTR, targetw as single) as IntPTR
End Function

' SRC\strokes.c (298, 1)
' pixModifyStrokeWidth()
' pixModifyStrokeWidth(PIX *, l_float32, l_float32) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix  with modified stroke width, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs  of 1 bpp pix</param>
''' <param name="width"> \param[in]   width  measured average stroke width</param>
''' <param name="targetw"> \param[in]   targetw  desired stroke width</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixModifyStrokeWidth")> _
Friend Shared Function pixModifyStrokeWidth(pixs as IntPTR, width as single, targetw as single) as IntPTR
End Function

' SRC\strokes.c (345, 1)
' pixaSetStrokeWidth()
' pixaSetStrokeWidth(PIXA *, l_int32, l_int32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) If %thinfirst == 1, thin to a skeleton using the specified
'''  * %connectivity.  Use %thinfirst == 0 if all pix in pixas
'''  * have already been thinned as far as possible.
'''  *   (2) The image is dilated to the required %width.  This dilation
'''  * is not connectivity preserving, so this is typically
'''  * used in a situation where merging of c.c. in the individual
'''  * pix is not a problem; e.g., where each pix is a single c.c.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa  with all stroke widths being %width, or NULL on error</returns>
''' <param name="pixas"> \param[in]   pixas  of 1 bpp pix</param>
''' <param name="width"> \param[in]   width  set stroke width to this value, in [1 ... 100].</param>
''' <param name="thinfirst"> \param[in]   thinfirst  1 to thin all pix to a skeleton first; 0 to skip</param>
''' <param name="connectivity"> \param[in]   connectivity  4 or 8, to be used if %thinfirst == 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaSetStrokeWidth")> _
Friend Shared Function pixaSetStrokeWidth(pixas as IntPTR, width as Integer, thinfirst as Integer, connectivity as Integer) as IntPTR
End Function

' SRC\strokes.c (397, 1)
' pixSetStrokeWidth()
' pixSetStrokeWidth(PIX *, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See notes in pixaSetStrokeWidth().
'''  *   (2) A white border of sufficient width to avoid boundary
'''  * artifacts in the thickening step is added before thinning.
'''  *   (3) %connectivity == 8 usually gives a slightly smoother result.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd  with stroke width set to %width, or NULL on error</returns>
''' <param name="pixs"> \param[in]   pixs  1 bpp pix</param>
''' <param name="width"> \param[in]   width  set stroke width to this value, in [1 ... 100].</param>
''' <param name="thinfirst"> \param[in]   thinfirst  1 to thin all pix to a skeleton first; 0 to skip</param>
''' <param name="connectivity"> \param[in]   connectivity  4 or 8, to be used if %thinfirst == 1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetStrokeWidth")> _
Friend Shared Function pixSetStrokeWidth(pixs as IntPTR, width as Integer, thinfirst as Integer, connectivity as Integer) as IntPTR
End Function

#End Region
#Region "SRC\sudoku.c"
' SRC\sudoku.c (144, 16)
' sudokuValidState()
' sudokuValidState(l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This can be used on either the initial state (init)
'''  * or on the current state (state) of the l_soduku.
'''  * All values of 0 are ignored.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if valid, 0 if invalid</returns>
''' <param name="state"> \param[in]    state array of size 81</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sudokuValidState")> _
Friend Shared Function sudokuValidState(state as Integer) as Integer
End Function

' SRC\sudoku.c (145, 16)
' sudokuNewGuess()
' sudokuNewGuess(L_SUDOKU *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This attempts to increment the number in the current
'''  * location.  If it can't, it backtracks (sets the number
'''  * in the current location to zero and decrements the
'''  * current location).  If it can, it tests that number,
'''  * and if the number is valid, moves forward to the next
'''  * empty location (increments the current location).
'''  *   (2) If there is no solution, backtracking will eventually
'''  * exhaust possibilities for the first location.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 if no solution is possible</returns>
''' <param name="sud"> \param[in]    sud l_sudoku</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sudokuNewGuess")> _
Friend Shared Function sudokuNewGuess(sud as IntPTR) as Integer
End Function

' SRC\sudoku.c (146, 16)
' sudokuTestState()
' sudokuTestState(l_int32 *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if valid; 0 if invalid no error checking</returns>
''' <param name="state"> \param[in]    state current state: array of 81 values</param>
''' <param name="index"> \param[in]    index into state element that we are testing</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sudokuTestState")> _
Friend Shared Function sudokuTestState(state as Integer, index as Integer) as Integer
End Function

' SRC\sudoku.c (147, 16)
' sudokuCompareState()
' sudokuCompareState(L_SUDOKU *, L_SUDOKU *, l_int32, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) The input to sud2 has been rotated by %quads relative to the
'''  * input to sud1.  Therefore, we must rotate the solution to
'''  * sud1 by the same amount before comparing it to the
'''  * solution to sud2.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sud1"> \param[in]    sud1, sud2</param>
''' <param name="sud2"> \param[in]    quads rotation of sud2 input with respect to sud1,</param>
''' <param name="quads"> \param[out]   psame 1 if all 4 results are identical; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sudokuCompareState")> _
Friend Shared Function sudokuCompareState(sud1 as IntPTR, sud2 as IntPTR, quads as Integer, psame as Integer) as Integer
End Function

' SRC\sudoku.c (149, 17)
' sudokuRotateArray()
' sudokuRotateArray(l_int32 *, l_int32) as l_int32 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  rarray rotated array, or NULL on error</returns>
''' <param name="array"> \param[in]    array of 81 numbers; 9 lines of 9 numbers each</param>
''' <param name="quads"> \param[in]    quads 1-3; number of 90 degree cw rotations</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sudokuRotateArray")> _
Friend Shared Function sudokuRotateArray(array as Integer, quads as Integer) as String
End Function

' SRC\sudoku.c (181, 1)
' sudokuReadFile()
' sudokuReadFile(const char *) as l_int32 *
''' <summary>
''' * Notes:
'''  *   (1) The file format has:
'''  * * any number of comment lines beginning with '#'
'''  * * a set of 9 lines, each having 9 digits (0-9) separated
'''  *   by a space
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  array of 81 numbers, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename of formatted sudoku file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sudokuReadFile")> _
Friend Shared Function sudokuReadFile(filename as String) as String
End Function

' SRC\sudoku.c (260, 1)
' sudokuReadString()
' sudokuReadString(const char *) as l_int32 *
''' <summary>
''' * Notes:
'''  *   (1) The string is formatted as 81 single digits, each separated
'''  * by 81 spaces.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  array of 81 numbers, or NULL on error</returns>
''' <param name="str"> \param[in]    str of input data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sudokuReadString")> _
Friend Shared Function sudokuReadString(str as String) as String
End Function

' SRC\sudoku.c (301, 1)
' sudokuCreate()
' sudokuCreate(l_int32 *) as L_SUDOKU *
''' <summary>
''' * Notes:
'''  *   (1) The input array has 0 for the unknown values, and 1-9
'''  * for the known initial values.  It is generated from
'''  * a file using sudokuReadInput(), which checks that the file
'''  * data has 81 numbers in 9 rows.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  l_sudoku, or NULL on error</returns>
''' <param name="array"> \param[in]    array of 81 numbers, 9 rows of 9 numbers each</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sudokuCreate")> _
Friend Shared Function sudokuCreate(array as Integer) as IntPTR
End Function

' SRC\sudoku.c (337, 1)
' sudokuDestroy()
' sudokuDestroy(L_SUDOKU **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="psud"> \param[in,out]   psud to be nulled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sudokuDestroy")> _
Friend Shared Function sudokuDestroy(psud as Object) as Boolean ' Org. Void
End Function

' SRC\sudoku.c (371, 1)
' sudokuSolve()
' sudokuSolve(L_SUDOKU *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 on success, 0 on failure to solve note reversal of</returns>
''' <param name="sud"> \param[in]    sud l_sudoku starting in initial state</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sudokuSolve")> _
Friend Shared Function sudokuSolve(sud as IntPTR) as Integer
End Function

' SRC\sudoku.c (562, 1)
' sudokuTestUniqueness()
' sudokuTestUniqueness(l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This applies the brute force method to all four 90 degree
'''  * rotations.  If there is more than one solution, it is highly
'''  * unlikely that all four results will be the same;
'''  * consequently, if they are the same, the solution is
'''  * most likely to be unique.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="array"> \param[in]    array of 81 numbers, 9 lines of 9 numbers each</param>
''' <param name="punique"> \param[out]   punique 1 if unique, 0 if not</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sudokuTestUniqueness")> _
Friend Shared Function sudokuTestUniqueness(array as Integer, punique as Integer) as Integer
End Function

' SRC\sudoku.c (731, 1)
' sudokuGenerate()
' sudokuGenerate(l_int32 *, l_int32, l_int32, l_int32) as L_SUDOKU *
''' <summary>
''' * Notes:
'''  *   (1) This is a brute force generator.  It starts with a completed
'''  * sudoku solution and, by removing elements (setting them to 0),
'''  * generates a valid (unique) sudoku initial condition.
'''  *   (2) The process stops when either %minelems, the minimum
'''  * number of non-zero elements, is reached, or when the
'''  * number of attempts to remove the next element exceeds %maxtries.
'''  *   (3) No sudoku is known with less than 17 nonzero elements.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  l_sudoku, or NULL on error</returns>
''' <param name="array"> \param[in]    array of 81 numbers, 9 rows of 9 numbers each</param>
''' <param name="seed"> \param[in]    seed random number</param>
''' <param name="minelems"> \param[in]    minelems min non-zero elements allowed; <= 80</param>
''' <param name="maxtries"> \param[in]    maxtries max tries to remove a number and get a valid sudoku</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sudokuGenerate")> _
Friend Shared Function sudokuGenerate(array as Integer, seed as Integer, minelems as Integer, maxtries as Integer) as IntPTR
End Function

' SRC\sudoku.c (854, 1)
' sudokuOutput()
' sudokuOutput(L_SUDOKU *, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Prints either the initial array or the current state
'''  * of the solution.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="sud"> \param[in]    sud l_sudoku at any stage</param>
''' <param name="arraytype"> \param[in]    arraytype L_SUDOKU_INIT, L_SUDOKU_STATE</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="sudokuOutput")> _
Friend Shared Function sudokuOutput(sud as IntPTR, arraytype as Integer) as Integer
End Function

#End Region
#Region "SRC\textops.c"
' SRC\textops.c (78, 16)
' stringAllWhitespace()
' stringAllWhitespace(char *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="textstr"> \param[in]    textstr text string</param>
''' <param name="pval"> \param[out]   pval 1 if all whitespace; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringAllWhitespace")> _
Friend Shared Function stringAllWhitespace(textstr as Object, pval as Integer) as Integer
End Function

' SRC\textops.c (79, 16)
' stringLeadingWhitespace()
' stringLeadingWhitespace(char *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="textstr"> \param[in]    textstr text string</param>
''' <param name="pval"> \param[out]   pval 1 if leading char is [space] or [tab]; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringLeadingWhitespace")> _
Friend Shared Function stringLeadingWhitespace(textstr as Object, pval as Integer) as Integer
End Function

' SRC\textops.c (115, 1)
' pixAddSingleTextblock()
' pixAddSingleTextblock(PIX *, L_BMF *, const char *, l_uint32, l_int32, l_int32 *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function paints a set of lines of text over an image.
'''  * If %location is L_ADD_ABOVE or L_ADD_BELOW, the pix size
'''  * is expanded with a border and rendered over the border.
'''  *   (2) %val is the pixel value to be painted through the font mask.
'''  * It should be chosen to agree with the depth of pixs.
'''  * If it is out of bounds, an intermediate value is chosen.
'''  * For RGB, use hex notation: 0xRRGGBB00, where RR is the
'''  * hex representation of the red intensity, etc.
'''  *   (3) If textstr == NULL, use the text field in the pix.
'''  *   (4) If there is a colormap, this does the best it can to use
'''  * the requested color, or something similar to it.
'''  *   (5) Typical usage is for labelling a pix with some text data.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd new pix with rendered text, or either a copy</returns>
''' <param name="pixs"> \param[in]    pixs input pix; colormap ok</param>
''' <param name="bmf"> \param[in]    bmf bitmap font data</param>
''' <param name="textstr"> \param[in]    textstr [optional] text string to be added</param>
''' <param name="val"> \param[in]    val color to set the text</param>
''' <param name="location"> \param[in]    location L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW</param>
''' <param name="poverflow"> \param[out]   poverflow [optional] 1 if text overflows</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddSingleTextblock")> _
Friend Shared Function pixAddSingleTextblock(pixs as IntPTR, bmf as IntPTR, textstr as String, val as UInteger, location as Integer, poverflow as Integer) as IntPTR
End Function

' SRC\textops.c (270, 1)
' pixAddTextlines()
' pixAddTextlines(PIX *, L_BMF *, const char *, l_uint32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function expands an image as required to paint one or
'''  * more lines of text adjacent to the image.  If %bmf == NULL,
'''  * this returns a copy.  If above or below, the lines are
'''  * centered with respect to the image; if left or right, they
'''  * are left justified.
'''  *   (2) %val is the pixel value to be painted through the font mask.
'''  * It should be chosen to agree with the depth of pixs.
'''  * If it is out of bounds, an intermediate value is chosen.
'''  * For RGB, use hex notation: 0xRRGGBB00, where RR is the
'''  * hex representation of the red intensity, etc.
'''  *   (3) If textstr == NULL, use the text field in the pix.  The
'''  * text field contains one or most "lines" of text, where newlines
'''  * are used as line separators.
'''  *   (4) If there is a colormap, this does the best it can to use
'''  * the requested color, or something similar to it.
'''  *   (5) Typical usage is for labelling a pix with some text data.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd new pix with rendered text, or either a copy</returns>
''' <param name="pixs"> \param[in]    pixs input pix; colormap ok</param>
''' <param name="bmf"> \param[in]    bmf bitmap font data</param>
''' <param name="textstr"> \param[in]    textstr [optional] text string to be added</param>
''' <param name="val"> \param[in]    val color to set the text</param>
''' <param name="location"> \param[in]    location L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixAddTextlines")> _
Friend Shared Function pixAddTextlines(pixs as IntPTR, bmf as IntPTR, textstr as String, val as UInteger, location as Integer) as IntPTR
End Function

' SRC\textops.c (431, 1)
' pixSetTextblock()
' pixSetTextblock(PIX *, L_BMF *, const char *, l_uint32, l_int32, l_int32, l_int32, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function paints a set of lines of text over an image.
'''  *   (2) %val is the pixel value to be painted through the font mask.
'''  * It should be chosen to agree with the depth of pixs.
'''  * If it is out of bounds, an intermediate value is chosen.
'''  * For RGB, use hex notation: 0xRRGGBB00, where RR is the
'''  * hex representation of the red intensity, etc.
'''  * The last two hex digits are 00 (byte value 0), assigned to
'''  * the A component.  Note that, as usual, RGBA proceeds from
'''  * left to right in the order from MSB to LSB (see pix.h
'''  * for details).
'''  *   (3) If there is a colormap, this does the best it can to use
'''  * the requested color, or something similar to it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs input image</param>
''' <param name="bmf"> \param[in]    bmf bitmap font data</param>
''' <param name="textstr"> \param[in]    textstr block text string to be set</param>
''' <param name="val"> \param[in]    val color to set the text</param>
''' <param name="x0"> \param[in]    x0 left edge for each line of text</param>
''' <param name="y0"> \param[in]    y0 baseline location for the first text line</param>
''' <param name="wtext"> \param[in]    wtext max width of each line of generated text</param>
''' <param name="firstindent"> \param[in]    firstindent indentation of first line, in x-widths</param>
''' <param name="poverflow"> \param[out]   poverflow [optional] 0 if text is contained in</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetTextblock")> _
Friend Shared Function pixSetTextblock(pixs as IntPTR, bmf as IntPTR, textstr as String, val as UInteger, x0 as Integer, y0 as Integer, wtext as Integer, firstindent as Integer, poverflow as Integer) as Integer
End Function

' SRC\textops.c (544, 1)
' pixSetTextline()
' pixSetTextline(PIX *, L_BMF *, const char *, l_uint32, l_int32, l_int32, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function paints a line of text over an image.
'''  *   (2) %val is the pixel value to be painted through the font mask.
'''  * It should be chosen to agree with the depth of pixs.
'''  * If it is out of bounds, an intermediate value is chosen.
'''  * For RGB, use hex notation: 0xRRGGBB00, where RR is the
'''  * hex representation of the red intensity, etc.
'''  * The last two hex digits are 00 (byte value 0), assigned to
'''  * the A component.  Note that, as usual, RGBA proceeds from
'''  * left to right in the order from MSB to LSB (see pix.h
'''  * for details).
'''  *   (3) If there is a colormap, this does the best it can to use
'''  * the requested color, or something similar to it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pixs"> \param[in]    pixs input image</param>
''' <param name="bmf"> \param[in]    bmf bitmap font data</param>
''' <param name="textstr"> \param[in]    textstr text string to be set on the line</param>
''' <param name="val"> \param[in]    val color to set the text</param>
''' <param name="x0"> \param[in]    x0 left edge for first char</param>
''' <param name="y0"> \param[in]    y0 baseline location for all text on line</param>
''' <param name="pwidth"> \param[out]   pwidth [optional] width of generated text</param>
''' <param name="poverflow"> \param[out]   poverflow [optional] 0 if text is contained in</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSetTextline")> _
Friend Shared Function pixSetTextline(pixs as IntPTR, bmf as IntPTR, textstr as String, val as UInteger, x0 as Integer, y0 as Integer, pwidth as Integer, poverflow as Integer) as Integer
End Function

' SRC\textops.c (641, 1)
' pixaAddTextNumber()
' pixaAddTextNumber(PIXA *, L_BMF *, NUMA *, l_uint32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) Typical usage is for labelling each pix in a pixa with a number.
'''  *   (2) This function paints numbers external to each pix, in a position
'''  * given by %location.  In all cases, the pix is expanded on
'''  * on side and the number is painted over white in the added region.
'''  *   (3) %val is the pixel value to be painted through the font mask.
'''  * It should be chosen to agree with the depth of pixs.
'''  * If it is out of bounds, an intermediate value is chosen.
'''  * For RGB, use hex notation: 0xRRGGBB00, where RR is the
'''  * hex representation of the red intensity, etc.
'''  *   (4) If na == NULL, number each pix sequentially, starting with 1.
'''  *   (5) If there is a colormap, this does the best it can to use
'''  * the requested color, or something similar to it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad new pixa with rendered numbers, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas input pixa; colormap ok</param>
''' <param name="bmf"> \param[in]    bmf bitmap font data</param>
''' <param name="na"> \param[in]    na [optional] number array; use 1 ... n if null</param>
''' <param name="val"> \param[in]    val color to set the text</param>
''' <param name="location"> \param[in]    location L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaAddTextNumber")> _
Friend Shared Function pixaAddTextNumber(pixas as IntPTR, bmf as IntPTR, na as IntPTR, val as UInteger, location as Integer) as IntPTR
End Function

' SRC\textops.c (710, 1)
' pixaAddTextlines()
' pixaAddTextlines(PIXA *, L_BMF *, SARRAY *, l_uint32, l_int32) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This function adds one or more lines of text externally to
'''  * each pix, in a position given by %location.  In all cases,
'''  * the pix is expanded as necessary to accommodate the text.
'''  *   (2) %val is the pixel value to be painted through the font mask.
'''  * It should be chosen to agree with the depth of pixs.
'''  * If it is out of bounds, an intermediate value is chosen.
'''  * For RGB, use hex notation: 0xRRGGBB00, where RR is the
'''  * hex representation of the red intensity, etc.
'''  *   (3) If sa == NULL, use the text embedded in each pix.  In all
'''  * cases, newlines in the text string are used to separate the
'''  * lines of text that are added to the pix.
'''  *   (4) If sa has a smaller count than pixa, issue a warning
'''  * and do not use any embedded text.
'''  *   (5) If there is a colormap, this does the best it can to use
'''  * the requested color, or something similar to it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixad new pixa with rendered text, or NULL on error</returns>
''' <param name="pixas"> \param[in]    pixas input pixa; colormap ok</param>
''' <param name="bmf"> \param[in]    bmf bitmap font data</param>
''' <param name="sa"> \param[in]    sa [optional] sarray; use text embedded in each pix if null</param>
''' <param name="val"> \param[in]    val color to set the text</param>
''' <param name="location"> \param[in]    location L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaAddTextlines")> _
Friend Shared Function pixaAddTextlines(pixas as IntPTR, bmf as IntPTR, sa as IntPTR, val as UInteger, location as Integer) as IntPTR
End Function

' SRC\textops.c (780, 1)
' pixaAddPixWithText()
' pixaAddPixWithText(PIXA *, PIX *, l_int32, L_BMF *, const char *, l_uint32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This function generates a new pix with added text, and adds
'''  * it by insertion into the pixa.
'''  *   (2) If the input pixs is not cmapped and not 32 bpp, it is
'''  * converted to 32 bpp rgb.  %val is a standard 32 bpp pixel,
'''  * expressed as 0xrrggbb00.  If there is a colormap, this does
'''  * the best it can to use the requested color, or something close.
'''  *   (3) if %bmf == NULL, generate an 8 pt font; this takes about 5 msec.
'''  *   (4) If %textstr == NULL, use the text field in the pix.
'''  *   (5) In general, the text string can be written in multiple lines;
'''  * use newlines as the separators.
'''  *   (6) Typical usage is for debugging, where the pixa of labeled images
'''  * is used to generate a pdf.  Suggest using 1.0 for scalefactor.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="pixs"> \param[in]    pixs any depth, colormap ok</param>
''' <param name="reduction"> \param[in]    reduction integer subsampling factor</param>
''' <param name="bmf"> \param[in]    bmf [optional] bitmap font data</param>
''' <param name="textstr"> \param[in]    textstr [optional] text string to be added</param>
''' <param name="val"> \param[in]    val color to set the text</param>
''' <param name="location"> \param[in]    location L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaAddPixWithText")> _
Friend Shared Function pixaAddPixWithText(pixa as IntPTR, pixs as IntPTR, reduction as Integer, bmf as IntPTR, textstr as String, val as UInteger, location as Integer) as Integer
End Function

' SRC\textops.c (862, 1)
' bmfGetLineStrings()
' bmfGetLineStrings(L_BMF *, const char *, l_int32, l_int32, l_int32 *) as SARRAY *
''' <summary>
''' * Notes:
'''  *   (1) Divides the input text string into an array of text strings,
'''  * each of which will fit within maxw bits of width.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sarray of text strings for each line, or NULL on error</returns>
''' <param name="bmf"> \param[in]    bmf</param>
''' <param name="textstr"> \param[in]    textstr</param>
''' <param name="maxw"> \param[in]    maxw max width of a text line in pixels</param>
''' <param name="firstindent"> \param[in]    firstindent indentation of first line, in x-widths</param>
''' <param name="ph"> \param[out]   ph height required to hold text bitmap</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bmfGetLineStrings")> _
Friend Shared Function bmfGetLineStrings(bmf as IntPTR, textstr as String, maxw as Integer, firstindent as Integer, ph as Integer) as IntPTR
End Function

' SRC\textops.c (938, 1)
' bmfGetWordWidths()
' bmfGetWordWidths(L_BMF *, const char *, SARRAY *) as NUMA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  numa of word lengths in pixels for the font represented</returns>
''' <param name="bmf"> \param[in]    bmf</param>
''' <param name="textstr"> \param[in]    textstr</param>
''' <param name="sa"> \param[in]    sa of individual words</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bmfGetWordWidths")> _
Friend Shared Function bmfGetWordWidths(bmf as IntPTR, textstr as String, sa as IntPTR) as IntPTR
End Function

' SRC\textops.c (979, 1)
' bmfGetStringWidth()
' bmfGetStringWidth(L_BMF *, const char *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="bmf"> \param[in]    bmf</param>
''' <param name="textstr"> \param[in]    textstr</param>
''' <param name="pw"> \param[out]   pw width of text string, in pixels for the</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="bmfGetStringWidth")> _
Friend Shared Function bmfGetStringWidth(bmf as IntPTR, textstr as String, pw as Integer) as Integer
End Function

' SRC\textops.c (1023, 1)
' splitStringToParagraphs()
' splitStringToParagraphs(char *, l_int32) as SARRAY *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  sarray where each string is a paragraph of the input,</returns>
''' <param name="textstr"> \param[in]    textstr text string</param>
''' <param name="splitflag"> \param[in]    splitflag see enum in bmf.h; valid values in {1,2,3}</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="splitStringToParagraphs")> _
Friend Shared Function splitStringToParagraphs(textstr as Object, splitflag as Integer) as IntPTR
End Function

#End Region
#Region "SRC\tiffio.c"
' SRC\tiffio.c (125, 18)
' 
' pixReadFromTiffStream(int *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadFromTiffStream")> _
Friend Shared Function pixReadFromTiffStream(tif as Object) as IntPTR
End Function

' SRC\tiffio.c (126, 18)
' 
' getTiffStreamResolution(int *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getTiffStreamResolution")> _
Friend Shared Function getTiffStreamResolution(tif as Object, pxres as Integer, pyres as Integer) as Integer
End Function

' SRC\tiffio.c (128, 18)
' 
' tiffReadHeaderTiff(int *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="tiffReadHeaderTiff")> _
Friend Shared Function tiffReadHeaderTiff(tif as Object, pwidth as Integer, pheight as Integer, pbps as Integer, pspp as Integer, pres as Integer, pcmap as Integer, pformat as Integer) as Integer
End Function

' SRC\tiffio.c (132, 18)
' 
' writeCustomTiffTags(int *, NUMA *, SARRAY *, SARRAY *, NUMA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="writeCustomTiffTags")> _
Friend Shared Function writeCustomTiffTags(tif as Object, natags as IntPTR, savals as IntPTR, satypes as IntPTR, nasizes as IntPTR) as Integer
End Function

' SRC\tiffio.c (135, 18)
' 
' pixWriteToTiffStream(int *, PIX *, l_int32, NUMA *, SARRAY *, SARRAY *, NUMA *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteToTiffStream")> _
Friend Shared Function pixWriteToTiffStream(tif as Object, pix as IntPTR, comptype as Integer, natags as IntPTR, savals as IntPTR, satypes as IntPTR, nasizes as IntPTR) as Integer
End Function

' SRC\tiffio.c (138, 18)
' 
' fopenTiff(FILE *, const char *) as int *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fopenTiff")> _
Friend Shared Function fopenTiff(fp as Object, modestring as String) as String
End Function

' SRC\tiffio.c (139, 18)
' 
' openTiff(const char *, const char *) as int *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="openTiff")> _
Friend Shared Function openTiff(filename as String, modestring as String) as String
End Function

' SRC\tiffio.c (142, 18)
' getTiffCompressedFormat()
' getTiffCompressedFormat(l_uint16) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) The input must be the actual tiff compression type
'''  * returned by a tiff library call.  It should always be
'''  * a valid tiff type.
'''  *   (2) The return type is defined in the enum in imageio.h.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  compression format defined in imageio.h</returns>
''' <param name="tiffcomp"> \param[in]    tiffcomp    defined in tiff.h</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getTiffCompressedFormat")> _
Friend Shared Function getTiffCompressedFormat(tiffcomp as UShort) as Integer
End Function

' SRC\tiffio.c (145, 18)
' 
' fopenTiffMemstream(const char *, const char *, l_uint8 **, size_t *) as int *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fopenTiffMemstream")> _
Friend Shared Function fopenTiffMemstream(filename as String, operation as String, pdata as Object, pdatasize as ULong) as String
End Function

' SRC\tiffio.c (149, 14)
' 
' dummyHandler(const char *, const char *, va_list) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="dummyHandler")> _
Friend Shared Function dummyHandler(_module_ as String, fmt as String, ap as Object) as Boolean ' Org. Void
End Function

' SRC\tiffio.c (210, 1)
' 
' lept_read_proc(int, int, int) as int
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_read_proc")> _
Friend Shared Function lept_read_proc(cookie as Object, buff as Object, size as Object) as Integer
End Function

' SRC\tiffio.c (223, 1)
' 
' lept_write_proc(int, int, int) as int
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_write_proc")> _
Friend Shared Function lept_write_proc(cookie as Object, buff as Object, size as Object) as Integer
End Function

' SRC\tiffio.c (236, 1)
' 
' lept_seek_proc(int, int, int) as int
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_seek_proc")> _
Friend Shared Function lept_seek_proc(cookie as Object, offs as Object, whence as Object) as Integer
End Function

' SRC\tiffio.c (306, 1)
' 
' lept_close_proc(int) as int
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_close_proc")> _
Friend Shared Function lept_close_proc(cookie as Object) as Integer
End Function

' SRC\tiffio.c (316, 1)
' 
' lept_size_proc(int) as int
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_size_proc")> _
Friend Shared Function lept_size_proc(cookie as Object) as Integer
End Function

' SRC\tiffio.c (371, 1)
' pixReadTiff()
' pixReadTiff(const char *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a version of pixRead(), specialized for tiff
'''  * files, that allows specification of the page to be returned
'''  *   (2) No warning messages on failure, because of how multi-page
'''  * TIFF reading works. You are supposed to keep trying until
'''  * it stops working.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="n"> \param[in]    n           page number 0 based</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadTiff")> _
Friend Shared Function pixReadTiff(filename as String, n as Integer) as IntPTR
End Function

' SRC\tiffio.c (408, 1)
' pixReadStreamTiff()
' pixReadStreamTiff(FILE *, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) No warning messages on failure, because of how multi-page
'''  * TIFF reading works. You are supposed to keep trying until
'''  * it stops working.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error or if there are no more images in the file</returns>
''' <param name="fp"> \param[in]    fp    file stream</param>
''' <param name="n"> \param[in]    n     page number: 0 based</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadStreamTiff")> _
Friend Shared Function pixReadStreamTiff(fp as Object, n as Integer) as IntPTR
End Function

' SRC\tiffio.c (654, 1)
' pixWriteTiff()
' pixWriteTiff(const char *, PIX *, l_int32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For multipage tiff, write the first pix with mode "w" and
'''  * all subsequent pix with mode "a".
'''  *   (2) For multipage tiff, there is considerable overhead in the
'''  * machinery to append an image and add the directory entry,
'''  * and the time required for each image increases linearly
'''  * with the number of images in the file.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename   to write to</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="comptype"> \param[in]    comptype   IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,</param>
''' <param name="modestr"> \param[in]    modestr    "a" or "w"</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteTiff")> _
Friend Shared Function pixWriteTiff(filename as String, pix as IntPTR, comptype as Integer, modestr as String) as Integer
End Function

' SRC\tiffio.c (711, 1)
' pixWriteTiffCustom()
' pixWriteTiffCustom(const char *, PIX *, l_int32, const char *, NUMA *, SARRAY *, SARRAY *, NUMA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename   to write to</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="comptype"> \param[in]    comptype   IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,</param>
''' <param name="modestr"> \param[in]    modestr    "a" or "w"</param>
''' <param name="natags"> \param[in]    natags [optional] NUMA of custom tiff tags</param>
''' <param name="savals"> \param[in]    savals [optional] SARRAY of values</param>
''' <param name="satypes"> \param[in]    satypes [optional] SARRAY of types</param>
''' <param name="nasizes"> \param[in]    nasizes [optional] NUMA of sizes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteTiffCustom")> _
Friend Shared Function pixWriteTiffCustom(filename as String, pix as IntPTR, comptype as Integer, modestr as String, natags as IntPTR, savals as IntPTR, satypes as IntPTR, nasizes as IntPTR) as Integer
End Function

' SRC\tiffio.c (770, 1)
' pixWriteStreamTiff()
' pixWriteStreamTiff(FILE *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This writes a single image to a file stream opened for writing.
'''  *   (2) For images with bpp > 1, this resets the comptype, if
'''  * necessary, to write uncompressed data.
'''  *   (3) G3 and G4 are only defined for 1 bpp.
'''  *   (4) We only allow PACKBITS for bpp = 1, because for bpp > 1
'''  * it typically expands images that are not synthetically generated.
'''  *   (5) G4 compression is typically about twice as good as G3.
'''  * G4 is excellent for binary compression of text/line-art,
'''  * but terrible for halftones and dithered patterns.  (In
'''  * fact, G4 on halftones can give a file that is larger
'''  * than uncompressed!)  If a binary image has dithered
'''  * regions, it is usually better to compress with png.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp       file stream</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="comptype"> \param[in]    comptype IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamTiff")> _
Friend Shared Function pixWriteStreamTiff(fp as Object, pix as IntPTR, comptype as Integer) as Integer
End Function

' SRC\tiffio.c (790, 1)
' pixWriteStreamTiffWA()
' pixWriteStreamTiffWA(FILE *, PIX *, l_int32, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp       file stream opened for append or write</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="comptype"> \param[in]    comptype IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,</param>
''' <param name="modestr"> \param[in]    modestr  "w" or "a"</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamTiffWA")> _
Friend Shared Function pixWriteStreamTiffWA(fp as Object, pix as IntPTR, comptype as Integer, modestr as String) as Integer
End Function

' SRC\tiffio.c (1177, 1)
' pixReadFromMultipageTiff()
' pixReadFromMultipageTiff(const char *, size_t *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This allows overhead for traversal of a multipage tiff file
'''  * to be linear in the number of images.  This will also work
'''  * with a singlepage tiff file.
'''  *   (2) No TIFF internal data structures are exposed to the caller
'''  * (thanks to Jeff Breidenbach).
'''  *   (3) offset is the byte offset of a particular image in a multipage
'''  * tiff file. To get the first image in the file, input the
'''  * special offset value of 0.
'''  *   (4) The offset is updated to point to the next image, for a
'''  * subsequent call.
'''  *   (5) On the last image, the offset returned is 0.  Exit the loop
'''  * when the returned offset is 0.
'''  *   (6) For reading a multipage tiff from a memory buffer, see
'''  *   pixReadMemFromMultipageTiff()
'''  *   (7) Example usage for reading all the images in the tif file:
'''  *   size_t offset = 0;
'''  *   do {
'''  * Pix *pix = pixReadFromMultipageTiff(filename, &offset);
'''  * // do something with pix
'''  *   } while (offset != 0);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error or if previous call returned the last image</returns>
''' <param name="fname"> \param[in]      fname     filename</param>
''' <param name="poffset"> \param[in,out]  poffset   set offset to 0 for first image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadFromMultipageTiff")> _
Friend Shared Function pixReadFromMultipageTiff(fname as String, poffset as ULong) as IntPTR
End Function

' SRC\tiffio.c (1226, 1)
' pixaReadMultipageTiff()
' pixaReadMultipageTiff(const char *) as PIXA *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa of page images, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename    input tiff file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaReadMultipageTiff")> _
Friend Shared Function pixaReadMultipageTiff(filename as String) as IntPTR
End Function

' SRC\tiffio.c (1286, 1)
' pixaWriteMultipageTiff()
' pixaWriteMultipageTiff(const char *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The tiff directory overhead is O(n^2).  I have not been
'''  * able to reduce it to O(n).  The overhead for n = 2000 is
'''  * about 1 second.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fname"> \param[in]    fname      input tiff file</param>
''' <param name="pixa"> \param[in]    pixa       any depth; colormap will be removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaWriteMultipageTiff")> _
Friend Shared Function pixaWriteMultipageTiff(fname as String, pixa as IntPTR) as Integer
End Function

' SRC\tiffio.c (1347, 1)
' writeMultipageTiff()
' writeMultipageTiff(const char *, const char *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This writes a set of image files in a directory out
'''  * as a multipage tiff file.  The images can be in any
'''  * initial file format.
'''  *   (2) Images with a colormap have the colormap removed before
'''  * re-encoding as tiff.
'''  *   (3) All images are encoded losslessly.  Those with 1 bpp are
'''  * encoded 'g4'.  The rest are encoded as 'zip' (flate encoding).
'''  * Because it is lossless, this is an expensive method for
'''  * saving most rgb images.
'''  *   (4) The tiff directory overhead is quadratic in the number of
'''  * images.  To avoid this for very large numbers of images to be
'''  * written, apply the method used in pixaWriteMultipageTiff().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dirin"> \param[in]    dirin   input directory</param>
''' <param name="substr"> \param[in]    substr  [optional] substring filter on filenames; can be NULL</param>
''' <param name="fileout"> \param[in]    fileout output multipage tiff file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="writeMultipageTiff")> _
Friend Shared Function writeMultipageTiff(dirin as String, substr as String, fileout as String) as Integer
End Function

' SRC\tiffio.c (1383, 1)
' writeMultipageTiffSA()
' writeMultipageTiffSA(SARRAY *, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See writeMultipageTiff()
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="sa"> \param[in]    sa       string array of full path names</param>
''' <param name="fileout"> \param[in]    fileout  output ps file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="writeMultipageTiffSA")> _
Friend Shared Function writeMultipageTiffSA(sa as IntPTR, fileout as String) as Integer
End Function

' SRC\tiffio.c (1443, 1)
' fprintTiffInfo()
' fprintTiffInfo(FILE *, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fpout"> \param[in]    fpout    stream for output of tag data</param>
''' <param name="tiffile"> \param[in]    tiffile  input</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fprintTiffInfo")> _
Friend Shared Function fprintTiffInfo(fpout as Object, tiffile as String) as Integer
End Function

' SRC\tiffio.c (1476, 1)
' tiffGetCount()
' tiffGetCount(FILE *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]    fp   file stream opened for read</param>
''' <param name="pn"> \param[out]   pn   number of images</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="tiffGetCount")> _
Friend Shared Function tiffGetCount(fp as Object, pn as Integer) as Integer
End Function

' SRC\tiffio.c (1524, 1)
' getTiffResolution()
' getTiffResolution(FILE *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If neither resolution field is set, this is not an error;
'''  * the returned resolution values are 0 (designating 'unknown').
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fp"> \param[in]    fp            file stream opened for read</param>
''' <param name="pxres"> \param[out]   pxres, pyres  resolution in ppi</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getTiffResolution")> _
Friend Shared Function getTiffResolution(fp as Object, pxres as Integer, pyres as Integer) as Integer
End Function

' SRC\tiffio.c (1621, 1)
' readHeaderTiff()
' readHeaderTiff(const char *, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If there is a colormap, cmap is returned as 1; else 0.
'''  *   (2) If %n is equal to or greater than the number of images, returns 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="n"> \param[in]    n          page image number: 0-based</param>
''' <param name="pw"> \param[out]   pw         [optional] width</param>
''' <param name="ph"> \param[out]   ph         [optional] height</param>
''' <param name="pbps"> \param[out]   pbps       [optional] bits per sample -- 1, 2, 4 or 8</param>
''' <param name="pspp"> \param[out]   pspp       [optional] samples per pixel -- 1 or 3</param>
''' <param name="pres"> \param[out]   pres       [optional] resolution in x dir; NULL to ignore</param>
''' <param name="pcmap"> \param[out]   pcmap      [optional] colormap exists; input NULL to ignore</param>
''' <param name="pformat"> \param[out]   pformat    [optional] tiff format; input NULL to ignore</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readHeaderTiff")> _
Friend Shared Function readHeaderTiff(filename as String, n as Integer, pw as Integer, ph as Integer, pbps as Integer, pspp as Integer, pres as Integer, pcmap as Integer, pformat as Integer) as Integer
End Function

' SRC\tiffio.c (1677, 1)
' freadHeaderTiff()
' freadHeaderTiff(FILE *, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If there is a colormap, cmap is returned as 1; else 0.
'''  *   (2) If %n is equal to or greater than the number of images, returns 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp       file stream</param>
''' <param name="n"> \param[in]    n        page image number: 0-based</param>
''' <param name="pw"> \param[out]   pw       [optional] width</param>
''' <param name="ph"> \param[out]   ph       [optional] height</param>
''' <param name="pbps"> \param[out]   pbps     [optional] bits per sample -- 1, 2, 4 or 8</param>
''' <param name="pspp"> \param[out]   pspp     [optional] samples per pixel -- 1 or 3</param>
''' <param name="pres"> \param[out]   pres     [optional] resolution in x dir; NULL to ignore</param>
''' <param name="pcmap"> \param[out]   pcmap    [optional] colormap exists; input NULL to ignore</param>
''' <param name="pformat"> \param[out]   pformat  [optional] tiff format; input NULL to ignore</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="freadHeaderTiff")> _
Friend Shared Function freadHeaderTiff(fp as Object, n as Integer, pw as Integer, ph as Integer, pbps as Integer, pspp as Integer, pres as Integer, pcmap as Integer, pformat as Integer) as Integer
End Function

' SRC\tiffio.c (1748, 1)
' readHeaderMemTiff()
' readHeaderMemTiff(const l_uint8 *, size_t, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="cdata"> \param[in]    cdata     const; tiff-encoded</param>
''' <param name="size"> \param[in]    size      size of data</param>
''' <param name="n"> \param[in]    n         page image number: 0-based</param>
''' <param name="pw"> \param[out]   pw        [optional] width</param>
''' <param name="ph"> \param[out]   ph        [optional] height</param>
''' <param name="pbps"> \param[out]   pbps      [optional] bits per sample -- 1, 2, 4 or 8</param>
''' <param name="pspp"> \param[out]   pspp      [optional] samples per pixel -- 1 or 3</param>
''' <param name="pres"> \param[out]   pres      [optional] resolution in x dir; NULL to ignore</param>
''' <param name="pcmap"> \param[out]   pcmap     [optional] colormap exists; input NULL to ignore</param>
''' <param name="pformat"> \param[out]   pformat   [optional] tiff format; input NULL to ignore</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readHeaderMemTiff")> _
Friend Shared Function readHeaderMemTiff(cdata as Byte, size as ULong, n as Integer, pw as Integer, ph as Integer, pbps as Integer, pspp as Integer, pres as Integer, pcmap as Integer, pformat as Integer) as Integer
End Function

' SRC\tiffio.c (1883, 1)
' findTiffCompression()
' findTiffCompression(FILE *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The returned compression type is that defined in
'''  * the enum in imageio.h.  It is not the tiff flag value.
'''  *   (2) The compression type is initialized to IFF_UNKNOWN.
'''  * If it is not one of the specified types, the returned
'''  * type is IFF_TIFF, which indicates no compression.
'''  *   (3) When this function is called, the stream must be at BOF.
'''  * If the opened stream is to be used again to read the
'''  * file, it must be rewound to BOF after calling this function.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp         file stream; must be rewound to BOF</param>
''' <param name="pcomptype"> \param[out]   pcomptype  compression type</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="findTiffCompression")> _
Friend Shared Function findTiffCompression(fp as Object, pcomptype as Integer) as Integer
End Function

' SRC\tiffio.c (1968, 1)
' extractG4DataFromFile()
' extractG4DataFromFile(const char *, l_uint8 **, size_t *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein</param>
''' <param name="pdata"> \param[out]   pdata         binary data of ccitt g4 encoded stream</param>
''' <param name="pnbytes"> \param[out]   pnbytes       size of binary data</param>
''' <param name="pw"> \param[out]   pw            [optional] image width</param>
''' <param name="ph"> \param[out]   ph            [optional] image height</param>
''' <param name="pminisblack"> \param[out]   pminisblack   [optional] boolean</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="extractG4DataFromFile")> _
Friend Shared Function extractG4DataFromFile(filein as String, pdata as Object, pnbytes as ULong, pw as Integer, ph as Integer, pminisblack as Integer) as Integer
End Function

' SRC\tiffio.c (2189, 21)
' 
' memstreamCreateForRead(l_uint8 *, size_t) as L_MEMSTREAM *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="memstreamCreateForRead")> _
Friend Shared Function memstreamCreateForRead(indata as Byte, pinsize as ULong) as IntPTR
End Function

' SRC\tiffio.c (2190, 21)
' 
' memstreamCreateForWrite(l_uint8 **, size_t *) as L_MEMSTREAM *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="memstreamCreateForWrite")> _
Friend Shared Function memstreamCreateForWrite(poutdata as Object, poutsize as ULong) as IntPTR
End Function

' SRC\tiffio.c (2192, 16)
' 
' tiffReadCallback(int, int, int) as int
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="tiffReadCallback")> _
Friend Shared Function tiffReadCallback(handle as Object, data as Object, length as Object) as Integer
End Function

' SRC\tiffio.c (2193, 16)
' 
' tiffWriteCallback(int, int, int) as int
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="tiffWriteCallback")> _
Friend Shared Function tiffWriteCallback(handle as Object, data as Object, length as Object) as Integer
End Function

' SRC\tiffio.c (2195, 15)
' 
' tiffSeekCallback(int, int, l_int32) as int
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="tiffSeekCallback")> _
Friend Shared Function tiffSeekCallback(handle as Object, offset as Object, whence as Integer) as Integer
End Function

' SRC\tiffio.c (2196, 16)
' 
' tiffCloseCallback(int) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="tiffCloseCallback")> _
Friend Shared Function tiffCloseCallback(handle as Object) as Integer
End Function

' SRC\tiffio.c (2197, 15)
' 
' tiffSizeCallback(int) as int
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="tiffSizeCallback")> _
Friend Shared Function tiffSizeCallback(handle as Object) as Integer
End Function

' SRC\tiffio.c (2198, 16)
' 
' tiffMapCallback(int, int *, int *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="tiffMapCallback")> _
Friend Shared Function tiffMapCallback(handle as Object, data as Object, length as Object) as Integer
End Function

' SRC\tiffio.c (2199, 13)
' 
' tiffUnmapCallback(int, int, int) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="tiffUnmapCallback")> _
Friend Shared Function tiffUnmapCallback(handle as Object, data as Object, length as Object) as Boolean ' Org. Void
End Function

' SRC\tiffio.c (2445, 1)
' pixReadMemTiff()
' pixReadMemTiff(const l_uint8 *, size_t, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a version of pixReadTiff(), where the data is read
'''  * from a memory buffer and uncompressed.
'''  *   (2) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.
'''  *   (3) No warning messages on failure, because of how multi-page
'''  * TIFF reading works. You are supposed to keep trying until
'''  * it stops working.
'''  *   (4) Tiff directory overhead is linear in the input page number.
'''  * If reading many images, use pixReadMemFromMultipageTiff().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error</returns>
''' <param name="cdata"> \param[in]    cdata    const; tiff-encoded</param>
''' <param name="size"> \param[in]    size     size of cdata</param>
''' <param name="n"> \param[in]    n        page image number: 0-based</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadMemTiff")> _
Friend Shared Function pixReadMemTiff(cdata as Byte, size as ULong, n as Integer) as IntPTR
End Function

' SRC\tiffio.c (2510, 1)
' pixReadMemFromMultipageTiff()
' pixReadMemFromMultipageTiff(const l_uint8 *, size_t, size_t *) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This is a read-from-memory version of pixReadFromMultipageTiff().
'''  * See that function for usage.
'''  *   (2) If reading sequentially from the tiff data, this is more
'''  * efficient than pixReadMemTiff(), which has an overhead
'''  * proportional to the image index n.
'''  *   (3) Example usage for reading all the images:
'''  *   size_t offset = 0;
'''  *   do {
'''  * Pix *pix = pixReadMemFromMultipageTiff(data, size, &offset);
'''  * // do something with pix
'''  *   } while (offset != 0);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pix, or NULL on error or if previous call returned the last image</returns>
''' <param name="cdata"> \param[in]    cdata      const; tiff-encoded</param>
''' <param name="size"> \param[in]    size       size of cdata</param>
''' <param name="poffset"> \param[in,out]  poffset  set offset to 0 for first image</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadMemFromMultipageTiff")> _
Friend Shared Function pixReadMemFromMultipageTiff(cdata as Byte, size as ULong, poffset as ULong) as IntPTR
End Function

' SRC\tiffio.c (2566, 1)
' pixaReadMemMultipageTiff()
' pixaReadMemMultipageTiff(const l_uint8 *, size_t) as PIXA *
''' <summary>
''' * Notes:
'''  *   (1) This is an O(n) read-from-memory version of pixaReadMultipageTiff().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixa, or NULL on error</returns>
''' <param name="data"> \param[in]    data    const; multiple pages; tiff-encoded</param>
''' <param name="size"> \param[in]    size    size of cdata</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaReadMemMultipageTiff")> _
Friend Shared Function pixaReadMemMultipageTiff(data as Byte, size as ULong) as IntPTR
End Function

' SRC\tiffio.c (2606, 1)
' pixaWriteMemMultipageTiff()
' pixaWriteMemMultipageTiff(l_uint8 **, size_t *, PIXA *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) fopenTiffMemstream() does not work in append mode, so we
'''  * must work-around with a temporary file.
'''  *   (2) Getting a file stream from
'''  *   open_memstream((char **)pdata, psize)
'''  * does not work with the tiff directory.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]    pdata   const; tiff-encoded</param>
''' <param name="psize"> \param[out]    psize   size of data</param>
''' <param name="pixa"> \param[in]     pixa    any depth; colormap will be removed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaWriteMemMultipageTiff")> _
Friend Shared Function pixaWriteMemMultipageTiff(pdata as Object, psize as ULong, pixa as IntPTR) as Integer
End Function

' SRC\tiffio.c (2672, 1)
' pixWriteMemTiff()
' pixWriteMemTiff(l_uint8 **, size_t *, PIX *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata     data of tiff compressed image</param>
''' <param name="psize"> \param[out]   psize     size of returned data</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="comptype"> \param[in]    comptype  IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMemTiff")> _
Friend Shared Function pixWriteMemTiff(pdata as Object, psize as ULong, pix as IntPTR, comptype as Integer) as Integer
End Function

' SRC\tiffio.c (2703, 1)
' pixWriteMemTiffCustom()
' pixWriteMemTiffCustom(l_uint8 **, size_t *, PIX *, l_int32, NUMA *, SARRAY *, SARRAY *, NUMA *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata     data of tiff compressed image</param>
''' <param name="psize"> \param[out]   psize     size of returned data</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="comptype"> \param[in]    comptype  IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,</param>
''' <param name="natags"> \param[in]    natags    [optional] NUMA of custom tiff tags</param>
''' <param name="savals"> \param[in]    savals    [optional] SARRAY of values</param>
''' <param name="satypes"> \param[in]    satypes   [optional] SARRAY of types</param>
''' <param name="nasizes"> \param[in]    nasizes   [optional] NUMA of sizes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMemTiffCustom")> _
Friend Shared Function pixWriteMemTiffCustom(pdata as Object, psize as ULong, pix as IntPTR, comptype as Integer, natags as IntPTR, savals as IntPTR, satypes as IntPTR, nasizes as IntPTR) as Integer
End Function

#End Region
#Region "SRC\utils1.c"
' SRC\utils1.c (125, 1)
' setMsgSeverity()
' setMsgSeverity(l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) setMsgSeverity() allows the user to specify the desired
'''  * message severity threshold.  Messages of equal or greater
'''  * severity will be output.  The previous message severity is
'''  * returned when the new severity is set.
'''  *   (2) If L_SEVERITY_EXTERNAL is passed, then the severity will be
'''  * obtained from the LEPT_MSG_SEVERITY environment variable.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  oldsev</returns>
''' <param name="newsev"> \param[in]    newsev</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="setMsgSeverity")> _
Friend Shared Function setMsgSeverity(newsev as Integer) as Integer
End Function

' SRC\utils1.c (176, 1)
' returnErrorInt()
' returnErrorInt(const char *, const char *, l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ival typically 1 for an error return</returns>
''' <param name="msg"> \param[in]    msg error message</param>
''' <param name="procname"> \param[in]    procname</param>
''' <param name="ival"> \param[in]    ival return val</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="returnErrorInt")> _
Friend Shared Function returnErrorInt(msg as String, procname as String, ival as Integer) as Integer
End Function

' SRC\utils1.c (194, 1)
' returnErrorFloat()
' returnErrorFloat(const char *, const char *, l_float32) as l_float32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fval</returns>
''' <param name="msg"> \param[in]    msg error message</param>
''' <param name="procname"> \param[in]    procname</param>
''' <param name="fval"> \param[in]    fval return val</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="returnErrorFloat")> _
Friend Shared Function returnErrorFloat(msg as String, procname as String, fval as single) as single
End Function

' SRC\utils1.c (212, 1)
' returnErrorPtr()
' returnErrorPtr(const char *, const char *, void *) as void *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pval typically null</returns>
''' <param name="msg"> \param[in]    msg error message</param>
''' <param name="procname"> \param[in]    procname</param>
''' <param name="pval"> \param[in]    pval  return val</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="returnErrorPtr")> _
Friend Shared Function returnErrorPtr(msg as String, procname as String, pval as Object) as String
End Function

' SRC\utils1.c (233, 1)
' filesAreIdentical()
' filesAreIdentical(const char *, const char *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fname1"> \param[in]    fname1</param>
''' <param name="fname2"> \param[in]    fname2</param>
''' <param name="psame"> \param[out]   psame 1 if identical; 0 if different</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="filesAreIdentical")> _
Friend Shared Function filesAreIdentical(fname1 as String, fname2 as String, psame as Integer) as Integer
End Function

' SRC\utils1.c (303, 1)
' 
' convertOnLittleEnd16(l_uint16) as l_uint16
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertOnLittleEnd16")> _
Friend Shared Function convertOnLittleEnd16(shortin as UShort) as UShort
End Function

' SRC\utils1.c (309, 1)
' 
' convertOnBigEnd16(l_uint16) as l_uint16
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertOnBigEnd16")> _
Friend Shared Function convertOnBigEnd16(shortin as UShort) as UShort
End Function

' SRC\utils1.c (338, 1)
' 
' convertOnLittleEnd32(l_uint32) as l_uint32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertOnLittleEnd32")> _
Friend Shared Function convertOnLittleEnd32(wordin as UInteger) as UInteger
End Function

' SRC\utils1.c (345, 1)
' 
' convertOnBigEnd32(l_uint32) as l_uint32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertOnBigEnd32")> _
Friend Shared Function convertOnBigEnd32(wordin as UInteger) as UInteger
End Function

' SRC\utils1.c (377, 1)
' fileCorruptByDeletion()
' fileCorruptByDeletion(const char *, l_float32, l_float32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) %loc and %size are expressed as a fraction of the file size.
'''  *   (2) This makes a copy of the data in %filein, where bytes in the
'''  * specified region have deleted.
'''  *   (3) If (%loc + %size) >= 1.0, this deletes from the position
'''  * represented by %loc to the end of the file.
'''  *   (4) It is useful for testing robustness of I/O wrappers when the
'''  * data is corrupted, by simulating data corruption by deletion.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein</param>
''' <param name="loc"> \param[in]    loc fractional location of start of deletion</param>
''' <param name="size"> \param[in]    size fractional size of deletion</param>
''' <param name="fileout"> \param[in]    fileout corrupted file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fileCorruptByDeletion")> _
Friend Shared Function fileCorruptByDeletion(filein as String, loc as single, size as single, fileout as String) as Integer
End Function

' SRC\utils1.c (441, 1)
' fileCorruptByMutation()
' fileCorruptByMutation(const char *, l_float32, l_float32, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) %loc and %size are expressed as a fraction of the file size.
'''  *   (2) This makes a copy of the data in %filein, where bytes in the
'''  * specified region have been replaced by random data.
'''  *   (3) If (%loc + %size) >= 1.0, this modifies data from the position
'''  * represented by %loc to the end of the file.
'''  *   (4) It is useful for testing robustness of I/O wrappers when the
'''  * data is corrupted, by simulating data corruption.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filein"> \param[in]    filein</param>
''' <param name="loc"> \param[in]    loc fractional location of start of randomization</param>
''' <param name="size"> \param[in]    size fractional size of randomization</param>
''' <param name="fileout"> \param[in]    fileout corrupted file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fileCorruptByMutation")> _
Friend Shared Function fileCorruptByMutation(filein as String, loc as single, size as single, fileout as String) as Integer
End Function

' SRC\utils1.c (499, 1)
' genRandomIntegerInRange()
' genRandomIntegerInRange(l_int32, l_int32, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) For example, to choose a rand integer between 0 and 99,
'''  * use %range = 100.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="range"> \param[in]    range size of range; must be >= 2</param>
''' <param name="seed"> \param[in]    seed use 0 to skip; otherwise call srand</param>
''' <param name="pval"> \param[out]   pval random integer in range {0 ... range-1}</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="genRandomIntegerInRange")> _
Friend Shared Function genRandomIntegerInRange(range as Integer, seed as Integer, pval as Integer) as Integer
End Function

' SRC\utils1.c (536, 1)
' lept_roundftoi()
' lept_roundftoi(l_float32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) For fval >= 0, fval --> round(fval) == floor(fval + 0.5)
'''  * For fval  0, fval --> -round(-fval))
'''  * This is symmetric around 0.
'''  * e.g., for fval in (-0.5 ... 0.5), fval --> 0
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  value rounded to int</returns>
''' <param name="fval"> \param[in]    fval</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_roundftoi")> _
Friend Shared Function lept_roundftoi(fval as single) as Integer
End Function

' SRC\utils1.c (568, 1)
' l_hashStringToUint64()
' l_hashStringToUint64(const char *, l_uint64 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The intent of the hash is to avoid collisions by mapping
'''  * the string as randomly as possible into 64 bits.
'''  *   (2) To the extent that the hashes are random, the probability of
'''  * a collision can be approximated by the square of the number
'''  * of strings divided by 2^64.  For 1 million strings, the
'''  * collision probability is about 1 in 16 million.
'''  *   (3) I expect non-randomness of the distribution to be most evident
'''  * for small text strings.  This hash function has been tested
'''  * for all 5-character text strings composed of 26 letters,
'''  * of which there are 26^5 = 12356630.  There are no hash
'''  * collisions for this set.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="str"> \param[in]    str</param>
''' <param name="phash"> \param[out]   phash hash vale</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_hashStringToUint64")> _
Friend Shared Function l_hashStringToUint64(str as String, phash as ULong) as Integer
End Function

' SRC\utils1.c (614, 1)
' l_hashPtToUint64()
' l_hashPtToUint64(l_int32, l_int32, l_uint64 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) I found that a simple hash function has no collisions for
'''  * any of 400 million points with x and y up to 20000.
'''  *   (2) Previously used a much more complicated and slower function:
'''  *   mulp = 26544357894361;
'''  *   hash = 104395301;
'''  *   hash += (x * mulp) ^ (hash >> 5);
'''  *   hash ^= (hash  7);
'''  *   hash += (y * mulp) ^ (hash >> 7);
'''  *   hash = hash ^ (hash  11);
'''  * Such logical gymnastics to get coverage over the 2^64
'''  * values are not required.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="x"> \param[in]    x, y</param>
''' <param name="y"> \param[out]   phash hash value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_hashPtToUint64")> _
Friend Shared Function l_hashPtToUint64(x as Integer, y as Integer, phash as ULong) as Integer
End Function

' SRC\utils1.c (654, 1)
' l_hashFloat64ToUint64()
' l_hashFloat64ToUint64(l_int32, l_float64, l_uint64 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Simple, fast hash for using dnaHash with 64-bit data
'''  * (e.g., sets and histograms).
'''  *   (2) The resulting hash is called a "key" in a lookup
'''  * operation.  The bucket for %val in a dnaHash is simply
'''  * found by taking the mod of the hash with the number of
'''  * buckets (which is prime).  What gets stored in the
'''  * dna in that bucket could depend on use, but for the most
'''  * flexibility, we store an index into the associated dna.
'''  * This is all that is required for generating either a hash set
'''  * or a histogram (an example of a hash map).
'''  *   (3) For example, to generate a histogram, the histogram dna,
'''  * a histogram of unique values aligned with the histogram dna,
'''  * and a dnahash hashmap are built.  See l_dnaMakeHistoByHash().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="nbuckets"> \param[in]    nbuckets</param>
''' <param name="val"> \param[in]    val</param>
''' <param name="phash"> \param[out]   phash hash value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_hashFloat64ToUint64")> _
Friend Shared Function l_hashFloat64ToUint64(nbuckets as Integer, val as Double, phash as ULong) as Integer
End Function

' SRC\utils1.c (678, 1)
' findNextLargerPrime()
' findNextLargerPrime(l_int32, l_uint32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="start"> \param[in]    start</param>
''' <param name="pprime"> \param[out]   pprime first prime larger than %start</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="findNextLargerPrime")> _
Friend Shared Function findNextLargerPrime(start as Integer, pprime as UInteger) as Integer
End Function

' SRC\utils1.c (713, 1)
' lept_isPrime()
' lept_isPrime(l_uint64, l_int32 *, l_uint32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="n"> \param[in]    n 64-bit unsigned</param>
''' <param name="pis_prime"> \param[out]   pis_prime 1 if prime, 0 otherwise</param>
''' <param name="pfactor"> \param[out]   pfactor [optional] smallest divisor,</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_isPrime")> _
Friend Shared Function lept_isPrime(n as ULong, pis_prime as Integer, pfactor as UInteger) as Integer
End Function

' SRC\utils1.c (764, 1)
' convertIntToGrayCode()
' convertIntToGrayCode(l_uint32) as l_uint32
''' <summary>
''' * Notes:
'''  *   (1) Gray code values corresponding to integers differ by
'''  * only one bit transition between successive integers.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return     corresponding gray code value</returns>
''' <param name="val"> \param[in]  val    integer value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertIntToGrayCode")> _
Friend Shared Function convertIntToGrayCode(val as UInteger) as UInteger
End Function

' SRC\utils1.c (777, 1)
' convertGrayCodeToInt()
' convertGrayCodeToInt(l_uint32) as l_uint32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return     corresponding integer value</returns>
''' <param name="val"> \param[in]  val    gray code value</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertGrayCodeToInt")> _
Friend Shared Function convertGrayCodeToInt(val as UInteger) as UInteger
End Function

' SRC\utils1.c (799, 1)
' getLeptonicaVersion()
' getLeptonicaVersion() as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getLeptonicaVersion")> _
Friend Shared Function getLeptonicaVersion() as String
End Function

' SRC\utils1.c (946, 1)
' 
' startTimer() as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="startTimer")> _
Friend Shared Function startTimer() as Boolean ' Org. Void
End Function

' SRC\utils1.c (960, 1)
' 
' stopTimer() as l_float32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stopTimer")> _
Friend Shared Function stopTimer() as single
End Function

' SRC\utils1.c (977, 1)
' 
' startTimerNested() as L_TIMER
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="startTimerNested")> _
Friend Shared Function startTimerNested() as Object
End Function

' SRC\utils1.c (994, 1)
' 
' stopTimerNested(L_TIMER) as l_float32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stopTimerNested")> _
Friend Shared Function stopTimerNested(utime_start as Object) as single
End Function

' SRC\utils1.c (1013, 1)
' 
' l_getCurrentTime(l_int32 *, l_int32 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_getCurrentTime")> _
Friend Shared Function l_getCurrentTime(sec as Integer, usec as Integer) as Boolean ' Org. Void
End Function

' SRC\utils1.c (1053, 1)
' startWallTimer()
' startWallTimer() as L_WALLTIMER *
''' <summary>
''' * Notes:
'''  *   (1) These measure the wall clock time  elapsed between the two calls:
'''  *   L_WALLTIMER *timer = startWallTimer();
'''  *   ....
'''  *   fprintf(stderr, "Elapsed time = %f sec\n", stopWallTimer(&timer);
'''  *   (2) Note that the timer object is destroyed by stopWallTimer().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  walltimer-ptr</returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="startWallTimer")> _
Friend Shared Function startWallTimer() as IntPTR
End Function

' SRC\utils1.c (1069, 1)
' stopWallTimer()
' stopWallTimer(L_WALLTIMER **) as l_float32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  time wall time elapsed in seconds</returns>
''' <param name="ptimer"> \param[in,out]  ptimer walltimer-ptr</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stopWallTimer")> _
Friend Shared Function stopWallTimer(ptimer as Object) as single
End Function

' SRC\utils1.c (1104, 1)
' l_getFormattedDate()
' l_getFormattedDate() as char *
''' <summary>
''' * Notes:
'''  *   (1) This is used in pdf, in the form specified in section 3.8.2 of
'''  * http://partners.adobe.com/public/developer/en/pdf/PDFReference.pdf
'''  *   (2) Contributed by Dave Bryan.  Works on all platforms.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  formatted date string, or NULL on error</returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_getFormattedDate")> _
Friend Shared Function l_getFormattedDate() as String
End Function

#End Region
#Region "SRC\utils2.c"
' SRC\utils2.c (205, 1)
' stringNew()
' stringNew(const char *) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dest copy of src string, or NULL on error</returns>
''' <param name="src"> \param[in]    src string</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringNew")> _
Friend Shared Function stringNew(src as String) as String
End Function

' SRC\utils2.c (245, 1)
' stringCopy()
' stringCopy(char *, const char *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Relatively safe wrapper for strncpy, that checks the input,
'''  * and does not complain if %src is null or %n  1.
'''  * If %n  1, this is a no-op.
'''  *   (2) %dest needs to be at least %n bytes in size.
'''  *   (3) We don't call strncpy() because valgrind complains about
'''  * use of uninitialized values.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="dest"> \param[in]    dest existing byte buffer</param>
''' <param name="src"> \param[in]    src string [optional] can be null</param>
''' <param name="n"> \param[in]    n max number of characters to copy</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringCopy")> _
Friend Shared Function stringCopy(dest as Object, src as String, n as Integer) as Integer
End Function

' SRC\utils2.c (282, 1)
' stringReplace()
' stringReplace(char **, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Frees any existing dest string
'''  *   (2) Puts a copy of src string in the dest
'''  *   (3) If either or both strings are null, does something reasonable.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pdest"> \param[out]   pdest string copy</param>
''' <param name="src"> \param[in]    src string [optional] can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringReplace")> _
Friend Shared Function stringReplace(pdest as String, src as String) as Integer
End Function

' SRC\utils2.c (318, 1)
' stringLength()
' stringLength(const char *, size_t) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Safe implementation of strlen that only checks size bytes
'''  * for trailing NUL.
'''  *   (2) Valid returned string lengths are between 0 and size - 1.
'''  * If size bytes are checked without finding a NUL byte, then
'''  * an error is indicated by returning size.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  length of src in bytes.</returns>
''' <param name="src"> \param[in]    src string can be null or NULL-terminated string</param>
''' <param name="size"> \param[in]    size size of src buffer</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringLength")> _
Friend Shared Function stringLength(src as String, size as ULong) as Integer
End Function

' SRC\utils2.c (359, 1)
' stringCat()
' stringCat(char *, size_t, const char *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) Alternative implementation of strncat, that checks the input,
'''  * is easier to use (since the size of the dest buffer is specified
'''  * rather than the number of bytes to copy), and does not complain
'''  * if %src is null.
'''  *   (2) Never writes past end of dest.
'''  *   (3) If it can't append src (an error), it does nothing.
'''  *   (4) N.B. The order of 2nd and 3rd args is reversed from that in
'''  * strncat, as in the Windows function strcat_s().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  number of bytes added to dest; -1 on error</returns>
''' <param name="dest"> \param[in]    dest null-terminated byte buffer</param>
''' <param name="size"> \param[in]    size size of dest</param>
''' <param name="src"> \param[in]    src string can be null or NULL-terminated string</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringCat")> _
Friend Shared Function stringCat(dest as Object, size as ULong, src as String) as Integer
End Function

' SRC\utils2.c (407, 1)
' stringConcatNew()
' stringConcatNew(const char *, ...) as char *
''' <summary>
''' * Notes:
'''  *   (1) The last arg in the list of strings must be NULL.
'''  *   (2) Caller must free the returned string.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  result new string concatenating the input strings, or</returns>
''' <param name="first"> \param[in]    first first string in list</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringConcatNew")> _
Friend Shared Function stringConcatNew(first as String) as String
End Function

' SRC\utils2.c (454, 1)
' stringJoin()
' stringJoin(const char *, const char *) as char *
''' <summary>
''' * Notes:
'''  *   (1) This is a safe version of strcat; it makes a new string.
'''  *   (2) It is not an error if either or both of the strings
'''  * are empty, or if either or both of the pointers are null.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  concatenated string, or NULL on error</returns>
''' <param name="src1"> \param[in]    src1 string [optional] can be null</param>
''' <param name="src2"> \param[in]    src2 string [optional] can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringJoin")> _
Friend Shared Function stringJoin(src1 as String, src2 as String) as String
End Function

' SRC\utils2.c (509, 1)
' stringJoinIP()
' stringJoinIP(char **, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a safe in-place version of strcat.  The contents of
'''  * src1 is replaced by the concatenation of src1 and src2.
'''  *   (2) It is not an error if either or both of the strings
'''  * are empty (""), or if the pointers to the strings (*psrc1, src2)
'''  * are null.
'''  *   (3) src1 should be initialized to null or an empty string
'''  * before the first call.  Use one of these:
'''  *  char *src1 = NULL;
'''  *  char *src1 = stringNew("");
'''  * Then call with:
'''  *  stringJoinIP(&src1, src2);
'''  *   (4) This can also be implemented as a macro:
'''  * \code
'''  *  #define stringJoinIP(src1, src2) \
'''  *   {tmpstr = stringJoin((src1),(src2)); \
'''  *   LEPT_FREE(src1); \
'''  *   (src1) = tmpstr;}
'''  * \endcode
'''  *   (5) Another function to consider for joining many strings is
'''  * stringConcatNew().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="psrc1"> \param[in,out]  psrc1 string address of src1; cannot be on the stack</param>
''' <param name="src2"> \param[in]      src2 string [optional] can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringJoinIP")> _
Friend Shared Function stringJoinIP(psrc1 as String, src2 as String) as Integer
End Function

' SRC\utils2.c (533, 1)
' stringReverse()
' stringReverse(const char *) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dest newly-allocated reversed string</returns>
''' <param name="src"> \param[in]    src string</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringReverse")> _
Friend Shared Function stringReverse(src as String) as String
End Function

' SRC\utils2.c (585, 1)
' strtokSafe()
' strtokSafe(char *, const char *, char **) as char *
''' <summary>
''' * Notes:
'''  *   (1) This is a thread-safe implementation of strtok.
'''  *   (2) It has the same interface as strtok_r.
'''  *   (3) It differs from strtok_r in usage in two respects:
'''  * (a) the input string is not altered
'''  * (b) each returned substring is newly allocated and must
'''  *  be freed after use.
'''  *   (4) Let me repeat that.  This is "safe" because the input
'''  * string is not altered and because each returned string
'''  * is newly allocated on the heap.
'''  *   (5) It is here because, surprisingly, some C libraries don't
'''  * include strtok_r.
'''  *   (6) Important usage points:
'''  * ~ Input the string to be parsed on the first invocation.
'''  * ~ Then input NULL after that; the value returned in saveptr
'''  *   is used in all subsequent calls.
'''  *   (7) This is only slightly slower than strtok_r.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  substr a new string that is copied from the previous</returns>
''' <param name="_cstr_"> \param[in]    cstr input string to be sequentially parsed;</param>
''' <param name="seps"> \param[in]    seps a string of character separators</param>
''' <param name="psaveptr"> \param[out]   psaveptr ptr to the next char after</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="strtokSafe")> _
Friend Shared Function strtokSafe(_cstr_ as Object, seps as String, psaveptr as String) as String
End Function

' SRC\utils2.c (679, 1)
' stringSplitOnToken()
' stringSplitOnToken(char *, const char *, char **, char **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The input string is not altered; all split parts are new strings.
'''  *   (2) The split occurs around the first consecutive sequence of
'''  * tokens encountered.
'''  *   (3) The head goes from the beginning of the string up to
'''  * but not including the first token found.
'''  *   (4) The tail contains the second part of the string, starting
'''  * with the first char in that part that is NOT a token.
'''  *   (5) If no separator token is found, 'head' contains a copy
'''  * of the input string and 'tail' is null.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="_cstr_"> \param[in]    cstr input string to be split; not altered</param>
''' <param name="seps"> \param[in]    seps a string of character separators</param>
''' <param name="phead"> \param[out]   phead ptr to copy of the input string, up to</param>
''' <param name="ptail"> \param[out]   ptail ptr to copy of the part of the input string</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringSplitOnToken")> _
Friend Shared Function stringSplitOnToken(_cstr_ as Object, seps as String, phead as String, ptail as String) as Integer
End Function

' SRC\utils2.c (723, 1)
' stringCheckForChars()
' stringCheckForChars(const char *, const char *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This can be used to sanitize an operation by checking for
'''  * special characters that don't belong in a string.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="src"> \param[in]    src      input string; can be of zero length</param>
''' <param name="chars"> \param[in]    chars    string of chars to be searched for in %src</param>
''' <param name="pfound"> \param[out]   pfound   1 if any characters are found; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringCheckForChars")> _
Friend Shared Function stringCheckForChars(src as String, chars as String, pfound as Integer) as Integer
End Function

' SRC\utils2.c (758, 1)
' stringRemoveChars()
' stringRemoveChars(const char *, const char *) as char *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dest string with specified chars removed, or NULL on error</returns>
''' <param name="src"> \param[in]    src input string; can be of zero length</param>
''' <param name="remchars"> \param[in]    remchars  string of chars to be removed from src</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringRemoveChars")> _
Friend Shared Function stringRemoveChars(src as String, remchars as String) as String
End Function

' SRC\utils2.c (803, 1)
' stringFindSubstr()
' stringFindSubstr(const char *, const char *, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This is a wrapper around strstr().
'''  *   (2) Both %src and %sub must be defined, and %sub must have
'''  * length of at least 1.
'''  *   (3) If the substring is not found and loc is returned, it has
'''  * the value -1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  1 if found; 0 if not found or on error</returns>
''' <param name="src"> \param[in]    src input string; can be of zero length</param>
''' <param name="_sub_"> \param[in]    sub substring to be searched for</param>
''' <param name="ploc"> \param[out]   ploc [optional] location of substring in src</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringFindSubstr")> _
Friend Shared Function stringFindSubstr(src as String, _sub_ as String, ploc as Integer) as Integer
End Function

' SRC\utils2.c (855, 1)
' stringReplaceSubstr()
' stringReplaceSubstr(const char *, const char *, const char *, l_int32 *, l_int32 *) as char *
''' <summary>
''' * Notes:
'''  *   (1) Replaces the first instance.
'''  *   (2) To only remove sub1, use "" for sub2
'''  *   (3) Returns a new string if sub1 and sub2 are the same.
'''  *   (4) The optional loc is input as the byte offset within the src
'''  * from which the search starts, and after the search it is the
'''  * char position in the string of the next character after
'''  * the substituted string.
'''  *   (5) N.B. If ploc is not null, loc must always be initialized.
'''  * To search the string from the beginning, set loc = 0.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dest string with substring replaced, or NULL if the</returns>
''' <param name="src"> \param[in]    src input string; can be of zero length</param>
''' <param name="sub1"> \param[in]    sub1 substring to be replaced</param>
''' <param name="sub2"> \param[in]    sub2 substring to put in; can be ""</param>
''' <param name="pfound"> \param[out]   pfound [optional] 1 if sub1 is found; 0 otherwise</param>
''' <param name="ploc"> \param[out]   ploc [optional] location of ptr after replacement</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringReplaceSubstr")> _
Friend Shared Function stringReplaceSubstr(src as String, sub1 as String, sub2 as String, pfound as Integer, ploc as Integer) as String
End Function

' SRC\utils2.c (922, 1)
' stringReplaceEachSubstr()
' stringReplaceEachSubstr(const char *, const char *, const char *, l_int32 *) as char *
''' <summary>
''' * Notes:
'''  *   (1) Replaces every instance.
'''  *   (2) To only remove each instance of sub1, use "" for sub2
'''  *   (3) Returns NULL if sub1 and sub2 are the same.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dest string with substring replaced, or NULL if the</returns>
''' <param name="src"> \param[in]    src input string; can be of zero length</param>
''' <param name="sub1"> \param[in]    sub1 substring to be replaced</param>
''' <param name="sub2"> \param[in]    sub2 substring to put in; can be ""</param>
''' <param name="pcount"> \param[out]   pcount [optional] the number of times that sub1</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="stringReplaceEachSubstr")> _
Friend Shared Function stringReplaceEachSubstr(src as String, sub1 as String, sub2 as String, pcount as Integer) as String
End Function

' SRC\utils2.c (977, 1)
' arrayFindEachSequence()
' arrayFindEachSequence(const l_uint8 *, size_t, const l_uint8 *, size_t) as L_DNA *
''' <summary>
''' * Notes:
'''  *   (1) The byte arrays %data and %sequence are not C strings,
'''  * as they can contain null bytes.  Therefore, for each
'''  * we must give the length of the array.
'''  *   (2) This finds every occurrence in %data of %sequence.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dna of offsets where the sequence is found, or NULL if</returns>
''' <param name="data"> \param[in]    data byte array</param>
''' <param name="datalen"> \param[in]    datalen length of data, in bytes</param>
''' <param name="sequence"> \param[in]    sequence subarray of bytes to find in data</param>
''' <param name="seqlen"> \param[in]    seqlen length of sequence, in bytes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="arrayFindEachSequence")> _
Friend Shared Function arrayFindEachSequence(data as Byte, datalen as ULong, sequence as Byte, seqlen as ULong) as IntPTR
End Function

' SRC\utils2.c (1037, 1)
' arrayFindSequence()
' arrayFindSequence(const l_uint8 *, size_t, const l_uint8 *, size_t, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The byte arrays 'data' and 'sequence' are not C strings,
'''  * as they can contain null bytes.  Therefore, for each
'''  * we must give the length of the array.
'''  *   (2) This searches for the first occurrence in %data of %sequence,
'''  * which consists of %seqlen bytes.  The parameter %seqlen
'''  * must not exceed the actual length of the %sequence byte array.
'''  *   (3) If the sequence is not found, the offset will be 0, so you
'''  * must check %found.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="data"> \param[in]    data byte array</param>
''' <param name="datalen"> \param[in]    datalen length of data, in bytes</param>
''' <param name="sequence"> \param[in]    sequence subarray of bytes to find in data</param>
''' <param name="seqlen"> \param[in]    seqlen length of sequence, in bytes</param>
''' <param name="poffset"> \param[out]   poffset offset from beginning of</param>
''' <param name="pfound"> \param[out]   pfound 1 if sequence is found; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="arrayFindSequence")> _
Friend Shared Function arrayFindSequence(data as Byte, datalen as ULong, sequence as Byte, seqlen as ULong, poffset as Integer, pfound as Integer) as Integer
End Function

' SRC\utils2.c (1106, 1)
' reallocNew()
' reallocNew(void **, l_int32, l_int32) as void *
''' <summary>
''' * Notes:
'''  *   (1) If newsize =0, just frees input data and nulls ptr
'''  *   (2) If input ptr is null, just callocs new memory
'''  *   (3) This differs from realloc in that it always allocates
'''  * new memory (if newsize > 0) and initializes it to 0,
'''  * it requires the amount of old data to be copied,
'''  * and it takes the address of the input ptr and
'''  * nulls the handle.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  ptr to new data, or NULL on error</returns>
''' <param name="pindata"> \param[in,out]  pindata [optional]; nulls indata</param>
''' <param name="oldsize"> \param[in]      oldsize size of input data to be copied, in bytes</param>
''' <param name="newsize"> \param[in]      newsize size of data to be reallocated in bytes</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="reallocNew")> _
Friend Shared Function reallocNew(pindata as Object, oldsize as Integer, newsize as Integer) as String
End Function

' SRC\utils2.c (1158, 1)
' l_binaryRead()
' l_binaryRead(const char *, size_t *) as l_uint8 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pnbytes"> \param[out]   pnbytes number of bytes read</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_binaryRead")> _
Friend Shared Function l_binaryRead(filename as String, pnbytes as ULong) as String
End Function

' SRC\utils2.c (1208, 1)
' l_binaryReadStream()
' l_binaryReadStream(FILE *, size_t *) as l_uint8 *
''' <summary>
''' * Notes:
'''  *   (1) The returned array is terminated with a null byte so that it can
'''  * be used to read ascii data from a file into a proper C string.
'''  *   (2) This can be used to capture data that is piped in via stdin,
'''  * because it does not require seeking within the file.
'''  *   (3) For example, you can read an image from stdin into memory
'''  * using shell redirection, with one of these shell commands:
'''  * \code
'''  * cat imagefile> | readprog
'''  * readprog  imagefile>
'''  * \endcode
'''  * where readprog is:
'''  * \code
'''  * l_uint8 *data = l_binaryReadStream(stdin, &nbytes);
'''  * Pix *pix = pixReadMem(data, nbytes);
'''  * \endcode
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  null-terminated array, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream opened to read; can be stdin</param>
''' <param name="pnbytes"> \param[out]   pnbytes number of bytes read</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_binaryReadStream")> _
Friend Shared Function l_binaryReadStream(fp as Object, pnbytes as ULong) as String
End Function

' SRC\utils2.c (1275, 1)
' l_binaryReadSelect()
' l_binaryReadSelect(const char *, size_t, size_t, size_t *) as l_uint8 *
''' <summary>
''' * Notes:
'''  *   (1) The returned array is terminated with a null byte so that it can
'''  * be used to read ascii data from a file into a proper C string.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  data, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="start"> \param[in]    start first byte to read</param>
''' <param name="nbytes"> \param[in]    nbytes number of bytes to read; use 0 to read to end of file</param>
''' <param name="pnread"> \param[out]   pnread number of bytes actually read</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_binaryReadSelect")> _
Friend Shared Function l_binaryReadSelect(filename as String, start as ULong, nbytes as ULong, pnread as ULong) as String
End Function

' SRC\utils2.c (1320, 1)
' l_binaryReadSelectStream()
' l_binaryReadSelectStream(FILE *, size_t, size_t, size_t *) as l_uint8 *
''' <summary>
''' * Notes:
'''  *   (1) The returned array is terminated with a null byte so that it can
'''  * be used to read ascii data from a file into a proper C string.
'''  * If the file to be read is empty and %start == 0, an array
'''  * with a single null byte is returned.
'''  *   (2) Side effect: the stream pointer is re-positioned to the
'''  * beginning of the file.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  null-terminated array, or NULL on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="start"> \param[in]    start first byte to read</param>
''' <param name="nbytes"> \param[in]    nbytes number of bytes to read; use 0 to read to end of file</param>
''' <param name="pnread"> \param[out]   pnread number of bytes actually read</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_binaryReadSelectStream")> _
Friend Shared Function l_binaryReadSelectStream(fp as Object, start as ULong, nbytes as ULong, pnread as ULong) as String
End Function

' SRC\utils2.c (1375, 1)
' l_binaryWrite()
' l_binaryWrite(const char *, const char *, const void *, size_t) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="filename"> \param[in]    filename output</param>
''' <param name="operation"> \param[in]    operation  "w" for write; "a" for append</param>
''' <param name="data"> \param[in]    data  binary data to be written</param>
''' <param name="nbytes"> \param[in]    nbytes  size of data array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_binaryWrite")> _
Friend Shared Function l_binaryWrite(filename as String, operation as String, data as Object, nbytes as ULong) as Integer
End Function

' SRC\utils2.c (1417, 1)
' nbytesInFile()
' nbytesInFile(const char *) as size_t
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nbytes in file; 0 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="nbytesInFile")> _
Friend Shared Function nbytesInFile(filename as String) as ULong
End Function

' SRC\utils2.c (1441, 1)
' fnbytesInFile()
' fnbytesInFile(FILE *) as size_t
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  nbytes in file; 0 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fnbytesInFile")> _
Friend Shared Function fnbytesInFile(fp as Object) as ULong
End Function

' SRC\utils2.c (1479, 1)
' l_binaryCopy()
' l_binaryCopy(l_uint8 *, size_t) as l_uint8 *
''' <summary>
''' * Notes:
'''  *   (1) We add 4 bytes to the zeroed output because in some cases
'''  * (e.g., string handling) it is important to have the data
'''  * be null terminated.  This guarantees that after the memcpy,
'''  * the result is automatically null terminated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  datad on heap, or NULL on error</returns>
''' <param name="datas"> \param[in]    datas</param>
''' <param name="size"> \param[in]    size of data array</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_binaryCopy")> _
Friend Shared Function l_binaryCopy(datas as Byte, size as ULong) as String
End Function

' SRC\utils2.c (1507, 1)
' fileCopy()
' fileCopy(const char *, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="srcfile"> \param[in]    srcfile copy this file</param>
''' <param name="newfile"> \param[in]    newfile to this file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fileCopy")> _
Friend Shared Function fileCopy(srcfile as String, newfile as String) as Integer
End Function

' SRC\utils2.c (1537, 1)
' fileConcatenate()
' fileConcatenate(const char *, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="srcfile"> \param[in]    srcfile file to append</param>
''' <param name="destfile"> \param[in]    destfile file to add to</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fileConcatenate")> _
Friend Shared Function fileConcatenate(srcfile as String, destfile as String) as Integer
End Function

' SRC\utils2.c (1565, 1)
' fileAppendString()
' fileAppendString(const char *, const char *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="str"> \param[in]    str string to append to file</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fileAppendString")> _
Friend Shared Function fileAppendString(filename as String, str as String) as Integer
End Function

' SRC\utils2.c (1603, 1)
' fopenReadStream()
' fopenReadStream(const char *) as FILE *
''' <summary>
''' * Notes:
'''  *   (1) This should be used whenever you want to run fopen() to
'''  * read from a stream.  Never call fopen() directory.
'''  *   (2) This handles the temp directory pathname conversion on windows:
'''  *  /tmp  ==>  [Windows Temp directory]
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  stream, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fopenReadStream")> _
Friend Shared Function fopenReadStream(filename as String) as String
End Function

' SRC\utils2.c (1646, 1)
' fopenWriteStream()
' fopenWriteStream(const char *, const char *) as FILE *
''' <summary>
''' * Notes:
'''  *   (1) This should be used whenever you want to run fopen() to
'''  * write or append to a stream.  Never call fopen() directory.
'''  *   (2) This handles the temp directory pathname conversion on windows:
'''  *  /tmp  ==>  [Windows Temp directory]
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  stream, or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="modestring"> \param[in]    modestring</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fopenWriteStream")> _
Friend Shared Function fopenWriteStream(filename as String, modestring as String) as String
End Function

' SRC\utils2.c (1680, 1)
' fopenReadFromMemory()
' fopenReadFromMemory(const l_uint8 *, size_t) as FILE *
''' <summary>
''' * Notes:
'''  *   (1) Work-around if fmemopen() not available.
'''  *   (2) Windows tmpfile() writes into the root C:\ directory, which
'''  * requires admin privileges.  This also works around that.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  file stream, or NULL on error</returns>
''' <param name="data"> \param[in]    data, size</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fopenReadFromMemory")> _
Friend Shared Function fopenReadFromMemory(data as Byte, size as ULong) as String
End Function

' SRC\utils2.c (1726, 1)
' fopenWriteWinTempfile()
' fopenWriteWinTempfile() as FILE *
''' <summary>
''' * Notes:
'''  *   (1) The Windows version of tmpfile() writes into the root
'''  * C:\ directory, which requires admin privileges.  This
'''  * function provides an alternative implementation.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  file stream, or NULL on error</returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="fopenWriteWinTempfile")> _
Friend Shared Function fopenWriteWinTempfile() as String
End Function

' SRC\utils2.c (1784, 1)
' lept_fopen()
' lept_fopen(const char *, const char *) as FILE *
''' <summary>
''' * Notes:
'''  *   (1) This must be used by any application that passes
'''  * a file handle to a leptonica Windows DLL.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  stream or NULL on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="mode"> \param[in]    mode same as for fopen(); e.g., "rb"</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_fopen")> _
Friend Shared Function lept_fopen(filename as String, mode as String) as String
End Function

' SRC\utils2.c (1814, 1)
' lept_fclose()
' lept_fclose(FILE *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This should be used by any application that accepts
'''  * a file handle generated by a leptonica Windows DLL.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_fclose")> _
Friend Shared Function lept_fclose(fp as Object) as Integer
End Function

' SRC\utils2.c (1840, 1)
' lept_calloc()
' lept_calloc(size_t, size_t) as void *
''' <summary>
''' * Notes:
'''  *   (1) For safety with windows DLLs, this can be used in conjunction
'''  * with lept_free() to avoid C-runtime boundary problems.
'''  * Just use these two functions throughout your application.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void ptr, or NULL on error</returns>
''' <param name="nmemb"> \param[in]    nmemb number of members</param>
''' <param name="size"> \param[in]    size of each member</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_calloc")> _
Friend Shared Function lept_calloc(nmemb as ULong, size as ULong) as String
End Function

' SRC\utils2.c (1861, 1)
' lept_free()
' lept_free(void *) as void
''' <summary>
''' * Notes:
'''  *   (1) This should be used by any application that accepts
'''  * heap data allocated by a leptonica Windows DLL.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
''' <param name="ptr"> \param[in]    ptr</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_free")> _
Friend Shared Function lept_free(ptr as Object) as Boolean ' Org. Void
End Function

' SRC\utils2.c (1890, 1)
' lept_mkdir()
' lept_mkdir(const char *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) %subdir is a partial path that can consist of one or more
'''  * directories.
'''  *   (2) This makes any subdirectories of /tmp that are required.
'''  *   (3) The root temp directory is:
'''  *   /tmp (unix)  [default]
'''  *   [Temp]  (windows)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 on success, non-zero on failure</returns>
''' <param name="subdir"> \param[in]    subdir of /tmp or its equivalent on Windows</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_mkdir")> _
Friend Shared Function lept_mkdir(subdir as String) as Integer
End Function

' SRC\utils2.c (1967, 1)
' lept_rmdir()
' lept_rmdir(const char *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) %subdir is a partial path that can consist of one or more
'''  * directories.
'''  *   (2) This removes all files from the specified subdirectory of
'''  * the root temp directory:
'''  *   /tmp (unix)
'''  *   [Temp]  (windows)
'''  * and then removes the subdirectory.
'''  *   (3) The combination
'''  *   lept_rmdir(subdir);
'''  *   lept_mkdir(subdir);
'''  * is guaranteed to give you an empty subdirectory.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 on success, non-zero on failure</returns>
''' <param name="subdir"> \param[in]    subdir of /tmp or its equivalent on Windows</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_rmdir")> _
Friend Shared Function lept_rmdir(subdir as String) as Integer
End Function

' SRC\utils2.c (2041, 1)
' lept_direxists()
' lept_direxists(const char *, l_int32 *) as void
''' <summary>
''' * Notes:
'''  *   (1) Always use unix pathname separators.
'''  *   (2) By calling genPathname(), if the pathname begins with "/tmp"
'''  * this does an automatic directory translation on windows
'''  * to a path in the windows [Temp] directory:
'''  * "/tmp"  ==>  [Temp] (windows)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="dir"> \param[in]    dir</param>
''' <param name="pexists"> \param[out]   pexists 1 if it exists; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_direxists")> _
Friend Shared Function lept_direxists(dir as String, pexists as Integer) as Boolean ' Org. Void
End Function

' SRC\utils2.c (2099, 1)
' lept_rm_match()
' lept_rm_match(const char *, const char *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This removes the matched files in /tmp or a subdirectory of /tmp.
'''  * Use NULL for %subdir if the files are in /tmp.
'''  *   (2) If %substr == NULL, this removes all files in the directory.
'''  * If %substr == "" (empty), this removes no files.
'''  * If both %subdir == NULL and %substr == NULL, this removes
'''  * all files in /tmp.
'''  *   (3) Use unix pathname separators.
'''  *   (4) By calling genPathname(), if the pathname begins with "/tmp"
'''  * this does an automatic directory translation on windows
'''  * to a path in the windows [Temp] directory:
'''  * "/tmp"  ==>  [Temp] (windows)
'''  *   (5) Error conditions:
'''  *   * returns -1 if the directory is not found
'''  *   * returns the number of files (> 0) that it was unable to remove.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 on success, non-zero on failure</returns>
''' <param name="subdir"> \param[in]    subdir [optional]  If NULL, the removed files are in /tmp</param>
''' <param name="substr"> \param[in]    substr [optional] pattern to match in filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_rm_match")> _
Friend Shared Function lept_rm_match(subdir as String, substr as String) as Integer
End Function

' SRC\utils2.c (2149, 1)
' lept_rm()
' lept_rm(const char *, const char *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) By calling genPathname(), this does an automatic directory
'''  * translation on windows to a path in the windows [Temp] directory:
'''  * "/tmp/..."  ==>  [Temp]/... (windows)
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 on success, non-zero on failure</returns>
''' <param name="subdir"> \param[in]    subdir [optional] of '/tmp'; can be NULL</param>
''' <param name="tail"> \param[in]    tail filename without the directory</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_rm")> _
Friend Shared Function lept_rm(subdir as String, tail as String) as Integer
End Function

' SRC\utils2.c (2189, 1)
' 
' lept_rmfile(const char *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This removes the named file.
'''  *   (2) Use unix pathname separators.
'''  *   (3) There is no name translation.
'''  *   (4) Unlike the other lept_* functions in this section, this can remove
'''  * any file -- it is not restricted to files that are in /tmp or a
'''  * subdirectory of it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 on success, non-zero on failure</returns>
''' <param name="filepath"> \param[in]    filepath full path to file including the directory</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_rmfile")> _
Friend Shared Function lept_rmfile(filepath as String) as Integer
End Function

' SRC\utils2.c (2244, 1)
' lept_mv()
' lept_mv(const char *, const char *, const char *, char **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This moves %srcfile to /tmp or to a subdirectory of /tmp.
'''  *   (2) %srcfile can either be a full path or relative to the
'''  * current directory.
'''  *   (3) %newdir can either specify an existing subdirectory of /tmp
'''  * or can be NULL.  In the latter case, the file will be written
'''  * into /tmp.
'''  *   (4) %newtail can either specify a filename tail or, if NULL,
'''  * the filename is taken from src-tail, the tail of %srcfile.
'''  *   (5) For debugging, the computed newpath can be returned.  It must
'''  * be freed by the caller.
'''  *   (6) Reminders:
'''  * (a) specify files using unix pathnames
'''  * (b) for windows, translates
'''  *  /tmp  ==>  [Temp]
'''  *  where [Temp] is the windows temp directory
'''  *   (7) Examples:
'''  * * newdir = NULL, newtail = NULL ==> /tmp/src-tail
'''  * * newdir = NULL, newtail = abc  ==> /tmp/abc
'''  * * newdir = def/ghi, newtail = NULL ==> /tmp/def/ghi/src-tail
'''  * * newdir = def/ghi, newtail = abc  ==> /tmp/def/ghi/abc
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 on success, non-zero on failure</returns>
''' <param name="srcfile"> \param[in]    srcfile</param>
''' <param name="newdir"> \param[in]    newdir [optional]; can be NULL</param>
''' <param name="newtail"> \param[in]    newtail [optional]; can be NULL</param>
''' <param name="pnewpath"> \param[out]   pnewpath [optional] of actual path; can be NULL</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_mv")> _
Friend Shared Function lept_mv(srcfile as String, newdir as String, newtail as String, pnewpath as String) as Integer
End Function

' SRC\utils2.c (2343, 1)
' lept_cp()
' lept_cp(const char *, const char *, const char *, char **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This copies %srcfile to /tmp or to a subdirectory of /tmp.
'''  *   (2) %srcfile can either be a full path or relative to the
'''  * current directory.
'''  *   (3) %newdir can either specify an existing subdirectory of /tmp,
'''  * or can be NULL.  In the latter case, the file will be written
'''  * into /tmp.
'''  *   (4) %newtail can either specify a filename tail or, if NULL,
'''  * the filename is taken from src-tail, the tail of %srcfile.
'''  *   (5) For debugging, the computed newpath can be returned.  It must
'''  * be freed by the caller.
'''  *   (6) Reminders:
'''  * (a) specify files using unix pathnames
'''  * (b) for windows, translates
'''  *  /tmp  ==>  [Temp]
'''  *  where [Temp] is the windows temp directory
'''  *   (7) Examples:
'''  * * newdir = NULL, newtail = NULL ==> /tmp/src-tail
'''  * * newdir = NULL, newtail = abc  ==> /tmp/abc
'''  * * newdir = def/ghi, newtail = NULL ==> /tmp/def/ghi/src-tail
'''  * * newdir = def/ghi, newtail = abc  ==> /tmp/def/ghi/abc
'''  *
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 on success, non-zero on failure</returns>
''' <param name="srcfile"> \param[in]    srcfile</param>
''' <param name="newdir"> \param[in]    newdir [optional]; can be NULL</param>
''' <param name="newtail"> \param[in]    newtail [optional]; can be NULL</param>
''' <param name="pnewpath"> \param[out]   pnewpath [optional] of actual path; can be NULL</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="lept_cp")> _
Friend Shared Function lept_cp(srcfile as String, newdir as String, newtail as String, pnewpath as String) as Integer
End Function

' SRC\utils2.c (2420, 1)
' callSystemDebug()
' callSystemDebug(const char *) as void
''' <summary>
''' * Notes:
'''  *   (1) The C library 'system' call is only made through this function.
'''  * It only works in debug/test mode, where the global variable
'''  * LeptDebugOK == TRUE.  This variable is set to FALSE in the
'''  * library as distributed, and calling this function will
'''  * generate an error message.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="cmd"> \param[in]    cmd      command to be exec'd</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="callSystemDebug")> _
Friend Shared Function callSystemDebug(cmd as String) as Boolean ' Org. Void
End Function

' SRC\utils2.c (2484, 1)
' splitPathAtDirectory()
' splitPathAtDirectory(const char *, char **, char **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If you only want the tail, input null for the root directory ptr.
'''  *   (2) If you only want the root directory name, input null for the
'''  * tail ptr.
'''  *   (3) This function makes decisions based only on the lexical
'''  * structure of the input.  Examples:
'''  *   /usr/tmp/abc  -->  dir: /usr/tmp/ tail: abc
'''  *   /usr/tmp/  -->  dir: /usr/tmp/ tail: [empty string]
'''  *   /usr/tmp   -->  dir: /usr/  tail: tmp
'''  *   abc  -->  dir: [empty string]  tail: abc
'''  *   (4) The input can have either forward (unix) or backward (win)
'''  * slash separators.  The output has unix separators.
'''  * Note that Win32 pathname functions generally accept both
'''  * slash forms, but the windows command line interpreter
'''  * only accepts backward slashes, because forward slashes are
'''  * used to demarcate switches (vs. dashes in unix).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pathname"> \param[in]    pathname  full path; can be a directory</param>
''' <param name="pdir"> \param[out]   pdir  [optional] root directory name of</param>
''' <param name="ptail"> \param[out]   ptail [optional] path tail, which is either</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="splitPathAtDirectory")> _
Friend Shared Function splitPathAtDirectory(pathname as String, pdir as String, ptail as String) as Integer
End Function

' SRC\utils2.c (2551, 1)
' splitPathAtExtension()
' splitPathAtExtension(const char *, char **, char **) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) If you only want the extension, input null for the basename ptr.
'''  *   (2) If you only want the basename without extension, input null
'''  * for the extension ptr.
'''  *   (3) This function makes decisions based only on the lexical
'''  * structure of the input.  Examples:
'''  *   /usr/tmp/abc.jpg  -->  basename: /usr/tmp/abc ext: .jpg
'''  *   /usr/tmp/.jpg  -->  basename: /usr/tmp/ ext: .jpg
'''  *   /usr/tmp.jpg/  -->  basename: /usr/tmp.jpg/   ext: [empty str]
'''  *   ./.jpg   -->  basename: ./  ext: .jpg
'''  *   (4) The input can have either forward (unix) or backward (win)
'''  * slash separators.  The output has unix separators.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pathname"> \param[in]    pathname full path; can be a directory</param>
''' <param name="pbasename"> \param[out]   pbasename [optional] pathname not including the</param>
''' <param name="pextension"> \param[out]   pextension [optional] path extension, which is</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="splitPathAtExtension")> _
Friend Shared Function splitPathAtExtension(pathname as String, pbasename as String, pextension as String) as Integer
End Function

' SRC\utils2.c (2630, 1)
' pathJoin()
' pathJoin(const char *, const char *) as char *
''' <summary>
''' * Notes:
'''  *   (1) Use unix-style pathname separators ('/').
'''  *   (2) %fname can be the entire path, or part of the path containing
'''  * at least one directory, or a tail without a directory, or NULL.
'''  *   (3) It produces a path that strips multiple slashes to a single
'''  * slash, joins %dir and %fname by a slash, and has no trailing
'''  * slashes (except in the cases where %dir == "/" and
'''  * %fname == NULL, or v.v.).
'''  *   (4) If both %dir and %fname are null, produces an empty string.
'''  *   (5) Neither %dir nor %fname can begin with '..'.
'''  *   (6) The result is not canonicalized or tested for correctness:
'''  * garbage in (e.g., /&%), garbage out.
'''  *   (7) Examples:
'''  * //tmp// + //abc/  -->  /tmp/abc
'''  * tmp/ + /abc/   -->  tmp/abc
'''  * tmp/ + abc/ -->  tmp/abc
'''  * /tmp/ + /// -->  /tmp
'''  * /tmp/ + NULL   -->  /tmp
'''  * // + /abc// -->  /abc
'''  * // + NULL   -->  /
'''  * NULL + /abc/def/  -->  /abc/def
'''  * NULL + abc//   -->  abc
'''  * NULL + //   -->  /
'''  * NULL + NULL -->  (empty string)
'''  * "" + ""  -->  (empty string)
'''  * "" + /   -->  /
'''  * ".." + /etc/foo   -->  NULL
'''  * /tmp + ".." -->  NULL
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  specially concatenated path, or NULL on error</returns>
''' <param name="dir"> \param[in]    dir [optional] can be null</param>
''' <param name="fname"> \param[in]    fname [optional] can be null</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pathJoin")> _
Friend Shared Function pathJoin(dir as String, fname as String) as String
End Function

' SRC\utils2.c (2709, 1)
' appendSubdirs()
' appendSubdirs(const char *, const char *) as char *
''' <summary>
''' * Notes:
'''  *   (1) Use unix pathname separators
'''  *   (2) Allocates a new string:  [basedir]/[subdirs]
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  concatenated full directory path without trailing slash,</returns>
''' <param name="basedir"> \param[in]    basedir</param>
''' <param name="subdirs"> \param[in]    subdirs</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="appendSubdirs")> _
Friend Shared Function appendSubdirs(basedir as String, subdirs as String) as String
End Function

' SRC\utils2.c (2761, 1)
' convertSepCharsInPath()
' convertSepCharsInPath(char *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) In-place conversion.
'''  *   (2) Type is the resulting type:
'''  *   * UNIX_PATH_SEPCHAR:  '\\' ==> '/'
'''  *   * WIN_PATH_SEPCHAR:   '/' ==> '\\'
'''  *   (3) Virtually all path operations in leptonica use unix separators.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="path"> \param[in]    path</param>
''' <param name="type"> \param[in]    type UNIX_PATH_SEPCHAR, WIN_PATH_SEPCHAR</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="convertSepCharsInPath")> _
Friend Shared Function convertSepCharsInPath(path as Object, type as Integer) as Integer
End Function

' SRC\utils2.c (2824, 1)
' genPathname()
' genPathname(const char *, const char *) as char *
''' <summary>
''' * Notes:
'''  *   (1) This function generates actual paths in the following ways:
'''  *   * from two sub-parts (e.g., a directory and a file name).
'''  *   * from a single path full path, placed in %dir, with
'''  *  %fname == NULL.
'''  *   * from the name of a file in the local directory placed in
'''  *  %fname, with %dir == NULL.
'''  *   * if in a "/tmp" directory and on windows, the windows
'''  *  temp directory is used.
'''  *   (2) On windows, if the root of %dir is '/tmp', this does a name
'''  * translation:
'''  * "/tmp"  ==>  [Temp] (windows)
'''  * where [Temp] is the windows temp directory.
'''  *   (3) On unix, the TMPDIR variable is ignored.  No rewriting
'''  * of temp directories is permitted.
'''  *   (4) There are four cases for the input:
'''  * (a) %dir is a directory and %fname is defined: result is a full path
'''  * (b) %dir is a directory and %fname is null: result is a directory
'''  * (c) %dir is a full path and %fname is null: result is a full path
'''  * (d) %dir is null or an empty string: start in the current dir;
'''  *  result is a full path
'''  *   (5) In all cases, the resulting pathname is not terminated with a slash
'''  *   (6) The caller is responsible for freeing the returned pathname.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pathname either a directory or full path, or NULL on error</returns>
''' <param name="dir"> \param[in]    dir [optional] directory or full path name, with or without</param>
''' <param name="fname"> \param[in]    fname [optional] file name within a directory</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="genPathname")> _
Friend Shared Function genPathname(dir as String, fname as String) as String
End Function

' SRC\utils2.c (2930, 1)
' makeTempDirname()
' makeTempDirname(char *, size_t, const char *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This generates the directory path for output temp files,
'''  * written into %result with unix separators.
'''  *   (2) Caller allocates %result, large enough to hold the path,
'''  * which is:
'''  *   /tmp/%subdir (unix)
'''  *   [Temp]/%subdir  (windows)
'''  * where [Temp] is a path on windows determined by GenTempPath()
'''  * and %subdir is in general a set of nested subdirectories:
'''  *   dir1/dir2/.../dirN
'''  * which in use would not typically exceed 2 levels.
'''  *   (3) Usage example:
'''  * \code
'''  *  char  result[256];
'''  *  makeTempDirname(result, 256, "lept/golden");
'''  * \endcode
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="result"> \param[in]    result preallocated on stack or heap and passed in</param>
''' <param name="nbytes"> \param[in]    nbytes size of %result array, in bytes</param>
''' <param name="subdir"> \param[in]    subdir [optional]; can be NULL or an empty string</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="makeTempDirname")> _
Friend Shared Function makeTempDirname(result as Object, nbytes as ULong, subdir as String) as Integer
End Function

' SRC\utils2.c (2980, 1)
' modifyTrailingSlash()
' modifyTrailingSlash(char *, size_t, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This carries out the requested action if necessary.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="path"> \param[in]    path preallocated on stack or heap and passed in</param>
''' <param name="nbytes"> \param[in]    nbytes size of %path array, in bytes</param>
''' <param name="flag"> \param[in]    flag L_ADD_TRAIL_SLASH or L_REMOVE_TRAIL_SLASH</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="modifyTrailingSlash")> _
Friend Shared Function modifyTrailingSlash(path as Object, nbytes as ULong, flag as Integer) as Integer
End Function

' SRC\utils2.c (3030, 1)
' l_makeTempFilename()
' l_makeTempFilename() as char *
''' <summary>
''' * Notes:
'''  *   (1) On unix, this makes a filename of the form
'''  *   "/tmp/lept.XXXXXX",
'''  * where each X is a random character.
'''  *   (2) On windows, this makes a filename of the form
'''  *   "/[Temp]/lp.XXXXXX".
'''  *   (3) On all systems, this fails if the file is not writable.
'''  *   (4) Safest usage is to write to a subdirectory in debug code.
'''  *   (5) The returned filename must be freed by the caller, using lept_free.
'''  *   (6) The tail of the filename has a '.', so that cygwin interprets
'''  * the file as having an extension.  Otherwise, cygwin assumes it
'''  * is an executable and appends ".exe" to the filename.
'''  *   (7) On unix, whenever possible use tmpfile() instead.  tmpfile()
'''  * hides the file name, returns a stream opened for write,
'''  * and deletes the temp file when the stream is closed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  fname : heap allocated filename; returns NULL on failure.</returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_makeTempFilename")> _
Friend Shared Function l_makeTempFilename() as String
End Function

' SRC\utils2.c (3086, 1)
' extractNumberFromFilename()
' extractNumberFromFilename(const char *, l_int32, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) The number is to be found in the basename, which is the
'''  * filename without either the directory or the last extension.
'''  *   (2) When a number is found, it is non-negative.  If no number
'''  * is found, this returns -1, without an error message.  The
'''  * caller needs to check.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  num number embedded in the filename; -1 on error or if</returns>
''' <param name="fname"> \param[in]    fname</param>
''' <param name="numpre"> \param[in]    numpre number of characters before the digits to be found</param>
''' <param name="numpost"> \param[in]    numpost number of characters after the digits to be found</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="extractNumberFromFilename")> _
Friend Shared Function extractNumberFromFilename(fname as String, numpre as Integer, numpost as Integer) as Integer
End Function

#End Region
#Region "SRC\warper.c"
' SRC\warper.c (68, 19)
' 
' generateRandomNumberArray(l_int32) as l_float64 *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="generateRandomNumberArray")> _
Friend Shared Function generateRandomNumberArray(size as Integer) as String
End Function

' SRC\warper.c (69, 16)
' applyWarpTransform()
' applyWarpTransform(l_float32, l_float32, l_float32, l_float32, l_float64 *, l_int32, l_int32, l_int32, l_int32, l_float32 *, l_float32 *) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="applyWarpTransform")> _
Friend Shared Function applyWarpTransform(xmag as single, ymag as single, xfreq as single, yfreq as single, randa as Double, nx as Integer, ny as Integer, xp as Integer, yp as Integer, px as single, py as single) as Integer
End Function

' SRC\warper.c (107, 1)
' pixSimpleCaptcha()
' pixSimpleCaptcha(PIX *, l_int32, l_int32, l_uint32, l_uint32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This uses typical default values for generating captchas.
'''  * The magnitudes of the harmonic warp are typically to be
'''  * smaller when more terms are used, even though the phases
'''  * are random.  See, for example, prog/warptest.c.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp cmap or 32 bpp rgb, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp; no colormap</param>
''' <param name="border"> \param[in]    border added white pixels on each side</param>
''' <param name="nterms"> \param[in]    nterms number of x and y harmonic terms</param>
''' <param name="seed"> \param[in]    seed of random number generator</param>
''' <param name="color"> \param[in]    color for colorizing; in 0xrrggbb00 format; use 0 for black</param>
''' <param name="cmapflag"> \param[in]    cmapflag 1 for colormap output; 0 for rgb</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSimpleCaptcha")> _
Friend Shared Function pixSimpleCaptcha(pixs as IntPTR, border as Integer, nterms as Integer, seed as UInteger, color as UInteger, cmapflag as Integer) as IntPTR
End Function

' SRC\warper.c (181, 1)
' pixRandomHarmonicWarp()
' pixRandomHarmonicWarp(PIX *, l_float32, l_float32, l_float32, l_float32, l_int32, l_int32, l_uint32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) To generate the warped image p(x',y'), set up the transforms
'''  * that are in getWarpTransform().  For each (x',y') in the
'''  * dest, the warp function computes the originating location
'''  * (x, y) in the src.  The differences (x - x') and (y - y')
'''  * are given as a sum of products of sinusoidal terms.  Each
'''  * term is multiplied by a maximum amplitude (in pixels), and the
'''  * angle is determined by a frequency and phase, and depends
'''  * on the (x', y') value of the dest.  Random numbers with
'''  * a variable input seed are used to allow the warping to be
'''  * unpredictable.  A linear interpolation is used to find
'''  * the value for the source at (x, y); this value is written
'''  * into the dest.
'''  *   (2) This can be used to generate 'captcha's, which are somewhat
'''  * randomly distorted images of text.  A typical set of parameters
'''  * for a captcha are:
'''  *  xmag = 4.0  ymag = 6.0
'''  *  xfreq = 0.10   yfreq = 0.13
'''  *  nx = 3   ny = 3
'''  * Other examples can be found in prog/warptest.c.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 8 bpp; no colormap, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 bpp; no colormap</param>
''' <param name="xmag"> \param[in]    xmag, ymag maximum magnitude of x and y distortion</param>
''' <param name="ymag"> \param[in]    xfreq, yfreq maximum magnitude of x and y frequency</param>
''' <param name="xfreq"> \param[in]    nx, ny number of x and y harmonic terms</param>
''' <param name="yfreq"> \param[in]    seed of random number generator</param>
''' <param name="nx"> \param[in]    grayval color brought in from the outside;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixRandomHarmonicWarp")> _
Friend Shared Function pixRandomHarmonicWarp(pixs as IntPTR, xmag as single, ymag as single, xfreq as single, yfreq as single, nx as Integer, ny as Integer, seed as UInteger, grayval as Integer) as IntPTR
End Function

' SRC\warper.c (586, 1)
' pixWarpStereoscopic()
' pixWarpStereoscopic(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This function splits out the red channel, mucks around with
'''  * it, then recombines with the unmolested cyan channel.
'''  *   (2) By using a quadratically increasing shift of the red
'''  * pixels horizontally and away from the vertical centerline,
'''  * the image appears to bend quadratically out of the image
'''  * plane, symmetrically with respect to the vertical center
'''  * line.  A positive value of %zbend causes the plane to be
'''  * curved away from the viewer.  We use linearly interpolated
'''  * stretching to avoid the appearance of kinks in the curve.
'''  *   (3) The parameters %zshiftt and %zshiftb tilt the image plane
'''  * about a horizontal line through the center, and at the
'''  * same time move that line either in toward the viewer or away.
'''  * This is implemented by a combination of horizontal shear
'''  * about the center line (for the tilt) and horizontal
'''  * translation (to move the entire plane in or out).
'''  * A positive value of %zshiftt moves the top of the plane
'''  * away from the viewer, and a positive value of %zshiftb
'''  * moves the bottom of the plane away.  We use linear interpolated
'''  * shear to avoid visible vertical steps in the tilted image.
'''  *   (4) The image can be bent in the plane and about the vertical
'''  * centerline.  The centerline does not shift, and the
'''  * parameter %ybend gives the relative shift at left and right
'''  * edges, with a downward shift for positive values of %ybend.
'''  *   (6) When writing out a steroscopic (red/cyan) image in jpeg,
'''  * first call pixSetChromaSampling(pix, 0) to get sufficient
'''  * resolution in the red channel.
'''  *   (7) Typical values are:
'''  * zbend = 20
'''  * zshiftt = 15
'''  * zshiftb = -15
'''  * ybendt = 30
'''  * ybendb = 0
'''  * If the disparity z-values are too large, it is difficult for
'''  * the brain to register the two images.
'''  *   (8) This function has been cleverly reimplemented by Jeff Breidenbach.
'''  * The original implementation used two 32 bpp rgb images,
'''  * and merged them at the end.  The result is somewhat faded,
'''  * and has a parameter "thresh" that controls the amount of
'''  * color in the result.  (The present implementation avoids these
'''  * two problems, skipping both the colorization and the alpha
'''  * blending at the end, and is about 3x faster)
'''  * The basic operations with 32 bpp are as follows:
'''  *   // Immediate conversion to 32 bpp
'''  *   Pix *pixt1 = pixConvertTo32(pixs);
'''  *   // Do vertical shear
'''  *   Pix *pixr = pixQuadraticVerticalShear(pixt1, L_WARP_TO_RIGHT,
'''  *     ybendt, ybendb,
'''  *     L_BRING_IN_WHITE);
'''  *   // Colorize two versions, toward red and cyan
'''  *   Pix *pixc = pixCopy(NULL, pixr);
'''  *   l_int32 thresh = 150;  // if higher, get less original color
'''  *   pixColorGray(pixr, NULL, L_PAINT_DARK, thresh, 255, 0, 0);
'''  *   pixColorGray(pixc, NULL, L_PAINT_DARK, thresh, 0, 255, 255);
'''  *   // Shift the red pixels; e.g., by stretching
'''  *   Pix *pixrs = pixStretchHorizontal(pixr, L_WARP_TO_RIGHT,
'''  *    L_QUADRATIC_WARP, zbend,
'''  *    L_INTERPOLATED,
'''  *    L_BRING_IN_WHITE);
'''  *   // Blend the shifted red and unshifted cyan 50:50
'''  *   Pix *pixg = pixCreate(w, h, 8);
'''  *   pixSetAllArbitrary(pixg, 128);
'''  *   pixd = pixBlendWithGrayMask(pixrs, pixc, pixg, 0, 0);
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd 32 bpp, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs any depth, colormap ok</param>
''' <param name="zbend"> \param[in]    zbend horizontal separation in pixels of red and cyan</param>
''' <param name="zshiftt"> \param[in]    zshiftt uniform pixel translation difference between</param>
''' <param name="zshiftb"> \param[in]    zshiftb uniform pixel translation difference between</param>
''' <param name="ybendt"> \param[in]    ybendt multiplicative parameter for in-plane vertical</param>
''' <param name="ybendb"> \param[in]    ybendb same as ybendt, except at the left or right edge</param>
''' <param name="redleft"> \param[in]    redleft 1 if the red filter is on the left; 0 otherwise</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWarpStereoscopic")> _
Friend Shared Function pixWarpStereoscopic(pixs as IntPTR, zbend as Integer, zshiftt as Integer, zshiftb as Integer, ybendt as Integer, ybendb as Integer, redleft as Integer) as IntPTR
End Function

' SRC\warper.c (733, 1)
' pixStretchHorizontal()
' pixStretchHorizontal(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) If %hmax > 0, this is an increase in the coordinate value of
'''  * pixels in pixd, relative to the same pixel in pixs.
'''  *   (2) If %dir == L_WARP_TO_LEFT, the pixels on the right edge of
'''  * the image are not moved. So, for example, if %hmax > 0
'''  * and %dir == L_WARP_TO_LEFT, the pixels in pixd are
'''  * contracted toward the right edge of the image, relative
'''  * to those in pixs.
'''  *   (3) If %type == L_LINEAR_WARP, the pixel positions are moved
'''  * to the left or right by an amount that varies linearly with
'''  * the horizontal location.
'''  *   (4) If %operation == L_SAMPLED, the dest pixels are taken from
'''  * the nearest src pixel.  Otherwise, we use linear interpolation
'''  * between pairs of sampled pixels.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd stretched/compressed, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 8 or 32 bpp</param>
''' <param name="dir"> \param[in]    dir L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
''' <param name="type"> \param[in]    type L_LINEAR_WARP or L_QUADRATIC_WARP</param>
''' <param name="hmax"> \param[in]    hmax horizontal displacement at edge</param>
''' <param name="operation"> \param[in]    operation L_SAMPLED or L_INTERPOLATED</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixStretchHorizontal")> _
Friend Shared Function pixStretchHorizontal(pixs as IntPTR, dir as Integer, type as Integer, hmax as Integer, operation as Integer, incolor as Integer) as IntPTR
End Function

' SRC\warper.c (785, 1)
' pixStretchHorizontalSampled()
' pixStretchHorizontalSampled(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixStretchHorizontal() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd stretched/compressed, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 8 or 32 bpp</param>
''' <param name="dir"> \param[in]    dir L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
''' <param name="type"> \param[in]    type L_LINEAR_WARP or L_QUADRATIC_WARP</param>
''' <param name="hmax"> \param[in]    hmax horizontal displacement at edge</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixStretchHorizontalSampled")> _
Friend Shared Function pixStretchHorizontalSampled(pixs as IntPTR, dir as Integer, type as Integer, hmax as Integer, incolor as Integer) as IntPTR
End Function

' SRC\warper.c (883, 1)
' pixStretchHorizontalLI()
' pixStretchHorizontalLI(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixStretchHorizontal() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd stretched/compressed, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 8 or 32 bpp</param>
''' <param name="dir"> \param[in]    dir L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
''' <param name="type"> \param[in]    type L_LINEAR_WARP or L_QUADRATIC_WARP</param>
''' <param name="hmax"> \param[in]    hmax horizontal displacement at edge</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixStretchHorizontalLI")> _
Friend Shared Function pixStretchHorizontalLI(pixs as IntPTR, dir as Integer, type as Integer, hmax as Integer, incolor as Integer) as IntPTR
End Function

' SRC\warper.c (1019, 1)
' pixQuadraticVShear()
' pixQuadraticVShear(PIX *, l_int32, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) This gives a quadratic bending, upward or downward, as you
'''  * move to the left or right.
'''  *   (2) If %dir == L_WARP_TO_LEFT, the right edge is unchanged, and
'''  * the left edge pixels are moved maximally up or down.
'''  *   (3) Parameters %vmaxt and %vmaxb control the maximum amount of
'''  * vertical pixel shear at the top and bottom, respectively.
'''  * If %vmaxt > 0, the vertical displacement of pixels at the
'''  * top is downward.  Likewise, if %vmaxb > 0, the vertical
'''  * displacement of pixels at the bottom is downward.
'''  *   (4) If %operation == L_SAMPLED, the dest pixels are taken from
'''  * the nearest src pixel.  Otherwise, we use linear interpolation
'''  * between pairs of sampled pixels.
'''  *   (5) This is for quadratic shear.  For uniform (linear) shear,
'''  * use the standard shear operators.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd stretched, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 8 or 32 bpp</param>
''' <param name="dir"> \param[in]    dir L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
''' <param name="vmaxt"> \param[in]    vmaxt max vertical displacement at edge and at top</param>
''' <param name="vmaxb"> \param[in]    vmaxb max vertical displacement at edge and at bottom</param>
''' <param name="operation"> \param[in]    operation L_SAMPLED or L_INTERPOLATED</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixQuadraticVShear")> _
Friend Shared Function pixQuadraticVShear(pixs as IntPTR, dir as Integer, vmaxt as Integer, vmaxb as Integer, operation as Integer, incolor as Integer) as IntPTR
End Function

' SRC\warper.c (1073, 1)
' pixQuadraticVShearSampled()
' pixQuadraticVShearSampled(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixQuadraticVShear() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd stretched, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 1, 8 or 32 bpp</param>
''' <param name="dir"> \param[in]    dir L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
''' <param name="vmaxt"> \param[in]    vmaxt max vertical displacement at edge and at top</param>
''' <param name="vmaxb"> \param[in]    vmaxb max vertical displacement at edge and at bottom</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixQuadraticVShearSampled")> _
Friend Shared Function pixQuadraticVShearSampled(pixs as IntPTR, dir as Integer, vmaxt as Integer, vmaxb as Integer, incolor as Integer) as IntPTR
End Function

' SRC\warper.c (1179, 1)
' pixQuadraticVShearLI()
' pixQuadraticVShearLI(PIX *, l_int32, l_int32, l_int32, l_int32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) See pixQuadraticVShear() for details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd stretched, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs 8 or 32 bpp, or colormapped</param>
''' <param name="dir"> \param[in]    dir L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
''' <param name="vmaxt"> \param[in]    vmaxt max vertical displacement at edge and at top</param>
''' <param name="vmaxb"> \param[in]    vmaxb max vertical displacement at edge and at bottom</param>
''' <param name="incolor"> \param[in]    incolor L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixQuadraticVShearLI")> _
Friend Shared Function pixQuadraticVShearLI(pixs as IntPTR, dir as Integer, vmaxt as Integer, vmaxb as Integer, incolor as Integer) as IntPTR
End Function

' SRC\warper.c (1332, 1)
' pixStereoFromPair()
' pixStereoFromPair(PIX *, PIX *, l_float32, l_float32, l_float32) as PIX *
''' <summary>
''' * Notes:
'''  *   (1) pix1 and pix2 are a pair of stereo images, ideally taken
'''  * concurrently in the same plane, with some lateral translation.
'''  *   (2) The output red channel is determined from %pix1.
'''  * The output green and blue channels are taken from the green
'''  * and blue channels, respectively, of %pix2.
'''  *   (3) The weights determine how much of each component in %pix1
'''  * goes into the output red channel.  The sum of weights
'''  * must be 1.0.  If it's not, we scale the weights to
'''  * satisfy this criterion.
'''  *   (4) The most general pixel mapping allowed here is:
'''  *   rval = rwt * r1 + gwt * g1 + bwt * b1  (from pix1)
'''  *   gval = g2   (from pix2)
'''  *   bval = b2   (from pix2)
'''  *   (5) The simplest method is to use rwt = 1.0, gwt = 0.0, bwt = 0.0,
'''  * but this causes unpleasant visual artifacts with red in the image.
'''  * Use of green and blue from %pix1 in the red channel,
'''  * instead of red, tends to fix that problem.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd stereo enhanced, or NULL on error</returns>
''' <param name="pix1"> \param[in]    pix1 32 bpp rgb</param>
''' <param name="pix2"> \param[in]    pix2 32 bpp rgb</param>
''' <param name="rwt"> \param[in]    rwt, gwt, bwt weighting factors used for each component in</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixStereoFromPair")> _
Friend Shared Function pixStereoFromPair(pix1 as IntPTR, pix2 as IntPTR, rwt as single, gwt as single, bwt as single) as IntPTR
End Function

#End Region
#Region "SRC\watershed.c"
' SRC\watershed.c (143, 13)
' wshedSaveBasin()
' wshedSaveBasin(L_WSHED *, l_int32, l_int32) as void
''' <summary>
''' * Notes:
'''  *   (1) This identifies a single watershed.  It does not change
'''  * the LUT, which must be done subsequently.
'''  *   (2) The fill level of a basin is taken to be %level - 1.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="wshed"> \param[in]    wshed</param>
''' <param name="index"> \param[in]    index index of basin to be located</param>
''' <param name="level"> \param[in]    level filling level reached at the time this function</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="wshedSaveBasin")> _
Friend Shared Function wshedSaveBasin(wshed as IntPTR, index as Integer, level as Integer) as Boolean ' Org. Void
End Function

' SRC\watershed.c (145, 16)
' identifyWatershedBasin()
' identifyWatershedBasin(L_WSHED *, l_int32, l_int32, BOX **, PIX **) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This is a static function, so we assume pixlab, pixs and pixt
'''  * exist and are the same size.
'''  *   (2) It selects all pixels that have the label %index in pixlab
'''  * and that have a value in pixs that is less than %level.
'''  *   (3) It is used whenever two seeded basins meet (typically at a saddle),
'''  * or when one seeded basin meets a 'filler'.  All identified
'''  * basins are saved as a watershed.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="wshed"> \param[in]    wshed</param>
''' <param name="index"> \param[in]    index index of basin to be located</param>
''' <param name="level"> \param[in]    level of basin at point at which the two basins met</param>
''' <param name="pbox"> \param[out]   pbox bounding box of basin</param>
''' <param name="ppixd"> \param[out]   ppixd pix of basin, cropped to its bounding box</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="identifyWatershedBasin")> _
Friend Shared Function identifyWatershedBasin(wshed as IntPTR, index as Integer, level as Integer, pbox as Object, ppixd as Object) as Integer
End Function

' SRC\watershed.c (150, 16)
' mergeLookup()
' mergeLookup(L_WSHED *, l_int32, l_int32) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) The links are a sparse array of Numas showing current back-links.
'''  * The lut gives the current index (of the seed or the minima
'''  * for the wshed  in which it is located.
'''  *   (2) Think of each entry in the lut.  There are two types:
'''  * owner:  lut[index] = index
'''  * redirect:  lut[index] != index
'''  *   (3) This is called each time a merge occurs.  It puts the lut
'''  * and backlinks in a canonical form after the merge, where
'''  * all entries in the lut point to the current "owner", which
'''  * has all backlinks.  That is, every "redirect" in the lut
'''  * points to an "owner".  The lut always gives the index of
'''  * the current owner.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="wshed"> \param[in]    wshed</param>
''' <param name="sindex"> \param[in]    sindex primary index being changed in the merge</param>
''' <param name="dindex"> \param[in]    dindex index that %sindex will point to after the merge</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="mergeLookup")> _
Friend Shared Function mergeLookup(wshed as IntPTR, sindex as Integer, dindex as Integer) as Integer
End Function

' SRC\watershed.c (154, 16)
' wshedGetHeight()
' wshedGetHeight(L_WSHED *, l_int32, l_int32, l_int32 *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) It is only necessary to find the height for a watershed
'''  * that is indexed by a seed or a minima.  This function should
'''  * not be called on a finished watershed (that continues to fill).
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="wshed"> \param[in]    wshed array of current indices</param>
''' <param name="val"> \param[in]    val value of current pixel popped off queue</param>
''' <param name="label"> \param[in]    label of pixel or 32 bpp label image</param>
''' <param name="pheight"> \param[out]   pheight height of current value from seed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="wshedGetHeight")> _
Friend Shared Function wshedGetHeight(wshed as IntPTR, val as Integer, label as Integer, pheight as Integer) as Integer
End Function

' SRC\watershed.c (158, 13)
' 
' pushNewPixel(L_QUEUE *, l_int32, l_int32, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pushNewPixel")> _
Friend Shared Function pushNewPixel(lq as IntPTR, x as Integer, y as Integer, pminx as Integer, pmaxx as Integer, pminy as Integer, pmaxy as Integer) as Boolean ' Org. Void
End Function

' SRC\watershed.c (161, 13)
' 
' popNewPixel(L_QUEUE *, l_int32 *, l_int32 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="popNewPixel")> _
Friend Shared Function popNewPixel(lq as IntPTR, px as Integer, py as Integer) as Boolean ' Org. Void
End Function

' SRC\watershed.c (164, 13)
' 
' pushWSPixel(L_HEAP *, L_STACK *, l_int32, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pushWSPixel")> _
Friend Shared Function pushWSPixel(lh as IntPTR, stack as IntPTR, val as Integer, x as Integer, y as Integer, index as Integer) as Boolean ' Org. Void
End Function

' SRC\watershed.c (166, 13)
' 
' popWSPixel(L_HEAP *, L_STACK *, l_int32 *, l_int32 *, l_int32 *, l_int32 *) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="popWSPixel")> _
Friend Shared Function popWSPixel(lh as IntPTR, stack as IntPTR, pval as Integer, px as Integer, py as Integer, pindex as Integer) as Boolean ' Org. Void
End Function

' SRC\watershed.c (170, 13)
' 
' debugPrintLUT(l_int32 *, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="debugPrintLUT")> _
Friend Shared Function debugPrintLUT(lut as Integer, size as Integer, debug as Integer) as Boolean ' Org. Void
End Function

' SRC\watershed.c (172, 13)
' 
' debugWshedMerge(L_WSHED *, char *, l_int32, l_int32, l_int32, l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="debugWshedMerge")> _
Friend Shared Function debugWshedMerge(wshed as IntPTR, descr as Object, x as Integer, y as Integer, label as Integer, index as Integer) as Boolean ' Org. Void
End Function

' SRC\watershed.c (203, 1)
' wshedCreate()
' wshedCreate(PIX *, PIX *, l_int32, l_int32) as L_WSHED *
''' <summary>
''' * Notes:
'''  *   (1) It is not necessary for the fg pixels in the seed image
'''  * be at minima, or that they be isolated.  We extract a
'''  * single pixel from each connected component, and a seed
'''  * anywhere in a watershed will eventually label the watershed
'''  * when the filling level reaches it.
'''  *   (2) Set mindepth to some value to ignore noise in pixs that
'''  * can create small local minima.  Any watershed shallower
'''  * than mindepth, even if it has a seed, will not be saved;
'''  * It will either be incorporated in another watershed or
'''  * eliminated.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  WShed, or NULL on error</returns>
''' <param name="pixs"> \param[in]    pixs  8 bpp source</param>
''' <param name="pixm"> \param[in]    pixm  1 bpp 'marker' seed</param>
''' <param name="mindepth"> \param[in]    mindepth minimum depth; anything less is not saved</param>
''' <param name="debugflag"> \param[in]    debugflag 1 for debug output</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="wshedCreate")> _
Friend Shared Function wshedCreate(pixs as IntPTR, pixm as IntPTR, mindepth as Integer, debugflag as Integer) as IntPTR
End Function

' SRC\watershed.c (250, 1)
' wshedDestroy()
' wshedDestroy(L_WSHED **) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  void</returns>
''' <param name="pwshed"> \param[in,out]   pwshed will be set to null before returning</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="wshedDestroy")> _
Friend Shared Function wshedDestroy(pwshed as Object) as Boolean ' Org. Void
End Function

' SRC\watershed.c (305, 1)
' wshedApply()
' wshedApply(L_WSHED *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="wshed"> \param[in]    wshed generated from wshedCreate()</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="wshedApply")> _
Friend Shared Function wshedApply(wshed as IntPTR) as Integer
End Function

' SRC\watershed.c (1034, 1)
' wshedBasins()
' wshedBasins(L_WSHED *, PIXA **, NUMA **) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="wshed"> \param[in]    wshed</param>
''' <param name="ppixa"> \param[out]   ppixa  [optional] mask of watershed basins</param>
''' <param name="pnalevels"> \param[out]   pnalevels   [optional] watershed levels</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="wshedBasins")> _
Friend Shared Function wshedBasins(wshed as IntPTR, ppixa as Object, pnalevels as Object) as Integer
End Function

' SRC\watershed.c (1058, 1)
' wshedRenderFill()
' wshedRenderFill(L_WSHED *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd initial image with all basins filled, or NULL on error</returns>
''' <param name="wshed"> \param[in]    wshed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="wshedRenderFill")> _
Friend Shared Function wshedRenderFill(wshed as IntPTR) as IntPTR
End Function

' SRC\watershed.c (1094, 1)
' wshedRenderColors()
' wshedRenderColors(L_WSHED *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  pixd initial image with all basins filled, or NULL on error</returns>
''' <param name="wshed"> \param[in]    wshed</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="wshedRenderColors")> _
Friend Shared Function wshedRenderColors(wshed as IntPTR) as IntPTR
End Function

#End Region
#Region "SRC\webpiostub.c"
' SRC\webpiostub.c (45, 7)
' 
' pixReadStreamWebP(FILE *) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadStreamWebP")> _
Friend Shared Function pixReadStreamWebP(fp as Object) as IntPTR
End Function

' SRC\webpiostub.c (52, 7)
' 
' pixReadMemWebP(const l_uint8 *, size_t) as PIX *
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixReadMemWebP")> _
Friend Shared Function pixReadMemWebP(filedata as Byte, filesize as ULong) as IntPTR
End Function

' SRC\webpiostub.c (59, 6)
' 
' readHeaderWebP(const char *, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readHeaderWebP")> _
Friend Shared Function readHeaderWebP(filename as String, pw as Integer, ph as Integer, pspp as Integer) as Integer
End Function

' SRC\webpiostub.c (67, 6)
' 
' readHeaderMemWebP(const l_uint8 *, size_t, l_int32 *, l_int32 *, l_int32 *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="readHeaderMemWebP")> _
Friend Shared Function readHeaderMemWebP(data as Byte, size as ULong, pw as Integer, ph as Integer, pspp as Integer) as Integer
End Function

' SRC\webpiostub.c (75, 6)
' 
' pixWriteWebP(const char *, PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteWebP")> _
Friend Shared Function pixWriteWebP(filename as String, pixs as IntPTR, quality as Integer, lossless as Integer) as Integer
End Function

' SRC\webpiostub.c (83, 6)
' 
' pixWriteStreamWebP(FILE *, PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStreamWebP")> _
Friend Shared Function pixWriteStreamWebP(fp as Object, pixs as IntPTR, quality as Integer, lossless as Integer) as Integer
End Function

' SRC\webpiostub.c (91, 6)
' 
' pixWriteMemWebP(l_uint8 **, size_t *, PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMemWebP")> _
Friend Shared Function pixWriteMemWebP(pencdata as Object, pencsize as ULong, pixs as IntPTR, quality as Integer, lossless as Integer) as Integer
End Function

#End Region
#Region "SRC\writefile.c"
' SRC\writefile.c (182, 1)
' l_jpegSetQuality()
' l_jpegSetQuality(l_int32) as l_int32
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return       prev           previous quality</returns>
''' <param name="new_quality"> \param[in]    new_quality    1 - 100; 75 is default; 0 defaults to 75</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_jpegSetQuality")> _
Friend Shared Function l_jpegSetQuality(new_quality as Integer) as Integer
End Function

' SRC\writefile.c (217, 1)
' setLeptDebugOK()
' setLeptDebugOK(l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return       void</returns>
''' <param name="allow"> \param[in]    allow     TRUE (1) or FALSE (0)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="setLeptDebugOK")> _
Friend Shared Function setLeptDebugOK(allow as Integer) as Boolean ' Org. Void
End Function

' SRC\writefile.c (242, 1)
' pixaWriteFiles()
' pixaWriteFiles(const char *, PIXA *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Use %format = IFF_DEFAULT to decide the output format
'''  * individually for each pix.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="rootname"> \param[in]    rootname</param>
''' <param name="pixa"> \param[in]    pixa</param>
''' <param name="format"> \param[in]    format  defined in imageio.h; see notes for default</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixaWriteFiles")> _
Friend Shared Function pixaWriteFiles(rootname as String, pixa as IntPTR, format as Integer) as Integer
End Function

' SRC\writefile.c (295, 1)
' pixWriteDebug()
' pixWriteDebug(const char *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Debug version, intended for use in the library when writing
'''  * to files in a temp directory with names that are compiled in.
'''  * This is used instead of pixWrite() for all such library calls.
'''  *   (2) The global variable LeptDebugOK defaults to 0, and can be set
'''  * or cleared by the function setLeptDebugOK().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fname"> \param[in]    fname</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="format"> \param[in]    format  defined in imageio.h</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteDebug")> _
Friend Shared Function pixWriteDebug(fname as String, pix as IntPTR, format as Integer) as Integer
End Function

' SRC\writefile.c (332, 1)
' pixWrite()
' pixWrite(const char *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Open for write using binary mode (with the "b" flag)
'''  * to avoid having Windows automatically translate the NL
'''  * into CRLF, which corrupts image files.  On non-windows
'''  * systems this flag should be ignored, per ISO C90.
'''  * Thanks to Dave Bryan for pointing this out.
'''  *   (2) If the default image format IFF_DEFAULT is requested:
'''  * use the input format if known; otherwise, use a lossless format.
'''  *   (3) The default jpeg quality is 75.  For some other value,
'''  * Use l_jpegSetQuality().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fname"> \param[in]    fname</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="format"> \param[in]    format  defined in imageio.h</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWrite")> _
Friend Shared Function pixWrite(fname as String, pix as IntPTR, format as Integer) as Integer
End Function

' SRC\writefile.c (365, 1)
' pixWriteAutoFormat()
' pixWriteAutoFormat(const char *, PIX *) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pix"> \param[in]    pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteAutoFormat")> _
Friend Shared Function pixWriteAutoFormat(filename as String, pix as IntPTR) as Integer
End Function

' SRC\writefile.c (392, 1)
' pixWriteStream()
' pixWriteStream(FILE *, PIX *, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error.</returns>
''' <param name="fp"> \param[in]    fp file stream</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="format"> \param[in]    format</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteStream")> _
Friend Shared Function pixWriteStream(fp as Object, pix as IntPTR, format as Integer) as Integer
End Function

' SRC\writefile.c (484, 1)
' pixWriteImpliedFormat()
' pixWriteImpliedFormat(const char *, PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This determines the output format from the filename extension.
'''  *   (2) The last two args are ignored except for requests for jpeg files.
'''  *   (3) The jpeg default quality is 75.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="filename"> \param[in]    filename</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="quality"> \param[in]    quality iff JPEG; 1 - 100, 0 for default</param>
''' <param name="progressive"> \param[in]    progressive iff JPEG; 0 for baseline seq., 1 for progressive</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteImpliedFormat")> _
Friend Shared Function pixWriteImpliedFormat(filename as String, pix as IntPTR, quality as Integer, progressive as Integer) as Integer
End Function

' SRC\writefile.c (549, 1)
' pixChooseOutputFormat()
' pixChooseOutputFormat(PIX *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This should only be called if the requested format is IFF_DEFAULT.
'''  *   (2) If the pix wasn't read from a file, its input format value
'''  * will be IFF_UNKNOWN, and in that case it is written out
'''  * in a compressed but lossless format.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  output format, or 0 on error</returns>
''' <param name="pix"> \param[in]    pix</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixChooseOutputFormat")> _
Friend Shared Function pixChooseOutputFormat(pix as IntPTR) as Integer
End Function

' SRC\writefile.c (584, 1)
' getImpliedFileFormat()
' getImpliedFileFormat(const char *) as l_int32
''' <summary>
''' * Notes:
'''  *   (1) This determines the output file format from the extension
'''  * of the input filename.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  output format, or IFF_UNKNOWN on error or invalid extension.</returns>
''' <param name="filename"> \param[in]    filename</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getImpliedFileFormat")> _
Friend Shared Function getImpliedFileFormat(filename as String) as Integer
End Function

' SRC\writefile.c (625, 1)
' pixGetAutoFormat()
' pixGetAutoFormat(PIX *, l_int32 *) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) The output formats are restricted to tiff, jpeg and png
'''  * because these are the most commonly used image formats and
'''  * the ones that are typically installed with leptonica.
'''  *   (2) This decides what compression to use based on the pix.
'''  * It chooses tiff-g4 if 1 bpp without a colormap, jpeg with
'''  * quality 75 if grayscale, rgb or rgba (where it loses
'''  * the alpha layer), and lossless png for all other situations.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="pformat"> \param[in]    &format</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixGetAutoFormat")> _
Friend Shared Function pixGetAutoFormat(pix as IntPTR, pformat as Integer) as Integer
End Function

' SRC\writefile.c (666, 1)
' getFormatExtension()
' getFormatExtension(l_int32) as const char *
''' <summary>
''' * Notes:
'''  *   (1) This string is NOT owned by the caller; it is just a pointer
'''  * to a global string.  Do not free it.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  extension string, or NULL if format is out of range</returns>
''' <param name="format"> \param[in]    format integer</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="getFormatExtension")> _
Friend Shared Function getFormatExtension(format as Integer) as String
End Function

' SRC\writefile.c (701, 1)
' pixWriteMem()
' pixWriteMem(l_uint8 **, size_t *, PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) On windows, this will only write tiff and PostScript to memory.
'''  * For other formats, it requires open_memstream(3).
'''  *   (2) PostScript output is uncompressed, in hex ascii.
'''  * Most printers support level 2 compression (tiff_g4 for 1 bpp,
'''  * jpeg for 8 and 32 bpp).
'''  *   (3) The default jpeg quality is 75.  For some other value,
'''  * Use l_jpegSetQuality().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error</returns>
''' <param name="pdata"> \param[out]   pdata data of tiff compressed image</param>
''' <param name="psize"> \param[out]   psize size of returned data</param>
''' <param name="pix"> \param[in]    pix</param>
''' <param name="format"> \param[in]    format  defined in imageio.h</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixWriteMem")> _
Friend Shared Function pixWriteMem(pdata as Object, psize as ULong, pix as IntPTR, format as Integer) as Integer
End Function

' SRC\writefile.c (801, 1)
' l_fileDisplay()
' l_fileDisplay(const char *, l_int32, l_int32, l_float32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is a convenient wrapper for displaying image files.
'''  *   (2) It does nothing unless LeptDebugOK == TRUE.
'''  *   (2) Set %scale = 0 to disable display.
'''  *   (3) This downscales 1 bpp to gray.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="fname"> \param[in]    fname</param>
''' <param name="x"> \param[in]    x, y  location of display frame on the screen</param>
''' <param name="y"> \param[in]    scale  scale factor (use 0 to skip display)</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_fileDisplay")> _
Friend Shared Function l_fileDisplay(fname as String, x as Integer, y as Integer, scale as single) as Integer
End Function

' SRC\writefile.c (877, 1)
' pixDisplay()
' pixDisplay(PIX *, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) This is debugging code that displays an image on the screen.
'''  * It uses a static internal variable to number the output files
'''  * written by a single process.  Behavior with a shared library
'''  * may be unpredictable.
'''  *   (2) It does nothing unless LeptDebugOK == TRUE.
'''  *   (3) It uses these programs to display the image:
'''  * On Unix: xzgv, xli or xv
'''  * On Windows: i_view
'''  * The display program must be on your $PATH variable.  It is
'''  * chosen by setting the global var_DISPLAY_PROG, using
'''  * l_chooseDisplayProg().  Default on Unix is xzgv.
'''  *   (4) Images with dimensions larger than MAX_DISPLAY_WIDTH or
'''  * MAX_DISPLAY_HEIGHT are downscaled to fit those constraints.
'''  * This is particularly important for displaying 1 bpp images
'''  * with xv, because xv automatically downscales large images
'''  * by subsampling, which looks poor.  For 1 bpp, we use
'''  * scale-to-gray to get decent-looking anti-aliased images.
'''  * In all cases, we write a temporary file to /tmp/lept/disp,
'''  * that is read by the display program.
'''  *   (5) The temporary file is written as png if, after initial
'''  * processing for special cases, any of these obtain:
'''  *   * pix dimensions are smaller than some thresholds
'''  *   * pix depth is less than 8 bpp
'''  *   * pix is colormapped
'''  *   (6) For spp == 4, we call pixDisplayLayersRGBA() to show 3
'''  * versions of the image: the image with a fully opaque
'''  * alpha, the alpha, and the image as it would appear with
'''  * a white background.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pix 1, 2, 4, 8, 16, 32 bpp</param>
''' <param name="x"> \param[in]    x, y  location of display frame on the screen</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDisplay")> _
Friend Shared Function pixDisplay(pixs as IntPTR, x as Integer, y as Integer) as Integer
End Function

' SRC\writefile.c (901, 1)
' pixDisplayWithTitle()
' pixDisplayWithTitle(PIX *, l_int32, l_int32, const char *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) See notes for pixDisplay().
'''  *   (2) This displays the image if dispflag == 1; otherwise it punts.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pix 1, 2, 4, 8, 16, 32 bpp</param>
''' <param name="x"> \param[in]    x, y  location of display frame</param>
''' <param name="y"> \param[in]    title [optional] on frame; can be NULL;</param>
''' <param name="title"> \param[in]    dispflag 1 to write, else disabled</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDisplayWithTitle")> _
Friend Shared Function pixDisplayWithTitle(pixs as IntPTR, x as Integer, y as Integer, title as String, dispflag as Integer) as Integer
End Function

' SRC\writefile.c (1077, 1)
' pixSaveTiled()
' pixSaveTiled(PIX *, PIXA *, l_float32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 32 bpp</param>
''' <param name="pixa"> \param[in]    pixa the pix are accumulated here</param>
''' <param name="scalefactor"> \param[in]    scalefactor 0.0 to disable; otherwise this is a scale factor</param>
''' <param name="newrow"> \param[in]    newrow 0 if placed on the same row as previous; 1 otherwise</param>
''' <param name="space"> \param[in]    space horizontal and vertical spacing, in pixels</param>
''' <param name="dp"> \param[in]    dp depth of pixa; 8 or 32 bpp; only used on first call</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSaveTiled")> _
Friend Shared Function pixSaveTiled(pixs as IntPTR, pixa as IntPTR, scalefactor as single, newrow as Integer, space as Integer, dp as Integer) as Integer
End Function

' SRC\writefile.c (1128, 1)
' pixSaveTiledOutline()
' pixSaveTiledOutline(PIX *, PIXA *, l_float32, l_int32, l_int32, l_int32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Before calling this function for the first time, use
'''  * pixaCreate() to make the %pixa that will accumulate the pix.
'''  * This is passed in each time pixSaveTiled() is called.
'''  *   (2) %scalefactor scales the input image.  After scaling and
'''  * possible depth conversion, the image is saved in the input
'''  * pixa, along with a box that specifies the location to
'''  * place it when tiled later.  Disable saving the pix by
'''  * setting %scalefactor == 0.0.
'''  *   (3) %newrow and %space specify the location of the new pix
'''  * with respect to the last one(s) that were entered.
'''  *   (4) %dp specifies the depth at which all pix are saved.  It can
'''  * be only 8 or 32 bpp.  Any colormap is removed.  This is only
'''  * used at the first invocation.
'''  *   (5) This function uses two variables from call to call.
'''  * If they were static, the function would not be .so or thread
'''  * safe, and furthermore, there would be interference with two or
'''  * more pixa accumulating images at a time.  Consequently,
'''  * we use the first pix in the pixa to store and obtain both
'''  * the depth and the current position of the bottom (one pixel
'''  * below the lowest image raster line when laid out using
'''  * the boxa).  The bottom variable is stored in the input format
'''  * field, which is the only field available for storing an int.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 32 bpp</param>
''' <param name="pixa"> \param[in]    pixa the pix are accumulated here</param>
''' <param name="scalefactor"> \param[in]    scalefactor 0.0 to disable; otherwise this is a scale factor</param>
''' <param name="newrow"> \param[in]    newrow 0 if placed on the same row as previous; 1 otherwise</param>
''' <param name="space"> \param[in]    space horizontal and vertical spacing, in pixels</param>
''' <param name="linewidth"> \param[in]    linewidth width of added outline for image; 0 for no outline</param>
''' <param name="dp"> \param[in]    dp depth of pixa; 8 or 32 bpp; only used on first call</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSaveTiledOutline")> _
Friend Shared Function pixSaveTiledOutline(pixs as IntPTR, pixa as IntPTR, scalefactor as single, newrow as Integer, space as Integer, linewidth as Integer, dp as Integer) as Integer
End Function

' SRC\writefile.c (1258, 1)
' pixSaveTiledWithText()
' pixSaveTiledWithText(PIX *, PIXA *, l_int32, l_int32, l_int32, l_int32, L_BMF *, const char *, l_uint32, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (1) Before calling this function for the first time, use
'''  * pixaCreate() to make the %pixa that will accumulate the pix.
'''  * This is passed in each time pixSaveTiled() is called.
'''  *   (2) %outwidth is the scaled width.  After scaling, the image is
'''  * saved in the input pixa, along with a box that specifies
'''  * the location to place it when tiled later.  Disable saving
'''  * the pix by setting %outwidth == 0.
'''  *   (3) %newrow and %space specify the location of the new pix
'''  * with respect to the last one(s) that were entered.
'''  *   (4) All pix are saved as 32 bpp RGB.
'''  *   (5) If both %bmf and %textstr are defined, this generates a pix
'''  * with the additional text; otherwise, no text is written.
'''  *   (6) The text is written before scaling, so it is properly
'''  * antialiased in the scaled pix.  However, if the pix on
'''  * different calls have different widths, the size of the
'''  * text will vary.
'''  *   (7) See pixSaveTiledOutline() for other implementation details.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK, 1 on error.</returns>
''' <param name="pixs"> \param[in]    pixs 1, 2, 4, 8, 32 bpp</param>
''' <param name="pixa"> \param[in]    pixa the pix are accumulated here; as 32 bpp</param>
''' <param name="outwidth"> \param[in]    outwidth in pixels; use 0 to disable entirely</param>
''' <param name="newrow"> \param[in]    newrow 1 to start a new row; 0 to go on same row as previous</param>
''' <param name="space"> \param[in]    space horizontal and vertical spacing, in pixels</param>
''' <param name="linewidth"> \param[in]    linewidth width of added outline for image; 0 for no outline</param>
''' <param name="bmf"> \param[in]    bmf [optional] font struct</param>
''' <param name="textstr"> \param[in]    textstr [optional] text string to be added</param>
''' <param name="val"> \param[in]    val color to set the text</param>
''' <param name="location"> \param[in]    location L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixSaveTiledWithText")> _
Friend Shared Function pixSaveTiledWithText(pixs as IntPTR, pixa as IntPTR, outwidth as Integer, newrow as Integer, space as Integer, linewidth as Integer, bmf as IntPTR, textstr as String, val as UInteger, location as Integer) as Integer
End Function

' SRC\writefile.c (1300, 1)
' 
' l_chooseDisplayProg(l_int32) as void
''' <summary>
''' 
''' </summary>
''' <remarks></remarks>
''' <returns></returns>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="l_chooseDisplayProg")> _
Friend Shared Function l_chooseDisplayProg(selection as Integer) as Boolean ' Org. Void
End Function

' SRC\writefile.c (1347, 1)
' pixDisplayWrite()
' pixDisplayWrite(PIX *, l_int32) as l_ok
''' <summary>
''' * Notes:
'''  *   (0) Deprecated.
'''  *   (1) This is a simple interface for writing a set of files.
'''  *   (2) This uses jpeg output for pix that are 32 bpp or 8 bpp
'''  * without a colormap; otherwise, it uses png.
'''  *   (3) To erase any previously written files in the output directory:
'''  * pixDisplayWrite(NULL, -1);
'''  *   (4) If reduction > 1 and depth == 1, this does a scale-to-gray
'''  * reduction.
'''  *   (5) This function uses a static internal variable to number
'''  * output files written by a single process.  Behavior
'''  * with a shared library may be unpredictable.
'''  *   (6) For 16 bpp, this displays the full dynamic range with log scale.
'''  * Alternative image transforms to generate 8 bpp pix are:
'''  * pix8 = pixMaxDynamicRange(pixt, L_LINEAR_SCALE);
'''  * pix8 = pixConvert16To8(pixt, 0);  // low order byte
'''  * pix8 = pixConvert16To8(pixt, 1);  // high order byte
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  0 if OK; 1 on error</returns>
''' <param name="pixs"> \param[in]    pix 1, 2, 4, 8, 16, 32 bpp</param>
''' <param name="reduction"> \param[in]    reduction -1 to reset/erase; 0 to disable;</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="pixDisplayWrite")> _
Friend Shared Function pixDisplayWrite(pixs as IntPTR, reduction as Integer) as Integer
End Function

#End Region
#Region "SRC\zlibmem.c"
' SRC\zlibmem.c (92, 1)
' zlibCompress()
' zlibCompress(l_uint8 *, size_t, size_t *) as l_uint8 *
''' <summary>
''' * Notes:
'''  *   (1) We repeatedly read in and fill up an input buffer,
'''  * compress the data, and read it back out.  zlib
'''  * uses two byte buffers internally in the z_stream
'''  * data structure.  We use the bbuffers to feed data
'''  * into the fixed bufferin, and feed it out of bufferout,
'''  * in the same way that a pair of streams would normally
'''  * be used if the data were being read from one file
'''  * and written to another.  This is done iteratively,
'''  * compressing L_BUF_SIZE bytes of input data at a time.
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dataout compressed data, or NULL on error</returns>
''' <param name="datain"> \param[in]    datain byte buffer with input data</param>
''' <param name="nin"> \param[in]    nin    number of bytes of input data</param>
''' <param name="pnout"> \param[out]   pnout  number of bytes of output data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="zlibCompress")> _
Friend Shared Function zlibCompress(datain as Byte, nin as ULong, pnout as ULong) as String
End Function

' SRC\zlibmem.c (198, 1)
' zlibUncompress()
' zlibUncompress(l_uint8 *, size_t, size_t *) as l_uint8 *
''' <summary>
''' * Notes:
'''  *   (1) See zlibCompress().
'''  *
''' </summary>
''' <remarks></remarks>
''' <returns> \return  dataout uncompressed data, or NULL on error</returns>
''' <param name="datain"> \param[in]    datain byte buffer with compressed input data</param>
''' <param name="nin"> \param[in]    nin    number of bytes of input data</param>
''' <param name="pnout"> \param[out]   pnout  number of bytes of output data</param>
<DllImport(DllPath, CallingConvention:=CConv, EntryPoint:="zlibUncompress")> _
Friend Shared Function zlibUncompress(datain as Byte, nin as ULong, pnout as ULong) as String
End Function

#End Region

End Class
