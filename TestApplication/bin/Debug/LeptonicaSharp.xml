<?xml version="1.0"?>
<doc>
<assembly>
<name>
LeptonicaSharp
</name>
</assembly>
<members>
<member name="M:LeptonicaSharp.Natives.pixCleanBackgroundToWhite(System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a simplified interface for cleaning an image.
 For comparison, see pixAdaptThresholdToBinaryGen().
 (2) The suggested default values for the input parameters are
 gamma 1.0  (reduce this to increase the contrast; e.g.,
 for light text)
 blackval   70  (a bit more than 60)
 whiteval  190  (a bit less than 200)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale or 32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="pixg">8 bpp grayscale version; can be null</param>
	<param name="gamma">gamma correction; must be GT 0.0; typically ~1.0</param>
	<param name="blackval">dark value to set to black (0)</param>
	<param name="whiteval">light value to set to white (255)</param>
	<returns>pixd 8 bpp or 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBackgroundNormSimple(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This is a simplified interface to pixBackgroundNorm(),
 where seven parameters are defaulted.
 (2) The input image is either grayscale or rgb.
 (3) See pixBackgroundNorm() for usage and function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale or 32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="pixg">8 bpp grayscale version; can be null</param>
	<returns>pixd 8 bpp or 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBackgroundNorm(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a top-level interface for normalizing the image intensity
 by mapping the image so that the background is near the input
 value 'bgval'.
 (2) The input image is either grayscale or rgb.
 (3) For each component in the input image, the background value
 in each tile is estimated using the values in the tile that
 are not part of the foreground, where the foreground is
 determined by the input 'thresh' argument.
 (4) An optional binary mask can be specified, with the foreground
 pixels typically over image regions.  The resulting background
 map values will be determined by surrounding pixels that are
 not under the mask foreground.  The origin (0,0) of this mask
 is assumed to be aligned with the origin of the input image.
 This binary mask must not fully cover pixs, because then there
 will be no pixels in the input image available to compute
 the background.
 (5) An optional grayscale version of the input pixs can be supplied.
 The only reason to do this is if the input is RGB and this
 grayscale version can be used elsewhere.  If the input is RGB
 and this is not supplied, it is made internally using only
 the green component, and destroyed after use.
 (6) The dimensions of the pixel tile (sx, sy) give the amount by
 by which the map is reduced in size from the input image.
 (7) The threshold is used to binarize the input image, in order to
 locate the foreground components.  If this is set too low,
 some actual foreground may be used to determine the maps;
 if set too high, there may not be enough background
 to determine the map values accurately.  Typically, it's
 better to err by setting the threshold too high.
 (8) A 'mincount' threshold is a minimum count of pixels in a
 tile for which a background reading is made, in order for that
 pixel in the map to be valid.  This number should perhaps be
 at least 1/3 the size of the tile.
 (9) A 'bgval' target background value for the normalized image.  This
 should be at least 128.  If set too close to 255, some
 clipping will occur in the result.
 (10) Two factors, 'smoothx' and 'smoothy', are input for smoothing
 the map.  Each low-pass filter kernel dimension is
 is 2  (smoothing factor) + 1, so a
 value of 0 means no smoothing. A value of 1 or 2 is recommended.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale or 32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="pixg">8 bpp grayscale version; can be null</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="smoothx">half-width of block convolution kernel width</param>
	<param name="smoothy">half-width of block convolution kernel height</param>
	<returns>pixd 8 bpp or 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBackgroundNormMorph(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a top-level interface for normalizing the image intensity
 by mapping the image so that the background is near the input
 value 'bgval'.
 (2) The input image is either grayscale or rgb.
 (3) For each component in the input image, the background value
 is estimated using a grayscale closing; hence the 'Morph'
 in the function name.
 (4) An optional binary mask can be specified, with the foreground
 pixels typically over image regions.  The resulting background
 map values will be determined by surrounding pixels that are
 not under the mask foreground.  The origin (0,0) of this mask
 is assumed to be aligned with the origin of the input image.
 This binary mask must not fully cover pixs, because then there
 will be no pixels in the input image available to compute
 the background.
 (5) The map is computed at reduced size (given by 'reduction')
 from the input pixs and optional pixim.  At this scale,
 pixs is closed to remove the background, using a square Sel
 of odd dimension.  The product of reduction  size should be
 large enough to remove most of the text foreground.
 (6) No convolutional smoothing needs to be done on the map before
 inverting it.
 (7) A 'bgval' target background value for the normalized image.  This
 should be at least 128.  If set too close to 255, some
 clipping will occur in the result.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale or 32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="reduction">at which morph closings are done; between 2 and 16</param>
	<param name="size">of square Sel for the closing; use an odd number</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBackgroundNormGrayArray(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) See notes in pixBackgroundNorm().
 (2) This returns a 16 bpp pix that can be used by
 pixApplyInvBackgroundGrayMap() to generate a normalized version
 of the input pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="smoothx">half-width of block convolution kernel width</param>
	<param name="smoothy">half-width of block convolution kernel height</param>
	<param name="ppixd">16 bpp array of inverted background value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBackgroundNormRGBArrays(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) See notes in pixBackgroundNorm().
 (2) This returns a set of three 16 bpp pix that can be used by
 pixApplyInvBackgroundGrayMap() to generate a normalized version
 of each component of the input pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="pixg">8 bpp grayscale version; can be null</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="smoothx">half-width of block convolution kernel width</param>
	<param name="smoothy">half-width of block convolution kernel height</param>
	<param name="ppixr">16 bpp array of inverted R background value</param>
	<param name="ppixg">16 bpp array of inverted G background value</param>
	<param name="ppixb">16 bpp array of inverted B background value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBackgroundNormGrayArrayMorph(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) See notes in pixBackgroundNormMorph().
 (2) This returns a 16 bpp pix that can be used by
 pixApplyInvBackgroundGrayMap() to generate a normalized version
 of the input pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="reduction">at which morph closings are done; between 2 and 16</param>
	<param name="size">of square Sel for the closing; use an odd number</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="ppixd">16 bpp array of inverted background value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBackgroundNormRGBArraysMorph(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) See notes in pixBackgroundNormMorph().
 (2) This returns a set of three 16 bpp pix that can be used by
 pixApplyInvBackgroundGrayMap() to generate a normalized version
 of each component of the input pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="reduction">at which morph closings are done; between 2 and 16</param>
	<param name="size">of square Sel for the closing; use an odd number</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="ppixr">16 bpp array of inverted R background value</param>
	<param name="ppixg">16 bpp array of inverted G background value</param>
	<param name="ppixb">16 bpp array of inverted B background value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetBackgroundGrayMap(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) The background is measured in regions that don't have
 images.  It is then propagated into the image regions,
 and finally smoothed in each image region.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not cmapped</param>
	<param name="pixim">1 bpp 'image' mask; can be null; it should not have all foreground pixels</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="ppixd">8 bpp grayscale map</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetBackgroundRGBMap(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) If pixg, which is a grayscale version of pixs, is provided,
 use this internally to generate the foreground mask.
 Otherwise, a grayscale version of pixs will be generated
 from the green component only, used, and destroyed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null; it should not have all foreground pixels</param>
	<param name="pixg">8 bpp grayscale version; can be null</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="ppixmr">rgb maps</param>
	<param name="ppixmg">rgb maps</param>
	<param name="ppixmb">rgb maps</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetBackgroundGrayMapMorph(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not cmapped</param>
	<param name="pixim">1 bpp 'image' mask; can be null; it should not have all foreground pixels</param>
	<param name="reduction">factor at which closing is performed</param>
	<param name="size">of square Sel for the closing; use an odd number</param>
	<param name="ppixm">grayscale map</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetBackgroundRGBMapMorph(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null; it should not have all foreground pixels</param>
	<param name="reduction">factor at which closing is performed</param>
	<param name="size">of square Sel for the closing; use an odd number</param>
	<param name="ppixmr">red component map</param>
	<param name="ppixmg">green component map</param>
	<param name="ppixmb">blue component map</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFillMapHoles(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place operation on pix (the map).  pix is
 typically a low-resolution version of some other image
 from which it was derived, where each pixel in pix
 corresponds to a rectangular tile (say, m x n) of pixels
 in the larger image.  All we need to know about the larger
 image is whether or not the rightmost column and bottommost
 row of pixels in pix correspond to tiles that are
 only partially covered by pixels in the larger image.
 (2) Typically, some number of pixels in the input map are
 not known, and their values must be determined by near
 pixels that are known.  These unknown pixels are the 'holes'.
 They can take on only two values, 0 and 255, and the
 instruction about which to fill is given by the filltype flag.
 (3) The "holes" can come from two sources.  The first is when there
 are not enough foreground or background pixels in a tile;
 the second is when a tile is at least partially covered
 by an image mask.  If we're filling holes in a fg mask,
 the holes are initialized to black (0) and use L_FILL_BLACK.
 For filling holes in a bg mask, initialize the holes to
 white (255) and use L_FILL_WHITE.
 (4) If w is the map width, nx = w or nx = w - 1; ditto for h and ny.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; a map, with one pixel for each tile in a larger image</param>
	<param name="nx">number of horizontal pixel tiles that are entirely covered with pixels in the original source image</param>
	<param name="ny">ditto for the number of vertical pixel tiles</param>
	<param name="filltype">L_FILL_WHITE or L_FILL_BLACK</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExtendByReplication(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The pixel values are extended to the left and down, as required.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="addw">number of extra pixels horizontally to add</param>
	<param name="addh">number of extra pixels vertically to add</param>
	<returns>pixd extended with replicated pixel values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSmoothConnectedRegions(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The pixels in pixs corresponding to those in each
 8-connected region in the mask are set to the average value.
 (2) This is required for adaptive mapping to avoid the
 generation of stripes in the background map, due to
 variations in the pixel values near the edges of mask regions.
 (3) This function is optimized for background smoothing, where
 there are a relatively small number of components.  It will
 be inefficient if used where there are many small components.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; no colormap</param>
	<param name="pixm">1 bpp; if null, this is a no-op</param>
	<param name="factor">subsampling factor for getting average; GT= 1</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetInvBackgroundMap(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) bgval should typically be GT 120 and LT 240
 (2) pixd is a normalization image; the original image is
 multiplied by pixd and the result is divided by 256.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; no colormap</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="smoothx">half-width of block convolution kernel width</param>
	<param name="smoothy">half-width of block convolution kernel height</param>
	<returns>pixd 16 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixApplyInvBackgroundGrayMap(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; no colormap</param>
	<param name="pixm">16 bpp, inverse background map</param>
	<param name="sx">tile width in pixels</param>
	<param name="sy">tile height in pixels</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixApplyInvBackgroundRGBMap(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rbg</param>
	<param name="pixmr">16 bpp, red inverse background map</param>
	<param name="pixmg">16 bpp, green inverse background map</param>
	<param name="pixmb">16 bpp, blue inverse background map</param>
	<param name="sx">tile width in pixels</param>
	<param name="sy">tile height in pixels</param>
	<returns>pixd 32 bpp rbg, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixApplyVariableGrayMap(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Suppose you have an image that you want to transform based
 on some photometric measurement at each point, such as the
 threshold value for binarization.  Representing the photometric
 measurement as an image pixg, you can threshold in input image
 using pixVarThresholdToBinary().  Alternatively, you can map
 the input image pointwise so that the threshold over the
 entire image becomes a constant, such as 128.  For example,
 if a pixel in pixg is 150 and the target is 128, the
 corresponding pixel in pixs is mapped linearly to a value
 (128/150) of the input value.  If the resulting mapped image
 pixd were then thresholded at 128, you would obtain the
 same result as a direct binarization using pixg with
 pixVarThresholdToBinary().
 (2) The sizes of pixs and pixg must be equal.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="pixg">8 bpp, variable map</param>
	<param name="target">typ. 128 for threshold</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGlobalNormRGB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The value of pixd determines if the results are written to a
 new pix (use NULL), in-place to pixs (use pixs), or to some
 other existing pix.
 (2) This does a global normalization of an image where the
 r,g,b color components are not balanced.  Thus, white in pixs is
 represented by a set of r,g,b values that are not all 255.
 (3) The input values (rval, gval, bval) should be chosen to
 represent the gray color (mapval, mapval, mapval) in src.
 Thus, this function will map (rval, gval, bval) to that gray color.
 (4) Typically, mapval = 255, so that (rval, gval, bval)
 corresponds to the white point of src.  In that case, these
 parameters should be chosen so that few pixels have higher values.
 (5) In all cases, we do a linear TRC separately on each of the
 components, saturating at 255.
 (6) If the input pix is 8 bpp without a colormap, you can get
 this functionality with mapval = 255 by calling
 pixGammaTRC(pixd, pixs, 1.0, 0, bgval);
 where bgval is the value you want to be mapped to 255.
 Or more generally, if you want bgval to be mapped to mapval
 pixGammaTRC(pixd, pixs, 1.0, 0, 255  bgval / mapval);
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null, existing or equal to pixs</param>
	<param name="pixs">32 bpp rgb, or colormapped</param>
	<param name="rval">pixel values in pixs that are linearly mapped to mapval</param>
	<param name="gval">pixel values in pixs that are linearly mapped to mapval</param>
	<param name="bval">pixel values in pixs that are linearly mapped to mapval</param>
	<param name="mapval">use 255 for mapping to white</param>
	<returns>pixd 32 bpp rgb or colormapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGlobalNormNoSatRGB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This is a version of pixGlobalNormRGB(), where the output
 intensity is scaled back so that a controlled fraction of
 pixel components is allowed to saturate.  See comments in
 pixGlobalNormRGB().
 (2) The value of pixd determines if the results are written to a
 new pix (use NULL), in-place to pixs (use pixs), or to some
 other existing pix.
 (3) This does a global normalization of an image where the
 r,g,b color components are not balanced.  Thus, white in pixs is
 represented by a set of r,g,b values that are not all 255.
 (4) The input values (rval, gval, bval) can be chosen to be the
 color that, after normalization, becomes white background.
 For images that are mostly background, the closer these values
 are to the median component values, the closer the resulting
 background will be to gray, becoming white at the brightest places.
 (5) The mapval used in pixGlobalNormRGB() is computed here to
 avoid saturation of any component in the image (save for a
 fraction of the pixels given by the input rank value).
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null, existing or equal to pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="rval">pixel values in pixs that are linearly mapped to mapval; but see below</param>
	<param name="gval">pixel values in pixs that are linearly mapped to mapval; but see below</param>
	<param name="bval">pixel values in pixs that are linearly mapped to mapval; but see below</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="rank">between 0.0 and 1.0; typ. use a value near 1.0</param>
	<returns>pixd 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixThresholdSpreadNorm(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The basis of this approach is the use of seed spreading
 on a (possibly) sparse set of estimates for the local threshold.
 The resulting dense estimates are smoothed by convolution
 and used to either threshold the input image or normalize it
 with a local transformation that linearly maps the pixels so
 that the local threshold estimate becomes constant over the
 resulting image.  This approach is one of several that
 have been suggested (and implemented) by Ray Smith.
 (2) You can use either the Sobel or TwoSided edge filters.
 The results appear to be similar, using typical values
 of edgethresh in the rang 10-20.
 (3) To skip the trc enhancement, use gamma = 1.0, minval = 0
 and maxval = 255.
 (4) For the normalized image pixd, each pixel is linearly mapped
 in such a way that the local threshold is equal to targetthresh.
 (5) The full width and height of the convolution kernel
 are (2  smoothx + 1) and (2  smoothy + 1).
 (6) This function can be used with the pixtiling utility if the
 images are too large.  See pixOtsuAdaptiveThreshold() for
 an example of this.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="filtertype">L_SOBEL_EDGE or L_TWO_SIDED_EDGE;</param>
	<param name="edgethresh">threshold on magnitude of edge filter; typ 10-20</param>
	<param name="smoothx">half-width of convolution kernel applied to spread threshold use 0 for no smoothing</param>
	<param name="smoothy">half-width of convolution kernel applied to spread threshold use 0 for no smoothing</param>
	<param name="gamma">gamma correction; typ. about 0.7</param>
	<param name="minval">input value that gives 0 for output; typ. -25</param>
	<param name="maxval">input value that gives 255 for output; typ. 255</param>
	<param name="targetthresh">target threshold for normalization</param>
	<param name="ppixth">computed local threshold value</param>
	<param name="ppixb">thresholded normalized image</param>
	<param name="ppixd">normalized image</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBackgroundNormFlex(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does adaptation flexibly to a quickly varying background.
 For that reason, all input parameters should be small.
 (2) sx and sy give the tile size; they should be in [5 - 7].
 (3) The full width and height of the convolution kernel
 are (2  smoothx + 1) and (2  smoothy + 1).  They
 should be in [1 - 2].
 (4) Basin filling is used to fill the large fg regions.  The
 parameter %delta measures the height that the black
 background is raised from the local minima.  By raising
 the background, it is possible to threshold the large
 fg regions to foreground.  If %delta is too large,
 bg regions will be lifted, causing thickening of
 the fg regions.  Use 0 to skip.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="sx">desired tile dimensions; actual size may vary; use values between 3 and 10</param>
	<param name="sy">desired tile dimensions; actual size may vary; use values between 3 and 10</param>
	<param name="smoothx">half-width of convolution kernel applied to threshold array use values between 1 and 3</param>
	<param name="smoothy">half-width of convolution kernel applied to threshold array use values between 1 and 3</param>
	<param name="delta">difference parameter in basin filling; use 0 to skip</param>
	<returns>pixd 8 bpp, background-normalized), or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixContrastNorm(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This function adaptively attempts to expand the contrast
 to the full dynamic range in each tile.  If the contrast in
 a tile is smaller than %mindiff, it uses the min and max
 pixel values from neighboring tiles.  It also can use
 convolution to smooth the min and max values from
 neighboring tiles.  After all that processing, it is
 possible that the actual pixel values in the tile are outside
 the computed [min ... max] range for local contrast
 normalization.  Such pixels are taken to be at either 0
 (if below the min) or 255 (if above the max).
 (2) pixd can be equal to pixs (in-place operation) or
 null (makes a new pixd).
 (3) sx and sy give the tile size; they are typically at least 20.
 (4) mindiff is used to eliminate results for tiles where it is
 likely that either fg or bg is missing.  A value around 50
 or more is reasonable.
 (5) The full width and height of the convolution kernel
 are (2  smoothx + 1) and (2  smoothy + 1).  Some smoothing
 is typically useful, and we limit the smoothing half-widths
 to the range from 0 to 8.
 (6) A linear TRC (gamma = 1.0) is applied to increase the contrast
 in each tile.  The result can subsequently be globally corrected,
 by applying pixGammaTRC() with arbitrary values of gamma
 and the 0 and 255 points of the mapping.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8 bpp; null or equal to pixs</param>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="sx">tile dimensions</param>
	<param name="sy">tile dimensions</param>
	<param name="mindiff">minimum difference to accept as valid</param>
	<param name="smoothx">half-width of convolution kernel applied to min and max arrays use 0 for no smoothing</param>
	<param name="smoothy">half-width of convolution kernel applied to min and max arrays use 0 for no smoothing</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMinMaxTiles(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This computes filtered and smoothed values for the min and
 max pixel values in each tile of the image.
 (2) See pixContrastNorm() for usage.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="sx">tile dimensions</param>
	<param name="sy">tile dimensions</param>
	<param name="mindiff">minimum difference to accept as valid</param>
	<param name="smoothx">half-width of convolution kernel applied to min and max arrays use 0 for no smoothing</param>
	<param name="smoothy">half-width of convolution kernel applied to min and max arrays use 0 for no smoothing</param>
	<param name="ppixmin">tiled minima</param>
	<param name="ppixmax">tiled maxima</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetLowContrast(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This compares corresponding pixels in pixs1 and pixs2.
 When they differ by less than %mindiff, set the pixel
 values to 0 in each.  Each pixel typically represents a tile
 in a larger image, and a very small difference between
 the min and max in the tile indicates that the min and max
 values are not to be trusted.
 (2) If contrast (pixel difference) detection is expected to fail,
 caller should check return value.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">8 bpp</param>
	<param name="pixs2">8 bpp</param>
	<param name="mindiff">minimum difference to accept as valid</param>
	<returns>0 if OK; 1 if no pixel diffs are large enough, or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixLinearTRCTiled(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) pixd can be equal to pixs (in-place operation) or
 null (makes a new pixd).
 (2) sx and sy give the tile size; they are typically at least 20.
 (3) pixmin and pixmax are generated by pixMinMaxTiles()
 (4) For each tile, this does a linear expansion of the dynamic
 range so that the min value in the tile becomes 0 and the
 max value in the tile becomes 255.
 (5) The LUTs that do the mapping are generated as needed
 and stored for reuse in an integer array within the ptr array iaa[].
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8 bpp</param>
	<param name="pixs">8 bpp, not colormapped</param>
	<param name="sx">tile dimensions</param>
	<param name="sy">tile dimensions</param>
	<param name="pixmin">pix of min values in tiles</param>
	<param name="pixmax">pix of max values in tiles</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAffineSampledPta(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary.
 (2) Retains colormap, which you can do for a sampled transform..
 (3) The 3 points must not be collinear.
 (4) The order of the 3 points is arbitrary; however, to compare
 with the sequential transform they must be in these locations
 and in this order origin, x-axis, y-axis.
 (5) For 1 bpp images, this has much better quality results
 than pixAffineSequential(), particularly for text.
 It is about 3x slower, but does not require additional
 border pixels.  The poor quality of pixAffineSequential()
 is due to repeated quantized transforms.  It is strongly
 recommended that pixAffineSampled() be used for 1 bpp images.
 (6) For 8 or 32 bpp, much better quality is obtained by the
 somewhat slower pixAffinePta().  See that function
 for relative timings between sampled and interpolated.
 (7) To repeat, use of the sequential transform,
 pixAffineSequential(), for any images, is discouraged.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="ptad">3 pts of final coordinate space</param>
	<param name="ptas">3 pts of initial coordinate space</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAffineSampled(System.IntPtr,System.Single[],System.Int32)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary.
 (2) Retains colormap, which you can do for a sampled transform..
 (3) For 8 or 32 bpp, much better quality is obtained by the
 somewhat slower pixAffine().  See that function
 for relative timings between sampled and interpolated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="vc">vector of 6 coefficients for affine transformation</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAffinePta(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary
 (2) Removes any existing colormap, if necessary, before transforming
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="ptad">3 pts of final coordinate space</param>
	<param name="ptas">3 pts of initial coordinate space</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAffine(System.IntPtr,System.Single[],System.Int32)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary
 (2) Removes any existing colormap, if necessary, before transforming
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="vc">vector of 6 coefficients for affine transformation</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAffinePtaColor(System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="ptad">3 pts of final coordinate space</param>
	<param name="ptas">3 pts of initial coordinate space</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAffineColor(System.IntPtr,System.Single[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="vc">vector of 6 coefficients for affine transformation</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAffinePtaGray(System.IntPtr,System.IntPtr,System.IntPtr,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="ptad">3 pts of final coordinate space</param>
	<param name="ptas">3 pts of initial coordinate space</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAffineGray(System.IntPtr,System.Single[],System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="vc">vector of 6 coefficients for affine transformation</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAffinePtaWithAlpha(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) The alpha channel is transformed separately from pixs,
 and aligns with it, being fully transparent outside the
 boundary of the transformed pixs.  For pixels that are fully
 transparent, a blending function like pixBlendWithGrayMask()
 will give zero weight to corresponding pixels in pixs.
 (2) If pixg is NULL, it is generated as an alpha layer that is
 partially opaque, using %fract.  Otherwise, it is cropped
 to pixs if required and %fract is ignored.  The alpha channel
 in pixs is never used.
 (3) Colormaps are removed.
 (4) When pixs is transformed, it doesn't matter what color is brought
 in because the alpha channel will be transparent (0) there.
 (5) To avoid losing source pixels in the destination, it may be
 necessary to add a border to the source pix before doing
 the affine transformation.  This can be any non-negative number.
 (6) The input %ptad and %ptas are in a coordinate space before
 the border is added.  Internally, we compensate for this
 before doing the affine transform on the image after the border
 is added.
 (7) The default setting for the border values in the alpha channel
 is 0 (transparent) for the outermost ring of pixels and
 (0.5  fract  255) for the second ring.  When blended over
 a second image, this
 (a) shrinks the visible image to make a clean overlap edge
 with an image below, and
 (b) softens the edges by weakening the aliasing there.
 Use l_setAlphaMaskBorder() to change these values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="ptad">3 pts of final coordinate space</param>
	<param name="ptas">3 pts of initial coordinate space</param>
	<param name="pixg">8 bpp, can be null</param>
	<param name="fract">between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	<param name="border">of pixels added to capture transformed source pixels</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getAffineXformCoeffs(System.IntPtr,System.IntPtr,System.IntPtr@)">
	<summary>
 We have a set of six equations, describing the affine
 transformation that takes 3 points ptas into 3 other
 points ptad.  These equations are
 x1' = c[0]x1 + c[1]y1 + c[2]
 y1' = c[3]x1 + c[4]y1 + c[5]
 x2' = c[0]x2 + c[1]y2 + c[2]
 y2' = c[3]x2 + c[4]y2 + c[5]
 x3' = c[0]x3 + c[1]y3 + c[2]
 y3' = c[3]x3 + c[4]y3 + c[5]
 This can be represented as
 AC = B
 where B and C are column vectors
 B = [ x1' y1' x2' y2' x3' y3' ]
 C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] ]
 and A is the 6x6 matrix
 x1   y1   1   0 0 0
 0 0   0   x1   y1   1
 x2   y2   1   0 0 0
 0 0   0   x2   y2   1
 x3   y3   1   0 0 0
 0 0   0   x3   y3   1
 These six equations are solved here for the coefficients C.
 These six coefficients can then be used to find the dest
 point x',y') corresponding to any src point (x,y, according
 to the equations
 x' = c[0]x + c[1]y + c[2]
 y' = c[3]x + c[4]y + c[5]
 that are implemented in affineXformPt.
 !!!!!!!!!!!!!!!!!!   Very important   !!!!!!!!!!!!!!!!!!!!!!
 When the affine transform is composed from a set of simple
 operations such as translation, scaling and rotation,
 it is built in a form to convert from the un-transformed src
 point to the transformed dest point.  However, when an
 affine transform is used on images, it is used in an inverted
 way it converts from the transformed dest point to the
 un-transformed src point.  So, for example, if you transform
 a boxa using transform A, to transform an image in the same
 way you must use the inverse of A.
 For example, if you transform a boxa with a 3x3 affine matrix
 'mat', the analogous image transformation must use 'matinv'
 \code
 boxad = boxaAffineTransform(boxas, mat);
 affineInvertXform(mat, matinv);
 pixd = pixAffine(pixs, matinv, L_BRING_IN_WHITE);
 \endcode
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">source 3 points; unprimed</param>
	<param name="ptad">transformed 3 points; primed</param>
	<param name="pvc">vector of coefficients of transform</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.affineInvertXform(System.Single[],System.IntPtr@)">
	<summary>
 Notes
 (1) The 6 affine transform coefficients are the first
 two rows of a 3x3 matrix where the last row has
 only a 1 in the third column.  We invert this
 using gaussjordan(), and select the first 2 rows
 as the coefficients of the inverse affine transform.
 (2) Alternatively, we can find the inverse transform
 coefficients by inverting the 2x2 submatrix,
 and treating the top 2 coefficients in the 3rd column as
 a RHS vector for that 2x2 submatrix.  Then the
 6 inverted transform coefficients are composed of
 the inverted 2x2 submatrix and the negative of the
 transformed RHS vector.  Why is this so?  We have
 Y = AX + R  (2 equations in 6 unknowns)
 Then
 X = A'Y - A'R
 Gauss-jordan solves
 AF = R
 and puts the solution for F, which is A'R,
 into the input R vector.
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 6 coefficients</param>
	<param name="pvci">inverted transform</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.affineXformSampledPt(System.Single[],System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This finds the nearest pixel coordinates of the transformed point.
 (2) It does not check ptrs for returned data!
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 6 coefficients</param>
	<param name="x">initial point</param>
	<param name="y">initial point</param>
	<param name="pxp">transformed point</param>
	<param name="pyp">transformed point</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.affineXformPt(System.Single[],System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This computes the floating point location of the transformed point.
 (2) It does not check ptrs for returned data!
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 6 coefficients</param>
	<param name="x">initial point</param>
	<param name="y">initial point</param>
	<param name="pxp">transformed point</param>
	<param name="pyp">transformed point</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.linearInterpolatePixelColor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) This is a standard linear interpolation function.  It is
 equivalent to area weighting on each component, and
 avoids "jaggies" when rendering sharp edges.
 </summary>
	<remarks>
	</remarks>
	<param name="datas">ptr to beginning of image data</param>
	<param name="wpls">32-bit word/line for this data array</param>
	<param name="w">of image</param>
	<param name="h">of image</param>
	<param name="x">floating pt location for evaluation</param>
	<param name="y">floating pt location for evaluation</param>
	<param name="colorval">color brought in from the outside when the input x,y location is outside the image; in 0xrrggbb00 format)</param>
	<param name="pval">interpolated color value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.linearInterpolatePixelGray(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This is a standard linear interpolation function.  It is
 equivalent to area weighting on each component, and
 avoids "jaggies" when rendering sharp edges.
 </summary>
	<remarks>
	</remarks>
	<param name="datas">ptr to beginning of image data</param>
	<param name="wpls">32-bit word/line for this data array</param>
	<param name="w">of image</param>
	<param name="h">of image</param>
	<param name="x">floating pt location for evaluation</param>
	<param name="y">floating pt location for evaluation</param>
	<param name="grayval">color brought in from the outside when the input x,y location is outside the image</param>
	<param name="pval">interpolated gray value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gaussjordan(System.IntPtr,System.Single[],System.Int32)">
	<summary>
 Notes
 (1) There are two side-effects
 The matrix a is transformed to its inverse A
 The rhs vector b is transformed to the solution x
 of the linear equation ax = b
 (2) The inverse A can then be used to solve the same equation with
 different rhs vectors c by multiplication x = Ac
 (3) Adapted from "Numerical Recipes in C, Second Edition", 1992,
 pp. 36-41 (gauss-jordan elimination)
 </summary>
	<remarks>
	</remarks>
	<param name="a">n x n matrix</param>
	<param name="b">n x 1 right-hand side column vector</param>
	<param name="n">dimension</param>
	<returns>0 if ok, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAffineSequential(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The 3 pts must not be collinear.
 (2) The 3 pts must be given in this order
 ~ origin
 ~ a location along the x-axis
 ~ a location along the y-axis.
 (3) You must guess how much border must be added so that no
 pixels are lost in the transformations from src to
 dest coordinate space.  (This can be calculated but it
 is a lot of work!)  For coordinate spaces that are nearly
 at right angles, on a 300 ppi scanned page, the addition
 of 1000 pixels on each side is usually sufficient.
 (4) This is here for pedagogical reasons.  It is about 3x faster
 on 1 bpp images than pixAffineSampled(), but the results
 on text are much inferior.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="ptad">3 pts of final coordinate space</param>
	<param name="ptas">3 pts of initial coordinate space</param>
	<param name="bw">pixels of additional border width during computation</param>
	<param name="bh">pixels of additional border height during computation</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.createMatrix2dTranslate(System.Single,System.Single)">
	<summary>
 Notes
 (1) The translation is equivalent to
 v' = Av
 where v and v' are 1x3 column vectors in the form
 v = [x, y, 1]^ ^ denotes transpose
 and the affine translation matrix is
 A = [ 1   0   tx
 0   1   ty
 0   0 1  ]
 (2) We consider translation as with respect to a fixed origin.
 In a clipping operation, the origin moves and the points
 are fixed, and you use (-tx, -ty) where (tx, ty) is the
 translation vector of the origin.
 </summary>
	<remarks>
	</remarks>
	<param name="transx">x component of translation wrt. the origin</param>
	<param name="transy">y component of translation wrt. the origin</param>
	<returns>3x3 transform matrix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.createMatrix2dScale(System.Single,System.Single)">
	<summary>
 Notes
 (1) The scaling is equivalent to
 v' = Av
 where v and v' are 1x3 column vectors in the form
 v = [x, y, 1]^ ^ denotes transpose
 and the affine scaling matrix is
 A = [ sx  0 0
 0   sy   0
 0   0 1  ]
 (2) We consider scaling as with respect to a fixed origin.
 In other words, the origin is the only point that doesn't
 move in the scaling transform.
 </summary>
	<remarks>
	</remarks>
	<param name="scalex">horizontal scale factor</param>
	<param name="scaley">vertical scale factor</param>
	<returns>3x3 transform matrix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.createMatrix2dRotate(System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) The rotation is equivalent to
 v' = Av
 where v and v' are 1x3 column vectors in the form
 v = [x, y, 1]^ ^ denotes transpose
 and the affine rotation matrix is
 A = [ cosa   -sina xc1-cosa + ycsina
 sina cosa yc1-cosa - xcsina
 0 0  1   ]
 If the rotation is about the origin, xc, yc) = (0, 0 and
 this simplifies to
 A = [ cosa   -sina 0
 sina cosa 0
 0 0  1 ]
 These relations follow from the following equations, which
 you can convince yourself are correct as follows.  Draw a
 circle centered on xc,yc) and passing through (x,y), with
 (x',y') on the arc at an angle 'a' clockwise from (x,y).
 [ Hint cosa + b = cosa  cosb - sina  sinb
 sina + b = sina  cosb + cosa  sinb ]
 x' - xc =  x - xc)  cosa - (y - yc  sina
 y' - yc =  x - xc)  sina + (y - yc  cosa
 </summary>
	<remarks>
	</remarks>
	<param name="xc">location of center of rotation</param>
	<param name="yc">location of center of rotation</param>
	<param name="angle">rotation in radians; clockwise is positive</param>
	<returns>3x3 transform matrix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaTranslate(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) See createMatrix2dTranslate() for details of transform.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">for initial points</param>
	<param name="transx">x component of translation wrt. the origin</param>
	<param name="transy">y component of translation wrt. the origin</param>
	<returns>ptad  translated points, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaScale(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) See createMatrix2dScale() for details of transform.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">for initial points</param>
	<param name="scalex">horizontal scale factor</param>
	<param name="scaley">vertical scale factor</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaRotate(System.IntPtr,System.Single,System.Single,System.Single)">
	<summary>
 Notes;
 (1) See createMatrix2dScale() for details of transform.
 (2) This transform can be thought of as composed of the
 sum of two parts
 a) an (x,y)-dependent rotation about the origin
 xr = x  cosa - y  sina
 yr = x  sina + y  cosa
 b) an (x,y)-independent translation that depends on the
 rotation center and the angle
 xt = xc - xc  cosa + yc  sina
 yt = yc - xc  sina - yc  cosa
 The translation part (xt,yt) is equal to the difference
 between the center (xc,yc) and the location of the
 center after it is rotated about the origin.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">for initial points</param>
	<param name="xc">location of center of rotation</param>
	<param name="yc">location of center of rotation</param>
	<param name="angle">rotation in radians; clockwise is positive</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaTranslate(System.IntPtr,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="transx">x component of translation wrt. the origin</param>
	<param name="transy">y component of translation wrt. the origin</param>
	<returns>boxad  translated boxas, or NULL on error Notes (1) See createMatrix2dTranslate() for details of transform.</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaScale(System.IntPtr,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="scalex">horizontal scale factor</param>
	<param name="scaley">vertical scale factor</param>
	<returns>boxad  scaled boxas, or NULL on error Notes (1) See createMatrix2dScale() for details of transform.</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaRotate(System.IntPtr,System.Single,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="xc">location of center of rotation</param>
	<param name="yc">location of center of rotation</param>
	<param name="angle">rotation in radians; clockwise is positive</param>
	<returns>boxad  scaled boxas, or NULL on error Notes (1) See createMatrix2dRotate() for details of transform.</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaAffineTransform(System.IntPtr,System.Single[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas">for initial points</param>
	<param name="mat">3x3 transform matrix; canonical form</param>
	<returns>ptad  transformed points, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaAffineTransform(System.IntPtr,System.Single[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="mat">3x3 transform matrix; canonical form</param>
	<returns>boxad  transformed boxas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_productMatVec(System.Single[],System.Single[],System.Single[],System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="mat">square matrix, as a 1-dimensional %size^2 array</param>
	<param name="vecs">input column vector of length %size</param>
	<param name="vecd">result column vector</param>
	<param name="size">matrix is %size x %size; vectors are length %size</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_productMat2(System.Single[],System.Single[],System.Single[],System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="mat1">square matrix, as a 1-dimensional size^2 array</param>
	<param name="mat2">square matrix, as a 1-dimensional size^2 array</param>
	<param name="matd">square matrix; product stored here</param>
	<param name="size">of matrices</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_productMat3(System.Single[],System.Single[],System.Single[],System.Single[],System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="mat1">square matrix, as a 1-dimensional size^2 array</param>
	<param name="mat2">square matrix, as a 1-dimensional size^2 array</param>
	<param name="mat3">square matrix, as a 1-dimensional size^2 array</param>
	<param name="matd">square matrix; product stored here</param>
	<param name="size">of matrices</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_productMat4(System.Single[],System.Single[],System.Single[],System.Single[],System.Single[],System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="mat1">square matrix, as a 1-dimensional size^2 array</param>
	<param name="mat2">square matrix, as a 1-dimensional size^2 array</param>
	<param name="mat3">square matrix, as a 1-dimensional size^2 array</param>
	<param name="mat4">square matrix, as a 1-dimensional size^2 array</param>
	<param name="matd">square matrix; product stored here</param>
	<param name="size">of matrices</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_getDataBit(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<returns>val of the nth 1-bit pixel.</returns>
</member><member name="M:LeptonicaSharp.Natives.l_setDataBit(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
</member><member name="M:LeptonicaSharp.Natives.l_clearDataBit(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
</member><member name="M:LeptonicaSharp.Natives.l_setDataBitVal(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an accessor for a 1 bpp pix.
 (2) It is actually a little slower than using
 if (val == 0)
 l_ClearDataBit(line, n);
 else
 l_SetDataBit(line, n);
 </summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<param name="val">val to be inserted 0 or 1</param>
</member><member name="M:LeptonicaSharp.Natives.l_getDataDibit(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<returns>val of the nth 2-bit pixel.</returns>
</member><member name="M:LeptonicaSharp.Natives.l_setDataDibit(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<param name="val">val to be inserted 0 - 3</param>
</member><member name="M:LeptonicaSharp.Natives.l_clearDataDibit(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
</member><member name="M:LeptonicaSharp.Natives.l_getDataQbit(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<returns>val of the nth 4-bit pixel.</returns>
</member><member name="M:LeptonicaSharp.Natives.l_setDataQbit(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<param name="val">val to be inserted 0 - 0xf</param>
</member><member name="M:LeptonicaSharp.Natives.l_clearDataQbit(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
</member><member name="M:LeptonicaSharp.Natives.l_getDataByte(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<returns>value of the n-th byte pixel</returns>
</member><member name="M:LeptonicaSharp.Natives.l_setDataByte(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<param name="val">val to be inserted 0 - 0xff</param>
</member><member name="M:LeptonicaSharp.Natives.l_getDataTwoBytes(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<returns>value of the n-th 2-byte pixel</returns>
</member><member name="M:LeptonicaSharp.Natives.l_setDataTwoBytes(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<param name="val">val to be inserted 0 - 0xffff</param>
</member><member name="M:LeptonicaSharp.Natives.l_getDataFourBytes(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<returns>value of the n-th 4-byte pixel</returns>
</member><member name="M:LeptonicaSharp.Natives.l_setDataFourBytes(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<param name="val">val to be inserted 0 - 0xffffffff</param>
</member><member name="M:LeptonicaSharp.Natives.barcodeDispatchDecoder(System.String,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="barstr">string of integers in set {1,2,3,4} of bar widths</param>
	<param name="format">L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>data string of decoded barcode data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.barcodeFormatIsSupported(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="format"></param>
	<returns>1 if format is one of those supported; 0 otherwise</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindBaselines(System.IntPtr,System.IntPtr@,System.IntPtr)">
	<summary>
 Notes
 (1) Input binary image must have text lines already aligned
 horizontally.  This can be done by either rotating the
 image with pixDeskew(), or, if a projective transform
 is required, by doing pixDeskewLocal() first.
 (2) Input null for pta if you don't want this returned.
 The pta will come in pairs of points (left and right end
 of each baseline).
 (3) Caution this will not work properly on text with multiple
 columns, where the lines are not aligned between columns.
 If there are multiple columns, they should be extracted
 separately before finding the baselines.
 (4) This function constructs different types of output
 for baselines; namely, a set of raster line values and
 a set of end points of each baseline.
 (5) This function was designed to handle short and long text lines
 without using dangerous thresholds on the peak heights.  It does
 this by combining the differential signal with a morphological
 analysis of the locations of the text lines.  One can also
 combine this data to normalize the peak heights, by weighting
 the differential signal in the region of each baseline
 by the inverse of the width of the text line found there.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, 300 ppi</param>
	<param name="ppta">pairs of pts corresponding to approx. ends of each text line</param>
	<param name="pixadb">for debug output; use NULL to skip</param>
	<returns>na of baseline y values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDeskewLocal(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This function allows deskew of a page whose skew changes
 approximately linearly with vertical position.  It uses
 a projective transform that in effect does a differential
 shear about the LHS of the page, and makes all text lines
 horizontal.
 (2) The origin of the keystoning can be either a cheap document
 feeder that rotates the page as it is passed through, or a
 camera image taken from either the left or right side
 of the vertical.
 (3) The image transformation is a projective warping,
 not a rotation.  Apart from this function, the text lines
 must be properly aligned vertically with respect to each
 other.  This can be done by pre-processing the page; e.g.,
 by rotating or horizontally shearing it.
 Typically, this can be achieved by vertically aligning
 the page edge.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="nslices">the number of horizontal overlapping slices; must be larger than 1 and not exceed 20; use 0 for default</param>
	<param name="redsweep">sweep reduction factor 1, 2, 4 or 8; use 0 for default value</param>
	<param name="redsearch">search reduction factor 1, 2, 4 or 8, and not larger than redsweep; use 0 for default value</param>
	<param name="sweeprange">half the full range, assumed about 0; in degrees; use 0.0 for default value</param>
	<param name="sweepdelta">angle increment of sweep; in degrees; use 0.0 for default value</param>
	<param name="minbsdelta">min binary search increment angle; in degrees; use 0.0 for default value</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetLocalSkewTransform(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This generates two pairs of points in the src, each pair
 corresponding to a pair of points that would lie along
 the same raster line in a transformed (dewarped) image.
 (2) The sets of 4 src and 4 dest points returned by this function
 can then be used, in a projective or bilinear transform,
 to remove keystoning in the src.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="nslices">the number of horizontal overlapping slices; must be larger than 1 and not exceed 20; use 0 for default</param>
	<param name="redsweep">sweep reduction factor 1, 2, 4 or 8; use 0 for default value</param>
	<param name="redsearch">search reduction factor 1, 2, 4 or 8, and not larger than redsweep; use 0 for default value</param>
	<param name="sweeprange">half the full range, assumed about 0; in degrees; use 0.0 for default value</param>
	<param name="sweepdelta">angle increment of sweep; in degrees; use 0.0 for default value</param>
	<param name="minbsdelta">min binary search increment angle; in degrees; use 0.0 for default value</param>
	<param name="pptas">4 points in the source</param>
	<param name="pptad">the corresponding 4 pts in the dest</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetLocalSkewAngles(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single[]@,System.Single[]@,System.Int32)">
	<summary>
 Notes
 (1) The local skew is measured in a set of overlapping strips.
 We then do a least square linear fit parameters to get
 the slope and intercept parameters a and b in
 skew-angle = a  y + b  (degrees)
 for the local skew as a function of raster line y.
 This is then used to make naskew, which can be interpreted
 as the computed skew angle (in degrees) at the left edge
 of each raster line.
 (2) naskew can then be used to find the baselines of text, because
 each text line has a baseline that should intersect
 the left edge of the image with the angle given by this
 array, evaluated at the raster line of intersection.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="nslices">the number of horizontal overlapping slices; must be larger than 1 and not exceed 20; 0 for default</param>
	<param name="redsweep">sweep reduction factor 1, 2, 4 or 8; use 0 for default value</param>
	<param name="redsearch">search reduction factor 1, 2, 4 or 8, and not larger than redsweep; use 0 for default value</param>
	<param name="sweeprange">half the full range, assumed about 0; in degrees; use 0.0 for default value</param>
	<param name="sweepdelta">angle increment of sweep; in degrees; use 0.0 for default value</param>
	<param name="minbsdelta">min binary search increment angle; in degrees; use 0.0 for default value</param>
	<param name="pa">slope of skew as fctn of y</param>
	<param name="pb">intercept at y=0 of skew as fctn of y</param>
	<param name="debug">1 for generating plot of skew angle vs. y; 0 otherwise</param>
	<returns>naskew, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.bbufferCreate(System.Byte[],System.Int32)">
	<summary>
 Notes
 (1) If a buffer address is given, you should read all the data in.
 (2) Allocates a bbuffer with associated byte array of
 the given size.  If a buffer address is given,
 it then reads the number of bytes into the byte array.
 </summary>
	<remarks>
	</remarks>
	<param name="indata">address in memory [optional]</param>
	<param name="nalloc">size of byte array to be alloc'd 0 for default</param>
	<returns>bbuffer, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.bbufferDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Destroys the byte array in the bbuffer and then the bbuffer;
 then nulls the contents of the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pbb">buffer to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.bbufferDestroyAndSaveData(System.IntPtr@,System.UInt32@)">
	<summary>
 Notes
 (1) Copies data to newly allocated array; then destroys the bbuffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pbb">buffer to be nulled</param>
	<param name="pnbytes">number of bytes saved in array</param>
	<returns>barray newly allocated array of data</returns>
</member><member name="M:LeptonicaSharp.Natives.bbufferRead(System.IntPtr,System.Byte[],System.Int32)">
	<summary>
 Notes
 (1) For a read after write, first remove the written
 bytes by shifting the unwritten bytes in the array,
 then check if there is enough room to add the new bytes.
 If not, realloc with bbufferExpandArray(), resulting
 in a second writing of the unwritten bytes.  While less
 efficient, this is simpler than making a special case
 of reallocNew().
 </summary>
	<remarks>
	</remarks>
	<param name="bb">bbuffer</param>
	<param name="src">source memory buffer from which bytes are read</param>
	<param name="nbytes">bytes to be read</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.bbufferReadStream(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bb">bbuffer</param>
	<param name="fp">source stream from which bytes are read</param>
	<param name="nbytes">bytes to be read</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.bbufferExtendArray(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) reallocNew() copies all bb-GTnalloc bytes, even though
 only bb-GTn are data.
 </summary>
	<remarks>
	</remarks>
	<param name="bb">bbuffer</param>
	<param name="nbytes">number of bytes to extend array size</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.bbufferWrite(System.IntPtr,System.Byte[],System.UInt32,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bb">bbuffer</param>
	<param name="dest">dest memory buffer to which bytes are written</param>
	<param name="nbytes">bytes requested to be written</param>
	<param name="pnout">bytes actually written</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.bbufferWriteStream(System.IntPtr,System.IntPtr,System.UInt32,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bb">bbuffer</param>
	<param name="fp">dest stream to which bytes are written</param>
	<param name="nbytes">bytes requested to be written</param>
	<param name="pnout">bytes actually written</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBilateral(System.IntPtr,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This performs a relatively fast, separable bilateral
 filtering operation.  The time is proportional to ncomps
 and varies inversely approximately as the cube of the
 reduction factor.  See bilateral.h for algorithm details.
 (2) We impose minimum values for range_stdev and ncomps to
 avoid nasty artifacts when either are too small.  We also
 impose a constraint on their product
 ncomps  range_stdev GT= 100.
 So for values of range_stdev GT= 25, ncomps can be as small as 4.
 Here is a qualitative, intuitive explanation for this constraint.
 Call the difference in k values between the J(k) == 'delta', where
 'delta' ~ 200 / ncomps
 Then this constraint is roughly equivalent to the condition
 'delta' LT 2  range_stdev
 Note that at an intensity difference of (2  range_stdev), the
 range part of the kernel reduces the effect by the factor 0.14.
 This constraint requires that we have a sufficient number of
 PCBs (i.e, a small enough 'delta'), so that for any value of
 image intensity I, there exists a k (and a PCB, J(k), such that
 |I - k| LT range_stdev
 Any fewer PCBs and we don't have enough to support this condition.
 (3) The upper limit of 30 on ncomps is imposed because the
 gain in accuracy is not worth the extra computation.
 (4) The size of the gaussian kernel is twice the spatial_stdev
 on each side of the origin.  The minimum value of
 spatial_stdev, 0.5, is required to have a finite sized
 spatial kernel.  In practice, a much larger value is used.
 (5) Computation of the intermediate images goes inversely
 as the cube of the reduction factor.  If you can use a
 reduction of 2 or 4, it is well-advised.
 (6) The range kernel is defined over the absolute value of pixel
 grayscale differences, and hence must have size 256 x 1.
 Values in the array represent the multiplying weight
 depending on the absolute gray value difference between
 the source pixel and the neighboring pixel, and should
 be monotonically decreasing.
 (7) Interesting observation.  Run this on prog/fish24.jpg, with
 range_stdev = 60, ncomps = 6, and spatial_dev = {10, 30, 50}.
 As spatial_dev gets larger, we get the counter-intuitive
 result that the body of the red fish becomes less blurry.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb, no colormap</param>
	<param name="spatial_stdev">of gaussian kernel; in pixels, GT 0.5</param>
	<param name="range_stdev">of gaussian range kernel; GT 5.0; typ. 50.0</param>
	<param name="ncomps">number of intermediate sums J(k,x); in [4 ... 30]</param>
	<param name="reduction">1, 2 or 4</param>
	<returns>pixd bilateral filtered image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBilateralGray(System.IntPtr,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixBilateral() for constraints on the input parameters.
 (2) See pixBilateral() for algorithm details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray</param>
	<param name="spatial_stdev">of gaussian kernel; in pixels, GT 0.5</param>
	<param name="range_stdev">of gaussian range kernel; GT 5.0; typ. 50.0</param>
	<param name="ncomps">number of intermediate sums J(k,x); in [4 ... 30]</param>
	<param name="reduction">1, 2 or 4</param>
	<returns>pixd 8 bpp bilateral filtered image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBilateralExact(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) The spatial_kel is a conventional smoothing kernel, typically a
 2-d Gaussian kernel or other block kernel.  It can be either
 normalized or not, but must be everywhere positive.
 (2) The range_kel is defined over the absolute value of pixel
 grayscale differences, and hence must have size 256 x 1.
 Values in the array represent the multiplying weight for each
 gray value difference between the target pixel and center of the
 kernel, and should be monotonically decreasing.
 (3) If range_kel == NULL, a constant weight is applied regardless
 of the range value difference.  This degenerates to a regular
 pixConvolve() with a normalized kernel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb</param>
	<param name="spatial_kel">gaussian kernel</param>
	<param name="range_kel">256 x 1, monotonically decreasing</param>
	<returns>pixd 8 bpp bilateral filtered image</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBilateralGrayExact(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) See pixBilateralExact().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray</param>
	<param name="spatial_kel">gaussian kernel</param>
	<param name="range_kel">256 x 1, monotonically decreasing</param>
	<returns>pixd 8 bpp bilateral filtered image</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlockBilateralExact(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) See pixBilateralExact().  This provides an interface using
 the standard deviations of the spatial and range filters.
 (2) The convolution window halfwidth is 2  spatial_stdev,
 and the square filter size is 4  spatial_stdev + 1.
 The kernel captures 95% of total energy.  This is compensated
 by normalization.
 (3) The range_stdev is analogous to spatial_halfwidth in the
 grayscale domain [0...255], and determines how much damping of the
 smoothing operation is applied across edges.  The larger this
 value is, the smaller the damping.  The smaller the value, the
 more edge details are preserved.  These approximations are useful
 for deciding the appropriate cutoff.
 kernel[1  stdev] ~= 0.6   kernel[0]
 kernel[2  stdev] ~= 0.14  kernel[0]
 kernel[3  stdev] ~= 0.01  kernel[0]
 If range_stdev is infinite there is no damping, and this
 becomes a conventional gaussian smoothing.
 This value does not affect the run time.
 (4) If range_stdev is negative or zero, the range kernel is
 ignored and this degenerates to a straight gaussian convolution.
 (5) This is very slow for large spatial filters.  The time
 on a 3GHz pentium is roughly
 T = 1.2  10^-8  (A  sh^2)  sec
 where A = # of pixels, sh = spatial halfwidth of filter.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb</param>
	<param name="spatial_stdev">GT 0.0</param>
	<param name="range_stdev">GT 0.0</param>
	<returns>pixd 8 bpp or 32 bpp bilateral filtered image</returns>
</member><member name="M:LeptonicaSharp.Natives.makeRangeKernel(System.Single)">
	<summary>
 Notes
 (1) Creates a one-sided Gaussian kernel with the given
 standard deviation.  At grayscale difference of one stdev,
 the kernel falls to 0.6, and to 0.01 at three stdev.
 (2) A typical input number might be 20.  Then pixels whose
 value differs by 60 from the center pixel have their
 weight in the convolution reduced by a factor of about 0.01.
 </summary>
	<remarks>
	</remarks>
	<param name="range_stdev">GT 0</param>
	<returns>kel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBilinearSampledPta(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary.
 (2) Retains colormap, which you can do for a sampled transform..
 (3) No 3 of the 4 points may be collinear.
 (4) For 8 and 32 bpp pix, better quality is obtained by the
 somewhat slower pixBilinearPta().  See that
 function for relative timings between sampled and interpolated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBilinearSampled(System.IntPtr,System.Single[],System.Int32)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary.
 (2) Retains colormap, which you can do for a sampled transform..
 (3) For 8 or 32 bpp, much better quality is obtained by the
 somewhat slower pixBilinear().  See that function
 for relative timings between sampled and interpolated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="vc">vector of 8 coefficients for bilinear transformation</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBilinearPta(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary
 (2) Removes any existing colormap, if necessary, before transforming
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBilinear(System.IntPtr,System.Single[],System.Int32)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary
 (2) Removes any existing colormap, if necessary, before transforming
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="vc">vector of 8 coefficients for bilinear transformation</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBilinearPtaColor(System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBilinearColor(System.IntPtr,System.Single[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="vc">vector of 8 coefficients for bilinear transformation</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBilinearPtaGray(System.IntPtr,System.IntPtr,System.IntPtr,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBilinearGray(System.IntPtr,System.Single[],System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="vc">vector of 8 coefficients for bilinear transformation</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBilinearPtaWithAlpha(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) The alpha channel is transformed separately from pixs,
 and aligns with it, being fully transparent outside the
 boundary of the transformed pixs.  For pixels that are fully
 transparent, a blending function like pixBlendWithGrayMask()
 will give zero weight to corresponding pixels in pixs.
 (2) If pixg is NULL, it is generated as an alpha layer that is
 partially opaque, using %fract.  Otherwise, it is cropped
 to pixs if required and %fract is ignored.  The alpha channel
 in pixs is never used.
 (3) Colormaps are removed.
 (4) When pixs is transformed, it doesn't matter what color is brought
 in because the alpha channel will be transparent (0) there.
 (5) To avoid losing source pixels in the destination, it may be
 necessary to add a border to the source pix before doing
 the bilinear transformation.  This can be any non-negative number.
 (6) The input %ptad and %ptas are in a coordinate space before
 the border is added.  Internally, we compensate for this
 before doing the bilinear transform on the image after
 the border is added.
 (7) The default setting for the border values in the alpha channel
 is 0 (transparent) for the outermost ring of pixels and
 (0.5  fract  255) for the second ring.  When blended over
 a second image, this
 (a) shrinks the visible image to make a clean overlap edge
 with an image below, and
 (b) softens the edges by weakening the aliasing there.
 Use l_setAlphaMaskBorder() to change these values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="pixg">8 bpp, can be null</param>
	<param name="fract">between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	<param name="border">of pixels added to capture transformed source pixels</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getBilinearXformCoeffs(System.IntPtr,System.IntPtr,System.IntPtr@)">
	<summary>
 We have a set of 8 equations, describing the bilinear
 transformation that takes 4 points ptas into 4 other
 points ptad.  These equations are
 x1' = c[0]x1 + c[1]y1 + c[2]x1y1 + c[3]
 y1' = c[4]x1 + c[5]y1 + c[6]x1y1 + c[7]
 x2' = c[0]x2 + c[1]y2 + c[2]x2y2 + c[3]
 y2' = c[4]x2 + c[5]y2 + c[6]x2y2 + c[7]
 x3' = c[0]x3 + c[1]y3 + c[2]x3y3 + c[3]
 y3' = c[4]x3 + c[5]y3 + c[6]x3y3 + c[7]
 x4' = c[0]x4 + c[1]y4 + c[2]x4y4 + c[3]
 y4' = c[4]x4 + c[5]y4 + c[6]x4y4 + c[7]
 This can be represented as
 AC = B
 where B and C are column vectors
 B = [ x1' y1' x2' y2' x3' y3' x4' y4' ]
 C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] c[7] ]
 and A is the 8x8 matrix
 x1   y1   x1y1   1   0 0   0  0
 0 0  0  0   x1   y1   x1y1   1
 x2   y2   x2y2   1   0 0   0  0
 0 0  0  0   x2   y2   x2y2   1
 x3   y3   x3y3   1   0 0   0  0
 0 0  0  0   x3   y3   x3y3   1
 x4   y4   x4y4   1   0 0   0  0
 0 0  0  0   x4   y4   x4y4   1
 These eight equations are solved here for the coefficients C.
 These eight coefficients can then be used to find the mapping
 x,y) --GT (x',y'
 x' = c[0]x + c[1]y + c[2]xy + c[3]
 y' = c[4]x + c[5]y + c[6]xy + c[7]
 that are implemented in bilinearXformSampledPt and
 bilinearXFormPt.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">source 4 points; unprimed</param>
	<param name="ptad">transformed 4 points; primed</param>
	<param name="pvc">vector of coefficients of transform</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.bilinearXformSampledPt(System.Single[],System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This finds the nearest pixel coordinates of the transformed point.
 (2) It does not check ptrs for returned data!
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 8 coefficients</param>
	<param name="x">initial point</param>
	<param name="y">initial point</param>
	<param name="pxp">transformed point</param>
	<param name="pyp">transformed point</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.bilinearXformPt(System.Single[],System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This computes the floating point location of the transformed point.
 (2) It does not check ptrs for returned data!
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 8 coefficients</param>
	<param name="x">initial point</param>
	<param name="y">initial point</param>
	<param name="pxp">transformed point</param>
	<param name="pyp">transformed point</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOtsuAdaptiveThreshold(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The Otsu method finds a single global threshold for an image.
 This function allows a locally adapted threshold to be
 found for each tile into which the image is broken up.
 (2) The array of threshold values, one for each tile, constitutes
 a highly downscaled image.  This array is optionally
 smoothed using a convolution.  The full width and height of the
 convolution kernel are (2  %smoothx + 1) and (2  %smoothy + 1).
 (3) The minimum tile dimension allowed is 16.  If such small
 tiles are used, it is recommended to use smoothing, because
 without smoothing, each small tile determines the splitting
 threshold independently.  A tile that is entirely in the
 image bg will then hallucinate fg, resulting in a very noisy
 binarization.  The smoothing should be large enough that no
 tile is only influenced by one type (fg or bg) of pixels,
 because it will force a split of its pixels.
 (4) To get a single global threshold for the entire image, use
 input values of %sx and %sy that are larger than the image.
 For this situation, the smoothing parameters are ignored.
 (5) The threshold values partition the image pixels into two classes
 one whose values are less than the threshold and another
 whose values are greater than or equal to the threshold.
 This is the same use of 'threshold' as in pixThresholdToBinary().
 (6) The scorefract is the fraction of the maximum Otsu score, which
 is used to determine the range over which the histogram minimum
 is searched.  See numaSplitDistribution() for details on the
 underlying method of choosing a threshold.
 (7) This uses enables a modified version of the Otsu criterion for
 splitting the distribution of pixels in each tile into a
 fg and bg part.  The modification consists of searching for
 a minimum in the histogram over a range of pixel values where
 the Otsu score is within a defined fraction, %scorefract,
 of the max score.  To get the original Otsu algorithm, set
 %scorefract == 0.
 (8) N.B. This method is NOT recommended for images with weak text
 and significant background noise, such as bleedthrough, because
 of the problem noted in (3) above for tiling.  Use Sauvola.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="sx">desired tile dimensions; actual size may vary</param>
	<param name="sy">desired tile dimensions; actual size may vary</param>
	<param name="smoothx">half-width of convolution kernel applied to threshold array use 0 for no smoothing</param>
	<param name="smoothy">half-width of convolution kernel applied to threshold array use 0 for no smoothing</param>
	<param name="scorefract">fraction of the max Otsu score; typ. 0.1; use 0.0 for standard Otsu</param>
	<param name="ppixth">array of threshold values found for each tile</param>
	<param name="ppixd">thresholded input pixs, based on the threshold array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOtsuThreshOnBackgroundNorm(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Int32@)">
	<summary>
 Notes
 (1) This does background normalization followed by Otsu
 thresholding.  Otsu binarization attempts to split the
 image into two roughly equal sets of pixels, and it does
 a very poor job when there are large amounts of dark
 background.  By doing a background normalization first,
 to get the background near 255, we remove this problem.
 Then we use a modified Otsu to estimate the best global
 threshold on the normalized image.
 (2) See pixBackgroundNorm() for meaning and typical values
 of input parameters.  For a start, you can try
 sx, sy = 10, 15
 thresh = 100
 mincount = 50
 bgval = 255
 smoothx, smoothy = 2
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="smoothx">half-width of block convolution kernel width</param>
	<param name="smoothy">half-width of block convolution kernel height</param>
	<param name="scorefract">fraction of the max Otsu score; typ. 0.1</param>
	<param name="pthresh">threshold value that was used on the normalized image</param>
	<returns>pixd 1 bpp thresholded image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMaskedThreshOnBackgroundNorm(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Int32@)">
	<summary>
 Notes
 (1) This begins with a standard background normalization.
 Additionally, there is a flexible background norm, that
 will adapt to a rapidly varying background, and this
 puts white pixels in the background near regions with
 significant foreground.  The white pixels are turned into
 a 1 bpp selection mask by binarization followed by dilation.
 Otsu thresholding is performed on the input image to get an
 estimate of the threshold in the non-mask regions.
 The background normalized image is thresholded with two
 different values, and the result is combined using
 the selection mask.
 (2) Note that the numbers 255 (for bgval target) and 190 (for
 thresholding on pixn) are tied together, and explicitly
 defined in this function.
 (3) See pixBackgroundNorm() for meaning and typical values
 of input parameters.  For a start, you can try
 sx, sy = 10, 15
 thresh = 100
 mincount = 50
 smoothx, smoothy = 2
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="smoothx">half-width of block convolution kernel width</param>
	<param name="smoothy">half-width of block convolution kernel height</param>
	<param name="scorefract">fraction of the max Otsu score; typ. ~ 0.1</param>
	<param name="pthresh">threshold value that was used on the normalized image</param>
	<returns>pixd 1 bpp thresholded image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSauvolaBinarizeTiled(System.IntPtr,System.Int32,System.Single,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The window width and height are 2  %whsize + 1.  The minimum
 value for %whsize is 2; typically it is GT= 7..
 (2) For nx == ny == 1, this defaults to pixSauvolaBinarize().
 (3) Why a tiled version?
 (a) Because the mean value accumulator is a uint32, overflow
 can occur for an image with more than 16M pixels.
 (b) The mean value accumulator array for 16M pixels is 64 MB.
 The mean square accumulator array for 16M pixels is 128 MB.
 Using tiles reduces the size of these arrays.
 (c) Each tile can be processed independently, in parallel,
 on a multicore processor.
 (4) The Sauvola threshold is determined from the formula
 t = m  (1 - k  (1 - s / 128))
 See pixSauvolaBinarize() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, not colormapped</param>
	<param name="whsize">window half-width for measuring local statistics</param>
	<param name="factor">factor for reducing threshold due to variance; GT= 0</param>
	<param name="nx">subdivision into tiles; GT= 1</param>
	<param name="ny">subdivision into tiles; GT= 1</param>
	<param name="ppixth">Sauvola threshold values</param>
	<param name="ppixd">thresholded image</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSauvolaBinarize(System.IntPtr,System.Int32,System.Single,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The window width and height are 2  %whsize + 1.  The minimum
 value for %whsize is 2; typically it is GT= 7..
 (2) The local statistics, measured over the window, are the
 average and standard deviation.
 (3) The measurements of the mean and standard deviation are
 performed inside a border of (%whsize + 1) pixels.  If pixs does
 not have these added border pixels, use %addborder = 1 to add
 it here; otherwise use %addborder = 0.
 (4) The Sauvola threshold is determined from the formula
 t = m  (1 - k  (1 - s / 128))
 where
 t = local threshold
 m = local mean
 k = %factor (GT= 0)   [ typ. 0.35 ]
 s = local standard deviation, which is maximized at
 127.5 when half the samples are 0 and half are 255.
 (5) The basic idea of Niblack and Sauvola binarization is that
 the local threshold should be less than the median value,
 and the larger the variance, the closer to the median
 it should be chosen.  Typical values for k are between
 0.2 and 0.5.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="whsize">window half-width for measuring local statistics</param>
	<param name="factor">factor for reducing threshold due to variance; GT= 0</param>
	<param name="addborder">1 to add border of width (%whsize + 1) on all sides</param>
	<param name="ppixm">local mean values</param>
	<param name="ppixsd">local standard deviation values</param>
	<param name="ppixth">threshold values</param>
	<param name="ppixd">thresholded image</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSauvolaGetThreshold(System.IntPtr,System.IntPtr,System.Single,System.IntPtr@)">
	<summary>
 Notes
 (1) The Sauvola threshold is determined from the formula
 t = m  (1 - k  (1 - s / 128))
 where
 t = local threshold
 m = local mean
 k = %factor (GT= 0)   [ typ. 0.35 ]
 s = local standard deviation, which is maximized at
 127.5 when half the samples are 0 and half are 255.
 (2) See pixSauvolaBinarize() for other details.
 (3) Important definitions and relations for computing averages
 v == pixel value
 E(p) == expected value of p == average of p over some pixel set
 S(v) == square of v == v  v
 mv == E(v) == expected pixel value == mean value
 ms == E(S(v)) == expected square of pixel values
 == mean square value
 var == variance == expected square of deviation from mean
 == E(S(v - mv)) = E(S(v) - 2  S(v  mv) + S(mv))
 = E(S(v)) - S(mv)
 = ms - mv  mv
 s == standard deviation = sqrt(var)
 So for evaluating the standard deviation in the Sauvola
 threshold, we take
 s = sqrt(ms - mv  mv)
 </summary>
	<remarks>
	</remarks>
	<param name="pixm">8 bpp grayscale; not colormapped</param>
	<param name="pixms">32 bpp</param>
	<param name="factor">factor for reducing threshold due to variance; GT= 0</param>
	<param name="ppixsd">local standard deviation</param>
	<returns>pixd 8 bpp, sauvola threshold values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixApplyLocalThreshold(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="pixth">8 bpp array of local thresholds</param>
	<param name="redfactor">...</param>
	<returns>pixd 1 bpp, thresholded image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixThresholdByConnComp(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This finds a global threshold based on connected components.
 Although slow, it is reasonable to use it in a situation where
 (a) the background in the image is relatively uniform, and
 (b) the result will be fed to an OCR program that accepts 1 bpp
 images and works best with easily segmented characters.
 The reason for (b) is that this selects a threshold with a
 minimum number of both broken characters and merged characters.
 (2) If the pix has color, it is converted to gray using the
 max component.
 (3) Input 0 to use default values for any of these inputs
 %start, %end, %incr, %thresh48, %threshdiff.
 (4) This approach can be understood as follows.  When the
 binarization threshold is varied, the numbers of c.c. identify
 four regimes
 (a) For low thresholds, text is broken into small pieces, and
 the number of c.c. is large, with the 4 c.c. significantly
 exceeding the 8 c.c.
 (b) As the threshold rises toward the optimum value, the text
 characters coalesce and there is very little difference
 between the numbers of 4 and 8 c.c, which both go
 through a minimum.
 (c) Above this, the image background gets noisy because some
 pixels are(thresholded to foreground, and the numbers
 of c.c. quickly increase, with the 4 c.c. significantly
 larger than the 8 c.c.
 (d) At even higher thresholds, the image background noise
 coalesces as it becomes mostly foreground, and the
 number of c.c. drops quickly.
 (5) If there is no global threshold that distinguishes foreground
 text from background (e.g., weak text over a background that
 has significant variation and/or bleedthrough), this returns 1,
 which the caller should check.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">depth GT 1, colormap OK</param>
	<param name="pixm">1 bpp mask giving region to ignore by setting pixels to white; use NULL if no mask</param>
	<param name="start">binarization threshold levels to test</param>
	<param name="incr">binarization threshold levels to test</param>
	<param name="thresh48">threshold on normalized difference between the numbers of 4 and 8 connected components</param>
	<param name="threshdiff">threshold on normalized difference between the number of 4 cc at successive iterations</param>
	<param name="pglobthresh">best global threshold; 0 if no threshold is found</param>
	<param name="ppixd">image thresholded to binary, or null if no threshold is found</param>
	<param name="debugflag">1 for plotted results</param>
	<returns>0 if OK, 1 on error or if no threshold is found</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExpandBinaryReplicate(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="xfact">integer scale factor for horiz. replicative expansion</param>
	<param name="yfact">integer scale factor for vertical replicative expansion</param>
	<returns>pixd scaled up, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExpandBinaryPower2(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="factor">expansion factor 1, 2, 4, 8, 16</param>
	<returns>pixd expanded 1 bpp by replication, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReduceBinary2(System.IntPtr,System.Byte[])">
	<summary>
 Notes
 (1) After folding, the data is in bytes 0 and 2 of the word,
 and the bits in each byte are in the following order
 (with 0 being the leftmost originating pair and 7 being
 the rightmost originating pair)
 0 4 1 5 2 6 3 7
 These need to be permuted to
 0 1 2 3 4 5 6 7
 which is done with an 8-bit table generated by makeSubsampleTab2x().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="intab">; if null, a table is made here and destroyed before exit</param>
	<returns>pixd 2x subsampled, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReduceRankBinaryCascade(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This performs up to four cascaded 2x rank reductions.
 (2) Use level = 0 to truncate the cascade.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="level1">threshold, in the set {0, 1, 2, 3, 4}</param>
	<param name="level2">threshold, in the set {0, 1, 2, 3, 4}</param>
	<param name="level3">threshold, in the set {0, 1, 2, 3, 4}</param>
	<param name="level4">threshold, in the set {0, 1, 2, 3, 4}</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReduceRankBinary2(System.IntPtr,System.Int32,System.Byte[])">
	<summary>
 Notes
 (1) pixd is downscaled by 2x from pixs.
 (2) The rank threshold specifies the minimum number of ON
 pixels in each 2x2 region of pixs that are required to
 set the corresponding pixel ON in pixd.
 (3) Rank filtering is done to the UL corner of each 2x2 pixel block,
 using only logical operations.  Then these pixels are chosen
 in the 2x subsampling process, subsampled, as described
 above in pixReduceBinary2().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="level">rank threshold 1, 2, 3, 4</param>
	<param name="intab">; if null, a table is made here and destroyed before exit</param>
	<returns>pixd 1 bpp, 2x rank threshold reduced, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makeSubsampleTab2x">
	<summary>
 This table permutes the bits in a byte, from
 0 4 1 5 2 6 3 7
 to
 0 1 2 3 4 5 6 7
 </summary>
	<remarks>
	</remarks>
	<returns>tab table of 256 permutations, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlend(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This is a simple top-level interface.  For more flexibility,
 call directly into pixBlendMask(), etc.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">blendee</param>
	<param name="pixs2">blender; typ. smaller</param>
	<param name="x">,y  origin [UL corner] of pixs2 relative to the origin of pixs1; can be LT 0</param>
	<param name="fract">blending fraction</param>
	<returns>pixd blended image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlendMask(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
 (2) If pixs1 has a colormap, it is removed.
 (3) For inplace operation (pixs1 not cmapped), call it this way
 pixBlendMask(pixs1, pixs1, pixs2, ...)
 (4) For generating a new pixd
 pixd = pixBlendMask(NULL, pixs1, pixs2, ...)
 (5) Only call in-place if pixs1 does not have a colormap.
 (6) Invalid %fract defaults to 0.5 with a warning.
 Invalid %type defaults to L_BLEND_WITH_INVERSE with a warning.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs1 for in-place</param>
	<param name="pixs1">blendee, depth GT 1</param>
	<param name="pixs2">blender, 1 bpp; typ. smaller in size than pixs1</param>
	<param name="x">,y  origin [UL corner] of pixs2 relative to the origin of pixs1; can be LT 0</param>
	<param name="fract">blending fraction</param>
	<param name="type">L_BLEND_WITH_INVERSE, L_BLEND_TO_WHITE, L_BLEND_TO_BLACK</param>
	<returns>pixd if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlendGray(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) For inplace operation (pixs1 not cmapped), call it this way
 pixBlendGray(pixs1, pixs1, pixs2, ...)
 (2) For generating a new pixd
 pixd = pixBlendGray(NULL, pixs1, pixs2, ...)
 (3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
 (4) If pixs1 has a colormap, it is removed; otherwise, if pixs1
 has depth LT 8, it is unpacked to generate a 8 bpp pix.
 (5) If transparent = 0, the blending fraction (fract) is
 applied equally to all pixels.
 (6) If transparent = 1, all pixels of value transpix (typically
 either 0 or 0xff) in pixs2 are transparent in the blend.
 (7) After processing pixs1, it is either 8 bpp or 32 bpp
 ~ if 8 bpp, the fraction of pixs2 is mixed with pixs1.
 ~ if 32 bpp, each component of pixs1 is mixed with
 the same fraction of pixs2.
 (8) For L_BLEND_GRAY_WITH_INVERSE, the white values of the blendee
 (cval == 255 in the code below) result in a delta of 0.
 Thus, these pixels are intrinsically transparent!
 The "pivot" value of the src, at which no blending occurs, is
 128.  Compare with the adaptive pivot in pixBlendGrayAdapt().
 (9) Invalid %fract defaults to 0.5 with a warning.
 Invalid %type defaults to L_BLEND_GRAY with a warning.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs1 for in-place</param>
	<param name="pixs1">blendee, depth GT 1</param>
	<param name="pixs2">blender, any depth; typ. smaller in size than pixs1</param>
	<param name="x">,y  origin [UL corner] of pixs2 relative to the origin of pixs1; can be LT 0</param>
	<param name="fract">blending fraction</param>
	<param name="type">L_BLEND_GRAY, L_BLEND_GRAY_WITH_INVERSE</param>
	<param name="transparent">1 to use transparency; 0 otherwise</param>
	<param name="transpix">pixel grayval in pixs2 that is to be transparent</param>
	<returns>pixd if OK; pixs1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlendGrayInverse(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) For inplace operation (pixs1 not cmapped), call it this way
 pixBlendGrayInverse(pixs1, pixs1, pixs2, ...)
 (2) For generating a new pixd
 pixd = pixBlendGrayInverse(NULL, pixs1, pixs2, ...)
 (3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
 (4) If pixs1 has a colormap, it is removed; otherwise if pixs1
 has depth LT 8, it is unpacked to generate a 8 bpp pix.
 (5) This is a no-nonsense blender.  It changes the src1 pixel except
 when the src1 pixel is midlevel gray.  Use fract == 1 for the most
 aggressive blending, where, if the gray pixel in pixs2 is 0,
 we get a complete inversion of the color of the src pixel in pixs1.
 (6) The basic logic is that each component transforms by
   d  --GT  c * d + (1 - c ) * (f * (1 - d) + d * (1 - f))
 where c is the blender pixel from pixs2,
 f is %fract,
 c and d are normalized to [0...1]
 This has the property that for f == 0 (no blend) or c == 1 (white)
 d  --GT  d
 For c == 0 (black) we get maximum inversion
 d  --GT  f  (1 - d) + d  (1 - f)   [inversion by fraction f]
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs1 for in-place</param>
	<param name="pixs1">blendee, depth GT 1</param>
	<param name="pixs2">blender, any depth; typ. smaller in size than pixs1</param>
	<param name="x">,y  origin [UL corner] of pixs2 relative to the origin of pixs1; can be LT 0</param>
	<param name="fract">blending fraction</param>
	<returns>pixd if OK; pixs1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlendColor(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) For inplace operation (pixs1 must be 32 bpp), call it this way
 pixBlendColor(pixs1, pixs1, pixs2, ...)
 (2) For generating a new pixd
 pixd = pixBlendColor(NULL, pixs1, pixs2, ...)
 (3) If pixs2 is not 32 bpp rgb, it is converted.
 (4) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
 (5) If pixs1 has a colormap, it is removed to generate a 32 bpp pix.
 (6) If pixs1 has depth LT 32, it is unpacked to generate a 32 bpp pix.
 (7) If transparent = 0, the blending fraction (fract) is
 applied equally to all pixels.
 (8) If transparent = 1, all pixels of value transpix (typically
 either 0 or 0xffffff00) in pixs2 are transparent in the blend.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs1 for in-place</param>
	<param name="pixs1">blendee; depth GT 1</param>
	<param name="pixs2">blender, any depth;; typ. smaller in size than pixs1</param>
	<param name="x">,y  origin [UL corner] of pixs2 relative to the origin of pixs1</param>
	<param name="fract">blending fraction</param>
	<param name="transparent">1 to use transparency; 0 otherwise</param>
	<param name="transpix">pixel color in pixs2 that is to be transparent</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlendColorByChannel(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Int32,System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlendGrayAdapt(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) For inplace operation (pixs1 not cmapped), call it this way
 pixBlendGrayAdapt(pixs1, pixs1, pixs2, ...)
 For generating a new pixd
 pixd = pixBlendGrayAdapt(NULL, pixs1, pixs2, ...)
 (2) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
 (3) If pixs1 has a colormap, it is removed.
 (4) If pixs1 has depth LT 8, it is unpacked to generate a 8 bpp pix.
 (5) This does a blend with inverse.  Whereas in pixGlendGray(), the
 zero blend point is where the blendee pixel is 128, here
 the zero blend point is found adaptively, with respect to the
 median of the blendee region.  If the median is LT 128,
 the zero blend point is found from
 median + shift.
 Otherwise, if the median GT= 128, the zero blend point is
 median - shift.
 The purpose of shifting the zero blend point away from the
 median is to prevent a situation in pixBlendGray() where
 the median is 128 and the blender is not visible.
 The default value of shift is 64.
 (6) After processing pixs1, it is either 8 bpp or 32 bpp
 ~ if 8 bpp, the fraction of pixs2 is mixed with pixs1.
 ~ if 32 bpp, each component of pixs1 is mixed with
 the same fraction of pixs2.
 (7) The darker the blender, the more it mixes with the blendee.
 A blender value of 0 has maximum mixing; a value of 255
 has no mixing and hence is transparent.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs1 for in-place</param>
	<param name="pixs1">blendee, depth GT 1</param>
	<param name="pixs2">blender, any depth; typ. smaller in size than pixs1</param>
	<param name="x">,y  origin [UL corner] of pixs2 relative to the origin of pixs1; can be LT 0</param>
	<param name="fract">blending fraction</param>
	<param name="shift">GT= 0 but LT= 128 shift of zero blend value from median source; use -1 for default value;</param>
	<returns>pixd if OK; pixs1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFadeWithGray(System.IntPtr,System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This function combines two pix aligned to the UL corner; they
 need not be the same size.
 (2) Each pixel in pixb is multiplied by 'factor' divided by 255, and
 clipped to the range [0 ... 1].  This gives the fade fraction
 to be applied to pixs.  Fade either to white (L_BLEND_TO_WHITE)
 or to black (L_BLEND_TO_BLACK).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped or 8 bpp or 32 bpp</param>
	<param name="pixb">8 bpp blender</param>
	<param name="factor">multiplicative factor to apply to blender value</param>
	<param name="type">L_BLEND_TO_WHITE, L_BLEND_TO_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlendHardLight(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlendCmap(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This function combines two colormaps, and replaces the pixels
 in pixs that have a specified color value with those in pixb.
 (2) sindex must be in the existing colormap; otherwise an
 error is returned.  In use, sindex will typically be the index
 for white (255, 255, 255).
 (3) Blender colors that already exist in the colormap are used;
 others are added.  If any blender colors cannot be
 stored in the colormap, an error is returned.
 (4) In the implementation, a mapping is generated from each
 original blender colormap index to the corresponding index
 in the expanded colormap for pixs.  Then for each pixel in
 pixs with value sindex, and which is covered by a blender pixel,
 the new index corresponding to the blender pixel is substituted
 for sindex.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp, with colormap</param>
	<param name="pixb">colormapped blender</param>
	<param name="x">UL corner of blender relative to pixs</param>
	<param name="y">UL corner of blender relative to pixs</param>
	<param name="sindex">colormap index of pixels in pixs to be changed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlendWithGrayMask(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The result is 8 bpp grayscale if both pixs1 and pixs2 are
 8 bpp gray.  Otherwise, the result is 32 bpp rgb.
 (2) pixg is an 8 bpp transparency image, where 0 is transparent
 and 255 is opaque.  It determines the transparency of pixs2
 when applied over pixs1.  It can be null if pixs2 is rgba,
 in which case we use the alpha component of pixs2.
 (3) If pixg exists, it need not be the same size as pixs2.
 However, we assume their UL corners are aligned with each other,
 and placed at the location (x, y) in pixs1.
 (4) The pixels in pixd are a combination of those in pixs1
 and pixs2, where the amount from pixs2 is proportional to
 the value of the pixel (p) in pixg, and the amount from pixs1
 is proportional to (255 - p).  Thus pixg is a transparency
 image (usually called an alpha blender) where each pixel
 can be associated with a pixel in pixs2, and determines
 the amount of the pixs2 pixel in the final result.
 For example, if pixg is all 0, pixs2 is transparent and
 the result in pixd is simply pixs1.
 (5) A typical use is for the pixs2/pixg combination to be
 a small watermark that is applied to pixs1.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">8 bpp gray, rgb, rgba or colormapped</param>
	<param name="pixs2">8 bpp gray, rgb, rgba or colormapped</param>
	<param name="pixg">8 bpp gray, for transparency of pixs2; can be null</param>
	<param name="x">UL corner of pixs2 and pixg with respect to pixs1</param>
	<param name="y">UL corner of pixs2 and pixg with respect to pixs1</param>
	<returns>pixd blended image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlendBackgroundToColor(System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This in effect replaces light background pixels in pixs
 by the input color.  It does it by alpha blending so that
 there are no visible artifacts from hard cutoffs.
 (2) If pixd == pixs, this is done in-place.
 (3) If box == NULL, this is performed on all of pixs.
 (4) The alpha component for blending is derived from pixs,
 by converting to grayscale and enhancing with a TRC.
 (5) The last three arguments specify the TRC operation.
 Suggested values are %gamma = 0.3, %minval = 50, %maxval = 200.
 To skip the TRC, use %gamma == 1, %minval = 0, %maxval = 255.
 See pixGammaTRC() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">or pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="box">region for blending; can be NULL)</param>
	<param name="color">32 bit color in 0xrrggbb00 format</param>
	<param name="gamma">args for grayscale TRC mapping</param>
	<param name="minval">args for grayscale TRC mapping</param>
	<param name="maxval">args for grayscale TRC mapping</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMultiplyByColor(System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32)">
	<summary>
 Notes
 (1) This filters all pixels in the specified region by
 multiplying each component by the input color.
 This leaves black invariant and transforms white to the
 input color.
 (2) If pixd == pixs, this is done in-place.
 (3) If box == NULL, this is performed on all of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">or pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="box">region for filtering; can be NULL)</param>
	<param name="color">32 bit color in 0xrrggbb00 format</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAlphaBlendUniform(System.IntPtr,System.UInt32)">
	<summary>
 Notes
 (1) This is a convenience function that renders 32 bpp RGBA images
 (with an alpha channel) over a uniform background of
 value %color.  To render over a white background,
 use %color = 0xffffff00.  The result is an RGB image.
 (2) If pixs does not have an alpha channel, it returns a clone
 of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgba, with alpha</param>
	<param name="color">32 bit color in 0xrrggbb00 format</param>
	<returns>pixd 32 bpp rgb pixs blended over uniform color %color, a clone of pixs if no alpha, and NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddAlphaToBlend(System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This is a simple alpha layer generator, where typically white has
 maximum transparency and black has minimum.
 (2) If %invert == 1, generate the same alpha layer but invert
 the input image photometrically.  This is useful for blending
 over dark images, where you want dark regions in pixs, such
 as text, to be lighter in the blended image.
 (3) The fade %fract gives the minimum transparency (i.e.,
 maximum opacity).  A small fraction is useful for adding
 a watermark to an image.
 (4) If pixs has a colormap, it is removed to rgb.
 (5) If pixs already has an alpha layer, it is overwritten.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="fract">fade fraction in the alpha component</param>
	<param name="invert">1 to photometrically invert pixs</param>
	<returns>pixd 32 bpp with alpha, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetAlphaOverWhite(System.IntPtr)">
	<summary>
 Notes
 (1) The generated alpha component is transparent over white
 (background) pixels in pixs, and quickly grades to opaque
 away from the transparent parts.  This is a cheap and
 dirty alpha generator.  The 2 pixel gradation is useful
 to blur the boundary between the transparent region
 (that will render entirely from a backing image) and
 the remainder which renders from pixs.
 (2) All alpha component bits in pixs are overwritten.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped or 32 bpp rgb; no alpha</param>
	<returns>pixd new pix with meaningful alpha component, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixLinearEdgeFade(System.IntPtr,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) In-place operation.
 (2) Maximum fading fraction %maxfade occurs at the edge of the image,
 and the fraction goes to 0 at the fractional distance %distfract
 from the edge.  %maxfade must be in [0, 1].
 (3) %distrfact must be in [0, 1], and typically it would be LT= 0.5.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp; no colormap</param>
	<param name="dir">L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
	<param name="fadeto">L_BLEND_TO_WHITE, L_BLEND_TO_BLACK</param>
	<param name="distfract">fraction of width or height over which fading occurs</param>
	<param name="maxfade">fraction of fading at the edge, LT= 1.0</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.bmfCreate(System.String,System.Int32)">
	<summary>
 Notes
 (1) If %dir == null, this generates the font bitmaps from a
 compiled string.
 (2) Otherwise, this tries to read a pre-computed pixa file with the
 95 ascii chars in it.  If the file is not found, it then
 attempts to generate the pixa and associated baseline
 data from a tiff image containing all the characters.  If
 that fails, it uses the compiled string.
 </summary>
	<remarks>
	</remarks>
	<param name="dir">directory holding pixa of character set</param>
	<param name="fontsize">4, 6, 8, ... , 20</param>
	<returns>bmf holding the bitmap font and associated information</returns>
</member><member name="M:LeptonicaSharp.Natives.bmfDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pbmf">set to null</param>
</member><member name="M:LeptonicaSharp.Natives.bmfGetPix(System.IntPtr,System.Char)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bmf"></param>
	<param name="chr">should be one of the 95 supported printable bitmaps</param>
	<returns>pix clone of pix in bmf, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.bmfGetWidth(System.IntPtr,System.Char,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bmf"></param>
	<param name="chr">should be one of the 95 supported bitmaps</param>
	<param name="pw">character width; -1 if not printable</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.bmfGetBaseline(System.IntPtr,System.Char,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bmf"></param>
	<param name="chr">should be one of the 95 supported bitmaps</param>
	<param name="pbaseline">distance below UL corner of bitmap char</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaGetFont(System.String,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This reads a pre-computed pixa file with the 95 ascii chars.
 </summary>
	<remarks>
	</remarks>
	<param name="dir">directory holding pixa of character set</param>
	<param name="fontsize">4, 6, 8, ... , 20</param>
	<param name="pbl0">baseline of row 1</param>
	<param name="pbl1">baseline of row 2</param>
	<param name="pbl2">baseline of row 3</param>
	<returns>pixa of font bitmaps for 95 characters, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSaveFont(System.String,System.String,System.Int32)">
	<summary>
 Notes
 (1) This saves a font of a particular size.
 (2) If %dir == null, this generates the font bitmaps from a
 compiled string.
 (3) prog/genfonts calls this function for each of the
 nine font sizes, to generate all the font pixa files.
 </summary>
	<remarks>
	</remarks>
	<param name="indir">directory holding image of character set</param>
	<param name="outdir">directory into which the output pixa file will be written</param>
	<param name="fontsize">in pts, at 300 ppi</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadStreamBmp(System.IntPtr)">
	<summary>
 Notes
 (1) Here are references on the bmp file format
 http//en.wikipedia.org/wiki/BMP_file_format
 http//www.fortunecity.com/skyscraper/windows/364/bmpffrmt.html
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for read</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadMemBmp(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cdata">bmp data</param>
	<param name="size">number of bytes of bmp-formatted data</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamBmp(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix">all depths</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMemBmp(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) 2 bpp bmp files are not valid in the spec, and are
 written as 8 bpp.
 (2) pix with depth LT= 8 bpp are written with a colormap.
 16 bpp gray and 32 bpp rgb pix are written without a colormap.
 (3) The transparency component in an rgb pix is ignored.
 All 32 bpp pix have the bmp alpha component set to 255 (opaque).
 (4) The bmp colormap entries, RGBA_QUAD, are the same as
 the ones used for colormaps in leptonica.  This allows
 a simple memcpy for bmp output.
 </summary>
	<remarks>
	</remarks>
	<param name="pfdata">data of bmp formatted image</param>
	<param name="pfsize">size of returned data</param>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_bootnum_gen1">
	<summary>
 Call this way
 PIXA  pixa = l_bootnum_gen1();   (C)
 Pixa  pixa = l_bootnum_gen1();   (C++)
 </summary>
	<remarks>
	</remarks>
	<returns>pixa  of labeled digits</returns>
</member><member name="M:LeptonicaSharp.Natives.l_bootnum_gen2">
	<summary>
 Call this way
 PIXA  pixa = l_bootnum_gen2();   (C)
 Pixa  pixa = l_bootnum_gen2();   (C++)
 </summary>
	<remarks>
	</remarks>
	<returns>pixa  of labeled digits</returns>
</member><member name="M:LeptonicaSharp.Natives.l_bootnum_gen3">
	<summary>
 Call this way
 PIXA  pixa = l_bootnum_gen3();   (C)
 Pixa  pixa = l_bootnum_gen3();   (C++)
 </summary>
	<remarks>
	</remarks>
	<returns>pixa  of labeled digits</returns>
</member><member name="M:LeptonicaSharp.Natives.boxCreate(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This clips the box to the +quad.  If no part of the
 box is in the +quad, this returns NULL.
 (2) We allow you to make a box with w = 0 and/or h = 0.
 This does not represent a valid region, but it is useful
 as a placeholder in a boxa for which the index of the
 box in the boxa is important.  This is an atypical
 situation; usually you want to put only valid boxes with
 nonzero width and height in a boxa.  If you have a boxa
 with invalid boxes, the accessor boxaGetValidBox()
 will return NULL on each invalid box.
 (3) If you want to create only valid boxes, use boxCreateValid(),
 which returns NULL if either w or h is 0.
 </summary>
	<remarks>
	</remarks>
	<param name="x"></param>
	<param name="y"></param>
	<param name="w"></param>
	<param name="h"></param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxCreateValid(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This returns NULL if either w = 0 or h = 0.
 </summary>
	<remarks>
	</remarks>
	<param name="x"></param>
	<param name="y"></param>
	<param name="w"></param>
	<param name="h"></param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxCopy(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<returns>copy of box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxClone(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<returns>ptr to same box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the box.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pbox">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp.Natives.boxGetGeometry(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="px">each can be null</param>
	<param name="py">each can be null</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxSetGeometry(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="x">use -1 to leave unchanged</param>
	<param name="y">use -1 to leave unchanged</param>
	<param name="w">use -1 to leave unchanged</param>
	<param name="h">use -1 to leave unchanged</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxGetSideLocations(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) All returned values are within the box.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="pl">each can be null</param>
	<param name="pr">each can be null</param>
	<param name="pt">each can be null</param>
	<param name="pb">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxSetSideLocations(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="l">use -1 to leave unchanged</param>
	<param name="r">use -1 to leave unchanged</param>
	<param name="t">use -1 to leave unchanged</param>
	<param name="b">use -1 to leave unchanged</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxGetRefcount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box">ptr to Box</param>
	<returns>refcount</returns>
</member><member name="M:LeptonicaSharp.Natives.boxChangeRefcount(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box">ptr to box</param>
	<param name="delta">adjustment, usually -1 or 1</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxIsValid(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="pvalid">1 if valid; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">initial number of ptrs</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaCopy(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) See pix.h for description of the copyflag.
 (2) The copy-clone makes a new boxa that holds clones of each box.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="copyflag">L_COPY, L_CLONE, L_COPY_CLONE</param>
	<returns>new boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the boxa.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pboxa">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp.Natives.boxaAddBox(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="box">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaExtendArray(System.IntPtr)">
	<summary>
 Notes
 (1) Reallocs with doubled size of ptr array.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaExtendArrayToSize(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If necessary, reallocs new boxa ptr array to %size.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="size">new size of boxa array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<returns>count of all boxes; 0 if no boxes or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetValidCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<returns>count of valid boxes; 0 if no valid boxes or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetBox(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">to the index-th box</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetValidBox(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This returns NULL for an invalid box in a boxa.
 For a box to be valid, both the width and height must be GT 0.
 (2) We allow invalid boxes, with w = 0 or h = 0, as placeholders
 in boxa for which the index of the box in the boxa is important.
 This is an atypical situation; usually you want to put only
 valid boxes in a boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">to the index-th box</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>box, or NULL if box is not valid or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaFindInvalidBoxes(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<returns>na   numa of invalid boxes; NULL if there are none or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetBoxGeometry(System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">to the index-th box</param>
	<param name="px">each can be null</param>
	<param name="py">each can be null</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaIsFull(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pfull">1 if boxa is full</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaReplaceBox(System.IntPtr,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) In-place replacement of one box.
 (2) The previous box at that location, if any, is destroyed.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">to the index-th box</param>
	<param name="box">insert to replace existing one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaInsertBox(System.IntPtr,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) This shifts box[i] --GT box[i + 1] for all i GT= index,
 and then inserts box as box[index].
 (2) To insert at the beginning of the array, set index = 0.
 (3) To append to the array, it's easier to use boxaAddBox().
 (4) This should not be used repeatedly to insert into large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">location in boxa to insert new value</param>
	<param name="box">new box to be inserted</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaRemoveBox(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This removes box[index] and then shifts
 box[i] --GT box[i - 1] for all i GT index.
 (2) It should not be used repeatedly to remove boxes from
 large arrays, because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">of box to be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaRemoveBoxAndSave(System.IntPtr,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) This removes box[index] and then shifts
 box[i] --GT box[i - 1] for all i GT index.
 (2) It should not be used repeatedly to remove boxes from
 large arrays, because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">of box to be removed</param>
	<param name="pbox">removed box</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSaveValid(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This makes a copy/clone of each valid box.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="copyflag">L_COPY or L_CLONE</param>
	<returns>boxad if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaInitFull(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This initializes a boxa by filling up the entire box ptr array
 with copies of %box.  If %box == NULL, use a placeholder box
 of zero size.  Any existing boxes are destroyed.
 After this opepration, the number of boxes is equal to
 the number of allocated ptrs.
 (2) Note that we use boxaReplaceBox() instead of boxaInsertBox().
 They both have the same effect when inserting into a NULL ptr
 in the boxa ptr array
 (3) Example usage.  This function is useful to prepare for a
 random insertion (or replacement) of boxes into a boxa.
 To randomly insert boxes into a boxa, up to some index "max"
 Boxa boxa = boxaCreate(max);
 boxaInitFull(boxa, NULL);
 If you want placeholder boxes of non-zero size
 Boxa boxa = boxaCreate(max);
 Box box = boxCreate(...);
 boxaInitFull(boxa, box);
 boxDestroy(box);
 If we have an existing boxa with a smaller ptr array, it can
 be reused for up to max boxes
 boxaExtendArrayToSize(boxa, max);
 boxaInitFull(boxa, NULL);
 The initialization allows the boxa to always be properly
 filled, even if all the boxes are not later replaced.
 If you want to know which boxes have been replaced,
 and you initialized with invalid zero-sized boxes,
 use boxaGetValidBox() to return NULL for the invalid boxes.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">typically empty</param>
	<param name="box">to be replicated into the entire ptr array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaClear(System.IntPtr)">
	<summary>
 Notes
 (1) This destroys all boxes in the boxa, setting the ptrs
 to null.  The number of allocated boxes, n, is set to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of boxa ptr array to be alloc'd; 0 for default</param>
	<returns>baa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaCopy(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) L_COPY makes a copy of each boxa in baas.
 L_CLONE makes a clone of each boxa in baas.
 </summary>
	<remarks>
	</remarks>
	<param name="baas">input boxaa to be copied</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>baad new boxaa, composed of copies or clones of the boxa in baas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pbaa">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp.Natives.boxaaAddBoxa(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="ba">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaExtendArray(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaExtendArrayToSize(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If necessary, reallocs the boxa ptr array to %size.
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="size">new size of boxa array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<returns>count number of boxa, or 0 if no boxa or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaGetBoxCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<returns>count number of boxes, or 0 if no boxes or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaGetBoxa(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="index">to the index-th boxa</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaGetBox(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="iboxa">index into the boxa array in the boxaa</param>
	<param name="ibox">index into the box array in the boxa</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaInitFull(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This initializes a boxaa by filling up the entire boxa ptr array
 with copies of %boxa.  Any existing boxa are destroyed.
 After this operation, the number of boxa is equal to
 the number of allocated ptrs.
 (2) Note that we use boxaaReplaceBox() instead of boxaInsertBox().
 They both have the same effect when inserting into a NULL ptr
 in the boxa ptr array
 (3) Example usage.  This function is useful to prepare for a
 random insertion (or replacement) of boxa into a boxaa.
 To randomly insert boxa into a boxaa, up to some index "max"
 Boxaa baa = boxaaCreate(max);
 // initialize the boxa
 Boxa boxa = boxaCreate(...);
 ...  [optionally fix with boxes]
 boxaaInitFull(baa, boxa);
 A typical use is to initialize the array with empty boxa,
 and to replace only a subset that must be aligned with
 something else, such as a pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="baa">typically empty</param>
	<param name="boxa">to be replicated into the entire ptr array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaExtendWithInit(System.IntPtr,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) This should be used on an existing boxaa that has been
 fully loaded with boxa.  It then extends the boxaa,
 loading all the additional ptrs with copies of boxa.
 Typically, boxa will be empty.
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="maxindex"></param>
	<param name="boxa">to be replicated into the extended ptr array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaReplaceBoxa(System.IntPtr,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) Any existing boxa is destroyed, and the input one
 is inserted in its place.
 (2) If the index is invalid, return 1 (error)
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="index">to the index-th boxa</param>
	<param name="boxa">insert and replace any existing one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaInsertBoxa(System.IntPtr,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) This shifts boxa[i] --GT boxa[i + 1] for all i GT= index,
 and then inserts boxa as boxa[index].
 (2) To insert at the beginning of the array, set index = 0.
 (3) To append to the array, it's easier to use boxaaAddBoxa().
 (4) This should not be used repeatedly to insert into large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="index">location in boxaa to insert new boxa</param>
	<param name="boxa">new boxa to be inserted</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaRemoveBoxa(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This removes boxa[index] and then shifts
 boxa[i] --GT boxa[i - 1] for all i GT index.
 (2) The removed boxaa is destroyed.
 (2) This should not be used repeatedly on large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="index">of the boxa to be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaAddBox(System.IntPtr,System.Int32,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Adds to an existing boxa only.
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="index">of boxa with boxaa</param>
	<param name="box">to be added</param>
	<param name="accessflag">L_INSERT, L_COPY or L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaReadFromFiles(System.String,System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The files must be serialized boxa files (e.g., .ba).
 If some files cannot be read, warnings are issued.
 (2) Use %substr to filter filenames in the directory.  If
 %substr == NULL, this takes all files.
 (3) After filtering, use %first and %nfiles to select
 a contiguous set of files, that have been lexically
 sorted in increasing order.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="first">0-based</param>
	<param name="nfiles">use 0 for everything from %first to the end</param>
	<returns>baa, or NULL on error or if no boxa files are found.</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>boxaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>boxaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization of boxaa; in ascii</param>
	<param name="size">of data in bytes; can use strlen to get it</param>
	<returns>baa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="baa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="baa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a boxaa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized boxaa; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="baa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization of boxa; in ascii</param>
	<param name="size">of data in bytes; can use strlen to get it</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaWriteDebug(System.String,System.IntPtr)">
	<summary>
 Notes
 (1) Debug version, intended for use in the library when writing
 to files in a temp directory with names that are compiled in.
 This is used instead of boxaWrite() for all such library calls.
 (2) The global variable LeptDebugOK defaults to 0, and can be set
 or cleared by the function setLeptDebugOK().
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="boxa"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="boxa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="boxa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a boxa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized boxa; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="boxa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxPrintStreamInfo(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This outputs debug info.  Use serialization functions to
 write to file if you want to read the data back.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="box"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxContains(System.IntPtr,System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box1"></param>
	<param name="box2"></param>
	<param name="presult">1 if box2 is entirely contained within box1, and 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxIntersects(System.IntPtr,System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box1"></param>
	<param name="box2"></param>
	<param name="presult">1 if any part of box2 is contained in box1, and 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaContainedInBox(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) All boxes in boxa that are entirely outside box are removed.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="box">for containment</param>
	<returns>boxad boxa with all boxes in boxas that are entirely contained in box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaContainedInBoxCount(System.IntPtr,System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="box">for selecting contained boxes in %boxa</param>
	<param name="pcount">number of boxes intersecting the box</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaContainedInBoxa(System.IntPtr,System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa1"></param>
	<param name="boxa2"></param>
	<param name="pcontained">1 if every box in boxa2 is contained in some box in boxa1; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaIntersectsBox(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) All boxes in boxa that intersect with box (i.e., are completely
 or partially contained in box) are retained.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="box">for intersecting</param>
	<returns>boxad boxa with all boxes in boxas that intersect box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaIntersectsBoxCount(System.IntPtr,System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="box">for selecting intersecting boxes in %boxa</param>
	<param name="pcount">number of boxes intersecting the box</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaClipToBox(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) All boxes in boxa not intersecting with box are removed, and
 the remaining boxes are clipped to box.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="box">for clipping</param>
	<returns>boxad boxa with boxes in boxas clipped to box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaCombineOverlaps(System.IntPtr,System.IntPtr@)">
	<summary>
 Notes
 (1) If there are no overlapping boxes, it simply returns a copy
 of %boxas.
 (2) Input an empty %pixadb, using pixaCreate(0), for debug output.
 The output gives 2 visualizations of the boxes per iteration;
 boxes in red before, and added boxes in green after. Note that
 all pixels in the red boxes are contained in the green ones.
 (3) The alternative method of painting each rectangle and finding
 the 4-connected components gives a different result in
 general, because two non-overlapping (but touching)
 rectangles, when rendered, are 4-connected and will be joined.
 (4) A bad case computationally is to have n boxes, none of which
 overlap.  Then you have one iteration with O(n^2) compares.
 This is still faster than painting each rectangle and finding
 the bounding boxes of the connected components, even for
 thousands of rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="pixadb">debug output</param>
	<returns>boxad where each set of boxes in boxas that overlap are combined into a single bounding box in boxad, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaCombineOverlapsInPair(System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) One of three things happens to each box in %boxa1 and %boxa2
 it gets absorbed into a larger box that it overlaps with
 it absorbs a smaller (by area) box that it overlaps with
 and gets larger, using the bounding region of the 2 boxes
 it is unchanged (including absorbing smaller boxes that
 are contained within it).
 (2) If all the boxes from one of the input boxa are absorbed, this
 returns an empty boxa.
 (3) Input an empty %pixadb, using pixaCreate(0), for debug output
 (4) This is useful if different operations are to be carried out
 on possibly overlapping rectangular regions, and it is desired
 to have only one operation on any rectangular region.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas1">input boxa1</param>
	<param name="boxas2">input boxa2</param>
	<param name="pboxad1">output boxa1</param>
	<param name="pboxad2">output boxa2</param>
	<param name="pixadb">debug output</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxOverlapRegion(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This is the geometric intersection of the two rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="box1">two boxes</param>
	<param name="box2">two boxes</param>
	<returns>box of overlap region between input boxes, or NULL if no overlap or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxBoundingRegion(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This is the geometric union of the two rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="box1">two boxes</param>
	<param name="box2">two boxes</param>
	<returns>box of bounding region containing the input boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxOverlapFraction(System.IntPtr,System.IntPtr,System.Single[]@)">
	<summary>
 Notes
 (1) The result depends on the order of the input boxes,
 because the overlap is taken as a fraction of box2.
 </summary>
	<remarks>
	</remarks>
	<param name="box1">two boxes</param>
	<param name="box2">two boxes</param>
	<param name="pfract">the fraction of box2 overlapped by box1</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.boxOverlapArea(System.IntPtr,System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box1">two boxes</param>
	<param name="box2">two boxes</param>
	<param name="parea">the number of pixels in the overlap</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaHandleOverlaps(System.IntPtr,System.Int32,System.Int32,System.Single,System.Single,System.IntPtr@)">
	<summary>
 Notes
 (1) For all n(n-1)/2 box pairings, if two boxes overlap, either
 (a) op == L_COMBINE get the bounding region for the two,
 replace the larger with the bounding region, and remove
 the smaller of the two, or
 (b) op == L_REMOVE_SMALL just remove the smaller.
 (2) If boxas is 2D sorted, range can be small, but if it is
 not spatially sorted, range should be large to allow all
 pairwise comparisons to be made.
 (3) The %min_overlap parameter allows ignoring small overlaps.
 If %min_overlap == 1.0, only boxes fully contained in larger
 boxes can be considered for removal; if %min_overlap == 0.0,
 this constraint is ignored.
 (4) The %max_ratio parameter allows ignoring overlaps between
 boxes that are not too different in size.  If %max_ratio == 0.0,
 no boxes can be removed; if %max_ratio == 1.0, this constraint
 is ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="op">L_COMBINE, L_REMOVE_SMALL</param>
	<param name="range">GT 0, forward distance over which overlaps are checked</param>
	<param name="min_overlap">minimum fraction of smaller box required for overlap to count; 0.0 to ignore</param>
	<param name="max_ratio">maximum fraction of small/large areas for overlap to count; 1.0 to ignore</param>
	<param name="pnamap">combining map</param>
	<returns>boxad, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.boxSeparationDistance(System.IntPtr,System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This measures horizontal and vertical separation of the
 two boxes.  If the boxes are touching but have no pixels
 in common, the separation is 0.  If the boxes overlap by
 a distance d, the returned separation is -d.
 </summary>
	<remarks>
	</remarks>
	<param name="box1">two boxes, in any order</param>
	<param name="box2">two boxes, in any order</param>
	<param name="ph_sep">horizontal separation</param>
	<param name="pv_sep">vertical separation</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxCompareSize(System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) We're re-using the SORT enum for these comparisons.
 </summary>
	<remarks>
	</remarks>
	<param name="box1"></param>
	<param name="box2"></param>
	<param name="type">L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER, L_SORT_BY_AREA,</param>
	<param name="prel">1 if box1 GT box2, 0 if the same, -1 if box1 LT box2</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxContainsPt(System.IntPtr,System.Single,System.Single,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="x">a point</param>
	<param name="y">a point</param>
	<param name="pcontains">1 if box contains point; 0 otherwise</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetNearestToPt(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Uses euclidean distance between centroid and point.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="x">point</param>
	<param name="y">point</param>
	<returns>box with centroid closest to the given point [x,y], or NULL if no boxes in boxa</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetNearestToLine(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For a horizontal line at some value y, get the minimum of the
 distance |yc - y| from the box centroid yc value to y;
 likewise minimize |xc - x| for a vertical line at x.
 (2) Input y LT 0, x GT= 0 to indicate a vertical line at x, and
 x LT 0, y GT= 0 for a horizontal line at y.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="x">(y = -1 for vertical line; x = -1 for horiz line)</param>
	<param name="y">(y = -1 for vertical line; x = -1 for horiz line)</param>
	<returns>box with centroid closest to the given line, or NULL if no boxes in boxa</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaFindNearestBoxes(System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) See boxaGetNearestByDirection() for usage of %dist_select
 and %range.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">either unsorted, or 2D sorted in LR/TB scan order</param>
	<param name="dist_select">L_NON_NEGATIVE, L_ALL</param>
	<param name="range">search distance from box i; use 0 to search entire boxa (e.g., if it's not 2D sorted)</param>
	<param name="pnaaindex">for each box in %boxa, contains a numa of 4 box indices (per direction) of the nearest box</param>
	<param name="pnaadist">for each box in %boxa, this contains a numa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetNearestByDirection(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) For efficiency, use a LR/TD sorted %boxa, which can be
 made by flattening a 2D sorted boxaa.  In that case,
 %range can be some positive integer like 50.
 (2) If boxes overlap, the distance will be LT 0.  Use %dist_select
 to determine if these should count or not.  If L_ALL, then
 one box will match as the nearest to another in 2 or more
 directions.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">either unsorted, or 2D sorted in LR/TB scan order</param>
	<param name="i">box we test against</param>
	<param name="dir">direction to look L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
	<param name="dist_select">L_NON_NEGATIVE, L_ALL</param>
	<param name="range">search distance from box i; use 0 to search entire boxa (e.g., if it's not 2D sorted)</param>
	<param name="pindex">index in boxa of nearest box with overlapping coordinates in the indicated direction; -1 if there is no box</param>
	<param name="pdist">distance of the nearest box in the indicated direction; 100000 if no box</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxGetCenter(System.IntPtr,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="pcx">location of center of box</param>
	<param name="pcy">location of center of box</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxIntersectByLine(System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If the intersection is at only one point (a corner), the
 coordinates are returned in (x1, y1).
 (2) Represent a vertical line by one with a large but finite slope.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="x">point that line goes through</param>
	<param name="y">point that line goes through</param>
	<param name="slope">of line</param>
	<param name="px1">1st point of intersection with box</param>
	<param name="py1">1st point of intersection with box</param>
	<param name="px2">2nd point of intersection with box</param>
	<param name="py2">2nd point of intersection with box</param>
	<param name="pn">number of points of intersection</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxClipToRectangle(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This can be used to clip a rectangle to an image.
 The clipping rectangle is assumed to have a UL corner at (0, 0),
 and a LR corner at (wi - 1, hi - 1).
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="wi">rectangle representing image</param>
	<param name="hi">rectangle representing image</param>
	<returns>part of box within given rectangle, or NULL on error or if box is entirely outside the rectangle</returns>
</member><member name="M:LeptonicaSharp.Natives.boxClipToRectangleParams(System.IntPtr,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The return value should be checked.  If it is 1, the
 returned parameter values are bogus.
 (2) This simplifies the selection of pixel locations within
 a given rectangle
 for (i = ystart; i LT yend; i++ {
 ...
 for (j = xstart; j LT xend; j++ {
 ....
 </summary>
	<remarks>
	</remarks>
	<param name="box">requested box; can be null</param>
	<param name="w">clipping box size; typ. the size of an image</param>
	<param name="h">clipping box size; typ. the size of an image</param>
	<param name="pxstart">start x coordinate</param>
	<param name="pystart">start y coordinate</param>
	<param name="pxend">one pixel beyond clipping box</param>
	<param name="pyend">one pixel beyond clipping box</param>
	<param name="pbw">clipped width</param>
	<param name="pbh">clipped height</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxRelocateOneSide(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Set boxd == NULL to get new box; boxd == boxs for in-place;
 or otherwise to resize existing boxd.
 (2) For usage, suggest one of these
 boxd = boxRelocateOneSide(NULL, boxs, ...);   // new
 boxRelocateOneSide(boxs, boxs, ...); // in-place
 boxRelocateOneSide(boxd, boxs, ...); // other
 </summary>
	<remarks>
	</remarks>
	<param name="boxd">; this can be null, equal to boxs, or different from boxs;</param>
	<param name="boxs">starting box; to have one side relocated</param>
	<param name="loc">new location of the side that is changing</param>
	<param name="sideflag">L_FROM_LEFT, etc., indicating the side that moves</param>
	<returns>boxd, or NULL on error or if the computed boxd has width or height LT= 0.</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaAdjustSides(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) New box dimensions are cropped at left and top to x GT= 0 and y GT= 0.
 (2) If the width or height of a box goes to 0, we generate a box with
 w == 1 and h == 1, as a placeholder.
 (3) See boxAdjustSides().
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="delleft">changes in location of each side for each box</param>
	<param name="delright">changes in location of each side for each box</param>
	<param name="deltop">changes in location of each side for each box</param>
	<param name="delbot">changes in location of each side for each box</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxAdjustSides(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Set boxd == NULL to get new box; boxd == boxs for in-place;
 or otherwise to resize existing boxd.
 (2) For usage, suggest one of these
 boxd = boxAdjustSides(NULL, boxs, ...);   // new
 boxAdjustSides(boxs, boxs, ...); // in-place
 boxAdjustSides(boxd, boxs, ...); // other
 (3) New box dimensions are cropped at left and top to x GT= 0 and y GT= 0.
 (4) For example, to expand in-place by 20 pixels on each side, use
 boxAdjustSides(box, box, -20, 20, -20, 20);
 </summary>
	<remarks>
	</remarks>
	<param name="boxd">; this can be null, equal to boxs, or different from boxs</param>
	<param name="boxs">starting box; to have sides adjusted</param>
	<param name="delleft">changes in location of each side</param>
	<param name="delright">changes in location of each side</param>
	<param name="deltop">changes in location of each side</param>
	<param name="delbot">changes in location of each side</param>
	<returns>boxd, or NULL on error or if the computed boxd has width or height LT= 0.</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSetSide(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sets the given side of each box.  Use boxad == NULL for a new
 boxa, and boxad == boxas for in-place.
 (2) Use one of these
 boxad = boxaSetSide(NULL, boxas, ...);   // new
 boxaSetSide(boxas, boxas, ...);  // in-place
 </summary>
	<remarks>
	</remarks>
	<param name="boxad">use NULL to get a new one; same as boxas for in-place</param>
	<param name="boxas"></param>
	<param name="side">L_SET_LEFT, L_SET_RIGHT, L_SET_TOP, L_SET_BOT</param>
	<param name="val">location to set for given side, for each box</param>
	<param name="thresh">min abs difference to cause resetting to %val</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaAdjustWidthToTarget(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Conditionally adjusts the width of each box, by moving
 the indicated edges (left and/or right) if the width differs
 by %thresh or more from %target.
 (2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.
 Use one of these
 boxad = boxaAdjustWidthToTarget(NULL, boxas, ...);   // new
 boxaAdjustWidthToTarget(boxas, boxas, ...);  // in-place
 </summary>
	<remarks>
	</remarks>
	<param name="boxad">use NULL to get a new one; same as boxas for in-place</param>
	<param name="boxas"></param>
	<param name="sides">L_ADJUST_LEFT, L_ADJUST_RIGHT, L_ADJUST_LEFT_AND_RIGHT</param>
	<param name="target">target width if differs by more than thresh</param>
	<param name="thresh">min abs difference in width to cause adjustment</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaAdjustHeightToTarget(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Conditionally adjusts the height of each box, by moving
 the indicated edges (top and/or bot) if the height differs
 by %thresh or more from %target.
 (2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.
 Use one of these
 boxad = boxaAdjustHeightToTarget(NULL, boxas, ...);   // new
 boxaAdjustHeightToTarget(boxas, boxas, ...);  // in-place
 </summary>
	<remarks>
	</remarks>
	<param name="boxad">use NULL to get a new one</param>
	<param name="boxas"></param>
	<param name="sides">L_ADJUST_TOP, L_ADJUST_BOT, L_ADJUST_TOP_AND_BOT</param>
	<param name="target">target height if differs by more than thresh</param>
	<param name="thresh">min abs difference in height to cause adjustment</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxEqual(System.IntPtr,System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box1"></param>
	<param name="box2"></param>
	<param name="psame">1 if equal; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaEqual(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr@,System.Int32@)">
	<summary>
 Notes
 (1) The two boxa are the "same" if they contain the same
 boxes and each box is within %maxdist of its counterpart
 in their positions within the boxa.  This allows for
 small rearrangements.  Use 0 for maxdist if the boxa
 must be identical.
 (2) This applies only to geometry and ordering; refcounts
 are not considered.
 (3) %maxdist allows some latitude in the ordering of the boxes.
 For the boxa to be the "same", corresponding boxes must
 be within %maxdist of each other.  Note that for large
 %maxdist, we should use a hash function for efficiency.
 (4) naindex[i] gives the position of the box in boxa2 that
 corresponds to box i in boxa1.  It is only returned if the
 boxa are equal.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa1"></param>
	<param name="boxa2"></param>
	<param name="maxdist"></param>
	<param name="pnaindex">index array of correspondences</param>
	<param name="psame">(1 if equal; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxSimilar(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The values of leftdiff (etc) are the maximum allowed deviations
 between the locations of the left (etc) sides.  If any side
 pairs differ by more than this amount, the boxes are not similar.
 </summary>
	<remarks>
	</remarks>
	<param name="box1"></param>
	<param name="box2"></param>
	<param name="leftdiff"></param>
	<param name="rightdiff"></param>
	<param name="topdiff"></param>
	<param name="botdiff"></param>
	<param name="psimilar">1 if similar; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSimilar(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.IntPtr@)">
	<summary>
 Notes
 (1) See boxSimilar() for parameter usage.
 (2) Corresponding boxes are taken in order in the two boxa.
 (3) %nasim is an indicator array with a (0/1) for each box pair.
 (4) With %nasim or debug == 1, boxes continue to be tested
 after failure.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa1"></param>
	<param name="boxa2"></param>
	<param name="leftdiff"></param>
	<param name="rightdiff"></param>
	<param name="topdiff"></param>
	<param name="botdiff"></param>
	<param name="debug">output details of non-similar boxes</param>
	<param name="psimilar">1 if similar; 0 otherwise</param>
	<param name="pnasim">na containing 1 if similar; else 0</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaJoin(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This appends a clone of each indicated box in boxas to boxad
 (2) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (3) iend LT 0 means 'read to the end'
 (4) if boxas == NULL or has no boxes, this is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="boxad">dest boxa; add to this one</param>
	<param name="boxas">source boxa; add from this one</param>
	<param name="istart">starting index in boxas</param>
	<param name="iend">ending index in boxas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaJoin(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This appends a clone of each indicated boxa in baas to baad
 (2) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (3) iend LT 0 means 'read to the end'
 (4) if baas == NULL, this is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="baad">dest boxaa; add to this one</param>
	<param name="baas">source boxaa; add from this one</param>
	<param name="istart">starting index in baas</param>
	<param name="iend">ending index in baas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSplitEvenOdd(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) If %fillflag == 1, boxae has copies of the even boxes
 in their original location, and nvalid boxes are placed
 in the odd array locations.  And v.v.
 (2) If %fillflag == 0, boxae has only copies of the even boxes.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="fillflag">1 to put invalid boxes in place; 0 to omit</param>
	<param name="pboxae">save even and odd boxes in their separate boxa, setting the other type to invalid boxes.</param>
	<param name="pboxao">save even and odd boxes in their separate boxa, setting the other type to invalid boxes.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaMergeEvenOdd(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is essentially the inverse of boxaSplitEvenOdd().
 Typically, boxae and boxao were generated by boxaSplitEvenOdd(),
 and the value of %fillflag needs to be the same in both calls.
 (2) If %fillflag == 1, both boxae and boxao are of the same size;
 otherwise boxae may have one more box than boxao.
 </summary>
	<remarks>
	</remarks>
	<param name="boxae">boxes to go in even positions in merged boxa</param>
	<param name="boxao">boxes to go in odd positions in merged boxa</param>
	<param name="fillflag">1 if there are invalid boxes in placeholders</param>
	<returns>boxad merged, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaTransform(System.IntPtr,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) This is a very simple function that first shifts, then scales.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="shiftx"></param>
	<param name="shifty"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxTransform(System.IntPtr,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) This is a very simple function that first shifts, then scales.
 (2) If the box is invalid, a new invalid box is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="shiftx"></param>
	<param name="shifty"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<returns>boxd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaTransformOrdered(System.IntPtr,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This allows a sequence of linear transforms on each box.
 the transforms are from the affine set, composed of
 shift, scaling and rotation, and the order of the
 transforms is specified.
 (2) Although these operations appear to be on an infinite
 2D plane, in practice the region of interest is clipped
 to a finite image.  The center of rotation is usually taken
 with respect to the image (either the UL corner or the
 center).  A translation can have two very different effects
 (a) Moves the boxes across the fixed image region.
 (b) Moves the image origin, causing a change in the image
 region and an opposite effective translation of the boxes.
 This function should only be used for (a), where the image
 region is fixed on translation.  If the image region is
 changed by the translation, use instead the functions
 in affinecompose.c, where the image region and rotation
 center can be computed from the actual clipping due to
 translation of the image origin.
 (3) See boxTransformOrdered() for usage and implementation details.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="shiftx"></param>
	<param name="shifty"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<param name="xcen">center of rotation</param>
	<param name="ycen">center of rotation</param>
	<param name="angle">in radians; clockwise is positive</param>
	<param name="order">one of 6 combinations L_TR_SC_RO, ...</param>
	<returns>boxd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxTransformOrdered(System.IntPtr,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This allows a sequence of linear transforms, composed of
 shift, scaling and rotation, where the order of the
 transforms is specified.
 (2) The rotation is taken about a point specified by (xcen, ycen).
 Let the components of the vector from the center of rotation
 to the box center be (xdif, ydif)
 xdif = (bx + 0.5  bw) - xcen
 ydif = (by + 0.5  bh) - ycen
 Then the box center after rotation has new components
 bxcen = xcen + xdif  cosa + ydif  sina
 bycen = ycen + ydif  cosa - xdif  sina
 where cosa and sina are the cos and sin of the angle,
 and the enclosing box for the rotated box has size
 rw = |bw  cosa| + |bh  sina|
 rh = |bh  cosa| + |bw  sina|
 where bw and bh are the unrotated width and height.
 Then the box UL corner (rx, ry) is
 rx = bxcen - 0.5  rw
 ry = bycen - 0.5  rh
 (3) The center of rotation specified by args %xcen and %ycen
 is the point BEFORE any translation or scaling.  If the
 rotation is not the first operation, this function finds
 the actual center at the time of rotation.  It does this
 by making the following assumptions
 (1) Any scaling is with respect to the UL corner, so
 that the center location scales accordingly.
 (2) A translation does not affect the center of
 the image; it just moves the boxes.
 We always use assumption (1).  However, assumption (2)
 will be incorrect if the apparent translation is due
 to a clipping operation that, in effect, moves the
 origin of the image.  In that case, you should NOT use
 these simple functions.  Instead, use the functions
 in affinecompose.c, where the rotation center can be
 computed from the actual clipping due to translation
 of the image origin.
 </summary>
	<remarks>
	</remarks>
	<param name="boxs"></param>
	<param name="shiftx"></param>
	<param name="shifty"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<param name="xcen">center of rotation</param>
	<param name="ycen">center of rotation</param>
	<param name="angle">in radians; clockwise is positive</param>
	<param name="order">one of 6 combinations L_TR_SC_RO, ...</param>
	<returns>boxd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaRotateOrth(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See boxRotateOrth() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="w">of image in which the boxa is embedded</param>
	<param name="h">of image in which the boxa is embedded</param>
	<param name="rotation">0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg; all rotations are clockwise</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxRotateOrth(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Rotate the image with the embedded box by the specified amount.
 (2) After rotation, the rotated box is always measured with
 respect to the UL corner of the image.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="w">of image in which the box is embedded</param>
	<param name="h">of image in which the box is embedded</param>
	<param name="rotation">0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg; all rotations are clockwise</param>
	<returns>boxd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSort(System.IntPtr,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) An empty boxa returns a copy, with a warning.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_RIGHT, L_SORT_BY_BOT, L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER, L_SORT_BY_AREA, L_SORT_BY_ASPECT_RATIO</param>
	<param name="sortorder">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<param name="pnaindex">index of sorted order into original array</param>
	<returns>boxad sorted version of boxas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaBinSort(System.IntPtr,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) For a large number of boxes (say, greater than 1000), this
 O(n) binsort is much faster than the O(nlogn) shellsort.
 For 5000 components, this is over 20x faster than boxaSort().
 (2) Consequently, boxaSort() calls this function if it will
 likely go much faster.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_PERIMETER</param>
	<param name="sortorder">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<param name="pnaindex">index of sorted order into original array</param>
	<returns>boxad sorted version of boxas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSortByIndex(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="naindex">na that maps from the new boxa to the input boxa</param>
	<returns>boxad sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSort2d(System.IntPtr,System.IntPtr@,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The final result is a sort where the 'fast scan' direction is
 left to right, and the 'slow scan' direction is from top
 to bottom.  Each boxa in the baa represents a sorted set
 of boxes from left to right.
 (2) Three passes are used to aggregate the boxas, which can correspond
 to characters or words in a line of text.  In pass 1, only
 taller components, which correspond to xheight or larger,
 are permitted to start a new boxa.  In pass 2, the remaining
 vertically-challenged components are allowed to join an
 existing boxa or start a new one.  In pass 3, boxa whose extent
 is overlapping are joined.  After that, the boxes in each
 boxa are sorted horizontally, and finally the boxa are
 sorted vertically.
 (3) If delta1 LT 0, the first pass allows aggregation when
 boxes in the same boxa do not overlap vertically.
 The distance by which they can miss and still be aggregated
 is the absolute value |delta1|.   Similar for delta2 on
 the second pass.
 (4) On the first pass, any component of height less than minh1
 cannot start a new boxa; it's put aside for later insertion.
 (5) On the second pass, any small component that doesn't align
 with an existing boxa can start a new one.
 (6) This can be used to identify lines of text from
 character or word bounding boxes.
 (7) Typical values for the input parameters on 300 ppi text are
 delta1 ~ 0
 delta2 ~ 0
 minh1 ~ 5
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="pnaad">numaa with sorted indices whose values are the indices of the input array</param>
	<param name="delta1">min overlap that permits aggregation of a box onto a boxa of horizontally-aligned boxes; pass 1</param>
	<param name="delta2">min overlap that permits aggregation of a box onto a boxa of horizontally-aligned boxes; pass 2</param>
	<param name="minh1">components less than this height either join an existing boxa or are set aside for pass 2</param>
	<returns>baa 2d sorted version of boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSort2dByIndex(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="naa">numaa that maps from the new baa to the input boxa</param>
	<returns>baa sorted boxaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaExtractAsNuma(System.IntPtr,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) If you are counting or sorting values, such as determining
 rank order, you must remove invalid boxes.
 (2) If you are parametrizing the values, or doing an evaluation
 where the position in the boxa sequence is important, you
 must replace the invalid boxes with valid ones before
 doing the extraction. This is easily done with boxaFillSequence().
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pnal">array of left locations</param>
	<param name="pnat">array of top locations</param>
	<param name="pnar">array of right locations</param>
	<param name="pnab">array of bottom locations</param>
	<param name="pnaw">array of widths</param>
	<param name="pnah">array of heights</param>
	<param name="keepinvalid">1 to keep invalid boxes; 0 to remove them</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaExtractAsPta(System.IntPtr,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) For most applications, such as counting, sorting, fitting
 to some parametrized form, plotting or filtering in general,
 you should remove the invalid boxes.  Each pta saves the
 box index in the x array, so replacing invalid boxes by
 filling with boxaFillSequence(), which is required for
 boxaExtractAsNuma(), is not necessary.
 (2) If invalid boxes are retained, each one will result in
 entries (typically 0) in all selected output pta.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pptal">array of left locations vs. index</param>
	<param name="pptat">array of top locations vs. index</param>
	<param name="pptar">array of right locations vs. index</param>
	<param name="pptab">array of bottom locations vs. index</param>
	<param name="pptaw">array of widths vs. index</param>
	<param name="pptah">array of heights vs. index</param>
	<param name="keepinvalid">1 to keep invalid boxes; 0 to remove them</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetRankVals(System.IntPtr,System.Single,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This function does not assume that all boxes in the boxa are valid
 (2) The four box parameters are sorted independently.
 For rank order, the width and height are sorted in increasing
 order.  But what does it mean to sort x and y in "rank order"?
 If the boxes are of comparable size and somewhat
 aligned (e.g., from multiple images), it makes some sense
 to give a "rank order" for x and y by sorting them in
 decreasing order.  But in general, the interpretation of a rank
 order on x and y is highly application dependent.  In summary
 ~ x and y are sorted in decreasing order
 ~ w and h are sorted in increasing order
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="fract">use 0.0 for smallest, 1.0 for largest width and height</param>
	<param name="px">rank value of x</param>
	<param name="py">rank value of y</param>
	<param name="pw">rank value of width</param>
	<param name="ph">rank value of height</param>
	<returns>0 if OK, 1 on error or if the boxa is empty or has no valid boxes</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetMedianVals(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) See boxaGetRankVals()
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="px">median value of x</param>
	<param name="py">median value of y</param>
	<param name="pw">median value of width</param>
	<param name="ph">median value of height</param>
	<returns>0 if OK, 1 on error or if the boxa is empty or has no valid boxes</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetAverageSize(System.IntPtr,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pw">average width</param>
	<param name="ph">average height</param>
	<returns>0 if OK, 1 on error or if the boxa is empty</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaGetExtent(System.IntPtr,System.Int32@,System.Int32@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The returned w and h are the minimum size image
 that would contain all boxes untranslated.
 (2) Each box in the returned boxa is the minimum box required to
 hold all the boxes in the respective boxa of baa.
 (3) If there are no valid boxes in a boxa, the box corresponding
 to its extent has all fields set to 0 (an invalid box).
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<param name="pbox">minimum box containing all boxa in boxaa</param>
	<param name="pboxa">boxa containing all boxes in each boxa in the boxaa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaFlattenToBoxa(System.IntPtr,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This 'flattens' the baa to a boxa, taking the boxes in
 order in the first boxa, then the second, etc.
 (2) If a boxa is empty, we generate an invalid, placeholder box
 of zero size.  This is useful when converting from a baa
 where each boxa has either 0 or 1 boxes, and it is necessary
 to maintain a 11 correspondence between the initial
 boxa array and the resulting box array.
 (3) If naindex is defined, we generate a Numa that gives, for
 each box in the baa, the index of the boxa to which it belongs.
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="pnaindex">the boxa index in the baa</param>
	<param name="copyflag">L_COPY or L_CLONE</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaFlattenAligned(System.IntPtr,System.Int32,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This 'flattens' the baa to a boxa, taking the first %num
 boxes from each boxa.
 (2) In each boxa, if there are less than %num boxes, we preserve
 the alignment between the input baa and the output boxa
 by inserting one or more fillerbox(es) or, if %fillerbox == NULL,
 one or more invalid placeholder boxes.
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="num">number extracted from each</param>
	<param name="fillerbox">that fills if necessary</param>
	<param name="copyflag">L_COPY or L_CLONE</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaEncapsulateAligned(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This puts %num boxes from the input %boxa into each of a
 set of boxa within an output baa.
 (2) This assumes that the boxes in %boxa are in sets of %num each.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="num">number put into each boxa in the baa</param>
	<param name="copyflag">L_COPY or L_CLONE</param>
	<returns>baa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaTranspose(System.IntPtr)">
	<summary>
 Notes
 (1) If you think of a boxaa as a 2D array of boxes that is accessed
 row major, then each row is represented by one of the boxa.
 This function creates a new boxaa related to the input boxaa
 as a column major traversal of the input boxaa.
 (2) For example, if %baas has 2 boxa, each with 10 boxes, then
 %baad will have 10 boxa, each with 2 boxes.
 (3) Require for this transpose operation that each boxa in
 %baas has the same number of boxes.  This operation is useful
 when the i-th boxes in each boxa are meaningfully related.
 </summary>
	<remarks>
	</remarks>
	<param name="baas"></param>
	<returns>baad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaAlignBox(System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This is not greedy.  It finds the boxa whose vertical
 extent has the closest overlap with the input box.
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="box">to be aligned with the bext boxa in the baa, if possible</param>
	<param name="delta">amount by which consecutive components can miss in overlap and still be included in the array</param>
	<param name="pindex">index of boxa with best overlap, or if none match, this is the index of the next boxa to be generated</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMaskConnComp(System.IntPtr,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) This generates a mask image with ON pixels over the
 b.b. of the c.c. in pixs.  If there are no ON pixels in pixs,
 pixd will also have no ON pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">4 or 8</param>
	<param name="pboxa">bounding boxes of c.c.</param>
	<returns>pixd 1 bpp mask over the c.c., or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMaskBoxa(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This can be used with
 pixd = NULL  (makes a new pixd)
 pixd = pixs  (in-place)
 (2) If pixd == NULL, this first makes a copy of pixs, and then
 bit-twiddles over the boxes.  Otherwise, it operates directly
 on pixs.
 (3) This simple function is typically used with 1 bpp images.
 It uses the 1-image rasterop function, rasteropUniLow(),
 to set, clear or flip the pixels in pixd.
 (4) If you want to generate a 1 bpp mask of ON pixels from the boxes
 in a Boxa, in a pix of size (w,h)
 pix = pixCreate(w, h, 1);
 pixMaskBoxa(pix, pix, boxa, L_SET_PIXELS);
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">may be NULL</param>
	<param name="pixs">any depth; not cmapped</param>
	<param name="boxa">of boxes, to paint</param>
	<param name="op">L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>pixd with masking op over the boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixPaintBoxa(System.IntPtr,System.IntPtr,System.UInt32)">
	<summary>
 Notes
 (1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp
 and the boxa is painted using a colormap; otherwise,
 it is converted to 32 bpp rgb.
 (2) There are several ways to display a box on an image
 Paint it as a solid color
 Draw the outline
 Blend the outline or region with the existing image
 We provide painting and drawing here; blending is in blend.c.
 When painting or drawing, the result can be either a
 cmapped image or an rgb image.  The dest will be cmapped
 if the src is either 1 bpp or has a cmap that is not full.
 To force RGB output, use pixConvertTo8(pixs, FALSE)
 before calling any of these paint and draw functions.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, can be cmapped</param>
	<param name="boxa">of boxes, to paint</param>
	<param name="val">rgba color to paint</param>
	<returns>pixd with painted boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetBlackOrWhiteBoxa(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, can be cmapped</param>
	<param name="boxa">of boxes, to clear or set</param>
	<param name="op">L_SET_BLACK, L_SET_WHITE</param>
	<returns>pixd with boxes filled with white or black, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixPaintBoxaRandom(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) If pixs is 1 bpp, we paint the boxa using a colormap;
 otherwise, we convert to 32 bpp.
 (2) We use up to 254 different colors for painting the regions.
 (3) If boxes overlap, the later ones paint over earlier ones.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, can be cmapped</param>
	<param name="boxa">of boxes, to paint</param>
	<returns>pixd with painted boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlendBoxaRandom(System.IntPtr,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) pixs is converted to 32 bpp.
 (2) This differs from pixPaintBoxaRandom(), in that the
 colors here are blended with the color of pixs.
 (3) We use up to 254 different colors for painting the regions.
 (4) If boxes overlap, the final color depends only on the last
 rect that is used.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; can be cmapped</param>
	<param name="boxa">of boxes, to blend/paint</param>
	<param name="fract">of box color to use</param>
	<returns>pixd 32 bpp, with blend/painted boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDrawBoxa(System.IntPtr,System.IntPtr,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp
 and the boxa is drawn using a colormap; otherwise,
 it is converted to 32 bpp rgb.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; can be cmapped</param>
	<param name="boxa">of boxes, to draw</param>
	<param name="width">of lines</param>
	<param name="val">rgba color to draw</param>
	<returns>pixd with outlines of boxes added, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDrawBoxaRandom(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If pixs is 1 bpp, we draw the boxa using a colormap;
 otherwise, we convert to 32 bpp.
 (2) We use up to 254 different colors for drawing the boxes.
 (3) If boxes overlap, the later ones draw over earlier ones.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, can be cmapped</param>
	<param name="boxa">of boxes, to draw</param>
	<param name="width">thickness of line</param>
	<returns>pixd with box outlines drawn, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaDisplay(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.UInt32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If %pixs exists, this renders the boxes over an 8 bpp version
 of it.  Otherwise, it renders the boxes over an empty image
 with a white background.
 (2) If %pixs exists, the dimensions of %pixd are the same,
 and input values of %w and %h are ignored.
 If %pixs is NULL, the dimensions of %pixd are determined by
 - %w and %h if both are GT 0, or
 - the minimum size required using all boxes in %baa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="baa">boxaa, typically from a 2d sort</param>
	<param name="linewba">line width to display outline of each boxa</param>
	<param name="linewb">line width to display outline of each box</param>
	<param name="colorba">color to display boxa</param>
	<param name="colorb">color to display box</param>
	<param name="w">width of outupt pix; use 0 if determined by %pixs or %baa</param>
	<param name="h">height of outupt pix; use 0 if determined by %pixs or %baa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplayBoxaa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) All pix in %pixas that are not rgb are converted to rgb.
 (2) Each boxa in %baa contains boxes that will be drawn on
 the corresponding pix in %pixas.
 (3) The color of the boxes drawn on each pix are selected with
 %colorflag
 For red, green or blue use L_DRAW_RED, etc.
 For sequential r, g, b use L_DRAW_RGB
 For random colors use L_DRAW_RANDOM
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">any depth, can be cmapped</param>
	<param name="baa">boxes to draw on input pixa</param>
	<param name="colorflag">(L_DRAW_RED, L_DRAW_GREEN, etc)</param>
	<param name="width">thickness of lines</param>
	<returns>pixa with box outlines drawn on each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSplitIntoBoxa(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates a boxa of rectangles that covers
 the fg of a mask.  For each 8-connected component in pixs,
 it does a greedy partitioning, choosing the largest
 rectangle found from each of the four directions at each iter.
 See pixSplitComponentIntoBoxa() for details.
 (2) The input parameters give some flexibility for boundary
 noise.  The resulting set of rectangles may cover some
 bg pixels.
 (3) This should be used when there are a small number of
 mask components, each of which has sides that are close
 to horizontal and vertical.  The input parameters %delta
 and %maxbg determine whether or not holes in the mask are covered.
 (4) The parameter %maxcomps gives the maximum number of allowed
 rectangles extracted from any single connected component.
 Use 0 if no limit is to be applied.
 (5) The flag %remainder specifies whether we take a final bounding
 box for anything left after the maximum number of allowed
 rectangle is extracted.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="minsum">minimum pixels to trigger propagation</param>
	<param name="skipdist">distance before computing sum for propagation</param>
	<param name="delta">difference required to stop propagation</param>
	<param name="maxbg">maximum number of allowed bg pixels in ref scan</param>
	<param name="maxcomps">use 0 for unlimited number of subdivided components</param>
	<param name="remainder">set to 1 to get b.b. of remaining stuff</param>
	<returns>boxa of rectangles covering the fg of pixs, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSplitComponentIntoBoxa(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates a boxa of rectangles that covers
 the fg of a mask.  It does so by a greedy partitioning of
 the mask, choosing the largest rectangle found from
 each of the four directions at each step.
 (2) The input parameters give some flexibility for boundary
 noise.  The resulting set of rectangles must cover all
 the fg pixels and, in addition, may cover some bg pixels.
 Using small input parameters on a noiseless mask (i.e., one
 that has only large vertical and horizontal edges) will
 result in a proper covering of only the fg pixels of the mask.
 (3) The input is assumed to be a single connected component, that
 may have holes.  From each side, sweep inward, counting
 the pixels.  If the count becomes greater than %minsum,
 and we have moved forward a further amount %skipdist,
 record that count ('countref'), but don't accept if the scan
 contains more than %maxbg bg pixels.  Continue the scan
 until we reach a count that differs from countref by at
 least %delta, at which point the propagation stops.  The box
 swept out gets a score, which is the sum of fg pixels
 minus a penalty.  The penalty is the number of bg pixels
 in the box.  This is done from all four sides, and the
 side with the largest score is saved as a rectangle.
 The process repeats until there is either no rectangle
 left, or there is one that can't be captured from any
 direction.  For the latter case, we simply accept the
 last rectangle.
 (4) The input box is only used to specify the location of
 the UL corner of pix, with respect to an origin that
 typically represents the UL corner of an underlying image,
 of which pix is one component.  If %box is null,
 the UL corner is taken to be (0, 0).
 (5) The parameter %maxcomps gives the maximum number of allowed
 rectangles extracted from any single connected component.
 Use 0 if no limit is to be applied.
 (6) The flag %remainder specifies whether we take a final bounding
 box for anything left after the maximum number of allowed
 rectangle is extracted.
 (7) So if %maxcomps GT 0, it specifies that we want no more than
 the first %maxcomps rectangles that satisfy the input
 criteria.  After this, we can get a final rectangle that
 bounds everything left over by setting %remainder == 1.
 If %remainder == 0, we only get rectangles that satisfy
 the input criteria.
 (8) It should be noted that the removal of rectangles can
 break the original c.c. into several c.c.
 (9) Summing up
 If %maxcomp == 0, the splitting proceeds as far as possible.
 If %maxcomp GT 0, the splitting stops when %maxcomps are
 found, or earlier if no more components can be selected.
 If %remainder == 1 and components remain that cannot be
 selected, they are returned as a single final rectangle;
 otherwise, they are ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="box">location of pix w/rt an origin</param>
	<param name="minsum">minimum pixels to trigger propagation</param>
	<param name="skipdist">distance before computing sum for propagation</param>
	<param name="delta">difference required to stop propagation</param>
	<param name="maxbg">maximum number of allowed bg pixels in ref scan</param>
	<param name="maxcomps">use 0 for unlimited number of subdivided components</param>
	<param name="remainder">set to 1 to get b.b. of remaining stuff</param>
	<returns>boxa of rectangles covering the fg of pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makeMosaicStrips(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For example, this can be used to generate a pixa of
 vertical strips of width 10 from an image, using
 pixGetDimensions(pix, w, h, NULL);
 boxa = makeMosaicStrips(w, h, L_SCAN_HORIZONTAL, 10);
 pixa = pixClipRectangles(pix, boxa);
 All strips except the last will be the same width.  The
 last strip will have width w % 10.
 </summary>
	<remarks>
	</remarks>
	<param name="w"></param>
	<param name="h"></param>
	<param name="direction">L_SCAN_HORIZONTAL or L_SCAN_VERTICAL</param>
	<param name="size">of strips in the scan direction</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaCompareRegions(System.IntPtr,System.IntPtr,System.Int32,System.Int32@,System.Single[]@,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) This takes 2 boxa, removes all boxes smaller than a given area,
 and compares the remaining boxes between the boxa.
 (2) The area threshold is introduced to help remove noise from
 small components.  Any box with a smaller value of w  h
 will be removed from consideration.
 (3) The xor difference is the most stringent test, requiring alignment
 of the corresponding boxes.  It is also more computationally
 intensive and is optionally returned.  Alignment is to the
 UL corner of each region containing all boxes, as given by
 boxaGetExtent().
 (4) Both fractional differences are with respect to the total
 area in the two boxa.  They range from 0.0 to 1.0.
 A perfect match has value 0.0.  If both boxa are empty,
 we return 0.0; if one is empty we return 1.0.
 (5) An example input might be the rectangular regions of a
 segmentation mask for text or images from two pages.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa1"></param>
	<param name="boxa2"></param>
	<param name="areathresh">minimum area of boxes to be considered</param>
	<param name="pnsame">true if same number of boxes</param>
	<param name="pdiffarea">fractional difference in total area</param>
	<param name="pdiffxor">fractional difference in xor of regions</param>
	<param name="ppixdb">debug pix showing two boxa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSelectLargeULComp(System.IntPtr,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This selects a box near the top (first) and left (second)
 of the image, from the set of all boxes that have
 area GT= %areaslop  (area of biggest box),
 where %areaslop is some fraction; say ~ 0.9.
 (2) For all boxes satisfying the above condition, select
 the left-most box that is within %yslop (say, 20) pixels
 of the box nearest the top.
 (3) This can be used to reliably select a specific one of
 the largest regions in an image, for applications where
 there are expected to be small variations in region size
 and location.
 (4) See boxSelectLargeULBox() for implementation details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="areaslop">fraction near but less than 1.0</param>
	<param name="yslop">number of pixels in y direction</param>
	<param name="connectivity">4 or 8</param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSelectLargeULBox(System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) See usage notes in pixSelectLargeULComp().
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">1 bpp</param>
	<param name="areaslop">fraction near but less than 1.0</param>
	<param name="yslop">number of pixels in y direction</param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSelectRange(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The copyflag specifies what we do with each box from boxas.
 Specifically, L_CLONE inserts a clone into boxad of each
 selected box from boxas.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="first">use 0 to select from the beginning</param>
	<param name="last">use 0 to select to the end</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaSelectRange(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The copyflag specifies what we do with each boxa from baas.
 Specifically, L_CLONE inserts a clone into baad of each
 selected boxa from baas.
 </summary>
	<remarks>
	</remarks>
	<param name="baas"></param>
	<param name="first">use 0 to select from the beginning</param>
	<param name="last">use 0 to select to the end</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>baad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSelectBySize(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) Uses box copies in the new boxa.
 (3) If the selection type is L_SELECT_WIDTH, the input
 height is ignored, and v.v.
 (4) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="width">threshold dimensions</param>
	<param name="height">threshold dimensions</param>
	<param name="type">L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>boxad filtered set, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaMakeSizeIndicator(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) If the selection type is L_SELECT_WIDTH, the input
 height is ignored, and v.v.
 (3) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="width">threshold dimensions</param>
	<param name="height">threshold dimensions</param>
	<param name="type">L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns>na indicator array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSelectByArea(System.IntPtr,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Uses box copies in the new boxa.
 (2) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="area">threshold value of width  height</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>boxad filtered set, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaMakeAreaIndicator(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="area">threshold value of width  height</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns>na indicator array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSelectByWHRatio(System.IntPtr,System.Single,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Uses box copies in the new boxa.
 (2) To keep narrow components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep wide components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="ratio">width/height threshold value</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>boxad filtered set, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaMakeWHRatioIndicator(System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) To keep narrow components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep wide components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="ratio">width/height threshold value</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns>na indicator array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSelectWithIndicator(System.IntPtr,System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) Returns a copy of the boxa if no components are removed.
 (2) Uses box copies in the new boxa.
 (3) The indicator numa has values 0 (ignore) and 1 (accept).
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="na">indicator numa</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaPermutePseudorandom(System.IntPtr)">
	<summary>
 Notes
 (1) This does a pseudorandom in-place permutation of the boxes.
 (2) The result is guaranteed not to have any boxes in their
 original position, but it is not very random.  If you
 need randomness, use boxaPermuteRandom().
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">input boxa</param>
	<returns>boxad with boxes permuted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaPermuteRandom(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) If boxad is null, make a copy of boxas and permute the copy.
 Otherwise, boxad must be equal to boxas, and the operation
 is done in-place.
 (2) If boxas is empty, return an empty boxad.
 (3) This does a random in-place permutation of the boxes,
 by swapping each box in turn with a random box.  The
 result is almost guaranteed not to have any boxes in their
 original position.
 (4) MSVC rand() has MAX_RAND = 2^15 - 1, so it will not do
 a proper permutation is the number of boxes exceeds this.
 </summary>
	<remarks>
	</remarks>
	<param name="boxad">can be null or equal to boxas</param>
	<param name="boxas">input boxa</param>
	<returns>boxad with boxes permuted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSwapBoxes(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="i">two indices of boxes, that are to be swapped</param>
	<param name="j">two indices of boxes, that are to be swapped</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaConvertToPta(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If ncorners == 2, we select the UL and LR corners.
 Otherwise we save all 4 corners in this order UL, UR, LL, LR.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="ncorners">2 or 4 for the representation of each box</param>
	<returns>pta with %ncorners points for each box in the boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaConvertToBoxa(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) For 2 corners, the order of the 2 points is UL, LR.
 For 4 corners, the order of points is UL, UR, LL, LR.
 (2) Each derived box is the minimum size containing all corners.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="ncorners">2 or 4 for the representation of each box</param>
	<returns>boxa with one box for each 2 or 4 points in the pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxConvertToPta(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If ncorners == 2, we select the UL and LR corners.
 Otherwise we save all 4 corners in this order UL, UR, LL, LR.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="ncorners">2 or 4 for the representation of the box</param>
	<returns>pta with %ncorners points, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaConvertToBox(System.IntPtr)">
	<summary>
 Notes
 (1) For 2 corners, the order of the 2 points is UL, LR.
 For 4 corners, the order of points is UL, UR, LL, LR.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>box minimum containing all points in the pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSmoothSequenceLS(System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This returns a modified version of %boxas by constructing
 for each input box a box that has been linear least square fit
 (LSF) to the entire set.  The linear fitting is done to each of
 the box sides independently, after outliers are rejected,
 and it is computed separately for sequences of even and
 odd boxes.  Once the linear LSF box is found, the output box
 (in %boxad) is constructed from the input box and the LSF
 box, depending on %subflag.  See boxaModifyWithBoxa() for
 details on the use of %subflag and %maxdiff.
 (2) This is useful if, in both the even and odd sets, the box
 edges vary roughly linearly with its index in the set.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">source boxa</param>
	<param name="factor">reject outliers with widths and heights deviating from the median by more than %factor times the median variation from the median; typically ~3</param>
	<param name="subflag">L_USE_MINSIZE, L_USE_MAXSIZE, L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	<param name="maxdiff">parameter used with L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	<param name="extrapixels">pixels added on all sides (or subtracted if %extrapixels LT 0) when using L_SUB_ON_LOC_DIFF and L_SUB_ON_SIZE_DIFF</param>
	<param name="debug">1 for debug output</param>
	<returns>boxad fitted boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSmoothSequenceMedian(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The target width of the sliding window is 2  %halfwin + 1.
 If necessary, this will be reduced by boxaWindowedMedian().
 (2) This returns a modified version of %boxas by constructing
 for each input box a box that has been smoothed with windowed
 median filtering.  The filtering is done to each of the
 box sides independently, and it is computed separately for
 sequences of even and odd boxes.  The output %boxad is
 constructed from the input boxa and the filtered boxa,
 depending on %subflag.  See boxaModifyWithBoxa() for
 details on the use of %subflag, %maxdiff and %extrapixels.
 (3) This is useful for removing noise separately in the even
 and odd sets, where the box edge locations can have
 discontinuities but otherwise vary roughly linearly within
 intervals of size %halfwin or larger.
 (4) If you don't need to handle even and odd sets separately,
 just do this
 boxam = boxaWindowedMedian(boxas, halfwin, debug);
 boxad = boxaModifyWithBoxa(boxas, boxam, subflag, maxdiff,
 extrapixels);
 boxaDestroy(boxam);
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">source boxa</param>
	<param name="halfwin">half-width of sliding window; used to find median</param>
	<param name="subflag">L_USE_MINSIZE, L_USE_MAXSIZE, L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	<param name="maxdiff">parameter used with L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	<param name="extrapixels">pixels added on all sides (or subtracted if %extrapixels LT 0) when using L_SUB_ON_LOC_DIFF and L_SUB_ON_SIZE_DIFF</param>
	<param name="debug">1 for debug output</param>
	<returns>boxad fitted boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaLinearFit(System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This finds a set of boxes (boxad) where each edge of each box is
 a linear least square fit (LSF) to the edges of the
 input set of boxes (boxas).  Before fitting, outliers in
 the boxes in boxas are removed (see below).
 (2) This is useful when each of the box edges in boxas are expected
 to vary linearly with box index in the set.  These could
 be, for example, noisy measurements of similar regions
 on successive scanned pages.
 (3) Method there are 2 steps
 (a) Find and remove outliers, separately based on the deviation
 from the median of the width and height of the box.
 Use %factor to specify tolerance to outliers; use a very
 large value of %factor to avoid rejecting any box sides
 in the linear LSF.
 (b) On the remaining boxes, do a linear LSF independently
 for each of the four sides.
 (4) Invalid input boxes are not used in computation of the LSF.
 (5) The returned boxad can then be used in boxaModifyWithBoxa()
 to selectively change the boxes in boxas.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">source boxa</param>
	<param name="factor">reject outliers with widths and heights deviating from the median by more than %factor times the median deviation from the median; typically ~3</param>
	<param name="debug">1 for debug output</param>
	<returns>boxad fitted boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaWindowedMedian(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This finds a set of boxes (boxad) where each edge of each box is
 a windowed median smoothed value to the edges of the
 input set of boxes (boxas).
 (2) Invalid input boxes are filled from nearby ones.
 (3) The returned boxad can then be used in boxaModifyWithBoxa()
 to selectively change the boxes in the source boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">source boxa</param>
	<param name="halfwin">half width of window over which the median is found</param>
	<param name="debug">1 for debug output</param>
	<returns>boxad smoothed boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaModifyWithBoxa(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This takes two input boxa (boxas, boxam) and constructs boxad,
 where each box in boxad is generated from the corresponding
 boxes in boxas and boxam.  The rule for constructing each
 output box depends on %subflag and %maxdiff.  Let boxs be
 a box from %boxas and boxm be a box from %boxam.
 If %subflag == L_USE_MINSIZE the output box is the intersection
 of the two input boxes.
 If %subflag == L_USE_MAXSIZE the output box is the union of the
 two input boxes; i.e., the minimum bounding rectangle for the
 two input boxes.
 If %subflag == L_SUB_ON_LOC_DIFF each side of the output box
 is found separately from the corresponding side of boxs and boxm.
 Use the boxm side, expanded by %extrapixels, if greater than
 %maxdiff pixels from the boxs side.
 If %subflag == L_SUB_ON_SIZE_DIFF the sides of the output box
 are determined in pairs from the width and height of boxs
 and boxm.  If the boxm width differs by more than %maxdiff
 pixels from boxs, use the boxm left and right sides,
 expanded by %extrapixels.  Ditto for the height difference.
 For the last two flags, each side of the output box is found
 separately from the corresponding side of boxs and boxm,
 according to these rules, where "smaller"("bigger") mean in a
 direction that decreases(increases) the size of the output box
 If %subflag == L_USE_CAPPED_MIN use the Min of boxm
 with the Max of (boxs, boxm +- %maxdiff), where the sign
 is adjusted to make the box smaller (e.g., use "+" on left side).
 If %subflag == L_USE_CAPPED_MAX use the Max of boxm
 with the Min of (boxs, boxm +- %maxdiff), where the sign
 is adjusted to make the box bigger (e.g., use "-" on left side).
 Use of the last 2 flags is further explained in (3) and (4).
 (2) boxas and boxam must be the same size.  If boxam == NULL,
 this returns a copy of boxas with a warning.
 (3) If %subflag == L_SUB_ON_LOC_DIFF, use boxm for each side
 where the corresponding sides differ by more than %maxdiff.
 Two extreme cases
 (a) set %maxdiff == 0 to use only values from boxam in boxad.
 (b) set %maxdiff == 10000 to ignore all values from boxam;
 then boxad will be the same as boxas.
 (4) If %subflag == L_USE_CAPPED_MAX use boxm if boxs is smaller;
 use boxs if boxs is bigger than boxm by an amount up to %maxdiff;
 and use boxm +- %maxdiff (the 'capped' value) if boxs is
 bigger than boxm by an amount larger than %maxdiff.
 Similarly, with interchange of Min/Max and sign of %maxdiff,
 for %subflag == L_USE_CAPPED_MIN.
 (5) If either of corresponding boxes in boxas and boxam is invalid,
 an invalid box is copied to the result.
 (6) Typical input for boxam may be the output of boxaLinearFit().
 where outliers have been removed and each side is LS fit to a line.
 (7) Unlike boxaAdjustWidthToTarget() and boxaAdjustHeightToTarget(),
 this uses two boxes and does not specify target dimensions.
 Additional constraints on the size of each box can be enforced
 by following this operation with boxaConstrainSize(), taking
 boxad as input.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="boxam">boxa with boxes used to modify those in boxas</param>
	<param name="subflag">L_USE_MINSIZE, L_USE_MAXSIZE, L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	<param name="maxdiff">parameter used with L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	<param name="extrapixels">pixels added on all sides (or subtracted if %extrapixels LT 0) when using L_SUB_ON_LOC_DIFF and L_SUB_ON_SIZE_DIFF</param>
	<returns>boxad result after adjusting boxes in boxas, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaConstrainSize(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Forces either width or height (or both) of every box in
 the boxa to a specified size, by moving the indicated sides.
 (2) Not all input boxes need to be valid.  Median values will be
 used with invalid boxes.
 (3) Typical input might be the output of boxaLinearFit(),
 where each side has been fit.
 (4) Unlike boxaAdjustWidthToTarget() and boxaAdjustHeightToTarget(),
 this is not dependent on a difference threshold to change the size.
 (5) On error, a message is issued and a copy of the input boxa
 is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="width">force width of all boxes to this size; input 0 to use the median width</param>
	<param name="widthflag">L_ADJUST_SKIP, L_ADJUST_LEFT, L_ADJUST_RIGHT, or L_ADJUST_LEFT_AND_RIGHT</param>
	<param name="height">force height of all boxes to this size; input 0 to use the median height</param>
	<param name="heightflag">L_ADJUST_SKIP, L_ADJUST_TOP, L_ADJUST_BOT, or L_ADJUST_TOP_AND_BOT</param>
	<returns>boxad adjusted so all boxes are the same size</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaReconcileEvenOddHeight(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) The basic idea is to reconcile differences in box height
 in the even and odd boxes, by moving the top and/or bottom
 edges in the even and odd boxes.  Choose the edge or edges
 to be moved, whether to adjust the boxes with the min
 or the max of the medians, and the threshold on the median
 difference between even and odd box heights for the operations
 to take place.  The same threshold is also used to
 determine if each individual box edge is to be adjusted.
 (2) Boxes are conditionally reset with either the same top (y)
 value or the same bottom value, or both.  The value is
 determined by the greater or lesser of the medians of the
 even and odd boxes, with the choice depending on the value
 of %op, which selects for either min or max median height.
 If the median difference between even and odd boxes is
 greater than %dely, then any individual box edge that differs
 from the selected median by more than %dely is set to
 the selected median times a factor typically near 1.0.
 (3) Note that if selecting for minimum height, you will choose
 the largest y-value for the top and the smallest y-value for
 the bottom of the box.
 (4) Typical input might be the output of boxaSmoothSequence(),
 where even and odd boxa have been independently regulated.
 (5) Require at least 3 valid even boxes and 3 valid odd boxes.
 Median values will be used for invalid boxes.
 (6) If the median height is not representative of the boxes
 in %boxas, this can make things much worse.  In that case,
 ignore the value of %op, and force pairwise equality of the
 heights, with pairwise maximal vertical extension.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">containing at least 3 valid boxes in even and odd</param>
	<param name="sides">L_ADJUST_TOP, L_ADJUST_BOT, L_ADJUST_TOP_AND_BOT</param>
	<param name="delh">threshold on median height difference</param>
	<param name="op">L_ADJUST_CHOOSE_MIN, L_ADJUST_CHOOSE_MAX</param>
	<param name="factor">GT 0.0, typically near 1.0</param>
	<param name="start">0 if pairing (0,1), etc; 1 if pairing (1,2), etc</param>
	<returns>boxad adjusted, or a copy of boxas on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaReconcilePairWidth(System.IntPtr,System.Int32,System.Int32,System.Single,System.IntPtr)">
	<summary>
 Notes
 (1) This reconciles differences in the width of adjacent boxes,
 by moving one side of one of the boxes in each pair.
 If the widths in the pair differ by more than some
 threshold, move either the left side for even boxes or
 the right side for odd boxes, depending on if we're choosing
 the min or max.  If choosing min, the width of the max is
 set to factor  (width of min).  If choosing max, the width
 of the min is set to factor  (width of max).
 (2) If %na exists, it is an indicator array corresponding to the
 boxes in %boxas.  If %na != NULL, only boxes with an
 indicator value of 1 are allowed to adjust; otherwise,
 all boxes can adjust.
 (3) Typical input might be the output of boxaSmoothSequence(),
 where even and odd boxa have been independently regulated.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="delw">threshold on adjacent width difference</param>
	<param name="op">L_ADJUST_CHOOSE_MIN, L_ADJUST_CHOOSE_MAX</param>
	<param name="factor">GT 0.0, typically near 1.0</param>
	<param name="na">indicator array allowing change</param>
	<returns>boxad adjusted, or a copy of boxas on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaPlotSides(System.IntPtr,System.String,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This debugging function shows the progression of the four
 sides in the boxa.  There must be at least 2 boxes.
 (2) If there are invalid boxes (e.g., if only even or odd
 indices have valid boxes), this will fill them with the
 nearest valid box before plotting.
 (3) The plotfiles are put in /tmp/lept/plots/, and are named
 either with %plotname or, if NULL, a default name.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">source boxa</param>
	<param name="plotname">, can be NULL</param>
	<param name="pnal">na of left sides</param>
	<param name="pnat">na of top sides</param>
	<param name="pnar">na of right sides</param>
	<param name="pnab">na of bottom sides</param>
	<param name="ppixd">pix of the output plot</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaPlotSizes(System.IntPtr,System.String,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This debugging function shows the progression of box width
 and height in the boxa.  There must be at least 2 boxes.
 (2) If there are invalid boxes (e.g., if only even or odd
 indices have valid boxes), this will fill them with the
 nearest valid box before plotting.
 (3) The plotfiles are put in /tmp/lept/plots/, and are named
 either with %plotname or, if NULL, a default name.  Make sure
 that %plotname is a string with no whitespace characters.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">source boxa</param>
	<param name="plotname">, can be NULL</param>
	<param name="pnaw">na of widths</param>
	<param name="pnah">na of heights</param>
	<param name="ppixd">pix of the output plot</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaFillSequence(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This simple function replaces invalid boxes with a copy of
 the nearest valid box, selected from either the entire
 sequence (L_USE_ALL_BOXES) or from the boxes with the
 same parity (L_USE_SAME_PARITY_BOXES).  It returns a new boxa.
 (2) This is useful if you expect boxes in the sequence to
 vary slowly with index.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">with at least 3 boxes</param>
	<param name="useflag">L_USE_ALL_BOXES, L_USE_SAME_PARITY_BOXES</param>
	<param name="debug">1 for debug output</param>
	<returns>boxad filled boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSizeVariation(System.IntPtr,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This gives several measures of the smoothness of either the
 width or height of a sequence of boxes.
 (2) Statistics can be found separately for even and odd boxes.
 Additionally, the average pair-wise difference between
 adjacent even and odd boxes can be returned.
 (3) The use case is bounding boxes for scanned page images,
 where ideally the sizes should have little variance.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">at least 4 boxes</param>
	<param name="type">L_SELECT_WIDTH, L_SELECT_HEIGHT</param>
	<param name="pdel_evenodd">average absolute value of (even - odd) size pairs</param>
	<param name="prms_even">rms deviation of even boxes</param>
	<param name="prms_odd">rms deviation of odd boxes</param>
	<param name="prms_all">rms deviation of all boxes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetExtent(System.IntPtr,System.Int32@,System.Int32@,System.IntPtr@)">
	<summary>
 Notes
 (1) The returned w and h are the minimum size image
 that would contain all boxes untranslated.
 (2) If there are no valid boxes, returned w and h are 0 and
 all parameters in the returned box are 0.  This
 is not an error, because an empty boxa is valid and
 boxaGetExtent() is required for serialization.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<param name="pbox">minimum box containing all boxes in boxa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetCoverage(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) The boxes in boxa are clipped to the input rectangle.
 (2)  When %exactflag == 1, we generate a 1 bpp pix of size
 wc x hc, paint all the boxes black, and count the fg pixels.
 This can take 1 msec on a large page with many boxes.
 When %exactflag == 0, we clip each box to the wc x hc region
 and sum the resulting areas.  This is faster.
 The results are the same when none of the boxes overlap
 within the wc x hc region.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="wc">dimensions of overall clipping rectangle with UL corner at (0, 0 that is covered by the boxes.</param>
	<param name="hc">dimensions of overall clipping rectangle with UL corner at (0, 0 that is covered by the boxes.</param>
	<param name="exactflag">1 for guaranteeing an exact result; 0 for getting an exact result only if the boxes do not overlap</param>
	<param name="pfract">sum of box area as fraction of w  h</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaSizeRange(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="pminw">range of dimensions of all boxes</param>
	<param name="pminh">range of dimensions of all boxes</param>
	<param name="pmaxw">range of dimensions of all boxes</param>
	<param name="pmaxh">range of dimensions of all boxes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaSizeRange(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pminw">range of dimensions of box in the array</param>
	<param name="pminh">range of dimensions of box in the array</param>
	<param name="pmaxw">range of dimensions of box in the array</param>
	<param name="pmaxh">range of dimensions of box in the array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaLocationRange(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pminx">range of UL corner positions</param>
	<param name="pminy">range of UL corner positions</param>
	<param name="pmaxx">range of UL corner positions</param>
	<param name="pmaxy">range of UL corner positions</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetSizes(System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pnaw">widths and heights of valid boxes</param>
	<param name="pnah">widths and heights of valid boxes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetArea(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) Measures the total area of the boxes, without regard to overlaps.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="parea">total area of all boxes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaDisplayTiled(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Displays each box separately in a tiled 32 bpp image.
 (2) If pixa is defined, it must have the same count as the boxa,
 and it will be a background over with each box is rendered.
 If pixa is not defined, the boxes will be rendered over
 blank images of identical size.
 (3) See pixaDisplayTiledInRows() for other parameters.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="pixa">background for each box</param>
	<param name="maxwidth">of output image</param>
	<param name="linewidth">width of box outlines, before scaling</param>
	<param name="scalefactor">applied to every box; use 1.0 for no scaling</param>
	<param name="background">0 for white, 1 for black; this is the color of the spacing between the images</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of black border added to each image; use 0 for no border</param>
	<returns>pixd of tiled images of boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaCreate(System.UInt32)">
	<summary>
 Notes
 (1) The allocated array is n + 1 bytes.  This allows room
 for null termination.
 </summary>
	<remarks>
	</remarks>
	<param name="nbytes">determines initial size of data array</param>
	<returns>l_bytea, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaInitFromMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">to be copied to the array</param>
	<param name="size">amount of data</param>
	<returns>l_bytea, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaInitFromFile(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<returns>l_bytea, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaInitFromStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>l_bytea, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaCopy(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If cloning, up the refcount and return a ptr to %bas.
 </summary>
	<remarks>
	</remarks>
	<param name="bas">source lba</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>clone or copy of bas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the lba.
 (2) Always nulls the input ptr.
 (3) If the data has been previously removed, the lba will
 have been nulled, so this will do nothing.
 </summary>
	<remarks>
	</remarks>
	<param name="pba">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp.Natives.l_byteaGetSize(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ba"></param>
	<returns>size of stored byte array, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaGetData(System.IntPtr,System.UInt32@)">
	<summary>
 Notes
 (1) The returned ptr is owned by %ba.  Do not free it!
 </summary>
	<remarks>
	</remarks>
	<param name="ba"></param>
	<param name="psize">size of data in lba</param>
	<returns>ptr to existing data array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaCopyData(System.IntPtr,System.UInt32@)">
	<summary>
 Notes
 (1) The returned data is owned by the caller.  The input %ba
 still owns the original data array.
 </summary>
	<remarks>
	</remarks>
	<param name="ba"></param>
	<param name="psize">size of data in lba</param>
	<returns>copy of data in use in the data array, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaAppendData(System.IntPtr,System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ba"></param>
	<param name="newdata">byte array to be appended</param>
	<param name="newbytes">size of data array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaAppendString(System.IntPtr,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ba"></param>
	<param name="str">null-terminated string to be appended</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaJoin(System.IntPtr,System.IntPtr@)">
	<summary>
 Notes
 (1) It is a no-op, not an error, for %ba2 to be null.
 </summary>
	<remarks>
	</remarks>
	<param name="ba1"></param>
	<param name="pba2">data array is added to the one in ba1, and then ba2 is destroyed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaSplit(System.IntPtr,System.UInt32,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ba1">lba to split; array bytes nulled beyond the split loc</param>
	<param name="splitloc">location in ba1 to split; ba2 begins there</param>
	<param name="pba2">with data starting at splitloc</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaFindEachSequence(System.IntPtr,System.Byte[],System.UInt32,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ba"></param>
	<param name="sequence">subarray of bytes to find in data</param>
	<param name="seqlen">length of sequence, in bytes</param>
	<param name="pda">byte positions of each occurrence of %sequence</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaWrite(System.String,System.IntPtr,System.UInt32,System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">output file</param>
	<param name="ba"></param>
	<param name="startloc">first byte to output</param>
	<param name="endloc">last byte to output; use 0 to write to the end of the data array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_byteaWriteStream(System.IntPtr,System.IntPtr,System.UInt32,System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for binary write</param>
	<param name="ba"></param>
	<param name="startloc">first byte to output</param>
	<param name="endloc">last byte to output; use 0 to write to the end of the data array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaCreate(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">binary image; can be null</param>
	<param name="n">initial number of ptrs</param>
	<returns>ccba, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pccba">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.ccbCreate(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>ccb or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pccb">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.ccbaAddCcb(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<param name="ccb">to be added by insertion</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<returns>count, with 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaGetCcb(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This returns a clone of the ccb; it must be destroyed
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<param name="index"></param>
	<returns>ccb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetAllCCBorders(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>ccborda, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetCCBorders(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) We are finding the exterior and interior borders
 of an 8-connected component.   This should be used
 on a pix that has exactly one 8-connected component.
 (2) Typically, pixs is a c.c. in some larger pix.  The
 input box gives its location in global coordinates.
 This box is saved, as well as the boxes for the
 borders of any holes within the c.c., but the latter
 are given in relative coords within the c.c.
 (3) The calculations for the exterior border are done
 on a pix with a 1-pixel
 added border, but the saved pixel coordinates
 are the correct (relative) ones for the input pix
 (without a 1-pixel border)
 (4) For the definition of the three tables -- xpostab[], ypostab[]
 and qpostab[] -- see above where they are defined.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, one 8-connected component</param>
	<param name="box">xul, yul, width, height in global coords</param>
	<returns>ccbord, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetOuterBordersPtaa(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>ptaa of outer borders, in global coords, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetOuterBorderPta(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) We are finding the exterior border of a single 8-connected
 component.
 (2) If box is NULL, the outline returned is in the local coords
 of the input pix.  Otherwise, box is assumed to give the
 location of the pix in global coordinates, and the returned
 pta will be in those global coordinates.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, one 8-connected component</param>
	<param name="box">of pixs, in global coordinates</param>
	<returns>pta of outer border, in global coords, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetOuterBorder(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) the border is saved in relative coordinates within
 the c.c. (pixs).  Because the calculation is done
 in pixb with added 1 pixel border, we must subtract
 1 from each pixel value before storing it.
 (2) the stopping condition is that after the first pixel is
 returned to, the next pixel is the second pixel.  Having
 these 2 pixels recur in sequence proves the path is closed,
 and we do not store the second pixel again.
 </summary>
	<remarks>
	</remarks>
	<param name="ccb">unfilled</param>
	<param name="pixs">for the component at hand</param>
	<param name="box">for the component, in global coords</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetHoleBorder(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) we trace out hole border on pixs without addition
 of single pixel added border to pixs
 (2) therefore all coordinates are relative within the c.c. (pixs)
 (3) same position tables and stopping condition as for
 exterior borders
 </summary>
	<remarks>
	</remarks>
	<param name="ccb">the exterior border is already made</param>
	<param name="pixs">for the connected component at hand</param>
	<param name="box">for the specific hole border, in relative coordinates to the c.c.</param>
	<param name="xs">first pixel on hole border, relative to c.c.</param>
	<param name="ys">first pixel on hole border, relative to c.c.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.findNextBorderPixel(System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) qpos increases clockwise from 0 to 7, with 0 at
 location with Q to left of P   Q P
 (2) this is a low-level function that does not check input
 parameters.  All calling functions should check them.
 </summary>
	<remarks>
	</remarks>
	<param name="w"></param>
	<param name="h"></param>
	<param name="data"></param>
	<param name="wpl"></param>
	<param name="px">current P</param>
	<param name="py">current P</param>
	<param name="pqpos">input current Q; new Q</param>
	<param name="pnpx">new P</param>
	<param name="pnpy">new P</param>
	<returns>0 if next pixel found; 1 otherwise</returns>
</member><member name="M:LeptonicaSharp.Natives.locateOutsideSeedPixel(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) the first and second pixels must be 8-adjacent,
 so |dx| LT= 1 and |dy| LT= 1 and both dx and dy
 cannot be 0.  There are 8 possible cases.
 (2) the seed pixel is OUTSIDE the foreground of the c.c.
 (3) these rules are for the situation where the INSIDE
 of the c.c. is on the right as you follow the border
 cw for an exterior border and ccw for a hole border.
 </summary>
	<remarks>
	</remarks>
	<param name="fpx">location of first pixel</param>
	<param name="fpy">location of first pixel</param>
	<param name="spx">location of second pixel</param>
	<param name="spy">location of second pixel</param>
	<param name="pxs">seed pixel to be returned</param>
	<param name="pys">seed pixel to be returned</param>
</member><member name="M:LeptonicaSharp.Natives.ccbaGenerateGlobalLocs(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ccba">with local chain ptaa of borders computed</param>
	<returns>0 if OK, 1 on error Action this uses the pixel locs in the local ptaa, which are all relative to each c.c., to find the global pixel locations, and stores them in the global ptaa.</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaGenerateStepChains(System.IntPtr)">
	<summary>
 Notes
 (1) This uses the pixel locs in the local ptaa,
 which are all relative to each c.c., to find
 the step directions for successive pixels in
 the chain, and stores them in the step numaa.
 (2) To get the step direction, use
 1   2   3
 0   P   4
 7   6   5
 where P is the previous pixel at (px, py).  The step direction
 is the number (from 0 through 7) for each relative location
 of the current pixel at (cx, cy).  It is easily found by
 indexing into a 2-d 3x3 array (dirtab).
 </summary>
	<remarks>
	</remarks>
	<param name="ccba">with local chain ptaa of borders computed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaStepChainsToPixCoords(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This uses the step chain data in each ccb to determine
 the pixel locations, either global or local,
 and stores them in the appropriate ptaa,
 either global or local.  For the latter, the
 pixel locations are relative to the c.c.
 </summary>
	<remarks>
	</remarks>
	<param name="ccba">with step chains numaa of borders</param>
	<param name="coordtype">CCB_GLOBAL_COORDS or CCB_LOCAL_COORDS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaGenerateSPGlobalLocs(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This calculates the splocal rep if not yet made.
 (2) It uses the local pixel values in splocal, the single
 path pta, which are all relative to each c.c., to find
 the corresponding global pixel locations, and stores
 them in the spglobal pta.
 (3) This lists only the turning points it both makes a
 valid svg file and is typically about half the size
 when all border points are listed.
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<param name="ptsflag">CCB_SAVE_ALL_PTS or CCB_SAVE_TURNING_PTS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaGenerateSinglePath(System.IntPtr)">
	<summary>
 Notes
 (1) Generates a single border in local pixel coordinates.
 For each c.c., if there is just an outer border, copy it.
 If there are also hole borders, for each hole border,
 determine the smallest horizontal or vertical
 distance from the border to the outside of the c.c.,
 and find a path through the c.c. for this cut.
 We do this in a way that guarantees a pixel from the
 hole border is the starting point of the path, and
 we must verify that the path intersects the outer
 border (if it intersects it, then it ends on it).
 One can imagine pathological cases, but they may not
 occur in images of text characters and un-textured
 line graphics.
 (2) Once it is verified that the path through the c.c.
 intersects both the hole and outer borders, we
 generate the full single path for all borders in the
 c.c.  Starting at the start point on the outer
 border, when we hit a line on a cut, we take
 the cut, do the hold border, and return on the cut
 to the outer border.  We compose a pta of the
 outer border pts that are on cut paths, and for
 every point on the outer border (as we go around),
 we check against this pta.  When we find a matching
 point in the pta, we do its cut path and hole border.
 The single path is saved in the ccb.
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getCutPathForHole(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If we don't find a path, we return a pta with no pts
 in it and len = 0.
 (2) The goal is to get a reasonably short path between the
 inner and outer borders, that goes entirely within the fg of
 the pix.  This function is cheap-and-dirty, may fail for some
 holes in complex topologies such as those you might find in a
 moderately dark scanned halftone.  If it fails to find a
 path to any particular hole, it gives a warning, and because
 that hole path is not included, the hole will not be rendered.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">of c.c.</param>
	<param name="pta">of outer border</param>
	<param name="boxinner">b.b. of hole path</param>
	<param name="pdir">direction (0-3), returned; only needed for debug</param>
	<param name="plen">length of path, returned</param>
	<returns>pta of pts on cut path from the hole border to the outer border, including end points on both borders; or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaDisplayBorder(System.IntPtr)">
	<summary>
 Notes
 (1) Uses global ptaa, which gives each border pixel in
 global coordinates, and must be computed in advance
 by calling ccbaGenerateGlobalLocs().
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<returns>pix of border pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaDisplaySPBorder(System.IntPtr)">
	<summary>
 Notes
 (1) Uses spglobal pta, which gives each border pixel in
 global coordinates, one path per c.c., and must
 be computed in advance by calling ccbaGenerateSPGlobalLocs().
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<returns>pix of border pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaDisplayImage1(System.IntPtr)">
	<summary>
 Notes
 (1) Uses local ptaa, which gives each border pixel in
 local coordinates, so the actual pixel positions must
 be computed using all offsets.
 (2) For the holes, use coordinates relative to the c.c.
 (3) This is slower than Method 2.
 (4) This uses topological properties (Method 1) to do scan
 conversion to raster
 This algorithm deserves some commentary.
 I first tried the following
 ~ outer borders 4-fill from outside, stopping at the
 border, using pixFillClosedBorders()
 ~ inner borders 4-fill from outside, stopping again
 at the border, XOR with the border, and invert
 to get the hole.  This did not work, because if
 you have a hole border that looks like
 x x x x x x
 x x
 x   x x x   x
 x x o x   x
 x  x
 x  x
 x x x
 if you 4-fill from the outside, the pixel 'o' will
 not be filled!  XORing with the border leaves it OFF.
 Inverting then gives a single bad ON pixel that is not
 actually part of the hole.
 So what you must do instead is 4-fill the holes from inside.
 You can do this from a seedfill, using a pix with the hole
 border as the filling mask.  But you need to start with a
 pixel inside the hole.  How is this determined?  The best
 way is from the contour.  We have a right-hand shoulder
 rule for inside (i.e., the filled region).   Take the
 first 2 pixels of the hole border, and compute dx and dy
 (second coord minus first coord  dx = sx - fx, dy = sy - fy).
 There are 8 possibilities, depending on the values of dx and
 dy (which can each be -1, 0, and +1, but not both 0).
 These 8 cases can be broken into 4; see the simple algorithm below.
 Once you have an interior seed pixel, you fill from the seed,
 clipping with the hole border pix by filling into its invert.
 You then successively XOR these interior filled components, in any order.
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<returns>pix of image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaDisplayImage2(System.IntPtr)">
	<summary>
 Notes
 (1) Uses local chain ptaa, which gives each border pixel in
 local coordinates, so the actual pixel positions must
 be computed using all offsets.
 (2) Treats exterior and hole borders on equivalent
 footing, and does all calculations on a pix
 that spans the c.c. with a 1 pixel added boundary.
 (3) This uses topological properties (Method 2) to do scan
 conversion to raster
 (4) The algorithm is described at the top of this file (Method 2).
 It is preferred to Method 1 because it is between 1.2x and 2x
 faster than Method 1.
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<returns>pix of image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="ccba"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="ccba"></param>
	<returns>0 if OK; 1 on error Format \code ccba %7d cc\n num. c.c.) (ascii)   (18B pix width 4B pix height 4B [for i = 1, ncc] ulx  4B uly  4B w    4B       -- not req'd for reconstruction h    4B       -- not req'd for reconstruction number of borders 4B [for j = 1, nb] startx  4B starty  4B [for k = 1, nb] 2 steps 1B end in z8 or 88  1B \endcode</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>ccba, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>ccba, or NULL on error \code Format  ccba %7d cc\n num. c.c.) (ascii)   (17B pix width 4B pix height 4B [for i = 1, ncc] ulx  4B uly  4B w    4B       -- not req'd for reconstruction h    4B       -- not req'd for reconstruction number of borders 4B [for j = 1, nb] startx  4B starty  4B [for k = 1, nb] 2 steps 1B end in z8 or 88  1B \endcode</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaWriteSVG(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="ccba"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ccbaWriteSVGString(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="ccba"></param>
	<returns>string in svg-formatted, that can be written to file, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaThinConnected(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See notes in pixThinConnected().
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">of 1 bpp pix</param>
	<param name="type">L_THIN_FG, L_THIN_BG</param>
	<param name="connectivity">4 or 8</param>
	<param name="maxiters">max number of iters allowed; use 0 to iterate until completion</param>
	<returns>pixds, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixThinConnected(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See "Connectivity-preserving morphological image transformations,"
 Dan S. Bloomberg, in SPIE Visual Communications and Image
 Processing, Conference 1606, pp. 320-334, November 1991,
 Boston, MA.   A web version is available at
 http//www.leptonica.com/papers/conn.pdf
 (2) This is a simple interface for two of the best iterative
 morphological thinning algorithms, for 4-c.c and 8-c.c.
 Each iteration uses a mixture of parallel operations
 (using several different 3x3 Sels) and serial operations.
 Specifically, each thinning iteration consists of
 four sequential thinnings from each of four directions.
 Each of these thinnings is a parallel composite
 operation, where the union of a set of HMTs are set
 subtracted from the input.  For 4-cc thinning, we
 use 3 HMTs in parallel, and for 8-cc thinning we use 4 HMTs.
 (3) A "good" thinning algorithm is one that generates a skeleton
 that is near the medial axis and has neither pruned
 real branches nor left extra dendritic branches.
 (4) Duality between operations on fg and bg require switching
 the connectivity.  To thin the foreground, which is the usual
 situation, use type == L_THIN_FG.  Thickening the foreground
 is equivalent to thinning the background (type == L_THIN_BG),
 where the alternate connectivity gets preserved.
 For example, to thicken the fg with 2 rounds of iterations
 using 4-c.c., thin the bg using Sels that preserve 8-connectivity
 Pix pix = pixThinConnected(pixs, L_THIN_BG, 8, 2);
 (5) This makes and destroys the sela set each time. It's not a large
 overhead, but if you are calling this thousands of times on
 very small images, you can avoid the overhead; e.g.
 Sela sela = selaMakeThinSets(1, 0);  // for 4-c.c.
 Pix pix = pixThinConnectedBySet(pixs, L_THIN_FG, sela, 0);
 using set 1 for 4-c.c. and set 5 for 8-c.c operations.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="type">L_THIN_FG, L_THIN_BG</param>
	<param name="connectivity">4 or 8</param>
	<param name="maxiters">max number of iters allowed; use 0 to iterate until completion</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixThinConnectedBySet(System.IntPtr,System.Int32,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) See notes in pixThinConnected().
 (2) This takes a sela representing one of 11 sets of HMT Sels.
 The HMTs from this set are run in parallel and the result
 is OR'd before being subtracted from the source.  For each
 iteration, this "parallel" thin is performed four times
 sequentially, for sels rotated by 90 degrees in all four
 directions.
 (3) The "parallel" and "sequential" nomenclature is standard
 in digital filtering.  Here, "parallel" operations work on the
 same source (pixd), and accumulate the results in a temp
 image before actually applying them to the source (in this
 case, using an in-place subtraction).  "Sequential" operations
 operate directly on the source (pixd) to produce the result
 (in this case, with four sequential thinning operations, one
 from each of four directions).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="type">L_THIN_FG, L_THIN_BG</param>
	<param name="sela">of Sels for parallel composite HMTs</param>
	<param name="maxiters">max number of iters allowed; use 0 to iterate until completion</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaMakeThinSets(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) These are specific sets of HMTs to be used in parallel for
 for thinning from each of four directions.
 (2) The sets are indexed as follows
 For thinning (e.g., run to completion)
 index = 1  sel_4_1, sel_4_2, sel_4_3
 index = 2  sel_4_1, sel_4_5, sel_4_6
 index = 3  sel_4_1, sel_4_7, sel_4_7_rot
 index = 4  sel_48_1, sel_48_1_rot, sel_48_2
 index = 5  sel_8_2, sel_8_3, sel_8_5, sel_8_6
 index = 6  sel_8_2, sel_8_3, sel_48_2
 index = 7  sel_8_1, sel_8_5, sel_8_6
 index = 8  sel_8_2, sel_8_3, sel_8_8, sel_8_9
 index = 9  sel_8_5, sel_8_6, sel_8_7, sel_8_7_rot
 For thickening (e.g., just a few iterations)
 index = 10 sel_4_2, sel_4_3
 index = 11 sel_8_4
 (3) For a very smooth skeleton, use set 1 for 4 connected and
 set 5 for 8 connected thins.
 </summary>
	<remarks>
	</remarks>
	<param name="index">into specific sets</param>
	<param name="debug">1 to output display of sela</param>
	<returns>sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbCorrelation(System.String,System.Single,System.Single,System.Int32,System.String,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The images must be 1 bpp.  If they are not, you can convert
 them using convertFilesTo1bpp().
 (2) See prog/jbcorrelation for generating more output (e.g.,
 for debugging)
 </summary>
	<remarks>
	</remarks>
	<param name="dirin">directory of input images</param>
	<param name="thresh">typically ~0.8</param>
	<param name="weight">typically ~0.6</param>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<param name="rootname">for output files</param>
	<param name="firstpage">0-based</param>
	<param name="npages">use 0 for all pages in dirin</param>
	<param name="renderflag">1 to render from templates; 0 to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbRankHaus(System.String,System.Int32,System.Single,System.Int32,System.String,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See prog/jbrankhaus for generating more output (e.g.,
 for debugging)
 </summary>
	<remarks>
	</remarks>
	<param name="dirin">directory of input images</param>
	<param name="size">of Sel used for dilation; typ. 2</param>
	<param name="rank">rank value of match; typ. 0.97</param>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<param name="rootname">for output files</param>
	<param name="firstpage">0-based</param>
	<param name="npages">use 0 for all pages in dirin</param>
	<param name="renderflag">1 to render from templates; 0 to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbWordsInTextlines(System.String,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.IntPtr@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a high-level function.  See prog/jbwords for example
 of usage.
 (2) Typically, use input of 75 - 150 ppi for finding words.
 </summary>
	<remarks>
	</remarks>
	<param name="dirin">directory of input pages</param>
	<param name="reduction">1 for full res; 2 for half-res</param>
	<param name="maxwidth">of word mask components, to be kept</param>
	<param name="maxheight">of word mask components, to be kept</param>
	<param name="thresh">on correlation; 0.80 is reasonable</param>
	<param name="weight">for handling thick text; 0.6 is reasonable</param>
	<param name="pnatl">numa with textline index for each component</param>
	<param name="firstpage">0-based</param>
	<param name="npages">use 0 for all pages in dirin</param>
	<returns>classer for the set of pages</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetWordsInTextlines(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The input should be at a resolution of between 75 and 150 ppi.
 (2) The four size constraints on saved components are all
 scaled by %reduction.
 (3) The result are word images (and their b.b.), extracted in
 textline order, at either full res or 2x reduction,
 and with a numa giving the textline index for each word.
 (4) The pixa and boxa interfaces should make this type of
 application simple to put together.  The steps are
 ~ generate first estimate of word masks
 ~ get b.b. of these, and remove the small and big ones
 ~ extract pixa of the word images, using the b.b.
 ~ sort actual word images in textline order (2d)
 ~ flatten them to a pixa (1d), saving the textline index
 for each pix
 (5) In an actual application, it may be desirable to pre-filter
 the input image to remove large components, to extract
 single columns of text, and to deskew them.  For example,
 to remove both large components and small noisy components
 that can interfere with the statistics used to estimate
 parameters for segmenting by words, but still retain text lines,
 the following image preprocessing can be done
 Pix pixt = pixMorphSequence(pixs, "c40.1", 0);
 Pix pixf = pixSelectBySize(pixt, 0, 60, 8,
 L_SELECT_HEIGHT, L_SELECT_IF_LT, NULL);
 pixAnd(pixf, pixf, pixs);  // the filtered image
 The closing turns text lines into long blobs, but does not
 significantly increase their height.  But if there are many
 small connected components in a dense texture, this is likely
 to generate tall components that will be eliminated in pixf.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, typ. 75 - 150 ppi</param>
	<param name="minwidth">of saved components; smaller are discarded</param>
	<param name="minheight">of saved components; smaller are discarded</param>
	<param name="maxwidth">of saved components; larger are discarded</param>
	<param name="maxheight">of saved components; larger are discarded</param>
	<param name="pboxad">word boxes sorted in textline line order</param>
	<param name="ppixad">word images sorted in textline line order</param>
	<param name="pnai">index of textline for each word</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetWordBoxesInTextlines(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The input should be at a resolution of between 75 and 150 ppi.
 (2) This is a special version of pixGetWordsInTextlines(), that
 just finds the word boxes in line order, with a numa
 giving the textline index for each word.
 See pixGetWordsInTextlines() for more details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, typ. 300 ppi</param>
	<param name="minwidth">of saved components; smaller are discarded</param>
	<param name="minheight">of saved components; smaller are discarded</param>
	<param name="maxwidth">of saved components; larger are discarded</param>
	<param name="maxheight">of saved components; larger are discarded</param>
	<param name="pboxad">word boxes sorted in textline line order</param>
	<param name="pnai">index of textline for each word</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaExtractSortedPattern(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) The input is expected to come from pixGetWordBoxesInTextlines().
 (2) Each numa in the output consists of an average y coordinate
 of the first box in the textline, followed by pairs of
 x coordinates representing the left and right edges of each
 of the boxes in the textline.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">typ. of word bounding boxes, in textline order</param>
	<param name="na">index of textline for each box in boxa</param>
	<returns>naa NUMAA, where each numa represents one textline, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaCompareImagesByBoxes(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) Each input numaa describes a set of sorted bounding boxes
 (sorted by textline and, within each textline, from
 left to right) in the images from which they are derived.
 See boxaExtractSortedPattern() for a description of the data
 format in each of the input numaa.
 (2) This function does an alignment between the input
 descriptions of bounding boxes for two images. The
 input parameter %nperline specifies the number of boxes
 to consider in each line when testing for a match, and
 %nreq is the required number of lines that must be well-aligned
 to get a match.
 (3) Testing by alignment has 3 steps
 (a) Generating the location of word bounding boxes from the
 images (prior to calling this function).
 (b) Listing all possible pairs of aligned rows, based on
 tolerances in horizontal and vertical positions of
 the boxes.  Specifically, all pairs of rows are enumerated
 whose first %nperline boxes can be brought into close
 alignment, based on the delx parameter for boxes in the
 line and within the overall the %maxshiftx and %maxshifty
 constraints.
 (c) Each pair, starting with the first, is used to search
 for a set of %nreq - 1 other pairs that can all be aligned
 with a difference in global translation of not more
 than (%delx, %dely).
 </summary>
	<remarks>
	</remarks>
	<param name="naa1">for image 1, formatted by boxaExtractSortedPattern()</param>
	<param name="naa2">ditto; for image 2</param>
	<param name="nperline">number of box regions to be used in each textline</param>
	<param name="nreq">number of complete row matches required</param>
	<param name="maxshiftx">max allowed x shift between two patterns, in pixels</param>
	<param name="maxshifty">max allowed y shift between two patterns, in pixels</param>
	<param name="delx">max allowed difference in x data, after alignment</param>
	<param name="dely">max allowed difference in y data, after alignment</param>
	<param name="psame">1 if %nreq row matches are found; 0 otherwise</param>
	<param name="debugflag">1 for debug output</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorContent(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This returns the color content in each component, which is
 a measure of the deviation from gray, and is defined
 as the difference between the component and the average of
 the other two components.  See the discussion at the
 top of this file.
 (2) The three numbers (rwhite, gwhite and bwhite) can be thought
 of as the values in the image corresponding to white.
 They are used to compensate for an unbalanced color white point.
 They must either be all 0 or all non-zero.  To turn this
 off, set them all to 0.
 (3) If the maximum component after white point correction,
 max(r,g,b), is less than mingray, all color components
 for that pixel are set to zero.
 Use mingray = 0 to turn off this filtering of dark pixels.
 (4) Therefore, use 0 for all four input parameters if the color
 magnitude is to be calculated without either white balance
 correction or dark filtering.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb or 8 bpp colormapped</param>
	<param name="rwhite">color value associated with white point</param>
	<param name="gwhite">color value associated with white point</param>
	<param name="bwhite">color value associated with white point</param>
	<param name="mingray">min gray value for which color is measured</param>
	<param name="ppixr">8 bpp red 'content'</param>
	<param name="ppixg">8 bpp green 'content'</param>
	<param name="ppixb">8 bpp blue 'content'</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorMagnitude(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For an RGB image, a gray pixel is one where all three components
 are equal.  We define the amount of color in an RGB pixel as
 a function depending on the absolute value of the differences
 between the three color components.  Consider the two largest
 of these differences.  The pixel component in common to these
 two differences is the color farthest from the other two.
 The color magnitude in an RGB pixel can be taken as one
 of these three definitions
 (a) The average of these two differences.  This is the
 average distance from the two components that are
 nearest to each other to the third component.
 (b) The minimum value of these two differences.  This is
 the intermediate value of the three distances between
 component values.  Stated otherwise, it is the
 maximum over all components of the minimum distance
 from that component to the other two components.
 (c) The maximum difference between component values.
 (2) As an example, suppose that R and G are the closest in
 magnitude.  Then the color is determined as either
 (a) The average distance of B from these two
 (|B - R| + |B - G|) / 2
 (b) The minimum distance of B from these two
 min(|B - R|, |B - G|).
 (c) The maximum distance of B from these two
 max(|B - R|, |B - G|)
 (3) The three methods for choosing the color magnitude from
 the components are selected with these flags
 (a) L_MAX_DIFF_FROM_AVERAGE_2
 (b) L_MAX_MIN_DIFF_FROM_2
 (c) L_MAX_DIFF
 (4) The three numbers (rwhite, gwhite and bwhite) can be thought
 of as the values in the image corresponding to white.
 They are used to compensate for an unbalanced color white point.
 They must either be all 0 or all non-zero.  To turn this
 off, set them all to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb or 8 bpp colormapped</param>
	<param name="rwhite">color value associated with white point</param>
	<param name="gwhite">color value associated with white point</param>
	<param name="bwhite">color value associated with white point</param>
	<param name="type">chooses the method for calculating the color magnitude L_MAX_DIFF_FROM_AVERAGE_2, L_MAX_MIN_DIFF_FROM_2, L_MAX_DIFF</param>
	<returns>pixd 8 bpp, amount of color in each source pixel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMaskOverColorPixels(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The generated mask identifies each pixel as either color or
 non-color.  For a pixel to be color, it must satisfy two
 constraints
 (a) The max difference between the r,g and b components must
 equal or exceed a threshold %threshdiff.
 (b) It must be at least %mindist (in an 8-connected way)
 from the nearest non-color pixel.
 (2) The distance constraint (b) is only applied if %mindist GT 1.
 For example, if %mindist == 2, the color pixels identified
 by (a) are eroded by a 3x3 Sel.  In general, the Sel size
 for erosion is 2  (%mindist - 1) + 1.
 Why have this constraint?  In scanned images that are
 essentially gray, color artifacts are typically introduced
 in transition regions near sharp edges that go from dark
 to light, so this allows these transition regions to be removed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb or 8 bpp colormapped</param>
	<param name="threshdiff">threshold for minimum of the max difference between components</param>
	<param name="mindist">minimum allowed distance from nearest non-color pixel</param>
	<returns>pixd 1 bpp, mask over color pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMaskOverColorRange(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb or 8 bpp colormapped</param>
	<param name="rmin">min and max allowed values for red component</param>
	<param name="rmax">min and max allowed values for red component</param>
	<param name="gmin"></param>
	<param name="gmax"></param>
	<param name="bmin"></param>
	<param name="bmax"></param>
	<returns>pixd 1 bpp, mask over color pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorFraction(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This function is asking the question to what extent does the
 image appear to have color?   The amount of color a pixel
 appears to have depends on both the deviation of the
 individual components from their average and on the average
 intensity itself.  For example, the color will be much more
 obvious with a small deviation from white than the same
 deviation from black.
 (2) Any pixel that meets these three tests is considered a
 colorful pixel
 (a) the lightest component must equal or exceed %darkthresh
 (b) the darkest component must not exceed %lightthresh
 (c) the max difference between components must equal or
 exceed %diffthresh.
 (3) The dark pixels are removed from consideration because
 they don't appear to have color.
 (4) The very lightest pixels are removed because if an image
 has a lot of "white", the color fraction will be artificially
 low, even if all the other pixels are colorful.
 (5) If pixfract is very small, there are few pixels that are neither
 black nor white.  If colorfract is very small, the pixels
 that are neither black nor white have very little color
 content.  The product 'pixfract  colorfract' gives the
 fraction of pixels with significant color content.
 (6) One use of this function is as a preprocessing step for median
 cut quantization (colorquant2.c), which does a very poor job
 splitting the color space into rectangular volume elements when
 all the pixels are near the diagonal of the color cube.  For
 octree quantization of an image with only gray values, the
 2^(level) octcubes on the diagonal are the only ones
 that can be occupied.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="darkthresh">threshold near black; if the lightest component is below this, the pixel is not considered in the statistics; typ. 20</param>
	<param name="lightthresh">threshold near white; if the darkest component is above this, the pixel is not considered in the statistics; typ. 244</param>
	<param name="diffthresh">thresh for the maximum difference between component value; below this the pixel is not considered to have sufficient color</param>
	<param name="factor">subsampling factor</param>
	<param name="ppixfract">fraction of pixels in intermediate brightness range that were considered for color content</param>
	<param name="pcolorfract">fraction of pixels that meet the criterion for sufficient color; 0.0 on error</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindColorRegions(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single[]@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This function tries to determine if there is a significant
 color or darker region on a scanned page image, where part
 of the image is background that is either white or reddish.
 This also allows extraction of regions of colored pixels that
 have a smaller red component than blue or green components.
 (2) If %pixm exists, pixels under its fg are combined with
 dark pixels to make a mask of pixels not to be considered
 as color candidates.
 (3) There are four thresholds.
 %lightthresh compute the average value of each rgb pixel,
 and make 10 buckets by value.  If the lightest bucket gray
 value is below %lightthresh, the image is not considered
 to have a light bg, and this returns 0.0 for %colorfract.
 %darkthresh ignore pixels darker than this (typ. fg text).
 We make a 1 bpp mask of these pixels, and then dilate it to
 remove all vestiges of fg from their vicinity.
 %mindiff consider pixels with either (b - r) or (g - r)
 being at least this value, as having color.
 %colordiff consider pixels where the (max - min) difference
 of the pixel components exceeds this value, as having color.
 (4) All components of color pixels that are touching the image
 border are removed.  Additionally, all pixels within some
 normalized distance %edgefract from the image border can
 be removed.  This insures that dark pixels near the edge
 of the image are not included.
 (5) This returns in %pcolorfract the fraction of pixels that have
 color and are not in the set consisting of an OR between
 %pixm and the dilated dark pixel mask.
 (6) No masks are returned unless light color pixels are found.
 If colorfract GT 0.0 and %pcolormask1 is defined, this returns
 a 1 bpp mask with fg pixels over the color background.
 This mask may have some holes in it.
 (7) If colorfract GT 0.0 and %pcolormask2 is defined, this returns
 a version of colormask1 where small holes have been filled.
 (8) To generate a boxa of rectangular regions from the overlap
 of components in the filtered mask
 boxa1 = pixConnCompBB(colormask2, 8);
 boxa2 = boxaCombineOverlaps(boxa1, NULL);
 This is done here in debug mode.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="pixm">1 bpp mask image</param>
	<param name="factor">subsample factor; integer GT= 1</param>
	<param name="lightthresh">threshold for component average in lightest of 10 buckets; typ. 210; -1 for default</param>
	<param name="darkthresh">threshold to eliminate dark pixels (e.g., text) from consideration; typ. 70; -1 for default.</param>
	<param name="mindiff">minimum difference (b - r) and (g - r), used to find blue or green pixels; typ. 10; -1 for default</param>
	<param name="colordiff">minimum difference in (max - min) component to qualify as a color pixel; typ. 90; -1 for default</param>
	<param name="edgefract">fraction of image half-width and half-height for which color pixels are ignored; typ. 0.05.</param>
	<param name="pcolorfract">fraction of 'color' pixels found</param>
	<param name="pcolormask1">mask over background color, if any</param>
	<param name="pcolormask2">filtered mask over background color</param>
	<param name="pixadb">debug intermediate results</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixNumSignificantGrayColors(System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This function is asking the question how many perceptually
 significant gray color levels is in this pix?
 A color level must meet 3 criteria to be significant
 ~ it can't be too close to black
 ~ it can't be too close to white
 ~ it must have at least some minimum fractional population
 (2) Use -1 for default values for darkthresh, lightthresh and minfract.
 (3) Choose default of darkthresh = 20, because variations in very
 dark pixels are not visually significant.
 (4) Choose default of lightthresh = 236, because document images
 that have been jpeg'd typically have near-white pixels in the
 8x8 jpeg blocks, and these should not be counted.  It is desirable
 to obtain a clean image by quantizing this noise away.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray</param>
	<param name="darkthresh">dark threshold for minimum intensity to be considered; typ. 20</param>
	<param name="lightthresh">threshold near white, for maximum intensity to be considered; typ. 236</param>
	<param name="minfract">minimum fraction of all pixels to include a level as significant; typ. 0.0001; should be LT 0.001</param>
	<param name="factor">subsample factor; integer GT= 1</param>
	<param name="pncolors">number of significant colors; 0 on error</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorsForQuantization(System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) This function finds a measure of the number of colors that are
 found in low-gradient regions of an image.  By its
 magnitude relative to some threshold (not specified in
 this function), it gives a good indication of whether
 quantization will generate posterization.   This number
 is larger for images with regions of slowly varying
 intensity (if 8 bpp) or color (if rgb). Such images, if
 quantized, may require dithering to avoid posterization,
 and lossless compression is then expected to be poor.
 (2) If pixs has a colormap, the number of colors returned is
 the number in the colormap.
 (3) It is recommended that document images be reduced to a width
 of 800 pixels before applying this function.  Then it can
 be expected that color detection will be fairly accurate
 and the number of colors will reflect both the content and
 the type of compression to be used.  For less than 15 colors,
 there is unlikely to be a halftone image, and lossless
 quantization should give both a good visual result and
 better compression.
 (4) When using the default threshold on the gradient (15),
 images (both gray and rgb) where ncolors is greater than
 about 15 will compress poorly with either lossless
 compression or dithered quantization, and they may be
 posterized with non-dithered quantization.
 (5) For grayscale images, or images without significant color,
 this returns the number of significant gray levels in
 the low-gradient regions.  The actual number of gray levels
 can be large due to jpeg compression noise in the background.
 (6) Similarly, for color images, the actual number of different
 (r,g,b) colors in the low-gradient regions (rather than the
 number of occupied level 4 octcubes) can be quite large, e.g.,
 due to jpeg compression noise, even for regions that appear
 to be of a single color.  By quantizing to level 4 octcubes,
 most of these superfluous colors are removed from the counting.
 (7) The image is tested for color.  If there is very little color,
 it is thresholded to gray and the number of gray levels in
 the low gradient regions is found.  If the image has color,
 the number of occupied level 4 octcubes is found.
 (8) The number of colors in the low-gradient regions increases
 monotonically with the threshold %thresh on the edge gradient.
 (9) Background grayscale and color quantization is often useful
 to achieve highly compressed images with little visible
 distortion.  However, gray or color washes (regions of
 low gradient) can defeat this approach to high compression.
 How can one determine if an image is expected to compress
 well using gray or color quantization?  We use the fact that
 gray washes, when quantized with less than 50 intensities,
 have posterization (visible boundaries between regions
 of uniform 'color') and poor lossless compression
 color washes, when quantized with level 4 octcubes,
 typically result in both posterization and the occupancy
 of many level 4 octcubes.
 Images can have colors either intrinsically or as jpeg
 compression artifacts.  This function reduces but does not
 completely eliminate measurement of jpeg quantization noise
 in the white background of grayscale or color images.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb; with or without colormap</param>
	<param name="thresh">binary threshold on edge gradient; 0 for default</param>
	<param name="pncolors">the number of colors found</param>
	<param name="piscolor">1 if significant color is found; 0 otherwise.  If pixs is 8 bpp, and does not have a colormap with color entries, this is 0</param>
	<param name="debug">1 to output masked image that is tested for colors; 0 otherwise</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixNumColors(System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This returns the actual number of colors found in the image,
 even if there is a colormap.  If %factor == 1 and the
 number of colors differs from the number of entries
 in the colormap, a warning is issued.
 (2) Use %factor == 1 to find the actual number of colors.
 Use %factor GT 1 to quickly find the approximate number of colors.
 (3) For d = 2, 4 or 8 bpp grayscale, this returns the number
 of colors found in the image in 'ncolors'.
 (4) For d = 32 bpp (rgb), if the number of colors is
 greater than 256, this returns 0 in 'ncolors'.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4, 8, 32 bpp</param>
	<param name="factor">subsampling factor; integer</param>
	<param name="pncolors">the number of colors found, or 0 if there are more than 256</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetMostPopulatedColors(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This finds the %ncolors most populated cubes in rgb colorspace,
 where the cube size depends on %sigbits as
 cube side = (256 GTGT sigbits)
 (2) The rgb color components are found at the center of the cube.
 (3) The output array of colors can be displayed using
 pixDisplayColorArray(array, ncolors, ...);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="sigbits">2-6, significant bits retained in the quantizer for each component of the input image</param>
	<param name="factor">subsampling factor; use 1 for no subsampling</param>
	<param name="ncolors">the number of most populated colors to select</param>
	<param name="parray">array of colors, each as 0xrrggbb00</param>
	<param name="pcmap">colormap of the colors</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSimpleColorQuantize(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If you want to do color quantization for real, use octcube
 or modified median cut.  This function shows that it is
 easy to make a simple quantizer based solely on the population
 in cells of a given size in rgb color space.
 (2) The %ncolors most populated cells at the %sigbits level form
 the colormap for quantizing, and this uses octcube indexing
 under the covers to assign each pixel to the nearest color.
 (3) %sigbits is restricted to 2, 3 and 4.  At the low end, the
 color discrimination is very crude; at the upper end, a set of
 similar colors can dominate the result.  Interesting results
 are generally found for %sigbits = 3 and ncolors ~ 20.
 (4) See also pixColorSegment() for a method of quantizing the
 colors to generate regions of similar color.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="sigbits">2-4, significant bits retained in the quantizer for each component of the input image</param>
	<param name="factor">subsampling factor; use 1 for no subsampling</param>
	<param name="ncolors">the number of most populated colors to select</param>
	<returns>pixd 8 bpp cmapped or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRGBHistogram(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This uses a simple, fast method of indexing into an rgb image.
 (2) The output is a 1D histogram of count vs. rgb-index, which
 uses red sigbits as the most significant and blue as the least.
 (3) This function produces the same result as pixMedianCutHisto().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="sigbits">2-6, significant bits retained in the quantizer for each component of the input image</param>
	<param name="factor">subsampling factor; use 1 for no subsampling</param>
	<returns>numa histogram of colors, indexed by RGB components, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makeRGBIndexTables(System.IntPtr@,System.IntPtr@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) These tables are used to map from rgb sample values to
 an rgb index, using
 rgbindex = rtab[rval] | gtab[gval] | btab[bval]
 where, e.g., if sigbits = 3, the index is a 9 bit integer
 r7 r6 r5 g7 g6 g5 b7 b6 b5
 </summary>
	<remarks>
	</remarks>
	<param name="prtab">256-entry index tables</param>
	<param name="pgtab">256-entry index tables</param>
	<param name="pbtab">256-entry index tables</param>
	<param name="sigbits">2-6, significant bits retained in the quantizer for each component of the input image</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getRGBFromIndex(System.UInt32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The %index is expressed in bits, based on the the
 %sigbits of the r, g and b components, as
 r7 r6 ... g7 g6 ... b7 b6 ...
 (2) The computed rgb values are in the center of the quantized cube.
 The extra bit that is OR'd accomplishes this.
 </summary>
	<remarks>
	</remarks>
	<param name="index">rgbindex</param>
	<param name="sigbits">2-6, significant bits retained in the quantizer for each component of the input image</param>
	<param name="prval">rgb values</param>
	<param name="pgval">rgb values</param>
	<param name="pbval">rgb values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixHasHighlightRed(System.IntPtr,System.Int32,System.Single,System.Single,System.Int32@,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) Pixels are identified as red if they satisfy two conditions
 (a) The components satisfy (R-B)/B GT %fthresh   (red or dark fg)
 (b) The red component satisfied R GT 128  (red or light bg)
 Masks are generated for (a) and (b), and the intersection
 gives the pixels that are red but not either light bg or
 dark fg.
 (2) A typical value for fract = 0.0001, which gives sensitivity
 to an image where a small fraction of the pixels are printed
 in red.
 (3) A typical value for fthresh = 2.5.  Higher values give less
 sensitivity to red, and fewer false positives.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="factor">subsampling; an integer GT= 1; use 1 for all pixels</param>
	<param name="fract">threshold fraction of all image pixels</param>
	<param name="fthresh">threshold on a function of the components; typ. ~2.5</param>
	<param name="phasred">1 if red pixels are above threshold</param>
	<param name="pratio">normalized fraction of threshold red pixels that is actually observed</param>
	<param name="ppixdb">seed pixel mask</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorGrayRegions(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates a new image, where some of the pixels in each
 box in the boxa are colorized.  See pixColorGray() for usage
 with %type and %thresh.  Note that %thresh is only used for
 rgb; it is ignored for colormapped images.
 (2) If the input image is colormapped, the new image will be 8 bpp
 colormapped if possible; otherwise, it will be converted
 to 32 bpp rgb.  Only pixels that are strictly gray will be
 colorized.
 (3) If the input image is not colormapped, it is converted to rgb.
 A "gray" value for a pixel is determined by averaging the
 components, and the output rgb value is determined from this.
 (4) This can be used in conjunction with pixHasHighlightRed() to
 add highlight color to a grayscale image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp gray, rgb, or colormapped</param>
	<param name="boxa">of regions in which to apply color</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="thresh">average value below/above which pixel is unchanged</param>
	<param name="rval">new color to paint</param>
	<param name="gval">new color to paint</param>
	<param name="bval">new color to paint</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorGray(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place operation; pixs is modified.
 If pixs is colormapped, the operation will add colors to the
 colormap.  Otherwise, pixs will be converted to 32 bpp rgb if
 it is initially 8 bpp gray.
 (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
 preserving antialiasing.
 If type == L_PAINT_DARK, it colorizes non-white pixels,
 preserving antialiasing.
 (3) If box is NULL, applies function to the entire image; otherwise,
 clips the operation to the intersection of the box and pix.
 (4) If colormapped, calls pixColorGrayCmap(), which applies the
 coloring algorithm only to pixels that are strictly gray.
 (5) For RGB, determines a "gray" value by averaging; then uses this
 value, plus the input rgb target, to generate the output
 pixel values.
 (6) thresh is only used for rgb; it is ignored for colormapped pix.
 If type == L_PAINT_LIGHT, use thresh = 0 if all pixels are to
 be colored (black pixels will be unaltered).
 In situations where there are a lot of black pixels,
 setting thresh GT 0 will make the function considerably
 more efficient without affecting the final result.
 If type == L_PAINT_DARK, use thresh = 255 if all pixels
 are to be colored (white pixels will be unaltered).
 In situations where there are a lot of white pixels,
 setting thresh LT 255 will make the function considerably
 more efficient without affecting the final result.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray, rgb or colormapped image</param>
	<param name="box">region in which to apply color; can be NULL</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="thresh">average value below/above which pixel is unchanged</param>
	<param name="rval">new color to paint</param>
	<param name="gval">new color to paint</param>
	<param name="bval">new color to paint</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorGrayMasked(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates a new image, where some of the pixels under
 FG in the mask are colorized.
 (2) See pixColorGray() for usage with %type and %thresh.  Note
 that %thresh is only used for rgb; it is ignored for
 colormapped images.  In most cases, the mask will be over
 the darker parts and %type == L_PAINT_DARK.
 (3) If pixs is colormapped this calls pixColorMaskedCmap(),
 which adds colors to the colormap for pixd; it only adds
 colors corresponding to strictly gray colors in the colormap.
 Otherwise, if pixs is 8 bpp gray, pixd will be 32 bpp rgb.
 (4) If pixs is 32 bpp rgb, for each pixel a "gray" value is
 found by averaging.  This average is then used with the
 input rgb target to generate the output pixel values.
 (5) This can be used in conjunction with pixHasHighlightRed() to
 add highlight color to a grayscale image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray, rgb or colormapped image</param>
	<param name="pixm">1 bpp mask, through which to apply color</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="thresh">average value below/above which pixel is unchanged</param>
	<param name="rval">new color to paint</param>
	<param name="gval">new color to paint</param>
	<param name="bval">new color to paint</param>
	<returns>pixd colorized, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSnapColor(System.IntPtr,System.IntPtr,System.UInt32,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) For inplace operation, call it this way
 pixSnapColor(pixs, pixs, ... )
 (2) For generating a new pixd
 pixd = pixSnapColor(NULL, pixs, ...)
 (3) If pixs has a colormap, it is handled by pixSnapColorCmap().
 (4) All pixels within 'diff' of 'srcval', componentwise,
 will be changed to 'dstval'.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs for in-place</param>
	<param name="pixs">colormapped or 8 bpp gray or 32 bpp rgb</param>
	<param name="srcval">color center to be selected for change 0xrrggbb00</param>
	<param name="dstval">target color for pixels 0xrrggbb00</param>
	<param name="diff">max absolute difference, applied to all components</param>
	<returns>pixd with all pixels within diff of pixval set to pixval, or pixd on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSnapColorCmap(System.IntPtr,System.IntPtr,System.UInt32,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) For inplace operation, call it this way
 pixSnapCcmap(pixs, pixs, ... )
 (2) For generating a new pixd
 pixd = pixSnapCmap(NULL, pixs, ...)
 (3) pixs must have a colormap.
 (4) All colors within 'diff' of 'srcval', componentwise,
 will be changed to 'dstval'.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs for in-place</param>
	<param name="pixs">colormapped</param>
	<param name="srcval">color center to be selected for change 0xrrggbb00</param>
	<param name="dstval">target color for pixels 0xrrggbb00</param>
	<param name="diff">max absolute difference, applied to all components</param>
	<returns>pixd with all pixels within diff of srcval set to dstval, or pixd on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixLinearMapToTargetColor(System.IntPtr,System.IntPtr,System.UInt32,System.UInt32)">
	<summary>
 Notes
 (1) For each component (r, b, g) separately, this does a piecewise
 linear mapping of the colors in pixs to colors in pixd.
 If rs and rd are the red src and dest components in %srcval and
 %dstval, then the range [0 ... rs] in pixs is mapped to
 [0 ... rd] in pixd.  Likewise, the range [rs ... 255] in pixs
 is mapped to [rd ... 255] in pixd.  And similarly for green
 and blue.
 (2) The mapping will in general change the hue of the pixels.
 However, if the src and dst targets are related by
 a transformation given by pixelFractionalShift(), the hue
 is invariant.
 (3) For inplace operation, call it this way
 pixLinearMapToTargetColor(pixs, pixs, ... )
 (4) For generating a new pixd
 pixd = pixLinearMapToTargetColor(NULL, pixs, ...)
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs for in-place</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="srcval">source color 0xrrggbb00</param>
	<param name="dstval">target color 0xrrggbb00</param>
	<returns>pixd with all pixels mapped based on the srcval/destval mapping, or pixd on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixelLinearMapToTargetColor(System.UInt32,System.UInt32,System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) This does this does a piecewise linear mapping of each
 component of %scolor to %dcolor, based on the relation
 between the components of %srcmap and %dstmap.  It is the
 same transformation, performed on a single color, as mapped
 on every pixel in a pix by pixLinearMapToTargetColor().
 (2) For each component, if the sval is larger than the smap,
 the dval will be pushed up from dmap towards white.
 Otherwise, dval will be pushed down from dmap towards black.
 This is because you can visualize the transformation as
 a linear stretching where smap moves to dmap, and everything
 else follows linearly with 0 and 255 fixed.
 (3) The mapping will in general change the hue of %scolor.
 However, if the %srcmap and %dstmap targets are related by
 a transformation given by pixelFractionalShift(), the hue
 will be invariant.
 </summary>
	<remarks>
	</remarks>
	<param name="scolor">rgb source color 0xrrggbb00</param>
	<param name="srcmap">source mapping color 0xrrggbb00</param>
	<param name="dstmap">target mapping color 0xrrggbb00</param>
	<param name="pdcolor">rgb dest color 0xrrggbb00</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixShiftByComponent(System.IntPtr,System.IntPtr,System.UInt32,System.UInt32)">
	<summary>
 Notes
 (1) For each component (r, b, g) separately, this does a linear
 mapping of the colors in pixs to colors in pixd.
 Let rs and rd be the red src and dest components in %srcval and
 %dstval, and rval is the red component of the src pixel.
 Then for all pixels in pixs, the mapping for the red
 component from pixs to pixd is
 if (rd LT= rs)   (shift toward black)
 rval --GT (rd/rs)  rval
 if (rd GT rs) (shift toward white)
 (255 - rval) --GT ((255 - rs)/(255 - rd))  (255 - rval)
 Thus if rd LT= rs, the red component of all pixels is
 mapped by the same fraction toward white, and if rd GT rs,
 they are mapped by the same fraction toward black.
 This is essentially a different linear TRC (gamma = 1)
 for each component.  The source and target color inputs are
 just used to generate the three fractions.
 (2) Note that this mapping differs from that in
 pixLinearMapToTargetColor(), which maps rs --GT rd and does
 a piecewise stretching in between.
 (3) For inplace operation, call it this way
 pixFractionalShiftByComponent(pixs, pixs, ... )
 (4) For generating a new pixd
 pixd = pixLinearMapToTargetColor(NULL, pixs, ...)
 (5) A simple application is to color a grayscale image.
 A light background can be colored using srcval = 0xffffff00
 and picking a target background color for dstval.
 A dark foreground can be colored by using srcval = 0x0
 and choosing a target foreground color for dstval.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs for in-place</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="srcval">source color 0xrrggbb00</param>
	<param name="dstval">target color 0xrrggbb00</param>
	<returns>pixd with all pixels mapped based on the srcval/destval mapping, or pixd on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixelShiftByComponent(System.Int32,System.Int32,System.Int32,System.UInt32,System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) This is a linear transformation that gives the same result
 on a single pixel as pixShiftByComponent() gives
 on a pix.  Each component is handled separately.  If
 the dest component is larger than the src, then the
 component is pushed toward 255 by the same fraction as
 the src --GT dest shift.
 </summary>
	<remarks>
	</remarks>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="srcval">source color 0xrrggbb00</param>
	<param name="dstval">target color 0xrrggbb00</param>
	<param name="ppixel">rgb value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixelFractionalShift(System.Int32,System.Int32,System.Int32,System.Single,System.UInt32@)">
	<summary>
 Notes
 (1) This transformation leaves the hue invariant, while changing
 the saturation and intensity.  It can be used for that
 purpose in pixLinearMapToTargetColor().
 (2) %fraction is in the range [-1 .... +1].  If %fraction LT 0,
 saturation is increased and brightness is reduced.  The
 opposite results if %fraction GT 0.  If %fraction == -1,
 the resulting pixel is black; %fraction == 1 results in white.
 </summary>
	<remarks>
	</remarks>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fraction">negative toward black; positive toward white</param>
	<param name="ppixel">rgb value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="depth">bpp, of pix</param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapCreateRandom(System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This sets up a colormap with random colors,
 where the first color is optionally black, the last color
 is optionally white, and the remaining colors are
 chosen randomly.
 (2) The number of randomly chosen colors is
 2^(depth) - haswhite - hasblack
 (3) Because rand() is seeded, it might disrupt otherwise
 deterministic results if also used elsewhere in a program.
 (4) rand() is not threadsafe, and will generate garbage if run
 on multiple threads at once -- though garbage is generally
 what you want from a random number generator!
 (5) Modern rand()s have equal randomness in low and high order
 bits, but older ones don't.  Here, we're just using rand()
 to choose colors for output.
 </summary>
	<remarks>
	</remarks>
	<param name="depth">bpp, of pix; 2, 4 or 8</param>
	<param name="hasblack">1 if the first color is black; 0 if no black</param>
	<param name="haswhite">1 if the last color is white; 0 if no white</param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapCreateLinear(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Colormap has equally spaced gray color values
 from black (0, 0, 0) to white (255, 255, 255).
 </summary>
	<remarks>
	</remarks>
	<param name="d">depth of pix for this colormap; 1, 2, 4 or 8</param>
	<param name="nlevels">valid in range [2, 2^d]</param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapCopy(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmaps"></param>
	<returns>cmapd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pcmap">set to null</param>
</member><member name="M:LeptonicaSharp.Natives.pixcmapAddColor(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This always adds the color if there is room.
 (2) The alpha component is 255 (opaque)
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="gval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="bval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapAddRGBA(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This always adds the color if there is room.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="gval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="bval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="aval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapAddNewColor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This only adds color if not already there.
 (2) The alpha component is 255 (opaque)
 (3) This returns the index of the new (or existing) color.
 (4) Returns 2 with a warning if unable to add this color;
 the caller should check the return value.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="gval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="bval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="pindex">index of color</param>
	<returns>0 if OK, 1 on error; 2 if unable to add color</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapAddNearestColor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This only adds color if not already there.
 (2) The alpha component is 255 (opaque)
 (3) If it's not in the colormap and there is no room to add
 another color, this returns the index of the nearest color.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="gval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="bval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="pindex">index of color</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapUsableColor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This checks if the color already exists or if there is
 room to add it.  It makes no change in the colormap.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="gval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="bval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="pusable">1 if usable; 0 if not</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapAddBlackOrWhite(System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This only adds color if not already there.
 (2) The alpha component is 255 (opaque)
 (3) This sets index to the requested color.
 (4) If there is no room in the colormap, returns the index
 of the closest color.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="color">0 for black, 1 for white</param>
	<param name="pindex">index of color; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapSetBlackAndWhite(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="setblack">0 for no operation; 1 to set darkest color to black</param>
	<param name="setwhite">0 for no operation; 1 to set lightest color to white</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetFreeCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<returns>free entries, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetDepth(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<returns>depth, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetMinDepth(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) On error, mindepth is returned as 0.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="pmindepth">minimum depth to support the colormap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapClear(System.IntPtr)">
	<summary>
 Notes
 (1) This removes the colors by setting the count to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetColor(System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="prval">each color value</param>
	<param name="pgval">each color value</param>
	<param name="pbval">each color value</param>
	<returns>0 if OK, 1 if not accessible caller should check</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetColor32(System.IntPtr,System.Int32,System.UInt32@)">
	<summary>
 Notes
 (1) The returned alpha channel value is 255.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="pval32">32-bit rgb color value</param>
	<returns>0 if OK, 1 if not accessible caller should check</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetRGBA(System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="prval">each color value</param>
	<param name="pgval">each color value</param>
	<param name="pbval">each color value</param>
	<param name="paval">each color value</param>
	<returns>0 if OK, 1 if not accessible caller should check</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetRGBA32(System.IntPtr,System.Int32,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="pval32">32-bit rgba color value</param>
	<returns>0 if OK, 1 if not accessible caller should check</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapResetColor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This resets sets the color of an entry that has already
 been set and included in the count of colors.
 (2) The alpha component is 255 (opaque)
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="rval">colormap entry to be reset; each number is in range [0, ... 255]</param>
	<param name="gval">colormap entry to be reset; each number is in range [0, ... 255]</param>
	<param name="bval">colormap entry to be reset; each number is in range [0, ... 255]</param>
	<returns>0 if OK, 1 if not accessible caller should check</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapSetAlpha(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This modifies the transparency of one entry in a colormap.
 The alpha component by default is 255 (opaque).
 This is used when extracting the colormap from a PNG file
 without decoding the image.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="aval">in range [0, ... 255]</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetIndex(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap colors to search for; each number is in range [0, ... 255]</param>
	<param name="gval">colormap colors to search for; each number is in range [0, ... 255]</param>
	<param name="bval">colormap colors to search for; each number is in range [0, ... 255]</param>
	<param name="pindex">found index</param>
	<returns>0 if found, 1 if not found caller must check</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapHasColor(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="pcolor">TRUE if cmap has color; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapIsOpaque(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="popaque">TRUE if fully opaque all entries are 255</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapIsBlackAndWhite(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="pblackwhite">TRUE if the cmap has only two colors black (0,0,0) and white (255,255,255)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapCountGrayColors(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) This counts the unique gray colors, including black and white.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="pngray">number of gray colors</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetRankIntensity(System.IntPtr,System.Single,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rankval">0.0 for darkest, 1.0 for lightest color</param>
	<param name="pindex">the index into the colormap that corresponds to the rank intensity color</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetNearestIndex(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Returns the index of the exact color if possible, otherwise the
 index of the color closest to the target color.
 (2) Nearest color is that which is the least sum-of-squares distance
 from the target color.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap colors to search for; each number is in range [0, ... 255]</param>
	<param name="gval">colormap colors to search for; each number is in range [0, ... 255]</param>
	<param name="bval">colormap colors to search for; each number is in range [0, ... 255]</param>
	<param name="pindex">the index of the nearest color</param>
	<returns>0 if OK, 1 on error caller must check</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetNearestGrayIndex(System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This should be used on gray colormaps.  It uses only the
 green value of the colormap.
 (2) Returns the index of the exact color if possible, otherwise the
 index of the color closest to the target color.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="val">gray value to search for; in range [0, ... 255]</param>
	<param name="pindex">the index of the nearest color</param>
	<returns>0 if OK, 1 on error caller must check</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetDistanceToColor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Returns the L2 distance (squared) between the color at index i
 and the target color.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="rval">target color</param>
	<param name="gval">target color</param>
	<param name="bval">target color</param>
	<param name="pdist">the distance from the cmap entry to target</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGetRangeValues(System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) Returns, for selected components (or the average), the
 the extreme values (min and/or max) and their indices
 that are found in the cmap.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="pminval">minimum value of component</param>
	<param name="pmaxval">maximum value of component</param>
	<param name="pminindex">index of minimum value</param>
	<param name="pmaxindex">index of maximum value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGrayToColor(System.UInt32)">
	<summary>
 Notes
 (1) This creates a colormap that maps from gray to
 a specific color.  In the mapping, each component
 is faded to white, depending on the gray value.
 (2) In use, this is simply attached to a grayscale pix
 to give it the input color.
 </summary>
	<remarks>
	</remarks>
	<param name="color"></param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapColorToGray(System.IntPtr,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This creates a gray colormap from an arbitrary colormap.
 (2) In use, attach the output gray colormap to the pix
 (or a copy of it) that provided the input colormap.
 </summary>
	<remarks>
	</remarks>
	<param name="cmaps"></param>
	<param name="rwt">non-negative; these should add to 1.0</param>
	<param name="gwt">non-negative; these should add to 1.0</param>
	<param name="bwt">non-negative; these should add to 1.0</param>
	<returns>cmap gray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapConvertTo4(System.IntPtr)">
	<summary>
 Notes
 (1) This converts a 2 bpp colormap to 4 bpp.  The colors
 are the same; the output colormap entry array has size 16.
 </summary>
	<remarks>
	</remarks>
	<param name="cmaps">colormap for 2 bpp pix</param>
	<returns>cmapd   (4 bpp)</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapConvertTo8(System.IntPtr)">
	<summary>
 Notes
 (1) This converts a 2 bpp or 4 bpp colormap to 8 bpp.  The colors
 are the same; the output colormap entry array has size 256.
 </summary>
	<remarks>
	</remarks>
	<param name="cmaps">colormap for 2 bpp or 4 bpp pix</param>
	<returns>cmapd   (8 bpp)</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization of pixcmap; in ascii</param>
	<param name="size">of data in bytes; can use strlen to get it</param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="cmap"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream    \param[in]    cmap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a pixcmap in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized pixcmap; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="cmap"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapToArrays(System.IntPtr,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="prmap">colormap arrays</param>
	<param name="pgmap">colormap arrays</param>
	<param name="pbmap">colormap arrays</param>
	<param name="pamap">alpha array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapToRGBTable(System.IntPtr,System.IntPtr@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="ptab">table of rgba values for the colormap</param>
	<param name="pncolors">size of table</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapSerializeToMemory(System.IntPtr,System.Int32,System.Int32@,System.IntPtr@)">
	<summary>
 Notes
 (1) When serializing to store in a pdf, use %cpc = 3.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="cpc">components/color 3 for rgb, 4 for rgba</param>
	<param name="pncolors">number of colors in table</param>
	<param name="pdata">binary string, cpc bytes per color</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapDeserializeFromMemory(System.Byte[],System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">binary string, 3 or 4 bytes per color</param>
	<param name="cpc">components/color 3 for rgb, 4 for rgba</param>
	<param name="ncolors"></param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapConvertToHex(System.Byte[],System.Int32)">
	<summary>
 Notes
 (1) The number of bytes in %data is 3  ncolors.
 (2) Output is in form
 LT r0g0b0 r1g1b1 ... rngnbn GT
 where r0, g0, b0 ... are each 2 bytes of hex ascii
 (3) This is used in pdf files to express the colormap as an
 array in ascii (human-readable) format.
 </summary>
	<remarks>
	</remarks>
	<param name="data">binary serialized data</param>
	<param name="ncolors">in colormap</param>
	<returns>hexdata bracketed, space-separated ascii hex string, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapGammaTRC(System.IntPtr,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place transform
 (2) See pixGammaTRC() and numaGammaTRC() in enhance.c
 for description and use of transform
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="gamma">gamma correction; must be GT 0.0</param>
	<param name="minval">input value that gives 0 for output; can be LT 0</param>
	<param name="maxval">input value that gives 255 for output; can be GT 255</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapContrastTRC(System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) This is an in-place transform
 (2) See pixContrastTRC() and numaContrastTRC() in enhance.c
 for description and use of transform
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="factor">generally between 0.0 [no enhancement] and 1.0, but can be larger than 1.0</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapShiftIntensity(System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) This is an in-place transform
 (2) It does a proportional shift of the intensity for each color.
 (3) If fraction LT 0.0, it moves all colors towards (0,0,0).
 This darkens the image.
 If fraction GT 0.0, it moves all colors towards (255,255,255)
 This fades the image.
 (4) The equivalent transform can be accomplished with pixcmapGammaTRC(),
 but it is considerably more difficult (see numaGammaTRC()).
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="fraction">between -1.0 and +1.0</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapShiftByComponent(System.IntPtr,System.UInt32,System.UInt32)">
	<summary>
 Notes
 (1) This is an in-place transform
 (2) It implements pixelShiftByComponent() for each color.
 The mapping is specified by srcval and dstval.
 (3) If a component decreases, the component in the colormap
 decreases by the same ratio.  Likewise for increasing, except
 all ratios are taken with respect to the distance from 255.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="srcval">source color 0xrrggbb00</param>
	<param name="dstval">target color 0xrrggbb00</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorMorph(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does the morph operation on each component separately,
 and recombines the result.
 (2) Sel is a brick with all elements being hits.
 (3) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="type">L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, or L_MORPH_CLOSE</param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOctreeColorQuant(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 I found one description in the literature of octree color
 quantization, using progressive truncation of the octree,
 by M. Gervautz and W. Purgathofer in Graphics Gems, pp.
 287-293, ed. A. Glassner, Academic Press, 1990.
 Rather than setting up a fixed partitioning of the color
 space ab initio, as we do here, they allow the octree to be
 progressively truncated as new pixels are added.  They
 need to set up some data structures that are traversed
 with the addition of each 24 bit pixel, in order to decide
 either 1) in which cluster (sub-branch of the octree to put
 the pixel, or 2 whether to truncate the octree further
 to place the pixel in an existing cluster, or 3 which
 two existing clusters should be merged so that the pixel
 can be left to start a truncated leaf of the octree.  Such dynamic
 truncation is considerably more complicated, and Gervautz et
 al. did not explain how they did it in anywhere near the
 detail required to check their implementation.
 The simple method in pixFixedOctcubeQuant256 is very
 fast, and with dithering the results are good, but you
 can do better if the color clusters are selected adaptively
 from the image.  We want a method that makes much better
 use of color samples in regions of color space with high
 pixel density, while also fairly representing small numbers
 of color pixels in low density regions.  Such adaptation
 requires two passes through the image the first for generating
 the pruned tree of color cubes and the second for computing the index
 into the color table for each pixel.
 A relatively simple adaptive method is pixOctreeQuantByPopulation.
 That function first determines if the image has very few colors,
 and, if so, quantizes to those colors.  If there are more than
 256 colors, it generates a histogram of octcube leaf occupancy
 at level 4, chooses the 192 most populated such leaves as
 the first 192 colors, and sets the remaining 64 colors to the
 residual average pixel values in each of the 64 level 2 octcubes.
 This is a bit faster than pixOctreeColorQuant, and does very
 well without dithering, but for most images with dithering it
 is clearly inferior.
 We now describe pixOctreeColorQuant.  The first pass is done
 on a subsampled image, because we do not need to use all the
 pixels in the image to generate the tree.  Subsampling
 down to 0.25 1/16 of the pixels makes the program run
 about 1.3 times faster.
 Instead of dividing the color space into 256 equal-sized
 regions, we initially divide it into 2^12 or 2^15 or 2^18
 equal-sized octcubes.  Suppose we choose to use 2^18 octcubes.
 This gives us 6 octree levels.  We then prune back,
 starting from level 6.  For every cube at level 6, there
 are 8 cubes at level 5.  Call the operation of putting a
 cube aside as a color table entry CTE a "saving."
 We use a in general level-dependent threshold, and save
 those level 6 cubes that are above threshold.
 The rest are combined into the containing level 5 cube.
 If between 1 and 7 level 6 cubes within a level 5
 cube have been saved by thresholding, then the remaining
 level 6 cubes in that level 5 cube are automatically
 saved as well, without applying a threshold.  This greatly
 simplifies both the description of the CTEs and the later
 classification of each pixel as belonging to a CTE.
 This procedure is iterated through every cube, starting at
 level 5, and then 4, 3, and 2, successively.  The result is that
 each CTE contains the entirety of a set of from 1 to 7 cubes
 from a given level that all belong to a single cube at the
 level above.   We classify the CTEs in terms of the
 condition in which they are made as either being "threshold"
 or "residual."  They are "threshold" CTEs if no subcubes
 are CTEs that is, they contain every pixel within the cube
 and the number of pixels exceeds the threshold for making
 a CTE.  They are "residual" CTEs if at least one but not more
 than 7 of the subcubes have already been determined to be CTEs;
 this happens automatically -- no threshold is applied.
 If all 8 subcubes are determined to be CTEs, the cube is
 marked as having all pixels accounted for 'bleaf' = 1 but
 is not saved as a CTE.
 We stop the pruning at level 2, at which there are 64
 sub-cubes.  Any pixels not already claimed in a CTE are
 put in these cubes.
 As the cubes are saved as color samples in the color table,
 the number of remaining pixels P and the number of
 remaining colors in the color table N are recomputed,
 along with the average number of pixels P/N ppc to go in
 each of the remaining colors.  This running average number is
 used to set the threshold at the current level.
 Because we are going to very small cubes at levels 6 or 5,
 and will dither the colors for errors, it is not necessary
 to compute the color center of each cluster; we can simply
 use the center of the cube.  This gives us a minimax error
 condition the maximum error is half the width of the
 level 2 cubes -- 32 color values out of 256 -- for each color
 sample.  In practice, most of the pixels will be very much
 closer to the center of their cells.  And with dithering,
 the average pixel color in a small region will be closer still.
 Thus with the octree quantizer, we are able to capture
 regions of high color pdf probability density function in small
 but accurate CTEs, and to have only a small number of pixels
 that end up a significant distance with a guaranteed maximum
 from their true color.
 How should the threshold factor vary?  Threshold factors
 are required for levels 2, 3, 4 and 5 in the pruning stage.
 The threshold for level 5 is actually applied to cubes at
 level 6, etc.  From various experiments, it appears that
 the results do not vary appreciably for threshold values near 1.0.
 If you want more colors in smaller cubes, the threshold
 factors can be set lower than 1.0 for cubes at levels 4 and 5.
 However, if the factor is set much lower than 1.0 for
 levels 2 and 3, we can easily run out of colors.
 We put aside 64 colors in the calculation of the threshold
 values, because we must have 64 color centers at level 2,
 that will have very few pixels in most of them.
 If we reduce the factor for level 5 to 0.4, this will
 generate many level 6 CTEs, and consequently
 many residual cells will be formed up from those leaves,
 resulting in the possibility of running out of colors.
 Remember, the residual CTEs are mandatory, and are formed
 without using the threshold, regardless of the number of
 pixels that are absorbed.
 The implementation logically has four parts
 1 accumulation into small, fixed cells
 2 pruning back into selected CTE cubes
 3 organizing the CTEs for fast search to find
 the CTE to which any image pixel belongs
 4 doing a second scan to code the image pixels by CTE
 Step 1 is straightforward; we use 2^15 cells.
 We've already discussed how the pruning step 2 will be performed.
 Steps 3) and (4 are related, in that the organization
 used by step 3 determines how the search actually
 takes place for each pixel in step 4.
 There are many ways to do step 3.  Let's explore a few.
 a The simplest is to order the cubes from highest occupancy
 to lowest, and traverse the list looking for the deepest
 match.  To make this more efficient, so that we know when
 to stop looking, any cube that has separate CTE subcubes
 would be marked as such, so that we know when we hit a
 true leaf.
 b Alternatively, we can order the cubes by highest
 occupancy separately each level, and work upward,
 starting at level 5, so that when we find a match we
 know that it will be correct.
 c Another approach would be to order the cubes by
 "address" and use a hash table to find the cube
 corresponding to a pixel color.  I don't know how to
 do this with a variable length address, as each CTE
 will have 3n bits, where n is the level.
 d Another approach entirely is to put the CTE cubes into
 a tree, in such a way that starting from the root, and
 using 3 bits of address at a time, the correct branch of
 each octree can be taken until a leaf is found.  Because
 a given cube can be both a leaf and also have branches
 going to sub-cubes, the search stops only when no
 marked subcubes have addresses that match the given pixel.
 In the tree method, we can start with a dense infrastructure,
 and place the leaves corresponding to the N colors
 in the tree, or we can grow from the root only those
 branches that end directly on leaves.
 What we do here is to take approach d, and implement the tree
 "virtually", as a set of arrays, one array for each level
 of the tree.   Initially we start at level 5, an array with
 2^15 cubes, each with 8 subcubes.  We then build nodes at
 levels closer to the root; at level 4 there are 2^12 nodes
 each with 8 subcubes; etc.  Using these arrays has
 several advantages
 ~  We don't need to keep track of links between cubes
 and subcubes, because we can use the canonical
 addressing on the cell arrays directly to determine
 which nodes are parent cubes and which are sub-cubes.
 ~  We can prune directly on this tree
 ~  We can navigate the pruned tree quickly to classify
 each pixel in the image.
 Canonical addressing guarantees that the i-th node at level k
 has 8 subnodes given by the 8i ... 8i+7 nodes at level k+1.
 The pruning step works as follows.  We go from the lowest
 level up.  At each level, the threshold is found from the
 product of a factor near 1.0 and the ratio of unmarked pixels
 to remaining colors minus the 64.  We march through
 the space, sequentially considering a cube and its 8 subcubes.
 We first check those subcubes that are not already
 marked as CTE to see if any are above threshold, and if so,
 generate a CTE and mark them as such.
 We then determine if any of the subcubes have been marked.
 If so, and there are subcubes that are not marked,
 we generate a CTE for the cube from the remaining unmarked
 subcubes; this is mandatory and does not depend on how many
 pixels are in the set of subcubes.  If none of the subcubes
 are marked, we aggregate their pixels into the cube
 containing them, but do not mark it as a CTE; that
 will be determined when iterating through the next level up.
 When all the pixels in a cube are accounted for in one or more
 colors, we set the boolean 'bleaf' to true.  This is the
 flag used to mark the cubes in the pruning step.  If a cube
 is marked, and all 8 subcubes are marked, then it is not
 itself given a CTE because all pixels have already been
 accounted for.
 Note that the pruning of the tree and labelling of the CTEs
 step 2 accomplishes step 3 implicitly, because the marked
 and pruned tree is ready for use in labelling each pixel
 in step 4.  We now, for every pixel in the image, traverse
 the tree from the root, looking for the lowest cube that is a leaf.
 At each level we have a cube and subcube.  If we reach a subcube
 leaf that is marked 0, we know that the color is stored in the
 cube above, and we've found the CTE.  Otherwise, the subcube
 leaf is marked 1.  If we're at the last level, we've reached
 the final leaf and must use it.  Otherwise, continue the
 process at the next level down.
 For robustness, efficiency and high quality output, we do the following
 (1) Measure the color content of the image.  If there is very little
 color, quantize in grayscale.
 (2) For efficiency, build the octree with a subsampled image if the
 image is larger than some threshold size.
 (3) Reserve an extra set of colors to prevent running out of colors
 when pruning the octree; specifically, during the assignment
 of those level 2 cells out of the 64 that have unassigned
 pixels.  The problem of running out is more likely to happen
 with small images, because the estimation we use for the
 number of pixels available is not accurate.
 (4) In the unlikely event that we run out of colors, the dithered
 image can be very poor.  As this would only happen with very
 small images, and dithering is not particularly noticeable with
 such images, turn it off.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; 24-bit color</param>
	<param name="colors">in colormap; some number in range [128 ... 256]; the actual number of colors used will be smaller</param>
	<param name="ditherflag">1 to dither, 0 otherwise</param>
	<returns>pixd 8 bpp with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOctreeColorQuantGeneral(System.IntPtr,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) The parameters %validthresh and %colorthresh are used to
 determine if color quantization should be used on an image,
 or whether, instead, it should be quantized in grayscale.
 If the image has very few non-white and non-black pixels, or
 if those pixels that are non-white and non-black are all
 very close to either white or black, it is usually better
 to treat the color as accidental and to quantize the image
 to gray only.  These parameters are useful if you know
 something a priori about the image.  Perhaps you know that
 there is only a very small fraction of color pixels, but they're
 important to preserve; then you want to use a smaller value for
 these parameters.  To disable conversion to gray and force
 color quantization, use %validthresh = 0.0 and %colorthresh = 0.0.
 (2) See pixOctreeColorQuant() for algorithmic and implementation
 details.  This function has a more general interface.
 (3) See pixColorFraction() for computing the fraction of pixels
 that are neither white nor black, and the fraction of those
 pixels that have little color.  From the documentation there
 If pixfract is very small, there are few pixels that are
 neither black nor white.  If colorfract is very small,
 the pixels that are neither black nor white have very
 little color content.  The product 'pixfract  colorfract'
 gives the fraction of pixels with significant color content.
 We test against the product %validthresh  %colorthresh
 to find color in images that have either very few
 intermediate gray pixels or that have many such gray pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; 24-bit color</param>
	<param name="colors">in colormap; some number in range [128 ... 240]; the actual number of colors used will be smaller</param>
	<param name="ditherflag">1 to dither, 0 otherwise</param>
	<param name="validthresh">minimum fraction of pixels neither near white nor black, required for color quantization; typically ~0.01, but smaller for images that have color but are nearly all white</param>
	<param name="colorthresh">minimum fraction of pixels with color that are not near white or black, that are required for color quantization; typ. ~0.01, but smaller for images that have color along with a significant fraction of gray</param>
	<returns>pixd 8 bit with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makeRGBToIndexTables(System.IntPtr@,System.IntPtr@,System.IntPtr@,System.Int32)">
	<summary>
 Set up tables.  e.g., for cqlevels = 5, we need an integer 0 LT i LT 2^15
 rtab = 0  i7  0   0  i6  0   0  i5  0   0   i4  0   0   i3  0   0
 gtab = 0  0   i7  0   0  i6  0   0  i5  0   0   i4  0   0   i3  0
 btab = 0  0   0   i7  0  0   i6  0  0   i5  0   0   i4  0   0   i3
 The tables are then used to map from rbg --GT index as follows
 index = 0  r7  g7  b7  r6  g6  b6  r5  g5  b5  r4  g4  b4  r3  g3  b3
 e.g., for cqlevels = 4, we map to
 index = 0  0   0   0   r7  g7  b7  r6  g6  b6  r5  g5  b5  r4  g4  b4
 This may look a bit strange.  The notation 'r7' means the MSBit of
 the r value which has 8 bits, going down from r7 to r0.
 Keep in mind that r7 is actually the r component bit for level 1 of
 the octtree.  Level 1 is composed of 8 octcubes, represented by
 the bits r7 g7 b7, which divide the entire color space into
 8 cubes.  At level 2, each of these 8 octcubes is further divided into
 8 cubes, each labeled by the second most significant bits r6 g6 b6
 of the rgb color.
 </summary>
	<remarks>
	</remarks>
	<param name="prtab">tables</param>
	<param name="pgtab">tables</param>
	<param name="pbtab">tables</param>
	<param name="cqlevels">can be 1, 2, 3, 4, 5 or 6</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getOctcubeIndexFromRGB(System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32@)">
	<summary>
 Notes
 No error checking!
 </summary>
	<remarks>
	</remarks>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="rtab">generated with makeRGBToIndexTables()</param>
	<param name="gtab">generated with makeRGBToIndexTables()</param>
	<param name="btab">generated with makeRGBToIndexTables()</param>
	<param name="pindex">found index</param>
</member><member name="M:LeptonicaSharp.Natives.pixOctreeQuantByPopulation(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This color quantization method works very well without
 dithering, using octcubes at two different levels
 (a) the input %level, which is either 3 or 4
 (b) level 2 (64 octcubes to cover the entire color space)
 (2) For best results, using %level = 4 is recommended.
 Why do we provide an option for using level 3?  Because
 there are 512 octcubes at level 3, and for many images
 not more than 256 are filled.  As a result, on some images
 a very accurate quantized representation is possible using
 %level = 3.
 (3) This first breaks up the color space into octcubes at the
 input %level, and computes, for each octcube, the average
 value of the pixels that are in it.
 (4) Then there are two possible situations
 (a) If there are not more than 256 populated octcubes,
 it returns a cmapped pix with those values assigned.
 (b) Otherwise, it selects 192 octcubes containing the largest
 number of pixels and quantizes pixels within those octcubes
 to their average.  Then, to handle the residual pixels
 that are not in those 192 octcubes, it generates a
 level 2 octree consisting of 64 octcubes, and within
 each octcube it quantizes the residual pixels to their
 average within each of those level 2 octcubes.
 (5) Unpopulated level 2 octcubes are represented in the colormap
 by their centers.  This, of course, has no effect unless
 dithering is used for the output image.
 (6) The depth of pixd is the minimum required to support the
 number of colors found at %level; namely, 2, 4 or 8.
 (7) This function works particularly well on images such as maps,
 where there are a relatively small number of well-populated
 colors, but due to antialiasing and compression artifacts
 there may be a large number of different colors.  This will
 pull out and represent accurately the highly populated colors,
 while still making a reasonable approximation for the others.
 (8) The highest level of octcubes allowed is 4.  Use of higher
 levels typically results in having a small fraction of
 pixels in the most populated 192 octcubes.  As a result,
 most of the pixels are represented at level 2, which is
 not sufficiently accurate.
 (9) Dithering shows artifacts on some images.  If you plan to
 dither, pixOctreeColorQuant() and pixFixedOctcubeQuant256()
 usually give better results.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="level">significant bits for each of RGB; valid for {3,4}, Use 0 for default (level 4; recommended</param>
	<param name="ditherflag">1 to dither, 0 otherwise</param>
	<returns>pixd quantized to octcubes or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOctreeQuantNumColors(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 pixOctreeColorQuant is very flexible in terms of the relative
 depth of different cubes of the octree.   By contrast, this function,
 pixOctreeQuantNumColors is also adaptive, but it supports octcube
 leaves at only two depths a smaller depth that guarantees
 full coverage of the color space and octcubes at one level
 deeper for more accurate colors.  Its main virutes are simplicity
 and speed, which are both derived from the natural indexing of
 the octcubes from the RGB values.
 Before describing pixOctreeQuantNumColors, consider an even simpler
 approach for 4 bpp with either 8 or 16 colors.  With 8 colors,
 you simply go to level 1 octcubes and use the average color
 found in each cube.  For 16 colors, you find which of the three
 colors has the largest variance at the second level, and use two
 indices for that color.  The result is quite poor, because 1 some
 of the cubes are nearly empty and 2 you don't get much color
 differentiation for the extra 8 colors.  Trust me, this method may
 be simple, but it isn't worth anything.
 In pixOctreeQuantNumColors, we generate colormapped images at
 either 4 bpp or 8 bpp.  For 4 bpp, we have a minimum of 8 colors
 for the level 1 octcubes, plus up to 8 additional colors that
 are determined from the level 2 popularity.  If the number of colors
 is between 8 and 16, the output is a 4 bpp image.  If the number of
 colors is greater than 16, the output is a 8 bpp image.
 We use a priority queue, implemented with a heap, to select the
 requisite number of most populated octcubes at the deepest level
 level 2 for 64 or fewer colors; level 3 for more than 64 colors.
 These are combined with one color for each octcube one level above,
 which is used to span the color space of octcubes that were not
 included at the deeper level.
 If the deepest level is 2, we combine the popular level 2 octcubes
 out of a total of 64 with the 8 level 1 octcubes.  If the deepest
 level is 3, we combine the popular level 3 octcubes out of a
 total 512 with the 64 level 2 octcubes that span the color space.
 In the latter case, we require a minimum of 64 colors for the level 2
 octcubes, plus up to 192 additional colors determined from level 3
 popularity.
 The parameter 'maxlevel' is the deepest octcube level that is used.
 The implementation also uses two LUTs, which are employed in
 two successive traversals of the dest image.  The first maps
 from the src octindex at 'maxlevel' to the color table index,
 which is the value that is stored in the 4 or 8 bpp dest pixel.
 The second LUT maps from that colormap value in the dest to a
 new colormap value for a minimum sized colormap, stored back in
 the dest.  It is used to remove any color map entries that
 correspond to color space regions that have no pixels in the
 source image.  These regions can be either from the higher level
 e.g., level 1 for 4 bpp, or from octcubes at 'maxlevel' that
 are unoccupied.  This remapping results in the minimum number
 of colors used according to the constraints induced by the
 input 'maxcolors'.  We also compute the average R, G and B color
 values in each region of the color space represented by a
 colormap entry, and store them in the colormap.
 The maximum number of colors is input, which determines the
 following properties of the dest image and octcube regions used
 Number of colors   dest image depth   maxlevel
 ----------------   ----------------   --------
 8 to 16   4 bpp   2
 17 to 64  8 bpp   2
 65 to 256 8 bpp   3
 It may turn out that the number of extra colors, beyond the
 minimum 8 and 64 for maxlevel 2 and 3, respectively, is larger
 than the actual number of occupied cubes at these levels
 In that case, all the pixels are contained in this
 subset of cubes at maxlevel, and no colormap colors are needed
 to represent the remainder pixels one level above.  Thus, for
 example, in use one often finds that the pixels in an image
 occupy less than 192 octcubes at level 3, so they can be represented
 by a colormap for octcubes at level 3 only.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="maxcolors">8 to 256; the actual number of colors used may be less than this</param>
	<param name="subsample">factor for computing color distribution; use 0 for default</param>
	<returns>pixd 4 or 8 bpp, colormapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOctcubeQuantMixedWithGray(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Generates a colormapped image, where the colormap table values
 have two components octcube values representing pixels with
 color content, and grayscale values for the rest.
 (2) The threshold (delta) is the maximum allowable difference of
 the max abs value of | r - g |, | r - b | and | g - b |.
 (3) The octcube values are the averages of all pixels that are
 found in the octcube, and that are far enough from gray to
 be considered color.  This can roughly be visualized as all
 the points in the rgb color cube that are not within a "cylinder"
 of diameter approximately 'delta' along the main diagonal.
 (4) We want to guarantee full coverage of the rgb color space; thus,
 if the output depth is 4, the octlevel is 1 (2 x 2 x 2 = 8 cubes)
 and if the output depth is 8, the octlevel is 2 (4 x 4 x 4
 = 64 cubes).
 (5) Consequently, we have the following constraint on the number
 of allowed gray levels for 4 bpp, 8; for 8 bpp, 192.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="depth">of output pix</param>
	<param name="graylevels">graylevels (must be GT 1)</param>
	<param name="delta">threshold for deciding if a pix is color or gray</param>
	<returns>pixd     quantized to octcube and gray levels or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFixedOctcubeQuant256(System.IntPtr,System.Int32)">
	<summary>
 Notes
 This simple 1-pass color quantization works by breaking the
 color space into 256 pieces, with 3 bits quantized for each of
 red and green, and 2 bits quantized for blue.  We shortchange
 blue because the eye is least sensitive to blue.  This
 division of the color space is into two levels of octrees,
 followed by a further division by 4 not 8, where both
 blue octrees have been combined in the third level.
 The color map is generated from the 256 color centers by
 taking the representative color to be the center of the
 cell volume.  This gives a maximum error in the red and
 green values of 16 levels, and a maximum error in the
 blue sample of 32 levels.
 Each pixel in the 24-bit color image is placed in its containing
 cell, given by the relevant MSbits of the red, green and blue
 samples.  An error-diffusion dithering is performed on each
 color sample to give the appearance of good average local color.
 Dithering is required; without it, the contouring and visible
 color errors are very bad.
 I originally implemented this algorithm in two passes,
 where the first pass was used to compute the weighted average
 of each sample in each pre-allocated region of color space.
 The idea was to use these centroids in the dithering algorithm
 of the second pass, to reduce the average error that was
 being dithered.  However, with dithering, there is
 virtually no difference, so there is no reason to make the
 first pass.  Consequently, this 1-pass version just assigns
 the pixels to the centers of the pre-allocated cells.
 We use dithering to spread the difference between the sample
 value and the location of the center of the cell.  For speed
 and simplicity, we use integer dithering and propagate only
 to the right, down, and diagonally down-right, with ratios
 3/8, 3/8 and 1/4, respectively.  The results should be nearly
 as good, and a bit faster, with propagation only to the right
 and down.
 The algorithm is very fast, because there is no search,
 only fast generation of the cell index for each pixel.
 We use a simple mapping from the three 8 bit rgb samples
 to the 8 bit cell index; namely, r7 r6 r5 g7 g6 g5 b7 b6.
 This is not in an octcube format, but it doesn't matter.
 There are no storage requirements.  We could keep a
 running average of the center of each sample in each
 cluster, rather than using the center of the cell, but
 this is just extra work, esp. with dithering.
 This method gives surprisingly good results with dithering.
 However, without dithering, the loss of color accuracy is
 evident in regions that are very light or that have subtle
 blending of colors.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; 24-bit color</param>
	<param name="ditherflag">1 for dithering; 0 for no dithering</param>
	<returns>pixd 8 bit with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFewColorsOctcubeQuant1(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Generates a colormapped image, where the colormap table values
 are the averages of all pixels that are found in the octcube.
 (2) This fails if there are more than 256 colors (i.e., more
 than 256 occupied octcubes).
 (3) Often level 3 (512 octcubes) will succeed because not more
 than half of them are occupied with 1 or more pixels.
 (4) The depth of the result, which is either 2, 4 or 8 bpp,
 is the minimum required to hold the number of colors that
 are found.
 (5) This can be useful for quantizing orthographically generated
 images such as color maps, where there may be more than 256 colors
 because of aliasing or jpeg artifacts on text or lines, but
 there are a relatively small number of solid colors.  Then,
 use with level = 3 can often generate a compact and accurate
 representation of the original RGB image.  For this purpose,
 it is better than pixFewColorsOctcubeQuant2(), because it
 uses the average value of pixels in the octcube rather
 than the first found pixel.  It is also simpler to use,
 because it generates the histogram internally.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="level">significant bits for each of RGB; valid in [1...6]</param>
	<returns>pixd quantized to octcube or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFewColorsOctcubeQuant2(System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Generates a colormapped image, where the colormap table values
 are the averages of all pixels that are found in the octcube.
 (2) This fails if there are more than 256 colors (i.e., more
 than 256 occupied octcubes).
 (3) Often level 3 (512 octcubes) will succeed because not more
 than half of them are occupied with 1 or more pixels.
 (4) For an image with not more than 256 colors, it is unlikely
 that two pixels of different color will fall in the same
 octcube at level = 4.   However it is possible, and this
 function optionally returns %nerrors, the number of pixels
 where, because more than one color is in the same octcube,
 the pixel color is not exactly reproduced in the colormap.
 The colormap for an occupied leaf of the octree contains
 the color of the first pixel encountered in that octcube.
 (5) This differs from pixFewColorsOctcubeQuant1(), which also
 requires not more than 256 occupied leaves, but represents
 the color of each leaf by an average over the pixels in
 that leaf.  This also requires precomputing the histogram
 of occupied octree leaves, which is generated using
 pixOctcubeHistogram().
 (6) This is used in pixConvertRGBToColormap() for images that
 are determined, by their histogram, to have relatively few
 colors.  This typically happens with orthographically
 produced images (as oppopsed to natural images), where
 it is expected that most of the pixels within a leaf
 octcube have exactly the same color, and quantization to
 that color is lossless.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="level">of octcube indexing, for histogram 3, 4, 5, 6</param>
	<param name="na">histogram of pixel occupation in octree leaves at given level</param>
	<param name="ncolors">number of occupied octree leaves at given level</param>
	<param name="pnerrors">num of pixels not exactly represented in the colormap</param>
	<returns>pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFewColorsOctcubeQuantMixed(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) First runs pixFewColorsOctcubeQuant1().  If this succeeds,
 it separates the color from gray(ish) entries in the cmap,
 and re-quantizes the gray pixels.  The result has some pixels
 in color and others in gray.
 (2) This fails if there are more than 256 colors (i.e., more
 than 256 occupied octcubes in the color quantization).
 (3) Level 3 (512 octcubes) will usually succeed because not more
 than half of them are occupied with 1 or more pixels.
 (4) This uses the criterion from pixColorFraction() for deciding
 if a colormap entry is color; namely, if the color components
 are not too close to either black or white, and the maximum
 difference between component values equals or exceeds a threshold.
 (5) For quantizing the gray pixels, it uses a histogram-based
 method where input parameters determining the buckets are
 the minimum population fraction and the maximum allowed size.
 (6) Recommended input parameters are
 %level  3 or 4  (3 is default)
 %darkthresh  20
 %lightthresh 244
 %diffthresh 20
 %minfract 0.05
 %maxspan 15
 These numbers are intended to be conservative (somewhat over-
 sensitive) in color detection,  It's usually better to pay
 extra with octcube quantization of a grayscale image than
 to use grayscale quantization on an image that has some
 actual color.  Input 0 on any of these to get the default.
 (7) This can be useful for quantizing orthographically generated
 images such as color maps, where there may be more than 256 colors
 because of aliasing or jpeg artifacts on text or lines, but
 there are a relatively small number of solid colors.  It usually
 gives results that are better than pixOctcubeQuantMixedWithGray(),
 both in size and appearance.  But it is a bit slower.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="level">significant octcube bits for each of RGB; valid in [1...6]; use 0 for default</param>
	<param name="darkthresh">threshold near black; if the lightest component is below this, the pixel is not considered to be gray or color; uses 0 for default</param>
	<param name="lightthresh">threshold near white; if the darkest component is above this, the pixel is not considered to be gray or color; use 0 for default</param>
	<param name="diffthresh">thresh for the max difference between component values; for differences below this, the pixel is considered to be gray; use 0 for default</param>
	<param name="minfract">min fraction of pixels for gray histo bin; use 0.0 for default</param>
	<param name="maxspan">max size of gray histo bin; use 0 for default</param>
	<returns>pixd 8 bpp, quantized to octcube for pixels that are not gray; gray pixels are quantized separately over the full gray range, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFixedOctcubeQuantGenRGB(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Unlike the other color quantization functions, this one
 generates an rgb image.
 (2) The pixel values are quantized to the center of each octcube
 (at the specified level) containing the pixel.  They are
 not quantized to the average of the pixels in that octcube.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="level">significant bits for each of r,g,b</param>
	<returns>pixd rgb; quantized to octcube centers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixQuantFromCmap(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a top-level wrapper for quantizing either grayscale
 or rgb images to a specified colormap.
 (2) The actual output depth is constrained by %mindepth and
 by the number of colors in %cmap.
 (3) For grayscale, %level and %metric are ignored.
 (4) If the cmap has color and pixs is grayscale, the color is
 removed from the cmap before quantizing pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale without cmap, or 32 bpp rgb</param>
	<param name="cmap">to quantize to; insert copy into dest pix</param>
	<param name="mindepth">minimum depth of pixd can be 2, 4 or 8 bpp</param>
	<param name="level">of octcube used for finding nearest color in cmap</param>
	<param name="metric">L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
	<returns>pixd  2, 4 or 8 bpp, colormapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOctcubeQuantFromCmap(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) In typical use, we are doing an operation, such as
 interpolative scaling, on a colormapped pix, where it is
 necessary to remove the colormap before the operation.
 We then want to re-quantize the RGB result using the same
 colormap.
 (2) The level is used to divide the color space into octcubes.
 Each input pixel is, in effect, placed at the center of an
 octcube at the given level, and it is mapped into the
 exact color (given in the colormap) that is the closest
 to that location.  We need to know that distance, for each color
 in the colormap.  The higher the level of the octtree, the smaller
 the octcubes in the color space, and hence the more accurately
 we can determine the closest color in the colormap; however,
 the size of the LUT, which is the total number of octcubes,
 increases by a factor of 8 for each increase of 1 level.
 The time required to acquire a level 4 mapping table, which has
 about 4K entries, is less than 1 msec, so that is the
 recommended minimum size to be used.  At that size, the
 octcubes have their centers 16 units apart in each (r,g,b)
 direction.  If two colors are in the same octcube, the one
 closest to the center will always be chosen.  The maximum
 error for any component occurs when the correct color is
 at a cube corner and there is an incorrect color just inside
 the cube next to the opposite corner, giving an error of
 14 units (out of 256) for each component.   Using a level 5
 mapping table reduces the maximum error to 6 units.
 (3) Typically you should use the Euclidean metric, because the
 resulting voronoi cells (which are generated using the actual
 colormap values as seeds) are convex for Euclidean distance
 but not for Manhattan distance.  In terms of the octcubes,
 convexity of the voronoi cells means that if the 8 corners
 of any cube (of which the octcubes are special cases)
 are all within a cell, then every point in the cube will
 lie within the cell.
 (4) The depth of the output pixd is equal to the maximum of
 (a) %mindepth and (b) the minimum (2, 4 or 8 bpp) necessary
 to hold the indices in the colormap.
 (5) We build a mapping table from octcube to colormap index so
 that this function can run in a time (otherwise) independent
 of the number of colors in the colormap.  This avoids a
 brute-force search for the closest colormap color to each
 pixel in the image.
 (6) This is similar to the function pixAssignToNearestColor()
 used for color segmentation.
 (7) Except for very small images or when using level GT 4,
 it takes very little time to generate the tables,
 compared to the generation of the colormapped dest pix,
 so one would not typically use the low-level version.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="cmap">to quantize to; insert copy into dest pix</param>
	<param name="mindepth">minimum depth of pixd can be 2, 4 or 8 bpp</param>
	<param name="level">of octcube used for finding nearest color in cmap</param>
	<param name="metric">L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
	<returns>pixd  2, 4 or 8 bpp, colormapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOctcubeHistogram(System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Input NULL for ncolors to prevent computation and return value.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="level">significant bits for each of RGB; valid in [1...6]</param>
	<param name="pncolors">number of occupied cubes</param>
	<returns>numa histogram of color pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapToOctcubeLUT(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This function is used to quickly find the colormap color
 that is closest to any rgb color.  It is used to assign
 rgb colors to an existing colormap.  It can be very expensive
 to search through the entire colormap for the closest color
 to each pixel.  Instead, we first set up this table, which is
 populated by the colormap index nearest to each octcube
 color.  Then we go through the image; for each pixel,
 do two table lookups first to generate the octcube index
 from rgb and second to use this table to read out the
 colormap index.
 (2) Do a slight modification for white and black.  For level = 4,
 each octcube size is 16.  The center of the whitest octcube
 is at (248, 248, 248), which is closer to 242 than 255.
 Consequently, any gray color between 242 and 254 will
 be selected, even if white (255, 255, 255) exists.  This is
 typically not optimal, because the original color was
 likely white.  Therefore, if white exists in the colormap,
 use it for any rgb color that falls into the most white octcube.
 Do the similar thing for black.
 (3) Here are the actual function calls for quantizing to a
 specified colormap
 ~ first make the tables that map from rgb --GT octcube index
 makeRGBToIndexTables()
 ~ then for each pixel
 use the tables to get the octcube index
 getOctcubeIndexFromRGB()
 use this table to get the nearest color in the colormap
 cmap_index = tab[index]
 (4) Distance can be either manhattan or euclidean.
 (5) In typical use, level = 4 gives reasonable results, and
 level = 5 is slightly better.  When this function is used
 for color segmentation, there are typically a small number
 of colors and the number of levels can be small (e.g., level = 3).
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="level">significant bits for each of RGB; valid in [1...6]</param>
	<param name="metric">L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
	<returns>tab[23  level]</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRemoveUnusedColors(System.IntPtr)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) If the image doesn't have a colormap, returns without error.
 (3) Unusued colors are removed from the colormap, and the
 image pixels are re-numbered.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixNumberOccupiedOctcubes(System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32@)">
	<summary>
 Notes
 (1) Exactly one of (%mincount, %minfract) must be -1, so, e.g.,
 if %mincount == -1, then we use %minfract.
 (2) If all occupied octcubes are to count, set %mincount == 1.
 Setting %minfract == 0.0 is taken to mean the same thing.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp</param>
	<param name="level">of octcube</param>
	<param name="mincount">minimum num pixels in an octcube to be counted; -1 to not use</param>
	<param name="minfract">minimum fract of pixels in an octcube to be counted; -1 to not use</param>
	<param name="pncolors">number of occupied octcubes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMedianCutQuant(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Simple interface.  See pixMedianCutQuantGeneral() for
 use of defaulted parameters.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; rgb color</param>
	<param name="ditherflag">1 for dither; 0 for no dither</param>
	<returns>pixd 8 bit with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMedianCutQuantGeneral(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) %maxcolors must be in the range [2 ... 256].
 (2) Use %outdepth = 0 to have the output depth computed as the
 minimum required to hold the actual colors found, given
 the %maxcolors constraint.
 (3) Use %outdepth = 1, 2, 4 or 8 to specify the output depth.
 In that case, %maxcolors must not exceed 2^(outdepth).
 (4) If there are fewer quantized colors in the image than %maxcolors,
 the colormap is simply generated from those colors.
 (5) %maxsub is the maximum allowed subsampling to be used in the
 computation of the color histogram and region of occupied
 color space.  The subsampling is chosen internally for
 efficiency, based on the image size, but this parameter
 limits it.  Use %maxsub = 0 for the internal default, which is the
 maximum allowed subsampling.  Use %maxsub = 1 to prevent
 subsampling.  In general use %maxsub GT= 1 to specify the
 maximum subsampling to be allowed, where the actual subsampling
 will be the minimum of this value and the internally
 determined default value.
 (6) If the image appears gray because either most of the pixels
 are gray or most of the pixels are essentially black or white,
 the image is trivially quantized with a grayscale colormap.  The
 reason is that median cut divides the color space into rectangular
 regions, and it does a very poor job if all the pixels are
 near the diagonal of the color space cube.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; rgb color</param>
	<param name="ditherflag">1 for dither; 0 for no dither</param>
	<param name="outdepth">output depth; valid 0, 1, 2, 4, 8</param>
	<param name="maxcolors">between 2 and 256</param>
	<param name="sigbits">valid 5 or 6; use 0 for default</param>
	<param name="maxsub">max subsampling, integer; use 0 for default; 1 for no subsampling</param>
	<param name="checkbw">1 to check if color content is very small, 0 to assume there is sufficient color</param>
	<returns>pixd 8 bit with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMedianCutQuantMixed(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) ncolor + ngray must not exceed 255.
 (2) The method makes use of pixMedianCutQuantGeneral() with
 minimal addition.
 (a) Preprocess the image, setting all pixels with little color
 to black, and populating an auxiliary 8 bpp image with the
 expected colormap values corresponding to the set of
 quantized gray values.
 (b) Color quantize the altered input image to n + 1 colors.
 (c) Augment the colormap with the gray indices, and
 substitute the gray quantized values from the auxiliary
 image for those in the color quantized output that had
 been quantized as black.
 (3) Median cut color quantization is relatively poor for grayscale
 images with many colors, when compared to octcube quantization.
 Thus, for images with both gray and color, it is important
 to quantize the gray pixels by another method.  Here, we
 are conservative in detecting color, preferring to use
 a few extra bits to encode colorful pixels that push them
 to gray.  This is particularly reasonable with this function,
 because it handles the gray and color pixels separately,
 using median cut color quantization for the color pixels
 and equal-bin grayscale quantization for the non-color pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; rgb color</param>
	<param name="ncolor">maximum number of colors assigned to pixels with significant color</param>
	<param name="ngray">number of gray colors to be used; must be GT= 2</param>
	<param name="darkthresh">threshold near black; if the lightest component is below this, the pixel is not considered to be gray or color; uses 0 for default</param>
	<param name="lightthresh">threshold near white; if the darkest component is above this, the pixel is not considered to be gray or color; use 0 for default</param>
	<param name="diffthresh">thresh for the max difference between component values; for differences below this, the pixel is considered to be gray; use 0 for default</param>
	<returns>pixd 8 bpp cmapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFewColorsMedianCutQuantMixed(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is the "few colors" version of pixMedianCutQuantMixed().
 It fails (returns NULL) if it finds more than maxncolors, but
 otherwise it gives the same result.
 (2) Recommended input parameters are
 %maxncolors  20
 %darkthresh  20
 %lightthresh 244
 %diffthresh  15  (any higher can miss colors differing
 slightly from gray)
 (3) Both ncolor and ngray should be at least equal to maxncolors.
 If they're not, they are automatically increased, and a
 warning is given.
 (4) If very little color content is found, the input is
 converted to gray and quantized in equal intervals.
 (5) This can be useful for quantizing orthographically generated
 images such as color maps, where there may be more than 256 colors
 because of aliasing or jpeg artifacts on text or lines, but
 there are a relatively small number of solid colors.
 (6) Example of usage
 // Try to quantize, using default values for mixed med cut
 Pix pixq = pixFewColorsMedianCutQuantMixed(pixs, 100, 20,
 0, 0, 0, 0);
 if (!pixq)  // too many colors; don't quantize
 pixq = pixClone(pixs);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="ncolor">number of colors to be assigned to pixels with significant color</param>
	<param name="ngray">number of gray colors to be used; must be GT= 2</param>
	<param name="maxncolors">maximum number of colors to be returned from pixColorsForQuantization(); use 0 for default</param>
	<param name="darkthresh">threshold near black; if the lightest component is below this, the pixel is not considered to be gray or color; use 0 for default</param>
	<param name="lightthresh">threshold near white; if the darkest component is above this, the pixel is not considered to be gray or color; use 0 for default</param>
	<param name="diffthresh">thresh for the max difference between component values; for differences below this, the pixel is considered to be gray; use 0 for default</param>
	<returns>pixd 8 bpp, median cut quantized for pixels that are not gray; gray pixels are quantized separately over the full gray range; null if too many colors or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMedianCutHisto(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Array is indexed by (3  sigbits) bits.  The array size
 is 2^(3  sigbits).
 (2) Indexing into the array from rgb uses red sigbits as
 most significant and blue as least.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; rgb color</param>
	<param name="sigbits">valid 5 or 6</param>
	<param name="subsample">integer GT 0</param>
	<returns>histo 1-d array, giving the number of pixels in each quantized region of color space, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorSegment(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Color segmentation proceeds in four phases
 Phase 1  pixColorSegmentCluster()
 The image is traversed in raster order.  Each pixel either
 becomes the representative for a new cluster or is assigned to an
 existing cluster.  Assignment is greedy.  The data is stored in
 a colormapped image.  Three auxiliary arrays are used to hold
 the colors of the representative pixels, for fast lookup.
 The average color in each cluster is computed.
 Phase 2.  pixAssignToNearestColor()
 A second non-greedy clustering pass is performed, where each pixel
 is assigned to the nearest cluster average.  We also keep track
 of how many pixels are assigned to each cluster.
 Phase 3.  pixColorSegmentClean()
 For each cluster, starting with the largest, do a morphological
 closing to eliminate small components within larger ones.
 Phase 4.  pixColorSegmentRemoveColors()
 Eliminate all colors except the most populated 'finalcolors'.
 Then remove unused colors from the colormap, and reassign those
 pixels to the nearest remaining cluster, using the original pixel values.
 Notes
 (1) The goal is to generate a small number of colors.
 Typically this would be specified by 'finalcolors',
 a number that would be somewhere between 3 and 6.
 The parameter 'maxcolors' specifies the maximum number of
 colors generated in the first phase.  This should be
 larger than finalcolors, perhaps twice as large.
 If more than 'maxcolors' are generated in the first phase
 using the input 'maxdist', the distance is repeatedly
 increased by a multiplicative factor until the condition
 is satisfied.  The implicit relation between 'maxdist'
 and 'maxcolors' is thus adjusted programmatically.
 (2) As a very rough guideline, given a target value of 'finalcolors',
 here are approximate values of 'maxdist' and 'maxcolors'
 to start with
 finalcolors maxcolors maxdist
 ----------- --------- -------
 3 6 100
 4 8  90
 5   10  75
 6   12  60
 For a given number of finalcolors, if you use too many
 maxcolors, the result will be noisy.  If you use too few,
 the result will be a relatively poor assignment of colors.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; 24-bit color</param>
	<param name="maxdist">max euclidean dist to existing cluster</param>
	<param name="maxcolors">max number of colors allowed in first pass</param>
	<param name="selsize">linear size of sel for closing to remove noise</param>
	<param name="finalcolors">max number of final colors allowed after 4th pass</param>
	<param name="debugflag">1 for debug output; 0 otherwise</param>
	<returns>pixd 8 bit with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorSegmentCluster(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is phase 1.  See description in pixColorSegment().
 (2) Greedy unsupervised classification.  If the limit 'maxcolors'
 is exceeded, the computation is repeated with a larger
 allowed cluster size.
 (3) On each successive iteration, 'maxdist' is increased by a
 constant factor.  See comments in pixColorSegment() for
 a guideline on parameter selection.
 Note that the diagonal of the 8-bit rgb color cube is about
 440, so for 'maxdist' = 440, you are guaranteed to get 1 color!
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; 24-bit color</param>
	<param name="maxdist">max euclidean dist to existing cluster</param>
	<param name="maxcolors">max number of colors allowed in first pass</param>
	<param name="debugflag">1 for debug output; 0 otherwise</param>
	<returns>pixd 8 bit with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAssignToNearestColor(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32[])">
	<summary>
 Notes
 (1) This is used in phase 2 of color segmentation, where pixs
 is the original input image to pixColorSegment(), and
 pixd is the colormapped image returned from
 pixColorSegmentCluster().  It is also used, with a mask,
 in phase 4.
 (2) This is an in-place operation.
 (3) The colormap in pixd is unchanged.
 (4) pixs and pixd must be the same size (w, h).
 (5) The selection mask pixm can be null.  If it exists, it must
 be the same size as pixs and pixd, and only pixels
 corresponding to fg in pixm are assigned.  Set to
 NULL if all pixels in pixd are to be assigned.
 (6) The countarray can be null.  If it exists, it is pre-allocated
 and of a size at least equal to the size of the colormap in pixd.
 (7) This does a best-fit (non-greedy) assignment of pixels to
 existing clusters.  Specifically, it assigns each pixel
 in pixd to the color index in the pixd colormap that has a
 color closest to the corresponding rgb pixel in pixs.
 (8) 'level' is the octcube level used to quickly find the nearest
 color in the colormap for each pixel.  For color segmentation,
 this parameter is set to LEVEL_IN_OCTCUBE.
 (9) We build a mapping table from octcube to colormap index so
 that this function can run in a time (otherwise) independent
 of the number of colors in the colormap.  This avoids a
 brute-force search for the closest colormap color to each
 pixel in the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8 bpp, colormapped</param>
	<param name="pixs">32 bpp; 24-bit color</param>
	<param name="pixm">1 bpp</param>
	<param name="level">of octcube used for finding nearest color in cmap</param>
	<param name="countarray">ptr to array, in which we can store the number of pixels found in each color in the colormap in pixd</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorSegmentClean(System.IntPtr,System.Int32,System.Int32[])">
	<summary>
 Notes
 (1) This operation is in-place.
 (2) This is phase 3 of color segmentation.  It is the first
 part of a two-step noise removal process.  Colors with a
 large population are closed first; this operation absorbs
 small sets of intercolated pixels of a different color.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, colormapped</param>
	<param name="selsize">for closing</param>
	<param name="countarray">ptr to array containing the number of pixels found in each color in the colormap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorSegmentRemoveColors(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This operation is in-place.
 (2) This is phase 4 of color segmentation, and the second part
 of the 2-step noise removal.  Only 'finalcolors' different
 colors are retained, with colors with smaller populations
 being replaced by the nearest color of the remaining colors.
 For highest accuracy, for pixels that are being replaced,
 we find the nearest colormap color  to the original rgb color.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8 bpp, colormapped</param>
	<param name="pixs">32 bpp rgb, with initial pixel values</param>
	<param name="finalcolors">max number of colors to retain</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToHSV(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
 (2) The definition of our HSV space is given in convertRGBToHSV().
 (3) The h, s and v values are stored in the same places as
 the r, g and b values, respectively.  Here, they are explicitly
 placed in the 3 MS bytes in the pixel.
 (4) Normalizing to 1 and considering the r,g,b components,
 a simple way to understand the HSV space is
 ~ v = max(r,g,b)
 ~ s = (max - min) / max
 ~ h ~ (mid - min) / (max - min)  [apart from signs and constants]
 (5) Normalizing to 1, some properties of the HSV space are
 ~ For gray values (r = g = b) along the continuum between
 black and white
 s = 0  (becoming undefined as you approach black)
 h is undefined everywhere
 ~ Where one component is saturated and the others are zero
 v = 1
 s = 1
 h = 0 (r = max), 1/3 (g = max), 2/3 (b = max)
 ~ Where two components are saturated and the other is zero
 v = 1
 s = 1
 h = 1/2 (if r = 0), 5/6 (if g = 0), 1/6 (if b = 0)
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; if not NULL, must == pixs</param>
	<param name="pixs"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertHSVToRGB(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
 (2) The user takes responsibility for making sure that pixs is
 in our HSV space.  The definition of our HSV space is given
 in convertRGBToHSV().
 (3) The h, s and v values are stored in the same places as
 the r, g and b values, respectively.  Here, they are explicitly
 placed in the 3 MS bytes in the pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; if not NULL, must == pixs</param>
	<param name="pixs"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.convertRGBToHSV(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The range of returned values is
 h [0 ... 239]
 s [0 ... 255]
 v [0 ... 255]
 (2) If r = g = b, the pixel is gray (s = 0), and we define h = 0.
 (3) h wraps around, so that h = 0 and h = 240 are equivalent
 in hue space.
 (4) h has the following correspondence to color
 h = 0   magenta
 h = 40  red
 h = 80  yellow
 h = 120 green
 h = 160 cyan
 h = 200 blue
 </summary>
	<remarks>
	</remarks>
	<param name="rval">RGB input</param>
	<param name="gval">RGB input</param>
	<param name="bval">RGB input</param>
	<param name="phval">HSV values</param>
	<param name="psval">HSV values</param>
	<param name="pvval">HSV values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertHSVToRGB(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) See convertRGBToHSV() for valid input range of HSV values
 and their interpretation in color space.
 </summary>
	<remarks>
	</remarks>
	<param name="hval"></param>
	<param name="sval"></param>
	<param name="vval"></param>
	<param name="prval">RGB values</param>
	<param name="pgval">RGB values</param>
	<param name="pbval">RGB values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapConvertRGBToHSV(System.IntPtr)">
	<summary>
 Notes
 ~ in-place transform
 ~ See convertRGBToHSV() for def'n of HSV space.
 ~ replaces r --GT h, g --GT s, b --GT v
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapConvertHSVToRGB(System.IntPtr)">
	<summary>
 Notes
 ~ in-place transform
 ~ See convertRGBToHSV() for def'n of HSV space.
 ~ replaces h --GT r, s --GT g, v --GT b
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToHue(System.IntPtr)">
	<summary>
 Notes
 (1) The conversion to HSV hue is in-lined here.
 (2) If there is a colormap, it is removed.
 (3) If you just want the hue component, this does it
 at about 10 Mpixels/sec/GHz, which is about
 2x faster than using pixConvertRGBToHSV()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB or 8 bpp with colormap</param>
	<returns>pixd 8 bpp hue of HSV, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToSaturation(System.IntPtr)">
	<summary>
 Notes
 (1) The conversion to HSV sat is in-lined here.
 (2) If there is a colormap, it is removed.
 (3) If you just want the saturation component, this does it
 at about 12 Mpixels/sec/GHz.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB or 8 bpp with colormap</param>
	<returns>pixd 8 bpp sat of HSV, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToValue(System.IntPtr)">
	<summary>
 Notes
 (1) The conversion to HSV sat is in-lined here.
 (2) If there is a colormap, it is removed.
 (3) If you just want the value component, this does it
 at about 35 Mpixels/sec/GHz.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB or 8 bpp with colormap</param>
	<returns>pixd 8 bpp max component intensity of HSV, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMakeRangeMaskHS(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The pixels are selected based on the specified ranges of
 hue and saturation.  For selection or exclusion, the pixel
 HS component values must be within both ranges.  Care must
 be taken in finding the hue range because of wrap-around.
 (2) Use %regionflag == L_INCLUDE_REGION to take only those
 pixels within the rectangular region specified in HS space.
 Use %regionflag == L_EXCLUDE_REGION to take all pixels except
 those within the rectangular region specified in HS space.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="huecenter">center value of hue range</param>
	<param name="huehw">half-width of hue range</param>
	<param name="satcenter">center value of saturation range</param>
	<param name="sathw">half-width of saturation range</param>
	<param name="regionflag">L_INCLUDE_REGION, L_EXCLUDE_REGION</param>
	<returns>pixd 1 bpp mask over selected pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMakeRangeMaskHV(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The pixels are selected based on the specified ranges of
 hue and max intensity values.  For selection or exclusion,
 the pixel HV component values must be within both ranges.
 Care must be taken in finding the hue range because of wrap-around.
 (2) Use %regionflag == L_INCLUDE_REGION to take only those
 pixels within the rectangular region specified in HV space.
 Use %regionflag == L_EXCLUDE_REGION to take all pixels except
 those within the rectangular region specified in HV space.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="huecenter">center value of hue range</param>
	<param name="huehw">half-width of hue range</param>
	<param name="valcenter">center value of max intensity range</param>
	<param name="valhw">half-width of max intensity range</param>
	<param name="regionflag">L_INCLUDE_REGION, L_EXCLUDE_REGION</param>
	<returns>pixd 1 bpp mask over selected pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMakeRangeMaskSV(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The pixels are selected based on the specified ranges of
 saturation and max intensity (val).  For selection or
 exclusion, the pixel SV component values must be within both ranges.
 (2) Use %regionflag == L_INCLUDE_REGION to take only those
 pixels within the rectangular region specified in SV space.
 Use %regionflag == L_EXCLUDE_REGION to take all pixels except
 those within the rectangular region specified in SV space.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="satcenter">center value of saturation range</param>
	<param name="sathw">half-width of saturation range</param>
	<param name="valcenter">center value of max intensity range</param>
	<param name="valhw">half-width of max intensity range</param>
	<param name="regionflag">L_INCLUDE_REGION, L_EXCLUDE_REGION</param>
	<returns>pixd 1 bpp mask over selected pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMakeHistoHS(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) pixs is a 32 bpp image in HSV colorspace; hue is in the "red"
 byte, saturation is in the "green" byte.
 (2) In pixd, hue is displayed vertically; saturation horizontally.
 The dimensions of pixd are w = 256, h = 240, and the depth
 is 32 bpp.  The value at each point is simply the number
 of pixels found at that value of hue and saturation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">HSV colorspace</param>
	<param name="factor">subsampling factor; integer</param>
	<param name="pnahue">hue histogram</param>
	<param name="pnasat">saturation histogram</param>
	<returns>pixd 32 bpp histogram in hue and saturation, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMakeHistoHV(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) pixs is a 32 bpp image in HSV colorspace; hue is in the "red"
 byte, max intensity ("value") is in the "blue" byte.
 (2) In pixd, hue is displayed vertically; intensity horizontally.
 The dimensions of pixd are w = 256, h = 240, and the depth
 is 32 bpp.  The value at each point is simply the number
 of pixels found at that value of hue and intensity.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">HSV colorspace</param>
	<param name="factor">subsampling factor; integer</param>
	<param name="pnahue">hue histogram</param>
	<param name="pnaval">max intensity (value) histogram</param>
	<returns>pixd 32 bpp histogram in hue and value, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMakeHistoSV(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) pixs is a 32 bpp image in HSV colorspace; sat is in the "green"
 byte, max intensity ("value") is in the "blue" byte.
 (2) In pixd, sat is displayed vertically; intensity horizontally.
 The dimensions of pixd are w = 256, h = 256, and the depth
 is 32 bpp.  The value at each point is simply the number
 of pixels found at that value of saturation and intensity.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">HSV colorspace</param>
	<param name="factor">subsampling factor; integer</param>
	<param name="pnasat">sat histogram</param>
	<param name="pnaval">max intensity (value) histogram</param>
	<returns>pixd 32 bpp histogram in sat and value, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindHistoPeaksHSV(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) pixs is a 32 bpp histogram in a pair of HSV colorspace.  It
 should be thought of as a single sample with 32 bps (bits/sample).
 (2) After each peak is found, the peak is erased with a window
 that is centered on the peak and scaled from the sliding
 window by %erasefactor.  Typically, %erasefactor is chosen
 to be GT 1.0.
 (3) Data for a maximum of %npeaks is returned in %pta and %natot.
 (4) For debugging, after the pixa is returned, display with
 pixd = pixaDisplayTiledInRows(pixa, 32, 1000, 1.0, 0, 30, 2);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; HS, HV or SV histogram; not changed</param>
	<param name="type">L_HS_HISTO, L_HV_HISTO or L_SV_HISTO</param>
	<param name="width">half width of sliding window</param>
	<param name="height">half height of sliding window</param>
	<param name="npeaks">number of peaks to look for</param>
	<param name="erasefactor">ratio of erase window size to sliding window size</param>
	<param name="ppta">locations of max for each integrated peak area</param>
	<param name="pnatot">integrated peak areas</param>
	<param name="ppixa">pixa for debugging; NULL to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.displayHSVColorRange(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The total number of color samplings in each of the hue
 and saturation directions is 2  nsamp + 1.
 </summary>
	<remarks>
	</remarks>
	<param name="hval">hue center value; in range [0 ... 240]</param>
	<param name="sval">saturation center value; in range [0 ... 255]</param>
	<param name="vval">max intensity value; in range [0 ... 255]</param>
	<param name="huehw">half-width of hue range; GT 0</param>
	<param name="sathw">half-width of saturation range; GT 0</param>
	<param name="nsamp">number of samplings in each half-width in hue and sat</param>
	<param name="factor">linear size of each color square, in pixels; GT 3</param>
	<returns>pixd 32 bpp set of color squares over input range, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToYUV(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
 (2) The Y, U and V values are stored in the same places as
 the r, g and b values, respectively.  Here, they are explicitly
 placed in the 3 MS bytes in the pixel.
 (3) Normalizing to 1 and considering the r,g,b components,
 a simple way to understand the YUV space is
 ~ Y = weighted sum of (r,g,b)
 ~ U = weighted difference between Y and B
 ~ V = weighted difference between Y and R
 (4) Following video conventions, Y, U and V are in the range
 Y [16, 235]
 U [16, 240]
 V [16, 240]
 (5) For the coefficients in the transform matrices, see eq. 4 in
 "Frequently Asked Questions about Color" by Charles Poynton,
 //http//user.engineering.uiowa.edu/~aip/Misc/ColorFAQ.html
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; if not NULL, must == pixs</param>
	<param name="pixs"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertYUVToRGB(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
 (2) The user takes responsibility for making sure that pixs is
 in YUV space.
 (3) The Y, U and V values are stored in the same places as
 the r, g and b values, respectively.  Here, they are explicitly
 placed in the 3 MS bytes in the pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; if not NULL, must == pixs</param>
	<param name="pixs"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.convertRGBToYUV(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The range of returned values is
 Y [16 ... 235]
 U [16 ... 240]
 V [16 ... 240]
 </summary>
	<remarks>
	</remarks>
	<param name="rval">RGB input</param>
	<param name="gval">RGB input</param>
	<param name="bval">RGB input</param>
	<param name="pyval">YUV values</param>
	<param name="puval">YUV values</param>
	<param name="pvval">YUV values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertYUVToRGB(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The range of valid input values is
 Y [16 ... 235]
 U [16 ... 240]
 V [16 ... 240]
 (2) Conversion of RGB --GT YUV --GT RGB leaves the image unchanged.
 (3) The YUV gamut is larger than the RBG gamut; many YUV values
 will result in an invalid RGB value.  We clip individual
 r,g,b components to the range [0, 255], and do not test input.
 </summary>
	<remarks>
	</remarks>
	<param name="yval"></param>
	<param name="uval"></param>
	<param name="vval"></param>
	<param name="prval">RGB values</param>
	<param name="pgval">RGB values</param>
	<param name="pbval">RGB values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapConvertRGBToYUV(System.IntPtr)">
	<summary>
 Notes
 ~ in-place transform
 ~ See convertRGBToYUV() for def'n of YUV space.
 ~ replaces r --GT y, g --GT u, b --GT v
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcmapConvertYUVToRGB(System.IntPtr)">
	<summary>
 Notes
 ~ in-place transform
 ~ See convertRGBToYUV() for def'n of YUV space.
 ~ replaces y --GT r, u --GT g, v --GT b
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToXYZ(System.IntPtr)">
	<summary>
 Notes
 (1) The [x,y,z] values are stored as float values in three fpix
 that are returned in a fpixa.
 (2) The XYZ color space was defined in 1931 as a reference model that
 simulates human color perception.  When Y is taken as luminance,
 the values of X and Z constitute a color plane representing
 all the hues that can be perceived.  This gamut of colors
 is larger than the gamuts that can be displayed or printed.
 For example, although all rgb values map to XYZ, the converse
 is not true.
 (3) The value of the coefficients depends on the illuminant.  We use
 coefficients for converting sRGB under D65 (the spectrum from
 a 6500 degree K black body; an approximation to daylight color).
 See, e.g.,
 http//www.cs.rit.edu/~ncs/color/t_convert.html
 For more general information on color transforms, see
 http//www.brucelindbloom.com/
 http//user.engineering.uiowa.edu/~aip/Misc/ColorFAQ.html
 http//en.wikipedia.org/wiki/CIE_1931_color_space
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">rgb</param>
	<returns>fpixa xyz</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaConvertXYZToRGB(System.IntPtr)">
	<summary>
 Notes
 (1) The xyz image is stored in three fpix.
 (2) For values of xyz that are out of gamut for rgb, the rgb
 components are set to the closest valid color.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixa">three fpix x,y,z</param>
	<returns>pixd rgb</returns>
</member><member name="M:LeptonicaSharp.Natives.convertRGBToXYZ(System.Int32,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) These conversions are for illuminant D65 acting on linear sRGB
 values.
 </summary>
	<remarks>
	</remarks>
	<param name="rval">rgb input</param>
	<param name="gval">rgb input</param>
	<param name="bval">rgb input</param>
	<param name="pfxval">xyz values</param>
	<param name="pfyval">xyz values</param>
	<param name="pfzval">xyz values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertXYZToRGB(System.Single,System.Single,System.Single,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) For values of xyz that are out of gamut for rgb, at least
 one of the r, g or b components will be either less than 0
 or greater than 255.  For that situation
 if blackout == 0, the individual component(s) that are out
 of gamut will be set to 0 or 255, respectively.
 if blackout == 1, the output color will be set to black
 </summary>
	<remarks>
	</remarks>
	<param name="fxval"></param>
	<param name="fyval"></param>
	<param name="fzval"></param>
	<param name="blackout">0 to output nearest color if out of gamut; 1 to output black</param>
	<param name="prval">rgb values</param>
	<param name="pgval">rgb values</param>
	<param name="pbval">rgb values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaConvertXYZToLAB(System.IntPtr)">
	<summary>
 Notes
 (1) The input [x,y,z] and output [l,a,b] values are stored as
 float values, each set in three fpix.
 (2) The CIE LAB color space was invented in 1976, as an
 absolute reference for specifying colors that we can
 perceive, independently of the rendering device.  It was
 invented to align color display and print images.
 For information, see
 http//www.brucelindbloom.com/
 http//en.wikipedia.org/wiki/Lab_color_space
 </summary>
	<remarks>
	</remarks>
	<param name="fpixas">xyz</param>
	<returns>fpixa lab</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaConvertLABToXYZ(System.IntPtr)">
	<summary>
 Notes
 (1) The input [l,a,b] and output [x,y,z] values are stored as
 float values, each set in three fpix.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixas">lab</param>
	<returns>fpixa xyz</returns>
</member><member name="M:LeptonicaSharp.Natives.convertXYZToLAB(System.Single,System.Single,System.Single,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="xval">xyz input</param>
	<param name="yval">xyz input</param>
	<param name="zval">xyz input</param>
	<param name="plval">lab values</param>
	<param name="paval">lab values</param>
	<param name="pbval">lab values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertLABToXYZ(System.Single,System.Single,System.Single,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lval"></param>
	<param name="aval"></param>
	<param name="bval"></param>
	<param name="pxval">xyz values</param>
	<param name="pyval">xyz values</param>
	<param name="pzval">xyz values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToLAB(System.IntPtr)">
	<summary>
 Notes
 (1) The [l,a,b] values are stored as float values in three fpix
 that are returned in a fpixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">rgb</param>
	<returns>fpixa lab</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaConvertLABToRGB(System.IntPtr)">
	<summary>
 Notes
 (1) The lab image is stored in three fpix.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixa">three fpix l,a,b</param>
	<returns>pixd rgb</returns>
</member><member name="M:LeptonicaSharp.Natives.convertRGBToLAB(System.Int32,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) These conversions are for illuminant D65 acting on linear sRGB
 values.
 </summary>
	<remarks>
	</remarks>
	<param name="rval">rgb input</param>
	<param name="gval">rgb input</param>
	<param name="bval">rgb input</param>
	<param name="pflval">lab values</param>
	<param name="pfaval">lab values</param>
	<param name="pfbval">lab values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertLABToRGB(System.Single,System.Single,System.Single,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) For values of lab that are out of gamut for rgb, the rgb
 components are set to the closest valid color.
 </summary>
	<remarks>
	</remarks>
	<param name="flval"></param>
	<param name="faval"></param>
	<param name="fbval"></param>
	<param name="prval">rgb values</param>
	<param name="pgval">rgb values</param>
	<param name="pbval">rgb values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixEqual(System.IntPtr,System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) Equality is defined as having the same pixel values for
 each respective image pixel.
 (2) This works on two pix of any depth.  If one or both pix
 have a colormap, the depths can be different and the
 two pix can still be equal.
 (3) This ignores the alpha component for 32 bpp images.
 (4) If both pix have colormaps and the depths are equal,
 use the pixEqualWithCmap() function, which does a fast
 comparison if the colormaps are identical and a relatively
 slow comparison otherwise.
 (5) In all other cases, any existing colormaps must first be
 removed before doing pixel comparison.  After the colormaps
 are removed, the resulting two images must have the same depth.
 The "lowest common denominator" is RGB, but this is only
 chosen when necessary, or when both have colormaps but
 different depths.
 (6) For images without colormaps that are not 32 bpp, all bits
 in the image part of the data array must be identical.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1"></param>
	<param name="pix2"></param>
	<param name="psame">1 if same; 0 if different</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixEqualWithAlpha(System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) See notes in pixEqual().
 (2) This is more general than pixEqual(), in that for 32 bpp
 RGBA images, where spp = 4, you can optionally include
 the alpha component in the comparison.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1"></param>
	<param name="pix2"></param>
	<param name="use_alpha">1 to compare alpha in RGBA; 0 to ignore</param>
	<param name="psame">1 if same; 0 if different</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixEqualWithCmap(System.IntPtr,System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) This returns same = TRUE if the images have identical content.
 (2) Both pix must have a colormap, and be of equal size and depth.
 If these conditions are not satisfied, it is not an error;
 the returned result is same = FALSE.
 (3) We then check whether the colormaps are the same; if so,
 the comparison proceeds 32 bits at a time.
 (4) If the colormaps are different, the comparison is done by
 slow brute force.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1"></param>
	<param name="pix2"></param>
	<param name="psame"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.cmapEqual(System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This returns %same = TRUE if the colormaps have identical entries.
 (2) If %ncomps == 4, the alpha components of the colormaps are also
 compared.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap1"></param>
	<param name="cmap2"></param>
	<param name="ncomps">3 for RGB, 4 for RGBA</param>
	<param name="psame"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixUsesCmapColor(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) This returns color = TRUE if three things are obtained
 (a) the pix has a colormap
 (b) the colormap has at least one color entry
 (c) a color entry is actually used
 (2) It is used in pixEqual() for comparing two images, in a
 situation where it is required to know if the colormap
 has color entries that are actually used in the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, colormap</param>
	<param name="pcolor">TRUE if color found</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCorrelationBinary(System.IntPtr,System.IntPtr,System.Single[]@)">
	<summary>
 Notes
 (1) The correlation is a number between 0.0 and 1.0,
 based on foreground similarity
 (|1 AND 2|)2
 correlation =  --------------
 |1|  |2|
 where |x| is the count of foreground pixels in image x.
 If the images are identical, this is 1.0.
 If they have no fg pixels in common, this is 0.0.
 If one or both images have no fg pixels, the correlation is 0.0.
 (2) Typically the two images are of equal size, but this
 is not enforced.  Instead, the UL corners are aligned.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">1 bpp</param>
	<param name="pix2">1 bpp</param>
	<param name="pval">correlation</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDisplayDiffBinary(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This gives a color representation of the difference between
 pix1 and pix2.  The color difference depends on the order.
 The pixels in pixd have 4 colors
 unchanged  black (on), white (off)
 on in pix1, off in pix2 red
 on in pix2, off in pix1 green
 (2) This aligns the UL corners of pix1 and pix2, and crops
 to the overlapping pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">1 bpp</param>
	<param name="pix2">1 bpp</param>
	<returns>pixd 4 bpp cmapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCompareBinary(System.IntPtr,System.IntPtr,System.Int32,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) The two images are aligned at the UL corner, and do not
 need to be the same size.
 (2) If using L_COMPARE_SUBTRACT, pix2 is subtracted from pix1.
 (3) The total number of pixels is determined by pix1.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">1 bpp</param>
	<param name="pix2">1 bpp</param>
	<param name="comptype">L_COMPARE_XOR, L_COMPARE_SUBTRACT</param>
	<param name="pfract">fraction of pixels that are different</param>
	<param name="ppixdiff">pix of difference</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCompareGrayOrRGB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32@,System.Single[]@,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) The two images are aligned at the UL corner, and do not
 need to be the same size.  If they are not the same size,
 the comparison will be made over overlapping pixels.
 (2) If there is a colormap, it is removed and the result
 is either gray or RGB depending on the colormap.
 (3) If RGB, each component is compared separately.
 (4) If type is L_COMPARE_ABS_DIFF, pix2 is subtracted from pix1
 and the absolute value is taken.
 (5) If type is L_COMPARE_SUBTRACT, pix2 is subtracted from pix1
 and the result is clipped to 0.
 (6) The plot output types are specified in gplot.h.
 Use 0 if no difference plot is to be made.
 (7) If the images are pixelwise identical, no difference
 plot is made, even if requested.  The result (TRUE or FALSE)
 is optionally returned in the parameter 'same'.
 (8) The average difference (either subtracting or absolute value)
 is optionally returned in the parameter 'diff'.
 (9) The RMS difference is optionally returned in the
 parameter 'rmsdiff'.  For RGB, we return the average of
 the RMS differences for each of the components.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 or 16 bpp gray, 32 bpp rgb, or colormapped</param>
	<param name="pix2">8 or 16 bpp gray, 32 bpp rgb, or colormapped</param>
	<param name="comptype">L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF</param>
	<param name="plottype">gplot plot output type, or 0 for no plot</param>
	<param name="psame">1 if pixel values are identical</param>
	<param name="pdiff">average difference</param>
	<param name="prmsdiff">rms of difference</param>
	<param name="ppixdiff">pix of difference</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCompareGray(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32@,System.Single[]@,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) See pixCompareGrayOrRGB() for details.
 (2) Use pixCompareGrayOrRGB() if the input pix are colormapped.
 (3) Note setting %plottype GT 0 can result in writing named
 output files.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 or 16 bpp, not cmapped</param>
	<param name="pix2">8 or 16 bpp, not cmapped</param>
	<param name="comptype">L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF</param>
	<param name="plottype">gplot plot output type, or 0 for no plot</param>
	<param name="psame">1 if pixel values are identical</param>
	<param name="pdiff">average difference</param>
	<param name="prmsdiff">rms of difference</param>
	<param name="ppixdiff">pix of difference</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCompareRGB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32@,System.Single[]@,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) See pixCompareGrayOrRGB() for details.
 (2) Note setting %plottype GT 0 can result in writing named
 output files.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">32 bpp rgb</param>
	<param name="pix2">32 bpp rgb</param>
	<param name="comptype">L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF</param>
	<param name="plottype">gplot plot output type, or 0 for no plot</param>
	<param name="psame">1 if pixel values are identical</param>
	<param name="pdiff">average difference</param>
	<param name="prmsdiff">rms of difference</param>
	<param name="ppixdiff">pix of difference</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCompareTiled(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) With L_MEAN_ABSVAL, we compute for each tile the
 average abs value of the pixel component difference between
 the two (aligned) images.  With L_ROOT_MEAN_SQUARE, we
 compute instead the rms difference over all components.
 (2) The two input pix must be the same depth.  Comparison is made
 using UL corner alignment.
 (3) For 32 bpp, the distance between corresponding tiles
 is found by averaging the measured difference over all three
 components of each pixel in the tile.
 (4) The result, pixdiff, contains one pixel for each source tile.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 bpp or 32 bpp rgb</param>
	<param name="pix2">8 bpp 32 bpp rgb</param>
	<param name="sx">tile size; must be GT 1 in each dimension</param>
	<param name="sy">tile size; must be GT 1 in each dimension</param>
	<param name="type">L_MEAN_ABSVAL or L_ROOT_MEAN_SQUARE</param>
	<param name="ppixdiff">pix of difference</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCompareRankDifference(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This answers the question if the pixel values in each
 component are compared by absolute difference, for
 any value of difference, what is the fraction of
 pixel pairs that have a difference of this magnitude
 or greater.  For a difference of 0, the fraction is 1.0.
 In this sense, it is a mapping from pixel difference to
 rank order of difference.
 (2) The two images are aligned at the UL corner, and do not
 need to be the same size.  If they are not the same size,
 the comparison will be made over overlapping pixels.
 (3) If there is a colormap, it is removed and the result
 is either gray or RGB depending on the colormap.
 (4) If RGB, pixel differences for each component are aggregated
 into a single histogram.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="pix2">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="factor">subsampling factor; use 0 or 1 for no subsampling</param>
	<returns>narank      numa of rank difference, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixTestForSimilarity(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single,System.Single,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) This takes 2 pix that are the same size and determines using
 3 input parameters if they are "similar".  The first parameter
 %mindiff establishes a criterion of pixel-to-pixel similarity
 two pixels are not similar if their difference in value is
 at least mindiff.  Then %maxfract and %maxave are thresholds
 on the number and distribution of dissimilar pixels
 allowed for the two pix to be similar.   If the pix are
 to be similar, neither threshold can be exceeded.
 (2) In setting the %maxfract and %maxave thresholds, you have
 these options
 (a) Base the comparison only on %maxfract.  Then set
 %maxave = 0.0 or 256.0.  (If 0, we always ignore it.)
 (b) Base the comparison only on %maxave.  Then set
 %maxfract = 1.0.
 (c) Base the comparison on both thresholds.
 (3) Example of values that can be expected at mindiff = 15 when
 comparing lossless png encoding with jpeg encoding, q=75
 (smoothish bg) fractdiff = 0.01, avediff = 2.5
 (natural scene)   fractdiff = 0.13, avediff = 3.5
 To identify these images as 'similar', select maxfract
 and maxave to be upper bounds of what you expect.
 (4) See pixGetDifferenceStats() for a discussion of why we subtract
 mindiff from the computed average diff of the nonsimilar pixels
 to get the 'avediff' returned by that function.
 (5) If there is a colormap, it is removed and the result
 is either gray or RGB depending on the colormap.
 (6) If RGB, the maximum difference between pixel components is
 saved in the histogram.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="pix2">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="factor">subsampling factor; use 0 or 1 for no subsampling</param>
	<param name="mindiff">minimum pixel difference to be counted; GT 0</param>
	<param name="maxfract">maximum fraction of pixels allowed to have diff greater than or equal to mindiff</param>
	<param name="maxave">maximum average difference of pixels allowed for pixels with diff greater than or equal to mindiff, after subtracting mindiff</param>
	<param name="psimilar">1 if similar, 0 otherwise</param>
	<param name="details">use 1 to give normalized histogram and other data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetDifferenceStats(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Int32)">
	<summary>
 Notes
 (1) This takes a threshold %mindiff and describes the difference
 between two images in terms of two numbers
 (a) the fraction of pixels, %fractdiff, whose difference
 equals or exceeds the threshold %mindiff, and
 (b) the average value %avediff of the difference in pixel value
 for the pixels in the set given by (a), after you subtract
 %mindiff.  The reason for subtracting %mindiff is that
 you then get a useful measure for the rate of falloff
 of the distribution for larger differences.  For example,
 if %mindiff = 10 and you find that %avediff = 2.5, it
 says that of the pixels with diff GT 10, the average of
 their diffs is just mindiff + 2.5 = 12.5.  This is a
 fast falloff in the histogram with increasing difference.
 (2) The two images are aligned at the UL corner, and do not
 need to be the same size.  If they are not the same size,
 the comparison will be made over overlapping pixels.
 (3) If there is a colormap, it is removed and the result
 is either gray or RGB depending on the colormap.
 (4) If RGB, the maximum difference between pixel components is
 saved in the histogram.
 (5) Set %details == 1 to see the difference histogram and get
 an output that shows for each value of %mindiff, what are the
 minimum values required for fractdiff and avediff in order
 that the two pix will be considered similar.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="pix2">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="factor">subsampling factor; use 0 or 1 for no subsampling</param>
	<param name="mindiff">minimum pixel difference to be counted; GT 0</param>
	<param name="pfractdiff">fraction of pixels with diff greater than or equal to mindiff</param>
	<param name="pavediff">average difference of pixels with diff greater than or equal to mindiff, less mindiff</param>
	<param name="details">use 1 to give normalized histogram and other data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetDifferenceHistogram(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The two images are aligned at the UL corner, and do not
 need to be the same size.  If they are not the same size,
 the comparison will be made over overlapping pixels.
 (2) If there is a colormap, it is removed and the result
 is either gray or RGB depending on the colormap.
 (3) If RGB, the maximum difference between pixel components is
 saved in the histogram.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="pix2">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="factor">subsampling factor; use 0 or 1 for no subsampling</param>
	<returns>na     Numa of histogram of differences, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetPerceptualDiff(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single[]@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This takes 2 pix and determines, using 2 input parameters
 %dilation specifies the amount of grayscale or color
 dilation to apply to the images, to compensate for
 a small amount of misregistration.  A typical number might
 be 5, which uses a 5x5 Sel.  Grayscale dilation expands
 lighter pixels into darker pixel regions.
 %mindiff determines the threshold on the difference in
 pixel values to be counted -- two pixels are not similar
 if their difference in value is at least %mindiff.  For
 color pixels, we use the maximum component difference.
 (2) The pixelwise comparison is always done with the UL corners
 aligned.  The sizes of pix1 and pix2 need not be the same,
 although in practice it can be useful to scale to the same size.
 (3) If there is a colormap, it is removed and the result
 is either gray or RGB depending on the colormap.
 (4) Two optional diff images can be retrieved (typ. for debugging)
 pixdiff1 the gray or color difference
 pixdiff2 thresholded to 1 bpp for pixels exceeding %mindiff
 (5) The returned value of fract can be compared to some threshold,
 which is application dependent.
 (6) This method is in analogy to the two-sided hausdorff transform,
 except here it is for d GT 1.  For d == 1 (see pixRankHaustest()),
 we verify that when one pix1 is dilated, it covers at least a
 given fraction of the pixels in pix2, and v.v.; in that
 case, the two pix are sufficiently similar.  Here, we
 do an analogous thing subtract the dilated pix1 from pix2 to
 get a 1-sided hausdorff-like transform.  Then do it the
 other way.  Take the component-wise max of the two results,
 and threshold to get the fraction of pixels with a difference
 below the threshold.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="pixs2">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="sampling">subsampling factor; use 0 or 1 for no subsampling</param>
	<param name="dilation">size of grayscale or color Sel; odd</param>
	<param name="mindiff">minimum pixel difference to be counted; GT 0</param>
	<param name="pfract">fraction of pixels with diff greater than mindiff</param>
	<param name="ppixdiff1">showing difference (gray or color)</param>
	<param name="ppixdiff2">showing pixels of sufficient diff</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetPSNR(System.IntPtr,System.IntPtr,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) This computes the power S/N ratio, in dB, for the difference
 between two images.  By convention, the power S/N
 for a grayscale image is ('log' == log base 10,
 and 'ln == log base e)
 PSNR = 10  log((255/MSE)^2)
 = 4.3429  ln((255/MSE)^2)
 = -4.3429  ln((MSE/255)^2)
 where MSE is the mean squared error.
 Here are some examples
 MSE PSNR
 --- ----
 10  28.1
 3   38.6
 1   48.1
 0.1 68.1
 (2) If pix1 and pix2 have the same pixel values, the MSE = 0.0
 and the PSNR is infinity.  For that case, this returns
 PSNR = 1000, which corresponds to the very small MSE of
 about 10^(-48).
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 or 32 bpp; no colormap</param>
	<param name="pix2">8 or 32 bpp; no colormap</param>
	<param name="factor">sampling factor; GT= 1</param>
	<param name="ppsnr">power signal/noise ratio difference</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaComparePhotoRegionsByHisto(System.IntPtr,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This function takes a pixa of cropped photo images and
 compares each one to the others for similarity.
 Each image is first tested to see if it is a photo that can
 be compared by tiled histograms.  If so, it is padded to put
 the centroid in the center of the image, and the histograms
 are generated.  The final step of comparing each histogram
 with all the others is very fast.
 (2) An initial filter gives %score = 0 if the ratio of widths
 and heights (smallest / largest) does not exceed a
 threshold %minratio.  If set at 1.0, both images must be
 exactly the same size.  A typical value for %minratio is 0.9.
 (3) The comparison score between two images is a value in [0.0 .. 1.0].
 If the comparison score GT= %simthresh, the images are placed in
 the same similarity class.  Default value for %simthresh is 0.25.
 (4) An array %nai of similarity class indices for pix in the
 input pixa is returned.
 (5) There are two debugging options
 An optional 2D matrix of scores is returned as a 1D array.
 A visualization of this is written to a temp file.
 An optional pix showing the similarity classes can be
 returned.  Text in each input pix is reproduced.
 (6) See the notes in pixComparePhotoRegionsByHisto() for details
 on the implementation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">any depth; colormap OK</param>
	<param name="minratio">requiring sizes be compatible; LT 1.0</param>
	<param name="textthresh">threshold for text/photo; use 0 for default</param>
	<param name="factor">subsampling; GT= 1</param>
	<param name="nx">num subregions to use for histograms; e.g. 3x3</param>
	<param name="ny">num subregions to use for histograms; e.g. 3x3</param>
	<param name="simthresh">threshold for similarity; use 0 for default</param>
	<param name="pnai">array  giving similarity class indices</param>
	<param name="pscores">score matrix as 1-D array of size N^2</param>
	<param name="ppixd">pix of similarity classes</param>
	<param name="debug">1 to output histograms; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixComparePhotoRegionsByHisto(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32,System.Single[]@,System.Int32)">
	<summary>
 Notes
 (1) This function compares two grayscale photo regions.  If a
 box is given, the region is clipped; otherwise assume
 the entire images are photo regions.  This is done with a
 set of (nx  ny) spatially aligned histograms, which are
 aligned using the centroid of the inverse image.
 (2) An initial filter gives %score = 0 if the ratio of widths
 and heights (smallest / largest) does not exceed a
 threshold %minratio.  This must be between 0.5 and 1.0.
 If set at 1.0, both images must be exactly the same size.
 A typical value for %minratio is 0.9.
 (3) Because this function should not be used on text or
 line graphics, which can give false positive results
 (i.e., high scores for different images), filter the images
 using pixGenPhotoHistos(), which returns tiled histograms
 only if an image is not text and comparison is expected
 to work with histograms.  If either image fails the test,
 the comparison returns a score of 0.0.
 (4) The white value counts in the histograms are removed; they
 are typically pixels that were padded to achieve alignment.
 (5) For an efficient representation of the histogram, normalize
 using a multiplicative factor so that the number in the
 maximum bucket is 255.  It then takes 256 bytes to store.
 (6) When comparing the histograms of two regions, use the
 Earth Mover distance (EMD), with the histograms normalized
 so that the sum over bins is the same.  Further normalize
 by dividing by 255, so that the result is in [0.0 ... 1.0].
 (7) Get a similarity score S = 1.0 - k  D, where
 k is a constant, say in the range 5-10
 D = normalized EMD
 and for multiple tiles, take the Min(S) to be the final score.
 Using aligned tiles gives protection against accidental
 similarity of the overall grayscale histograms.
 A small number of aligned tiles works well.
 (8) With debug on, you get a pdf that shows, for each tile,
 the images, histograms and score.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">any depth; colormap OK</param>
	<param name="pix2">any depth; colormap OK</param>
	<param name="box1">photo regions from each; can be null</param>
	<param name="box2">photo regions from each; can be null</param>
	<param name="minratio">requiring sizes be compatible; LT 1.0</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="nx">num subregions to use for histograms; e.g. 3x3</param>
	<param name="ny">num subregions to use for histograms; e.g. 3x3</param>
	<param name="pscore">similarity score of histograms</param>
	<param name="debugflag">1 for debug output; 0 for no debugging</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenPhotoHistos(System.IntPtr,System.IntPtr,System.Int32,System.Single,System.Int32,System.Int32,System.IntPtr@,System.Int32@,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) This crops and converts to 8 bpp if necessary.  It adds a
 minimal white boundary such that the centroid of the
 photo-inverted image is in the center. This allows
 automatic alignment with histograms of other image regions.
 (2) The white value in the histogram is removed, because of
 the padding.
 (3) Use 0 for conservative default (1.3) for thresh.
 (4) For an efficient representation of the histogram, normalize
 using a multiplicative factor so that the number in the
 maximum bucket is 255.  It then takes 256 bytes to store.
 (5) With %debugindex GT 0, this makes a pdf that shows, for each tile,
 the images and histograms.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">depth GT 1 bpp; colormap OK</param>
	<param name="box">region to be selected; can be null</param>
	<param name="factor">subsampling; GT= 1</param>
	<param name="thresh">threshold for photo/text; use 0 for default</param>
	<param name="nx">number of subregions to use for histograms; e.g. 3x3</param>
	<param name="ny">number of subregions to use for histograms; e.g. 3x3</param>
	<param name="pnaa">nx  ny 256-entry gray histograms</param>
	<param name="pw">width of image used to make histograms</param>
	<param name="ph">height of image used to make histograms</param>
	<param name="debugindex">0 for no debugging; positive integer otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixPadToCenterCentroid(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This add minimum white padding to an 8 bpp pix, such that
 the centroid of the photometric inverse is in the center of
 the resulting image.  Thus in computing the centroid,
 black pixels have weight 255, and white pixels have weight 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, colormap OK</param>
	<param name="factor">subsampling for centroid; GT= 1</param>
	<returns>pixd padded with white pixels, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCentroid8(System.IntPtr,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This first does a photometric inversion (black = 255, white = 0).
 It then finds the centroid of the result.  The inversion is
 done because white is usually background, so the centroid
 is computed based on the "foreground" gray pixels, and the
 darker the pixel, the more weight it is given.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="pcx">x value of centroid</param>
	<param name="pcy">y value of centroid</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDecideIfPhotoImage(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr@,System.IntPtr)">
	<summary>
 Notes
 (1) The input image must be 8 bpp (no colormap), and padded with
 white pixels so the centroid of photo-inverted pixels is at
 the center of the image.
 (2) If the pix is not almost certainly a photoimage, the returned
 histograms (%naa) are null.
 (3) If histograms are generated, the white (255) count is set
 to 0.  This removes all pixels values above 230, including
 white padding from the centroid matching operation, from
 consideration.  The resulting histograms are then normalized
 so the maximum count is 255.
 (4) Default for %thresh is 1.3; this seems sufficiently conservative.
 (5) Use %pixadebug == NULL unless debug output is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp, centroid in center</param>
	<param name="factor">subsampling for histograms; GT= 1</param>
	<param name="nx">number of subregions to use for histograms</param>
	<param name="ny">number of subregions to use for histograms</param>
	<param name="thresh">threshold for photo/text; use 0 for default</param>
	<param name="pnaa">array of normalized histograms</param>
	<param name="pixadebug">use only for debug output</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.compareTilesByHisto(System.IntPtr,System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Single[]@,System.IntPtr)">
	<summary>
 Notes
 (1) naa1 and naa2 must be generated using pixGenPhotoHistos(),
 using the same tile sizes.
 (2) The image dimensions must be similar.  The score is 0.0
 if the ratio of widths and heights (smallest / largest)
 exceeds a threshold %minratio, which must be between
 0.5 and 1.0.  If set at 1.0, both images must be exactly
 the same size.  A typical value for %minratio is 0.9.
 (2) The input pixadebug is null unless debug output is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="naa1">each is a set of 256 entry histograms</param>
	<param name="naa2">each is a set of 256 entry histograms</param>
	<param name="minratio">requiring image sizes be compatible; LT 1.0</param>
	<param name="w1">image sizes from which histograms were made</param>
	<param name="h1">image sizes from which histograms were made</param>
	<param name="w2">image sizes from which histograms were made</param>
	<param name="h2">image sizes from which histograms were made</param>
	<param name="pscore">similarity score of histograms</param>
	<param name="pixadebug">use only for debug output</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCompareGrayByHisto(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Single[]@,System.Int32)">
	<summary>
 Notes
 (1) This function compares two grayscale photo regions.  It can
 do it with a single histogram from each region, or with a
 set of (nx  ny) spatially aligned histograms.  For both
 cases, align the regions using the centroid of the inverse
 image, and crop to the smallest of the two.
 (2) An initial filter gives %score = 0 if the ratio of widths
 and heights (smallest / largest) does not exceed a
 threshold %minratio.  This must be between 0.5 and 1.0.
 If set at 1.0, both images must be exactly the same size.
 A typical value for %minratio is 0.9.
 (3) The lightest values in the histogram can be disregarded.
 Set %maxgray to the lightest value to be kept.  For example,
 to eliminate white (255), set %maxgray = 254.  %maxgray must
 be GT= 200.
 (4) For an efficient representation of the histogram, normalize
 using a multiplicative factor so that the number in the
 maximum bucket is 255.  It then takes 256 bytes to store.
 (5) When comparing the histograms of two regions
 ~ Use %maxgray = 254 to ignore the white pixels, the number
 of which may be sensitive to the crop region if the pixels
 outside that region are white.
 ~ Use the Earth Mover distance (EMD), with the histograms
 normalized so that the sum over bins is the same.
 Further normalize by dividing by 255, so that the result
 is in [0.0 ... 1.0].
 (6) Get a similarity score S = 1.0 - k  D, where
 k is a constant, say in the range 5-10
 D = normalized EMD
 and for multiple tiles, take the Min(S) to be the final score.
 Using aligned tiles gives protection against accidental
 similarity of the overall grayscale histograms.
 A small number of aligned tiles works well.
 (7) With debug on, you get a pdf that shows, for each tile,
 the images, histograms and score.
 (8) When to use
 (a) Because this function should not be used on text or
 line graphics, which can give false positive results
 (i.e., high scores for different images), the input
 images should be filtered.
 (b) To filter, first use pixDecideIfText().  If that function
 says the image is text, do not use it.  If the function
 says it is not text, it still may be line graphics, and
 in that case, use
 pixGetGrayHistogramTiled()
 grayInterHistogramStats()
 to determine whether it is photo or line graphics.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">any depth; colormap OK</param>
	<param name="pix2">any depth; colormap OK</param>
	<param name="box1">region selected from each; can be null</param>
	<param name="box2">region selected from each; can be null</param>
	<param name="minratio">requiring sizes be compatible; LT 1.0</param>
	<param name="maxgray">max value to keep in histo; GT= 200, 255 to keep all</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="nx">num subregions to use for histograms; e.g. 3x3</param>
	<param name="ny">num subregions to use for histograms; e.g. 3x3</param>
	<param name="pscore">similarity score of histograms</param>
	<param name="debugflag">1 for debug output; 0 for no debugging</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCropAlignedToCentroid(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This finds the maximum crop boxes for two 8 bpp images when
 their centroids of their photometric inverses are aligned.
 Black pixels have weight 255; white pixels have weight 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">any depth; colormap OK</param>
	<param name="pix2">any depth; colormap OK</param>
	<param name="factor">subsampling; GT= 1</param>
	<param name="pbox1">crop box for pix1</param>
	<param name="pbox2">crop box for pix2</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_compressGrayHistograms(System.IntPtr,System.Int32,System.Int32,System.UInt32@)">
	<summary>
 Notes
 (1) This first writes w and h to the byte array as 4 byte ints.
 (2) Then it normalizes each histogram to a max value of 255,
 and saves each value as a byte.  If there are
 N histograms, the output bytearray has 8 + 256  N bytes.
 (3) Further compression of the array with zlib yields only about
 a 25% decrease in size, so we don't bother.  If size reduction
 were important, a lossy transform using a 1-dimensional DCT
 would be effective, because we don't care about the fine
 details of these histograms.
 </summary>
	<remarks>
	</remarks>
	<param name="naa">set of 256-entry histograms</param>
	<param name="w">size of image</param>
	<param name="h">size of image</param>
	<param name="psize">size of byte array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_uncompressGrayHistograms(System.Byte[],System.UInt32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The first 8 bytes are read as two 32-bit ints.
 (2) Then this constructs a numaa representing some number of
 gray histograms that are normalized such that the max value
 in each histogram is 255.  The data is stored as a byte
 array, with 256 bytes holding the data for each histogram.
 Each gray histogram was computed from a tile of a grayscale image.
 </summary>
	<remarks>
	</remarks>
	<param name="bytea">byte array of size 8 + 256  N, N an integer</param>
	<param name="size">size of byte array</param>
	<param name="pw">width of the image that generated the histograms</param>
	<param name="ph">height of the image</param>
	<returns>numaa     representing N histograms, each with 256 bins, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCompareWithTranslation(System.IntPtr,System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Single[]@,System.Int32)">
	<summary>
 Notes
 (1) This does a coarse-to-fine search for best translational
 alignment of two images, measured by a scoring function
 that is the correlation between the fg pixels.
 (2) The threshold is used if the images aren't 1 bpp.
 (3) With debug on, you get a pdf that shows, as a grayscale
 image, the score as a function of shift from the initial
 estimate, for each of the four levels.  The shift is 0 at
 the center of the image.
 (4) With debug on, you also get a pdf that shows the
 difference at the best alignment between the two images,
 at each of the four levels.  The red and green pixels
 show locations where one image has a fg pixel and the
 other doesn't.  The black pixels are where both images
 have fg pixels, and white pixels are where neither image
 has fg pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">any depth; colormap OK</param>
	<param name="pix2">any depth; colormap OK</param>
	<param name="thresh">threshold for converting to 1 bpp</param>
	<param name="pdelx">x translation on pix2 to align with pix1</param>
	<param name="pdely">y translation on pix2 to align with pix1</param>
	<param name="pscore">correlation score at best alignment</param>
	<param name="debugflag">1 for debug output; 0 for no debugging</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBestCorrelation(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32@,System.Int32@,System.Single[]@,System.Int32)">
	<summary>
 Notes
 (1) This maximizes the correlation score between two 1 bpp images,
 by starting with an estimate of the alignment
 (%etransx, %etransy) and computing the correlation around this.
 It optionally returns the shift (%delx, %dely) that maximizes
 the correlation score when pix2 is shifted by this amount
 relative to pix1.
 (2) Get the centroids of pix1 and pix2, using pixCentroid(),
 to compute (%etransx, %etransy).  Get the areas using
 pixCountPixels().
 (3) The centroid of pix2 is shifted with respect to the centroid
 of pix1 by all values between -maxshiftx and maxshiftx,
 and likewise for the y shifts.  Therefore, the number of
 correlations computed is
 (2  maxshiftx + 1)  (2  maxshifty + 1)
 Consequently, if pix1 and pix2 are large, you should do this
 in a coarse-to-fine sequence.  See the use of this function
 in pixCompareWithTranslation().
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">1 bpp</param>
	<param name="pix2">1 bpp</param>
	<param name="area1">number of on pixels in pix1</param>
	<param name="area2">number of on pixels in pix2</param>
	<param name="etransx">estimated x translation of pix2 to align with pix1</param>
	<param name="etransy">estimated y translation of pix2 to align with pix1</param>
	<param name="maxshift">max x and y shift of pix2, around the estimated alignment location, relative to pix1</param>
	<param name="tab8">sum tab for ON pixels in byte; can be NULL</param>
	<param name="pdelx">best x shift of pix2 relative to pix1</param>
	<param name="pdely">best y shift of pix2 relative to pix1</param>
	<param name="pscore">maximum score found; can be NULL</param>
	<param name="debugflag">LT= 0 to skip; positive to generate output. The integer is used to label the debug image.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConnComp(System.IntPtr,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This is the top-level call for getting bounding boxes or
 a pixa of the components, and it can be used instead
 of either pixConnCompBB() or pixConnCompPixa(), rsp.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="ppixa">pixa of each c.c.</param>
	<param name="connectivity">4 or 8</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConnCompPixa(System.IntPtr,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This finds bounding boxes of 4- or 8-connected components
 in a binary image, and saves images of each c.c
 in a pixa array.
 (2) It sets up 2 temporary pix, and for each c.c. that is
 located in raster order, it erases the c.c. from one pix,
 then uses the b.b. to extract the c.c. from the two pix using
 an XOR, and finally erases the c.c. from the second pix.
 (3) A clone of the returned boxa (where all boxes in the array
 are clones) is inserted into the pixa.
 (4) If the input is valid, this always returns a boxa and a pixa.
 If pixs is empty, the boxa and pixa will be empty.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="ppixa">pixa of each c.c.</param>
	<param name="connectivity">4 or 8</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConnCompBB(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Finds bounding boxes of 4- or 8-connected components
 in a binary image.
 (2) This works on a copy of the input pix.  The c.c. are located
 in raster order and erased one at a time.  In the process,
 the b.b. is computed and saved.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">4 or 8</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCountConnComp(System.IntPtr,System.Int32,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">4 or 8</param>
	<param name="pcount"></param>
	<returns>0 if OK, 1 on error Notes (1 This is the top-level call for getting the number of 4- or 8-connected components in a 1 bpp image. 2 It works on a copy of the input pix.  The c.c. are located in raster order and erased one at a time.</returns>
</member><member name="M:LeptonicaSharp.Natives.nextOnPixelInRaster(System.IntPtr,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="xstart">starting point for search</param>
	<param name="ystart">starting point for search</param>
	<param name="px">coord value of next ON pixel</param>
	<param name="py">coord value of next ON pixel</param>
	<returns>1 if a pixel is found; 0 otherwise or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.nextOnPixelInRasterLow(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">pix data</param>
	<param name="w">width and height</param>
	<param name="h">width and height</param>
	<param name="wpl">words per line</param>
	<param name="xstart">starting point for search</param>
	<param name="ystart">starting point for search</param>
	<param name="px">coord value of next ON pixel</param>
	<param name="py">coord value of next ON pixel</param>
	<returns>1 if a pixel is found; 0 otherwise or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfillBB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is the high-level interface to Paul Heckbert's
 stack-based seedfill algorithm.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="stack">for holding fillsegs</param>
	<param name="x">,y   location of seed pixel</param>
	<param name="connectivity">4 or 8</param>
	<returns>box or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfill4BB(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.
 (2) This operates on the input 1 bpp pix to remove the fg seed
 pixel, at (x,y), and all pixels that are 4-connected to it.
 The seed pixel at (x,y) must initially be ON.
 (3) Returns the bounding box of the erased 4-cc component.
 (4) Reference see Paul Heckbert's stack-based seed fill algorithm
 in "Graphic Gems", ed. Andrew Glassner, Academic
 Press, 1990.  The algorithm description is given
 on pp. 275-277; working C code is on pp. 721-722.)
 The code here follows Heckbert's exactly, except
 we use function calls instead of macros for
 pushing data on and popping data off the stack.
 This makes sense to do because Heckbert's fixed-size
 stack with macros is dangerous images exist that
 will overrun the stack and crash.   The stack utility
 here grows dynamically as needed, and the fillseg
 structures that are not in use are stored in another
 stack for reuse.  It should be noted that the
 overhead in the function calls (vs. macros) is negligible.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="stack">for holding fillsegs</param>
	<param name="x">,y   location of seed pixel</param>
	<returns>box or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfill8BB(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.
 (2) This operates on the input 1 bpp pix to remove the fg seed
 pixel, at (x,y), and all pixels that are 8-connected to it.
 The seed pixel at (x,y) must initially be ON.
 (3) Returns the bounding box of the erased 8-cc component.
 (4) Reference see Paul Heckbert's stack-based seed fill algorithm
 in "Graphic Gems", ed. Andrew Glassner, Academic
 Press, 1990.  The algorithm description is given
 on pp. 275-277; working C code is on pp. 721-722.)
 The code here follows Heckbert's closely, except
 the leak checks are changed for 8 connectivity.
 See comments on pixSeedfill4BB() for more details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="stack">for holding fillsegs</param>
	<param name="x">,y   location of seed pixel</param>
	<returns>box or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfill(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This removes the component from pixs with a fg pixel at (x,y).
 (2) See pixSeedfill4() and pixSeedfill8() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="stack">for holding fillsegs</param>
	<param name="x">,y   location of seed pixel</param>
	<param name="connectivity">4 or 8</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfill4(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.
 (2) This operates on the input 1 bpp pix to remove the fg seed
 pixel, at (x,y), and all pixels that are 4-connected to it.
 The seed pixel at (x,y) must initially be ON.
 (3) Reference see pixSeedFill4BB()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="stack">for holding fillsegs</param>
	<param name="x">,y   location of seed pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfill8(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.
 (2) This operates on the input 1 bpp pix to remove the fg seed
 pixel, at (x,y), and all pixels that are 8-connected to it.
 The seed pixel at (x,y) must initially be ON.
 (3) Reference see pixSeedFill8BB()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="stack">for holding fillsegs</param>
	<param name="x">,y   location of seed pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertFilesTo1bpp(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Int32)">
	<summary>
 Notes
 (1) Images are sorted lexicographically, and the names in the
 output directory are retained except for the extension.
 </summary>
	<remarks>
	</remarks>
	<param name="dirin"></param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="upscaling">1, 2 or 4; only for input color or grayscale</param>
	<param name="thresh">global threshold for binarization; use 0 for default</param>
	<param name="firstpage"></param>
	<param name="npages">use 0 to do all from %firstpage to the end</param>
	<param name="dirout"></param>
	<param name="outformat">IFF_PNG, IFF_TIFF_G4</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlockconv(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1)
 (2) Returns a copy if both wc and hc are 0
 (3) Require that w GT= 2  wc + 1 and h GT= 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlockconvGray(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If accum pix is null, make one and destroy it before
 returning; otherwise, just use the input accum pix.
 (2) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1).
 (3) Returns a copy if both wc and hc are 0.
 (4) Require that w GT= 2  wc + 1 and h GT= 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="pixacc">pix 32 bpp; can be null</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<returns>pix 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlockconvAccum(System.IntPtr)">
	<summary>
 Notes
 (1) The general recursion relation is
 a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)
 For the first line, this reduces to the special case
 a(i,j) = v(i,j) + a(i, j-1)
 For the first column, the special case is
 a(i,j) = v(i,j) + a(i-1, j)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 or 32 bpp</param>
	<returns>accum pix 32 bpp, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlockconvGrayUnnormalized(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1).
 (2) Require that w GT= 2  wc + 1 and h GT= 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 (3) Returns a copy if both wc and hc are 0.
 (3) Adds mirrored border to avoid treating the boundary pixels
 specially.  Note that we add wc + 1 pixels to the left
 and wc to the right.  The added width is 2  wc + 1 pixels,
 and the particular choice simplifies the indexing in the loop.
 Likewise, add hc + 1 pixels to the top and hc to the bottom.
 (4) To get the normalized result, divide by the area of the
 convolution kernel (2  wc + 1)  (2  hc + 1)
 Specifically, do this
 pixc = pixBlockconvGrayUnnormalized(pixs, wc, hc);
 fract = 1. / ((2  wc + 1)  (2  hc + 1));
 pixMultConstantGray(pixc, fract);
 pixd = pixGetRGBComponent(pixc, L_ALPHA_CHANNEL);
 (5) Unlike pixBlockconvGray(), this always computes the accumulation
 pix because its size is tied to wc and hc.
 (6) Compare this implementation with pixBlockconvGray(), where
 most of the code in blockconvLow() is special casing for
 efficiently handling the boundary.  Here, the use of
 mirrored borders and destination indexing makes the
 implementation very simple.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<returns>pix 32 bpp; containing the convolution without normalizing for the window size, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlockconvTiled(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1)
 (2) Returns a copy if both wc and hc are 0
 (3) Require that w GT= 2  wc + 1 and h GT= 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 (4) For nx == ny == 1, this defaults to pixBlockconv(), which
 is typically about twice as fast, and gives nearly
 identical results as pixBlockconvGrayTile().
 (5) If the tiles are too small, nx and/or ny are reduced
 a minimum amount so that the tiles are expanded to the
 smallest workable size in the problematic direction(s).
 (6) Why a tiled version?  Three reasons
 (a) Because the accumulator is a uint32, overflow can occur
 for an image with more than 16M pixels.
 (b) The accumulator array for 16M pixels is 64 MB; using
 tiles reduces the size of this array.
 (c) Each tile can be processed independently, in parallel,
 on a multicore processor.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<param name="nx">subdivision into tiles</param>
	<param name="ny">subdivision into tiles</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlockconvGrayTile(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1)
 (2) Assumes that the input pixs is padded with (wc + 1) pixels on
 left and right, and with (hc + 1) pixels on top and bottom.
 The returned pix has these stripped off; they are only used
 for computation.
 (3) Returns a copy if both wc and hc are 0
 (4) Require that w GT 2  wc + 1 and h GT 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray</param>
	<param name="pixacc">32 bpp accum pix</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWindowedStats(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This is a high-level convenience function for calculating
 any or all of these derived images.
 (2) If %hasborder = 0, a border is added and the result is
 computed over all pixels in pixs.  Otherwise, no border is
 added and the border pixels are removed from the output images.
 (3) These statistical measures over the pixels in the
 rectangular window are
 ~ average value LTpGT  (pixm)
 ~ average squared value LTppGT (pixms)
 ~ variance LT(p - LTpGT)(p - LTpGT)GT = LTppGT - LTpGTLTpGT  (pixv)
 ~ square-root of variance (pixrv)
 where the brackets LT .. GT indicate that the average value is
 to be taken over the window.
 (4) Note that the variance is just the mean square difference from
 the mean value; and the square root of the variance is the
 root mean square difference from the mean, sometimes also
 called the 'standard deviation'.
 (5) The added border, along with the use of an accumulator array,
 allows computation without special treatment of pixels near
 the image boundary, and runs in a time that is independent
 of the size of the convolution kernel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<param name="hasborder">use 1 if it already has (wc + 1 border pixels on left and right, and hc + 1 on top and bottom; use 0 to add kernel-dependent border)</param>
	<param name="ppixm">8 bpp mean value in window</param>
	<param name="ppixms">32 bpp mean square value in window</param>
	<param name="pfpixv">float variance in window</param>
	<param name="pfpixrv">float rms deviation from the mean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWindowedMean(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The input and output depths are the same.
 (2) A set of border pixels of width (wc + 1) on left and right,
 and of height (hc + 1) on top and bottom, must be on the
 pix before the accumulator is found.  The output pixd
 (after convolution) has this border removed.
 If %hasborder = 0, the required border is added.
 (3) Typically, %normflag == 1.  However, if you want the sum
 within the window, rather than a normalized convolution,
 use %normflag == 0.
 (4) This builds a block accumulator pix, uses it here, and
 destroys it.
 (5) The added border, along with the use of an accumulator array,
 allows computation without special treatment of pixels near
 the image boundary, and runs in a time that is independent
 of the size of the convolution kernel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp grayscale</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<param name="hasborder">use 1 if it already has (wc + 1 border pixels on left and right, and hc + 1 on top and bottom; use 0 to add kernel-dependent border)</param>
	<param name="normflag">1 for normalization to get average in window; 0 for the sum in the window (un-normalized)</param>
	<returns>pixd 8 or 32 bpp, average over kernel window</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWindowedMeanSquare(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) A set of border pixels of width (wc + 1) on left and right,
 and of height (hc + 1) on top and bottom, must be on the
 pix before the accumulator is found.  The output pixd
 (after convolution) has this border removed.
 If %hasborder = 0, the required border is added.
 (2) The advantage is that we are unaffected by the boundary, and
 it is not necessary to treat pixels within %wc and %hc of the
 border differently.  This is because processing for pixd
 only takes place for pixels in pixs for which the
 kernel is entirely contained in pixs.
 (3) Why do we have an added border of width (%wc + 1) and
 height (%hc + 1), when we only need %wc and %hc pixels
 to satisfy this condition?  Answer the accumulators
 are asymmetric, requiring an extra row and column of
 pixels at top and left to work accurately.
 (4) The added border, along with the use of an accumulator array,
 allows computation without special treatment of pixels near
 the image boundary, and runs in a time that is independent
 of the size of the convolution kernel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<param name="hasborder">use 1 if it already has (wc + 1 border pixels on left and right, and hc + 1 on top and bottom; use 0 to add kernel-dependent border)</param>
	<returns>pixd 32 bpp, average over rectangular window of width = 2  wc + 1 and height = 2  hc + 1</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWindowedVariance(System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The mean and mean square values are precomputed, using
 pixWindowedMean() and pixWindowedMeanSquare().
 (2) Either or both of the variance and square-root of variance
 are returned as an fpix, where the variance is the
 average over the window of the mean square difference of
 the pixel value from the mean
 LT(p - LTpGT)(p - LTpGT)GT = LTppGT - LTpGTLTpGT
 (3) To visualize the results
 ~ for both, use fpixDisplayMaxDynamicRange().
 ~ for rms deviation, simply convert the output fpix to pix,
 </summary>
	<remarks>
	</remarks>
	<param name="pixm">mean over window; 8 or 32 bpp grayscale</param>
	<param name="pixms">mean square over window; 32 bpp</param>
	<param name="pfpixv">float variance -- the ms deviation from the mean</param>
	<param name="pfpixrv">float rms deviation from the mean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMeanSquareAccum(System.IntPtr)">
	<summary>
 Notes
 (1) Similar to pixBlockconvAccum(), this computes the
 sum of the squares of the pixel values in such a way
 that the value at (i,j) is the sum of all squares in
 the rectangle from the origin to (i,j).
 (2) The general recursion relation (v are squared pixel values) is
 a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)
 For the first line, this reduces to the special case
 a(i,j) = v(i,j) + a(i, j-1)
 For the first column, the special case is
 a(i,j) = v(i,j) + a(i-1, j)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<returns>dpix 64 bit array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlockrank(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1)
 (2) This returns a pixd where each pixel is a 1 if the
 neighborhood (2  wc + 1) x (2  hc + 1)) pixels
 contains the rank fraction of 1 pixels.  Otherwise,
 the returned pixel is 0.  Note that the special case
 of rank = 0.0 is always satisfied, so the returned
 pixd has all pixels with value 1.
 (3) If accum pix is null, make one, use it, and destroy it
 before returning; otherwise, just use the input accum pix
 (4) If both wc and hc are 0, returns a copy unless rank == 0.0,
 in which case this returns an all-ones image.
 (5) Require that w GT= 2  wc + 1 and h GT= 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pixacc">pix [optional] 32 bpp</param>
	<param name="wc">half width/height of block sum/rank kernel</param>
	<param name="hc">half width/height of block sum/rank kernel</param>
	<param name="rank">between 0.0 and 1.0; 0.5 is median filter</param>
	<returns>pixd 1 bpp</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlocksum(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If accum pix is null, make one and destroy it before
 returning; otherwise, just use the input accum pix
 (2) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1)
 (3) Use of wc = hc = 1, followed by pixInvert() on the
 8 bpp result, gives a nice anti-aliased, and somewhat
 darkened, result on text.
 (4) Require that w GT= 2  wc + 1 and h GT= 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 (5) Returns in each dest pixel the sum of all src pixels
 that are within a block of size of the kernel, centered
 on the dest pixel.  This sum is the number of src ON
 pixels in the block at each location, normalized to 255
 for a block containing all ON pixels.  For pixels near
 the boundary, where the block is not entirely contained
 within the image, we then multiply by a second normalization
 factor that is greater than one, so that all results
 are normalized by the number of participating pixels
 within the block.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pixacc">pix [optional] 32 bpp</param>
	<param name="wc">half width/height of block sum/rank kernel</param>
	<param name="hc">half width/height of block sum/rank kernel</param>
	<returns>pixd 8 bpp</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCensusTransform(System.IntPtr,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) The Census transform was invented by Ramin Zabih and John Woodfill
 ("Non-parametric local transforms for computing visual
 correspondence", Third European Conference on Computer Vision,
 Stockholm, Sweden, May 1994); see publications at
 http//www.cs.cornell.edu/~rdz/index.htm
 This compares each pixel against the average of its neighbors,
 in a square of odd dimension centered on the pixel.
 If the pixel is greater than the average of its neighbors,
 the output pixel value is 1; otherwise it is 0.
 (2) This can be used as an encoding for an image that is
 fairly robust against slow illumination changes, with
 applications in image comparison and mosaicing.
 (3) The size of the convolution kernel is (2  halfsize + 1)
 on a side.  The halfsize parameter must be GT= 1.
 (4) If accum pix is null, make one, use it, and destroy it
 before returning; otherwise, just use the input accum pix
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="halfsize">of square over which neighbors are averaged</param>
	<param name="pixacc">pix [optional] 32 bpp</param>
	<returns>pixd 1 bpp</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvolve(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This gives a convolution with an arbitrary kernel.
 (2) The input pixs must have only one sample/pixel.
 To do a convolution on an RGB image, use pixConvolveRGB().
 (3) The parameter %outdepth determines the depth of the result.
 If the kernel is normalized to unit sum, the output values
 can never exceed 255, so an output depth of 8 bpp is sufficient.
 If the kernel is not normalized, it may be necessary to use
 16 or 32 bpp output to avoid overflow.
 (4) If normflag == 1, the result is normalized by scaling all
 kernel values for a unit sum.  If the sum of kernel values
 is very close to zero, the kernel can not be normalized and
 the convolution will not be performed.  A warning is issued.
 (5) The kernel values can be positive or negative, but the
 result for the convolution can only be stored as a positive
 number.  Consequently, if it goes negative, the choices are
 to clip to 0 or take the absolute value.  We're choosing
 to take the absolute value.  (Another possibility would be
 to output a second unsigned image for the negative values.)
 If you want to get a clipped result, or to keep the negative
 values in the result, use fpixConvolve(), with the
 converters in fpix2.c between pix and fpix.
 (6) This uses a mirrored border to avoid special casing on
 the boundaries.
 (7) To get a subsampled output, call l_setConvolveSampling().
 The time to make a subsampled output is reduced by the
 product of the sampling factors.
 (8) The function is slow, running at about 12 machine cycles for
 each pixel-op in the convolution.  For example, with a 3 GHz
 cpu, a 1 Mpixel grayscale image, and a kernel with
 (sx  sy) = 25 elements, the convolution takes about 100 msec.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16, 32 bpp; no colormap</param>
	<param name="kel">kernel</param>
	<param name="outdepth">of pixd 8, 16 or 32</param>
	<param name="normflag">1 to normalize kernel to unit sum; 0 otherwise</param>
	<returns>pixd 8, 16 or 32 bpp</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvolveSep(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does a convolution with a separable kernel that is
 is a sequence of convolutions in x and y.  The two
 one-dimensional kernel components must be input separately;
 the full kernel is the product of these components.
 The support for the full kernel is thus a rectangular region.
 (2) The input pixs must have only one sample/pixel.
 To do a convolution on an RGB image, use pixConvolveSepRGB().
 (3) The parameter %outdepth determines the depth of the result.
 If the kernel is normalized to unit sum, the output values
 can never exceed 255, so an output depth of 8 bpp is sufficient.
 If the kernel is not normalized, it may be necessary to use
 16 or 32 bpp output to avoid overflow.
 (2) The %normflag parameter is used as in pixConvolve().
 (4) The kernel values can be positive or negative, but the
 result for the convolution can only be stored as a positive
 number.  Consequently, if it goes negative, the choices are
 to clip to 0 or take the absolute value.  We're choosing
 the former for now.  Another possibility would be to output
 a second unsigned image for the negative values.
 (5) Warning if you use l_setConvolveSampling() to get a
 subsampled output, and the sampling factor is larger than
 the kernel half-width, it is faster to use the non-separable
 version pixConvolve().  This is because the first convolution
 here must be done on every raster line, regardless of the
 vertical sampling factor.  If the sampling factor is smaller
 than kernel half-width, it's faster to use the separable
 convolution.
 (6) This uses mirrored borders to avoid special casing on
 the boundaries.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16, 32 bpp; no colormap</param>
	<param name="kelx">x-dependent kernel</param>
	<param name="kely">y-dependent kernel</param>
	<param name="outdepth">of pixd 8, 16 or 32</param>
	<param name="normflag">1 to normalize kernel to unit sum; 0 otherwise</param>
	<returns>pixd 8, 16 or 32 bpp</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvolveRGB(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This gives a convolution on an RGB image using an
 arbitrary kernel (which we normalize to keep each
 component within the range [0 ... 255].
 (2) The input pixs must be RGB.
 (3) The kernel values can be positive or negative, but the
 result for the convolution can only be stored as a positive
 number.  Consequently, if it goes negative, we clip the
 result to 0.
 (4) To get a subsampled output, call l_setConvolveSampling().
 The time to make a subsampled output is reduced by the
 product of the sampling factors.
 (5) This uses a mirrored border to avoid special casing on
 the boundaries.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="kel">kernel</param>
	<returns>pixd 32 bpp rgb</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvolveRGBSep(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This does a convolution on an RGB image using a separable
 kernel that is a sequence of convolutions in x and y.  The two
 one-dimensional kernel components must be input separately;
 the full kernel is the product of these components.
 The support for the full kernel is thus a rectangular region.
 (2) The kernel values can be positive or negative, but the
 result for the convolution can only be stored as a positive
 number.  Consequently, if it goes negative, we clip the
 result to 0.
 (3) To get a subsampled output, call l_setConvolveSampling().
 The time to make a subsampled output is reduced by the
 product of the sampling factors.
 (4) This uses a mirrored border to avoid special casing on
 the boundaries.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="kelx">x-dependent kernel</param>
	<param name="kely">y-dependent kernel</param>
	<returns>pixd 32 bpp rgb</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixConvolve(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This gives a float convolution with an arbitrary kernel.
 (2) If normflag == 1, the result is normalized by scaling all
 kernel values for a unit sum.  If the sum of kernel values
 is very close to zero, the kernel can not be normalized and
 the convolution will not be performed.  A warning is issued.
 (3) With the FPix, there are no issues about negative
 array or kernel values.  The convolution is performed
 with single precision arithmetic.
 (4) To get a subsampled output, call l_setConvolveSampling().
 The time to make a subsampled output is reduced by the
 product of the sampling factors.
 (5) This uses a mirrored border to avoid special casing on
 the boundaries.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs">32 bit float array</param>
	<param name="kel">kernel</param>
	<param name="normflag">1 to normalize kernel to unit sum; 0 otherwise</param>
	<returns>fpixd 32 bit float array</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixConvolveSep(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This does a convolution with a separable kernel that is
 is a sequence of convolutions in x and y.  The two
 one-dimensional kernel components must be input separately;
 the full kernel is the product of these components.
 The support for the full kernel is thus a rectangular region.
 (2) The normflag parameter is used as in fpixConvolve().
 (3) Warning if you use l_setConvolveSampling() to get a
 subsampled output, and the sampling factor is larger than
 the kernel half-width, it is faster to use the non-separable
 version pixConvolve().  This is because the first convolution
 here must be done on every raster line, regardless of the
 vertical sampling factor.  If the sampling factor is smaller
 than kernel half-width, it's faster to use the separable
 convolution.
 (4) This uses mirrored borders to avoid special casing on
 the boundaries.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs">32 bit float array</param>
	<param name="kelx">x-dependent kernel</param>
	<param name="kely">y-dependent kernel</param>
	<param name="normflag">1 to normalize kernel to unit sum; 0 otherwise</param>
	<returns>fpixd 32 bit float array</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvolveWithBias(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This does a convolution with either a single kernel or
 a pair of separable kernels, and automatically applies whatever
 bias (shift) is required so that the resulting pixel values
 are non-negative.
 (2) The kernel is always normalized.  If there are no negative
 values in the kernel, a standard normalized convolution is
 performed, with 8 bpp output.  If the sum of kernel values is
 very close to zero, the kernel can not be normalized and
 the convolution will not be performed.  An error message results.
 (3) If there are negative values in the kernel, the pix is
 converted to an fpix, the convolution is done on the fpix, and
 a bias (shift) may need to be applied.
 (4) If force8 == TRUE and the range of values after the convolution
 is GT 255, the output values will be scaled to fit in [0 ... 255].
 If force8 == FALSE, the output will be either 8 or 16 bpp,
 to accommodate the dynamic range of output values without scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="kel1"></param>
	<param name="kel2">; use if separable</param>
	<param name="force8">if 1, force output to 8 bpp; otherwise, determine output depth by the dynamic range of pixel values</param>
	<param name="pbias">applied bias</param>
	<returns>pixd 8 or 16 bpp</returns>
</member><member name="M:LeptonicaSharp.Natives.l_setConvolveSampling(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This sets the x and y output subsampling factors for generic pix
 and fpix convolution.  The default values are 1 (no subsampling).
 </summary>
	<remarks>
	</remarks>
	<param name="xfact">integer GT= 1</param>
	<param name="yfact">integer GT= 1</param>
</member><member name="M:LeptonicaSharp.Natives.pixAddGaussianNoise(System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) This adds noise to each pixel, taken from a normal
 distribution with zero mean and specified standard deviation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb; no colormap</param>
	<param name="stdev">of noise</param>
	<returns>pixd 8 or 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gaussDistribSampling">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixCorrelationScore(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32[],System.Single[]@)">
	<summary>
 Notes
 We check first that the two pix are roughly the same size.
 For jbclass (jbig2) applications at roughly 300 ppi, maxdiffw and
 maxdiffh should be at least 2.
 Only if they meet that criterion do we compare the bitmaps.
 The centroid difference is used to align the two images to the
 nearest integer for the correlation.
 The correlation score is the ratio of the square of the number of
 pixels in the AND of the two bitmaps to the product of the number
 of ON pixels in each.  Denote the number of ON pixels in pix1
 by |1|, the number in pix2 by |2|, and the number in the AND
 of pix1 and pix2 by |1  2|.  The correlation score is then
 (|1  2|)2 / (|1||2|).
 This score is compared with an input threshold, which can
 be modified depending on the weight of the template.
 The modified threshold is
 thresh + (1.0 - thresh)  weight  R
 where
 weight is a fixed input factor between 0.0 and 1.0
 R = |2| / area(2)
 and area(2) is the total number of pixels in 2 (i.e., width x height).
 To understand why a weight factor is useful, consider what happens
 with thick, sans-serif characters that look similar and have a value
 of R near 1.  Different characters can have a high correlation value,
 and the classifier will make incorrect substitutions.  The weight
 factor raises the threshold for these characters.
 Yet another approach to reduce such substitutions is to run the classifier
 in a non-greedy way, matching to the template with the highest
 score, not the first template with a score satisfying the matching
 constraint.  However, this is not particularly effective.
 The implementation here gives the same result as in
 pixCorrelationScoreSimple(), where a temporary Pix is made to hold
 the AND and implementation uses rasterop
 pixt = pixCreateTemplate(pix1);
 pixRasterop(pixt, idelx, idely, wt, ht, PIX_SRC, pix2, 0, 0);
 pixRasterop(pixt, 0, 0, wi, hi, PIX_SRC  PIX_DST, pix1, 0, 0);
 pixCountPixels(pixt, count, tab);
 pixDestroy(pixt);
 However, here it is done in a streaming fashion, counting as it goes,
 and touching memory exactly once, giving a 3-4x speedup over the
 simple implementation.  This very fast correlation matcher was
 contributed by William Rucklidge.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">test pix, 1 bpp</param>
	<param name="pix2">exemplar pix, 1 bpp</param>
	<param name="area1">number of on pixels in pix1</param>
	<param name="area2">number of on pixels in pix2</param>
	<param name="delx">x comp of centroid difference</param>
	<param name="dely">y comp of centroid difference</param>
	<param name="maxdiffw">max width difference of pix1 and pix2</param>
	<param name="maxdiffh">max height difference of pix1 and pix2</param>
	<param name="tab">sum tab for byte</param>
	<param name="pscore">correlation score</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCorrelationScoreThresholded(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Single)">
	<summary>
 Notes
 We check first that the two pix are roughly the same size.
 Only if they meet that criterion do we compare the bitmaps.
 The centroid difference is used to align the two images to the
 nearest integer for the correlation.
 The correlation score is the ratio of the square of the number of
 pixels in the AND of the two bitmaps to the product of the number
 of ON pixels in each.  Denote the number of ON pixels in pix1
 by |1|, the number in pix2 by |2|, and the number in the AND
 of pix1 and pix2 by |1  2|.  The correlation score is then
 (|1  2|)2 / (|1||2|).
 This score is compared with an input threshold, which can
 be modified depending on the weight of the template.
 The modified threshold is
 thresh + (1.0 - thresh)  weight  R
 where
 weight is a fixed input factor between 0.0 and 1.0
 R = |2| / area(2)
 and area(2) is the total number of pixels in 2 (i.e., width x height).
 To understand why a weight factor is useful, consider what happens
 with thick, sans-serif characters that look similar and have a value
 of R near 1.  Different characters can have a high correlation value,
 and the classifier will make incorrect substitutions.  The weight
 factor raises the threshold for these characters.
 Yet another approach to reduce such substitutions is to run the classifier
 in a non-greedy way, matching to the template with the highest
 score, not the first template with a score satisfying the matching
 constraint.  However, this is not particularly effective.
 This very fast correlation matcher was contributed by William Rucklidge.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">test pix, 1 bpp</param>
	<param name="pix2">exemplar pix, 1 bpp</param>
	<param name="area1">number of on pixels in pix1</param>
	<param name="area2">number of on pixels in pix2</param>
	<param name="delx">x comp of centroid difference</param>
	<param name="dely">y comp of centroid difference</param>
	<param name="maxdiffw">max width difference of pix1 and pix2</param>
	<param name="maxdiffh">max height difference of pix1 and pix2</param>
	<param name="tab">sum tab for byte</param>
	<param name="downcount">count of 1 pixels below each row of pix1</param>
	<param name="score_threshold"></param>
	<returns>whether the correlation score is GT= score_threshold</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCorrelationScoreSimple(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32[],System.Single[]@)">
	<summary>
 Notes
 (1) This calculates exactly the same value as pixCorrelationScore().
 It is 2-3x slower, but much simpler to understand.
 (2) The returned correlation score is 0.0 if the width or height
 exceed %maxdiffw or %maxdiffh.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">test pix, 1 bpp</param>
	<param name="pix2">exemplar pix, 1 bpp</param>
	<param name="area1">number of on pixels in pix1</param>
	<param name="area2">number of on pixels in pix2</param>
	<param name="delx">x comp of centroid difference</param>
	<param name="dely">y comp of centroid difference</param>
	<param name="maxdiffw">max width difference of pix1 and pix2</param>
	<param name="maxdiffh">max height difference of pix1 and pix2</param>
	<param name="tab">sum tab for byte</param>
	<param name="pscore">correlation score, in range [0.0 ... 1.0]</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCorrelationScoreShifted(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[],System.Single[]@)">
	<summary>
 Notes
 (1) This finds the correlation between two 1 bpp images,
 when pix2 is shifted by (delx, dely) with respect
 to each other.
 (2) This is implemented by starting with a copy of pix1 and
 ANDing its pixels with those of a shifted pix2.
 (3) Get the pixel counts for area1 and area2 using piCountPixels().
 (4) A good estimate for a shift that would maximize the correlation
 is to align the centroids (cx1, cy1; cx2, cy2), giving the
 relative translations etransx and etransy
 etransx = cx1 - cx2
 etransy = cy1 - cy2
 Typically delx is chosen to be near etransx; ditto for dely.
 This function is used in pixBestCorrelation(), where the
 translations delx and dely are varied to find the best alignment.
 (5) We do not check the sizes of pix1 and pix2, because they should
 be comparable.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">1 bpp</param>
	<param name="pix2">1 bpp</param>
	<param name="area1">number of on pixels in pix1</param>
	<param name="area2">number of on pixels in pix2</param>
	<param name="delx">x translation of pix2 relative to pix1</param>
	<param name="dely">y translation of pix2 relative to pix1</param>
	<param name="tab">sum tab for byte</param>
	<param name="pscore">correlation score</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpCreate(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The input pixs is either full resolution or 2x reduced.
 (2) The page number is typically 0-based.  If scanned from a book,
 the even pages are usually on the left.  Disparity arrays
 built for even pages should only be applied to even pages.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pageno">page number</param>
	<returns>dew or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpCreateRef(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This specifies which dewarp struct should be used for
 the given page.  It is placed in dewarpa for pages
 for which no model can be built.
 (2) This page and the reference page have the same parity and
 the reference page is the closest page with a disparity model
 to this page.
 </summary>
	<remarks>
	</remarks>
	<param name="pageno">this page number</param>
	<param name="refpage">page number of dewarp disparity arrays to be used</param>
	<returns>dew or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdew">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp.Natives.dewarpaCreate(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The sampling, minlines and maxdist parameters will be
 applied to all images.
 (2) The sampling factor is used for generating the disparity arrays
 from the input image.  For 2x reduced input, use a sampling
 factor that is half the sampling you want on the full resolution
 images.
 (3) Use %redfactor = 1 for full resolution; 2 for 2x reduction.
 All input images must be at one of these two resolutions.
 (4) %minlines is the minimum number of nearly full-length lines
 required to generate a vertical disparity array.  The default
 number is 15.  Use a smaller number to accept a questionable
 array, but not smaller than 4.
 (5) When a model can't be built for a page, it looks up to %maxdist
 in either direction for a valid model with the same page parity.
 Use -1 for the default value of %maxdist; use 0 to avoid using
 a ref model.
 (6) The ptr array is expanded as necessary to accommodate page images.
 </summary>
	<remarks>
	</remarks>
	<param name="nptrs">number of dewarp page ptrs; typically the number of pages</param>
	<param name="sampling">use 0 for default value; the minimum allowed is 8</param>
	<param name="redfactor">of input images 1 is full resolution; 2 is 2x reduced</param>
	<param name="minlines">minimum number of lines to accept; use 0 for default</param>
	<param name="maxdist">for locating reference disparity; use -1 for default</param>
	<returns>dewa or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaCreateFromPixacomp(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The returned dewa has disparity arrays calculated and
 is ready for serialization or for use in dewarping.
 (2) The sampling, minlines and maxdist parameters are
 applied to all images.  See notes in dewarpaCreate() for details.
 (3) The pixac is full.  Placeholders, if any, are w=h=d=1 images,
 and the real input images are 1 bpp at full resolution.
 They are assumed to be cropped to the actual page regions,
 and may be arbitrarily sparse in the array.
 (4) The output dewarpa is indexed by the page number.
 The offset in the pixac gives the mapping between the
 array index in the pixac and the page number.
 (5) This adds the ref page models.
 (6) This can be used to make models for any desired set of pages.
 The direct models are only made for pages with images in
 the pixacomp; the ref models are made for pages of the
 same parity within %maxdist of the nearest direct model.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac">pixacomp of G4, 1 bpp images; with 1x1x1 placeholders</param>
	<param name="useboth">0 for only vert disparity; 1 for both vert and horiz</param>
	<param name="sampling">use -1 or 0 for default value; otherwise minimum of 5</param>
	<param name="minlines">minimum number of lines to accept; e.g., 10</param>
	<param name="maxdist">for locating reference disparity; use -1 for default</param>
	<returns>dewa or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdewa">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp.Natives.dewarpaDestroyDewarp(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="pageno">of dew to be destroyed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaInsertDewarp(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This inserts the dewarp into the array, which now owns it.
 It also keeps track of the largest page number stored.
 It must be done before the disparity model is built.
 (2) Note that this differs from the usual method of filling out
 arrays in leptonica, where the arrays are compact and
 new elements are typically added to the end.  Here,
 the dewarp can be added anywhere, even beyond the initial
 allocation.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="dew">to be added</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaGetDewarp(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dewa">populated with dewarp structs for pages</param>
	<param name="index">into dewa this is the pageno</param>
	<returns>dew handle; still owned by dewa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaSetCurvatures(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Approximating the line by a quadratic, the coefficient
 of the quadratic term is the curvature, and distance
 units are in pixels (of course).  The curvature is very
 small, so we multiply by 10^6 and express the constraints
 on the model curvatures in micro-units.
 (2) This sets five curvature thresholds and a slope threshold
 the maximum absolute value of the vertical disparity
 line curvatures
 the minimum absolute value of the largest difference in
 vertical disparity line curvatures (Use a value of 0
 to accept all models.)
 the maximum absolute value of the largest difference in
 vertical disparity line curvatures
 the maximum absolute value of the left and right edge
 curvature for the horizontal disparity
 the maximum absolute value of the difference between
 left and right edge curvature for the horizontal disparity
 all in micro-units, for dewarping to take place.
 Use -1 for default values.
 (3) An image with a line curvature less than about 0.00001
 has fairly straight textlines.  This is 10 micro-units.
 (4) For example, if %max_linecurv == 100, this would prevent dewarping
 if any of the lines has a curvature exceeding 100 micro-units.
 A model having maximum line curvature larger than about 150
 micro-units should probably not be used.
 (5) A model having a left or right edge curvature larger than
 about 100 micro-units should probably not be used.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="max_linecurv">-1 for default</param>
	<param name="min_diff_linecurv">-1 for default; 0 to accept all models</param>
	<param name="max_diff_linecurv">-1 for default</param>
	<param name="max_edgecurv">-1 for default</param>
	<param name="max_diff_edgecurv">-1 for default</param>
	<param name="max_edgeslope">-1 for default</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaUseBothArrays(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This sets the useboth field.  If set, this will attempt
 to apply both vertical and horizontal disparity arrays.
 Note that a model with only a vertical disparity array will
 always be valid.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="useboth">0 for false, 1 for true</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaSetCheckColumns(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This sets the 'check_columns" field.  If set, and if
 'useboth' is set, this will count the number of text
 columns.  If the number is larger than 1, this will
 prevent the application of horizontal disparity arrays
 if they exist.  Note that the default value of check_columns
 if 0 (FALSE).
 (2) This field is set to 0 by default.  For horizontal disparity
 correction to take place on a single column of text, you must have
 - a valid horizontal disparity array
 - useboth = 1 (TRUE)
 If there are multiple columns, additionally
 - check_columns = 0 (FALSE)
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="check_columns">0 for false, 1 for true</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaSetMaxDistance(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This sets the maxdist field.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="maxdist">for using ref models</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>dew, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpReadStream(System.IntPtr)">
	<summary>
 Notes
 (1) The dewarp struct is stored in minimized format, with only
 subsampled disparity arrays.
 (2) The sampling and extra horizontal disparity parameters are
 stored here.  During generation of the dewarp struct, they
 are passed in from the dewarpa.  In readback, it is assumed
 that they are (a) the same for each page and (b) the same
 as the values used to create the dewarpa.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>dew, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization of dewarp</param>
	<param name="size">of data in bytes</param>
	<returns>dew  dewarp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="dew"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This should not be written if there is no sampled
 vertical disparity array, which means that no model has
 been built for this page.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="dew"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a dewarp in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized dewarp (not ascii)</param>
	<param name="psize">size of returned data</param>
	<param name="dew"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>dewa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaReadStream(System.IntPtr)">
	<summary>
 Notes
 (1) The serialized dewarp contains a Numa that gives the
 (increasing) page number of the dewarp structs that are
 contained.
 (2) Reference pages are added in after readback.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>dewa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization of dewarpa</param>
	<param name="size">of data in bytes</param>
	<returns>dewa  dewarpa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="dewa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="dewa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a dewarpa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized dewarpa (not ascii)</param>
	<param name="psize">size of returned data</param>
	<param name="dewa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpBuildPageModel(System.IntPtr,System.String)">
	<summary>
 Notes
 (1) This is the basic function that builds the horizontal and
 vertical disparity arrays, which allow determination of the
 src pixel in the input image corresponding to each
 dest pixel in the dewarped image.
 (2) Sets vsuccess = 1 if the vertical disparity array builds.
 Always attempts to build the horizontal disparity array,
 even if it will not be requested (useboth == 0).
 Sets hsuccess = 1 if horizontal disparity builds.
 (3) The method is as follows
 (a) Estimate the points along the centers of all the
 long textlines.  If there are too few lines, no
 disparity models are built.
 (b) From the vertical deviation of the lines, estimate
 the vertical disparity.
 (c) From the ends of the lines, estimate the horizontal
 disparity, assuming that the text is made of lines
 that are close to left and right justified.
 (d) One can also compute an additional contribution to the
 horizontal disparity, inferred from slopes of the top
 and bottom lines.  We do not do this.
 (4) In more detail for the vertical disparity
 (a) Fit a LS quadratic to center locations along each line.
 This smooths the curves.
 (b) Sample each curve at a regular interval, find the y-value
 of the mid-point on each curve, and subtract the sampled
 curve value from this value.  This is the vertical
 disparity at sampled points along each curve.
 (c) Fit a LS quadratic to each set of vertically aligned
 disparity samples.  This smooths the disparity values
 in the vertical direction.  Then resample at the same
 regular interval.  We now have a regular grid of smoothed
 vertical disparity valuels.
 (5) Once the sampled vertical disparity array is found, it can be
 interpolated to get a full resolution vertical disparity map.
 This can be applied directly to the src image pixels
 to dewarp the image in the vertical direction, making
 all textlines horizontal.  Likewise, the horizontal
 disparity array is used to left- and right-align the
 longest textlines.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="debugfile">writing this</param>
	<returns>0 if OK, 1 if unable to build the model or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpFindVertDisparity(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This starts with points along the centers of textlines.
 It does quadratic fitting (and smoothing), first along the
 lines and then in the vertical direction, to generate
 the sampled vertical disparity map.  This can then be
 interpolated to full resolution and used to remove
 the vertical line warping.
 (2) Use %rotflag == 1 if you are dewarping vertical lines, as
 is done in dewarpBuildLineModel().  The usual case is for
 %rotflag == 0.
 (3) Note that this builds a vertical disparity model (VDM), but
 does not check it against constraints for validity.
 Constraint checking is done after building the models,
 and before inserting reference models.
 (4) This sets the vsuccess flag to 1 on success.
 (5) Pix debug output goes to /tmp/dewvert/ for collection into
 a pdf.  Non-pix debug output goes to /tmp.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="ptaa">unsmoothed lines, not vertically ordered</param>
	<param name="rotflag">0 if using dew-GTpixs; 1 if rotated by 90 degrees cw</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpFindHorizDisparity(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This builds a horizontal disparity model (HDM), but
 does not check it against constraints for validity.
 Constraint checking is done at rendering time.
 (2) Horizontal disparity is not required for a successful model;
 only the vertical disparity is required.  This will not be
 called if the function to build the vertical disparity fails.
 (3) This sets the hsuccess flag to 1 on success.
 (4) Internally in ptal1, ptar1, ptal2, ptar2 x and y are reversed,
 so the 'y' value is horizontal distance across the image width.
 (5) Debug output goes to /tmp/lept/dewmod/ for collection into a pdf.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="ptaa">unsmoothed lines, not vertically ordered</param>
	<returns>0 if OK, 1 if horizontal disparity array is not built, or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpGetTextlineCenters(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This in general does not have a point for each value
 of x, because there will be gaps between words.
 It doesn't matter because we will fit a quadratic to the
 points that we do have.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="debugflag">1 for debug output</param>
	<returns>ptaa of center values of textlines</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpRemoveShortLines(System.IntPtr,System.IntPtr,System.Single,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="ptaas">input lines</param>
	<param name="fract">minimum fraction of longest line to keep</param>
	<param name="debugflag"></param>
	<returns>ptaad containing only lines of sufficient length, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpFindHorizSlopeDisparity(System.IntPtr,System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) %fractthresh is a threshold on the fractional difference in stroke
 density between between left and right sides.  Process this
 disparity only if the absolute value of the fractional
 difference equals or exceeds this threshold.
 (2) %parity indicates where the binding is on the left for
 %parity == 0 and on the right for %parity == 1.
 (3) This takes a 1 bpp %pixb where both vertical and horizontal
 disparity have been applied, so the text lines are straight and,
 more importantly, the line end points are vertically aligned.
 It estimates the foreshortening of the characters on the
 binding side, and if significant, computes a one-dimensional
 horizontal disparity function to compensate.
 (4) The first attempt was to use the average width of the
 connected components (c.c.) in vertical slices.  This does not work
 reliably, because the horizontal compression of the text is
 often accompanied by horizontal joining of c.c.
 (5) We use the density of vertical strokes, measured by first using
 a vertical opening, which improves the signal.  The result
 is relatively insensitive to the size of the opening; we use
 a 10-pixel opening.  The relative density is measured by
 finding the number of c.c. in a full height sliding window
 of width 50 pixels, and compute every 25 pixels.  Similar results
 are obtained counting c.c. that either intersect the window
 or are fully contained within it.
 (6) Debug output goes to /tmp/lept/dewmod/ for collection into a pdf.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="pixb">(1 bpp, with vertical and horizontal disparity removed)</param>
	<param name="fractthresh">(threshold fractional difference in density)</param>
	<param name="parity">(0 if even page, 1 if odd page)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpBuildLineModel(System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) This builds the horizontal and vertical disparity arrays
 for an input of ruled lines, typically for calibration.
 In book scanning, you could lay the ruled paper over a page.
 Then for that page and several below it, you can use the
 disparity correction of the line model to dewarp the pages.
 (2) The dew has been initialized with the image of ruled lines.
 These lines must be continuous, but we do a small amount
 of pre-processing here to insure that.
 (3) %opensize is typically about 8.  It must be larger than
 the thickness of the lines to be extracted.  This is the
 default value, which is applied if %opensize LT 3.
 (4) Sets vsuccess = 1 and hsuccess = 1 if the vertical and/or
 horizontal disparity arrays build.
 (5) Similar to dewarpBuildPageModel(), except here the vertical
 and horizontal disparity arrays are both built from ruled lines.
 See notes there.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="opensize">size of opening to remove perpendicular lines</param>
	<param name="debugfile">writing this</param>
	<returns>0 if OK, 1 if unable to build the model or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaModelStatus(System.IntPtr,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This tests if a model has been built, not if it is valid.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="pageno"></param>
	<param name="pvsuccess">1 on success</param>
	<param name="phsuccess">1 on success</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaApplyDisparity(System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.String)">
	<summary>
 Notes
 (1) This applies the disparity arrays to the specified image.
 (2) Specify gray color for pixels brought in from the outside
 0 is black, 255 is white.  Use -1 to select pixels from the
 boundary of the source image.
 (3) If the models and ref models have not been validated, this
 will do so by calling dewarpaInsertRefModels().
 (4) This works with both stripped and full resolution page models.
 If the full res disparity array(s) are missing, they are remade.
 (5) The caller must handle errors that are returned because there
 are no valid models or ref models for the page -- typically
 by using the input pixs.
 (6) If there is no model for %pageno, this will use the model for
 'refpage' and put the result in the dew for %pageno.
 (7) This populates the full resolution disparity arrays if
 necessary.  If x and/or y are positive, they are used,
 in conjunction with pixs, to determine the required
 slope-based extension of the full resolution disparity
 arrays in each direction.  When (x,y) == (0,0), all
 extension is to the right and down.  Nonzero values of (x,y)
 are useful for dewarping when pixs is deliberately undercropped.
 (8) Important when applying disparity to a number of images,
 after calling this function and saving the resulting pixd,
 you should call dewarpMinimize(dew) on the dew for %pageno.
 This will remove pixs and pixd (or their clones) stored in dew,
 as well as the full resolution disparity arrays.  Together,
 these hold approximately 16 bytes for each pixel in pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="pageno">of page model to be used; may be a ref model</param>
	<param name="pixs">image to be modified; can be 1, 8 or 32 bpp</param>
	<param name="grayin">gray value, from 0 to 255, for pixels brought in; use -1 to use pixels on the boundary of pixs</param>
	<param name="x">origin for generation of disparity arrays</param>
	<param name="y">origin for generation of disparity arrays</param>
	<param name="ppixd">disparity corrected image</param>
	<param name="debugfile">writing this</param>
	<returns>0 if OK, 1 on error no models or ref models available</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaApplyDisparityBoxa(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.String)">
	<summary>
 Notes
 (1) This applies the disparity arrays in one of two mapping directions
 to the specified boxa.  It can be used in the backward direction
 to locate a box in the original coordinates that would have
 been dewarped to to the specified image.
 (2) If there is no model for %pageno, this will use the model for
 'refpage' and put the result in the dew for %pageno.
 (3) This works with both stripped and full resolution page models.
 If the full res disparity array(s) are missing, they are remade.
 (4) If an error occurs, a copy of the input boxa is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="pageno">of page model to be used; may be a ref model</param>
	<param name="pixs">initial pix reference; for alignment and debugging</param>
	<param name="boxas">boxa to be mapped</param>
	<param name="mapdir">1 if mapping forward from original to dewarped; 0 if backward</param>
	<param name="x">origin for generation of disparity arrays with respect to the source region</param>
	<param name="y">origin for generation of disparity arrays with respect to the source region</param>
	<param name="pboxad">disparity corrected boxa</param>
	<param name="debugfile">writing this</param>
	<returns>0 if OK, 1 on error no models or ref models available</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpMinimize(System.IntPtr)">
	<summary>
 Notes
 (1) This removes all data that is not needed for serialization.
 It keeps the subsampled disparity array(s), so the full
 resolution arrays can be reconstructed.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpPopulateFullRes(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If the full resolution vertical and horizontal disparity
 arrays do not exist, they are built from the subsampled ones.
 (2) If pixs is not given, the size of the arrays is determined
 by the original image from which the sampled version was
 generated.  Any values of (x,y) are ignored.
 (3) If pixs is given, the full resolution disparity arrays must
 be large enough to accommodate it.
 (a) If the arrays do not exist, the value of (x,y) determines
 the origin of the full resolution arrays without extension,
 relative to pixs.  Thus, (x,y) gives the amount of
 slope extension in (left, top).  The (right, bottom)
 extension is then determined by the size of pixs and
 (x,y); the values should never be LT 0.
 (b) If the arrays exist and pixs is too large, the existing
 full res arrays are destroyed and new ones are made,
 again using (x,y) to determine the extension in the
 four directions.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="pix">, to give size of actual image</param>
	<param name="x">origin for generation of disparity arrays</param>
	<param name="y">origin for generation of disparity arrays</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpSinglePage(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) Dewarps pixs and returns the result in pixd.
 (2) This uses default values for all model parameters.
 (3) If pixs is 1 bpp, the parameters %adaptive and %thresh are ignored.
 (4) If it can't build a model, returns a copy of pixs in pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">with text, any depth</param>
	<param name="thresh">for global thresholding to 1 bpp; ignored otherwise</param>
	<param name="adaptive">1 for adaptive thresholding; 0 for global threshold</param>
	<param name="useboth">1 for horizontal and vertical; 0 for vertical only</param>
	<param name="check_columns">1 to skip horizontal if multiple columns; 0 otherwise; default is to skip</param>
	<param name="ppixd">dewarped result</param>
	<param name="pdewa">dewa with single page; NULL to skip</param>
	<param name="debug">1 for debugging output, 0 otherwise</param>
	<returns>0 if OK, 1 on error list of page numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpSinglePageInit(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This binarizes the input pixs if necessary, returning the
 binarized image.  It also initializes the dewa to default values
 for the model parameters.
 (2) If pixs is 1 bpp, the parameters %adaptive and %thresh are ignored.
 (3) To change the model parameters, call dewarpaSetCurvatures()
 before running dewarpSinglePageRun().  For example
 dewarpSinglePageInit(pixs, 0, 1, 1, 1, pixb, dewa);
 dewarpaSetCurvatures(dewa, 250, -1, -1, 80, 70, 150);
 dewarpSinglePageRun(pixs, pixb, dewa, pixd, 0);
 dewarpaDestroy(dewa);
 pixDestroy(pixb);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">with text, any depth</param>
	<param name="thresh">for global thresholding to 1 bpp; ignored otherwise</param>
	<param name="adaptive">1 for adaptive thresholding; 0 for global threshold</param>
	<param name="useboth">1 for horizontal and vertical; 0 for vertical only</param>
	<param name="check_columns">1 to skip horizontal if multiple columns; 0 otherwise; default is to skip</param>
	<param name="ppixb">1 bpp image</param>
	<param name="pdewa">initialized dewa</param>
	<returns>0 if OK, 1 on error list of page numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpSinglePageRun(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) Dewarps pixs and returns the result in pixd.
 (2) The 1 bpp version %pixb and %dewa are conveniently generated by
 dewarpSinglePageInit().
 (3) Non-default model parameters must be set before calling this.
 (4) If a model cannot be built, this returns a copy of pixs in pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="pixb">1 bpp</param>
	<param name="dewa">initialized</param>
	<param name="ppixd">dewarped result</param>
	<param name="debug">1 for debugging output, 0 otherwise</param>
	<returns>0 if OK, 1 on error list of page numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaListPages(System.IntPtr)">
	<summary>
 Notes
 (1) This generates two numas, stored in the dewarpa, that give
 (a) the page number for each dew that has a page model.
 (b) the page number for each dew that has either a page
 model or a reference model.
 It can be called at any time.
 (2) It is called by the dewarpa serializer before writing.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa">populated with dewarp structs for pages</param>
	<returns>0 if OK, 1 on error list of page numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaSetValidModels(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) A valid model must meet the rendering requirements, which
 include whether or not a vertical disparity model exists
 and conditions on curvatures for vertical and horizontal
 disparity models.
 (2) If %notests == 1, this ignores the curvature constraints
 and assumes that all successfully built models are valid.
 (3) This function does not need to be called by the application.
 It is called by dewarpaInsertRefModels(), which
 will destroy all invalid dewarps.  Consequently, to inspect
 an invalid dewarp model, it must be done before calling
 dewarpaInsertRefModels().
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="notests"></param>
	<param name="debug">1 to output information on invalid page models</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaInsertRefModels(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This destroys all dewarp models that are invalid, and then
 inserts reference models where possible.
 (2) If %notests == 1, this ignores the curvature constraints
 and assumes that all successfully built models are valid.
 (3) If useboth == 0, it uses the closest valid model within the
 distance and parity constraints.  If useboth == 1, it tries
 to use the closest allowed hvalid model; if it doesn't find
 an hvalid model, it uses the closest valid model.
 (4) For all pages without a model, this clears out any existing
 invalid and reference dewarps, finds the nearest valid model
 with the same parity, and inserts an empty dewarp with the
 reference page.
 (5) Then if it is requested to use both vertical and horizontal
 disparity arrays (useboth == 1), it tries to replace any
 hvalid == 0 model or reference with an hvalid == 1 reference.
 (6) The distance constraint is that any reference model must
 be within maxdist.  Note that with the parity constraint,
 no reference models will be used if maxdist LT 2.
 (7) This function must be called, even if reference models will
 not be used.  It should be called after building models on all
 available pages, and after setting the rendering parameters.
 (8) If the dewa has been serialized, this function is called by
 dewarpaRead() when it is read back.  It is also called
 any time the rendering parameters are changed.
 (9) Note if this has been called with useboth == 1, and useboth
 is reset to 0, you should first call dewarpaRestoreModels()
 to bring real models from the cache back to the primary array.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="notests">if 1, ignore curvature constraints on model</param>
	<param name="debug">1 to output information on invalid page models</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaStripRefModels(System.IntPtr)">
	<summary>
 Notes
 (1) This examines each dew in a dewarpa, and removes
 all that don't have their own page model (i.e., all
 that have "references" to nearby pages with valid models).
 These references were generated by dewarpaInsertRefModels(dewa).
 </summary>
	<remarks>
	</remarks>
	<param name="dewa">populated with dewarp structs for pages</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaRestoreModels(System.IntPtr)">
	<summary>
 Notes
 (1) This puts all real models (and only real models) in the
 primary dewarpa array.  First remove all dewarps that are
 only references to other page models.  Then move all models
 that had been cached back into the primary dewarp array.
 (2) After this is done, we still need to recompute and insert
 the reference models before dewa-GTmodelsready is true.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa">populated with dewarp structs for pages</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaInfo(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp"></param>
	<param name="dewa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaModelStats(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) A page without a model has no dew.  It most likely failed to
 generate a vertical model, and has not been assigned a ref
 model from a neighboring page with a valid vertical model.
 (2) A page has vsuccess == 1 if there is at least a model of the
 vertical disparity.  The model may be invalid, in which case
 dewarpaInsertRefModels() will stash it in the cache and
 attempt to replace it by a valid ref model.
 (3) A vvvalid model is a vertical disparity model whose parameters
 satisfy the constraints given in dewarpaSetValidModels().
 (4) A page has hsuccess == 1 if both the vertical and horizontal
 disparity arrays have been constructed.
 (5) An  hvalid model has vertical and horizontal disparity
 models whose parameters satisfy the constraints given
 in dewarpaSetValidModels().
 (6) A page has a ref model if it failed to generate a valid
 model but was assigned a vvalid or hvalid model on another
 page (within maxdist) by dewarpaInsertRefModel().
 (7) This calls dewarpaTestForValidModel(); it ignores the vvalid
 and hvalid fields.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="pnnone">number without any model</param>
	<param name="pnvsuccess">number with a vert model</param>
	<param name="pnvvalid">number with a valid vert model</param>
	<param name="pnhsuccess">number with both models</param>
	<param name="pnhvalid">number with both models valid</param>
	<param name="pnref">number with a reference model</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpaShowArrays(System.IntPtr,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Generates a pdf of contour plots of the disparity arrays.
 (2) This only shows actual models; not ref models
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="scalefact">on contour images; typ. 0.5</param>
	<param name="first">first page model to render</param>
	<param name="last">last page model to render; use 0 to go to end</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpDebug(System.IntPtr,System.String,System.Int32)">
	<summary>
 Notes
 (1) Prints dewarp fields and generates disparity array contour images.
 The contour images are written to file
 /tmp/[subdirs]/pixv_[index].png
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="subdirs">one or more subdirectories of /tmp; e.g., "dew1"</param>
	<param name="index">to help label output images; e.g., the page number</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dewarpShowResults(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) This generates a pdf of image pairs (before, after) for
 the designated set of input pages.
 (2) If the boxa exists, its elements are aligned with numbers
 in the filenames in %sa.  It is used to crop the input images.
 It is assumed that the dewa was generated from the cropped
 images.  No undercropping is applied before rendering.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="sa">of indexed input images</param>
	<param name="boxa">crop boxes for input images; can be null</param>
	<param name="firstpage"></param>
	<param name="lastpage"></param>
	<param name="pdfout">filename</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of number array to be alloc'd; 0 for default</param>
	<returns>da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaCreateFromIArray(System.Int32[],System.Int32)">
	<summary>
 Notes
 (1) We can't insert this int array into the l_dna, because a l_dna
 takes a double array.  So this just copies the data from the
 input array into the l_dna.  The input array continues to be
 owned by the caller.
 </summary>
	<remarks>
	</remarks>
	<param name="iarray">integer</param>
	<param name="size">of the array</param>
	<returns>da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaCreateFromDArray(System.Double[],System.Int32,System.Int32)">
	<summary>
 Notes
 (1) With L_INSERT, ownership of the input array is transferred
 to the returned l_dna, and all %size elements are considered
 to be valid.
 </summary>
	<remarks>
	</remarks>
	<param name="darray">float</param>
	<param name="size">of the array</param>
	<param name="copyflag">L_INSERT or L_COPY</param>
	<returns>da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaMakeSequence(System.Double,System.Double,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="startval"></param>
	<param name="increment"></param>
	<param name="size">of sequence</param>
	<returns>l_dna of sequence of evenly spaced values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the l_dna.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pda">to be nulled if it exists</param>
</member><member name="M:LeptonicaSharp.Natives.l_dnaCopy(System.IntPtr)">
	<summary>
 Notes
 (1) This removes unused ptrs above da-GTn.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>copy of da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaClone(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>ptr to same da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaEmpty(System.IntPtr)">
	<summary>
 Notes
 (1) This does not change the allocation of the array.
 It just clears the number of stored numbers, so that
 the array appears to be empty.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaAddNumber(System.IntPtr,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="val">float or int to be added; stored as a float</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaInsertNumber(System.IntPtr,System.Int32,System.Double)">
	<summary>
 Notes
 (1) This shifts da[i] --GT da[i + 1] for all i GT= index,
 and then inserts val as da[index].
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">location in da to insert new value</param>
	<param name="val">float64 or integer to be added</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaRemoveNumber(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This shifts da[i] --GT da[i - 1] for all i GT index.
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">element to be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaReplaceNumber(System.IntPtr,System.Int32,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">element to be replaced</param>
	<param name="val">new value to replace old one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>count, or 0 if no numbers or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaSetCount(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If newcount LT= da-GTnalloc, this resets da-GTn.
 Using newcount = 0 is equivalent to l_dnaEmpty().
 (2) If newcount GT da-GTnalloc, this causes a realloc
 to a size da-GTnalloc = newcount.
 (3) All the previously unused values in da are set to 0.0.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="newcount"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaGetDValue(System.IntPtr,System.Int32,System.Double[]@)">
	<summary>
 Notes
 (1) Caller may need to check the function return value to
 decide if a 0.0 in the returned ival is valid.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">into l_dna</param>
	<param name="pval">double value; 0.0 on error</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaGetIValue(System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Caller may need to check the function return value to
 decide if a 0 in the returned ival is valid.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">into l_dna</param>
	<param name="pival">integer value; 0 on error</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaSetValue(System.IntPtr,System.Int32,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">to element to be set</param>
	<param name="val">to set element</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaShiftValue(System.IntPtr,System.Int32,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">to element to change relative to the current value</param>
	<param name="diff">increment if diff GT 0 or decrement if diff LT 0</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaGetIArray(System.IntPtr)">
	<summary>
 Notes
 (1) A copy of the array is made, because we need to
 generate an integer array from the bare double array.
 The caller is responsible for freeing the array.
 (2) The array size is determined by the number of stored numbers,
 not by the size of the allocated array in the l_dna.
 (3) This function is provided to simplify calculations
 using the bare internal array, rather than continually
 calling accessors on the l_dna.  It is typically used
 on an array of size 256.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>a copy of the bare internal array, integerized by rounding, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaGetDArray(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If copyflag == L_COPY, it makes a copy which the caller
 is responsible for freeing.  Otherwise, it operates
 directly on the bare array of the l_dna.
 (2) Very important for L_NOCOPY, any writes to the array
 will be in the l_dna.  Do not write beyond the size of
 the count field, because it will not be accessible
 from the l_dna!  If necessary, be sure to set the count
 field to a larger number (such as the alloc size)
 BEFORE calling this function.  Creating with l_dnaMakeConstant()
 is another way to insure full initialization.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="copyflag">L_NOCOPY or L_COPY</param>
	<returns>either the bare internal array or a copy of it, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaGetRefcount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>refcount, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaChangeRefcount(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="delta">change to be applied</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaGetParameters(System.IntPtr,System.Double[]@,System.Double[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="pstartx">startx</param>
	<param name="pdelx">delx</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaSetParameters(System.IntPtr,System.Double,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="startx">x value corresponding to da[0]</param>
	<param name="delx">difference in x values for the situation where the elements of da correspond to the evaulation of a function at equal intervals of size %delx</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaCopyParameters(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dad">destination DNuma</param>
	<param name="das">source DNuma</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaReadStream(System.IntPtr)">
	<summary>
 Notes
 (1) fscanf takes %lf to read a double; fprintf takes %f to write it.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="da"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="da"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of l_dna ptr array to be alloc'd 0 for default</param>
	<returns>daa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaCreateFull(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This allocates a dnaa and fills the array with allocated dnas.
 In use, after calling this function, use
 l_dnaaAddNumber(dnaa, index, val);
 to add val to the index-th dna in dnaa.
 </summary>
	<remarks>
	</remarks>
	<param name="nptr">size of dna ptr array to be alloc'd</param>
	<param name="n">size of individual dna arrays to be alloc'd 0 for default</param>
	<returns>daa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaTruncate(System.IntPtr)">
	<summary>
 Notes
 (1) This identifies the largest index containing a dna that
 has any numbers within it, destroys all dna beyond that
 index, and resets the count.
 </summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdaa">to be nulled if it exists</param>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaAddDna(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<param name="da">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<returns>count number of l_dna, or 0 if no l_dna or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaGetDnaCount(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<param name="index">of l_dna in daa</param>
	<returns>count of numbers in the referenced l_dna, or 0 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaGetNumberCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<returns>count total number of numbers in the l_dnaa, or 0 if no numbers or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaGetDna(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<param name="index">to the index-th l_dna</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>l_dna, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaReplaceDna(System.IntPtr,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) Any existing l_dna is destroyed, and the input one
 is inserted in its place.
 (2) If the index is invalid, return 1 (error)
 </summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<param name="index">to the index-th l_dna</param>
	<param name="da">insert and replace any existing one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaGetValue(System.IntPtr,System.Int32,System.Int32,System.Double[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<param name="i">index of l_dna within l_dnaa</param>
	<param name="j">index into l_dna</param>
	<param name="pval">double value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaAddNumber(System.IntPtr,System.Int32,System.Double)">
	<summary>
 Notes
 (1) Adds to an existing l_dna only.
 </summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<param name="index">of l_dna within l_dnaa</param>
	<param name="val">number to be added; stored as a double</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>daa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>daa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="daa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="daa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaJoin(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (2) iend LT 0 means 'read to the end'
 (3) if das == NULL, this is a no-op
 </summary>
	<remarks>
	</remarks>
	<param name="dad">dest dna; add to this one</param>
	<param name="das">source dna; add from this one</param>
	<param name="istart">starting index in das</param>
	<param name="iend">ending index in das; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaaFlattenToDna(System.IntPtr)">
	<summary>
 Notes
 (1) This 'flattens' the dnaa to a dna, by joining successively
 each dna in the dnaa.
 (2) It leaves the input dnaa unchanged.
 </summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<returns>dad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaConvertToNuma(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaConvertToDna(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaUnionByAset(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) See sarrayUnionByAset() for the approach.
 (2) Here, the key in building the sorted tree is the number itself.
 (3) Operations using an underlying tree are O(nlogn), which is
 typically less efficient than hashing, which is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="da1"></param>
	<param name="da2"></param>
	<returns>dad with the union of the set of numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaRemoveDupsByAset(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="das"></param>
	<returns>dad with duplicates removed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaIntersectionByAset(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) See sarrayIntersection() for the approach.
 (2) Here, the key in building the sorted tree is the number itself.
 (3) Operations using an underlying tree are O(nlogn), which is
 typically less efficient than hashing, which is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="da1"></param>
	<param name="da2"></param>
	<returns>dad with the intersection of the two arrays, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_asetCreateFromDna(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da">source dna</param>
	<returns>set using the doubles in %da as keys</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaDiffAdjValues(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="das">input l_dna</param>
	<returns>dad of difference values val[i+1] - val[i], or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaHashCreate(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Actual dna are created only as required by l_dnaHashAdd()
 </summary>
	<remarks>
	</remarks>
	<param name="nbuckets">the number of buckets in the hash table, which should be prime.</param>
	<param name="initsize">initial size of each allocated dna; 0 for default</param>
	<returns>ptr to new dnahash, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaHashDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdahash">to be nulled, if it exists</param>
</member><member name="M:LeptonicaSharp.Natives.l_dnaHashGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dahash"></param>
	<returns>nbuckets allocated, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaHashGetTotalCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dahash"></param>
	<returns>n number of numbers in all dna, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaHashGetDna(System.IntPtr,System.UInt64,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dahash"></param>
	<param name="key">key to be hashed into a bucket number</param>
	<param name="copyflag">L_NOCOPY, L_COPY, L_CLONE</param>
	<returns>ptr to dna</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaHashAdd(System.IntPtr,System.UInt64,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dahash"></param>
	<param name="key">key to be hashed into a bucket number</param>
	<param name="value">float value to be appended to the specific dna</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaHashCreateFromDna(System.IntPtr)">
	<summary>
 Notes
 (1) The values stored in the %dahash are indices into %da;
 %dahash has no use without %da.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>dahash if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaRemoveDupsByHash(System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) Generates a dna with unique values.
 (2) The dnahash is built up with dad to assure uniqueness.
 It can be used to find if an element is in the set
 l_dnaFindValByHash(dad, dahash, val, index)
 </summary>
	<remarks>
	</remarks>
	<param name="das"></param>
	<param name="pdad">hash set</param>
	<param name="pdahash">dnahash used for lookup</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaMakeHistoByHash(System.IntPtr,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) Generates and returns a dna of occurrences (histogram),
 an aligned dna of values, and an associated hashmap.
 The hashmap takes %dav and a value, and points into the
 histogram in %dac.
 (2) The dna of values, %dav, is aligned with the histogram %dac,
 and is needed for fast lookup.  It is a hash set, because
 the values are unique.
 (3) Lookup is simple
 l_dnaFindValByHash(dav, dahash, val, index);
 if (index GT= 0)
 l_dnaGetIValue(dac, index, icount);
 else
 icount = 0;
 </summary>
	<remarks>
	</remarks>
	<param name="das"></param>
	<param name="pdahash">hash map val --GT index</param>
	<param name="pdav">array of values index --GT val</param>
	<param name="pdac">histo array of counts index --GT count</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaIntersectionByHash(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This uses the same method for building the intersection set
 as ptaIntersectionByHash() and sarrayIntersectionByHash().
 </summary>
	<remarks>
	</remarks>
	<param name="da1"></param>
	<param name="da2"></param>
	<returns>dad intersection of the number arrays, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaFindValByHash(System.IntPtr,System.IntPtr,System.Double,System.Int32@)">
	<summary>
 Notes
 (1) Algo hash %val into a key; hash the key to get the dna
 in %dahash (that holds indices into %da); traverse
 the dna of indices looking for %val in %da.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="dahash">containing indices into %da</param>
	<param name="val">searching for this number in %da</param>
	<param name="pindex">index into da if found; -1 otherwise</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMorphDwa_2(System.IntPtr,System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) This simply adds a border, calls the appropriate
 pixFMorphopGen_(), and removes the border.
 See the notes for that function.
 (2) The size of the border depends on the operation
 and the boundary conditions.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">usual 3 choices null, == pixs, != pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="operation">L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, L_MORPH_CLOSE</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFMorphopGen_2(System.IntPtr,System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) This is a dwa operation, and the Sels must be limited in
 size to not more than 31 pixels about the origin.
 (2) A border of appropriate size (32 pixels, or 64 pixels
 for safe closing with asymmetric b.c.) must be added before
 this function is called.
 (3) This handles all required setting of the border pixels
 before erosion and dilation.
 (4) The closing operation is safe; no pixels can be removed
 near the boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">usual 3 choices null, == pixs, != pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="operation">L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, L_MORPH_CLOSE</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.fmorphopgen_low_2(System.Object,System.Int32,System.Int32,System.Int32,System.Object,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixSobelEdgeFilter(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Invert pixd to see larger gradients as darker (grayscale).
 (2) To generate a binary image of the edges, threshold
 the result using pixThresholdToBinary().  If the high
 edge values are to be fg (1), invert after running
 pixThresholdToBinary().
 (3) Label the pixels as follows
 1 4 7
 2 5 8
 3 6 9
 Read the data incrementally across the image and unroll
 the loop.
 (4) This runs at about 45 Mpix/sec on a 3 GHz processor.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="orientflag">L_HORIZONTAL_EDGES, L_VERTICAL_EDGES, L_ALL_EDGES</param>
	<returns>pixd 8 bpp, edges are brighter, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixTwoSidedEdgeFilter(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) For detecting vertical edges, this considers the
 difference of the central pixel from those on the left
 and right.  For situations where the gradient is the same
 sign on both sides, this computes and stores the minimum
 (absolute value of the) difference.  The reason for
 checking the sign is that we are looking for pixels within
 a transition.  By contrast, for single pixel noise, the pixel
 value is either larger than or smaller than its neighbors,
 so the gradient would change direction on each side.  Horizontal
 edges are handled similarly, looking for vertical gradients.
 (2) To generate a binary image of the edges, threshold
 the result using pixThresholdToBinary().  If the high
 edge values are to be fg (1), invert after running
 pixThresholdToBinary().
 (3) This runs at about 60 Mpix/sec on a 3 GHz processor.
 It is about 30% faster than Sobel, and the results are
 similar.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="orientflag">L_HORIZONTAL_EDGES, L_VERTICAL_EDGES</param>
	<returns>pixd 8 bpp, edges are brighter, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMeasureEdgeSmoothness(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@,System.String)">
	<summary>
 Notes
 (1) This computes three measures of smoothness of the edge of a
 connected component
 jumps/length (jpl) the number of jumps of size GT= %minjump,
 normalized to the length of the side
 jump sum/length (jspl) the sum of all jump lengths of
 size GT= %minjump, normalized to the length of the side
 reversals/length (rpl) the number of peak LT--GT valley
 reversals, using %minreverse as a minimum deviation of
 the peak or valley from its preceding extremum,
 normalized to the length of the side
 (2) The input pix should be a single connected component, but
 this is not required.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="side">L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
	<param name="minjump">minimum jump to be counted; GT= 1</param>
	<param name="minreversal">minimum reversal size for new peak or valley</param>
	<param name="pjpl">jumps/length number of jumps, normalized to length of component side</param>
	<param name="pjspl">jumpsum/length sum of all sufficiently large jumps, normalized to length of component side</param>
	<param name="prpl">reversals/length number of peak-to-valley or valley-to-peak reversals, normalized to length of component side</param>
	<param name="debugfile">displays constructed edge; use NULL for no output</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetEdgeProfile(System.IntPtr,System.Int32,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="side">L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
	<param name="debugfile">displays constructed edge; use NULL for no output</param>
	<returns>na of fg edge pixel locations, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetLastOffPixelInRun(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetLastOnPixelInRun(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.encodeBase64(System.Byte[],System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The input character data is unrestricted binary.
 The output encoded data consists of the 64 characters
 in the base64 set, plus newlines and the pad character '='.
 </summary>
	<remarks>
	</remarks>
	<param name="inarray">input binary data</param>
	<param name="insize">number of bytes in input array</param>
	<param name="poutsize">number of bytes in output char array</param>
	<returns>chara with MAX_BASE64_LINE characters + \n in each line</returns>
</member><member name="M:LeptonicaSharp.Natives.decodeBase64(System.String,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The input character data should have only 66 different characters
 The 64 character set for base64 encoding, plus the pad
 character '=' and newlines for formatting with fixed line
 lengths.  If there are any other characters, the decoder
 will declare the input data to be invalid and return NULL.
 (2) The decoder ignores newlines and, for a valid input string,
 stops reading input when a pad byte is found.
 </summary>
	<remarks>
	</remarks>
	<param name="inarray">input encoded char data, with 72 chars/line)</param>
	<param name="insize">number of bytes in input array</param>
	<param name="poutsize">number of bytes in output byte array</param>
	<returns>bytea decoded byte data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.encodeAscii85(System.Byte[],System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Ghostscript has a stack break if the last line of
 data only has a 'GT', so we avoid the problem by
 always putting '~GT' on the last line.
 </summary>
	<remarks>
	</remarks>
	<param name="inarray">input data</param>
	<param name="insize">number of bytes in input array</param>
	<param name="poutsize">number of bytes in output char array</param>
	<returns>chara with 64 characters + \n in each line</returns>
</member><member name="M:LeptonicaSharp.Natives.decodeAscii85(System.String,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) We assume the data is properly encoded, so we do not check
 for invalid characters or the final 'GT' character.
 (2) We permit whitespace to be added to the encoding in an
 arbitrary way.
 </summary>
	<remarks>
	</remarks>
	<param name="inarray">ascii85 input data</param>
	<param name="insize">number of bytes in input array</param>
	<param name="poutsize">number of bytes in output l_uint8 array</param>
	<returns>outarray binary</returns>
</member><member name="M:LeptonicaSharp.Natives.reformatPacked64(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Each line in the output array has %leadspace space characters,
 followed optionally by a double-quote, followed by %linechars
 bytes of base64 data, followed optionally by a double-quote,
 followed by a newline.
 (2) This can be used to convert a base64 encoded string to a
 string formatted for inclusion in a C source file.
 </summary>
	<remarks>
	</remarks>
	<param name="inarray">base64 encoded string with newlines</param>
	<param name="insize">number of bytes in input array</param>
	<param name="leadspace">number of spaces in each line before the data</param>
	<param name="linechars">number of bytes of data in each line; multiple of 4</param>
	<param name="addquotes">1 to add quotes to each line of data; 0 to skip</param>
	<param name="poutsize">number of bytes in output char array</param>
	<returns>outarray ascii</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGammaTRC(System.IntPtr,System.IntPtr,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) pixd must either be null or equal to pixs.
 For in-place operation, set pixd == pixs
 pixGammaTRC(pixs, pixs, ...);
 To get a new image, set pixd == null
 pixd = pixGammaTRC(NULL, pixs, ...);
 (2) If pixs is colormapped, the colormap is transformed,
 either in-place or in a copy of pixs.
 (3) We use a gamma mapping between minval and maxval.
 (4) If gamma LT 1.0, the image will appear darker;
 if gamma GT 1.0, the image will appear lighter;
 (5) If gamma = 1.0 and minval = 0 and maxval = 255, no
 enhancement is performed; return a copy unless in-place,
 in which case this is a no-op.
 (6) For color images that are not colormapped, the mapping
 is applied to each component.
 (7) minval and maxval are not restricted to the interval [0, 255].
 If minval LT 0, an input value of 0 is mapped to a
 nonzero output.  This will turn black to gray.
 If maxval GT 255, an input value of 255 is mapped to
 an output value less than 255.  This will turn
 white (e.g., in the background) to gray.
 (8) Increasing minval darkens the image.
 (9) Decreasing maxval bleaches the image.
 (10) Simultaneously increasing minval and decreasing maxval
 will darken the image and make the colors more intense;
 e.g., minval = 50, maxval = 200.
 (11) See numaGammaTRC() for further examples of use.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null or equal to pixs</param>
	<param name="pixs">8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
	<param name="gamma">gamma correction; must be GT 0.0</param>
	<param name="minval">input value that gives 0 for output; can be LT 0</param>
	<param name="maxval">input value that gives 255 for output; can be GT 255</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGammaTRCMasked(System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Same as pixGammaTRC() except mapping is optionally over
 a subset of pixels described by pixm.
 (2) Masking does not work for colormapped images.
 (3) See pixGammaTRC() for details on how to use the parameters.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null or equal to pixs</param>
	<param name="pixs">8 or 32 bpp; not colormapped</param>
	<param name="pixm">null or 1 bpp</param>
	<param name="gamma">gamma correction; must be GT 0.0</param>
	<param name="minval">input value that gives 0 for output; can be LT 0</param>
	<param name="maxval">input value that gives 255 for output; can be GT 255</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGammaTRCWithAlpha(System.IntPtr,System.IntPtr,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See usage notes in pixGammaTRC().
 (2) This version saves the alpha channel.  It is only valid
 for 32 bpp (no colormap), and is a bit slower.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null or equal to pixs</param>
	<param name="pixs">32 bpp</param>
	<param name="gamma">gamma correction; must be GT 0.0</param>
	<param name="minval">input value that gives 0 for output; can be LT 0</param>
	<param name="maxval">input value that gives 255 for output; can be GT 255</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGammaTRC(System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The map is returned as a numa; values are clipped to [0, 255].
 (2) To force all intensities into a range within fraction delta
 of white, use minval = -256  (1 - delta) / delta
 maxval = 255
 (3) To force all intensities into a range within fraction delta
 of black, use minval = 0
 maxval = 256  (1 - delta) / delta
 </summary>
	<remarks>
	</remarks>
	<param name="gamma">gamma factor; must be GT 0.0</param>
	<param name="minval">input value that gives 0 for output</param>
	<param name="maxval">input value that gives 255 for output</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixContrastTRC(System.IntPtr,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) pixd must either be null or equal to pixs.
 For in-place operation, set pixd == pixs
 pixContrastTRC(pixs, pixs, ...);
 To get a new image, set pixd == null
 pixd = pixContrastTRC(NULL, pixs, ...);
 (2) If pixs is colormapped, the colormap is transformed,
 either in-place or in a copy of pixs.
 (3) Contrast is enhanced by mapping each color component
 using an atan function with maximum slope at 127.
 Pixels below 127 are lowered in intensity and pixels
 above 127 are increased.
 (4) The useful range for the contrast factor is scaled to
 be in (0.0 to 1.0), but larger values can also be used.
 (5) If factor == 0.0, no enhancement is performed; return a copy
 unless in-place, in which case this is a no-op.
 (6) For color images that are not colormapped, the mapping
 is applied to each component.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null or equal to pixs</param>
	<param name="pixs">8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
	<param name="factor">0.0 is no enhancement</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixContrastTRCMasked(System.IntPtr,System.IntPtr,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) Same as pixContrastTRC() except mapping is optionally over
 a subset of pixels described by pixm.
 (2) Masking does not work for colormapped images.
 (3) See pixContrastTRC() for details on how to use the parameters.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null or equal to pixs</param>
	<param name="pixs">8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
	<param name="pixm">null or 1 bpp</param>
	<param name="factor">0.0 is no enhancement</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.numaContrastTRC(System.Single)">
	<summary>
 Notes
 (1) The mapping is monotonic increasing, where 0 is mapped
 to 0 and 255 is mapped to 255.
 (2) As 'factor' is increased from 0.0 (where the mapping is linear),
 the map gets closer to its limit as a step function that
 jumps from 0 to 255 at the center (input value = 127).
 </summary>
	<remarks>
	</remarks>
	<param name="factor">generally between 0.0 [no enhancement] and 1.0, but can be larger than 1.0</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixEqualizeTRC(System.IntPtr,System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) pixd must either be null or equal to pixs.
 For in-place operation, set pixd == pixs
 pixEqualizeTRC(pixs, pixs, ...);
 To get a new image, set pixd == null
 pixd = pixEqualizeTRC(NULL, pixs, ...);
 (2) In histogram equalization, a tone reproduction curve
 mapping is used to make the number of pixels at each
 intensity equal.
 (3) If fract == 0.0, no equalization is performed; return a copy
 unless in-place, in which case this is a no-op.
 If fract == 1.0, equalization is complete.
 (4) Set the subsampling factor GT 1 to reduce the amount of computation.
 (5) If pixs is colormapped, the colormap is removed and
 converted to rgb or grayscale.
 (6) If pixs has color, equalization is done in each channel
 separately.
 (7) Note that even if there is a colormap, we can get an
 in-place operation because the intermediate image pixt
 is copied back to pixs (which for in-place is the same
 as pixd).
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null or equal to pixs</param>
	<param name="pixs">8 bpp gray, 32 bpp rgb, or colormapped</param>
	<param name="fract">fraction of equalization movement of pixel values</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaEqualizeTRC(System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) If fract == 0.0, no equalization will be performed.
 If fract == 1.0, equalization is complete.
 (2) Set the subsampling factor GT 1 to reduce the amount of computation.
 (3) The map is returned as a numa with 256 values, specifying
 the equalized value (array value) for every input value
 (the array index).
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp, no colormap</param>
	<param name="fract">fraction of equalization movement of pixel values</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>nad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixTRCMap(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This operation is in-place on pixs.
 (2) For 32 bpp, this applies the same map to each of the r,g,b
 components.
 (3) The mapping array is of size 256, and it maps the input
 index into values in the range [0, 255].
 (4) If defined, the optional 1 bpp mask pixm has its origin
 aligned with pixs, and the map function is applied only
 to pixels in pixs under the fg of pixm.
 (5) For 32 bpp, this does not save the alpha channel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 grayscale or 32 bpp rgb; not colormapped</param>
	<param name="pixm">1 bpp mask</param>
	<param name="na">mapping array</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixUnsharpMasking(System.IntPtr,System.Int32,System.Single)">
	<summary>
 Notes
 (1) We use symmetric smoothing filters of odd dimension,
 typically use sizes of 3, 5, 7, etc.  The %halfwidth parameter
 for these is (size - 1)/2; i.e., 1, 2, 3, etc.
 (2) The fract parameter is typically taken in the
 range  0.2 LT fract LT 0.7
 (3) Returns a clone if no sharpening is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths except 1 bpp; with or without colormaps</param>
	<param name="halfwidth">"half-width" of smoothing filter</param>
	<param name="fract">fraction of edge added back into image</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixUnsharpMaskingGray(System.IntPtr,System.Int32,System.Single)">
	<summary>
 Notes
 (1) We use symmetric smoothing filters of odd dimension,
 typically use sizes of 3, 5, 7, etc.  The %halfwidth parameter
 for these is (size - 1)/2; i.e., 1, 2, 3, etc.
 (2) The fract parameter is typically taken in the range
 0.2 LT fract LT 0.7
 (3) Returns a clone if no sharpening is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="halfwidth">"half-width" of smoothing filter</param>
	<param name="fract">fraction of edge added back into image</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixUnsharpMaskingFast(System.IntPtr,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) The fast version uses separable 1-D filters directly on
 the input image.  The halfwidth is either 1 (full width = 3)
 or 2 (full width = 5).
 (2) The fract parameter is typically taken in the
 range  0.2 LT fract LT 0.7
 (3) To skip horizontal sharpening, use %fracth = 0.0; ditto for %fractv
 (4) For one dimensional filtering (as an example)
 For %halfwidth = 1, the low-pass filter is
 L 1/3 1/3   1/3
 and the high-pass filter is
 H = I - L   -1/3   2/3   -1/3
 For %halfwidth = 2, the low-pass filter is
 L 1/5 1/5   1/5 1/5 1/5
 and the high-pass filter is
 H = I - L   -1/5  -1/5   4/5  -1/5   -1/5
 The new sharpened pixel value is found by adding some fraction
 of the high-pass filter value (which sums to 0) to the
 initial pixel value
 N = I + fract  H
 (5) For 2D, the sharpening filter is not separable, because the
 vertical filter depends on the horizontal location relative
 to the filter origin, and v.v.   So we either do the full
 2D filter (for %halfwidth == 1) or do the low-pass
 convolution separably and then compose with the original pix.
 (6) Returns a clone if no sharpening is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths except 1 bpp; with or without colormaps</param>
	<param name="halfwidth">"half-width" of smoothing filter; 1 and 2 only</param>
	<param name="fract">fraction of high frequency added to image</param>
	<param name="direction">L_HORIZ, L_VERT, L_BOTH_DIRECTIONS</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixUnsharpMaskingGrayFast(System.IntPtr,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) For usage and explanation of the algorithm, see notes
 in pixUnsharpMaskingFast().
 (2) Returns a clone if no sharpening is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="halfwidth">"half-width" of smoothing filter 1 or 2</param>
	<param name="fract">fraction of high frequency added to image</param>
	<param name="direction">L_HORIZ, L_VERT, L_BOTH_DIRECTIONS</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixUnsharpMaskingGray1D(System.IntPtr,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) For usage and explanation of the algorithm, see notes
 in pixUnsharpMaskingFast().
 (2) Returns a clone if no sharpening is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="halfwidth">"half-width" of smoothing filter 1 or 2</param>
	<param name="fract">fraction of high frequency added to image</param>
	<param name="direction">filtering direction; use L_HORIZ or L_VERT</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixUnsharpMaskingGray2D(System.IntPtr,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This is for %halfwidth == 1, 2.
 (2) The lowpass filter is implemented separably.
 (3) Returns a clone if no sharpening is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="halfwidth">"half-width" of smoothing filter 1 or 2</param>
	<param name="fract">fraction of high frequency added to image</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixModifyHue(System.IntPtr,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) pixd must either be null or equal to pixs.
 For in-place operation, set pixd == pixs
 pixEqualizeTRC(pixs, pixs, ...);
 To get a new image, set pixd == null
 pixd = pixEqualizeTRC(NULL, pixs, ...);
 (1) Use fract GT 0.0 to increase hue value; LT 0.0 to decrease it.
 1.0 (or -1.0) represents a 360 degree rotation; i.e., no change.
 (2) If no modification is requested (fract = -1.0 or 0 or 1.0),
 return a copy unless in-place, in which case this is a no-op.
 (3) See discussion of color-modification methods, in coloring.c.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be null or equal to pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="fract">between -1.0 and 1.0</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixModifySaturation(System.IntPtr,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) If fract GT 0.0, it gives the fraction that the pixel
 saturation is moved from its initial value toward 255.
 If fract LT 0.0, it gives the fraction that the pixel
 saturation is moved from its initial value toward 0.
 The limiting values for fract = -1.0 (1.0) thus set the
 saturation to 0 (255).
 (2) If fract = 0, no modification is requested; return a copy
 unless in-place, in which case this is a no-op.
 (3) See discussion of color-modification methods, in coloring.c.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be null, existing or equal to pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="fract">between -1.0 and 1.0</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMeasureSaturation(System.IntPtr,System.Int32,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="psat">average saturation</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixModifyBrightness(System.IntPtr,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) If fract GT 0.0, it gives the fraction that the v-parameter,
 which is max(r,g,b), is moved from its initial value toward 255.
 If fract LT 0.0, it gives the fraction that the v-parameter
 is moved from its initial value toward 0.
 The limiting values for fract = -1.0 (1.0) thus set the
 v-parameter to 0 (255).
 (2) If fract = 0, no modification is requested; return a copy
 unless in-place, in which case this is a no-op.
 (3) See discussion of color-modification methods, in coloring.c.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be null, existing or equal to pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="fract">between -1.0 and 1.0</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMosaicColorShiftRGB(System.IntPtr,System.Single,System.Single,System.Single,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This generates a mosaic view of the effect of shifting the RGB
 components.  See pixColorShiftRGB() for details on the shifting.
 (2) The offsets (%roff, %goff, %boff) set the color center point,
 and the deviations from this are shown separately for deltas
 in r, g and b.  For each component, we show 2  %nincr + 1
 images.
 (3) Usage color prints differ from the original due to three factors
 illumination, calibration of the camera in acquisition,
 and calibration of the printer.  This function can be used
 to iteratively match a color print to the original.  On each
 iteration, the center offsets are set to the best match so
 far, and the %delta increments are typically reduced.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="roff">center offset of red component</param>
	<param name="goff">center offset of green component</param>
	<param name="boff">center offset of blue component</param>
	<param name="delta">increments from center offsets [0.0 - 0.1]; use 0.0 to get the default (0.04)</param>
	<param name="nincr">number of increments in each (positive and negative) direction; use 0 to get the default (2).</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorShiftRGB(System.IntPtr,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This allows independent fractional shifts of the r,g and b
 components.  A positive shift pushes to saturation (255);
 a negative shift pushes toward 0 (black).
 (2) The effect can be imagined using a color wheel that consists
 (for our purposes) of these 6 colors, separated by 60 degrees
 red, magenta, blue, cyan, green, yellow
 (3) So, for example, a negative shift of the blue component
 (bfract LT 0) could be accompanied by positive shifts
 of red and green to make an image more yellow.
 (4) Examples of limiting cases
 rfract = 1 ==GT r = 255
 rfract = -1 ==GT r = 0
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="rfract">fractional shift in red component</param>
	<param name="gfract">fractional shift in green component</param>
	<param name="bfract">fractional shift in blue component</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDarkenGray(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This darkens gray pixels, by a fraction (sat/%satlimit), where
 the sat, the saturation, is the component difference (max - min).
 The pixel value is unchanged if sat GT= %satlimit.  A typical
 value of %satlimit might be 50; the larger the value, the
 more that pixels with a smaller saturation will be darkened.
 (2) Pixels with max component GT= %thresh are unchanged. This can be
 used to prevent bright pixels with low saturation from being
 darkened.  Setting thresh == 0 is a no-op; setting %thresh == 255
 causes the darkening to be applied to all pixels.
 (3) This function is useful to enhance pixels relative to a
 gray background.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be null or equal to pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="thresh">pixels with max component GT= %thresh are unchanged</param>
	<param name="satlimit">pixels with saturation GT= %satlimit are unchanged</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMultConstantColor(System.IntPtr,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) rfact, gfact and bfact can only have non-negative values.
 They can be greater than 1.0.  All transformed component
 values are clipped to the interval [0, 255].
 (2) For multiplication with a general 3x3 matrix of constants,
 use pixMultMatrixColor().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped or rgb</param>
	<param name="rfact">red multiplicative factor</param>
	<param name="gfact">green multiplicative factor</param>
	<param name="bfact">blue multiplicative factor</param>
	<returns>pixd colormapped or rgb, with colors scaled, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMultMatrixColor(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) The kernel is a data structure used mostly for floating point
 convolution.  Here it is a 3x3 matrix of floats that are used
 to transform the pixel values by matrix multiplication
 nrval = a[0,0]  rval + a[0,1]  gval + a[0,2]  bval
 ngval = a[1,0]  rval + a[1,1]  gval + a[1,2]  bval
 nbval = a[2,0]  rval + a[2,1]  gval + a[2,2]  bval
 (2) The matrix can be generated in several ways.
 See kernel.c for details.  Here are two of them
 (a) kel = kernelCreate(3, 3);
 kernelSetElement(kel, 0, 0, val00);
 kernelSetElement(kel, 0, 1, val01);
 ...
 (b) from a static string; e.g.,
 const char kdata = " 0.6  0.3 -0.2 "
 " 0.1  1.2  0.4 "
 " -0.4 0.2  0.9 ";
 kel = kernelCreateFromString(3, 3, 0, 0, kdata);
 (3) For the special case where the matrix is diagonal, it is easier
 to use pixMultConstantColor().
 (4) Matrix entries can have positive and negative values, and can
 be larger than 1.0.  All transformed component values
 are clipped to [0, 255].
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped or rgb</param>
	<param name="kel">kernel 3x3 matrix of floats</param>
	<returns>pixd colormapped or rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixHalfEdgeByBandpass(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) We use symmetric smoothing filters of odd dimension,
 typically use 3, 5, 7, etc.  The smoothing parameters
 for these are 1, 2, 3, etc.  The filter size is related
 to the smoothing parameter by
 size = 2  smoothing + 1
 (2) Because we take the difference of two lowpass filters,
 this is actually a bandpass filter.
 (3) We allow both filters to be anisotropic.
 (4) Consider either the h or v component of the 2 filters.
 Depending on whether sm1 GT sm2 or sm2 GT sm1, we get
 different halves of the smoothed gradients (or "edges").
 This difference of smoothed signals looks more like
 a second derivative of a transition, which we rectify
 by not allowing the signal to go below zero.  If sm1 LT sm2,
 the sm2 transition is broader, so the difference between
 sm1 and sm2 signals is positive on the upper half of
 the transition.  Likewise, if sm1 GT sm2, the sm1 - sm2
 signal difference is positive on the lower half of
 the transition.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb</param>
	<param name="sm1h">"half-widths" of smoothing filter sm1</param>
	<param name="sm1v">"half-widths" of smoothing filter sm1</param>
	<param name="sm2h">"half-widths" of smoothing filter sm2; require sm2 != sm1</param>
	<param name="sm2v">"half-widths" of smoothing filter sm2; require sm2 != sm1</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fhmtautogen(System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) This function generates all the code for implementing
 dwa morphological operations using all the sels in the sela.
 (2) See fhmtautogen1() and fhmtautogen2() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="fileindex"></param>
	<param name="filename">; can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fhmtautogen1(System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) This function uses hmttemplate1.txt to create a
 top-level file that contains two functions that carry
 out the hit-miss transform for any of the sels in
 the input sela.
 (2) The fileindex parameter is inserted into the output
 filename, as described below.
 (3) If filename == NULL, the output file is fhmtgen.[n].c,
 where [n] is equal to the 'fileindex' parameter.
 (4) If filename != NULL, the output file is [filename].[n].c.
 (5) Each sel must have at least one hit.  A sel with only misses
 generates code that will abort the operation if it is called.
 </summary>
	<remarks>
	</remarks>
	<param name="sela">array</param>
	<param name="fileindex"></param>
	<param name="filename">; can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fhmtautogen2(System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) This function uses hmttemplate2.txt to create a
 low-level file that contains the low-level functions for
 implementing the hit-miss transform for every sel
 in the input sela.
 (2) The fileindex parameter is inserted into the output
 filename, as described below.
 (3) If filename == NULL, the output file is fhmtgenlow.[n].c,
 where [n] is equal to the %fileindex parameter.
 (4) If filename != NULL, the output file is [filename]low.[n].c.
 </summary>
	<remarks>
	</remarks>
	<param name="sela">array</param>
	<param name="fileindex"></param>
	<param name="filename">; can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixHMTDwa_1(System.IntPtr,System.IntPtr,System.String)">
	<summary>
 Notes
 (1) This simply adds a 32 pixel border, calls the appropriate
 pixFHMTGen_(), and removes the border.
 See notes below for that function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">usual 3 choices null, == pixs, != pixs</param>
	<param name="pixs">1 bpp</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFHMTGen_1(System.IntPtr,System.IntPtr,System.String)">
	<summary>
 Notes
 (1) This is a dwa implementation of the hit-miss transform
 on pixs by the sel.
 (2) The sel must be limited in size to not more than 31 pixels
 about the origin.  It must have at least one hit, and it
 can have any number of misses.
 (3) This handles all required setting of the border pixels
 before erosion and dilation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">usual 3 choices null, == pixs, != pixs</param>
	<param name="pixs">1 bpp</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.fhmtgen_low_1(System.Object,System.Int32,System.Int32,System.Int32,System.Object,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixItalicWords(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) You can input the bounding boxes for the words in one of
 two forms as bounding boxes (%boxaw) or as a word mask with
 the word bounding boxes filled (%pixw).  For example,
 to compute %pixw, you can use pixWordMaskByDilation().
 (2) Alternatively, you can set both of these inputs to NULL,
 in which case the word mask is generated here.  This is
 done by dilating and closing the input image to connect
 letters within a word, while leaving the words separated.
 The parameters are chosen under the assumption that the
 input is 10 to 12 pt text, scanned at about 300 ppi.
 (3) sel_ital1 and sel_ital2 detect the right edges that are
 nearly vertical, at approximately the angle of italic
 strokes.  We use the right edge to avoid getting seeds
 from lower-case 'y'.  The typical italic slant has a smaller
 angle with the vertical than the 'W', so in most cases we
 will not trigger on the slanted lines in the 'W'.
 (4) Note that sel_ital2 is shorter than sel_ital1.  It is
 more appropriate for a typical font scanned at 200 ppi.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="boxaw">word bounding boxes; can be NULL</param>
	<param name="pixw">word box mask; can be NULL</param>
	<param name="pboxa">boxa of italic words</param>
	<param name="debugflag">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOrientCorrect(System.IntPtr,System.Single,System.Single,System.Single[]@,System.Single[]@,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) Simple top-level function to detect if Roman text is in
 reading orientation, and to rotate the image accordingly if not.
 (2) Returns a copy if no rotation is needed.
 (3) See notes for pixOrientDetect() and pixOrientDecision().
 Use 0.0 for default values for %minupconf and %minratio
 (4) Optional output of intermediate confidence results and
 the rotation performed on pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text, 150 - 300 ppi</param>
	<param name="minupconf">minimum value for which a decision can be made</param>
	<param name="minratio">minimum conf ratio required for a decision</param>
	<param name="pupconf">; use NULL to skip</param>
	<param name="pleftconf">; use NULL to skip</param>
	<param name="protation">; use NULL to skip</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>pixd  may be rotated by 90, 180 or 270; null on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOrientDetect(System.IntPtr,System.Single[]@,System.Single[]@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See "Measuring document image skew and orientation"
 Dan S. Bloomberg, Gary E. Kopec and Lakshmi Dasari
 IST/SPIE EI'95, Conference 2422 Document Recognition II
 pp 302-316, Feb 6-7, 1995, San Jose, CA
 (2) upconf is the normalized difference between up ascenders
 and down ascenders.  The image is analyzed without rotation
 for being rightside-up or upside-down.  Set upconf to null
 to skip this operation.
 (3) leftconf is the normalized difference between up ascenders
 and down ascenders in the image after it has been
 rotated 90 degrees clockwise.  With that rotation, ascenders
 projecting to the left in the source image will project up
 in the rotated image.  We compute this by rotating 90 degrees
 clockwise and testing for up and down ascenders.  Set
 leftconf to null to skip this operation.
 (4) Note that upconf and leftconf are not linear measures of
 confidence, e.g., in a range between 0 and 100.  They
 measure how far you are out on the tail of a (presumably)
 normal distribution.  For example, a confidence of 10 means
 that it is nearly certain that the difference did not
 happen at random.  However, these values must be interpreted
 cautiously, taking into consideration the estimated prior
 for a particular orientation or mirror flip.   The up-down
 signal is very strong if applied to text with ascenders
 up and down, and relatively weak for text at 90 degrees,
 but even at 90 degrees, the difference can look significant.
 For example, suppose the ascenders are oriented horizontally,
 but the test is done vertically.  Then upconf can
 be LT -MIN_CONF_FOR_UP_DOWN, suggesting the text may be
 upside-down.  However, if instead the test were done
 horizontally, leftconf will be very much larger
 (in absolute value), giving the correct orientation.
 (5) If you compute both upconf and leftconf, and there is
 sufficient signal, the following table determines the
 cw angle necessary to rotate pixs so that the text is
 rightside-up
 0 deg   upconf GTGT 1, abs(upconf) GTGT abs(leftconf)
 90 deg  leftconf GTGT 1,  abs(leftconf) GTGT abs(upconf)
 180 deg upconf LTLT -1,   abs(upconf) GTGT abs(leftconf)
 270 deg leftconf LTLT -1, abs(leftconf) GTGT abs(upconf)
 (6) One should probably not interpret the direction unless
 there are a sufficient number of counts for both orientations,
 in which case neither upconf nor leftconf will be 0.0.
 (7) Uses rasterop implementation of HMT.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text, 150 - 300 ppi</param>
	<param name="pupconf">; may be NULL</param>
	<param name="pleftconf">; may be NULL</param>
	<param name="mincount">min number of up + down; use 0 for default</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makeOrientDecision(System.Single,System.Single,System.Single,System.Single,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) This can be run after pixOrientDetect()
 (2) Both upconf and leftconf must be nonzero; otherwise the
 orientation cannot be determined.
 (3) The abs values of the input confidences are compared to
 minupconf.
 (4) The abs value of the largest of (upconf/leftconf) and
 (leftconf/upconf) is compared with minratio.
 (5) Input 0.0 for the default values for minupconf and minratio.
 (6) The return value of orient is interpreted thus
 L_TEXT_ORIENT_UNKNOWN  not enough evidence to determine
 L_TEXT_ORIENT_UP text rightside-up
 L_TEXT_ORIENT_LEFT  landscape, text up facing left
 L_TEXT_ORIENT_DOWN  text upside-down
 L_TEXT_ORIENT_RIGHT landscape, text up facing right
 </summary>
	<remarks>
	</remarks>
	<param name="upconf">nonzero</param>
	<param name="leftconf">nonzero</param>
	<param name="minupconf">minimum value for which a decision can be made</param>
	<param name="minratio">minimum conf ratio required for a decision</param>
	<param name="porient">text orientation enum {0,1,2,3,4}</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixUpDownDetect(System.IntPtr,System.Single[]@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Special (typical, slightly faster) case, where the pixels
 identified through the HMT (hit-miss transform) are not
 clipped by a truncated word mask pixm.  See pixOrientDetect()
 and pixUpDownDetectGeneral() for details.
 (2) The returned confidence is the normalized difference
 between the number of detected up and down ascenders,
 assuming that the text is either rightside-up or upside-down
 and not rotated at a 90 degree angle.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text, 150 - 300 ppi</param>
	<param name="pconf">confidence that text is rightside-up</param>
	<param name="mincount">min number of up + down; use 0 for default</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixUpDownDetectGeneral(System.IntPtr,System.Single[]@,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixOrientDetect() for other details.
 (2) %conf is the normalized difference between the number of
 detected up and down ascenders, assuming that the text
 is either rightside-up or upside-down and not rotated
 at a 90 degree angle.
 (3) The typical mode of operation is %npixels == 0.
 If %npixels GT 0, this removes HMT matches at the
 beginning and ending of "words."  This is useful for
 pages that may have mostly digits, because if npixels == 0,
 leading "1" and "3" digits can register as having
 ascenders or descenders, and "7" digits can match descenders.
 Consequently, a page image of only digits may register
 as being upside-down.
 (4) We want to count the number of instances found using the HMT.
 An expensive way to do this would be to count the
 number of connected components.  A cheap way is to do a rank
 reduction cascade that reduces each component to a single
 pixel, and results (after two or three 2x reductions)
 in one pixel for each of the original components.
 After the reduction, you have a much smaller pix over
 which to count pixels.  We do only 2 reductions, because
 this function is designed to work for input pix between
 150 and 300 ppi, and an 8x reduction on a 150 ppi image
 is going too far -- components will get merged.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text, 150 - 300 ppi</param>
	<param name="pconf">confidence that text is rightside-up</param>
	<param name="mincount">min number of up + down; use 0 for default</param>
	<param name="npixels">number of pixels removed from each side of word box</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOrientDetectDwa(System.IntPtr,System.Single[]@,System.Single[]@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Same interface as for pixOrientDetect().  See notes
 there for usage.
 (2) Uses auto-gen'd code for the Sels defined at the
 top of this file, with some renaming of functions.
 The auto-gen'd code is in fliphmtgen.c, and can
 be generated by a simple executable; see prog/flipselgen.c.
 (3) This runs about 2.5 times faster than the pixOrientDetect().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text</param>
	<param name="pupconf">; may be NULL</param>
	<param name="pleftconf">; may be NULL</param>
	<param name="mincount">min number of up + down; use 0 for default</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixUpDownDetectDwa(System.IntPtr,System.Single[]@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Faster (DWA) version of pixUpDownDetect().
 (2) This is a special case (but typical and slightly faster) of
 pixUpDownDetectGeneralDwa(), where the pixels identified
 through the HMT (hit-miss transform) are not clipped by
 a truncated word mask pixm.  See pixUpDownDetectGeneral()
 for usage and other details.
 (3) The returned confidence is the normalized difference
 between the number of detected up and down ascenders,
 assuming that the text is either rightside-up or upside-down
 and not rotated at a 90 degree angle.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text, 150 - 300 ppi</param>
	<param name="pconf">confidence that text is rightside-up</param>
	<param name="mincount">min number of up + down; use 0 for default</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixUpDownDetectGeneralDwa(System.IntPtr,System.Single[]@,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See the notes in pixUpDownDetectGeneral() for usage.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text</param>
	<param name="pconf">confidence that text is rightside-up</param>
	<param name="mincount">min number of up + down; use 0 for default</param>
	<param name="npixels">number of pixels removed from each side of word box</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMirrorDetect(System.IntPtr,System.Single[]@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For this test, it is necessary that the text is horizontally
 oriented, with ascenders going up.
 (2) conf is the normalized difference between the number of
 right and left facing characters with ascenders.
 Left-facing are {d}; right-facing are {b, h, k}.
 At least that was the expectation.  In practice, we can
 really just say that it is the normalized difference in
 hits using two specific hit-miss filters, textsel1 and textsel2,
 after the image has been suitably pre-filtered so that
 these filters are effective.  See (4) for what's really happening.
 (3) A large positive conf value indicates normal text, whereas
 a large negative conf value means the page is mirror reversed.
 (4) The implementation is a bit tricky.  The general idea is
 to fill the x-height part of characters, but not the space
 between them, before doing the HMT.  This is done by
 finding pixels added using two different operations -- a
 horizontal close and a vertical dilation -- and adding
 the intersection of these sets to the original.  It turns
 out that the original intuition about the signal was largely
 in error much of the signal for right-facing characters
 comes from the lower part of common x-height characters, like
 the e and c, that remain open after these operations.
 So it's important that the operations to close the x-height
 parts of the characters are purposely weakened sufficiently
 to allow these characters to remain open.  The wonders
 of morphology!
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text</param>
	<param name="pconf">confidence that text is not LR mirror reversed</param>
	<param name="mincount">min number of left + right; use 0 for default</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMirrorDetectDwa(System.IntPtr,System.Single[]@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) We assume the text is horizontally oriented, with
 ascenders going up.
 (2) See notes in pixMirrorDetect().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text</param>
	<param name="pconf">confidence that text is not LR mirror reversed</param>
	<param name="mincount">min number of left + right; use 0 for default</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFlipFHMTGen(System.IntPtr,System.IntPtr,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.fmorphautogen(System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) This function generates all the code for implementing
 dwa morphological operations using all the sels in the sela.
 (2) See fmorphautogen1() and fmorphautogen2() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="fileindex"></param>
	<param name="filename">; can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fmorphautogen1(System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) This function uses morphtemplate1.txt to create a
 top-level file that contains two functions.  These
 functions will carry out dilation, erosion,
 opening or closing for any of the sels in the input sela.
 (2) The fileindex parameter is inserted into the output
 filename, as described below.
 (3) If filename == NULL, the output file is fmorphgen.[n].c,
 where [n] is equal to the %fileindex parameter.
 (4) If filename != NULL, the output file is [%filename].[n].c.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="fileindex"></param>
	<param name="filename">; can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fmorphautogen2(System.IntPtr,System.Int32,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixMorphDwa_1(System.IntPtr,System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) This simply adds a border, calls the appropriate
 pixFMorphopGen_(), and removes the border.
 See the notes for that function.
 (2) The size of the border depends on the operation
 and the boundary conditions.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">usual 3 choices null, == pixs, != pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="operation">L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, L_MORPH_CLOSE</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFMorphopGen_1(System.IntPtr,System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) This is a dwa operation, and the Sels must be limited in
 size to not more than 31 pixels about the origin.
 (2) A border of appropriate size (32 pixels, or 64 pixels
 for safe closing with asymmetric b.c.) must be added before
 this function is called.
 (3) This handles all required setting of the border pixels
 before erosion and dilation.
 (4) The closing operation is safe; no pixels can be removed
 near the boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">usual 3 choices null, == pixs, != pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="operation">L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, L_MORPH_CLOSE</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.fmorphopgen_low_1(System.Object,System.Int32,System.Int32,System.Int32,System.Object,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.fpixCreate(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Makes a FPix of specified size, with the data array
 allocated and initialized to 0.
 (2) The number of pixels must be less than 2^29.
 </summary>
	<remarks>
	</remarks>
	<param name="width"></param>
	<param name="height"></param>
	<returns>fpixd   with data allocated and initialized to 0, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixCreateTemplate(System.IntPtr)">
	<summary>
 Notes
 (1) Makes a FPix of the same size as the input FPix, with the
 data array allocated and initialized to 0.
 (2) Copies the resolution.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixClone(System.IntPtr)">
	<summary>
 Notes
 (1) See pixClone() for definition and usage.
 </summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<returns>same fpix ptr, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixCopy(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) There are three cases
 (a) fpixd == null  (makes a new fpix; refcount = 1)
 (b) fpixd == fpixs  (no-op)
 (c) fpixd != fpixs  (data copy; no change in refcount)
 If the refcount of fpixd GT 1, case (c) will side-effect
 these handles.
 (2) The general pattern of use is
 fpixd = fpixCopy(fpixd, fpixs);
 This will work for all three cases.
 For clarity when the case is known, you can use
 (a) fpixd = fpixCopy(NULL, fpixs);
 (c) fpixCopy(fpixd, fpixs);
 (3) For case (c), we check if fpixs and fpixd are the same size.
 If so, the data is copied directly.
 Otherwise, the data is reallocated to the correct size
 and the copy proceeds.  The refcount of fpixd is unchanged.
 (4) This operation, like all others that may involve a pre-existing
 fpixd, will side-effect any existing clones of fpixd.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">; can be null, or equal to fpixs, or different from fpixs</param>
	<param name="fpixs"></param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixResizeImageData(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) If the data sizes differ, this destroys the existing
 data in fpixd and allocates a new, uninitialized, data array
 of the same size as the data in fpixs.  Otherwise, this
 doesn't do anything.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd"></param>
	<param name="fpixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the fpix.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pfpix">will be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.fpixGetDimensions(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixSetDimensions(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="w"></param>
	<param name="h"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixGetWpl(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<returns>wpl, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixSetWpl(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="wpl"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixGetRefcount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<returns>refcount, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixChangeRefcount(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="delta"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixGetResolution(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="pxres">x and y resolution</param>
	<param name="pyres">x and y resolution</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixSetResolution(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="xres">x and y resolution</param>
	<param name="yres">x and y resolution</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixCopyResolution(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixd"></param>
	<param name="fpixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixGetData(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<returns>ptr FPixdata, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixSetData(System.IntPtr,System.Single[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="data"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixGetPixel(System.IntPtr,System.Int32,System.Int32,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="x">,y pixel coords</param>
	<param name="pval">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixSetPixel(System.IntPtr,System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="x">,y pixel coords</param>
	<param name="val">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">initial number of ptrs</param>
	<returns>fpixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaCopy(System.IntPtr,System.Int32)">
	<summary>
 Notes
 copyflag may be one of
 ~ L_COPY makes a new fpixa and copies each fpix
 ~ L_CLONE gives a new ref-counted handle to the input fpixa
 ~ L_COPY_CLONE makes a new fpixa with clones of all fpix
 </summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="copyflag">L_COPY, L_CLODE or L_COPY_CLONE</param>
	<returns>new fpixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the fpixa.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pfpixa">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.fpixaAddFPix(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="fpix">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<returns>count, or 0 if no pixa</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaChangeRefcount(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="delta"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaGetFPix(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="index">to the index-th fpix</param>
	<param name="accesstype">L_COPY or L_CLONE</param>
	<returns>fpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaGetFPixDimensions(System.IntPtr,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="index">to the index-th box</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaGetData(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="index">into fpixa array</param>
	<returns>data not a copy, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaGetPixel(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="index">into fpixa array</param>
	<param name="x">,y pixel coords</param>
	<param name="pval">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaSetPixel(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="index">into fpixa array</param>
	<param name="x">,y pixel coords</param>
	<param name="val">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixCreate(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Makes a DPix of specified size, with the data array
 allocated and initialized to 0.
 (2) The number of pixels must be less than 2^28.
 </summary>
	<remarks>
	</remarks>
	<param name="width"></param>
	<param name="height"></param>
	<returns>dpix  with data allocated and initialized to 0, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixCreateTemplate(System.IntPtr)">
	<summary>
 Notes
 (1) Makes a DPix of the same size as the input DPix, with the
 data array allocated and initialized to 0.
 (2) Copies the resolution.
 </summary>
	<remarks>
	</remarks>
	<param name="dpixs"></param>
	<returns>dpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixClone(System.IntPtr)">
	<summary>
 Notes
 (1) See pixClone() for definition and usage.
 </summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<returns>same dpix ptr, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixCopy(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) There are three cases
 (a) dpixd == null  (makes a new dpix; refcount = 1)
 (b) dpixd == dpixs  (no-op)
 (c) dpixd != dpixs  (data copy; no change in refcount)
 If the refcount of dpixd GT 1, case (c) will side-effect
 these handles.
 (2) The general pattern of use is
 dpixd = dpixCopy(dpixd, dpixs);
 This will work for all three cases.
 For clarity when the case is known, you can use
 (a) dpixd = dpixCopy(NULL, dpixs);
 (c) dpixCopy(dpixd, dpixs);
 (3) For case (c), we check if dpixs and dpixd are the same size.
 If so, the data is copied directly.
 Otherwise, the data is reallocated to the correct size
 and the copy proceeds.  The refcount of dpixd is unchanged.
 (4) This operation, like all others that may involve a pre-existing
 dpixd, will side-effect any existing clones of dpixd.
 </summary>
	<remarks>
	</remarks>
	<param name="dpixd">; can be null, or equal to dpixs, or different from dpixs</param>
	<param name="dpixs"></param>
	<returns>dpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixResizeImageData(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpixd"></param>
	<param name="dpixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the dpix.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pdpix">will be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.dpixGetDimensions(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixSetDimensions(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="w"></param>
	<param name="h"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixGetWpl(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<returns>wpl, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixSetWpl(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="wpl"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixGetRefcount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<returns>refcount, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixChangeRefcount(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="delta"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixGetResolution(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="pxres">x and y resolution</param>
	<param name="pyres">x and y resolution</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixSetResolution(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="xres">x and y resolution</param>
	<param name="yres">x and y resolution</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixCopyResolution(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpixd"></param>
	<param name="dpixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixGetData(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<returns>ptr DPixdata, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixSetData(System.IntPtr,System.Double[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="data"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixGetPixel(System.IntPtr,System.Int32,System.Int32,System.Double[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="x">,y pixel coords</param>
	<param name="pval">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixSetPixel(System.IntPtr,System.Int32,System.Int32,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="x">,y pixel coords</param>
	<param name="val">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>fpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>fpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">of serialized fpix</param>
	<param name="size">of data in bytes</param>
	<returns>fpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="fpix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="fpix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a fpix in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized fpix</param>
	<param name="psize">size of returned data</param>
	<param name="fpix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixEndianByteSwap(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) On big-endian hardware, this does byte-swapping on each of
 the 4-byte floats in the fpix data.  On little-endians,
 the data is unchanged.  This is used for serialization
 of fpix; the data is serialized in little-endian byte
 order because most hardware is little-endian.
 (2) The operation can be either in-place or, if fpixd == NULL,
 a new fpix is made.  If not in-place, caller must catch
 the returned pointer.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">can be equal to fpixs or NULL</param>
	<param name="fpixs"></param>
	<returns>fpixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>dpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>dpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">of serialized dpix</param>
	<param name="size">of data in bytes</param>
	<returns>dpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="dpix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="dpix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a dpix in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized dpix</param>
	<param name="psize">size of returned data</param>
	<param name="dpix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixEndianByteSwap(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) On big-endian hardware, this does byte-swapping on each of
 the 4-byte words in the dpix data.  On little-endians,
 the data is unchanged.  This is used for serialization
 of dpix; the data is serialized in little-endian byte
 order because most hardware is little-endian.
 (2) The operation can be either in-place or, if dpixd == NULL,
 a new dpix is made.  If not in-place, caller must catch
 the returned pointer.
 </summary>
	<remarks>
	</remarks>
	<param name="dpixd">can be equal to dpixs or NULL</param>
	<param name="dpixs"></param>
	<returns>dpixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixPrintStream(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Subsampled printout of fpix for debugging.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="fpix"></param>
	<param name="factor">subsampled</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertToFPix(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If colormapped, remove to grayscale.
 (2) If 32 bpp and %ncomps == 3, this is RGB; convert to luminance.
 In all other cases the src image is treated as having a single
 component of pixel values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="ncomps">number of components 3 for RGB, 1 otherwise</param>
	<returns>fpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertToDPix(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If colormapped, remove to grayscale.
 (2) If 32 bpp and %ncomps == 3, this is RGB; convert to luminance.
 In all other cases the src image is treated as having a single
 component of pixel values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="ncomps">number of components 3 for RGB, 1 otherwise</param>
	<returns>dpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixConvertToPix(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Use %outdepth = 0 to programmatically determine the
 output depth.  If no values are greater than 255,
 it will set outdepth = 8; otherwise to 16 or 32.
 (2) Because we are converting a float to an unsigned int
 with a specified dynamic range (8, 16 or 32 bits), errors
 can occur.  If errorflag == TRUE, output the number
 of values out of range, both negative and positive.
 (3) If a pixel value is positive and out of range, clip to
 the maximum value represented at the outdepth of 8, 16
 or 32 bits.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="outdepth">0, 8, 16 or 32 bpp</param>
	<param name="negvals">L_CLIP_TO_ZERO, L_TAKE_ABSVAL</param>
	<param name="errorflag">1 to output error stats; 0 otherwise</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixDisplayMaxDynamicRange(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixConvertToDPix(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<returns>dpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixConvertToPix(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Use %outdepth = 0 to programmatically determine the
 output depth.  If no values are greater than 255,
 it will set outdepth = 8; otherwise to 16 or 32.
 (2) Because we are converting a float to an unsigned int
 with a specified dynamic range (8, 16 or 32 bits), errors
 can occur.  If errorflag == TRUE, output the number
 of values out of range, both negative and positive.
 (3) If a pixel value is positive and out of range, clip to
 the maximum value represented at the outdepth of 8, 16
 or 32 bits.
 </summary>
	<remarks>
	</remarks>
	<param name="dpixs"></param>
	<param name="outdepth">0, 8, 16 or 32 bpp</param>
	<param name="negvals">L_CLIP_TO_ZERO, L_TAKE_ABSVAL</param>
	<param name="errorflag">1 to output error stats; 0 otherwise</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixConvertToFPix(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<returns>fpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixGetMin(System.IntPtr,System.Single[]@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="pminval">min value</param>
	<param name="pxminloc">x location of min</param>
	<param name="pyminloc">y location of min</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixGetMax(System.IntPtr,System.Single[]@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="pmaxval">max value</param>
	<param name="pxmaxloc">x location of max</param>
	<param name="pymaxloc">y location of max</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixGetMin(System.IntPtr,System.Double[]@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="pminval">min value</param>
	<param name="pxminloc">x location of min</param>
	<param name="pyminloc">y location of min</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixGetMax(System.IntPtr,System.Double[]@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="pmaxval">max value</param>
	<param name="pxmaxloc">x location of max</param>
	<param name="pymaxloc">y location of max</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixScaleByInteger(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The width wd of fpixd is related to ws of fpixs by
 wd = factor  (ws - 1) + 1   (and ditto for the height)
 We avoid special-casing boundary pixels in the interpolation
 by constructing fpixd by inserting (factor - 1) interpolated
 pixels between each pixel in fpixs.  Then
 wd = ws + (ws - 1)  (factor - 1) (same as above)
 This also has the advantage that if we subsample by %factor,
 throwing out all the interpolated pixels, we regain the
 original low resolution fpix.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs">low resolution, subsampled</param>
	<param name="factor">scaling factor</param>
	<returns>fpixd interpolated result, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixScaleByInteger(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The width wd of dpixd is related to ws of dpixs by
 wd = factor  (ws - 1) + 1   (and ditto for the height)
 We avoid special-casing boundary pixels in the interpolation
 by constructing fpixd by inserting (factor - 1) interpolated
 pixels between each pixel in fpixs.  Then
 wd = ws + (ws - 1)  (factor - 1) (same as above)
 This also has the advantage that if we subsample by %factor,
 throwing out all the interpolated pixels, we regain the
 original low resolution dpix.
 </summary>
	<remarks>
	</remarks>
	<param name="dpixs">low resolution, subsampled</param>
	<param name="factor">scaling factor</param>
	<returns>dpixd interpolated result, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixLinearCombination(System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) Computes pixelwise linear combination a  src1 + b  src2
 (2) Alignment is to UL corner.
 (3) There are 3 cases.  The result can go to a new dest,
 in-place to fpixs1, or to an existing input dest
 fpixd == null   (src1 + src2) --GT new fpixd
 fpixd == fpixs1  (src1 + src2) --GT src1  (in-place)
 fpixd != fpixs1 (src1 + src2) --GT input fpixd
 (4) fpixs2 must be different from both fpixd and fpixs1.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">; this can be null, equal to fpixs1, or different from fpixs1</param>
	<param name="fpixs1">can be == to fpixd</param>
	<param name="fpixs2"></param>
	<param name="a">multiplication factors on fpixs1 and fpixs2, rsp.</param>
	<param name="b">multiplication factors on fpixs1 and fpixs2, rsp.</param>
	<returns>fpixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixAddMultConstant(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) It can be used to multiply each pixel by a constant,
 and also to add a constant to each pixel.  Multiplication
 is done first.
 </summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="addc">use 0.0 to skip the operation</param>
	<param name="multc">use 1.0 to skip the operation</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixLinearCombination(System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) Computes pixelwise linear combination a  src1 + b  src2
 (2) Alignment is to UL corner.
 (3) There are 3 cases.  The result can go to a new dest,
 in-place to dpixs1, or to an existing input dest
 dpixd == null   (src1 + src2) --GT new dpixd
 dpixd == dpixs1  (src1 + src2) --GT src1  (in-place)
 dpixd != dpixs1 (src1 + src2) --GT input dpixd
 (4) dpixs2 must be different from both dpixd and dpixs1.
 </summary>
	<remarks>
	</remarks>
	<param name="dpixd">; this can be null, equal to dpixs1, or different from dpixs1</param>
	<param name="dpixs1">can be == to dpixd</param>
	<param name="dpixs2"></param>
	<param name="a">multiplication factors on dpixs1 and dpixs2, rsp.</param>
	<param name="b">multiplication factors on dpixs1 and dpixs2, rsp.</param>
	<returns>dpixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixAddMultConstant(System.IntPtr,System.Double,System.Double)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) It can be used to multiply each pixel by a constant,
 and also to add a constant to each pixel.  Multiplication
 is done first.
 </summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="addc">use 0.0 to skip the operation</param>
	<param name="multc">use 1.0 to skip the operation</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixSetAllArbitrary(System.IntPtr,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="inval">to set at each pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.dpixSetAllArbitrary(System.IntPtr,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="inval">to set at each pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixAddBorder(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Adds border of '0' 32-bit pixels
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="left">pixels on each side to be added</param>
	<param name="right">pixels on each side to be added</param>
	<param name="top">pixels on each side to be added</param>
	<param name="bot">pixels on each side to be added</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixRemoveBorder(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="left">pixels on each side to be removed</param>
	<param name="right">pixels on each side to be removed</param>
	<param name="top">pixels on each side to be removed</param>
	<param name="bot">pixels on each side to be removed</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixAddMirroredBorder(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixAddMirroredBorder() for situations of usage.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="left">pixels on each side to be added</param>
	<param name="right">pixels on each side to be added</param>
	<param name="top">pixels on each side to be added</param>
	<param name="bot">pixels on each side to be added</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixAddContinuedBorder(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This adds pixels on each side whose values are equal to
 the value on the closest boundary pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="left">pixels on each side to be added</param>
	<param name="right">pixels on each side to be added</param>
	<param name="top">pixels on each side to be added</param>
	<param name="bot">pixels on each side to be added</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixAddSlopeBorder(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This adds pixels on each side whose values have a normal
 derivative equal to the normal derivative at the boundary
 of fpixs.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="left">pixels on each side to be added</param>
	<param name="right">pixels on each side to be added</param>
	<param name="top">pixels on each side to be added</param>
	<param name="bot">pixels on each side to be added</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixRasterop(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is similar in structure to pixRasterop(), except
 it only allows copying from the source into the destination.
 For that reason, no op code is necessary.  Additionally,
 all pixels are 32 bit words (float values), which makes
 the copy very simple.
 (2) Clipping of both src and dest fpix are done automatically.
 (3) This allows in-place copying, without checking to see if
 the result is valid  use for in-place with caution!
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">dest fpix</param>
	<param name="dx">x val of UL corner of dest rectangle</param>
	<param name="dy">y val of UL corner of dest rectangle</param>
	<param name="dw">width of dest rectangle</param>
	<param name="dh">height of dest rectangle</param>
	<param name="fpixs">src fpix</param>
	<param name="sx">x val of UL corner of src rectangle</param>
	<param name="sy">y val of UL corner of src rectangle</param>
	<returns>0 if OK; 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixRotateOrth(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="quads">0-3; number of 90 degree cw rotations</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixRotate180(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This does a 180 rotation of the image about the center,
 which is equivalent to a left-right flip about a vertical
 line through the image center, followed by a top-bottom
 flip about a horizontal line through the image center.
 (2) There are 3 cases for input
 (a) fpixd == null (creates a new fpixd)
 (b) fpixd == fpixs (in-place operation)
 (c) fpixd != fpixs (existing fpixd)
 (3) For clarity, use these three patterns, respectively
 (a) fpixd = fpixRotate180(NULL, fpixs);
 (b) fpixRotate180(fpixs, fpixs);
 (c) fpixRotate180(fpixd, fpixs);
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">; can be null, equal to fpixs, or different from fpixs</param>
	<param name="fpixs"></param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixRotate90(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This does a 90 degree rotation of the image about the center,
 either cw or ccw, returning a new pix.
 (2) The direction must be either 1 (cw) or -1 (ccw).
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="direction">1 = clockwise,  -1 = counter-clockwise</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixFlipLR(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This does a left-right flip of the image, which is
 equivalent to a rotation out of the plane about a
 vertical line through the image center.
 (2) There are 3 cases for input
 (a) fpixd == null (creates a new fpixd)
 (b) fpixd == fpixs (in-place operation)
 (c) fpixd != fpixs (existing fpixd)
 (3) For clarity, use these three patterns, respectively
 (a) fpixd = fpixFlipLR(NULL, fpixs);
 (b) fpixFlipLR(fpixs, fpixs);
 (c) fpixFlipLR(fpixd, fpixs);
 (4) If an existing fpixd is not the same size as fpixs, the
 image data will be reallocated.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">; can be null, equal to fpixs, or different from fpixs</param>
	<param name="fpixs"></param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixFlipTB(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This does a top-bottom flip of the image, which is
 equivalent to a rotation out of the plane about a
 horizontal line through the image center.
 (2) There are 3 cases for input
 (a) fpixd == null (creates a new fpixd)
 (b) fpixd == fpixs (in-place operation)
 (c) fpixd != fpixs (existing fpixd)
 (3) For clarity, use these three patterns, respectively
 (a) fpixd = fpixFlipTB(NULL, fpixs);
 (b) fpixFlipTB(fpixs, fpixs);
 (c) fpixFlipTB(fpixd, fpixs);
 (4) If an existing fpixd is not the same size as fpixs, the
 image data will be reallocated.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">; can be null, equal to fpixs, or different from fpixs</param>
	<param name="fpixs"></param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixAffinePta(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Single)">
	<summary>
 Notes
 (1) If %border GT 0, all four sides are extended by that distance,
 and removed after the transformation is finished.  Pixels
 that would be brought in to the trimmed result from outside
 the extended region are assigned %inval.  The purpose of
 extending the image is to avoid such assignments.
 (2) On the other hand, you may want to give all pixels that
 are brought in from outside fpixs a specific value.  In that
 case, set %border == 0.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs">8 bpp</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="border">size of extension with constant normal derivative</param>
	<param name="inval">value brought in; typ. 0</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixAffine(System.IntPtr,System.Single[],System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixs">8 bpp</param>
	<param name="vc">vector of 8 coefficients for projective transformation</param>
	<param name="inval">value brought in; typ. 0</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixProjectivePta(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Single)">
	<summary>
 Notes
 (1) If %border GT 0, all four sides are extended by that distance,
 and removed after the transformation is finished.  Pixels
 that would be brought in to the trimmed result from outside
 the extended region are assigned %inval.  The purpose of
 extending the image is to avoid such assignments.
 (2) On the other hand, you may want to give all pixels that
 are brought in from outside fpixs a specific value.  In that
 case, set %border == 0.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs">8 bpp</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="border">size of extension with constant normal derivative</param>
	<param name="inval">value brought in; typ. 0</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixProjective(System.IntPtr,System.Single[],System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixs">8 bpp</param>
	<param name="vc">vector of 8 coefficients for projective transformation</param>
	<param name="inval">value brought in; typ. 0</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.linearInterpolatePixelFloat(System.Single[],System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single[]@)">
	<summary>
 Notes
 (1) This is a standard linear interpolation function.  It is
 equivalent to area weighting on each component, and
 avoids "jaggies" when rendering sharp edges.
 </summary>
	<remarks>
	</remarks>
	<param name="datas">ptr to beginning of float image data</param>
	<param name="w">of image</param>
	<param name="h">of image</param>
	<param name="x">floating pt location for evaluation</param>
	<param name="y">floating pt location for evaluation</param>
	<param name="inval">float value brought in from the outside when the input x,y location is outside the image</param>
	<param name="pval">interpolated float value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixThresholdToPix(System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) For all values of fpix that are LT= thresh, sets the pixel
 in pixd to 1.
 </summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="thresh"></param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixComponentFunction(System.IntPtr,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This stores a function of the component values of each
 input pixel in %fpixd.
 (2) The function is a ratio of linear combinations of component values.
 There are two special cases for denominator coefficients
 (a) The denominator is 1.0 input 0 for all denominator coefficients
 (b) Only one component is used in the denominator input 1.0
 for that denominator component and 0.0 for the other two.
 (3) If the denominator is 0, multiply by an arbitrary number that
 is much larger than 1.  Choose 256 "arbitrarily".
 </summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="rnum">coefficients for numerator</param>
	<param name="gnum">coefficients for numerator</param>
	<param name="bnum">coefficients for numerator</param>
	<param name="rdenom">coefficients for denominator</param>
	<param name="gdenom">coefficients for denominator</param>
	<param name="bdenom">coefficients for denominator</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadStreamGif(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadMemGif(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamGif(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMemGif(System.Object,System.Object,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.gplotCreate(System.String,System.Int32,System.String,System.String,System.String)">
	<summary>
 Notes
 (1) This initializes the plot.
 (2) The 'title', 'xlabel' and 'ylabel' strings can have spaces,
 double quotes and backquotes, but not single quotes.
 </summary>
	<remarks>
	</remarks>
	<param name="rootname">root for all output files</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="title">overall title</param>
	<param name="xlabel">x axis label</param>
	<param name="ylabel">y axis label</param>
	<returns>gplot, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gplotDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pgplot">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.gplotAddPlot(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) There are 2 options for (x,y) values
 o  To plot an array vs a linear function of the
 index, set nax = NULL.
 o  To plot one array vs another, use both nax and nay.
 (2) If nax is NULL, the x value corresponding to the i-th
 value of nay is found from the startx and delx fields
 in nay
 x = startx + i  delx
 These are set with numaSetParameters().  Their default
 values are startx = 0.0, delx = 1.0.
 (3) If nax is defined, it must be the same size as nay, and
 must have at least one number.
 (4) The 'plottitle' string can have spaces, double
 quotes and backquotes, but not single quotes.
 </summary>
	<remarks>
	</remarks>
	<param name="gplot"></param>
	<param name="nax">numa set to null for Y_VS_I; required for Y_VS_X</param>
	<param name="nay">numa required for both Y_VS_I and Y_VS_X</param>
	<param name="plotstyle">GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES, GPLOT_LINESPOINTS, GPLOT_DOTS</param>
	<param name="plottitle">title for individual plot</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gplotSetScaling(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) By default, the x and y axis scaling is linear.
 (2) Call this function to set semi-log or log-log scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="gplot"></param>
	<param name="scaling">GPLOT_LINEAR_SCALE, GPLOT_LOG_SCALE_X, GPLOT_LOG_SCALE_Y, GPLOT_LOG_SCALE_X_Y</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gplotMakeOutput(System.IntPtr)">
	<summary>
 Notes
 (1) This uses gplot and the new arrays to add a plot
 to the output, by writing a new data file and appending
 the appropriate plot commands to the command file.
 (2) This is the only function in this file that requires the
 gnuplot executable, to actually generate the plot.
 (3) The command file name for unix is canonical (i.e., directory /tmp)
 but the temp filename paths in the command file must be correct.
 (4) The gnuplot program for windows is wgnuplot.exe.
 </summary>
	<remarks>
	</remarks>
	<param name="gplot"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gplotGenCommandFile(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="gplot"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gplotGenDataFiles(System.IntPtr)">
	<summary>
 Notes
 (1) The pathnames in the gplot command file are actual pathnames,
 which can be in temp directories.  Consequently, they must not be
 rewritten by calling fopenWriteStream(), and we use fopen().
 </summary>
	<remarks>
	</remarks>
	<param name="gplot"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gplotSimple1(System.IntPtr,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) This gives a line plot of a numa, where the array value
 is plotted vs the array index.  The plot is generated
 in the specified output format; the title  is optional.
 (2) When calling these simple plot functions more than once, use
 different %outroot to avoid overwriting the output files.
 </summary>
	<remarks>
	</remarks>
	<param name="na">numa; plot Y_VS_I</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="outroot">root of output files</param>
	<param name="title">, can be NULL</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gplotSimple2(System.IntPtr,System.IntPtr,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) This gives a line plot of two numa, where the array values
 are each plotted vs the array index.  The plot is generated
 in the specified output format; the title  is optional.
 (2) When calling these simple plot functions more than once, use
 different %outroot to avoid overwriting the output files.
 </summary>
	<remarks>
	</remarks>
	<param name="na1">numa; plotted with Y_VS_I</param>
	<param name="na2">ditto</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="outroot">root of output files</param>
	<param name="title"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gplotSimpleN(System.IntPtr,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) This gives a line plot of all numas in a numaa (array of numa),
 where the array values are each plotted vs the array index.
 The plot is generated in the specified output format;
 the title  is optional.
 (2) When calling these simple plot functions more than once, use
 different %outroot to avoid overwriting the output files.
 </summary>
	<remarks>
	</remarks>
	<param name="naa">numaa; we plotted with Y_VS_I for each numa</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="outroot">root of output files</param>
	<param name="title"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gplotSimpleXY1(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) This gives a plot of a %nay vs %nax, generated in
 the specified output format.  The title is optional.
 (2) Use 0 for default plotstyle (lines).
 (3) %nax is optional.  If NULL, %nay is plotted against
 the array index.
 (4) When calling these simple plot functions more than once, use
 different %outroot to avoid overwriting the output files.
 </summary>
	<remarks>
	</remarks>
	<param name="nax"></param>
	<param name="nay"></param>
	<param name="plotstyle">GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES, GPLOT_LINESPOINTS, GPLOT_DOTS</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="outroot">root of output files</param>
	<param name="title">, can be NULL</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gplotSimpleXY2(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) This gives plots of %nay1 and %nay2 against nax, generated
 in the specified output format.  The title is optional.
 (2) Use 0 for default plotstyle (lines).
 (3) %nax is optional.  If NULL, %nay1 and %nay2 are plotted
 against the array index.
 (4) When calling these simple plot functions more than once, use
 different %outroot to avoid overwriting the output files.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">LToptional; can be NULL</param>
	<param name="nay1"></param>
	<param name="nay2"></param>
	<param name="plotstyle">GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES, GPLOT_LINESPOINTS, GPLOT_DOTS</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="outroot">root of output files</param>
	<param name="title"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gplotSimpleXYN(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) This gives plots of each Numa in %naa against nax,
 generated in the specified output format.  The title is optional.
 (2) Use 0 for default plotstyle (lines).
 (3) %nax is optional.  If NULL, each Numa array is plotted against
 the array index.
 (4) When calling these simple plot functions more than once, use
 different %outroot to avoid overwriting the output files.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">; can be NULL</param>
	<param name="naay">numaa of arrays to plot against %nax</param>
	<param name="plotstyle">GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES, GPLOT_LINESPOINTS, GPLOT_DOTS</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="outroot">root of output files</param>
	<param name="title"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gplotRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>gplot, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.gplotWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="gplot"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generatePtaLine(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Uses Bresenham line drawing, which results in an 8-connected line.
 </summary>
	<remarks>
	</remarks>
	<param name="x1">end point 1</param>
	<param name="y1">end point 1</param>
	<param name="x2">end point 2</param>
	<param name="y2">end point 2</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generatePtaWideLine(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="x1">end point 1</param>
	<param name="y1">end point 1</param>
	<param name="x2">end point 2</param>
	<param name="y2">end point 2</param>
	<param name="width"></param>
	<returns>ptaj, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generatePtaBox(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Because the box is constructed so that we don't have any
 overlapping lines, there is no need to remove duplicates.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="width">of line</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generatePtaBoxa(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If the boxa has overlapping boxes, and if blending will
 be used to give a transparent effect, transparency
 artifacts at line intersections can be removed using
 removedups = 1.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="width"></param>
	<param name="removedups">1 to remove, 0 to leave</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generatePtaHashBox(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The orientation takes on one of 4 orientations (horiz, vertical,
 slope +1, slope -1).
 (2) The full outline is also drawn if %outline = 1.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">of line</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generatePtaHashBoxa(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The orientation takes on one of 4 orientations (horiz, vertical,
 slope +1, slope -1).
 (2) The full outline is also drawn if %outline = 1.
 (3) If the boxa has overlapping boxes, and if blending will
 be used to give a transparent effect, transparency
 artifacts at line intersections can be removed using
 removedups = 1.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">of line</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="removedups">1 to remove, 0 to leave</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generatePtaaBoxa(System.IntPtr)">
	<summary>
 Notes
 (1) This generates a pta of the four corners for each box in
 the boxa.
 (2) Each of these pta can be rendered onto a pix with random colors,
 by using pixRenderRandomCmapPtaa() with closeflag = 1.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generatePtaaHashBoxa(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The orientation takes on one of 4 orientations (horiz, vertical,
 slope +1, slope -1).
 (2) The full outline is also drawn if %outline = 1.
 (3) Each of these pta can be rendered onto a pix with random colors,
 by using pixRenderRandomCmapPtaa() with closeflag = 1.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="spacing">spacing between hash lines; must be GT 1</param>
	<param name="width">hash line width</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generatePtaPolyline(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas">vertices of polyline</param>
	<param name="width"></param>
	<param name="closeflag">1 to close the contour; 0 otherwise</param>
	<param name="removedups">1 to remove, 0 to leave</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generatePtaGrid(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="w">of region where grid will be displayed</param>
	<param name="h">of region where grid will be displayed</param>
	<param name="nx">number of rectangles in each direction in grid</param>
	<param name="ny">number of rectangles in each direction in grid</param>
	<param name="width">of rendered lines</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertPtaLineTo4cc(System.IntPtr)">
	<summary>
 Notes
 (1) When a polyline is generated with width = 1, the resulting
 line is not 4-connected in general.  This function adds
 points as necessary to convert the line to 4-cconnected.
 It is useful when rendering 1 bpp on a pix.
 (2) Do not use this for lines generated with width GT 1.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">8-connected line of points</param>
	<returns>ptad 4-connected line, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generatePtaFilledCircle(System.Int32)">
	<summary>
 Notes
 (1) The circle is has diameter = 2  radius + 1.
 (2) It is located with the center of the circle at the
 point (radius, radius).
 (3) Consequently, it typically must be translated if
 it is to represent a set of pixels in an image.
 </summary>
	<remarks>
	</remarks>
	<param name="radius"></param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generatePtaFilledSquare(System.Int32)">
	<summary>
 Notes
 (1) The center of the square can be chosen to be at
 (side / 2, side / 2).  It must be translated by this amount
 when used for replication.
 </summary>
	<remarks>
	</remarks>
	<param name="side"></param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generatePtaLineFromPt(System.Int32,System.Int32,System.Double,System.Double)">
	<summary>
 Notes
 (1) The %length of the line is 1 greater than the distance
 used in locatePtRadially().  Example a distance of 1
 gives rise to a length of 2.
 </summary>
	<remarks>
	</remarks>
	<param name="x">point of origination</param>
	<param name="y">point of origination</param>
	<param name="length">of line, including starting point</param>
	<param name="radang">angle in radians, CW from horizontal</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.locatePtRadially(System.Int32,System.Int32,System.Double,System.Double,System.Double[]@,System.Double[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="xr">reference point</param>
	<param name="yr">reference point</param>
	<param name="dist">distance of point from reference point along line given by the specified angle</param>
	<param name="radang">angle in radians, CW from horizontal</param>
	<param name="px">location of point</param>
	<param name="py">location of point</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderPlotFromNuma(System.IntPtr@,System.IntPtr,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) Simplified interface for plotting row or column aligned data
 on a pix.
 (2) This replaces %pix with a 32 bpp rgb version if it is not
 already 32 bpp.  It then draws the plot on the pix.
 (3) See makePlotPtaFromNumaGen() for more details.
 </summary>
	<remarks>
	</remarks>
	<param name="ppix">any type; replaced if not 32 bpp rgb</param>
	<param name="na">to be plotted</param>
	<param name="plotloc">location of plot L_PLOT_AT_TOP, etc</param>
	<param name="linewidth">width of "line" that is drawn; between 1 and 7</param>
	<param name="max">maximum excursion in pixels from baseline</param>
	<param name="color">plot color 0xrrggbb00</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makePlotPtaFromNuma(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates points from %numa representing y(x) or x(y)
 with respect to a pix.  A horizontal plot y(x) is drawn for
 a function of column position, and a vertical plot is drawn
 for a function x(y) of row position.  The baseline is located
 so that all plot points will fit in the pix.
 (2) See makePlotPtaFromNumaGen() for more details.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="size">pix height for horizontal plot; width for vertical plot</param>
	<param name="plotloc">location of plot L_PLOT_AT_TOP, etc</param>
	<param name="linewidth">width of "line" that is drawn; between 1 and 7</param>
	<param name="max">maximum excursion in pixels from baseline</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderPlotFromNumaGen(System.IntPtr@,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) General interface for plotting row or column aligned data
 on a pix.
 (2) This replaces %pix with a 32 bpp rgb version if it is not
 already 32 bpp.  It then draws the plot on the pix.
 (3) See makePlotPtaFromNumaGen() for other input parameters.
 </summary>
	<remarks>
	</remarks>
	<param name="ppix">any type; replaced if not 32 bpp rgb</param>
	<param name="na">to be plotted</param>
	<param name="orient">L_HORIZONTAL_LINE, L_VERTICAL_LINE</param>
	<param name="linewidth">width of "line" that is drawn; between 1 and 7</param>
	<param name="refpos">reference position y for horizontal and x for vertical</param>
	<param name="max">maximum excursion in pixels from baseline</param>
	<param name="drawref">1 to draw the reference line and the normal to it</param>
	<param name="color">plot color 0xrrggbb00</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makePlotPtaFromNumaGen(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates points from %numa representing y(x) or x(y)
 with respect to a pix.  For y(x), we draw a horizontal line
 at the reference position and a vertical line at the edge; then
 we draw the values of %numa, scaled so that the maximum
 excursion from the reference position is %max pixels.
 (2) The start and delx parameters of %numa are used to refer
 its values to the raster lines (L_VERTICAL_LINE) or columns
 (L_HORIZONTAL_LINE).
 (3) The linewidth is chosen in the interval [1 ... 7].
 (4) %refpos should be chosen so the plot is entirely within the pix
 that it will be painted onto.
 (5) This would typically be used to plot, in place, a function
 computed along pixel rows or columns.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="orient">L_HORIZONTAL_LINE, L_VERTICAL_LINE</param>
	<param name="linewidth">width of "line" that is drawn; between 1 and 7</param>
	<param name="refpos">reference position y for horizontal and x for vertical</param>
	<param name="max">maximum excursion in pixels from baseline</param>
	<param name="drawref">1 to draw the reference line and the normal to it</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderPta(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) L_SET_PIXELS puts all image bits in each pixel to 1
 (black for 1 bpp; white for depth GT 1)
 (2) L_CLEAR_PIXELS puts all image bits in each pixel to 0
 (white for 1 bpp; black for depth GT 1)
 (3) L_FLIP_PIXELS reverses all image bits in each pixel
 (4) This function clips the rendering to the pix.  It performs
 clipping for functions such as pixRenderLine(),
 pixRenderBox() and pixRenderBoxa(), that call pixRenderPta().
 </summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="pta">arbitrary set of points</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderPtaArb(System.IntPtr,System.IntPtr,System.Byte,System.Byte,System.Byte)">
	<summary>
 Notes
 (1) If pix is colormapped, render this color (or the nearest
 color if the cmap is full) on each pixel.
 (2) The rgb components have the standard dynamic range [0 ... 255]
 (3) If pix is not colormapped, do the best job you can using
 the input colors
 ~ d = 1 set the pixels
 ~ d = 2, 4, 8 average the input rgb value
 ~ d = 32 use the input rgb value
 (4) This function clips the rendering to the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, cmapped ok</param>
	<param name="pta">arbitrary set of points</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderPtaBlend(System.IntPtr,System.IntPtr,System.Byte,System.Byte,System.Byte,System.Single)">
	<summary>
 Notes
 (1) This function clips the rendering to the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="pta">arbitrary set of points</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderLine(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="x1"></param>
	<param name="y1"></param>
	<param name="x2"></param>
	<param name="y2"></param>
	<param name="width">thickness of line</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderLineArb(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte,System.Byte,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, cmapped ok</param>
	<param name="x1"></param>
	<param name="y1"></param>
	<param name="x2"></param>
	<param name="y2"></param>
	<param name="width">thickness of line</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderLineBlend(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte,System.Byte,System.Byte,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="x1"></param>
	<param name="y1"></param>
	<param name="x2"></param>
	<param name="y2"></param>
	<param name="width">thickness of line</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderBox(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="box"></param>
	<param name="width">thickness of box lines</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderBoxArb(System.IntPtr,System.IntPtr,System.Int32,System.Byte,System.Byte,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, cmapped ok</param>
	<param name="box"></param>
	<param name="width">thickness of box lines</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderBoxBlend(System.IntPtr,System.IntPtr,System.Int32,System.Byte,System.Byte,System.Byte,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="box"></param>
	<param name="width">thickness of box lines</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract">in [0.0 - 1.0]; complete transparency (no effect if 0.0; no transparency if 1.0)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderBoxa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="boxa"></param>
	<param name="width">thickness of line</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderBoxaArb(System.IntPtr,System.IntPtr,System.Int32,System.Byte,System.Byte,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; colormapped is ok</param>
	<param name="boxa"></param>
	<param name="width">thickness of line</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderBoxaBlend(System.IntPtr,System.IntPtr,System.Int32,System.Byte,System.Byte,System.Byte,System.Single,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="boxa"></param>
	<param name="width">thickness of line</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract">in [0.0 - 1.0]; complete transparency (no effect if 0.0; no transparency if 1.0)</param>
	<param name="removedups">1 to remove; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderHashBox(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="box"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderHashBoxArb(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; cmapped ok</param>
	<param name="box"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderHashBoxBlend(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp</param>
	<param name="box"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract">in [0.0 - 1.0]; complete transparency (no effect if 0.0; no transparency if 1.0)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderHashMaskArb(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place operation that renders hash lines
 through a mask %pixm onto %pix.  The mask origin is
 translated by (%x,%y) relative to the origin of %pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; cmapped ok</param>
	<param name="pixm">1 bpp clipping mask for hash marks</param>
	<param name="x">,y   UL corner of %pixm with respect to %pix</param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderHashBoxa(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="boxa"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderHashBoxaArb(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; cmapped ok</param>
	<param name="boxa"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderHashBoxaBlend(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="boxa"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract">in [0.0 - 1.0]; complete transparency (no effect if 0.0; no transparency if 1.0)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderPolyline(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 This renders a closed contour.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="ptas"></param>
	<param name="width">thickness of line</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<param name="closeflag">1 to close the contour; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderPolylineArb(System.IntPtr,System.IntPtr,System.Int32,System.Byte,System.Byte,System.Byte,System.Int32)">
	<summary>
 Notes
 This renders a closed contour.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; cmapped ok</param>
	<param name="ptas"></param>
	<param name="width">thickness of line</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="closeflag">1 to close the contour; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderPolylineBlend(System.IntPtr,System.IntPtr,System.Int32,System.Byte,System.Byte,System.Byte,System.Single,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="ptas"></param>
	<param name="width">thickness of line</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract">in [0.0 - 1.0]; complete transparency (no effect if 0.0; no transparency if 1.0)</param>
	<param name="closeflag">1 to close the contour; 0 otherwise</param>
	<param name="removedups">1 to remove; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderGridArb(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Byte,System.Byte,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, cmapped ok</param>
	<param name="nx">number of rectangles in each direction</param>
	<param name="ny">number of rectangles in each direction</param>
	<param name="width">thickness of grid lines</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderRandomCmapPtaa(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a debugging routine, that displays a set of
 pixels, selected by the set of Ptas in a Ptaa,
 in a random color in a pix.
 (2) If %polyflag == 1, each Pta is considered to be a polyline,
 and is rendered using %width and %closeflag.  Each polyline
 is rendered in a random color.
 (3) If %polyflag == 0, all points in each Pta are rendered in a
 random color.  The %width and %closeflag parameters are ignored.
 (4) The output pix is 8 bpp and colormapped.  Up to 254
 different, randomly selected colors, can be used.
 (5) The rendered pixels replace the input pixels.  They will
 be clipped silently to the input pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1, 2, 4, 8, 16, 32 bpp</param>
	<param name="ptaa"></param>
	<param name="polyflag">1 to interpret each Pta as a polyline; 0 to simply render the Pta as a set of pixels</param>
	<param name="width">thickness of line; use only for polyline</param>
	<param name="closeflag">1 to close the contour; 0 otherwise; use only for polyline mode</param>
	<returns>pixd cmapped, 8 bpp or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderPolygon(System.IntPtr,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The pix is the minimum size required to contain the origin
 and the polygon.  For example, the max x value of the input
 points is w - 1, where w is the pix width.
 (2) The rendered line is 4-connected, so that an interior or
 exterior 8-c.c. flood fill operation works properly.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">of vertices, none repeated</param>
	<param name="width">of polygon outline</param>
	<param name="pxmin">min x value of input pts</param>
	<param name="pymin">min y value of input pts</param>
	<returns>pix 1 bpp, with outline generated, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFillPolygon(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This fills the interior of the polygon, returning a
 new pix.  It works for both convex and non-convex polygons.
 (2) To generate a filled polygon from a pta
 PIX pixt = pixRenderPolygon(pta, 1, xmin, ymin);
 PIX pixd = pixFillPolygon(pixt, pta, xmin, ymin);
 pixDestroy(pixt);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, with 4-connected polygon outline</param>
	<param name="pta">vertices of the polygon</param>
	<param name="xmin">min values of vertices of polygon</param>
	<param name="ymin">min values of vertices of polygon</param>
	<returns>pixd with outline filled, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRenderContours(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The output can be either 1 bpp, showing just the contour
 lines, or a copy of the input pixs with the contour lines
 superposed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 16 bpp; no colormap</param>
	<param name="startval">value of lowest contour; must be in [0 ... maxval]</param>
	<param name="incr">increment to next contour; must be GT 0</param>
	<param name="outdepth">either 1 or depth of pixs</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixAutoRenderContours(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The increment is set to get approximately %ncontours.
 (2) The proximity to the target value for contour display
 is set to 0.15.
 (3) Negative values are rendered in red; positive values as black.
 </summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="ncontours">GT 1, LT 500, typ. about 50</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixRenderContours(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) Values are displayed when val/incr is within +-proxim
 to an integer.  The default value is 0.15; smaller values
 result in thinner contour lines.
 (2) Negative values are rendered in red; positive values as black.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="incr">increment between contours; must be GT 0.0</param>
	<param name="proxim">required proximity to target value; default 0.15</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGeneratePtaBoundary(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Similar to ptaGetBoundaryPixels(), except here
 we only get pixels in the foreground
 we can have a "line" width greater than 1 pixel.
 (2) Once generated, this can be applied to a random 1 bpp image
 to add a color boundary as follows
 Pta pta = pixGeneratePtaBoundary(pixs, width);
 Pix pix1 = pixConvert1To8Cmap(pixs);
 pixRenderPtaArb(pix1, pta, rval, gval, bval);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="width">of boundary line</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixErodeGray(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDilateGray(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOpenGray(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCloseGray(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixErodeGray3(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
 (2) If hsize = vsize = 1, just returns a copy.
 (3) It would be nice not to add a border, but it is required
 if we want the same results as from the general case.
 We add 4 bytes on the left to speed up the copying, and
 8 bytes at the right and bottom to allow unrolling of
 the computation of 8 pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="hsize">1 or 3</param>
	<param name="vsize">1 or 3</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDilateGray3(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
 (2) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="hsize">1 or 3</param>
	<param name="vsize">1 or 3</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOpenGray3(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
 (2) If hsize = vsize = 1, just returns a copy.
 (3) It would be nice not to add a border, but it is required
 to get the same results as for the general case.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="hsize">1 or 3</param>
	<param name="vsize">1 or 3</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCloseGray3(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
 (2) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="hsize">1 or 3</param>
	<param name="vsize">1 or 3</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDitherToBinary(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>pixd dithered binary, or NULL on error The Floyd-Steinberg error diffusion dithering algorithm binarizes an 8 bpp grayscale image to a threshold of 128. If a pixel has a value above 127, it is binarized to white and the excess below 255 is subtracted from three neighboring pixels in the fractions 3/8 to i, j+1, 3/8 to i+1, j) and 1/4 to (i+1,j+1, truncating to 0 if necessary.  Likewise, if it the pixel has a value below 128, it is binarized to black and the excess above 0 is added to the neighboring pixels, truncating to 255 if necessary. This function differs from straight dithering in that it allows clipping of grayscale to 0 or 255 if the values are sufficiently close, without distribution of the excess. This uses default values to specify the range of lower and upper values near 0 and 255, rsp that are clipped to black and white without propagating the excess. Not propagating the excess has the effect of reducing the snake patterns in parts of the image that are nearly black or white; however, it also prevents the attempt to reproduce gray for those values. The implementation is straightforward.  It uses a pair of line buffers to avoid changing pixs.  It is about the same speed as pixDitherToBinaryLUT(), which uses three LUTs.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDitherToBinarySpec(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See comments above in pixDitherToBinary() for details.
 (2) The input parameters lowerclip and upperclip specify the range
 of lower and upper values (near 0 and 255, rsp) that are
 clipped to black and white without propagating the excess.
 For that reason, lowerclip and upperclip should be small numbers.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="lowerclip">lower clip distance to black; use 0 for default</param>
	<param name="upperclip">upper clip distance to white; use 0 for default</param>
	<returns>pixd dithered binary, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ditherToBinaryLineLow(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lined">ptr to beginning of dest line</param>
	<param name="w">width of image in pixels</param>
	<param name="bufs1">buffer of current source line</param>
	<param name="bufs2">buffer of next source line</param>
	<param name="lowerclip">lower clip distance to black</param>
	<param name="upperclip">upper clip distance to white</param>
	<param name="lastlineflag">0 if not last dest line, 1 if last dest line</param>
</member><member name="M:LeptonicaSharp.Natives.pixThresholdToBinary(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If the source pixel is less than the threshold value,
 the dest will be 1; otherwise, it will be 0.
 (2) For example, for 8 bpp src pix, if %thresh == 256, the dest
 1 bpp pix is all ones (fg), and if %thresh == 0, the dest
 pix is all zeros (bg).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">4 or 8 bpp</param>
	<param name="thresh">threshold value</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.thresholdToBinaryLineLow(System.Object,System.Int32,System.Object,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.pixVarThresholdToBinary(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) If the pixel in pixs is less than the corresponding pixel
 in pixg, the dest will be 1; otherwise it will be 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="pixg">8 bpp; contains threshold values for each pixel</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAdaptThresholdToBinary(System.IntPtr,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) This is a simple convenience function for doing adaptive
 thresholding on a grayscale image with variable background.
 It uses default parameters appropriate for typical text images.
 (2) %pixm is a 1 bpp mask over "image" regions, which are not
 expected to have a white background.  The mask inhibits
 background finding under the fg pixels of the mask.  For
 images with both text and image, the image regions would
 be binarized (or quantized) by a different set of operations.
 (3) As %gamma is increased, the foreground pixels are reduced.
 (4) Under the covers  The default background value for normalization
 is 200, so we choose 170 for 'maxval' in pixGammaTRC.  Likewise,
 the default foreground threshold for normalization is 60,
 so we choose 50 for 'minval' in pixGammaTRC.  Because
 170 was mapped to 255, choosing 200 for the threshold is
 quite safe for avoiding speckle noise from the background.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="pixm">1 bpp image mask; can be null</param>
	<param name="gamma">gamma correction; must be GT 0.0; typically ~1.0</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAdaptThresholdToBinaryGen(System.IntPtr,System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a convenience function for doing adaptive thresholding
 on a grayscale image with variable background.  Also see notes
 in pixAdaptThresholdToBinary().
 (2) Reducing %gamma increases the foreground (text) pixels.
 Use a low value (e.g., 0.5) for images with light text.
 (3) For normal images, see default args in pixAdaptThresholdToBinary().
 For images with very light text, these values are appropriate
 gamma  ~0.5
 blackval  ~70
 whiteval  ~190
 thresh ~200
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="pixm">1 bpp image mask; can be null</param>
	<param name="gamma">gamma correction; must be GT 0.0; typically ~1.0</param>
	<param name="blackval">dark value to set to black (0)</param>
	<param name="whiteval">light value to set to white (255)</param>
	<param name="thresh">final threshold for binarization</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenerateMaskByValue(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) %val is the pixel value that we are selecting.  It can be
 either a gray value or a colormap index.
 (2) If pixs is colormapped, %usecmap determines if the colormap
 index values are used, or if the colormap is removed to gray and
 the gray values are used.  For the latter, it generates
 an approximate grayscale value for each pixel, and then looks
 for gray pixels with the value %val.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp, or colormapped</param>
	<param name="val">of pixels for which we set 1 in dest</param>
	<param name="usecmap">1 to retain cmap values; 0 to convert to gray</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenerateMaskByBand(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Generates a 1 bpp mask pixd, the same size as pixs, where
 the fg pixels in the mask are those either within the specified
 band (for inband == 1) or outside the specified band
 (for inband == 0).
 (2) If pixs is colormapped, %usecmap determines if the colormap
 values are used, or if the colormap is removed to gray and
 the gray values are used.  For the latter, it generates
 an approximate grayscale value for each pixel, and then looks
 for gray pixels with the value %val.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp, or colormapped</param>
	<param name="lower">two pixel values from which a range, either between (inband) or outside of (!inband), determines which pixels in pixs cause us to set a 1 in the dest mask</param>
	<param name="upper">two pixel values from which a range, either between (inband) or outside of (!inband), determines which pixels in pixs cause us to set a 1 in the dest mask</param>
	<param name="inband">1 for finding pixels in [lower, upper]; 0 for finding pixels in [0, lower) union (upper, 255]</param>
	<param name="usecmap">1 to retain cmap values; 0 to convert to gray</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDitherTo2bpp(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="cmapflag">1 to generate a colormap</param>
	<returns>pixd dithered 2 bpp, or NULL on error An analog of the Floyd-Steinberg error diffusion dithering algorithm is used to "dibitize" an 8 bpp grayscale image to 2 bpp, using equally spaced gray values of 0, 85, 170, and 255, which are served by thresholds of 43, 128 and 213. If cmapflag == 1, the colormap values are set to 0, 85, 170 and 255. If a pixel has a value between 0 and 42, it is dibitized to 0, and the excess above 0 is added to the three neighboring pixels, in the fractions 3/8 to i, j+1, 3/8 to i+1, j) and 1/4 to (i+1, j+1, truncating to 255 if necessary.  If a pixel has a value between 43 and 127, it is dibitized to 1, and the excess above 85 is added to the three neighboring pixels as before.  If the value is below 85, the excess is subtracted.  With a value between 128 and 212, it is dibitized to 2, with the excess on either side of 170 distributed as before.  Finally, with a value between 213 and 255, it is dibitized to 3, with the excess below 255 subtracted from the neighbors.  We always truncate to 0 or 255. The details can be seen in the lookup table generation. This function differs from straight dithering in that it allows clipping of grayscale to 0 or 255 if the values are sufficiently close, without distribution of the excess. This uses default values from pix.h to specify the range of lower and upper values near 0 and 255, rsp that are clipped to black and white without propagating the excess. Not propagating the excess has the effect of reducing the snake patterns in parts of the image that are nearly black or white; however, it also prevents any attempt to reproduce gray for those values. The implementation uses 3 lookup tables for simplicity, and a pair of line buffers to avoid modifying pixs.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDitherTo2bppSpec(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See comments above in pixDitherTo2bpp() for details.
 (2) The input parameters lowerclip and upperclip specify the range
 of lower and upper values (near 0 and 255, rsp) that are
 clipped to black and white without propagating the excess.
 For that reason, lowerclip and upperclip should be small numbers.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="lowerclip">lower clip distance to black; use 0 for default</param>
	<param name="upperclip">upper clip distance to white; use 0 for default</param>
	<param name="cmapflag">1 to generate a colormap</param>
	<returns>pixd dithered 2 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixThresholdTo2bpp(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Valid values for nlevels is the set {2, 3, 4}.
 (2) Any colormap on the input pixs is removed to 8 bpp grayscale.
 (3) This function is typically invoked with cmapflag == 1.
 In the situation where no colormap is desired, nlevels is
 ignored and pixs is thresholded to 4 levels.
 (4) The target output colors are equally spaced, with the
 darkest at 0 and the lightest at 255.  The thresholds are
 chosen halfway between adjacent output values.  A table
 is built that specifies the mapping from src to dest.
 (5) If cmapflag == 1, a colormap of size 'nlevels' is made,
 and the pixel values in pixs are replaced by their
 appropriate color indices.  The number of holdouts,
 4 - nlevels, will be between 0 and 2.
 (6) If you don't want the thresholding to be equally spaced,
 either first transform the 8 bpp src using pixGammaTRC().
 or, if cmapflag == 1, after calling this function you can use
 pixcmapResetColor() to change any individual colors.
 (7) If a colormap is generated, it will specify (to display
 programs) exactly how each level is to be represented in RGB
 space.  When representing text, 3 levels is far better than
 2 because of the antialiasing of the single gray level,
 and 4 levels (black, white and 2 gray levels) is getting
 close to the perceptual quality of a (nearly continuous)
 grayscale image.  With 2 bpp, you can set up a colormap
 and allocate from 2 to 4 levels to represent antialiased text.
 Any left over colormap entries can be used for coloring regions.
 For the same number of levels, the file size of a 2 bpp image
 is about 10% smaller than that of a 4 bpp result for the same
 number of levels.  For both 2 bpp and 4 bpp, using 4 levels you
 get compression far better than that of jpeg, because the
 quantization to 4 levels will remove the jpeg ringing in the
 background near character edges.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="nlevels">equally spaced; must be between 2 and 4</param>
	<param name="cmapflag">1 to build colormap; 0 otherwise</param>
	<returns>pixd 2 bpp, optionally with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixThresholdTo4bpp(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Valid values for nlevels is the set {2, ... 16}.
 (2) Any colormap on the input pixs is removed to 8 bpp grayscale.
 (3) This function is typically invoked with cmapflag == 1.
 In the situation where no colormap is desired, nlevels is
 ignored and pixs is thresholded to 16 levels.
 (4) The target output colors are equally spaced, with the
 darkest at 0 and the lightest at 255.  The thresholds are
 chosen halfway between adjacent output values.  A table
 is built that specifies the mapping from src to dest.
 (5) If cmapflag == 1, a colormap of size 'nlevels' is made,
 and the pixel values in pixs are replaced by their
 appropriate color indices.  The number of holdouts,
 16 - nlevels, will be between 0 and 14.
 (6) If you don't want the thresholding to be equally spaced,
 either first transform the 8 bpp src using pixGammaTRC().
 or, if cmapflag == 1, after calling this function you can use
 pixcmapResetColor() to change any individual colors.
 (7) If a colormap is generated, it will specify, to display
 programs, exactly how each level is to be represented in RGB
 space.  When representing text, 3 levels is far better than
 2 because of the antialiasing of the single gray level,
 and 4 levels (black, white and 2 gray levels) is getting
 close to the perceptual quality of a (nearly continuous)
 grayscale image.  Therefore, with 4 bpp, you can set up a
 colormap, allocate a relatively small fraction of the 16
 possible values to represent antialiased text, and use the
 other colormap entries for other things, such as coloring
 text or background.  Two other reasons for using a small number
 of gray values for antialiased text are (1) PNG compression
 gets worse as the number of levels that are used is increased,
 and (2) using a small number of levels will filter out most of
 the jpeg ringing that is typically introduced near sharp edges
 of text.  This filtering is partly responsible for the improved
 compression.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, can have colormap</param>
	<param name="nlevels">equally spaced; must be between 2 and 16</param>
	<param name="cmapflag">1 to build colormap; 0 otherwise</param>
	<returns>pixd 4 bpp, optionally with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixThresholdOn8bpp(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Valid values for nlevels is the set {2,...,256}.
 (2) Any colormap on the input pixs is removed to 8 bpp grayscale.
 (3) If cmapflag == 1, a colormap of size 'nlevels' is made,
 and the pixel values in pixs are replaced by their
 appropriate color indices.  Otherwise, the pixel values
 are the actual thresholded (i.e., quantized) grayscale values.
 (4) If you don't want the thresholding to be equally spaced,
 first transform the input 8 bpp src using pixGammaTRC().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, can have colormap</param>
	<param name="nlevels">equally spaced; must be between 2 and 256</param>
	<param name="cmapflag">1 to build colormap; 0 otherwise</param>
	<returns>pixd 8 bpp, optionally with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixThresholdGrayArb(System.IntPtr,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This function allows exact specification of the quantization bins.
 The string %edgevals is a space-separated set of values
 specifying the dividing points between output quantization bins.
 These threshold values are assigned to the bin with higher
 values, so that each of them is the smallest value in their bin.
 (2) The output image (pixd) depth is specified by %outdepth.  The
 number of bins is the number of edgevals + 1.  The
 relation between outdepth and the number of bins is
 outdepth = 2 nbins LT= 4
 outdepth = 4 nbins LT= 16
 outdepth = 8 nbins LT= 256
 With %outdepth == 0, the minimum required depth for the
 given number of bins is used.
 The output pixd has a colormap.
 (3) The last 3 args determine the specific values that go into
 the colormap.
 (4) For %use_average
 ~ if TRUE, the average value of pixels falling in the bin is
 chosen as the representative gray value.  Otherwise,
 ~ if FALSE, the central value of each bin is chosen as
 the representative value.
 The colormap holds the representative value.
 (5) For %setblack, if TRUE the darkest color is set to (0,0,0).
 (6) For %setwhite, if TRUE the lightest color is set to (255,255,255).
 (7) An alternative to using this function to quantize to
 unequally-spaced bins is to first transform the 8 bpp pixs
 using pixGammaTRC(), and follow this with pixThresholdTo4bpp().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; can have colormap</param>
	<param name="edgevals">string giving edge value of each bin</param>
	<param name="outdepth">0, 2, 4 or 8 bpp; 0 is default for min depth</param>
	<param name="use_average">1 if use the average pixel value in colormap</param>
	<param name="setblack">1 if darkest color is set to black</param>
	<param name="setwhite">1 if lightest color is set to white</param>
	<returns>pixd 2, 4 or 8 bpp quantized image with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makeGrayQuantIndexTable(System.Int32)">
	<summary>
 Notes
 (1) 'nlevels' is some number between 2 and 256 (typically 8 or less).
 (2) The table is typically used for quantizing 2, 4 and 8 bpp
 grayscale src pix, and generating a colormapped dest pix.
 </summary>
	<remarks>
	</remarks>
	<param name="nlevels">number of output levels</param>
	<returns>table maps input gray level to colormap index, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makeGrayQuantTableArb(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The number of bins is the count of %na + 1.
 (2) The bin boundaries in na must be sorted in increasing order.
 (3) The table is an inverse colormap it maps input gray level
 to colormap index (the bin number).
 (4) The colormap generated here has quantized values at the
 center of each bin.  If you want to use the average gray
 value of pixels within the bin, discard the colormap and
 compute it using makeGrayQuantColormapArb().
 (5) Returns an error if there are not enough levels in the
 output colormap for the number of bins.  The number
 of bins must not exceed 2^outdepth.
 </summary>
	<remarks>
	</remarks>
	<param name="na">numa of bin boundaries</param>
	<param name="outdepth">of colormap 1, 2, 4 or 8</param>
	<param name="ptab">table mapping input gray level to cmap index</param>
	<param name="pcmap">colormap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenerateMaskByBand32(System.IntPtr,System.UInt32,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) Generates a 1 bpp mask pixd, the same size as pixs, where
 the fg pixels in the mask within a band of rgb values
 surrounding %refval.  The band can be chosen in two ways
 for each component
 (a) Use (%delm, %delp) to specify how many levels down and up
 (b) Use (%fractm, %fractp) to specify the fractional
 distance toward 0 and 255, respectively.
 Note that %delm and %delp must be in [0 ... 255], whereas
 %fractm and %fractp must be in [0.0 - 1.0].
 (2) Either (%delm, %delp) or (%fractm, %fractp) can be used.
 Set each value in the other pair to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="refval">reference rgb value</param>
	<param name="delm">max amount below the ref value for any component</param>
	<param name="delp">max amount above the ref value for any component</param>
	<param name="fractm">fractional amount below ref value for all components</param>
	<param name="fractp">fractional amount above ref value for all components</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenerateMaskByDiscr32(System.IntPtr,System.UInt32,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) Generates a 1 bpp mask pixd, the same size as pixs, where
 the fg pixels in the mask are those where the pixel in pixs
 is "closer" to refval1 than to refval2.
 (2) "Closer" can be defined in several ways, such as
 ~ manhattan distance (L1)
 ~ euclidean distance (L2)
 ~ majority vote of the individual components
 Here, we have a choice of L1 or L2.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="refval1">reference rgb value</param>
	<param name="refval2">reference rgb value</param>
	<param name="distflag">L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGrayQuantFromHisto(System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This is useful for quantizing images with relatively few
 colors, but which may have both color and gray pixels.
 If there are color pixels, it is assumed that an input
 rgb image has been color quantized first so that
 ~ pixd has a colormap describing the color pixels
 ~ pixm is a mask over the non-color pixels in pixd
 ~ the colormap in pixd, and the color pixels in pixd,
 have been repacked to go from 0 to n-1 (n colors)
 If there are no color pixels, pixd and pixm are both null,
 and all pixels in pixs are quantized to gray.
 (2) A 256-entry histogram is built of the gray values in pixs.
 If pixm exists, the pixels contributing to the histogram are
 restricted to the fg of pixm.  A colormap and LUT are generated
 from this histogram.  We break up the array into a set
 of intervals, each one constituting a color in the colormap
 An interval is identified by summing histogram bins until
 either the sum equals or exceeds the %minfract of the total
 number of pixels, or the span itself equals or exceeds %maxsize.
 The color of each bin is always an average of the pixels
 that constitute it.
 (3) Note that we do not specify the number of gray colors in
 the colormap.  Instead, we specify two parameters that
 describe the accuracy of the color assignments; this and
 the actual image determine the number of resulting colors.
 (4) If a mask exists and it is not the same size as pixs, make
 a new mask the same size as pixs, with the original mask
 aligned at the UL corners.  Set all additional pixels
 in the (larger) new mask set to 1, causing those pixels
 in pixd to be set as gray.
 (5) We estimate the total number of colors (color plus gray);
 if it exceeds 255, return null.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">quantized pix with cmap; can be null</param>
	<param name="pixs">8 bpp gray input pix; not cmapped</param>
	<param name="pixm">mask over pixels in pixs to quantize</param>
	<param name="minfract">minimum fraction of pixels in a set of adjacent histo bins that causes the set to be automatically set aside as a color in the colormap; must be at least 0.01</param>
	<param name="maxsize">maximum number of adjacent bins allowed to represent a color, regardless of the population of pixels in the bins; must be at least 2</param>
	<returns>pixd 8 bpp, cmapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGrayQuantFromCmap(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) In use, pixs is an 8 bpp grayscale image without a colormap.
 If there is an existing colormap, a warning is issued and
 a copy of the input pixs is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale without cmap</param>
	<param name="cmap">to quantize to; of dest pix</param>
	<param name="mindepth">minimum depth of pixd can be 2, 4 or 8 bpp</param>
	<returns>pixd 2, 4 or 8 bpp, colormapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lheapCreate(System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nalloc">size of ptr array to be alloc'd 0 for default</param>
	<param name="direction">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<returns>lheap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lheapDestroy(System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) Use freeflag == TRUE when the items in the array can be
 simply destroyed using free.  If those items require their
 own destroy function, they must be destroyed before
 calling this function, and then this function is called
 with freeflag == FALSE.
 (2) To destroy the lheap, we destroy the ptr array, then
 the lheap, and then null the contents of the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="plh">to be nulled</param>
	<param name="freeflag">TRUE to free each remaining struct in the array</param>
</member><member name="M:LeptonicaSharp.Natives.lheapAdd(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lh">heap</param>
	<param name="item">to be added to the tail of the heap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lheapRemove(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lh">heap</param>
	<returns>ptr to item popped from the root of the heap, or NULL if the heap is empty or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lheapGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lh">heap</param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lheapSwapUp(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is called after a new item is put on the heap, at the
 bottom of a complete tree.
 (2) To regain the heap order, we let it bubble up,
 iteratively swapping with its parent, until it either
 reaches the root of the heap or it finds a parent that
 is in the correct position already vis-a-vis the child.
 </summary>
	<remarks>
	</remarks>
	<param name="lh">heap</param>
	<param name="index">of array corresponding to node to be swapped up</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lheapSwapDown(System.IntPtr)">
	<summary>
 Notes
 (1) This is called after an item has been popped off the
 root of the heap, and the last item in the heap has
 been placed at the root.
 (2) To regain the heap order, we let it bubble down,
 iteratively swapping with one of its children.  For a
 decreasing sort, it swaps with the largest child; for
 an increasing sort, the smallest.  This continues until
 it either reaches the lowest level in the heap, or the
 parent finds that neither child should swap with it
 (e.g., for a decreasing heap, the parent is larger
 than or equal to both children).
 </summary>
	<remarks>
	</remarks>
	<param name="lh">heap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lheapSort(System.IntPtr)">
	<summary>
 Notes
 (1) This sorts an array into heap order.  If the heap is already
 in heap order for the direction given, this has no effect.
 </summary>
	<remarks>
	</remarks>
	<param name="lh">heap, with internal array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lheapSortStrictOrder(System.IntPtr)">
	<summary>
 Notes
 (1) This sorts a heap into strict order.
 (2) For each element, starting at the end of the array and
 working forward, the element is swapped with the head
 element and then allowed to swap down onto a heap of
 size reduced by one.  The result is that the heap is
 reversed but in strict order.  The array elements are
 then reversed to put it in the original order.
 </summary>
	<remarks>
	</remarks>
	<param name="lh">heap, with internal array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lheapPrint(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="lh">heap</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbRankHausInit(System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<param name="maxwidth">of component; use 0 for default</param>
	<param name="maxheight">of component; use 0 for default</param>
	<param name="size">of square structuring element; 2, representing 2x2 sel, is necessary for reasonable accuracy of small components; combine this with rank ~ 0.97 to avoid undue class expansion</param>
	<param name="rank">rank val of match, each way; in [0.5 - 1.0]; when using size = 2, 0.97 is a reasonable value</param>
	<returns>jbclasser if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbCorrelationInit(System.Int32,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) For scanned text, suggested input values are
 thresh ~ [0.8 - 0.85]
 weightfactor ~ [0.5 - 0.6]
 (2) For electronically generated fonts (e.g., rasterized pdf),
 a very high thresh (e.g., 0.95) will not cause a significant
 increase in the number of classes.
 </summary>
	<remarks>
	</remarks>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<param name="maxwidth">of component; use 0 for default</param>
	<param name="maxheight">of component; use 0 for default</param>
	<param name="thresh">value for correlation score in [0.4 - 0.98]</param>
	<param name="weightfactor">corrects thresh for thick characters [0.0 - 1.0]</param>
	<returns>jbclasser if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbCorrelationInitWithoutComponents(System.Int32,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 Acts the same as jbCorrelationInit(), but the resulting
 object doesn't keep a list of all the components.
 </summary>
	<remarks>
	</remarks>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<param name="maxwidth">of component; use 0 for default</param>
	<param name="maxheight">of component; use 0 for default</param>
	<param name="thresh">value  for correlation score in [0.4 - 0.98]</param>
	<param name="weightfactor">corrects thresh for thick characters [0.0 - 1.0]</param>
	<returns>jbclasser if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbAddPages(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) jbclasser makes a copy of the array of file names.
 (2) The caller is still responsible for destroying the input array.
 </summary>
	<remarks>
	</remarks>
	<param name="safiles">of page image file names</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbAddPage(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">input page</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbAddPageComponents(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) If there are no components on the page, we don't require input
 of empty boxas or pixas, although that's the typical situation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input page</param>
	<param name="boxas">b.b. of components for this page</param>
	<param name="pixas">components for this page</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbClassifyRankHaus(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa">new components for classification</param>
	<param name="pixas">new components for classification</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixHaustest(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 We check first that the two pix are roughly
 the same size.  Only if they meet that criterion do
 we compare the bitmaps.  The Hausdorff is a 2-way
 check.  The centroid difference is used to align the two
 images to the nearest integer for each of the checks.
 These check that the dilated image of one contains
 ALL the pixels of the undilated image of the other.
 Checks are done in both direction.  A single pixel not
 contained in either direction results in failure of the test.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">new pix, not dilated</param>
	<param name="pix2">new pix, dilated</param>
	<param name="pix3">exemplar pix, not dilated</param>
	<param name="pix4">exemplar pix, dilated</param>
	<param name="delx">x comp of centroid difference</param>
	<param name="dely">y comp of centroid difference</param>
	<param name="maxdiffw">max width difference of pix1 and pix2</param>
	<param name="maxdiffh">max height difference of pix1 and pix2</param>
	<returns>0 FALSE) if no match, 1 (TRUE if the new pix is in the same class as the exemplar.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRankHaustest(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Int32[])">
	<summary>
 Notes
 We check first that the two pix are roughly
 the same size.  Only if they meet that criterion do
 we compare the bitmaps.  We convert the rank value to
 a number of pixels by multiplying the rank fraction by the number
 of pixels in the undilated image.  The Hausdorff is a 2-way
 check.  The centroid difference is used to align the two
 images to the nearest integer for each of the checks.
 The rank hausdorff checks that the dilated image of one
 contains the rank fraction of the pixels of the undilated
 image of the other.   Checks are done in both direction.
 Failure of the test in either direction results in failure
 of the test.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">new pix, not dilated</param>
	<param name="pix2">new pix, dilated</param>
	<param name="pix3">exemplar pix, not dilated</param>
	<param name="pix4">exemplar pix, dilated</param>
	<param name="delx">x comp of centroid difference</param>
	<param name="dely">y comp of centroid difference</param>
	<param name="maxdiffw">max width difference of pix1 and pix2</param>
	<param name="maxdiffh">max height difference of pix1 and pix2</param>
	<param name="area1">fg pixels in pix1</param>
	<param name="area3">fg pixels in pix3</param>
	<param name="rank">rank value of test, each way</param>
	<param name="tab8">table of pixel sums for byte</param>
	<returns>0 FALSE) if no match, 1 (TRUE if the new pix is in the same class as the exemplar.</returns>
</member><member name="M:LeptonicaSharp.Natives.jbClassifyCorrelation(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa">new components for classification</param>
	<param name="pixas">new components for classification</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbGetComponents(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<param name="maxwidth">of saved components; larger are discarded</param>
	<param name="maxheight">of saved components; larger are discarded</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWordMaskByDilation(System.IntPtr,System.IntPtr,System.Int32@,System.IntPtr@)">
	<summary>
 Notes
 (1) This gives an estimate of the word masks.  See
 pixWordBoxesByDilation() for further filtering of the word boxes.
 (2) The resolution should be between 75 and 150 ppi, and the optimal
 dilation will be between 3 and 10.
 (3) A good size for dilating to get word masks is optionally returned.
 (4) Typically, the number of c.c. reduced with each successive
 dilation (stored in nadiff) decreases quickly to a minimum
 (where the characters in a word are joined), and then
 increases again as the smaller number of words are joined.
 For the typical case, you can then look for this minimum
 and dilate to get the word mask.  However, there are many
 cases where the function is not so simple. For example, if the
 pix has been upscaled 2x, the nadiff function oscillates, with
 every other value being zero!  And for some images it tails
 off without a clear minimum to indicate where to break.
 So a more simple and robust method is to find the dilation
 where the initial number of c.c. has been reduced by some
 fraction (we use a 70% reduction).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp; typ. at 75 to 150 ppi</param>
	<param name="psize">size of good horizontal dilation</param>
	<param name="pixadb">debug pixa of intermediate steps</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWordBoxesByDilation(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.Int32@,System.IntPtr@)">
	<summary>
 Notes
 (1) Returns a pruned set of word boxes.
 (2) See pixWordMaskByDilation().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp; typ. 75 - 200 ppi</param>
	<param name="minwidth">saved components; smaller are discarded</param>
	<param name="minheight">saved components; smaller are discarded</param>
	<param name="maxwidth">saved components; larger are discarded</param>
	<param name="maxheight">saved components; larger are discarded</param>
	<param name="pboxa">of dilated word mask</param>
	<param name="psize">size of good horizontal dilation</param>
	<param name="pixadb">debug pixa of intermediate steps</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbAccumulateComposites(System.IntPtr,System.IntPtr,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixaa">one pixa for each class</param>
	<param name="pptat">centroids of bordered composites</param>
	<returns>pixad accumulated sum of samples in each class, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbTemplatesFromComposites(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixac">one pix of composites for each class</param>
	<param name="na">number of samples used for each class composite</param>
	<returns>pixad 8 bpp templates for each class, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbClasserCreate(System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="method">JB_RANKHAUS, JB_CORRELATION</param>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<returns>jbclasser, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbClasserDestroy(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.jbDataSave(System.IntPtr)">
	<summary>
 Notes
 (1) This routine stores the jbig2-type data required for
 generating a lossy jbig2 version of the image.
 It can be losslessly written to (and read from) two files.
 (2) It generates and stores the mosaic of templates.
 (3) It clones the Numa and Pta arrays, so these must all
 be destroyed by the caller.
 (4) Input 0 to use the default values for latticew and/or latticeh,
 </summary>
	<remarks>
	</remarks>
	<returns>jbdata, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbDataDestroy(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.jbDataWrite(System.String,System.IntPtr)">
	<summary>
 Notes
 (1) Serialization function that writes data in jbdata to file.
 </summary>
	<remarks>
	</remarks>
	<param name="jbdata"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbDataRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="rootname">for template and data files</param>
	<returns>jbdata, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbDataRender(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="debugflag">if TRUE, writes into 2 bpp pix and adds component outlines in color</param>
	<returns>pixa reconstruction of original images, using templates or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbGetULCorners(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This computes the ptaul field, which has the global UL corners,
 adjusted for each specific component, so that each component
 can be replaced by the template for its class and have the
 centroid in the template in the same position as the
 centroid of the original connected component.  It is important
 that this be done properly to avoid a wavy baseline in the
 result.
 (2) The array fields ptac and ptact give the centroids of
 those components relative to the UL corner of each component.
 Here, we compute the difference in each component, round to
 nearest integer, and correct the box-GTx and box-GTy by
 the appropriate integral difference.
 (3) The templates and stored instances are all bordered.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">full res image</param>
	<param name="boxa">of c.c. bounding rectangles for this page</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.jbGetLLCorners(System.IntPtr)">
	<summary>
 Notes
 (1) This computes the ptall field, which has the global LL corners,
 adjusted for each specific component, so that each component
 can be replaced by the template for its class and have the
 centroid in the template in the same position as the
 centroid of the original connected component. It is important
 that this be done properly to avoid a wavy baseline in the result.
 (2) It is computed here from the corresponding UL corners, where
 the input templates and stored instances are all bordered.
 This should be done after all pages have been processed.
 (3) For proper substitution, the templates whose LL corners are
 placed in these locations must be UN-bordered.
 This is available for a realistic jbig2 encoder, which would
 (1) encode each template without a border, and (2) encode
 the position using the LL corner (rather than the UL
 corner) because the difference between y-values
 of successive instances is typically close to zero.
 </summary>
	<remarks>
	</remarks>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.readHeaderJp2k(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.freadHeaderJp2k(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for read</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.readHeaderMemJp2k(System.Byte[],System.UInt32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The ISO/IEC reference for jpeg2000 is
 http//www.jpeg.org/public/15444-1annexi.pdf
 and the file format syntax begins at page 127.
 (2) The Image Header Box begins with 'ihdr' = 0x69686472 in
 big-endian order.  This typically, but not always, starts
 byte 44, with the big-endian data fields beginning at byte 48
 h 4 bytes
 w 4 bytes
 spp  2 bytes
 bps  1 byte   (contains bps - 1)
 </summary>
	<remarks>
	</remarks>
	<param name="data"></param>
	<param name="size">at least 80</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fgetJp2kResolution(System.IntPtr,System.Object,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadJp2k(System.String,System.UInt32,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadStreamJp2k(System.IntPtr,System.UInt32,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteJp2k(System.String,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamJp2k(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadMemJp2k(System.Byte[],System.UInt32,System.UInt32,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMemJp2k(System.Object,System.Object,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadJpeg(System.String,System.Int32,System.Int32,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) This is a special function for reading jpeg files.
 (2) Use this if you want the jpeg library to create
 an 8 bpp colormapped image.
 (3) Images reduced by factors of 2, 4 or 8 can be returned
 significantly faster than full resolution images.
 (4) If the jpeg data is bad, the jpeg library will continue
 silently, or return warnings, or attempt to exit.  Depending
 on the severity of the data corruption, there are two possible
 outcomes
 (a) a possibly damaged pix can be generated, along with zero
 or more warnings, or
 (b) the library will attempt to exit (caught by our error
 handler) and no pix will be returned.
 If a pix is generated with at least one warning of data
 corruption, and if L_JPEG_FAIL_ON_BAD_DATA is included in %hint,
 no pix will be returned.
 (5) The possible hint values are given in the enum in imageio.h
 L_JPEG_READ_LUMINANCE
 L_JPEG_FAIL_ON_BAD_DATA
 Default (0) is to do neither.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="cmapflag">0 for no colormap in returned pix; 1 to return an 8 bpp cmapped pix if spp = 3 or 4</param>
	<param name="reduction">scaling factor 1, 2, 4 or 8</param>
	<param name="pnwarn">number of warnings about corrupted data</param>
	<param name="hint">a bitwise OR of L_JPEG_ values; 0 for default</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadStreamJpeg(System.IntPtr,System.Int32,System.Int32,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) The jpeg comment, if it exists, is not stored in the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="cmapflag">0 for no colormap in returned pix; 1 to return an 8 bpp cmapped pix if spp = 3 or 4</param>
	<param name="reduction">scaling factor 1, 2, 4 or 8</param>
	<param name="pnwarn">number of warnings</param>
	<param name="hint">a bitwise OR of L_JPEG_ values; 0 for default</param>
	<returns>pix, or NULL on error Usage see pixReadJpeg</returns>
</member><member name="M:LeptonicaSharp.Natives.readHeaderJpeg(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pspp">samples/pixel</param>
	<param name="pycck">1 if ycck color space; 0 otherwise</param>
	<param name="pcmyk">1 if cmyk color space; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.freadHeaderJpeg(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pspp">samples/pixel</param>
	<param name="pycck">1 if ycck color space; 0 otherwise</param>
	<param name="pcmyk">1 if cmyk color space; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fgetJpegResolution(System.IntPtr,System.Object,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.fgetJpegComment(System.IntPtr,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteJpeg(System.String,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pix">any depth; cmap is OK</param>
	<param name="quality">1 - 100; 75 is default</param>
	<param name="progressive">0 for baseline sequential; 1 for progressive</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamJpeg(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Progressive encoding gives better compression, at the
 expense of slower encoding and decoding.
 (2) Standard chroma subsampling is 2x2 on both the U and V
 channels.  For highest quality, use no subsampling; this
 option is set by pixSetChromaSampling(pix, 0).
 (3) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16
 and 32 bpp.  However, it is possible, and in some cases desirable,
 to write out a jpeg file using an rgb pix that has 24 bpp.
 This can be created by appending the raster data for a 24 bpp
 image (with proper scanline padding) directly to a 24 bpp
 pix that was created without a data array.
 (4) There are two compression paths in this function
 Grayscale image, no colormap compress as 8 bpp image.
 rgb full color image copy each line into the color
 line buffer, and compress as three 8 bpp images.
 (5) Under the covers, the jpeg library transforms rgb to a
 luminance-chromaticity triple, each component of which is
 also 8 bits, and compresses that.  It uses 2 Huffman tables,
 a higher resolution one (with more quantization levels)
 for luminosity and a lower resolution one for the chromas.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pixs">any depth; cmap is OK</param>
	<param name="quality">1 - 100; 75 is default value; 0 is also default</param>
	<param name="progressive">0 for baseline sequential; 1 for progressive</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadMemJpeg(System.Byte[],System.UInt32,System.Int32,System.Int32,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) The %size byte of %data must be a null character.
 (2) The only hint flag so far is L_JPEG_READ_LUMINANCE,
 given in the enum in imageio.h.
 (3) See pixReadJpeg() for usage.
 </summary>
	<remarks>
	</remarks>
	<param name="data">const; jpeg-encoded</param>
	<param name="size">of data</param>
	<param name="cmflag">colormap flag 0 means return RGB image if color; 1 means create a colormap and return an 8 bpp colormapped image if color</param>
	<param name="reduction">scaling factor 1, 2, 4 or 8</param>
	<param name="pnwarn">number of warnings</param>
	<param name="hint">a bitwise OR of L_JPEG_ values; 0 for default</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.readHeaderMemJpeg(System.Byte[],System.UInt32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">const; jpeg-encoded</param>
	<param name="size">of data</param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<param name="pspp">samples/pixel</param>
	<param name="pycck">1 if ycck color space; 0 otherwise</param>
	<param name="pcmyk">1 if cmyk color space; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.readResolutionMemJpeg(System.Byte[],System.UInt32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">const; jpeg-encoded</param>
	<param name="size">of data</param>
	<param name="pxres"></param>
	<param name="pyres"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMemJpeg(System.IntPtr@,System.UInt32@,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixWriteStreamJpeg() for usage.  This version writes to
 memory instead of to a file stream.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of jpeg compressed image</param>
	<param name="psize">size of returned data</param>
	<param name="pix">any depth; cmap is OK</param>
	<param name="quality">1 - 100; 75 is default value; 0 is also default</param>
	<param name="progressive">0 for baseline sequential; 1 for progressive</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetChromaSampling(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The default is for 2x2 chroma subsampling because the files are
 considerably smaller and the appearance is typically satisfactory.
 To get full resolution output in the chroma channels for
 jpeg writing, call this with %sampling == 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="sampling">1 for subsampling; 0 for no subsampling</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelCreate(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) kernelCreate() initializes all values to 0.
 (2) After this call, (cy,cx) and nonzero data values must be
 assigned.
 (2) The number of kernel elements must be less than 2^29.
 </summary>
	<remarks>
	</remarks>
	<param name="height"></param>
	<param name="width"></param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pkel">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.kernelCopy(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kels">source kernel</param>
	<returns>keld copy of kels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelGetElement(System.IntPtr,System.Int32,System.Int32,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kel"></param>
	<param name="row"></param>
	<param name="col"></param>
	<param name="pval"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelSetElement(System.IntPtr,System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kel">kernel</param>
	<param name="row"></param>
	<param name="col"></param>
	<param name="val"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelGetParameters(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kel">kernel</param>
	<param name="psy">each can be null</param>
	<param name="psx">each can be null</param>
	<param name="pcy">each can be null</param>
	<param name="pcx">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelSetOrigin(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kel">kernel</param>
	<param name="cy"></param>
	<param name="cx"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelGetSum(System.IntPtr,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kel">kernel</param>
	<param name="psum">sum of all kernel values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelGetMinMax(System.IntPtr,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kel">kernel</param>
	<param name="pmin">minimum value</param>
	<param name="pmax">maximum value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelNormalize(System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) If the sum of kernel elements is close to 0, do not
 try to calculate the normalized kernel.  Instead,
 return a copy of the input kernel, with a warning.
 </summary>
	<remarks>
	</remarks>
	<param name="kels">source kel, to be normalized</param>
	<param name="normsum">desired sum of elements in keld</param>
	<returns>keld normalized version of kels, or NULL on error or if sum of elements is very close to 0)</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelInvert(System.IntPtr)">
	<summary>
 Notes
 (1) For convolution, the kernel is spatially inverted before
 a "correlation" operation is done between the kernel and the image.
 </summary>
	<remarks>
	</remarks>
	<param name="kels">source kel, to be inverted</param>
	<returns>keld spatially inverted, about the origin, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.create2dFloatArray(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The array[sy][sx] is indexed in standard "matrix notation",
 with the row index first.
 (2) The caller kernelCreate() limits the size to LT 2^29 pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="sy">rows == height</param>
	<param name="sx">columns == width</param>
	<returns>doubly indexed array i.e., an array of sy row pointers, each of which points to an array of sx floats</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">filename</param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">output file</param>
	<param name="kel">kernel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="kel"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelCreateFromString(System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) The data is an array of chars, in row-major order, giving
 space separated integers in the range [-255 ... 255].
 (2) The only other formatting limitation is that you must
 leave space between the last number in each row and
 the double-quote.  If possible, it's also nice to have each
 line in the string represent a line in the kernel; e.g.,
 static const char kdata =
 " 20   50   20 "
 " 70  140   70 "
 " 20   50   20 ";
 </summary>
	<remarks>
	</remarks>
	<param name="h">height, width</param>
	<param name="w">height, width</param>
	<param name="cy">origin</param>
	<param name="cx">origin</param>
	<param name="kdata"></param>
	<returns>kernel of the given size, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelCreateFromFile(System.String)">
	<summary>
 Notes
 (1) The file contains, in the following order
 ~ Any number of comment lines starting with '#' are ignored
 ~ The height and width of the kernel
 ~ The y and x values of the kernel origin
 ~ The kernel data, formatted as lines of numbers (integers
 or floats) for the kernel values in row-major order,
 and with no other punctuation.
 (Note this differs from kernelCreateFromString(),
 where each line must begin and end with a double-quote
 to tell the compiler it's part of a string.)
 ~ The kernel specification ends when a blank line,
 a comment line, or the end of file is reached.
 (2) All lines must be left-justified.
 (3) See kernelCreateFromString() for a description of the string
 format for the kernel data.  As an example, here are the lines
 of a valid kernel description file  In the file, all lines
 are left-justified
 \code
 # small 3x3 kernel
 3 3
 1 1
 25.5   51 24.3
 70.2  146.3  73.4
 20  50.9  18.4
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelCreateFromPix(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The origin must be positive and within the dimensions of the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="cy">origin of kernel</param>
	<param name="cx">origin of kernel</param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.kernelDisplayInPix(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This gives a visual representation of a kernel.
 (2) There are two modes of display
 (a) Grid lines of minimum width 2, surrounding regions
 representing kernel elements of minimum size 17,
 with a "plus" mark at the kernel origin, or
 (b) A pix without grid lines and using 1 pixel per kernel element.
 (3) For both cases, the kernel absolute value is displayed,
 normalized such that the maximum absolute value is 255.
 (4) Large 2D separable kernels should be used for convolution
 with two 1D kernels.  However, for the bilateral filter,
 the computation time is independent of the size of the
 2D content kernel.
 </summary>
	<remarks>
	</remarks>
	<param name="kel">kernel</param>
	<param name="size">of grid interiors; odd; either 1 or a minimum size of 17 is enforced</param>
	<param name="gthick">grid thickness; either 0 or a minimum size of 2 is enforced</param>
	<returns>pix display of kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.parseStringForNumbers(System.String,System.String)">
	<summary>
 Notes
 (1) The numbers can be ints or floats.
 </summary>
	<remarks>
	</remarks>
	<param name="str">string containing numbers; not changed</param>
	<param name="seps">string of characters that can be used between ints</param>
	<returns>numa of numbers found, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makeFlatKernel(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is the same low-pass filtering kernel that is used
 in the block convolution functions.
 (2) The kernel origin (%cy, %cx) is typically placed as near
 the center of the kernel as possible.  If height and
 width are odd, then using cy = height / 2 and
 cx = width / 2 places the origin at the exact center.
 (3) This returns a normalized kernel.
 </summary>
	<remarks>
	</remarks>
	<param name="height"></param>
	<param name="width"></param>
	<param name="cy">origin of kernel</param>
	<param name="cx">origin of kernel</param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makeGaussianKernel(System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) The kernel size (sx, sy) = (2  halfwidth + 1, 2  halfheight + 1).
 (2) The kernel center (cx, cy) = (halfwidth, halfheight).
 (3) The halfwidth and halfheight are typically equal, and
 are typically several times larger than the standard deviation.
 (4) If pixConvolve() is invoked with normalization (the sum of
 kernel elements = 1.0), use 1.0 for max (or any number that's
 not too small or too large).
 </summary>
	<remarks>
	</remarks>
	<param name="halfheight">sx = 2  halfwidth + 1, etc</param>
	<param name="halfwidth">sx = 2  halfwidth + 1, etc</param>
	<param name="stdev">standard deviation</param>
	<param name="max">value at (cx,cy)</param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makeGaussianKernelSep(System.Int32,System.Int32,System.Single,System.Single,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) See makeGaussianKernel() for description of input parameters.
 (2) These kernels are constructed so that the result of both
 normalized and un-normalized convolution will be the same
 as when convolving with pixConvolve() using the full kernel.
 (3) The trick for the un-normalized convolution is to have the
 product of the two kernel elemets at (cx,cy) be equal to max,
 not max2.  That's why the max for kely is 1.0.  If instead
 we use sqrt(max) for both, the results are slightly less
 accurate, when compared to using the full kernel in
 makeGaussianKernel().
 </summary>
	<remarks>
	</remarks>
	<param name="halfheight">sx = 2  halfwidth + 1, etc</param>
	<param name="halfwidth">sx = 2  halfwidth + 1, etc</param>
	<param name="stdev">standard deviation</param>
	<param name="max">value at (cx,cy)</param>
	<param name="pkelx">x part of kernel</param>
	<param name="pkely">y part of kernel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makeDoGKernel(System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) The DoG (difference of gaussians) is a wavelet mother
 function with null total sum.  By subtracting two blurred
 versions of the image, it acts as a bandpass filter for
 frequencies passed by the narrow gaussian but stopped
 by the wide one.See
 http//en.wikipedia.org/wiki/Difference_of_Gaussians
 (2) The kernel size (sx, sy) = (2  halfwidth + 1, 2  halfheight + 1).
 (3) The kernel center (cx, cy) = (halfwidth, halfheight).
 (4) The halfwidth and halfheight are typically equal, and
 are typically several times larger than the standard deviation.
 (5) The ratio is the ratio of standard deviations of the wide
 to narrow gaussian.  It must be GT= 1.0; 1.0 is a no-op.
 (6) Because the kernel is a null sum, it must be invoked without
 normalization in pixConvolve().
 </summary>
	<remarks>
	</remarks>
	<param name="halfheight">sx = 2  halfwidth + 1, etc</param>
	<param name="halfwidth">sx = 2  halfwidth + 1, etc</param>
	<param name="stdev">standard deviation of narrower gaussian</param>
	<param name="ratio">of stdev for wide filter to stdev for narrow one</param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetWindowsHBITMAP(System.IntPtr)">
	<summary>
 Notes
 (1) It's the responsibility of the caller to destroy the
 returned hBitmap with a call to DeleteObject (or with
 something that eventually calls DeleteObject).
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>Windows hBitmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getImagelibVersions">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.listDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) This only destroys the cons cells.  Before destroying
 the list, it is necessary to remove all data and set the
 data pointers in each cons cell to NULL.
 (2) listDestroy() will give a warning message for each data
 ptr that is not NULL.
 </summary>
	<remarks>
	</remarks>
	<param name="phead">to be nulled; head of list</param>
</member><member name="M:LeptonicaSharp.Natives.listAddToHead(System.IntPtr@,System.IntPtr)">
	<summary>
 Notes
 (1) This makes a new cell, attaches the data, and adds the
 cell to the head of the list.
 (2) When consing from NULL, be sure to initialize head to NULL
 before calling this function.
 </summary>
	<remarks>
	</remarks>
	<param name="phead">input head</param>
	<param name="data">void ptr, to be added</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.listAddToTail(System.IntPtr@,System.IntPtr@,System.IntPtr)">
	<summary>
 Notes
 (1) This makes a new cell, attaches the data, and adds the
 cell to the tail of the list.
 (2) head is input to allow the list to be "cons'd" up from NULL.
 (3) tail is input to allow the tail to be updated
 for efficient sequential operation with this function.
 (4) We assume that if phead and/or ptail are not NULL,
 then they are valid addresses.  Therefore
 (a) when consing from NULL, be sure to initialize both
 head and tail to NULL.
 (b) when tail == NULL for an existing list, the tail
 will be found and updated.
 </summary>
	<remarks>
	</remarks>
	<param name="phead">[may be updated], can be NULL</param>
	<param name="ptail">[updated], can be NULL</param>
	<param name="data">void ptr, to be hung on tail cons cell</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.listInsertBefore(System.IntPtr@,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This can be called on a null list, in which case both
 head and elem must be null.
 (2) If you are searching through a list, looking for a condition
 to add an element, you can do something like this
 \code
 L_BEGIN_LIST_FORWARD(head, elem)
 LTidentify an elem to insert beforeGT
 listInsertBefore(head, elem, data);
 L_END_LIST
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="phead">input head</param>
	<param name="elem">list element to be inserted in front of; must be NULL if head is NULL</param>
	<param name="data">void  address, to be added</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.listInsertAfter(System.IntPtr@,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This can be called on a null list, in which case both
 head and elem must be null.  The head is included
 in the call to allow "consing" up from NULL.
 (2) If you are searching through a list, looking for a condition
 to add an element, you can do something like this
 \code
 L_BEGIN_LIST_FORWARD(head, elem)
 LTidentify an elem to insert afterGT
 listInsertAfter(head, elem, data);
 L_END_LIST
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="phead">input head</param>
	<param name="elem">list element to be inserted after; must be NULL if head is NULL</param>
	<param name="data">void  ptr, to be added</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.listRemoveElement(System.IntPtr@,System.IntPtr)">
	<summary>
 Notes
 (1) in ANSI C, it is not necessary to cast return to actual type; e.g.,
 pix = listRemoveElement(head, elem);
 but in ANSI C++, it is necessary to do the cast
 pix = (Pix )listRemoveElement(head, elem);
 </summary>
	<remarks>
	</remarks>
	<param name="phead">[can be changed] input head</param>
	<param name="elem">list element to be removed</param>
	<returns>data  void struct on cell</returns>
</member><member name="M:LeptonicaSharp.Natives.listRemoveFromHead(System.IntPtr@)">
	<summary>
 Notes
 (1) in ANSI C, it is not necessary to cast return to actual type; e.g.,
 pix = listRemoveFromHead(head);
 but in ANSI C++, it is necessary to do the cast; e.g.,
 pix = (Pix )listRemoveFromHead(head);
 </summary>
	<remarks>
	</remarks>
	<param name="phead">head of list [to be updated]</param>
	<returns>data  void struct on cell, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.listRemoveFromTail(System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) We include head so that it can be set to NULL if
 if the only element in the list is removed.
 (2) The function is relying on the fact that if tail is
 not NULL, then is is a valid address.  You can use
 this function with tail == NULL for an existing list, in
 which case  the tail is found and updated, and the
 removed element is returned.
 (3) In ANSI C, it is not necessary to cast return to actual type; e.g.,
 pix = listRemoveFromTail(head, tail);
 but in ANSI C++, it is necessary to do the cast; e.g.,
 pix = (Pix )listRemoveFromTail(head, tail);
 </summary>
	<remarks>
	</remarks>
	<param name="phead">[may be changed], head must NOT be NULL</param>
	<param name="ptail">[always updated], tail may be NULL</param>
	<returns>data  void struct on cell or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.listFindElement(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This returns a ptr to the cell, which is still embedded in
 the list.
 (2) This handle and the attached data have not been copied or
 reference counted, so they must not be destroyed.  This
 violates our basic rule that every handle returned from a
 function is owned by that function and must be destroyed,
 but if rules aren't there to be broken, why have them?
 </summary>
	<remarks>
	</remarks>
	<param name="head">list head</param>
	<param name="data">void  address, to be searched for</param>
	<returns>cell  the containing cell, or NULL if not found or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.listFindTail(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="head"></param>
	<returns>tail, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.listGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="head">of list</param>
	<returns>number of elements; 0 if no list or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.listReverse(System.IntPtr@)">
	<summary>
 Notes
 (1) This reverses the list in-place.
 </summary>
	<remarks>
	</remarks>
	<param name="phead">[may be changed] list head</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.listJoin(System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The concatenated list is returned with head1 as the new head.
 (2) Both input ptrs must exist, though either can have the value NULL.
 </summary>
	<remarks>
	</remarks>
	<param name="phead1">[may be changed] head of first list</param>
	<param name="phead2">to be nulled; head of second list</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_amapCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_amapFind(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_amapInsert(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.l_amapDelete(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.l_amapDestroy(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.l_amapGetFirst(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_amapGetNext(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_amapGetLast(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_amapGetPrev(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_amapSize(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_asetCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_asetFind(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_asetInsert(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.l_asetDelete(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.l_asetDestroy(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.l_asetGetFirst(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_asetGetNext(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_asetGetLast(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_asetGetPrev(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_asetSize(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.generateBinaryMaze(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) We have two input probability factors that determine the
 density of walls and average length of straight passages.
 When ranis LT 1.0, you are more likely to generate a wall
 to the side than going forward.  Enter 0.0 for either if
 you want to use the default values.
 (2) This is a type of percolation problem, and exhibits
 different phases for different parameters wallps and ranis.
 For larger values of these parameters, regions in the maze
 are not explored because the maze generator walls them
 off and cannot get through.  The boundary between the
 two phases in this two-dimensional parameter space goes
 near these values
 wallps ranis
 0.35   1.00
 0.40   0.85
 0.45   0.70
 0.50   0.50
 0.55   0.40
 0.60   0.30
 0.65   0.25
 0.70   0.19
 0.75   0.15
 0.80   0.11
 (3) Because there is a considerable amount of overhead in calling
 pixGetPixel() and pixSetPixel(), this function can be sped
 up with little effort using raster line pointers and the
 GET_DATA and SET_DATA macros.
 </summary>
	<remarks>
	</remarks>
	<param name="w">size of maze</param>
	<param name="h">size of maze</param>
	<param name="xi">initial location</param>
	<param name="yi">initial location</param>
	<param name="wallps">probability that a pixel to the side is ON</param>
	<param name="ranis">ratio of prob that pixel in forward direction is a wall to the probability that pixel in side directions is a wall</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSearchBinaryMaze(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) Because of the overhead in calling pixGetPixel() and
 pixSetPixel(), we have used raster line pointers and the
 GET_DATA and SET_DATA macros for many of the pix accesses.
 (2) Commentary
 The goal is to find the shortest path between beginning and
 end points, without going through walls, and there are many
 ways to solve this problem.
 We use a queue to implement a breadth-first search.  Two auxiliary
 "image" data structures can be used one to mark the visited
 pixels and one to give the direction to the parent for each
 visited pixel.  The first structure is used to avoid putting
 pixels on the queue more than once, and the second is used
 for retracing back to the origin, like the breadcrumbs in
 Hansel and Gretel.  Each pixel taken off the queue is destroyed
 after it is used to locate the allowed neighbors.  In fact,
 only one distance image is required, if you initialize it
 to some value that signifies "not yet visited."  (We use
 a binary image for marking visited pixels because it is clearer.)
 This method for a simple search of a binary maze is implemented in
 pixSearchBinaryMaze().
 An alternative method would store the (manhattan) distance
 from the start point with each pixel on the queue.  The children
 of each pixel get a distance one larger than the parent.  These
 values can be stored in an auxiliary distance map image
 that is constructed simultaneously with the search.  Once the
 end point is reached, the distance map is used to backtrack
 along a minimum path.  There may be several equal length
 minimum paths, any one of which can be chosen this way.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, maze</param>
	<param name="xi">beginning point; use same initial point that was used to generate the maze</param>
	<param name="yi">beginning point; use same initial point that was used to generate the maze</param>
	<param name="xf">end point, or close to it</param>
	<param name="yf">end point, or close to it</param>
	<param name="ppixd">maze with path illustrated, or if no path possible, the part of the maze that was searched</param>
	<returns>pta shortest path, or NULL if either no path exists or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSearchGrayMaze(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, maze</param>
	<param name="xi">beginning point; use same initial point that was used to generate the maze</param>
	<param name="yi">beginning point; use same initial point that was used to generate the maze</param>
	<param name="xf">end point, or close to it</param>
	<param name="yf">end point, or close to it</param>
	<param name="ppixd">maze with path illustrated, or if no path possible, the part of the maze that was searched</param>
	<returns>pta shortest path, or NULL if either no path exists or on error Commentary Consider first a slight generalization of the binary maze search problem.  Suppose that you can go through walls, but the cost is higher say, an increment of 3 to go into a wall pixel rather than 1?  You're still trying to find the shortest path.  One way to do this is with an ordered queue, and a simple way to visualize an ordered queue is as a set of stacks, each stack being marked with the distance of each pixel in the stack from the start.  We place the start pixel in stack 0, pop it, and process its 4 children. Each pixel is given a distance that is incremented from that of its parent 0 in this case, depending on if it is a wall pixel or not.  That value may be recorded on a distance map, according to the algorithm below.  For children of the first pixel, those not on a wall go in stack 1, and wall children go in stack 3.  Stack 0 being emptied, the process then continues with pixels being popped from stack 1. Here is the algorithm for each child pixel.  The pixel's distance value, were it to be placed on a stack, is compared with the value for it that is on the distance map.  There are three possible cases 1 If the pixel has not yet been registered, it is pushed on its stack and the distance is written to the map. 2 If it has previously been registered with a higher distance, the distance on the map is relaxed to that of the current pixel, which is then placed on its stack. 3 If it has previously been registered with an equal or lower value, the pixel is discarded. The pixels are popped and processed successively from stack 1, and when stack 1 is empty, popping starts on stack 2. This continues until the destination pixel is popped off a stack.   The minimum path is then derived from the distance map, going back from the end point as before.  This is just Dijkstra's algorithm for a directed graph; here, the underlying graph consisting of the pixels and four edges connecting each pixel to its 4-neighbor is a special case of a directed graph, where each edge is bi-directional.  The implementation of this generalized maze search is left as an exercise to the reader. Let's generalize a bit further.  Suppose the "maze" is just a grayscale image -- think of it as an elevation map.  The cost of moving on this surface depends on the height, or the gradient, or whatever you want.  All that is required is that the cost is specified and non-negative on each link between adjacent pixels.  Now the problem becomes find the least cost path moving on this surface between two specified end points. For example, if the cost across an edge between two pixels depends on the "gradient", you can use cost = 1 + L_ABSdeltaV where deltaV is the difference in value between two adjacent pixels.  If the costs are all integers, we can still use an array of stacks to avoid ordering the queue e.g., by using a heap sort. This is a neat problem, because you don't even have to build a maze -- you can can use it on any grayscale image! Rather than using an array of stacks, a more practical approach is to implement with a priority queue, which is a queue that is sorted so that the elements with the largest or smallest key values always come off first.  The priority queue is efficiently implemented as a heap, and this is how we do it.  Suppose you run the algorithm using a priority queue, doing the bookkeeping with an auxiliary image data structure that saves the distance of each pixel put on the queue as before, according to the method described above.  We implement it as a 2-way choice by initializing the distance array to a large value and putting a pixel on the queue if its distance is less than the value found on the array.  When you finally pop the end pixel from the queue, you're done, and you can trace the path backward, either always going downhill or using an auxiliary image to give you the direction to go at each step.  This is implemented here in searchGrayMaze. Do we really have to use a sorted queue?  Can we solve this generalized maze with an unsorted queue of pixels?  Or even an unsorted stack, doing a depth-first search (DFS)? Consider a different algorithm for this generalized maze, where we travel again breadth first, but this time use a single, unsorted queue.  An auxiliary image is used as before to store the distances and to determine if pixels get pushed on the stack or dropped.  As before, we must allow pixels to be revisited, with relaxation of the distance if a shorter path arrives later.  As a result, we will in general have multiple instances of the same pixel on the stack with different distances.  However, because the queue is not ordered, some of these pixels will be popped when another instance with a lower distance is still on the stack.  Here, we're just popping them in the order they go on, rather than setting up a priority based on minimum distance.  Thus, unlike the priority queue, when a pixel is popped we have to check the distance map to see if a pixel with a lower distance has been put on the queue, and, if so, we discard the pixel we just popped.  So the "while" loop looks like this ~ pop a pixel from the queue ~ check its distance against the distance stored in the distance map; if larger, discard ~ otherwise, for each of its neighbors ~ compute its distance from the start pixel ~ compare this distance with that on the distance map ~ if the distance map value higher, relax the distance and push the pixel on the queue ~ if the distance map value is lower, discard the pixel How does this loop terminate?  Before, with an ordered queue, it terminates when you pop the end pixel.  But with an unordered queue or stack, the first time you hit the end pixel, the distance is not guaranteed to be correct, because the pixels along the shortest path may not have yet been visited and relaxed. Because the shortest path can theoretically go anywhere, we must keep going.  How do we know when to stop?   Dijkstra uses an ordered queue to systematically remove nodes from further consideration.  Each time a pixel is popped, we're done with it; it's "finalized" in the Dijkstra sense because we know the shortest path to it.  However, with an unordered queue, the brute force answer is stop when the queue or stack is empty, because then every pixel in the image has been assigned its minimum "distance" from the start pixel. This is similar to the situation when you use a stack for the simpler uniform-step problem with breadth-first search BFS the pixels on the queue are automatically ordered, so you are done when you locate the end pixel as a neighbor of a popped pixel; whereas depth-first search DFS, using a stack, requires, in general, a search of every accessible pixel.  Further, if a pixel is revisited with a smaller distance, that distance is recorded and the pixel is put on the stack again. But surely, you ask, can't we stop sooner?  What if the start and end pixels are very close to each other? OK, suppose they are, and you have very high walls and a long snaking level path that is actually the minimum cost. That long path can wind back and forth across the entire maze many times before ending up at the end point, which could be just over a wall from the start.  With the unordered queue, you very quickly get a high distance for the end pixel, which will be relaxed to the minimum distance only after all the pixels of the path have been visited and placed on the queue, multiple times for many of them.  So that's the price for not ordering the queue!</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDilate(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This dilates src using hits in Sel.
 (2) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixDilate(NULL, pixs, ...);
 (b) pixDilate(pixs, pixs, ...);
 (c) pixDilate(pixd, pixs, ...);
 (4) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixErode(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This erodes src using hits in Sel.
 (2) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixErode(NULL, pixs, ...);
 (b) pixErode(pixs, pixs, ...);
 (c) pixErode(pixd, pixs, ...);
 (4) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixHMT(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) The hit-miss transform erodes the src, using both hits
 and misses in the Sel.  It ANDs the shifted src for hits
 and ANDs the inverted shifted src for misses.
 (2) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixHMT(NULL, pixs, ...);
 (b) pixHMT(pixs, pixs, ...);
 (c) pixHMT(pixd, pixs, ...);
 (4) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOpen(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Generic morphological opening, using hits in the Sel.
 (2) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixOpen(NULL, pixs, ...);
 (b) pixOpen(pixs, pixs, ...);
 (c) pixOpen(pixd, pixs, ...);
 (4) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixClose(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Generic morphological closing, using hits in the Sel.
 (2) This implementation is a strict dual of the opening if
 symmetric boundary conditions are used (see notes at top
 of this file).
 (3) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (4) For clarity, if the case is known, use these patterns
 (a) pixd = pixClose(NULL, pixs, ...);
 (b) pixClose(pixs, pixs, ...);
 (c) pixClose(pixd, pixs, ...);
 (5) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCloseSafe(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Generic morphological closing, using hits in the Sel.
 (2) If non-symmetric boundary conditions are used, this
 function adds a border of OFF pixels that is of
 sufficient size to avoid losing pixels from the dilation,
 and it removes the border after the operation is finished.
 It thus enforces a correct extensive result for closing.
 (3) If symmetric b.c. are used, it is not necessary to add
 and remove this border.
 (4) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (5) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseSafe(NULL, pixs, ...);
 (b) pixCloseSafe(pixs, pixs, ...);
 (c) pixCloseSafe(pixd, pixs, ...);
 (6) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOpenGeneralized(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Generalized morphological opening, using both hits and
 misses in the Sel.
 (2) This does a hit-miss transform, followed by a dilation
 using the hits.
 (3) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (4) For clarity, if the case is known, use these patterns
 (a) pixd = pixOpenGeneralized(NULL, pixs, ...);
 (b) pixOpenGeneralized(pixs, pixs, ...);
 (c) pixOpenGeneralized(pixd, pixs, ...);
 (5) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCloseGeneralized(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Generalized morphological closing, using both hits and
 misses in the Sel.
 (2) This does a dilation using the hits, followed by a
 hit-miss transform.
 (3) This operation is a dual of the generalized opening.
 (4) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (5) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseGeneralized(NULL, pixs, ...);
 (b) pixCloseGeneralized(pixs, pixs, ...);
 (c) pixCloseGeneralized(pixd, pixs, ...);
 (6) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDilateBrick(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do separably if both hsize and vsize are GT 1.
 (4) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (5) For clarity, if the case is known, use these patterns
 (a) pixd = pixDilateBrick(NULL, pixs, ...);
 (b) pixDilateBrick(pixs, pixs, ...);
 (c) pixDilateBrick(pixd, pixs, ...);
 (6) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixErodeBrick(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do separably if both hsize and vsize are GT 1.
 (4) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (5) For clarity, if the case is known, use these patterns
 (a) pixd = pixErodeBrick(NULL, pixs, ...);
 (b) pixErodeBrick(pixs, pixs, ...);
 (c) pixErodeBrick(pixd, pixs, ...);
 (6) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOpenBrick(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do separably if both hsize and vsize are GT 1.
 (4) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (5) For clarity, if the case is known, use these patterns
 (a) pixd = pixOpenBrick(NULL, pixs, ...);
 (b) pixOpenBrick(pixs, pixs, ...);
 (c) pixOpenBrick(pixd, pixs, ...);
 (6) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCloseBrick(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do separably if both hsize and vsize are GT 1.
 (4) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (5) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseBrick(NULL, pixs, ...);
 (b) pixCloseBrick(pixs, pixs, ...);
 (c) pixCloseBrick(pixd, pixs, ...);
 (6) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCloseSafeBrick(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do separably if both hsize and vsize are GT 1.
 (4) Safe closing adds a border of 0 pixels, of sufficient size so
 that all pixels in input image are processed within
 32-bit words in the expanded image.  As a result, there is
 no special processing for pixels near the boundary, and there
 are no boundary effects.  The border is removed at the end.
 (5) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (6) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseBrick(NULL, pixs, ...);
 (b) pixCloseBrick(pixs, pixs, ...);
 (c) pixCloseBrick(pixd, pixs, ...);
 (7) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selectComposableSels(System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.selectComposableSizes(System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This works for Sel sizes up to 62500, which seems sufficient.
 (2) The composable sel size is typically within +- 1 of
 the requested size.  Up to size = 300, the maximum difference
 is +- 2.
 (3) We choose an overall cost function where the penalty for
 the size difference between input and actual is 4 times
 the penalty for additional rasterops.
 (4) Returned values factor1 GT= factor2
 If size GT 1, then factor1 GT 1.
 </summary>
	<remarks>
	</remarks>
	<param name="size">of sel to be decomposed</param>
	<param name="pfactor1">larger factor</param>
	<param name="pfactor2">smaller factor</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDilateCompBrick(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do compositely for each dimension GT 1.
 (4) Do separably if both hsize and vsize are GT 1.
 (5) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (6) For clarity, if the case is known, use these patterns
 (a) pixd = pixDilateCompBrick(NULL, pixs, ...);
 (b) pixDilateCompBrick(pixs, pixs, ...);
 (c) pixDilateCompBrick(pixd, pixs, ...);
 (7) The dimensions of the resulting image are determined by pixs.
 (8) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixErodeCompBrick(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do compositely for each dimension GT 1.
 (4) Do separably if both hsize and vsize are GT 1.
 (5) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (6) For clarity, if the case is known, use these patterns
 (a) pixd = pixErodeCompBrick(NULL, pixs, ...);
 (b) pixErodeCompBrick(pixs, pixs, ...);
 (c) pixErodeCompBrick(pixd, pixs, ...);
 (7) The dimensions of the resulting image are determined by pixs.
 (8) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOpenCompBrick(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do compositely for each dimension GT 1.
 (4) Do separably if both hsize and vsize are GT 1.
 (5) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (6) For clarity, if the case is known, use these patterns
 (a) pixd = pixOpenCompBrick(NULL, pixs, ...);
 (b) pixOpenCompBrick(pixs, pixs, ...);
 (c) pixOpenCompBrick(pixd, pixs, ...);
 (7) The dimensions of the resulting image are determined by pixs.
 (8) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCloseCompBrick(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do compositely for each dimension GT 1.
 (4) Do separably if both hsize and vsize are GT 1.
 (5) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (6) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseCompBrick(NULL, pixs, ...);
 (b) pixCloseCompBrick(pixs, pixs, ...);
 (c) pixCloseCompBrick(pixd, pixs, ...);
 (7) The dimensions of the resulting image are determined by pixs.
 (8) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCloseSafeCompBrick(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do compositely for each dimension GT 1.
 (4) Do separably if both hsize and vsize are GT 1.
 (5) Safe closing adds a border of 0 pixels, of sufficient size so
 that all pixels in input image are processed within
 32-bit words in the expanded image.  As a result, there is
 no special processing for pixels near the boundary, and there
 are no boundary effects.  The border is removed at the end.
 (6) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (7) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseSafeCompBrick(NULL, pixs, ...);
 (b) pixCloseSafeCompBrick(pixs, pixs, ...);
 (c) pixCloseSafeCompBrick(pixd, pixs, ...);
 (8) The dimensions of the resulting image are determined by pixs.
 (9) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.resetMorphBoundaryCondition(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bc">SYMMETRIC_MORPH_BC, ASYMMETRIC_MORPH_BC</param>
</member><member name="M:LeptonicaSharp.Natives.getMorphBorderPixelColor(System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="type">L_MORPH_DILATE, L_MORPH_ERODE</param>
	<param name="depth">of pix</param>
	<returns>color of border pixels for this operation</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExtractBoundary(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Extracts the fg or bg boundary pixels for each component.
 Components are assumed to end at the boundary of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="type">0 for background pixels; 1 for foreground pixels</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMorphSequenceMasked(System.IntPtr,System.IntPtr,System.String,System.Int32)">
	<summary>
 Notes
 (1) This applies the morph sequence to the image, but only allows
 changes in pixs for pixels under the background of pixm.
 (5) If pixm is NULL, this is just pixMorphSequence().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pixm">1 bpp mask</param>
	<param name="sequence">string specifying sequence of operations</param>
	<param name="dispsep">horizontal separation in pixels between successive displays; use zero to suppress display</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMorphSequenceByComponent(System.IntPtr,System.String,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) See pixMorphSequence() for composing operation sequences.
 (2) This operates separately on each c.c. in the input pix.
 (3) The dilation does NOT increase the c.c. size; it is clipped
 to the size of the original c.c.   This is necessary to
 keep the c.c. independent after the operation.
 (4) You can specify that the width and/or height must equal
 or exceed a minimum size for the operation to take place.
 (5) Use NULL for boxa to avoid returning the boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="sequence">string specifying sequence</param>
	<param name="connectivity">4 or 8</param>
	<param name="minw">minimum width to consider; use 0 or 1 for any width</param>
	<param name="minh">minimum height to consider; use 0 or 1 for any height</param>
	<param name="pboxa">return boxa of c.c. in pixs</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaMorphSequenceByComponent(System.IntPtr,System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixMorphSequence() for composing operation sequences.
 (2) This operates separately on each c.c. in the input pixa.
 (3) You can specify that the width and/or height must equal
 or exceed a minimum size for the operation to take place.
 (4) The input pixa should have a boxa giving the locations
 of the pix components.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">of 1 bpp pix</param>
	<param name="sequence">string specifying sequence</param>
	<param name="minw">minimum width to consider; use 0 or 1 for any width</param>
	<param name="minh">minimum height to consider; use 0 or 1 for any height</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMorphSequenceByRegion(System.IntPtr,System.IntPtr,System.String,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) See pixMorphCompSequence() for composing operation sequences.
 (2) This operates separately on the region in pixs corresponding
 to each c.c. in the mask pixm.  It differs from
 pixMorphSequenceByComponent() in that the latter does not have
 a pixm (mask), but instead operates independently on each
 component in pixs.
 (3) Dilation will NOT increase the region size; the result
 is clipped to the size of the mask region.  This is necessary
 to make regions independent after the operation.
 (4) You can specify that the width and/or height of a region must
 equal or exceed a minimum size for the operation to take place.
 (5) Use NULL for %pboxa to avoid returning the boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pixm">mask specifying regions</param>
	<param name="sequence">string specifying sequence</param>
	<param name="connectivity">4 or 8, used on mask</param>
	<param name="minw">minimum width to consider; use 0 or 1 for any width</param>
	<param name="minh">minimum height to consider; use 0 or 1 for any height</param>
	<param name="pboxa">return boxa of c.c. in pixm</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaMorphSequenceByRegion(System.IntPtr,System.IntPtr,System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixMorphSequence() for composing operation sequences.
 (2) This operates separately on each region in the input pixs
 defined by the components in pixam.
 (3) You can specify that the width and/or height of a mask
 component must equal or exceed a minimum size for the
 operation to take place.
 (4) The input pixam should have a boxa giving the locations
 of the regions in pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pixam">of 1 bpp mask elements</param>
	<param name="sequence">string specifying sequence</param>
	<param name="minw">minimum width to consider; use 0 or 1 for any width</param>
	<param name="minh">minimum height to consider; use 0 or 1 for any height</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixUnionOfMorphOps(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">binary</param>
	<param name="sela"></param>
	<param name="type">L_MORPH_DILATE, etc.</param>
	<returns>pixd union of the specified morphological operation on pixs for each Sel in the Sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixIntersectionOfMorphOps(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">binary</param>
	<param name="sela"></param>
	<param name="type">L_MORPH_DILATE, etc.</param>
	<returns>pixd intersection of the specified morphological operation on pixs for each Sel in the Sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSelectiveConnCompFill(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">binary</param>
	<param name="connectivity">4 or 8</param>
	<param name="minw">minimum width to consider; use 0 or 1 for any width</param>
	<param name="minh">minimum height to consider; use 0 or 1 for any height</param>
	<returns>pix with holes filled in selected c.c., or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRemoveMatchedPattern(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is in-place.
 (2) You can use various functions in selgen to create a Sel
 that is used to generate pixe from pixs.
 (3) This function is applied after pixe has been computed.
 It finds the centroid of each c.c., and subtracts
 (the appropriately dilated version of) pixp, with the center
 of the Sel used to align pixp with pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image, 1 bpp</param>
	<param name="pixp">pattern to be removed from image, 1 bpp</param>
	<param name="pixe">image after erosion by Sel that approximates pixp, 1 bpp</param>
	<param name="x0">center of Sel</param>
	<param name="y0">center of Sel</param>
	<param name="dsize">number of pixels on each side by which pixp is dilated before being subtracted from pixs; valid values are {0, 1, 2, 3, 4}</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDisplayMatchedPattern(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) A 4 bpp colormapped image is generated.
 (2) If scale LT= 1.0, do scale to gray for the output, and threshold
 to nlevels of gray.
 (3) You can use various functions in selgen to create a Sel
 that will generate pixe from pixs.
 (4) This function is applied after pixe has been computed.
 It finds the centroid of each c.c., and colors the output
 pixels using pixp (appropriately aligned) as a stencil.
 Alignment is done using the origin of the Sel and the
 centroid of the eroded image to place the stencil pixp.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image, 1 bpp</param>
	<param name="pixp">pattern to be removed from image, 1 bpp</param>
	<param name="pixe">image after erosion by Sel that approximates pixp, 1 bpp</param>
	<param name="x0">center of Sel</param>
	<param name="y0">center of Sel</param>
	<param name="color">to paint the matched patterns; 0xrrggbb00</param>
	<param name="scale">reduction factor for output pixd</param>
	<param name="nlevels">if scale LT 1.0, threshold to this number of levels</param>
	<returns>pixd 8 bpp, colormapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaExtendByMorph(System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This dilates or erodes every pix in %pixas, iteratively,
 using the input Sel (or, if null, a 2x2 Sel by default),
 and puts the results in %pixad.
 (2) If %niters LT= 0, this is a no-op; it returns a clone of pixas.
 (3) If %include == 1, the output %pixad contains all the pix
 in %pixas.  Otherwise, it doesn't, but pixaJoin() can be
 used later to join pixas with pixad.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="type">L_MORPH_DILATE, L_MORPH_ERODE</param>
	<param name="niters"></param>
	<param name="sel">used for dilation, erosion; uses 2x2 if null</param>
	<param name="include">1 to include a copy of the input pixas in pixad; 0 to omit</param>
	<returns>pixad   with derived pix, using all iterations, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaExtendByScaling(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This scales every pix in %pixas by each factor in %nasc.
 and puts the results in %pixad.
 (2) If %include == 1, the output %pixad contains all the pix
 in %pixas.  Otherwise, it doesn't, but pixaJoin() can be
 used later to join pixas with pixad.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="nasc">numa of scaling factors</param>
	<param name="type">L_HORIZ, L_VERT, L_BOTH_DIRECTIONS</param>
	<param name="include">1 to include a copy of the input pixas in pixad; 0 to omit</param>
	<returns>pixad   with derived pix, using all scalings, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfillMorph(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is in general a very inefficient method for filling
 from a seed into a mask.  Use it for a small number of iterations,
 but if you expect more than a few iterations, use
 pixSeedfillBinary().
 (2) We use a 3x3 brick SEL for 8-cc filling and a 3x3 plus SEL for 4-cc.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">seed</param>
	<param name="pixm">mask</param>
	<param name="maxiters">use 0 to go to completion</param>
	<param name="connectivity">4 or 8</param>
	<returns>pixd after filling into the mask or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRunHistogramMorph(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="runtype">L_RUN_OFF, L_RUN_ON</param>
	<param name="direction">L_HORIZ, L_VERT</param>
	<param name="maxsize">size of largest runlength counted</param>
	<returns>numa of run-lengths</returns>
</member><member name="M:LeptonicaSharp.Natives.pixTophat(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) If hsize = vsize = 1, returns an image with all 0 data.
 (3) The L_TOPHAT_WHITE flag emphasizes small bright regions,
 whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.
 The L_TOPHAT_WHITE tophat can be accomplished by doing a
 L_TOPHAT_BLACK tophat on the inverse, or v.v.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<param name="type">L_TOPHAT_WHITE image - opening L_TOPHAT_BLACK closing - image</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixHDome(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) It is more efficient to use a connectivity of 4 for the fill.
 (2) This fills bumps to some level, and extracts the unfilled
 part of the bump.  To extract the troughs of basins, first
 invert pixs and then apply pixHDome().
 (3) It is useful to compare the HDome operation with the TopHat.
 The latter extracts peaks or valleys that have a width
 not exceeding the size of the structuring element used
 in the opening or closing, rsp.  The height of the peak is
 irrelevant.  By contrast, for the HDome, the gray seedfill
 is used to extract all peaks that have a height not exceeding
 a given value, regardless of their width!
 (4) Slightly more precisely, suppose you set 'height' = 40.
 Then all bumps in pixs with a height greater than or equal
 to 40 become, in pixd, bumps with a max value of exactly 40.
 All shorter bumps have a max value in pixd equal to the height
 of the bump.
 (5) The method the filling mask, pixs, is the image whose peaks
 are to be extracted.  The height of a peak is the distance
 between the top of the peak and the highest "leak" to the
 outside -- think of a sombrero, where the leak occurs
 at the highest point on the rim.
 (a) Generate a seed, pixd, by subtracting some value, p, from
 each pixel in the filling mask, pixs.  The value p is
 the 'height' input to this function.
 (b) Fill in pixd starting with this seed, clipping by pixs,
 in the way described in seedfillGrayLow().  The filling
 stops before the peaks in pixs are filled.
 For peaks that have a height GT p, pixd is filled to
 the level equal to the (top-of-the-peak - p).
 For peaks of height LT p, the peak is left unfilled
 from its highest saddle point (the leak to the outside).
 (c) Subtract the filled seed (pixd) from the filling mask (pixs).
 Note that in this procedure, everything is done starting
 with the filling mask, pixs.
 (6) For segmentation, the resulting image, pixd, can be thresholded
 and used as a seed for another filling operation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, filling mask</param>
	<param name="height">of seed below the filling maskhdome; must be GT= 0</param>
	<param name="connectivity">4 or 8</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFastTophat(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Don't be fooled. This is NOT a tophat.  It is a tophat-like
 operation, where the result is similar to what you'd get
 if you used an erosion instead of an opening, or a dilation
 instead of a closing.
 (2) Instead of opening or closing at full resolution, it does
 a fast downscale/minmax operation, then a quick small smoothing
 at low res, a replicative expansion of the "background"
 to full res, and finally a removal of the background level
 from the input image.  The smoothing step may not be important.
 (3) It does not remove noise as well as a tophat, but it is
 5 to 10 times faster.
 If you need the preciseness of the tophat, don't use this.
 (4) The L_TOPHAT_WHITE flag emphasizes small bright regions,
 whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="xsize">width of max/min op, smoothing; any integer GT= 1</param>
	<param name="ysize">height of max/min op, smoothing; any integer GT= 1</param>
	<param name="type">L_TOPHAT_WHITE image - min L_TOPHAT_BLACK max - image</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMorphGradient(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<param name="smoothing">half-width of convolution smoothing filter. The width is (2  smoothing + 1, so 0 is no-op.</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaCentroids(System.IntPtr)">
	<summary>
 Notes
 (1) An error message is returned if any pix has something other
 than 1 bpp or 8 bpp depth, and the centroid from that pix
 is saved as (0, 0).
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of components 1 or 8 bpp</param>
	<returns>pta of centroids relative to the UL corner of each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCentroid(System.IntPtr,System.Int32[],System.Int32[],System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) Any table not passed in will be made internally and destroyed
 after use.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 or 8 bpp</param>
	<param name="centtab">table for finding centroids; can be null</param>
	<param name="sumtab">table for finding pixel sums; can be null</param>
	<param name="pxave">coordinates of centroid, relative to the UL corner of the pix</param>
	<param name="pyave">coordinates of centroid, relative to the UL corner of the pix</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDilateBrickDwa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) These implement 2D brick Sels, using linear Sels generated
 with selaAddBasic().
 (2) A brick Sel has hits for all elements.
 (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (4) Do separably if both hsize and vsize are GT 1.
 (5) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (6) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (7) For clarity, if the case is known, use these patterns
 (a) pixd = pixDilateBrickDwa(NULL, pixs, ...);
 (b) pixDilateBrickDwa(pixs, pixs, ...);
 (c) pixDilateBrickDwa(pixd, pixs, ...);
 (8) The size of pixd is determined by pixs.
 (9) If either linear Sel is not found, this calls
 the appropriate decomposible function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixErodeBrickDwa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) These implement 2D brick Sels, using linear Sels generated
 with selaAddBasic().
 (2) A brick Sel has hits for all elements.
 (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (4) Do separably if both hsize and vsize are GT 1.
 (5) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (6) Note that we must always set or clear the border pixels
 before each operation, depending on the the b.c.
 (symmetric or asymmetric).
 (7) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (8) For clarity, if the case is known, use these patterns
 (a) pixd = pixErodeBrickDwa(NULL, pixs, ...);
 (b) pixErodeBrickDwa(pixs, pixs, ...);
 (c) pixErodeBrickDwa(pixd, pixs, ...);
 (9) The size of the result is determined by pixs.
 (10) If either linear Sel is not found, this calls
 the appropriate decomposible function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOpenBrickDwa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) These implement 2D brick Sels, using linear Sels generated
 with selaAddBasic().
 (2) A brick Sel has hits for all elements.
 (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (4) Do separably if both hsize and vsize are GT 1.
 (5) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (6) Note that we must always set or clear the border pixels
 before each operation, depending on the the b.c.
 (symmetric or asymmetric).
 (7) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (8) For clarity, if the case is known, use these patterns
 (a) pixd = pixOpenBrickDwa(NULL, pixs, ...);
 (b) pixOpenBrickDwa(pixs, pixs, ...);
 (c) pixOpenBrickDwa(pixd, pixs, ...);
 (9) The size of the result is determined by pixs.
 (10) If either linear Sel is not found, this calls
 the appropriate decomposible function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCloseBrickDwa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a 'safe' closing; we add an extra border of 32 OFF
 pixels for the standard asymmetric b.c.
 (2) These implement 2D brick Sels, using linear Sels generated
 with selaAddBasic().
 (3) A brick Sel has hits for all elements.
 (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (5) Do separably if both hsize and vsize are GT 1.
 (6) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (7) Note that we must always set or clear the border pixels
 before each operation, depending on the the b.c.
 (symmetric or asymmetric).
 (8) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (9) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseBrickDwa(NULL, pixs, ...);
 (b) pixCloseBrickDwa(pixs, pixs, ...);
 (c) pixCloseBrickDwa(pixd, pixs, ...);
 (10) The size of the result is determined by pixs.
 (11) If either linear Sel is not found, this calls
 the appropriate decomposible function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDilateCompBrickDwa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) These implement a separable composite dilation with 2D brick Sels.
 (2) For efficiency, it may decompose each linear morphological
 operation into two (brick + comb).
 (3) A brick Sel has hits for all elements.
 (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (5) Do separably if both hsize and vsize are GT 1.
 (6) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (7) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (8) For clarity, if the case is known, use these patterns
 (a) pixd = pixDilateCompBrickDwa(NULL, pixs, ...);
 (b) pixDilateCompBrickDwa(pixs, pixs, ...);
 (c) pixDilateCompBrickDwa(pixd, pixs, ...);
 (9) The size of pixd is determined by pixs.
 (10) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixErodeCompBrickDwa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) These implement a separable composite erosion with 2D brick Sels.
 (2) For efficiency, it may decompose each linear morphological
 operation into two (brick + comb).
 (3) A brick Sel has hits for all elements.
 (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (5) Do separably if both hsize and vsize are GT 1.
 (6) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (7) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (8) For clarity, if the case is known, use these patterns
 (a) pixd = pixErodeCompBrickDwa(NULL, pixs, ...);
 (b) pixErodeCompBrickDwa(pixs, pixs, ...);
 (c) pixErodeCompBrickDwa(pixd, pixs, ...);
 (9) The size of pixd is determined by pixs.
 (10) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOpenCompBrickDwa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) These implement a separable composite opening with 2D brick Sels.
 (2) For efficiency, it may decompose each linear morphological
 operation into two (brick + comb).
 (3) A brick Sel has hits for all elements.
 (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (5) Do separably if both hsize and vsize are GT 1.
 (6) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (7) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (8) For clarity, if the case is known, use these patterns
 (a) pixd = pixOpenCompBrickDwa(NULL, pixs, ...);
 (b) pixOpenCompBrickDwa(pixs, pixs, ...);
 (c) pixOpenCompBrickDwa(pixd, pixs, ...);
 (9) The size of pixd is determined by pixs.
 (10) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCloseCompBrickDwa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This implements a separable composite safe closing with 2D
 brick Sels.
 (2) For efficiency, it may decompose each linear morphological
 operation into two (brick + comb).
 (3) A brick Sel has hits for all elements.
 (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (5) Do separably if both hsize and vsize are GT 1.
 (6) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (7) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (8) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseCompBrickDwa(NULL, pixs, ...);
 (b) pixCloseCompBrickDwa(pixs, pixs, ...);
 (c) pixCloseCompBrickDwa(pixd, pixs, ...);
 (9) The size of pixd is determined by pixs.
 (10) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDilateCompBrickExtendDwa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Ankur Jain suggested and implemented extending the composite
 DWA operations beyond the 63 pixel limit.  This is a
 simplified and approximate implementation of the extension.
 This allows arbitrary Dwa morph operations using brick Sels,
 by decomposing the horizontal and vertical dilations into
 a sequence of 63-element dilations plus a dilation of size
 between 3 and 62.
 (2) The 63-element dilations are exact, whereas the extra dilation
 is approximate, because the underlying decomposition is
 in pixDilateCompBrickDwa().  See there for further details.
 (3) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (4) There is no need to call this directly  pixDilateCompBrickDwa()
 calls this function if either brick dimension exceeds 63.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixErodeCompBrickExtendDwa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixDilateCompBrickExtendDwa() for usage.
 (2) There is no need to call this directly  pixErodeCompBrickDwa()
 calls this function if either brick dimension exceeds 63.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOpenCompBrickExtendDwa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd 1 There are three cases a) pixd == null   (result into new pixd b) pixd == pixs   (in-place; writes result back to pixs c) pixd != pixs   (puts result into existing pixd 2) There is no need to call this directly  pixOpenCompBrickDwa( calls this function if either brick dimension exceeds 63.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCloseCompBrickExtendDwa(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd 1 There are three cases a) pixd == null   (result into new pixd b) pixd == pixs   (in-place; writes result back to pixs c) pixd != pixs   (puts result into existing pixd 2) There is no need to call this directly  pixCloseCompBrickDwa( calls this function if either brick dimension exceeds 63.</returns>
</member><member name="M:LeptonicaSharp.Natives.getExtendedCompositeParameters(System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The DWA implementation allows Sels to be used with hits
 up to 31 pixels from the origin, either horizontally or
 vertically.  Larger Sels can be used if decomposed into
 a set of operations with Sels not exceeding 63 pixels
 in either width or height (and with the origin as close
 to the center of the Sel as possible).
 (2) This returns the decomposition of a linear Sel of length
 %size into a set of %n Sels of length 63 plus an extra
 Sel of length %extra.
 (3) For notation, let w == %size, n == %n, and e == %extra.
 We have 1 LT e LT 63.
 Then if w LT 64, we have n = 0 and e = w.
 The general formula for w GT 63 is
 w = 63 + (n - 1)  62 + (e - 1)
 Where did this come from?  Each successive convolution with
 a Sel of length L adds a total length (L - 1) to w.
 This accounts for using 62 for each additional Sel of size 63,
 and using (e - 1) for the additional Sel of size e.
 Solving for n and e for w GT 63
 n = 1 + Int((w - 63) / 62)
 e = w - 63 - (n - 1)  62 + 1
 The extra part is decomposed into two factors f1 and f2,
 and the actual size of the extra part is
 e' = f1  f2
 Then the actual width is
 w' = 63 + (n - 1)  62 + f1  f2 - 1
 </summary>
	<remarks>
	</remarks>
	<param name="size">of linear Sel</param>
	<param name="pn">number of 63 wide convolutions</param>
	<param name="pextra">size of extra Sel</param>
	<param name="pactualsize">actual size used in operation</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMorphSequence(System.IntPtr,System.String,System.Int32)">
	<summary>
 Notes
 (1) This does rasterop morphology on binary images.
 (2) This runs a pipeline of operations; no branching is allowed.
 (3) This only uses brick Sels, which are created on the fly.
 In the future this will be generalized to extract Sels from
 a Sela by name.
 (4) A new image is always produced; the input image is not changed.
 (5) This contains an interpreter, allowing sequences to be
 generated and run.
 (6) The format of the sequence string is defined below.
 (7) In addition to morphological operations, rank order reduction
 and replicated expansion allow operations to take place
 downscaled by a power of 2.
 (8) Intermediate results can optionally be displayed.
 (9) Thanks to Dar-Shyang Lee, who had the idea for this and
 built the first implementation.
 (10) The sequence string is formatted as follows
 ~ An arbitrary number of operations,  each separated
 by a '+' character.  White space is ignored.
 ~ Each operation begins with a case-independent character
 specifying the operation
 d or D  (dilation)
 e or E  (erosion)
 o or O  (opening)
 c or C  (closing)
 r or R  (rank binary reduction)
 x or X  (replicative binary expansion)
 b or B  (add a border of 0 pixels of this size)
 ~ The args to the morphological operations are bricks of hits,
 and are formatted as a.b, where a and b are horizontal and
 vertical dimensions, rsp.
 ~ The args to the reduction are a sequence of up to 4 integers,
 each from 1 to 4.
 ~ The arg to the expansion is a power of two, in the set
 {2, 4, 8, 16}.
 (11) An example valid sequence is
 "b32 + o1.3 + C3.1 + r23 + e2.2 + D3.2 + X4"
 In this example, the following operation sequence is carried out
 b32 Add a 32 pixel border around the input image
 o1.3 Opening with vert sel of length 3 (e.g., 1 x 3)
 C3.1 Closing with horiz sel of length 3  (e.g., 3 x 1)
 r23 Two successive 2x2 reductions with rank 2 in the first
 and rank 3 in the second.  The result is a 4x reduced pix.
 e2.2 Erosion with a 2x2 sel (origin will be at x,y 0,0)
 d3.2 Dilation with a 3x2 sel (origin will be at x,y 1,0)
 X4 4x replicative expansion, back to original resolution
 (12) The safe closing is used.  However, if you implement a
 closing as separable dilations followed by separable erosions,
 it will not be safe.  For that situation, you need to add
 a sufficiently large border as the first operation in
 the sequence.  This will be removed automatically at the
 end.  There are two cautions
 ~ When computing what is sufficient, remember that if
 reductions are carried out, the border is also reduced.
 ~ The border is removed at the end, so if a border is
 added at the beginning, the result must be at the
 same resolution as the input!
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="sequence">string specifying sequence</param>
	<param name="dispsep">controls debug display of each result in the sequence 0 no output GT 0 gives horizontal separation in pixels between successive displays LT 0 pdf output; abs(dispsep) is used for naming</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMorphCompSequence(System.IntPtr,System.String,System.Int32)">
	<summary>
 Notes
 (1) This does rasterop morphology on binary images, using composite
 operations for extra speed on large Sels.
 (2) Safe closing is used atomically.  However, if you implement a
 closing as a sequence with a dilation followed by an
 erosion, it will not be safe, and to ensure that you have
 no boundary effects you must add a border in advance and
 remove it at the end.
 (3) For other usage details, see the notes for pixMorphSequence().
 (4) The sequence string is formatted as follows
 ~ An arbitrary number of operations,  each separated
 by a '+' character.  White space is ignored.
 ~ Each operation begins with a case-independent character
 specifying the operation
 d or D  (dilation)
 e or E  (erosion)
 o or O  (opening)
 c or C  (closing)
 r or R  (rank binary reduction)
 x or X  (replicative binary expansion)
 b or B  (add a border of 0 pixels of this size)
 ~ The args to the morphological operations are bricks of hits,
 and are formatted as a.b, where a and b are horizontal and
 vertical dimensions, rsp.
 ~ The args to the reduction are a sequence of up to 4 integers,
 each from 1 to 4.
 ~ The arg to the expansion is a power of two, in the set
 {2, 4, 8, 16}.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="sequence">string specifying sequence</param>
	<param name="dispsep">controls debug display of each result in the sequence 0 no output GT 0 gives horizontal separation in pixels between successive displays LT 0 pdf output; abs(dispsep) is used for naming</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMorphSequenceDwa(System.IntPtr,System.String,System.Int32)">
	<summary>
 Notes
 (1) This does dwa morphology on binary images.
 (2) This runs a pipeline of operations; no branching is allowed.
 (3) This only uses brick Sels that have been pre-compiled with
 dwa code.
 (4) A new image is always produced; the input image is not changed.
 (5) This contains an interpreter, allowing sequences to be
 generated and run.
 (6) See pixMorphSequence() for further information about usage.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="sequence">string specifying sequence</param>
	<param name="dispsep">controls debug display of each result in the sequence 0 no output GT 0 gives horizontal separation in pixels between successive displays LT 0 pdf output; abs(dispsep) is used for naming</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMorphCompSequenceDwa(System.IntPtr,System.String,System.Int32)">
	<summary>
 Notes
 (1) This does dwa morphology on binary images, using brick Sels.
 (2) This runs a pipeline of operations; no branching is allowed.
 (3) It implements all brick Sels that have dimensions up to 63
 on each side, using a composite (linear + comb) when useful.
 (4) A new image is always produced; the input image is not changed.
 (5) This contains an interpreter, allowing sequences to be
 generated and run.
 (6) See pixMorphSequence() for further information about usage.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="sequence">string specifying sequence</param>
	<param name="dispsep">controls debug display of each result in the sequence 0 no output GT 0 gives horizontal separation in pixels between successive displays LT 0 pdf output; abs(dispsep) is used for naming</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.morphSequenceVerify(System.IntPtr)">
	<summary>
 Notes
 (1) This does verification of valid binary morphological
 operation sequences.
 (2) See pixMorphSequence() for notes on valid operations
 in the sequence.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of operation sequence</param>
	<returns>TRUE if valid; FALSE otherwise or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGrayMorphSequence(System.IntPtr,System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This works on 8 bpp grayscale images.
 (2) This runs a pipeline of operations; no branching is allowed.
 (3) This only uses brick SELs.
 (4) A new image is always produced; the input image is not changed.
 (5) This contains an interpreter, allowing sequences to be
 generated and run.
 (6) The format of the sequence string is defined below.
 (7) In addition to morphological operations, the composite
 morph/subtract tophat can be performed.
 (8) Sel sizes (width, height) must each be odd numbers.
 (9) Intermediate results can optionally be displayed
 (10) The sequence string is formatted as follows
 ~ An arbitrary number of operations,  each separated
 by a '+' character.  White space is ignored.
 ~ Each operation begins with a case-independent character
 specifying the operation
 d or D  (dilation)
 e or E  (erosion)
 o or O  (opening)
 c or C  (closing)
 t or T  (tophat)
 ~ The args to the morphological operations are bricks of hits,
 and are formatted as a.b, where a and b are horizontal and
 vertical dimensions, rsp. (each must be an odd number)
 ~ The args to the tophat are w or W (for white tophat)
 or b or B (for black tophat), followed by a.b as for
 the dilation, erosion, opening and closing.
 Example valid sequences are
 "c5.3 + o7.5"
 "c9.9 + tw9.9"
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="sequence">string specifying sequence</param>
	<param name="dispsep">controls debug display of each result in the sequence 0 no output GT 0 gives horizontal separation in pixels between successive displays LT 0 pdf output; abs(dispsep) is used for naming</param>
	<param name="dispy">if dispsep GT 0, this gives the y-value of the UL corner for display; otherwise it is ignored</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorMorphSequence(System.IntPtr,System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This works on 32 bpp rgb images.
 (2) Each component is processed separately.
 (3) This runs a pipeline of operations; no branching is allowed.
 (4) This only uses brick SELs.
 (5) A new image is always produced; the input image is not changed.
 (6) This contains an interpreter, allowing sequences to be
 generated and run.
 (7) Sel sizes (width, height) must each be odd numbers.
 (8) The format of the sequence string is defined below.
 (9) Intermediate results can optionally be displayed.
 (10) The sequence string is formatted as follows
 ~ An arbitrary number of operations,  each separated
 by a '+' character.  White space is ignored.
 ~ Each operation begins with a case-independent character
 specifying the operation
 d or D  (dilation)
 e or E  (erosion)
 o or O  (opening)
 c or C  (closing)
 ~ The args to the morphological operations are bricks of hits,
 and are formatted as a.b, where a and b are horizontal and
 vertical dimensions, rsp. (each must be an odd number)
 Example valid sequences are
 "c5.3 + o7.5"
 "D9.1"
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="sequence">string specifying sequence</param>
	<param name="dispsep">controls debug display of each result in the sequence 0 no output GT 0 gives horizontal separation in pixels between successive displays LT 0 pdf output; abs(dispsep) is used for naming</param>
	<param name="dispy">if dispsep GT 0, this gives the y-value of the UL corner for display; otherwise it is ignored</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of number array to be alloc'd 0 for default</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaCreateFromIArray(System.Int32[],System.Int32)">
	<summary>
 Notes
 (1) We can't insert this int array into the numa, because a numa
 takes a float array.  So this just copies the data from the
 input array into the numa.  The input array continues to be
 owned by the caller.
 </summary>
	<remarks>
	</remarks>
	<param name="iarray">integer</param>
	<param name="size">of the array</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaCreateFromFArray(System.Single[],System.Int32,System.Int32)">
	<summary>
 Notes
 (1) With L_INSERT, ownership of the input array is transferred
 to the returned numa, and all %size elements are considered
 to be valid.
 </summary>
	<remarks>
	</remarks>
	<param name="farray">float</param>
	<param name="size">of the array</param>
	<param name="copyflag">L_INSERT or L_COPY</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaCreateFromString(System.String)">
	<summary>
 Notes
 (1) The numbers can be ints or floats; they will be interpreted
 and stored as floats.  To use them as integers (e.g., for
 indexing into arrays), use numaGetIValue(...).
 </summary>
	<remarks>
	</remarks>
	<param name="str">string of comma-separated numbers</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the numa.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pna">to be nulled if it exists</param>
</member><member name="M:LeptonicaSharp.Natives.numaCopy(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>copy of numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaClone(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>ptr to same numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaEmpty(System.IntPtr)">
	<summary>
 Notes
 (1) This does not change the allocation of the array.
 It just clears the number of stored numbers, so that
 the array appears to be empty.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaAddNumber(System.IntPtr,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="val">float or int to be added; stored as a float</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaInsertNumber(System.IntPtr,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This shifts na[i] --GT na[i + 1] for all i GT= index,
 and then inserts val as na[index].
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">location in na to insert new value</param>
	<param name="val">float32 or integer to be added</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaRemoveNumber(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This shifts na[i] --GT na[i - 1] for all i GT index.
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">element to be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaReplaceNumber(System.IntPtr,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">element to be replaced</param>
	<param name="val">new value to replace old one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>count, or 0 if no numbers or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSetCount(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If newcount LT= na-GTnalloc, this resets na-GTn.
 Using newcount = 0 is equivalent to numaEmpty().
 (2) If newcount GT na-GTnalloc, this causes a realloc
 to a size na-GTnalloc = newcount.
 (3) All the previously unused values in na are set to 0.0.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="newcount"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetFValue(System.IntPtr,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) Caller may need to check the function return value to
 decide if a 0.0 in the returned ival is valid.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">into numa</param>
	<param name="pval">float value; 0.0 on error</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetIValue(System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Caller may need to check the function return value to
 decide if a 0 in the returned ival is valid.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">into numa</param>
	<param name="pival">integer value; 0 on error</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSetValue(System.IntPtr,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">to element to be set</param>
	<param name="val">to set element</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaShiftValue(System.IntPtr,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">to element to change relative to the current value</param>
	<param name="diff">increment if diff GT 0 or decrement if diff LT 0</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetIArray(System.IntPtr)">
	<summary>
 Notes
 (1) A copy of the array is always made, because we need to
 generate an integer array from the bare float array.
 The caller is responsible for freeing the array.
 (2) The array size is determined by the number of stored numbers,
 not by the size of the allocated array in the Numa.
 (3) This function is provided to simplify calculations
 using the bare internal array, rather than continually
 calling accessors on the numa.  It is typically used
 on an array of size 256.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>a copy of the bare internal array, integerized by rounding, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetFArray(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If copyflag == L_COPY, it makes a copy which the caller
 is responsible for freeing.  Otherwise, it operates
 directly on the bare array of the numa.
 (2) Very important for L_NOCOPY, any writes to the array
 will be in the numa.  Do not write beyond the size of
 the count field, because it will not be accessible
 from the numa!  If necessary, be sure to set the count
 field to a larger number (such as the alloc size)
 BEFORE calling this function.  Creating with numaMakeConstant()
 is another way to insure full initialization.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="copyflag">L_NOCOPY or L_COPY</param>
	<returns>either the bare internal array or a copy of it, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetRefcount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>refcount, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaChangeRefcount(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="delta">change to be applied</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetParameters(System.IntPtr,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="pstartx">startx</param>
	<param name="pdelx">delx</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSetParameters(System.IntPtr,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="startx">x value corresponding to na[0]</param>
	<param name="delx">difference in x values for the situation where the elements of na correspond to the evaulation of a function at equal intervals of size %delx</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaCopyParameters(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nad">destination Numa</param>
	<param name="nas">source Numa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaConvertToSarray(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For integer conversion, size2 is ignored.
 For float conversion, addzeroes is ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="size1">size of conversion field</param>
	<param name="size2">for float conversion size of field to the right of the decimal point</param>
	<param name="addzeros">for integer conversion to add lead zeros</param>
	<param name="type">L_INTEGER_VALUE, L_FLOAT_VALUE</param>
	<returns>a sarray of the float values converted to strings representing either integer or float values; or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.numaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">numa serialization; in ascii</param>
	<param name="size">of data; can use strlen to get it</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaWriteDebug(System.String,System.IntPtr)">
	<summary>
 Notes
 (1) Debug version, intended for use in the library when writing
 to files in a temp directory with names that are compiled in.
 This is used instead of numaWrite() for all such library calls.
 (2) The global variable LeptDebugOK defaults to 0, and can be set
 or cleared by the function setLeptDebugOK().
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="na"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="na"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="na"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a numa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized numa; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="na"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of numa ptr array to be alloc'd 0 for default</param>
	<returns>naa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaCreateFull(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This allocates numaa and fills the array with allocated numas.
 In use, after calling this function, use
 numaaAddNumber(naa, index, val);
 to add val to the index-th numa in naa.
 </summary>
	<remarks>
	</remarks>
	<param name="nptr">size of numa ptr array to be alloc'd</param>
	<param name="n">size of individual numa arrays to be alloc'd 0 for default</param>
	<returns>naa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaTruncate(System.IntPtr)">
	<summary>
 Notes
 (1) This identifies the largest index containing a numa that
 has any numbers within it, destroys all numa beyond that
 index, and resets the count.
 </summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pnaa">to be nulled if it exists</param>
</member><member name="M:LeptonicaSharp.Natives.numaaAddNuma(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<param name="na">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<returns>count number of numa, or 0 if no numa or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaGetNumaCount(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<param name="index">of numa in naa</param>
	<returns>count of numbers in the referenced numa, or 0 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaGetNumberCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<returns>count total number of numbers in the numaa, or 0 if no numbers or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaGetPtrArray(System.IntPtr)">
	<summary>
 Notes
 (1) This function is convenient for doing direct manipulation on
 a fixed size array of Numas.  To do this, it sets the count
 to the full size of the allocated array of Numa ptrs.
 The originating Numaa owns this array DO NOT free it!
 (2) Intended usage
 Numaa naa = numaaCreate(n);
 Numa array = numaaGetPtrArray(naa);
 ...  [manipulate Numas directly on the array]
 numaaDestroy(naa);
 (3) Cautions
 ~ Do not free this array; it is owned by tne Numaa.
 ~ Do not call any functions on the Numaa, other than
 numaaDestroy() when you're finished with the array.
 Adding a Numa will force a resize, destroying the ptr array.
 ~ Do not address the array outside its allocated size.
 With the bare array, there are no protections.  If the
 allocated size is n, array[n] is an error.
 </summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<returns>the internal array of ptrs to Numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaGetNuma(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<param name="index">to the index-th numa</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaReplaceNuma(System.IntPtr,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) Any existing numa is destroyed, and the input one
 is inserted in its place.
 (2) If the index is invalid, return 1 (error)
 </summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<param name="index">to the index-th numa</param>
	<param name="na">insert and replace any existing one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaGetValue(System.IntPtr,System.Int32,System.Int32,System.Single[]@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<param name="i">index of numa within numaa</param>
	<param name="j">index into numa</param>
	<param name="pfval">float value</param>
	<param name="pival">int value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaAddNumber(System.IntPtr,System.Int32,System.Single)">
	<summary>
 Notes
 (1) Adds to an existing numa only.
 </summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<param name="index">of numa within numaa</param>
	<param name="val">float or int to be added; stored as a float</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>naa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>naa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">numaa serialization; in ascii</param>
	<param name="size">of data; can use strlen to get it</param>
	<returns>naa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="naa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="naa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a numaa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized numaa; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="naa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaArithOp(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The sizes of na1 and na2 must be equal.
 (2) nad can only null or equal to na1.
 (3) To add a constant to a numa, or to multipy a numa by
 a constant, use numaTransform().
 </summary>
	<remarks>
	</remarks>
	<param name="nad">can be null or equal to na1 (in-place</param>
	<param name="na1"></param>
	<param name="na2"></param>
	<param name="op">L_ARITH_ADD, L_ARITH_SUBTRACT, L_ARITH_MULTIPLY, L_ARITH_DIVIDE</param>
	<returns>nad always operation applied to na1 and na2</returns>
</member><member name="M:LeptonicaSharp.Natives.numaLogicalOp(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The sizes of na1 and na2 must be equal.
 (2) nad can only be null or equal to na1.
 (3) This is intended for use with indicator arrays (0s and 1s).
 Input data is extracted as integers (0 == false, anything
 else == true); output results are 0 and 1.
 (4) L_SUBTRACTION is subtraction of val2 from val1.  For bit logical
 arithmetic this is (val1  ~val2), but because these values
 are integers, we use (val1  !val2).
 </summary>
	<remarks>
	</remarks>
	<param name="nad">can be null or equal to na1 (in-place</param>
	<param name="na1"></param>
	<param name="na2"></param>
	<param name="op">L_UNION, L_INTERSECTION, L_SUBTRACTION, L_EXCLUSIVE_OR</param>
	<returns>nad always operation applied to na1 and na2</returns>
</member><member name="M:LeptonicaSharp.Natives.numaInvert(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This is intended for use with indicator arrays (0s and 1s).
 It gives a boolean-type output, taking the input as
 an integer and inverting it
 0  --GT  1
 anything else  --GT   0
 </summary>
	<remarks>
	</remarks>
	<param name="nad">can be null or equal to nas (in-place</param>
	<param name="nas"></param>
	<returns>nad always 'inverts' nas</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSimilar(System.IntPtr,System.IntPtr,System.Single,System.Int32@)">
	<summary>
 Notes
 (1) Float values can differ slightly due to roundoff and
 accumulated errors.  Using %maxdiff GT 0.0 allows similar
 arrays to be identified.
 </summary>
	<remarks>
	</remarks>
	<param name="na1"></param>
	<param name="na2"></param>
	<param name="maxdiff">use 0.0 for exact equality</param>
	<param name="psimilar">1 if similar; 0 if different</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaAddToNumber(System.IntPtr,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This is useful for accumulating sums, regardless of the index
 order in which the values are made available.
 (2) Before use, the numa has to be filled up to %index.  This would
 typically be used by creating the numa with the full sized
 array, initialized to 0.0, using numaMakeConstant().
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="index">element to be changed</param>
	<param name="val">new value to be added</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetMin(System.IntPtr,System.Single[]@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pminval">min value</param>
	<param name="piminloc">index of min location</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetMax(System.IntPtr,System.Single[]@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pmaxval">max value</param>
	<param name="pimaxloc">index of max location</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetSum(System.IntPtr,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="psum">sum of values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetPartialSums(System.IntPtr)">
	<summary>
 Notes
 (1) nasum[i] is the sum for all j LT= i of na[j].
 So nasum[0] = na[0].
 (2) If you want to generate a rank function, where rank[0] - 0.0,
 insert a 0.0 at the beginning of the nasum array.
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<returns>nasum, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetSumOnInterval(System.IntPtr,System.Int32,System.Int32,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="first">beginning index</param>
	<param name="last">final index</param>
	<param name="psum">sum of values in the index interval range</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaHasOnlyIntegers(System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Set %maxsamples == 0 to check every integer in na.  Otherwise,
 this samples no more than %maxsamples.
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="maxsamples">maximum number of samples to check</param>
	<param name="pallints">1 if all sampled values are ints; else 0</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSubsample(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="subfactor">subsample factor, GT= 1</param>
	<returns>nad evenly sampled values from nas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaMakeDelta(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<returns>numa of difference values val[i+1] - val[i], or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaMakeSequence(System.Single,System.Single,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="startval"></param>
	<param name="increment"></param>
	<param name="size">of sequence</param>
	<returns>numa of sequence of evenly spaced values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaMakeConstant(System.Single,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="val"></param>
	<param name="size">of numa</param>
	<returns>numa of given size with all entries equal to 'val', or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaMakeAbsValue(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nad">for new array, or the same as nas for inplace</param>
	<param name="nas">input numa</param>
	<returns>nad with all numbers being the absval of the input, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaAddBorder(System.IntPtr,System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="left">number of elements to add on each side</param>
	<param name="right">number of elements to add on each side</param>
	<param name="val">initialize border elements</param>
	<returns>nad with added elements at left and right, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaAddSpecifiedBorder(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="left">number of elements to add on each side</param>
	<param name="right">number of elements to add on each side</param>
	<param name="type">L_CONTINUED_BORDER, L_MIRRORED_BORDER</param>
	<returns>nad with added elements at left and right, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaRemoveBorder(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="left">number of elements to remove from each side</param>
	<param name="right">number of elements to remove from each side</param>
	<returns>nad with removed elements at left and right, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaCountNonzeroRuns(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">e.g., of pixel counts in rows or columns</param>
	<param name="pcount">number of nonzero runs</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetNonzeroRange(System.IntPtr,System.Single,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="eps">largest value considered to be zero</param>
	<param name="pfirst">interval of array indices where values are nonzero</param>
	<param name="plast">interval of array indices where values are nonzero</param>
	<returns>0 if OK, 1 on error or if no nonzero range is found.</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetCountRelativeToZero(System.IntPtr,System.Int32,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="type">L_LESS_THAN_ZERO, L_EQUAL_TO_ZERO, L_GREATER_THAN_ZERO</param>
	<param name="pcount">count of values of given type</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaClipToInterval(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 If you want the indices of the array values to be unchanged,
 use first = 0.
 Usage
 This is useful to clip a histogram that has a few nonzero
 values to its nonzero range.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="first">clipping interval</param>
	<param name="last">clipping interval</param>
	<returns>numa with the same values as the input, but clipped to the specified interval</returns>
</member><member name="M:LeptonicaSharp.Natives.numaMakeThresholdIndicator(System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) For each element in nas, if the constraint given by 'type'
 correctly specifies its relation to thresh, a value of 1
 is recorded in nad.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<param name="thresh">threshold value</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.numaUniformSampling(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This resamples the values in the array, using %nsamp
 equal divisions.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<param name="nsamp">number of samples</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.numaReverse(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Usage
 numaReverse(nas, nas);   // in-place
 nad = numaReverse(NULL, nas);  // makes a new one
 </summary>
	<remarks>
	</remarks>
	<param name="nad">can be null or equal to nas</param>
	<param name="nas">input numa</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.numaLowPassIntervals(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) For each interval where the value is less than a specified
 fraction of the maximum, this records the left and right "x"
 value.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<param name="thresh">threshold fraction of max; in [0.0 ... 1.0]</param>
	<param name="maxn">for normalizing; set maxn = 0.0 to use the max in nas</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.numaThresholdEdges(System.IntPtr,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) For each edge interval, where where the value is less
 than %thresh1 on one side, greater than %thresh2 on
 the other, and between these thresholds throughout the
 interval, this records a triplet of values the
 'left' and 'right' edges, and either +1 or -1, depending
 on whether the edge is rising or falling.
 (2) No assumption is made about the value outside the array,
 so if the value at the array edge is between the threshold
 values, it is not considered part of an edge.  We start
 looking for edge intervals only after leaving the thresholded
 band.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<param name="thresh1">low threshold as fraction of max; in [0.0 ... 1.0]</param>
	<param name="thresh2">high threshold as fraction of max; in [0.0 ... 1.0]</param>
	<param name="maxn">for normalizing; set maxn = 0.0 to use the max in nas</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetSpanValues(System.IntPtr,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">numa that is output of numaLowPassIntervals()</param>
	<param name="span">span number, zero-based</param>
	<param name="pstart">location of start of transition</param>
	<param name="pend">location of end of transition</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetEdgeValues(System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">numa that is output of numaThresholdEdges()</param>
	<param name="edge">edge number, zero-based</param>
	<param name="pstart">location of start of transition</param>
	<param name="pend">location of end of transition</param>
	<param name="psign">transition sign +1 is rising, -1 is falling</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.numaInterpolateEqxVal(System.Single,System.Single,System.IntPtr,System.Int32,System.Single,System.Single[]@)">
	<summary>
 Notes
 (1) Considering nay as a function of x, the x values
 are equally spaced
 (2) Caller should check for valid return.
 For linear Lagrangian interpolation (through 2 data pts)
 y(x) = y1(x-x2)/(x1-x2) + y2(x-x1)/(x2-x1)
 For quadratic Lagrangian interpolation (through 3 data pts)
 y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +
 y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +
 y3(x-x1)(x-x2)/((x3-x1)(x3-x2))
 </summary>
	<remarks>
	</remarks>
	<param name="startx">xval corresponding to first element in array</param>
	<param name="deltax">x increment between array elements</param>
	<param name="nay">numa of ordinate values, assumed equally spaced</param>
	<param name="type">L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
	<param name="xval"></param>
	<param name="pyval">interpolated value</param>
	<returns>0 if OK, 1 on error e.g., if xval is outside range</returns>
</member><member name="M:LeptonicaSharp.Natives.numaInterpolateArbxVal(System.IntPtr,System.IntPtr,System.Int32,System.Single,System.Single[]@)">
	<summary>
 Notes
 (1) The values in nax must be sorted in increasing order.
 If, additionally, they are equally spaced, you can use
 numaInterpolateEqxVal().
 (2) Caller should check for valid return.
 (3) Uses lagrangian interpolation.  See numaInterpolateEqxVal()
 for formulas.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values</param>
	<param name="nay">numa of ordinate values, corresponding to nax</param>
	<param name="type">L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
	<param name="xval"></param>
	<param name="pyval">interpolated value</param>
	<returns>0 if OK, 1 on error e.g., if xval is outside range</returns>
</member><member name="M:LeptonicaSharp.Natives.numaInterpolateEqxInterval(System.Single,System.Single,System.IntPtr,System.Int32,System.Single,System.Single,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) Considering nasy as a function of x, the x values
 are equally spaced.
 (2) This creates nay (and optionally nax) of interpolated
 values over the specified interval (x0, x1).
 (3) If the interval (x0, x1) lies partially outside the array
 nasy (as interpreted by startx and deltax), it is an
 error and returns 1.
 (4) Note that deltax is the intrinsic x-increment for the input
 array nasy, whereas delx is the intrinsic x-increment for the
 output interpolated array nay.
 </summary>
	<remarks>
	</remarks>
	<param name="startx">xval corresponding to first element in nas</param>
	<param name="deltax">x increment between array elements in nas</param>
	<param name="nasy">numa of ordinate values, assumed equally spaced</param>
	<param name="type">L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
	<param name="x0">start value of interval</param>
	<param name="x1">end value of interval</param>
	<param name="npts">number of points to evaluate function in interval</param>
	<param name="pnax">array of x values in interval</param>
	<param name="pnay">array of y values in interval</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaInterpolateArbxInterval(System.IntPtr,System.IntPtr,System.Int32,System.Single,System.Single,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The values in nax must be sorted in increasing order.
 If they are not sorted, we do it here, and complain.
 (2) If the values in nax are equally spaced, you can use
 numaInterpolateEqxInterval().
 (3) Caller should check for valid return.
 (4) We don't call numaInterpolateArbxVal() for each output
 point, because that requires an O(n) search for
 each point.  Instead, we do a single O(n) pass through
 nax, saving the indices to be used for each output yval.
 (5) Uses lagrangian interpolation.  See numaInterpolateEqxVal()
 for formulas.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values</param>
	<param name="nay">numa of ordinate values, corresponding to nax</param>
	<param name="type">L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
	<param name="x0">start value of interval</param>
	<param name="x1">end value of interval</param>
	<param name="npts">number of points to evaluate function in interval</param>
	<param name="pnadx">array of x values in interval</param>
	<param name="pnady">array of y values in interval</param>
	<returns>0 if OK, 1 on error e.g., if x0 or x1 is outside range</returns>
</member><member name="M:LeptonicaSharp.Natives.numaFitMax(System.IntPtr,System.Single[]@,System.IntPtr,System.Single[]@)">
	<summary>
 Notes
 If %naloc is given, there is no requirement that the
 data points are evenly spaced.  Lagrangian interpolation
 handles that.  The only requirement is that the
 data points are ordered so that the values in naloc
 are either increasing or decreasing.  We test to make
 sure that the sizes of na and naloc are equal, and it
 is assumed that the correspondences %na[i] as a function
 of %naloc[i] are properly arranged for all i.
 The formula for Lagrangian interpolation through 3 data pts is
 y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +
 y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +
 y3(x-x1)(x-x2)/((x3-x1)(x3-x2))
 Then the derivative, using the constants (c1,c2,c3) defined below,
 is set to 0
 y'(x) = 2x(c1+c2+c3) - c1(x2+x3) - c2(x1+x3) - c3(x1+x2) = 0
 </summary>
	<remarks>
	</remarks>
	<param name="na">numa of ordinate values, to fit a max to</param>
	<param name="pmaxval">max value</param>
	<param name="naloc">associated numa of abscissa values</param>
	<param name="pmaxloc">abscissa value that gives max value in na; if naloc == null, this is given as an interpolated index value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaDifferentiateInterval(System.IntPtr,System.IntPtr,System.Single,System.Single,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The values in nax must be sorted in increasing order.
 If they are not sorted, it is done in the interpolation
 step, and a warning is issued.
 (2) Caller should check for valid return.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values</param>
	<param name="nay">numa of ordinate values, corresponding to nax</param>
	<param name="x0">start value of interval</param>
	<param name="x1">end value of interval</param>
	<param name="npts">number of points to evaluate function in interval</param>
	<param name="pnadx">array of x values in interval</param>
	<param name="pnady">array of derivatives in interval</param>
	<returns>0 if OK, 1 on error e.g., if x0 or x1 is outside range</returns>
</member><member name="M:LeptonicaSharp.Natives.numaIntegrateInterval(System.IntPtr,System.IntPtr,System.Single,System.Single,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) The values in nax must be sorted in increasing order.
 If they are not sorted, it is done in the interpolation
 step, and a warning is issued.
 (2) Caller should check for valid return.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values</param>
	<param name="nay">numa of ordinate values, corresponding to nax</param>
	<param name="x0">start value of interval</param>
	<param name="x1">end value of interval</param>
	<param name="npts">number of points to evaluate function in interval</param>
	<param name="psum">integral of function over interval</param>
	<returns>0 if OK, 1 on error e.g., if x0 or x1 is outside range</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSortGeneral(System.IntPtr,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sorting can be confusing.  Here's an array of five values with
 the results shown for the 3 output arrays.
 na   nasort   naindex   nainvert
 -----------------------------------
 3   9   2   3
 4   6   3   2
 9   4   1   0
 6   3   0   1
 1   1   4   4
 Note that naindex is a LUT into na for the sorted array values,
 and nainvert directly gives the sorted index values for the
 input array.  It is useful to view naindex is as a map
 0  --GT  2
 1  --GT  3
 2  --GT  1
 3  --GT  0
 4  --GT  4
 and nainvert, the inverse of this map
 0  --GT  3
 1  --GT  2
 2  --GT  0
 3  --GT  1
 4  --GT  4
 We can write these relations symbolically as
 nasort[i] = na[naindex[i]]
 na[i] = nasort[nainvert[i]]
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pnasort">sorted numa</param>
	<param name="pnaindex">index of elements in na associated with each element of nasort</param>
	<param name="pnainvert">index of elements in nasort associated with each element of na</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<param name="sorttype">L_SHELL_SORT or L_BIN_SORT</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSortAutoSelect(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This does either a shell sort or a bin sort, depending on
 the number of elements in nas and the dynamic range.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>naout output sorted numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSortIndexAutoSelect(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This does either a shell sort or a bin sort, depending on
 the number of elements in nas and the dynamic range.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>nad indices of nas, sorted by value in nas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaChooseSortType(System.IntPtr)">
	<summary>
 Notes
 (1) This selects either a shell sort or a bin sort, depending on
 the number of elements in nas and the dynamic range.
 (2) If there are negative values in nas, it selects shell sort.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">to be sorted</param>
	<returns>sorttype L_SHELL_SORT or L_BIN_SORT, or UNDEF on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSort(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Set naout = nain for in-place; otherwise, set naout = NULL.
 (2) Source Shell sort, modified from KR, 2nd edition, p.62.
 Slow but simple O(n logn) sort.
 </summary>
	<remarks>
	</remarks>
	<param name="naout">output numa; can be NULL or equal to nain</param>
	<param name="nain">input numa</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>naout output sorted numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaBinSort(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Because this uses a bin sort with buckets of size 1, it
 is not appropriate for sorting either small arrays or
 arrays containing very large integer values.  For such
 arrays, use a standard general sort function like
 numaSort().
 </summary>
	<remarks>
	</remarks>
	<param name="nas">of non-negative integers with a max that is typically less than 50,000</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>na sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetSortIndex(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>na giving an array of indices that would sort the input array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetBinSortIndex(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This creates an array (or lookup table) that contains
 the sorted position of the elements in the input Numa.
 (2) Because it uses a bin sort with buckets of size 1, it
 is not appropriate for sorting either small arrays or
 arrays containing very large integer values.  For such
 arrays, use a standard general sort function like
 numaGetSortIndex().
 </summary>
	<remarks>
	</remarks>
	<param name="nas">of non-negative integers with a max that is typically less than 1,000,000</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>na sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSortByIndex(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="naindex">na that maps from the new numa to the input numa</param>
	<returns>nad sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaIsSorted(System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This is a quick O(n) test if nas is sorted.  It is useful
 in situations where the array is likely to be already
 sorted, and a sort operation can be avoided.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<param name="psorted">1 if sorted; 0 if not</param>
	<returns>1 if OK; 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSortPair(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This function sorts the two input arrays, nax and nay,
 together, using nax as the key for sorting.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">input arrays</param>
	<param name="nay">input arrays</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<param name="pnasx">sorted</param>
	<param name="pnasy">sorted exactly in order of nasx</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaInvertMap(System.IntPtr)">
	<summary>
 Notes
 (1) This requires that nas contain each integer from 0 to n-1.
 The array is typically an index array into a sort or permutation
 of another array.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<returns>nad the inverted map, or NULL on error or if not invertible</returns>
</member><member name="M:LeptonicaSharp.Natives.numaPseudorandomSequence(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This uses the Durstenfeld shuffle.
 See http//en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle.
 Result is a pseudorandom permutation of the sequence of integers
 from 0 to size - 1.
 </summary>
	<remarks>
	</remarks>
	<param name="size">of sequence</param>
	<param name="seed">for random number generation</param>
	<returns>na pseudorandom on {0,...,size - 1}, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaRandomPermutation(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas">input array</param>
	<param name="seed">for random number generation</param>
	<returns>nas randomly shuffled array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetRankValue(System.IntPtr,System.Single,System.IntPtr,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) Computes the rank value of a number in the %na, which is
 the number that is a fraction %fract from the small
 end of the sorted version of %na.
 (2) If you do this multiple times for different rank values,
 sort the array in advance and use that for %nasort;
 if you're only calling this once, input %nasort == NULL.
 (3) If %usebins == 1, this uses a bin sorting method.
 Use this only where
 the numbers are non-negative integers
 there are over 100 numbers
 the maximum value is less than about 50,000
 (4) The advantage of using a bin sort is that it is O(n),
 instead of O(nlogn) for general sort routines.
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="fract">use 0.0 for smallest, 1.0 for largest</param>
	<param name="nasort">increasing sorted version of na</param>
	<param name="usebins">0 for general sort; 1 for bin sort</param>
	<param name="pval">rank val</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetMedian(System.IntPtr,System.Single[]@)">
	<summary>
 Notes
 (1) Computes the median value of the numbers in the numa, by
 sorting and finding the middle value in the sorted array.
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pval">median value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetBinnedMedian(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) Computes the median value of the numbers in the numa,
 using bin sort and finding the middle value in the sorted array.
 (2) See numaGetRankValue() for conditions on na for which
 this should be used.  Otherwise, use numaGetMedian().
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pval">integer median value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetMode(System.IntPtr,System.Single[]@,System.Int32@)">
	<summary>
 Notes
 (1) Computes the mode value of the numbers in the numa, by
 sorting and finding the value of the number with the
 largest count.
 (2) Optionally, also returns that count.
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pval">mode val</param>
	<param name="pcount">mode count</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetMedianVariation(System.IntPtr,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) Finds the median of the absolute value of the variation from
 the median value in the array.  Why take the absolute value?
 Consider the case where you have values equally distributed
 about both sides of a median value.  Without taking the absolute
 value of the differences, you will get 0 for the variation,
 and this is not useful.
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pmedval">median value</param>
	<param name="pmedvar">median variation from median val</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaJoin(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (2) iend LT 0 means 'read to the end'
 (3) if nas == NULL, this is a no-op
 </summary>
	<remarks>
	</remarks>
	<param name="nad">dest numa; add to this one</param>
	<param name="nas">source numa; add from this one</param>
	<param name="istart">starting index in nas</param>
	<param name="iend">ending index in nas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaJoin(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (2) iend LT 0 means 'read to the end'
 (3) if naas == NULL, this is a no-op
 </summary>
	<remarks>
	</remarks>
	<param name="naad">dest naa; add to this one</param>
	<param name="naas">source naa; add from this one</param>
	<param name="istart">starting index in nas</param>
	<param name="iend">ending index in naas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaaFlattenToNuma(System.IntPtr)">
	<summary>
 Notes
 (1) This 'flattens' the Numaa to a Numa, by joining successively
 each Numa in the Numaa.
 (2) It doesn't make any assumptions about the location of the
 Numas in the Numaa array, unlike most Numaa functions.
 (3) It leaves the input Numaa unchanged.
 </summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<returns>numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaErode(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The structuring element (sel) is linear, all "hits"
 (2) If size == 1, this returns a copy
 (3) General comment.  The morphological operations are equivalent
 to those that would be performed on a 1-dimensional fpix.
 However, because we have not implemented morphological
 operations on fpix, we do this here.  Because it is only
 1 dimensional, there is no reason to use the more
 complicated van Herk/Gil-Werman algorithm, and we do it
 by brute force.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="size">of sel; greater than 0, odd; origin implicitly in center</param>
	<returns>nad eroded, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaDilate(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The structuring element (sel) is linear, all "hits"
 (2) If size == 1, this returns a copy
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="size">of sel; greater than 0, odd; origin implicitly in center</param>
	<returns>nad dilated, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaOpen(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The structuring element (sel) is linear, all "hits"
 (2) If size == 1, this returns a copy
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="size">of sel; greater than 0, odd; origin implicitly in center</param>
	<returns>nad opened, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaClose(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The structuring element (sel) is linear, all "hits"
 (2) If size == 1, this returns a copy
 (3) We add a border before doing this operation, for the same
 reason that we add a border to a pix before doing a safe closing.
 Without the border, a small component near the border gets
 clipped at the border on dilation, and can be entirely removed
 by the following erosion, violating the basic extensivity
 property of closing.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="size">of sel; greater than 0, odd; origin implicitly in center</param>
	<returns>nad opened, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaTransform(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) Each number is shifted before scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="shift">add this to each number</param>
	<param name="scale">multiply each number by this</param>
	<returns>nad with all values shifted and scaled, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSimpleStats(System.IntPtr,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">input numa</param>
	<param name="first">first element to use</param>
	<param name="last">last element to use; 0 to go to the end</param>
	<param name="pmean">mean value</param>
	<param name="pvar">variance</param>
	<param name="prvar">rms deviation from the mean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaWindowedStats(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This is a high-level convenience function for calculating
 any or all of these derived arrays.
 (2) These statistical measures over the values in the
 rectangular window are
 ~ average value [x]  (nam)
 ~ average squared value [xx] (nams)
 ~ variance [(x - [x])(x - [x])] = [xx] - [x][x]  (nav)
 ~ square-root of variance (narv)
 where the brackets [ .. ] indicate that the average value is
 to be taken over the window.
 (3) Note that the variance is just the mean square difference from
 the mean value; and the square root of the variance is the
 root mean square difference from the mean, sometimes also
 called the 'standard deviation'.
 (4) Internally, use mirrored borders to handle values near the
 end of each array.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<param name="wc">half width of the window</param>
	<param name="pnam">mean value in window</param>
	<param name="pnams">mean square value in window</param>
	<param name="pnav">variance in window</param>
	<param name="pnarv">rms deviation from the mean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaWindowedMean(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is a convolution.  The window has width = 2  %wc + 1.
 (2) We add a mirrored border of size %wc to each end of the array.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="wc">half width of the convolution window</param>
	<returns>nad after low-pass filtering, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaWindowedMeanSquare(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The window has width = 2  %wc + 1.
 (2) We add a mirrored border of size %wc to each end of the array.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="wc">half width of the window</param>
	<returns>nad containing windowed mean square values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaWindowedVariance(System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The numas of windowed mean and mean square are precomputed,
 using numaWindowedMean() and numaWindowedMeanSquare().
 (2) Either or both of the variance and square-root of variance
 are returned, where the variance is the average over the
 window of the mean square difference of the pixel value
 from the mean
 [(x - [x])(x - [x])] = [xx] - [x][x]
 </summary>
	<remarks>
	</remarks>
	<param name="nam">windowed mean values</param>
	<param name="nams">windowed mean square values</param>
	<param name="pnav">numa of variance -- the ms deviation from the mean</param>
	<param name="pnarv">numa of rms deviation from the mean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaWindowedMedian(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The requested window has width = 2  %halfwin + 1.
 (2) If the input nas has less then 3 elements, return a copy.
 (3) If the filter is too small (%halfwin LT= 0), return a copy.
 (4) If the filter is too large, it is reduced in size.
 (5) We add a mirrored border of size %halfwin to each end of
 the array to simplify the calculation by avoiding end-effects.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="halfwin">half width of window over which the median is found</param>
	<returns>nad after windowed median filtering, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaConvertToInt(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas">source numa</param>
	<returns>na with all values rounded to nearest integer, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaMakeHistogram(System.IntPtr,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This simple interface is designed for integer data.
 The bins are of integer width and start on integer boundaries,
 so the results on float data will not have high precision.
 (2) Specify the max number of input bins.   Then %binsize,
 the size of bins necessary to accommodate the input data,
 is returned.  It is one of the sequence
 {1, 2, 5, 10, 20, 50, ...}.
 (3) If binstart is given, all values are accommodated,
 and the min value of the starting bin is returned.
 Otherwise, all negative values are discarded and
 the histogram bins start at 0.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="maxbins">max number of histogram bins</param>
	<param name="pbinsize">size of histogram bins</param>
	<param name="pbinstart">start val of minimum bin; input NULL to force start at 0</param>
	<returns>na consisiting of histogram of integerized values, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.numaMakeHistogramAuto(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This simple interface is designed for accurate binning
 of both integer and float data.
 (2) If the array data is integers, and the range of integers
 is smaller than %maxbins, they are binned as they fall,
 with binsize = 1.
 (3) If the range of data, (maxval - minval), is larger than
 %maxbins, or if the data is floats, they are binned into
 exactly %maxbins bins.
 (4) Unlike numaMakeHistogram(), these bins in general have
 non-integer location and width, even for integer data.
 </summary>
	<remarks>
	</remarks>
	<param name="na">numa of floats; these may be integers</param>
	<param name="maxbins">max number of histogram bins; GT= 1</param>
	<returns>na consisiting of histogram of quantized float values, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.numaMakeHistogramClipped(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) This simple function generates a histogram of values
 from na, discarding all values LT 0.0 or greater than
 min(%maxsize, maxval), where maxval is the maximum value in na.
 The histogram data is put in bins of size delx = %binsize,
 starting at x = 0.0.  We use as many bins as are
 needed to hold the data.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="binsize">typically 1.0</param>
	<param name="maxsize">of histogram ordinate</param>
	<returns>na histogram of bins of size %binsize, starting with the na[0] (x = 0.0 and going up to a maximum of x = %maxsize, by increments of %binsize), or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaRebinHistogram(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas">input histogram</param>
	<param name="newsize">number of old bins contained in each new bin</param>
	<returns>nad more coarsely re-binned histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaNormalizeHistogram(System.IntPtr,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas">input histogram</param>
	<param name="tsum">target sum of all numbers in dest histogram; e.g., use %tsum= 1.0 if this represents a probability distribution</param>
	<returns>nad normalized histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetStatsUsingHistogram(System.IntPtr,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,System.Single,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) This is a simple interface for gathering statistics
 from a numa, where a histogram is used 'under the covers'
 to avoid sorting if a rank value is requested.  In that case,
 by using a histogram we are trading speed for accuracy, because
 the values in %na are quantized to the center of a set of bins.
 (2) If the median, other rank value, or histogram are not requested,
 the calculation is all performed on the input Numa.
 (3) The variance is the average of the square of the
 difference from the mean.  The median is the value in na
 with rank 0.5.
 (4) There are two situations where this gives rank results with
 accuracy comparable to computing stastics directly on the input
 data, without binning into a histogram
 (a) the data is integers and the range of data is less than
 %maxbins, and
 (b) the data is floats and the range is small compared to
 %maxbins, so that the binsize is much less than 1.
 (5) If a histogram is used and the numbers in the Numa extend
 over a large range, you can limit the required storage by
 specifying the maximum number of bins in the histogram.
 Use %maxbins == 0 to force the bin size to be 1.
 (6) This optionally returns the median and one arbitrary rank value.
 If you need several rank values, return the histogram and use
 numaHistogramGetValFromRank(nah, rank, rval)
 multiple times.
 </summary>
	<remarks>
	</remarks>
	<param name="na">an arbitrary set of numbers; not ordered and not a histogram</param>
	<param name="maxbins">the maximum number of bins to be allowed in the histogram; use an integer larger than the largest number in %na for consecutive integer bins</param>
	<param name="pmin">min value of set</param>
	<param name="pmax">max value of set</param>
	<param name="pmean">mean value of set</param>
	<param name="pvariance">variance</param>
	<param name="pmedian">median value of set</param>
	<param name="rank">in [0.0 ... 1.0]; median has a rank 0.5; ignored if rval == NULL</param>
	<param name="prval">value in na corresponding to %rank</param>
	<param name="phisto">Numa histogram; use NULL to prevent</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetHistogramStats(System.IntPtr,System.Single,System.Single,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) If the histogram represents the relation y(x), the
 computed values that are returned are the x values.
 These are NOT the bucket indices i; they are related to the
 bucket indices by
 x(i) = startx + i  deltax
 </summary>
	<remarks>
	</remarks>
	<param name="nahisto">histogram y(x(i)), i = 0 ... nbins - 1</param>
	<param name="startx">x value of first bin x(0)</param>
	<param name="deltax">x increment between bins; the bin size; x(1) - x(0)</param>
	<param name="pxmean">mean value of histogram</param>
	<param name="pxmedian">median value of histogram</param>
	<param name="pxmode">mode value of histogram xmode = x(imode), where y(xmode) GT= y(x(i)) for all i != imode</param>
	<param name="pxvariance">variance of x</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetHistogramStatsOnInterval(System.IntPtr,System.Single,System.Single,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) If the histogram represents the relation y(x), the
 computed values that are returned are the x values.
 These are NOT the bucket indices i; they are related to the
 bucket indices by
 x(i) = startx + i  deltax
 </summary>
	<remarks>
	</remarks>
	<param name="nahisto">histogram y(x(i)), i = 0 ... nbins - 1</param>
	<param name="startx">x value of first bin x(0)</param>
	<param name="deltax">x increment between bins; the bin size; x(1) - x(0)</param>
	<param name="ifirst">first bin to use for collecting stats</param>
	<param name="ilast">last bin for collecting stats; use 0 to go to the end</param>
	<param name="pxmean">mean value of histogram</param>
	<param name="pxmedian">median value of histogram</param>
	<param name="pxmode">mode value of histogram xmode = x(imode), where y(xmode) GT= y(x(i)) for all i != imode</param>
	<param name="pxvariance">variance of x</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaMakeRankFromHistogram(System.Single,System.Single,System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="startx">xval corresponding to first element in nay</param>
	<param name="deltax">x increment between array elements in nay</param>
	<param name="nasy">input histogram, assumed equally spaced</param>
	<param name="npts">number of points to evaluate rank function</param>
	<param name="pnax">array of x values in range</param>
	<param name="pnay">rank array of specified npts</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaHistogramGetRankFromVal(System.IntPtr,System.Single,System.Single[]@)">
	<summary>
 Notes
 (1) If we think of the histogram as a function y(x), normalized
 to 1, for a given input value of x, this computes the
 rank of x, which is the integral of y(x) from the start
 value of x to the input value.
 (2) This function only makes sense when applied to a Numa that
 is a histogram.  The values in the histogram can be ints and
 floats, and are computed as floats.  The rank is returned
 as a float between 0.0 and 1.0.
 (3) The numa parameters startx and binsize are used to
 compute x from the Numa index i.
 </summary>
	<remarks>
	</remarks>
	<param name="na">histogram</param>
	<param name="rval">value of input sample for which we want the rank</param>
	<param name="prank">fraction of total samples below rval</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaHistogramGetValFromRank(System.IntPtr,System.Single,System.Single[]@)">
	<summary>
 Notes
 (1) If we think of the histogram as a function y(x), this returns
 the value x such that the integral of y(x) from the start
 value to x gives the fraction 'rank' of the integral
 of y(x) over all bins.
 (2) This function only makes sense when applied to a Numa that
 is a histogram.  The values in the histogram can be ints and
 floats, and are computed as floats.  The val is returned
 as a float, even though the buckets are of integer width.
 (3) The numa parameters startx and binsize are used to
 compute x from the Numa index i.
 </summary>
	<remarks>
	</remarks>
	<param name="na">histogram</param>
	<param name="rank">fraction of total samples</param>
	<param name="prval">approx. to the bin value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaDiscretizeRankAndIntensity(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) We are inverting the rank(intensity) function to get
 the intensity(rank) function at %nbins equally spaced
 values of rank between 0.0 and 1.0.  We save integer values
 for the intensity.
 (2) We are using the word "intensity" to describe the type of
 array values, but any array of non-negative numbers will work.
 (3) The output arrays give the following mappings, where the
 input is a normalized histogram of array values
 array values  --GT  rank bin number  (narbin)
 rank bin number  --GT  median array value in bin (nam)
 array values  --GT  cumulative norm = rank  (nar)
 rank bin number  --GT  array value at right bin edge (nabb)
 </summary>
	<remarks>
	</remarks>
	<param name="na">normalized histogram of probability density vs intensity</param>
	<param name="nbins">number of bins at which the rank is divided</param>
	<param name="pnarbin">rank bin value vs intensity</param>
	<param name="pnam">median intensity in a bin vs rank bin value, with %nbins of discretized rank values</param>
	<param name="pnar">rank vs intensity; this is a cumulative norm histogram</param>
	<param name="pnabb">intensity at the right bin boundary vs rank bin</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaGetRankBinValues(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) Simple interface for getting a binned rank representation
 of an input array of values.  This returns two mappings
 array value  --GT  rank bin number  (narbin)
 rank bin number --GT  median array value in each rank bin (nam)
 </summary>
	<remarks>
	</remarks>
	<param name="na">just an array of values</param>
	<param name="nbins">number of bins at which the rank is divided</param>
	<param name="pnarbin">rank bin value vs array value</param>
	<param name="pnam">median intensity in a bin vs rank bin value, with %nbins of discretized rank values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSplitDistribution(System.IntPtr,System.Single,System.Int32@,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) This function is intended to be used on a distribution of
 values that represent two sets, such as a histogram of
 pixel values for an image with a fg and bg, and the goal
 is to determine the averages of the two sets and the
 best splitting point.
 (2) The Otsu method finds a split point that divides the distribution
 into two parts by maximizing a score function that is the
 product of two terms
 (a) the square of the difference of centroids, (ave1 - ave2)^2
 (b) fract1  (1 - fract1)
 where fract1 is the fraction in the lower distribution.
 (3) This works well for images where the fg and bg are
 each relatively homogeneous and well-separated in color.
 However, if the actual fg and bg sets are very different
 in size, and the bg is highly varied, as can occur in some
 scanned document images, this will bias the split point
 into the larger "bump" (i.e., toward the point where the
 (b) term reaches its maximum of 0.25 at fract1 = 0.5.
 To avoid this, we define a range of values near the
 maximum of the score function, and choose the value within
 this range such that the histogram itself has a minimum value.
 The range is determined by scorefract we include all abscissa
 values to the left and right of the value that maximizes the
 score, such that the score stays above (1 - scorefract)  maxscore.
 The intuition behind this modification is to try to find
 a split point that both has a high variance score and is
 at or near a minimum in the histogram, so that the histogram
 slope is small at the split point.
 (4) We normalize the score so that if the two distributions
 were of equal size and at opposite ends of the numa, the
 score would be 1.0.
 </summary>
	<remarks>
	</remarks>
	<param name="na">histogram</param>
	<param name="scorefract">fraction of the max score, used to determine the range over which the histogram min is searched</param>
	<param name="psplitindex">index for splitting</param>
	<param name="pave1">average of lower distribution</param>
	<param name="pave2">average of upper distribution</param>
	<param name="pnum1">population of lower distribution</param>
	<param name="pnum2">population of upper distribution</param>
	<param name="pnascore">for debugging; otherwise use NULL</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.grayHistogramsToEMD(System.IntPtr,System.IntPtr,System.IntPtr@)">
	<summary>
 Notes
 (1) The two numaas must be the same size and have corresponding
 256-element histograms.  Pairs do not need to be normalized
 to the same sum.
 (2) This is typically used on two sets of histograms from
 corresponding tiles of two images.  The similarity of two
 images can be found with the scoring function used in
 pixCompareGrayByHisto()
 score S = 1.0 - k  D, where
 k is a constant, say in the range 5-10
 D = EMD
 for each tile; for multiple tiles, take the Min(S) over
 the set of tiles to be the final score.
 </summary>
	<remarks>
	</remarks>
	<param name="naa1">two numaa, each with one or more 256-element histograms</param>
	<param name="naa2">two numaa, each with one or more 256-element histograms</param>
	<param name="pnad">nad of EM distances for each histogram</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaEarthMoverDistance(System.IntPtr,System.IntPtr,System.Single[]@)">
	<summary>
 Notes
 (1) The two numas must have the same size.  They do not need to be
 normalized to the same sum before applying the function.
 (2) For a 1D discrete function, the implementation of the EMD
 is trivial.  Just keep filling or emptying buckets in one numa
 to match the amount in the other, moving sequentially along
 both arrays.
 (3) We divide the sum of the absolute value of everything moved
 (by 1 unit at a time) by the sum of the numa (amount of "earth")
 to get the average distance that the "earth" was moved.
 This is the value returned here.
 (4) The caller can do a further normalization, by the number of
 buckets (minus 1), to get the EM distance as a fraction of
 the maximum possible distance, which is n-1.  This fraction
 is 1.0 for the situation where all the 'earth' in the first
 array is at one end, and all in the second array is at the
 other end.
 </summary>
	<remarks>
	</remarks>
	<param name="na1">two numas of the same size, typically histograms</param>
	<param name="na2">two numas of the same size, typically histograms</param>
	<param name="pdist">EM distance</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.grayInterHistogramStats(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The %naa has two or more 256-element numa histograms, which
 are to be compared value-wise at each of the 256 gray levels.
 The result are stats (mean, mean square, variance, root variance)
 aggregated across the set of histograms, and each is output
 as a 256 entry numa.  Think of these histograms as a matrix,
 where each histogram is one row of the array.  The stats are
 then aggregated column-wise, between the histograms.
 (2) These stats are
 ~ average value LTvGT  (nam)
 ~ average squared value LTvvGT (nams)
 ~ variance LT(v - LTvGT)(v - LTvGT)GT = LTvvGT - LTvGTLTvGT  (nav)
 ~ square-root of variance (narv)
 where the brackets LT .. GT indicate that the average value is
 to be taken over each column of the array.
 (3) The input histograms are optionally smoothed before these
 statistical operations.
 (4) The input histograms are normalized to a sum of 10000.  By
 doing this, the resulting numbers are independent of the
 number of samples used in building the individual histograms.
 (5) A typical application is on a set of histograms from tiles
 of an image, to distinguish between text/tables and photo
 regions.  If the tiles are much larger than the text line
 spacing, text/table regions typically have smaller variance
 across tiles than photo regions.  For this application, it
 may be useful to ignore values near white, which are large for
 text and would magnify the variance due to variations in
 illumination.  However, because the variance of a drawing or
 a light photo can be similar to that of grayscale text, this
 function is only a discriminator between darker photos/drawings
 and light photos/text/line-graphics.
 </summary>
	<remarks>
	</remarks>
	<param name="naa">numaa with two or more 256-element histograms</param>
	<param name="wc">half-width of the smoothing window</param>
	<param name="pnam">mean values</param>
	<param name="pnams">mean square values</param>
	<param name="pnav">variances</param>
	<param name="pnarv">rms deviations from the mean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaFindPeaks(System.IntPtr,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) The returned na consists of sets of four numbers representing
 the peak, in the following order
 left edge; peak center; right edge; normalized peak area
 </summary>
	<remarks>
	</remarks>
	<param name="nas">source numa</param>
	<param name="nmax">max number of peaks to be found</param>
	<param name="fract1">min fraction of peak value</param>
	<param name="fract2">min slope</param>
	<returns>peak na, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.numaFindExtrema(System.IntPtr,System.Single,System.IntPtr@)">
	<summary>
 Notes
 (1) This returns a sequence of extrema (peaks and valleys).
 (2) The algorithm is analogous to that for determining
 mountain peaks.  Suppose we have a local peak, with
 bumps on the side.  Under what conditions can we consider
 those 'bumps' to be actual peaks?  The answer if the
 bump is separated from the peak by a saddle that is at
 least 500 feet below the bump.
 (3) Operationally, suppose we are looking for a peak.
 We are keeping the largest value we've seen since the
 last valley, and are looking for a value that is delta
 BELOW our current peak.  When we find such a value,
 we label the peak, use the current value to label the
 valley, and then do the same operation in reverse (looking
 for a valley).
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input values</param>
	<param name="delta">relative amount to resolve peaks and valleys</param>
	<param name="pnav">values of extrema</param>
	<returns>nad (locations of extrema, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaCountReversals(System.IntPtr,System.Single,System.Int32@,System.Single[]@)">
	<summary>
 Notes
 (1) The input numa is can be generated from pixExtractAlongLine().
 If so, the x parameters can be used to find the reversal
 frequency along a line.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input values</param>
	<param name="minreversal">relative amount to resolve peaks and valleys</param>
	<param name="pnr">number of reversals</param>
	<param name="pnrpl">([optional] reversal density reversals/length</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaSelectCrossingThreshold(System.IntPtr,System.IntPtr,System.Single,System.Single[]@)">
	<summary>
 Notes
 (1) When a valid threshold is used, the number of crossings is
 a maximum, because none are missed.  If no threshold intersects
 all the crossings, the crossings must be determined with
 numaCrossingsByPeaks().
 (2) %estthresh is an input estimate of the threshold that should
 be used.  We compute the crossings with 41 thresholds
 (20 below and 20 above).  There is a range in which the
 number of crossings is a maximum.  Return a threshold
 in the center of this stable plateau of crossings.
 This can then be used with numaCrossingsByThreshold()
 to get a good estimate of crossing locations.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values; can be NULL</param>
	<param name="nay">signal</param>
	<param name="estthresh">estimated pixel threshold for crossing e.g., for images, white LT--GT black; typ. ~120</param>
	<param name="pbestthresh">robust estimate of threshold to use</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaCrossingsByThreshold(System.IntPtr,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) If nax == NULL, we use startx and delx from nay to compute
 the crossing values in nad.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values; can be NULL</param>
	<param name="nay">numa of ordinate values, corresponding to nax</param>
	<param name="thresh">threshold value for nay</param>
	<returns>nad abscissa pts at threshold, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaCrossingsByPeaks(System.IntPtr,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) If nax == NULL, we use startx and delx from nay to compute
 the crossing values in nad.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values</param>
	<param name="nay">numa of ordinate values, corresponding to nax</param>
	<param name="delta">parameter used to identify when a new peak can be found</param>
	<returns>nad abscissa pts at threshold, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaEvalBestHaarParameters(System.IntPtr,System.Single,System.Int32,System.Int32,System.Single,System.Single,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This does a linear sweep of widths, evaluating at %nshift
 shifts for each width, computing the score from a convolution
 with a long comb, and finding the (width, shift) pair that
 gives the maximum score.  The best width is the "half-wavelength"
 of the signal.
 (2) The convolving function is a comb of alternating values
 +1 and -1  relweight, separated by the width and phased by
 the shift.  This is similar to a Haar transform, except
 there the convolution is performed with a square wave.
 (3) The function is useful for finding the line spacing
 and strength of line signal from pixel sum projections.
 (4) The score is normalized to the size of nas divided by
 the number of half-widths.  For image applications, the input is
 typically an array of pixel projections, so one should
 normalize by dividing the score by the image width in the
 pixel projection direction.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">numa of non-negative signal values</param>
	<param name="relweight">relative weight of (-1 comb) / (+1 comb) contributions to the 'convolution'.  In effect, the convolution kernel is a comb consisting of alternating +1 and -weight.</param>
	<param name="nwidth">number of widths to consider</param>
	<param name="nshift">number of shifts to consider for each width</param>
	<param name="minwidth">smallest width to consider</param>
	<param name="maxwidth">largest width to consider</param>
	<param name="pbestwidth">width giving largest score</param>
	<param name="pbestshift">shift giving largest score</param>
	<param name="pbestscore">convolution with "Haar"-like comb</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaEvalHaarSum(System.IntPtr,System.Single,System.Single,System.Single,System.Single[]@)">
	<summary>
 Notes
 (1) This does a convolution with a comb of alternating values
 +1 and -relweight, separated by the width and phased by the shift.
 This is similar to a Haar transform, except that for Haar,
 (1) the convolution kernel is symmetric about 0, so the
 relweight is 1.0, and
 (2) the convolution is performed with a square wave.
 (2) The score is normalized to the size of nas divided by
 twice the "width".  For image applications, the input is
 typically an array of pixel projections, so one should
 normalize by dividing the score by the image width in the
 pixel projection direction.
 (3) To get a Haar-like result, use relweight = 1.0.  For detecting
 signals where you expect every other sample to be close to
 zero, as with barcodes or filtered text lines, you can
 use relweight GT 1.0.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">numa of non-negative signal values</param>
	<param name="width">distance between +1 and -1 in convolution comb</param>
	<param name="shift">phase of the comb location of first +1</param>
	<param name="relweight">relative weight of (-1 comb) / (+1 comb) contributions to the 'convolution'.  In effect, the convolution kernel is a comb consisting of alternating +1 and -weight.</param>
	<param name="pscore">convolution with "Haar"-like comb</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.genConstrainedNumaInRange(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Selection is made uniformly in the range.  This can be used
 to select pages distributed as uniformly as possible
 through a book, where you are constrained to
 ~ choose between [first, ... biggest],
 ~ choose no more than nmax numbers, and
 and you have the option of requiring pairs of adjacent numbers.
 </summary>
	<remarks>
	</remarks>
	<param name="first">first number to choose; GT= 0</param>
	<param name="last">biggest possible number to reach; GT= first</param>
	<param name="nmax">maximum number of numbers to select; GT 0</param>
	<param name="use_pairs">1 = select pairs of adjacent numbers; 0 = select individual numbers</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRegionsBinary(System.IntPtr,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr)">
	<summary>
 Notes
 (1) It is best to deskew the image before segmenting.
 (2) Passing in %pixadb enables debug output.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, assumed to be 300 to 400 ppi</param>
	<param name="ppixhm">halftone mask</param>
	<param name="ppixtm">textline mask</param>
	<param name="ppixtb">textblock mask</param>
	<param name="pixadb">input for collecting debug pix; use NULL to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenHalftoneMask(System.IntPtr,System.IntPtr,System.Object,System.Int32)">
	<summary>
 Deprecated
 This wrapper avoids an ABI change with tesseract 3.0.4.
 It should be removed when we no longer need to support 3.0.4.
 The debug parameter is ignored (assumed 0).
 </summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenerateHalftoneMask(System.IntPtr,System.IntPtr@,System.Int32@,System.IntPtr)">
	<summary>
 Notes
 (1) This is not intended to work on small thumbnails.  The
 dimensions of pixs must be at least MinWidth x MinHeight.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, assumed to be 150 to 200 ppi</param>
	<param name="ppixtext">text part of pixs</param>
	<param name="phtfound">1 if the mask is not empty</param>
	<param name="pixadb">input for collecting debug pix; use NULL to skip</param>
	<returns>pixd halftone mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenTextlineMask(System.IntPtr,System.IntPtr@,System.Int32@,System.IntPtr)">
	<summary>
 Notes
 (1) The input pixs should be deskewed.
 (2) pixs should have no halftone pixels.
 (3) This is not intended to work on small thumbnails.  The
 dimensions of pixs must be at least MinWidth x MinHeight.
 (4) Both the input image and the returned textline mask
 are at the same resolution.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, assumed to be 150 to 200 ppi</param>
	<param name="ppixvws">vertical whitespace mask</param>
	<param name="ptlfound">1 if the mask is not empty</param>
	<param name="pixadb">input for collecting debug pix; use NULL to skip</param>
	<returns>pixd textline mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenTextblockMask(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Both the input masks (textline and vertical white space) and
 the returned textblock mask are at the same resolution.
 (2) This is not intended to work on small thumbnails.  The
 dimensions of pixs must be at least MinWidth x MinHeight.
 (3) The result is somewhat noisy, in that small "blocks" of
 text may be included.  These can be removed by post-processing,
 using, e.g.,
 pixSelectBySize(pix, 60, 60, 4, L_SELECT_IF_EITHER,
 L_SELECT_IF_GTE, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, textline mask, assumed to be 150 to 200 ppi</param>
	<param name="pixvws">vertical white space mask</param>
	<param name="pixadb">input for collecting debug pix; use NULL to skip</param>
	<returns>pixd textblock mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindPageForeground(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) This doesn't simply crop to the fg.  It attempts to remove
 pixel noise and junk at the edge of the image before cropping.
 The input %threshold is used if pixs is not 1 bpp.
 (2) This is not intended to work on small thumbnails.  The
 dimensions of pixs must be at least MinWidth x MinHeight.
 (3) Debug set showmorph to display the intermediate image in
 the morphological operations on this page.
 (4) Debug to get pdf output of results when called repeatedly,
 call with an existing pixac, which will add an image of this page,
 with the fg outlined.  If no foreground is found, there is
 no output for this page image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">full resolution (any type or depth</param>
	<param name="threshold">for binarization; typically about 128</param>
	<param name="mindist">min distance of text from border to allow cleaning near border; at 2x reduction, this should be larger than 50; typically about 70</param>
	<param name="erasedist">when conditions are satisfied, erase anything within this distance of the edge; typically 20-30 at 2x reduction</param>
	<param name="showmorph">debug set to a negative integer to show steps in generating masks; this is typically used for debugging region extraction</param>
	<param name="pixac">debug allocate outside and pass this in to accumulate results of each call to this function, which can be displayed in a mosaic or a pdf.</param>
	<returns>box region including foreground, with some pixel noise removed, or NULL if not found</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSplitIntoCharacters(System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This is a simple function that attempts to find split points
 based on vertical pixel profiles.
 (2) It should be given an image that has an arbitrary number
 of text characters.
 (3) The returned pixa includes the boxes from which the
 (possibly split) components are extracted.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, contains only deskewed text</param>
	<param name="minw">min component width for initial filtering; typ. 4</param>
	<param name="minh">min component height for initial filtering; typ. 4</param>
	<param name="pboxa">character bounding boxes</param>
	<param name="ppixa">character images</param>
	<param name="ppixdebug">showing splittings</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSplitComponentWithProfile(System.IntPtr,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) This will split the most obvious cases of touching characters.
 The split points it is searching for are narrow and deep
 minimima in the vertical pixel projection profile, after a
 large vertical closing has been applied to the component.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, exactly one connected component</param>
	<param name="delta">distance used in extrema finding in a numa; typ. 10</param>
	<param name="mindel">minimum required difference between profile minimum and profile values +2 and -2 away; typ. 7</param>
	<param name="ppixdebug">debug image of splitting</param>
	<returns>boxa of c.c. after splitting, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExtractTextlines(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) This function assumes that textline fragments have sufficient
 vertical separation and small enough skew so that a
 horizontal dilation sufficient to join words will not join
 textlines.  It does not guarantee that horizontally adjacent
 textline fragments on the same line will be joined.
 (2) For images with multiple columns, it attempts to avoid joining
 textlines across the space between columns.  If that is not
 a concern, you can also use pixExtractRawTextlines(),
 which will join them with alacrity.
 (3) This first removes components from pixs that are either
 wide (GT %maxw) or tall (GT %maxh).
 (4) A final filtering operation removes small components, such
 that width LT %minw or height LT %minh.
 (5) For reasonable accuracy, the resolution of pixs should be
 at least 100 ppi.  For reasonable efficiency, the resolution
 should not exceed 600 ppi.
 (6) This can be used to determine if some region of a scanned
 image is horizontal text.
 (7) As an example, for a pix with resolution 300 ppi, a reasonable
 set of parameters is
 pixExtractTextlines(pix, 150, 150, 36, 20, 5, 5, NULL);
 The defaults minw and minh for 300 ppi are about 36 and 20,
 so the same result is obtained with
 pixExtractTextlines(pix, 150, 150, 0, 0, 5, 5, NULL);
 (8) The output pixa is composed of subimages, one for each textline,
 and the boxa in the pixa tells where in %pixs each textline goes.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, assumed to have nearly horizontal text</param>
	<param name="maxw">initial filtering remove any components in pixs with components larger than maxw or maxh</param>
	<param name="maxh">initial filtering remove any components in pixs with components larger than maxw or maxh</param>
	<param name="minw">final filtering remove extracted 'lines' with sizes smaller than minw or minh; use 0 for default.</param>
	<param name="minh">final filtering remove extracted 'lines' with sizes smaller than minw or minh; use 0 for default.</param>
	<param name="adjw">final adjustment of boxes representing each text line.  If GT 0, these increase the box size at each edge by this amount.</param>
	<param name="adjh">final adjustment of boxes representing each text line.  If GT 0, these increase the box size at each edge by this amount.</param>
	<param name="pixadb">pixa for saving intermediate steps; NULL to omit</param>
	<returns>pixa of textline images, including bounding boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExtractRawTextlines(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) This function assumes that textlines have sufficient
 vertical separation and small enough skew so that a
 horizontal dilation sufficient to join words will not join
 textlines.  It aggressively joins textlines across multiple
 columns, so if that is not desired, you must either (a) make
 sure that %pixs is a single column of text or (b) use instead
 pixExtractTextlines(), which is more conservative
 about joining text fragments that have vertical overlap.
 (2) This first removes components from pixs that are either
 very wide (GT %maxw) or very tall (GT %maxh).
 (3) For reasonable accuracy, the resolution of pixs should be
 at least 100 ppi.  For reasonable efficiency, the resolution
 should not exceed 600 ppi.
 (4) This can be used to determine if some region of a scanned
 image is horizontal text.
 (5) As an example, for a pix with resolution 300 ppi, a reasonable
 set of parameters is
 pixExtractRawTextlines(pix, 150, 150, 0, 0, NULL);
 (6) The output pixa is composed of subimages, one for each textline,
 and the boxa in the pixa tells where in %pixs each textline goes.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, assumed to have nearly horizontal text</param>
	<param name="maxw">initial filtering remove any components in pixs with components larger than maxw or maxh; use 0 for default values.</param>
	<param name="maxh">initial filtering remove any components in pixs with components larger than maxw or maxh; use 0 for default values.</param>
	<param name="adjw">final adjustment of boxes representing each text line.  If GT 0, these increase the box size at each edge by this amount.</param>
	<param name="adjh">final adjustment of boxes representing each text line.  If GT 0, these increase the box size at each edge by this amount.</param>
	<param name="pixadb">pixa for saving intermediate steps; NULL to omit</param>
	<returns>pixa of textline images, including bounding boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCountTextColumns(System.IntPtr,System.Single,System.Single,System.Single,System.Int32@,System.IntPtr)">
	<summary>
 Notes
 (1) It is assumed that pixs has the correct resolution set.
 If the resolution is 0, we set to 300 and issue a warning.
 (2) If necessary, the image is scaled to between 37 and 75 ppi;
 most of the processing is done at this resolution.
 (3) If no text is found (essentially a blank page),
 this returns ncols = 0.
 (4) For debug output, input a pre-allocated pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="deltafract">fraction of (max - min) to be used in the delta for extrema finding; typ 0.3</param>
	<param name="peakfract">fraction of (max - min) to be used to threshold the peak value; typ. 0.5</param>
	<param name="clipfract">fraction of image dimension removed on each side; typ. 0.1, which leaves w and h reduced by 0.8</param>
	<param name="pncols">number of columns; -1 if not determined</param>
	<param name="pixadb">pre-allocated, for showing intermediate computation; use null to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDecideIfText(System.IntPtr,System.IntPtr,System.Int32@,System.IntPtr)">
	<summary>
 Notes
 (1) It is assumed that pixs has the correct resolution set.
 If the resolution is 0, we set to 300 and issue a warning.
 (2) If necessary, the image is scaled to 300 ppi; most of the
 processing is done at this resolution.
 (3) Text is assumed to be in horizontal lines.
 (4) Because thin vertical lines are removed before filtering for
 text lines, this should identify tables as text.
 (5) If %box is null and pixs contains both text lines and line art,
 this function might return %istext == true.
 (6) If the input pixs is empty, or for some other reason the
 result can not be determined, return -1.
 (7) For debug output, input a pre-allocated pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="box">if null, use entire pixs</param>
	<param name="pistext">1 if text; 0 if photo; -1 if not determined or empty</param>
	<param name="pixadb">pre-allocated, for showing intermediate computation; use NULL to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindThreshFgExtent(System.IntPtr,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="thresh">threshold number of pixels in row</param>
	<param name="ptop">location of top of region</param>
	<param name="pbot">location of bottom of region</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDecideIfTable(System.IntPtr,System.IntPtr,System.Int32,System.Int32@,System.IntPtr)">
	<summary>
 Notes
 (1) It is assumed that pixs has the correct resolution set.
 If the resolution is 0, we assume it is 300 ppi and issue a warning.
 (2) If %orient == L_LANDSCAPE_MODE, the image is rotated 90 degrees
 clockwise before being analyzed.
 (3) The interpretation of the returned score
 -1  undetermined
 0  no table
 1  unlikely to have a table
 2  likely to have a table
 3  even more likely to have a table
 4  extremely likely to have a table
 Setting the condition for finding a table at score GT= 2 works
 well, except for false positives on kanji and landscape text.
 These false positives can be removed by setting the condition
 at score GT= 3, but recall is lowered because it will not find
 tables without either horizontal or vertical lines.
 (4) Most of the processing takes place at 75 ppi.
 (5) Internally, three numbers are determined, for horizontal and
 vertical fg lines, and for vertical bg lines.  From these,
 four tests are made to decide if there is a table occupying
 a significant part of the image.
 (6) Images have arbitrary content and would be likely to trigger
 this detector, so they are checked for first, and if found,
 return with a 0 (no table) score.
 (7) Musical scores (tablature) are likely to trigger the detector.
 (8) Tables of content with more than 2 columns are likely to
 trigger the detector.
 (9) For debug output, input a pre-allocated pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, any resolution GT= 75 ppi</param>
	<param name="box">if null, use entire pixs</param>
	<param name="orient">L_PORTRAIT_MODE, L_LANDSCAPE_MODE</param>
	<param name="pscore">0 - 4; -1 if not determined</param>
	<param name="pixadb">pre-allocated, for showing intermediate computation; use NULL to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixPrepare1bpp(System.IntPtr,System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This handles some common pre-processing operations,
 where the page segmentation algorithm takes a 1 bpp image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="box">if null, use entire pixs</param>
	<param name="cropfract">fraction to be removed from the boundary; use 0.0 to retain the entire image</param>
	<param name="outres">desired resolution of output image; if the input image resolution is not set, assume 300 ppi; use 0 to skip scaling.</param>
	<returns>pixd if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixEstimateBackground(System.IntPtr,System.Int32,System.Single,System.Int32@)">
	<summary>
 Notes
 (1) Caller should check that return bg value is GT 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, with or without colormap</param>
	<param name="darkthresh">pixels below this value are never considered part of the background; typ. 70; use 0 to skip</param>
	<param name="edgecrop">fraction of half-width on each side, and of half-height at top and bottom, that are cropped</param>
	<param name="pbg">estimated background, or 0 on error</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindLargeRectangles(System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This does a greedy search to find the largest rectangles,
 either black or white and without overlaps, in %pix.
 (2) See pixFindLargestRectangle(), which is called multiple
 times, for details.  On each call, the largest rectangle
 found is painted, so that none of its pixels can be
 used later, before calling it again.
 (3) This function is surprisingly fast.  Although
 pixFindLargestRectangle() runs at about 50 MPix/sec, when it
 is run multiple times by pixFindLargeRectangles(), it processes
 at 150 - 250 MPix/sec, and the time is approximately linear
 in %nrect.  For example, for a 1 MPix image, searching for
 the largest 50 boxes takes about 0.2 seconds.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="polarity">0 within background, 1 within foreground</param>
	<param name="nrect">number of rectangles to be found</param>
	<param name="pboxa">largest rectangles, sorted by decreasing area</param>
	<param name="ppixdb">optional return output with rectangles drawn on it</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindLargestRectangle(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This is a simple and elegant solution to a problem in
 computational geometry that at first appears to be quite
 difficult what is the largest rectangle that can be
 placed in the image, covering only pixels of one polarity
 (bg or fg)?  The solution is O(n), where n is the number
 of pixels in the image, and it requires nothing more than
 using a simple recursion relation in a single sweep of the image.
 (2) In a sweep from UL to LR with left-to-right being the fast
 direction, calculate the largest white rectangle at (x, y),
 using previously calculated values at pixels #1 and #2
 #1 (x, y - 1)
 #2 (x - 1, y)
 We also need the most recent "black" pixels that were seen
 in the current row and column.
 Consider the largest area.  There are only two possibilities
 (a)  Min(w(1), horizdist)  (h(1) + 1)
 (b)  Min(h(2), vertdist)  (w(2) + 1)
 where
 horizdist the distance from the rightmost "black" pixel seen
 in the current row across to the current pixel
 vertdist the distance from the lowest "black" pixel seen
 in the current column down to the current pixel
 and we choose the Max of (a) and (b).
 (3) To convince yourself that these recursion relations are correct,
 it helps to draw the maximum rectangles at #1 and #2.
 Then for #1, you try to extend the rectangle down one line,
 so that the height is h(1) + 1.  Do you get the full
 width of #1, w(1)?  It depends on where the black pixels are
 in the current row.  You know the final width is bounded by w(1)
 and w(2) + 1, but the actual value depends on the distribution
 of black pixels in the current row that are at a distance
 from the current pixel that is between these limits.
 We call that value "horizdist", and the area is then given
 by the expression (a) above.  Using similar reasoning for #2,
 where you attempt to extend the rectangle to the right
 by 1 pixel, you arrive at (b).  The largest rectangle is
 then found by taking the Max.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="polarity">0 within background, 1 within foreground</param>
	<param name="pbox">largest area rectangle</param>
	<param name="ppixdb">optional return output with rectangle drawn on it</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetSelectCmap(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) It sets all pixels in region that have the color specified
 by the colormap index 'sindex' to the new color.
 (3) sindex must be in the existing colormap; otherwise an
 error is returned.
 (4) If the new color exists in the colormap, it is used;
 otherwise, it is added to the colormap.  If it cannot be
 added because the colormap is full, an error is returned.
 (5) If box is NULL, applies function to the entire image; otherwise,
 clips the operation to the intersection of the box and pix.
 (6) An example of use would be to set to a specific color all
 the light (background) pixels within a certain region of
 a 3-level 2 bpp image, while leaving light pixels outside
 this region unchanged.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4 or 8 bpp, with colormap</param>
	<param name="box">region to set color; can be NULL</param>
	<param name="sindex">colormap index of pixels to be changed</param>
	<param name="rval">new color to paint</param>
	<param name="gval">new color to paint</param>
	<param name="bval">new color to paint</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorGrayRegionsCmap(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
 preserving antialiasing.
 If type == L_PAINT_DARK, it colorizes non-white pixels,
 preserving antialiasing.  See pixColorGrayCmap() for details.
 (3) This can also be called through pixColorGrayRegions().
 (4) This increases the colormap size by the number of
 different gray (non-black or non-white) colors in the
 selected regions of pixs.  If there is not enough room in
 the colormap for this expansion, it returns 1 (error),
 and the caller should check the return value.
 (5) Because two boxes in the boxa can overlap, pixels that
 are colorized in the first box must be excluded in the
 second because their value exceeds the size of the map.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, with colormap</param>
	<param name="boxa">of regions in which to apply color</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="rval">target color</param>
	<param name="gval">target color</param>
	<param name="bval">target color</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorGrayCmap(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
 preserving antialiasing.
 If type == L_PAINT_DARK, it colorizes non-white pixels,
 preserving antialiasing.
 (3) box gives the region to apply color; if NULL, this
 colorizes the entire image.
 (4) If the cmap is only 2 or 4 bpp, pixs is converted in-place
 to an 8 bpp cmap.  A 1 bpp cmap is not a valid input pix.
 (5) This can also be called through pixColorGray().
 (6) This operation increases the colormap size by the number of
 different gray (non-black or non-white) colors in the
 input colormap.  If there is not enough room in the colormap
 for this expansion, it returns 1 (error), and the caller
 should check the return value.
 (7) Using the darkness of each original pixel in the rect,
 it generates a new color (based on the input rgb values).
 If type == L_PAINT_LIGHT, the new color is a (generally)
 darken-to-black version of the  input rgb color, where the
 amount of darkening increases with the darkness of the
 original pixel color.
 If type == L_PAINT_DARK, the new color is a (generally)
 faded-to-white version of the  input rgb color, where the
 amount of fading increases with the brightness of the
 original pixel color.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp, with colormap</param>
	<param name="box">region to set color; can be NULL</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="rval">target color</param>
	<param name="gval">target color</param>
	<param name="bval">target color</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorGrayMaskedCmap(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
 preserving antialiasing.
 If type == L_PAINT_DARK, it colorizes non-white pixels,
 preserving antialiasing.  See pixColorGrayCmap() for details.
 (3) This increases the colormap size by the number of
 different gray (non-black or non-white) colors in the
 input colormap.  If there is not enough room in the colormap
 for this expansion, it returns 1 (error).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, with colormap</param>
	<param name="pixm">1 bpp mask, through which to apply color</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="rval">target color</param>
	<param name="gval">target color</param>
	<param name="bval">target color</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.addColorizedGrayToCmap(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
 preserving antialiasing.
 If type == L_PAINT_DARK, it colorizes non-white pixels,
 preserving antialiasing.
 (2) This increases the colormap size by the number of
 different gray (non-black or non-white) colors in the
 input colormap.  If there is not enough room in the colormap
 for this expansion, it returns 1 (treated as a warning);
 the caller should check the return value.
 (3) This can be used to determine if the new colors will fit in
 the cmap, using null for na.  Returns 0 if they fit; 2 if
 they don't fit.
 (4) The mapping table contains, for each gray color found, the
 index of the corresponding colorized pixel.  Non-gray
 pixels are assigned the invalid index 256.
 (5) See pixColorGrayCmap() for usage.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">from 2 or 4 bpp pix</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="rval">target color</param>
	<param name="gval">target color</param>
	<param name="bval">target color</param>
	<param name="pna">table for mapping new cmap entries</param>
	<returns>0 if OK; 1 on error; 2 if new colors will not fit in cmap.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetSelectMaskedCmap(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) This paints through the fg of pixm and replaces all pixels
 in pixs that have a particular value (sindex) with the new color.
 (3) If pixm == NULL, a warning is given.
 (4) sindex must be in the existing colormap; otherwise an
 error is returned.
 (5) If the new color exists in the colormap, it is used;
 otherwise, it is added to the colormap.  If the colormap
 is full, an error is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp, with colormap</param>
	<param name="pixm">1 bpp mask; no-op if NULL</param>
	<param name="x">UL corner of mask relative to pixs</param>
	<param name="y">UL corner of mask relative to pixs</param>
	<param name="sindex">colormap index of pixels in pixs to be changed</param>
	<param name="rval">new color to substitute</param>
	<param name="gval">new color to substitute</param>
	<param name="bval">new color to substitute</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetMaskedCmap(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) It paints a single color through the mask (as a stencil).
 (3) The mask origin is placed at (x,y) on pixs, and the
 operation is clipped to the intersection of the mask and pixs.
 (4) If pixm == NULL, a warning is given.
 (5) Typically, pixm is a small binary mask located somewhere
 on the larger pixs.
 (6) If the color is in the colormap, it is used.  Otherwise,
 it is added if possible; an error is returned if the
 colormap is already full.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp, colormapped</param>
	<param name="pixm">1 bpp mask; no-op if NULL</param>
	<param name="x">origin of pixm relative to pixs; can be negative</param>
	<param name="y">origin of pixm relative to pixs; can be negative</param>
	<param name="rval">new color to set at each masked pixel</param>
	<param name="gval">new color to set at each masked pixel</param>
	<param name="bval">new color to set at each masked pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.parseForProtos(System.String,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.boxaGetWhiteblocks(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This uses the elegant Breuel algorithm, found in "Two
 Geometric Algorithms for Layout Analysis", 2002,
 url "citeseer.ist.psu.edu/breuel02two.html".
 It starts with the bounding boxes (b.b.) of the connected
 components (c.c.) in a region, along with the rectangle
 representing that region.  It repeatedly divides the
 rectangle into four maximal rectangles that exclude a
 pivot rectangle, sorting them in a priority queue
 according to one of the six sort flags.  It returns a boxa
 of the "largest" set that have no intersection with boxes
 from the input boxas.
 (2) If box == NULL, the initial region is the minimal region
 that includes the origin and every box in boxas.
 (3) maxboxes is the maximum number of whitespace boxes that will
 be returned.  The actual number will depend on the image
 and the values chosen for maxoverlap and maxpops.  In many
 cases, the actual number will be 'maxboxes'.
 (4) maxoverlap allows pruning of whitespace boxes depending on
 the overlap.  To avoid all pruning, use maxoverlap = 1.0.
 To select only boxes that have no overlap with each other
 (maximal pruning), choose maxoverlap = 0.0.
 Otherwise, no box can have more than the 'maxoverlap' fraction
 of its area overlapped by any larger (in the sense of the
 sortflag) box.
 (5) Choose maxperim (actually, maximum half-perimeter) to
 represent a c.c. that is small enough so that you don't care
 about the white space that could be inside of it.  For all such
 c.c., the pivot for 'quadfurcation' of a rectangle is selected
 as having a reasonable proximity to the rectangle centroid.
 (6) Use fract in the range [0.0 ... 1.0].  Set fract = 0.0
 to choose the small box nearest the centroid as the pivot.
 If you choose fract GT 0.0, it is suggested that you call
 boxaPermuteRandom() first, to permute the boxes (see usage below).
 This should reduce the search time for each of the pivot boxes.
 (7) Choose maxpops to be the maximum number of rectangles that
 are popped from the heap.  This is an indirect way to limit the
 execution time.  Use 0 for default (a fairly large number).
 At any time, you can expect the heap to contain about
 2.5 times as many boxes as have been popped off.
 (8) The output result is a sorted set of overlapping
 boxes, constrained by 'maxboxes', 'maxoverlap' and 'maxpops'.
 (9) The main defect of the method is that it abstracts out the
 actual components, retaining only the b.b. for analysis.
 Consider a component with a large b.b.  If this is chosen
 as a pivot, all white space inside is immediately taken
 out of consideration.  Furthermore, even if it is never chosen
 as a pivot, as the partitioning continues, at no time will
 any of the whitespace inside this component be part of a
 rectangle with zero overlapping boxes.  Thus, the interiors
 of all boxes are necessarily excluded from the union of
 the returned whitespace boxes.
 (10) It should be noted that the algorithm puts a large number
 of partels on the queue.  Setting a limit of X partels to
 remove from the queue, one typically finds that there will be
 several times that number (say, 2X - 3X) left on the queue.
 For an efficient algorithm to find the largest white or
 or black rectangles, without permitting them to overlap,
 see pixFindLargeRectangles().
 (11) USAGE One way to accommodate to this weakness is to remove such
 large b.b. before starting the computation.  For example,
 if 'box' is an input image region containing 'boxa' b.b. of c.c.
 // Faster pivot choosing
 boxaPermuteRandom(boxa, boxa);
 // Remove anything either large width or height
 boxat = boxaSelectBySize(boxa, maxwidth, maxheight,
 L_SELECT_IF_BOTH, L_SELECT_IF_LT,
 NULL);
 boxad = boxaGetWhiteblocks(boxat, box, type, maxboxes,
 maxoverlap, maxperim, fract,
 maxpops);
 The result will be rectangular regions of "white space" that
 extend into (and often through) the excluded components.
 (11) As a simple example, suppose you wish to find the columns on a page.
 First exclude large c.c. that may block the columns, and then call
 boxad = boxaGetWhiteblocks(boxa, box, L_SORT_BY_HEIGHT,
 20, 0.15, 200, 0.2, 2000);
 to get the 20 tallest boxes with no more than 0.15 overlap
 between a box and any of the taller ones, and avoiding the
 use of any c.c. with a b.b. half perimeter greater than 200
 as a pivot.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">typically, a set of bounding boxes of fg components</param>
	<param name="box">initial region; typically including all boxes in boxas; if null, it computes the region to include all boxes in boxas</param>
	<param name="sortflag">L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER, L_SORT_BY_AREA</param>
	<param name="maxboxes">maximum number of output whitespace boxes; e.g., 100</param>
	<param name="maxoverlap">maximum fractional overlap of a box by any of the larger boxes; e.g., 0.2</param>
	<param name="maxperim">maximum half-perimeter, in pixels, for which pivot is selected by proximity to box centroid; e.g., 200</param>
	<param name="fract">fraction of box diagonal that is an acceptable distance from the box centroid to select the pivot; e.g., 0.2</param>
	<param name="maxpops">maximum number of pops from the heap; use 0 as default</param>
	<returns>boxa of sorted whitespace boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaPruneSortedOnOverlap(System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) This selectively removes smaller boxes when they are overlapped
 by any larger box by more than the input 'maxoverlap' fraction.
 (2) To avoid all pruning, use maxoverlap = 1.0.  To select only
 boxes that have no overlap with each other (maximal pruning),
 set maxoverlap = 0.0.
 (3) If there are no boxes in boxas, returns an empty boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">sorted by size in decreasing order</param>
	<param name="maxoverlap">maximum fractional overlap of a box by any of the larger boxes</param>
	<returns>boxad pruned, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertFilesToPdf(System.String,System.String,System.Int32,System.Single,System.Int32,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) If %substr is not NULL, only image filenames that contain
 the substring can be used.  If %substr == NULL, all files
 in the directory are used.
 (2) The files in the directory, after optional filtering by
 the substring, are lexically sorted in increasing order
 before concatenation.
 (3) The scalefactor is applied to each image before encoding.
 If you enter a value LT= 0.0, it will be set to 1.0.
 (4) Specifying one of the three encoding types for %type forces
 all images to be compressed with that type.  Use 0 to have
 the type determined for each image based on depth and whether
 or not it has a colormap.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name containing images</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="res">input resolution of all images</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.saConvertFilesToPdf(System.IntPtr,System.Int32,System.Single,System.Int32,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) See convertFilesToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of pathnames for images</param>
	<param name="res">input resolution of all images</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.saConvertFilesToPdfData(System.IntPtr,System.Int32,System.Single,System.Int32,System.Int32,System.String,System.IntPtr@,System.UInt32@)">
	<summary>
 Notes
 (1) See convertFilesToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of pathnames for images</param>
	<param name="res">input resolution of all images</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="pdata">output pdf data (of all images</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selectDefaultPdfEncoding(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) This attempts to choose an encoding for the pix that results
 in the smallest file, assuming that if jpeg encoded, it will
 use quality = 75.  The decision is approximate, in that
 (a) all colormapped images will be losslessly encoded with
 gzip (flate), and (b) an image with less than about 20 colors
 is likely to be smaller if flate encoded than if encoded
 as a jpeg (dct).  For example, an image made by pixScaleToGray3()
 will have 10 colors, and flate encoding will give about
 twice the compression as jpeg with quality = 75.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="ptype">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertUnscaledFilesToPdf(System.String,System.String,System.String,System.String)">
	<summary>
 Notes
 (1) If %substr is not NULL, only image filenames that contain
 the substring can be used.  If %substr == NULL, all files
 in the directory are used.
 (2) The files in the directory, after optional filtering by
 the substring, are lexically sorted in increasing order
 before concatenation.
 (3) For jpeg and jp2k, this is very fast because the compressed
 data is wrapped up and concatenated.  For png and tiffg4,
 the images must be read and recompressed.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name containing images</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.saConvertUnscaledFilesToPdf(System.IntPtr,System.String,System.String)">
	<summary>
 Notes
 (1) See convertUnscaledFilesToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of pathnames for images</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.saConvertUnscaledFilesToPdfData(System.IntPtr,System.String,System.IntPtr@,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array of pathnames for images</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="pdata">output pdf data (of all images)</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertUnscaledToPdfData(System.String,System.String,System.IntPtr@,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">of image file</param>
	<param name="title">pdf title; can be NULL</param>
	<param name="pdata">output pdf data for image</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaConvertToPdf(System.IntPtr,System.Int32,System.Single,System.Int32,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without
 colormap and many colors, or 32 bpp; FLATE for anything else.
 (2) The scalefactor must be GT 0.0; otherwise it is set to 1.0.
 (3) Specifying one of the three encoding types for %type forces
 all images to be compressed with that type.  Use 0 to have
 the type determined for each image based on depth and whether
 or not it has a colormap.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">containing images all at the same resolution</param>
	<param name="res">override the resolution of each input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaConvertToPdfData(System.IntPtr,System.Int32,System.Single,System.Int32,System.Int32,System.String,System.IntPtr@,System.UInt32@)">
	<summary>
 Notes
 (1) See pixaConvertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">containing images all at the same resolution</param>
	<param name="res">input resolution of all images</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title</param>
	<param name="pdata">output pdf data (of all images</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertToPdf(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) To wrap only one image in pdf, input %plpd = NULL, and
 the value of %position will be ignored
 convertToPdf(...  type, quality, x, y, res, NULL, 0);
 (2) To wrap multiple images on a single pdf page, this is called
 once for each successive image.  Do it this way
 L_PDF_DATA   lpd;
 convertToPdf(...  type, quality, x, y, res, lpd, L_FIRST_IMAGE);
 convertToPdf(...  type, quality, x, y, res, lpd, L_NEXT_IMAGE);
 ...
 convertToPdf(...  type, quality, x, y, res, lpd, L_LAST_IMAGE);
 This will write the result to the value of %fileout specified
 in the first call; succeeding values of %fileout are ignored.
 On the last call the pdf data bytes are computed and written
 to %fileout, lpd is destroyed internally, and the returned
 value of lpd is null.  So the client has nothing to clean up.
 (3) (a) Set %res == 0 to respect the resolution embedded in the
 image file.  If no resolution is embedded, it will be set
 to the default value.
 (b) Set %res to some other value to override the file resolution.
 (4) (a) If the input %res and the resolution of the output device
 are equal, the image will be "displayed" at the same size
 as the original.
 (b) If the input %res is 72, the output device will render
 the image at 1 pt/pixel.
 (c) Some possible choices for the default input pix resolution are
 72 ppi  Render pix on any output device at one pt/pixel
 96 ppi  Windows default for generated display images
 300 ppi  Typical default for scanned images.
 We choose 300, which is sensible for rendering page images.
 However,  images come from a variety of sources, and
 some are explicitly created for viewing on a display.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input image file -- any format</param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="fileout">output pdf file; only required on last image on page</param>
	<param name="x">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="y">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title; if null, taken from filein</param>
	<param name="plpd">ptr to lpd, which is created on the first invocation and returned until last image is processed, at which time it is destroyed</param>
	<param name="position">in image sequence L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertImageDataToPdf(System.Byte[],System.UInt32,System.Int32,System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) If %res == 0 and the input resolution field is 0,
 this will use DEFAULT_INPUT_RES.
 (2) See comments in convertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="imdata">array of formatted image data; e.g., png, jpeg</param>
	<param name="size">size of image data</param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="fileout">output pdf file; only required on last image on page</param>
	<param name="x">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="y">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title</param>
	<param name="plpd">ptr to lpd, which is created on the first invocation and returned until last image is processed, at which time it is destroyed</param>
	<param name="position">in image sequence L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertToPdfData(System.String,System.Int32,System.Int32,System.IntPtr@,System.UInt32@,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) If %res == 0 and the input resolution field is 0,
 this will use DEFAULT_INPUT_RES.
 (2) See comments in convertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input image file -- any format</param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="pdata">pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<param name="x">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="y">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title; if null, use filein</param>
	<param name="plpd">ptr to lpd, which is created on the first invocation and returned until last image is processed, at which time it is destroyed</param>
	<param name="position">in image sequence L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertImageDataToPdfData(System.Byte[],System.UInt32,System.Int32,System.Int32,System.IntPtr@,System.UInt32@,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) If %res == 0 and the input resolution field is 0,
 this will use DEFAULT_INPUT_RES.
 (2) See comments in convertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="imdata">array of formatted image data; e.g., png, jpeg</param>
	<param name="size">size of image data</param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="pdata">pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<param name="x">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="y">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title</param>
	<param name="plpd">ptr to lpd, which is created on the first invocation and returned until last image is processed, at which time it is destroyed</param>
	<param name="position">in image sequence L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertToPdf(System.IntPtr,System.Int32,System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) If %res == 0 and the input resolution field is 0,
 this will use DEFAULT_INPUT_RES.
 (2) This only writes data to fileout if it is the last
 image to be written on the page.
 (3) See comments in convertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="fileout">output pdf file; only required on last image on page</param>
	<param name="x">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0 at the lower-left corner of the page)</param>
	<param name="y">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0 at the lower-left corner of the page)</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title</param>
	<param name="plpd">ptr to lpd, which is created on the first invocation and returned until last image is processed</param>
	<param name="position">in image sequence L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamPdf(System.IntPtr,System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) This is the simplest interface for writing a single image
 with pdf encoding to a stream.  It uses G4 encoding for 1 bpp,
 JPEG encoding for 8 bpp (no cmap) and 32 bpp, and FLATE
 encoding for everything else.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for writing</param>
	<param name="pix">all depths, cmap OK</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title; taken from the first image placed on a page; e.g., an input image filename</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMemPdf(System.IntPtr@,System.UInt32@,System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) This is the simplest interface for writing a single image
 with pdf encoding to memory.  It uses G4 encoding for 1 bpp,
 JPEG encoding for 8 bpp (no cmap) and 32 bpp, and FLATE
 encoding for everything else.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">pdf as byte array</param>
	<param name="pnbytes">number of bytes in pdf array</param>
	<param name="pix">all depths, cmap OK</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title; taken from the first image placed on a page; e.g., an input image filename</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertSegmentedFilesToPdf(System.String,System.String,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Single,System.String,System.String)">
	<summary>
 Notes
 (1) If %substr is not NULL, only image filenames that contain
 the substring can be used.  If %substr == NULL, all files
 in the directory are used.
 (2) The files in the directory, after optional filtering by
 the substring, are lexically sorted in increasing order
 before concatenation.
 (3) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without
 colormap and many colors, or 32 bpp; FLATE for anything else.
 (4) The boxaa, if it exists, contains one boxa of "image regions"
 for each image file.  The boxa must be aligned with the
 sorted set of images.
 (5) The scalefactor is applied to each image region.  It is
 typically LT 1.0, to save bytes in the final pdf, because
 the resolution is often not critical in non-text regions.
 (6) If the non-image regions have pixel depth GT 1 and the encoding
 type is G4, they are automatically scaled up by 2x and
 thresholded.  Otherwise, no scaling is performed on them.
 (7) Note that this function can be used to generate multipage
 G4 compressed pdf from any input, by using %boxaa == NULL
 and %type == L_G4_ENCODE.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name containing images</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="res">input resolution of all images</param>
	<param name="type">compression type for non-image regions; the image regions are always compressed with L_JPEG_ENCODE</param>
	<param name="thresh">used for converting gray --GT 1 bpp with L_G4_ENCODE</param>
	<param name="baa">boxaa of image regions</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="scalefactor">scaling factor applied to each image region</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertNumberedMasksToBoxaa(System.String,System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is conveniently used to generate the input boxaa
 for convertSegmentedFilesToPdf().  It guarantees that the
 boxa will be aligned with the page images, even if some
 of the boxa are empty.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name containing mask images</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="numpre">number of characters in name before number</param>
	<param name="numpost">number of characters in name after number, up to a dot before an extension including an extension and the dot separator</param>
	<returns>boxaa of mask regions, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertToPdfSegmented(System.String,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Single,System.String,System.String)">
	<summary>
 Notes
 (1) If there are no image regions, set %boxa == NULL;
 %quality and %scalefactor are ignored.
 (2) Typically, %scalefactor is LT 1.0, because the image regions
 can be rendered at a lower resolution (for better compression)
 than the text regions.  If %scalefactor == 0, we use 1.0.
 If the input image is 1 bpp and scalefactor LT 1.0, we
 use scaleToGray() to downsample the image regions to gray
 before compressing them.
 (3) If the compression type for non-image regions is L_G4_ENCODE
 and bpp GT 1, the image is upscaled 2x and thresholded
 to 1 bpp.  That is the only situation where %thresh is used.
 (4) The parameter %quality is only used for image regions.
 If %type == L_JPEG_ENCODE, default jpeg quality (75) is
 used for the non-image regions.
 (5) Processing matrix for non-image regions.
 Input  G4  JPEG FLATE
 ----------|---------------------------------------------------
 1 bpp  |  1x, 1 bpp 1x flate, 1 bpp  1x, 1 bpp
 |
 cmap   |  2x, 1 bpp 1x flate, cmap   1x, cmap
 |
 2,4 bpp   |  2x, 1 bpp 1x flate   1x, 2,4 bpp
 no cmap   |   2,4 bpp
 |
 8,32 bpp  |  2x, 1 bpp 1x (jpeg)  1x, 8,32 bpp
 no cmap   |   8,32 bpp
 Summary
 (a) if G4 is requested, G4 is used, with 2x upscaling
 for all cases except 1 bpp.
 (b) if JPEG is requested, use flate encoding for all cases
 except 8 bpp without cmap and 32 bpp (rgb).
 (c) if FLATE is requested, use flate with no transformation
 of the raster data.
 (6) Calling options/sequence for these functions
 file  --GT  file   (convertToPdfSegmented)
 pix  --GT  file   (pixConvertToPdfSegmented)
 pix  --GT  data   (pixConvertToPdfDataSegmented)
 file  --GT  data   (convertToPdfDataSegmented)
 pix  --GT  data   (pixConvertToPdfDataSegmented)
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input image file -- any format</param>
	<param name="res">input image resolution; typ. 300 ppi; use 0 for default</param>
	<param name="type">compression type for non-image regions; the image regions are always compressed with L_JPEG_ENCODE</param>
	<param name="thresh">used for converting gray --GT 1 bpp with L_G4_ENCODE</param>
	<param name="boxa">of image regions; can be null</param>
	<param name="quality">used for jpeg image regions; 0 for default</param>
	<param name="scalefactor">used for jpeg regions; must be LT= 1.0</param>
	<param name="title">pdf title; typically taken from the input file for the pix</param>
	<param name="fileout">output pdf file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertToPdfSegmented(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Single,System.String,System.String)">
	<summary>
 Notes
 (1) See convertToPdfSegmented() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, cmap OK</param>
	<param name="res">input image resolution; typ. 300 ppi; use 0 for default</param>
	<param name="type">compression type for non-image regions; the image regions are always compressed with L_JPEG_ENCODE</param>
	<param name="thresh">used for converting gray --GT 1 bpp with L_G4_ENCODE</param>
	<param name="boxa">of image regions; can be null</param>
	<param name="quality">used for jpeg image regions; 0 for default</param>
	<param name="scalefactor">used for jpeg regions; must be LT= 1.0</param>
	<param name="title">pdf title; typically taken from the input file for the pix</param>
	<param name="fileout">output pdf file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertToPdfDataSegmented(System.String,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Single,System.String,System.IntPtr@,System.UInt32@)">
	<summary>
 Notes
 (1) If there are no image regions, set %boxa == NULL;
 %quality and %scalefactor are ignored.
 (2) Typically, %scalefactor is LT 1.0.  The image regions are
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input image file -- any format</param>
	<param name="res">input image resolution; typ. 300 ppi; use 0 for default</param>
	<param name="type">compression type for non-image regions; the image regions are always compressed with L_JPEG_ENCODE</param>
	<param name="thresh">used for converting gray --GT 1 bpp with L_G4_ENCODE</param>
	<param name="boxa">image regions; can be null</param>
	<param name="quality">used for jpeg image regions; 0 for default</param>
	<param name="scalefactor">used for jpeg regions; must be LT= 1.0</param>
	<param name="title">pdf title; if null, uses filein</param>
	<param name="pdata">pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertToPdfDataSegmented(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Single,System.String,System.IntPtr@,System.UInt32@)">
	<summary>
 Notes
 (1) See convertToPdfSegmented() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, cmap OK</param>
	<param name="res">input image resolution; typ. 300 ppi; use 0 for default</param>
	<param name="type">compression type for non-image regions; the image regions are always compressed with L_JPEG_ENCODE</param>
	<param name="thresh">used for converting gray --GT 1 bpp with L_G4_ENCODE</param>
	<param name="boxa">of image regions; can be null</param>
	<param name="quality">used for jpeg image regions; 0 for default</param>
	<param name="scalefactor">used for jpeg regions; must be LT= 1.0</param>
	<param name="title">pdf title; typically taken from the input file for the pix</param>
	<param name="pdata">pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.concatenatePdf(System.String,System.String,System.String)">
	<summary>
 Notes
 (1) This only works with leptonica-formatted single-page pdf files.
 (2) If %substr is not NULL, only filenames that contain
 the substring can be returned.  If %substr == NULL,
 none of the filenames are filtered out.
 (3) The files in the directory, after optional filtering by
 the substring, are lexically sorted in increasing order
 before concatenation.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name containing single-page pdf files</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="fileout">concatenated pdf file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.saConcatenatePdf(System.IntPtr,System.String)">
	<summary>
 Notes
 (1) This only works with leptonica-formatted single-page pdf files.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of pathnames for single-page pdf files</param>
	<param name="fileout">concatenated pdf file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraConcatenatePdf(System.IntPtr,System.String)">
	<summary>
 Notes
 (1) This only works with leptonica-formatted single-page pdf files.
 </summary>
	<remarks>
	</remarks>
	<param name="pa">array of pdf strings, each for a single-page pdf file</param>
	<param name="fileout">concatenated pdf file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.concatenatePdfToData(System.String,System.String,System.IntPtr@,System.UInt32@)">
	<summary>
 Notes
 (1) This only works with leptonica-formatted single-page pdf files.
 (2) If %substr is not NULL, only filenames that contain
 the substring can be returned.  If %substr == NULL,
 none of the filenames are filtered out.
 (3) The files in the directory, after optional filtering by
 the substring, are lexically sorted in increasing order
 before concatenation.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name containing single-page pdf files</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="pdata">concatenated pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.saConcatenatePdfToData(System.IntPtr,System.IntPtr@,System.UInt32@)">
	<summary>
 Notes
 (1) This only works with leptonica-formatted single-page pdf files.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of pathnames for single-page pdf files</param>
	<param name="pdata">concatenated pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertToPdfData(System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.UInt32@,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) If %res == 0 and the input resolution field is 0,
 this will use DEFAULT_INPUT_RES.
 (2) This only writes %data if it is the last image to be
 written on the page.
 (3) See comments in convertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; cmap OK</param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="pdata">pdf array</param>
	<param name="pnbytes">number of bytes in pdf array</param>
	<param name="x">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page)</param>
	<param name="y">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page)</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title</param>
	<param name="plpd">ptr to lpd, which is created on the first invocation and returned until last image is processed</param>
	<param name="position">in image sequence L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraConcatenatePdfToData(System.IntPtr,System.IntPtr,System.IntPtr@,System.UInt32@)">
	<summary>
 Notes
 (1) This only works with leptonica-formatted single-page pdf files.
 pdf files generated by other programs will have unpredictable
 (and usually bad) results.  The requirements for each pdf file
 (a) The Catalog and Info objects are the first two.
 (b) Object 3 is Pages
 (c) Object 4 is Page
 (d) The remaining objects are Contents, XObjects, and ColorSpace
 (2) We remove trailers from each page, and append the full trailer
 for all pages at the end.
 (3) For all but the first file, remove the ID and the first 3
 objects (catalog, info, pages), so that each subsequent
 file has only objects of these classes
 Page, Contents, XObject, ColorSpace (Indexed RGB).
 For those objects, we substitute these refs to objects
 in the local file
 Page  Parent(object 3), Contents, XObject(typically multiple)
 XObject  [ColorSpace if indexed]
 The Pages object on the first page (object 3) has a Kids array
 of references to all the Page objects, with a Count equal
 to the number of pages.  Each Page object refers back to
 this parent.
 </summary>
	<remarks>
	</remarks>
	<param name="pa_data">ptra array of pdf strings, each for a single-page pdf file</param>
	<param name="sa">string array [optional] of pathnames for input pdf files</param>
	<param name="pdata">concatenated pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertTiffMultipageToPdf(System.String,System.String)">
	<summary>
 Notes
 (1) A multipage tiff file can also be converted to PS, using
 convertTiffMultipageToPS()
 </summary>
	<remarks>
	</remarks>
	<param name="filein">(tiff)</param>
	<param name="fileout">(pdf)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_generateCIDataForPdf(System.String,System.IntPtr,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) You must set either filename or pix.
 (2) Given an image file and optionally a pix raster of that data,
 this provides a CID that is compatible with PDF, preferably
 without transcoding.
 (3) The pix is included for efficiency, in case transcoding
 is required and the pix is available to the caller.
 (4) We don't try to open files named "stdin" or "-" for Tesseract
 compatibility reasons. We may remove this restriction
 in the future.
 </summary>
	<remarks>
	</remarks>
	<param name="fname">; can be null</param>
	<param name="pix">; can be null</param>
	<param name="quality">for jpeg if transcoded; 75 is standard</param>
	<param name="pcid">compressed data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_generateFlateDataPdf(System.String,System.IntPtr)">
	<summary>
 Notes
 (1) If you hand this a png file, you are going to get
 png predictors embedded in the flate data. So it has
 come to this. http//xkcd.com/1022/
 (2) Exception if the png is interlaced or if it is RGBA,
 it will be transcoded.
 (3) If transcoding is required, this will not have to read from
 file if you also input a pix.
 </summary>
	<remarks>
	</remarks>
	<param name="fname">preferably png</param>
	<param name="pixs">; can be null</param>
	<returns>cid containing png data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_generateJpegData(System.String,System.Int32)">
	<summary>
 Notes
 (1) Set ascii85flag
 ~ 0 for binary data (not permitted in PostScript)
 ~ 1 for ascii85 (5 for 4) encoded binary data
 (not permitted in pdf)
 (2) Do not free the data.  l_generateJpegDataMem() will free
 the data if it does not use ascii encoding.
 </summary>
	<remarks>
	</remarks>
	<param name="fname">of jpeg file</param>
	<param name="ascii85flag">0 for jpeg; 1 for ascii85-encoded jpeg</param>
	<returns>cid containing jpeg data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_generateJpegDataMem(System.Byte[],System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) See l_generateJpegData().
 </summary>
	<remarks>
	</remarks>
	<param name="data">of jpeg file</param>
	<param name="nbytes"></param>
	<param name="ascii85flag">0 for jpeg; 1 for ascii85-encoded jpeg</param>
	<returns>cid containing jpeg data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_generateCIData(System.String,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) This can be used for both PostScript and pdf.
 (1) Set ascii85
 ~ 0 for binary data (not permitted in PostScript)
 ~ 1 for ascii85 (5 for 4) encoded binary data
 (2) This attempts to compress according to the requested type.
 If this can't be done, it falls back to ordinary flate encoding.
 (3) This differs from l_generateCIDataPdf(), which determines
 the format and attempts to generate the CID without transcoding.
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE, L_JP2K_ENCODE</param>
	<param name="quality">used for jpeg only; 0 for default (75)</param>
	<param name="ascii85">0 for binary; 1 for ascii85-encoded</param>
	<param name="pcid">compressed data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenerateCIData(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) Set ascii85
 ~ 0 for binary data (not permitted in PostScript)
 ~ 1 for ascii85 (5 for 4) encoded binary data
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp, no colormap</param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for jpeg only; 0 for default (75)</param>
	<param name="ascii85">0 for binary; 1 for ascii85-encoded</param>
	<param name="pcid">compressed data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_generateFlateData(System.String,System.Int32)">
	<summary>
 Notes
 (1) The input image is converted to one of these 4 types
 ~ 1 bpp
 ~ 8 bpp, no colormap
 ~ 8 bpp, colormap
 ~ 32 bpp rgb
 (2) Set ascii85flag
 ~ 0 for binary data (not permitted in PostScript)
 ~ 1 for ascii85 (5 for 4) encoded binary data
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="ascii85flag">0 for gzipped; 1 for ascii85-encoded gzipped</param>
	<returns>cid flate compressed image data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_generateG4Data(System.String,System.Int32)">
	<summary>
 Notes
 (1) Set ascii85flag
 ~ 0 for binary data (not permitted in PostScript)
 ~ 1 for ascii85 (5 for 4) encoded binary data
 (not permitted in pdf)
 </summary>
	<remarks>
	</remarks>
	<param name="fname">of g4 compressed file</param>
	<param name="ascii85flag">0 for g4 compressed; 1 for ascii85-encoded g4</param>
	<returns>cid g4 compressed image data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.cidConvertToPdfData(System.IntPtr,System.String,System.IntPtr@,System.UInt32@)">
	<summary>
 Notes
 (1) Caller must not destroy the cid.  It is absorbed in the
 lpd and destroyed by this function.
 </summary>
	<remarks>
	</remarks>
	<param name="cid">compressed image data -- of jp2k image</param>
	<param name="title">pdf title; can be NULL</param>
	<param name="pdata">output pdf data for image</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_CIDataDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pcid">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp.Natives.l_pdfSetG4ImageMask(System.Int32)">
	<summary>
 Notes
 (1) The default is for writing only the fg (through the mask).
 That way when you write a 1 bpp image, the bg is transparent,
 so any previously written image remains visible behind it.
 </summary>
	<remarks>
	</remarks>
	<param name="flag">1 for writing g4 data as fg only through a mask; 0 for writing fg and bg</param>
</member><member name="M:LeptonicaSharp.Natives.l_pdfSetDateAndVersion(System.Int32)">
	<summary>
 Notes
 (1) The default is for writing this data.  For regression tests
 that compare output against golden files, it is useful to omit.
 </summary>
	<remarks>
	</remarks>
	<param name="flag">1 for writing date/time and leptonica version; 0 for omitting this from the metadata</param>
</member><member name="M:LeptonicaSharp.Natives.setPixMemoryManager(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Use this to change the alloc and/or dealloc functions;
 e.g., setPixMemoryManager(my_malloc, my_free).
 (2) The C99 standard (section 6.7.5.3, par. 8) says
 A declaration of a parameter as "function returning type"
 shall be adjusted to "pointer to function returning type"
 so that it can be in either of these two forms
 (a) type (function-ptr(type, ...))
 (b) type ((function-ptr)(type, ...))
 because form (a) is implictly converted to form (b), as in the
 definition of struct PixMemoryManager above.  So, for example,
 we should be able to declare either of these
 (a) void (allocator(size_t))
 (b) void ((allocator)(size_t))
 However, MSVC++ only accepts the second version.
 </summary>
	<remarks>
	</remarks>
	<param name="allocator">use NULL to skip</param>
	<param name="deallocator">use NULL to skip</param>
</member><member name="M:LeptonicaSharp.Natives.pixCreate(System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="width"></param>
	<param name="height"></param>
	<param name="depth"></param>
	<returns>pixd with data allocated and initialized to 0, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCreateNoInit(System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Must set pad bits to avoid reading uninitialized data, because
 some optimized routines (e.g., pixConnComp()) read from pad bits.
 </summary>
	<remarks>
	</remarks>
	<param name="width"></param>
	<param name="height"></param>
	<param name="depth"></param>
	<returns>pixd with data allocated but not initialized, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCreateTemplate(System.IntPtr)">
	<summary>
 Notes
 (1) Makes a Pix of the same size as the input Pix, with the
 data array allocated and initialized to 0.
 (2) Copies the other fields, including colormap if it exists.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCreateTemplateNoInit(System.IntPtr)">
	<summary>
 Notes
 (1) Makes a Pix of the same size as the input Pix, with
 the data array allocated but not initialized to 0.
 (2) Copies the other fields, including colormap if it exists.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCreateHeader(System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) It is assumed that all 32 bit pix have 3 spp.  If there is
 a valid alpha channel, this will be set to 4 spp later.
 (2) If the number of bytes to be allocated is larger than the
 maximum value in an int32, we can get overflow, resulting
 in a smaller amount of memory actually being allocated.
 Later, an attempt to access memory that wasn't allocated will
 cause a crash.  So to avoid crashing a program (or worse)
 with bad (or malicious) input, this is where we limit the
 requested allocation of image data in a typesafe way.
 </summary>
	<remarks>
	</remarks>
	<param name="width"></param>
	<param name="height"></param>
	<param name="depth"></param>
	<returns>pixd with no data allocated, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixClone(System.IntPtr)">
	<summary>
 Notes
 (1) A "clone" is simply a handle (ptr) to an existing pix.
 It is implemented because (a) images can be large and
 hence expensive to copy, and (b) extra handles to a data
 structure need to be made with a simple policy to avoid
 both double frees and memory leaks.  Pix are reference
 counted.  The side effect of pixClone() is an increase
 by 1 in the ref count.
 (2) The protocol to be used is
 (a) Whenever you want a new handle to an existing image,
 call pixClone(), which just bumps a ref count.
 (b) Always call pixDestroy() on all handles.  This
 decrements the ref count, nulls the handle, and
 only destroys the pix when pixDestroy() has been
 called on all handles.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>same pix ptr, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the pix.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppix">will be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.pixCopy(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) There are three cases
 (a) pixd == null  (makes a new pix; refcount = 1)
 (b) pixd == pixs  (no-op)
 (c) pixd != pixs  (data copy; no change in refcount)
 If the refcount of pixd GT 1, case (c) will side-effect
 these handles.
 (2) The general pattern of use is
 pixd = pixCopy(pixd, pixs);
 This will work for all three cases.
 For clarity when the case is known, you can use
 (a) pixd = pixCopy(NULL, pixs);
 (c) pixCopy(pixd, pixs);
 (3) For case (c), we check if pixs and pixd are the same
 size (w,h,d).  If so, the data is copied directly.
 Otherwise, the data is reallocated to the correct size
 and the copy proceeds.  The refcount of pixd is unchanged.
 (4) This operation, like all others that may involve a pre-existing
 pixd, will side-effect any existing clones of pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be null, equal to pixs, different from pixs</param>
	<param name="pixs"></param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixResizeImageData(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) If the sizes of data in pixs and pixd are unequal, this
 frees the existing image data in pixd and allocates
 an uninitialized buffer that will hold the required amount
 of image data in pixs.  The image data from pixs is not
 copied into the new buffer.
 (2) On failure to allocate, pixd is unchanged.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">gets new uninitialized buffer for image data</param>
	<param name="pixs">determines the size of the buffer; not changed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCopyColormap(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This always destroys any colormap in pixd (except if
 the operation is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd"></param>
	<param name="pixs">copies the colormap to %pixd</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSizesEqual(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix1"></param>
	<param name="pix2"></param>
	<returns>1 if the two pix have same {h, w, d}; 0 otherwise.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixTransferAllData(System.IntPtr,System.IntPtr@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does a complete data transfer from pixs to pixd,
 followed by the destruction of pixs (refcount permitting).
 (2) If the refcount of pixs is 1, pixs is destroyed.  Otherwise,
 the data in pixs is copied (rather than transferred) to pixd.
 (3) This operation, like all others with a pre-existing pixd,
 will side-effect any existing clones of pixd.  The pixd
 refcount does not change.
 (4) When might you use this?  Suppose you have an in-place Pix
 function (returning void) with the typical signature
 void function-inplace(PIX pix, ...)
 where "..." are non-pointer input parameters, and suppose
 further that you sometimes want to return an arbitrary Pix
 in place of the input Pix.  There are two ways you can do this
 (a) The straightforward way is to change the function
 signature to take the address of the Pix ptr
 \code
 void function-inplace(PIX ppix, ...) {
 PIX pixt = function-makenew(ppix);
 pixDestroy(ppix);
 ppix = pixt;
 return;
 }
 \endcode
 Here, the input and returned pix are different, as viewed
 by the calling function, and the inplace function is
 expected to destroy the input pix to avoid a memory leak.
 (b) Keep the signature the same and use pixTransferAllData()
 to return the new Pix in the input Pix struct
 \code
 void function-inplace(PIX pix, ...) {
 PIX pixt = function-makenew(pix);
 pixTransferAllData(pix, pixt, 0, 0);
 // pixDestroy() is called on pixt
 return;
 }
 \endcode
 Here, the input and returned pix are the same, as viewed
 by the calling function, and the inplace function must
 never destroy the input pix, because the calling function
 maintains an unchanged handle to it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">must be different from pixs</param>
	<param name="ppixs">will be nulled if refcount goes to 0</param>
	<param name="copytext">1 to copy the text field; 0 to skip</param>
	<param name="copyformat">1 to copy the informat field; 0 to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSwapAndDestroy(System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) Simple operation to change the handle name safely.
 After this operation, the original image in pixd has
 been destroyed, pixd points to what was pixs, and
 the input pixs ptr has been nulled.
 (2) This works safely whether or not pixs and pixd are cloned.
 If pixs is cloned, the other handles still point to
 the original image, with the ref count reduced by 1.
 (3) Usage example
 \code
 Pix pix1 = pixRead("...");
 Pix pix2 = function(pix1, ...);
 pixSwapAndDestroy(pix1, pix2);
 pixDestroy(pix1);  // holds what was in pix2
 \endcode
 Example with clones ([] shows ref count of image generated
 by the function)
 \code
 Pix pixs = pixRead("...");
 Pix pix1 = pixClone(pixs);
 Pix pix2 = function(pix1, ...);   [1]
 Pix pix3 = pixClone(pix2);   [1] --GT [2]
 pixSwapAndDestroy(pix1, pix2);
 pixDestroy(pixs);  // still holds read image
 pixDestroy(pix1);  // holds what was in pix2  [2] --GT [1]
 pixDestroy(pix3);  // holds what was in pix2  [1] --GT [0]
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="ppixd">input pixd can be null, and it must be different from pixs</param>
	<param name="ppixs">will be nulled after the swap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetWidth(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetWidth(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetHeight(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetHeight(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetDepth(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetDepth(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetDimensions(System.IntPtr,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<param name="pd">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetDimensions(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="w">use 0 to skip the setting for any of these</param>
	<param name="h">use 0 to skip the setting for any of these</param>
	<param name="d">use 0 to skip the setting for any of these</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCopyDimensions(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd"></param>
	<param name="pixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetSpp(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetSpp(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixCopySpp(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd"></param>
	<param name="pixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetWpl(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetWpl(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRefcount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixChangeRefcount(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetXRes(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetXRes(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetYRes(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetYRes(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetResolution(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="pxres">each can be null</param>
	<param name="pyres">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetResolution(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="xres">use 0 to skip setting a value for either of these</param>
	<param name="yres">use 0 to skip setting a value for either of these</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCopyResolution(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleResolution(System.IntPtr,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetInputFormat(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetInputFormat(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixCopyInputFormat(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetSpecial(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetText(System.IntPtr)">
	<summary>
 Notes
 (1) The text string belongs to the pix.  The caller must
 NOT free it!
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>ptr to existing text string</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetText(System.IntPtr,System.String)">
	<summary>
 Notes
 (1) This removes any existing textstring and puts a copy of
 the input textstring there.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="textstring"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddText(System.IntPtr,System.String)">
	<summary>
 Notes
 (1) This adds the new textstring to any existing text.
 (2) Either or both the existing text and the new text
 string can be null.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="textstring"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCopyText(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetColormap(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetColormap(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Unlike with the pix data field, pixSetColormap() destroys
 any existing colormap before assigning the new one.
 Because colormaps are not ref counted, it is important that
 the new colormap does not belong to any other pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="colormap">to be assigned</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDestroyColormap(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetData(System.IntPtr)">
	<summary>
 Notes
 (1) This gives a new handle for the data.  The data is still
 owned by the pix, so do not call LEPT_FREE() on it.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>ptr to image data</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetData(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This does not free any existing data.  To free existing
 data, use pixFreeData() before pixSetData().
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="data"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExtractData(System.IntPtr)">
	<summary>
 Notes
 (1) This extracts the pix image data for use in another context.
 The caller still needs to use pixDestroy() on the input pix.
 (2) If refcount == 1, the data is extracted and the
 pix-GTdata ptr is set to NULL.
 (3) If refcount GT 1, this simply returns a copy of the data,
 using the pix allocator, and leaving the input pix unchanged.
 </summary>
	<remarks>
	</remarks>
	<returns>ptr to data, or null on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFreeData(System.IntPtr)">
	<summary>
 Notes
 (1) This frees the data and sets the pix data ptr to null.
 It should be used before pixSetData() in the situation where
 you want to free any existing data before doing
 a subsequent assignment with pixSetData().
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetLinePtrs(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) This is intended to be used for fast random pixel access.
 For example, for an 8 bpp image,
 val = GET_DATA_BYTE(lines8[i], j);
 is equivalent to, but much faster than,
 pixGetPixel(pix, j, i, val);
 (2) How much faster?  For 1 bpp, it's from 6 to 10x faster.
 For 8 bpp, it's an amazing 30x faster.  So if you are
 doing random access over a substantial part of the image,
 use this line ptr array.
 (3) When random access is used in conjunction with a stack,
 queue or heap, the overall computation time depends on
 the operations performed on each struct that is popped
 or pushed, and whether we are using a priority queue (O(logn))
 or a queue or stack (O(1)).  For example, for maze search,
 the overall ratio of time for line ptrs vs. pixGet/Set is
 Maze type  Type    Time ratio
 binary   queue   0.4
 gray  heap (priority queue)  0.6
 (4) Because this returns a void and the accessors take void,
 the compiler cannot check the pointer types.  It is
 strongly recommended that you adopt a naming scheme for
 the returned ptr arrays that indicates the pixel depth.
 (This follows the original intent of Simonyi's "Hungarian"
 application notation, where naming is used proactively
 to make errors visibly obvious.)  By doing this, you can
 tell by inspection if the correct accessor is used.
 For example, for an 8 bpp pixg
 void lineg8 = pixGetLinePtrs(pixg, NULL);
 val = GET_DATA_BYTE(lineg8[i], j);  // fast access; BYTE, 8
 ...
 LEPT_FREE(lineg8);  // don't forget this
 (5) These are convenient for accessing bytes sequentially in an
 8 bpp grayscale image.  People who write image processing code
 on 8 bpp images are accustomed to grabbing pixels directly out
 of the raster array.  Note that for little endians, you first
 need to reverse the byte order in each 32-bit word.
 Here's a typical usage pattern
 pixEndianByteSwap(pix);   // always safe; no-op on big-endians
 l_uint8 lineptrs = (l_uint8 )pixGetLinePtrs(pix, NULL);
 pixGetDimensions(pix, w, h, NULL);
 for (i = 0; i LT h; i++) {
 l_uint8 line = lineptrs[i];
 for (j = 0; j LT w; j++) {
 val = line[j];
 ...
 }
 }
 pixEndianByteSwap(pix);  // restore big-endian order
 LEPT_FREE(lineptrs);
 This can be done even more simply as follows
 l_uint8 lineptrs = pixSetupByteProcessing(pix, w, h);
 for (i = 0; i LT h; i++) {
 l_uint8 line = lineptrs[i];
 for (j = 0; j LT w; j++) {
 val = line[j];
 ...
 }
 }
 pixCleanupByteProcessing(pix, lineptrs);
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="psize">array size, which is the pix height</param>
	<returns>array of line ptrs, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixPrintStreamInfo(System.IntPtr,System.IntPtr,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix"></param>
	<param name="text">identifying string; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetPixel(System.IntPtr,System.Int32,System.Int32,System.UInt32@)">
	<summary>
 Notes
 (1) This returns the value in the data array.  If the pix is
 colormapped, it returns the colormap index, not the rgb value.
 (2) Because of the function overhead and the parameter checking,
 this is much slower than using the GET_DATA_() macros directly.
 Speed on a 1 Mpixel RGB image, using a 3 GHz machine
 pixGet/pixSet ~25 Mpix/sec
 GET_DATA/SET_DATA ~350 MPix/sec
 If speed is important and you're doing random access into
 the pix, use pixGetLinePtrs() and the array access macros.
 (3) If the point is outside the image, this returns an error (1),
 with 0 in %pval.  To avoid spamming output, it fails silently.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="x">,y    pixel coords</param>
	<param name="pval">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetPixel(System.IntPtr,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) Warning the input value is not checked for overflow with respect
 the the depth of %pix, and the sign bit (if any) is ignored.
 For d == 1, %val GT 0 sets the bit on.
 For d == 2, 4, 8 and 16, %val is masked to the maximum allowable
 pixel value, and any (invalid) higher order bits are discarded.
 (2) See pixGetPixel() for information on performance.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="x">,y   pixel coords</param>
	<param name="val">value to be inserted</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRGBPixel(System.IntPtr,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb, not colormapped</param>
	<param name="x">,y    pixel coords</param>
	<param name="prval">red component</param>
	<param name="pgval">green component</param>
	<param name="pbval">blue component</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetRGBPixel(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="x">,y    pixel coords</param>
	<param name="rval">red component</param>
	<param name="gval">green component</param>
	<param name="bval">blue component</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRandomPixel(System.IntPtr,System.UInt32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If the pix is colormapped, it returns the rgb value.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; can be colormapped</param>
	<param name="pval">pixel value</param>
	<param name="px">x coordinate chosen; can be null</param>
	<param name="py">y coordinate chosen; can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixClearPixel(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; warning if colormapped</param>
	<param name="x">,y   pixel coords</param>
	<returns>0 if OK; 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFlipPixel(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, warning if colormapped</param>
	<param name="x">,y   pixel coords</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.setPixelLow(System.IntPtr,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) Caution input variables are not checked!
 </summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of line,</param>
	<param name="x">pixel location in line</param>
	<param name="depth">bpp</param>
	<param name="val">to be inserted</param>
</member><member name="M:LeptonicaSharp.Natives.pixGetBlackOrWhiteVal(System.IntPtr,System.Int32,System.UInt32@)">
	<summary>
 Notes
 (1) Side effect.  For a colormapped image, if the requested
 color is not present and there is room to add it in the cmap,
 it is added and the new index is returned.  If there is no room,
 the index of the closest color in intensity is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; cmap ok</param>
	<param name="op">L_GET_BLACK_VAL, L_GET_WHITE_VAL</param>
	<param name="pval">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixClearAll(System.IntPtr)">
	<summary>
 Notes
 (1) Clears all data to 0.  For 1 bpp, this is white; for grayscale
 or color, this is black.
 (2) Caution for colormapped pix, this sets the color to the first
 one in the colormap.  Be sure that this is the intended color!
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; use cmapped with caution</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetAll(System.IntPtr)">
	<summary>
 Notes
 (1) Sets all data to 1.  For 1 bpp, this is black; for grayscale
 or color, this is white.
 (2) Caution for colormapped pix, this sets the pixel value to the
 maximum value supported by the colormap 2^d - 1.  However, this
 color may not be defined, because the colormap may not be full.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; use cmapped with caution</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetAllGray(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) N.B.  For all images, %grayval == 0 represents black and
 %grayval == 255 represents white.
 (2) For depth LT 8, we do our best to approximate the gray level.
 For 1 bpp images, any %grayval LT 128 is black; GT= 128 is white.
 For 32 bpp images, each r,g,b component is set to %grayval,
 and the alpha component is preserved.
 (3) If pix is colormapped, it adds the gray value, replicated in
 all components, to the colormap if it's not there and there
 is room.  If the colormap is full, it finds the closest color in
 L2 distance of components.  This index is written to all pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths, cmap ok</param>
	<param name="grayval">in range 0 ... 255</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetAllArbitrary(System.IntPtr,System.UInt32)">
	<summary>
 Notes
 (1) Caution 1!  For colormapped pix, %val is used as an index
 into a colormap.  Be sure that index refers to the intended color.
 If the color is not in the colormap, you should first add it
 and then call this function.
 (2) Caution 2!  For 32 bpp pix, the interpretation of the LSB
 of %val depends on whether spp == 3 (RGB) or spp == 4 (RGBA).
 For RGB, the LSB is ignored in image transformations.
 For RGBA, the LSB is interpreted as the alpha (transparency)
 component; full transparency has alpha == 0x0, whereas
 full opacity has alpha = 0xff.  An RGBA image with full
 opacity behaves like an RGB image.
 (3) As an example of (2), suppose you want to initialize a 32 bpp
 pix with partial opacity, say 0xee337788.  If the pix is 3 spp,
 the 0x88 alpha component will be ignored and may be changed
 in subsequent processing.  However, if the pix is 4 spp, the
 alpha component will be retained and used. The function
 pixCreate(w, h, 32) makes an RGB image by default, and
 pixSetSpp(pix, 4) can be used to promote an RGB image to RGBA.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; use cmapped with caution</param>
	<param name="val">value to set all pixels</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetBlackOrWhite(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Function for setting all pixels in an image to either black
 or white.
 (2) If pixs is colormapped, it adds black or white to the
 colormap if it's not there and there is room.  If the colormap
 is full, it finds the closest color in intensity.
 This index is written to all pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; cmap ok</param>
	<param name="op">L_SET_BLACK, L_SET_WHITE</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetComponentArbitrary(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For example, this can be used to set the alpha component to opaque
 pixSetComponentArbitrary(pix, L_ALPHA_CHANNEL, 255)
 </summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp</param>
	<param name="comp">COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL</param>
	<param name="val">value to set this component</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixClearInRect(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Clears all data in rect to 0.  For 1 bpp, this is white;
 for grayscale or color, this is black.
 (2) Caution for colormapped pix, this sets the color to the first
 one in the colormap.  Be sure that this is the intended color!
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; can be cmapped</param>
	<param name="box">in which all pixels will be cleared</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetInRect(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Sets all data in rect to 1.  For 1 bpp, this is black;
 for grayscale or color, this is white.
 (2) Caution for colormapped pix, this sets the pixel value to the
 maximum value supported by the colormap 2^d - 1.  However, this
 color may not be defined, because the colormap may not be full.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths, can be cmapped</param>
	<param name="box">in which all pixels will be set</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetInRectArbitrary(System.IntPtr,System.IntPtr,System.UInt32)">
	<summary>
 Notes
 (1) For colormapped pix, be sure the value is the intended
 one in the colormap.
 (2) Caution for colormapped pix, this sets each pixel in the
 rect to the color at the index equal to val.  Be sure that
 this index exists in the colormap and that it is the intended one!
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; can be cmapped</param>
	<param name="box">in which all pixels will be set to val</param>
	<param name="val">value to set all pixels</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixBlendInRect(System.IntPtr,System.IntPtr,System.UInt32,System.Single)">
	<summary>
 Notes
 (1) This is an in-place function.  It blends the input color %val
 with the pixels in pixs in the specified rectangle.
 If no rectangle is specified, it blends over the entire image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="box">in which all pixels will be blended</param>
	<param name="val">blend value; 0xrrggbb00</param>
	<param name="fract">fraction of color to be blended with each pixel in pixs</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetPadBits(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The pad bits are the bits that expand each scanline to a
 multiple of 32 bits.  They are usually not used in
 image processing operations.  When boundary conditions
 are important, as in seedfill, they must be set properly.
 (2) This sets the value of the pad bits (if any) in the last
 32-bit word in each scanline.
 (3) For 32 bpp pix, there are no pad bits, so this is a no-op.
 (4) When writing formatted output, such as tiff, png or jpeg,
 the pad bits have no effect on the raster image that is
 generated by reading back from the file.  However, in some
 cases, the compressed file itself will depend on the pad
 bits.  This is seen, for example, in Windows with 2 and 4 bpp
 tiff-compressed images that have pad bits on each scanline.
 It is sometimes convenient to use a golden file with a
 byte-by-byte check to verify invariance.  Consequently,
 and because setting the pad bits is cheap, the pad bits are
 set to 0 before writing these compressed files.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1, 2, 4, 8, 16, 32 bpp</param>
	<param name="val">0 or 1</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetPadBitsBand(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The pad bits are the bits that expand each scanline to a
 multiple of 32 bits.  They are usually not used in
 image processing operations.  When boundary conditions
 are important, as in seedfill, they must be set properly.
 (2) This sets the value of the pad bits (if any) in the last
 32-bit word in each scanline, within the specified
 band of raster lines.
 (3) For 32 bpp pix, there are no pad bits, so this is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1, 2, 4, 8, 16, 32 bpp</param>
	<param name="by">starting y value of band</param>
	<param name="bh">height of band</param>
	<param name="val">0 or 1</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetOrClearBorder(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The border region is defined to be the region in the
 image within a specific distance of each edge.  Here, we
 allow the pixels within a specified distance of each
 edge to be set independently.  This either sets or
 clears all pixels in the border region.
 (2) For binary images, use PIX_SET for black and PIX_CLR for white.
 (3) For grayscale or color images, use PIX_SET for white
 and PIX_CLR for black.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="left">right, top, bot amount to set or clear</param>
	<param name="op">operation PIX_SET or PIX_CLR</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetBorderVal(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) The border region is defined to be the region in the
 image within a specific distance of each edge.  Here, we
 allow the pixels within a specified distance of each
 edge to be set independently.  This sets the pixels
 in the border region to the given input value.
 (2) For efficiency, use pixSetOrClearBorder() if
 you're setting the border to either black or white.
 (3) If d != 32, the input value should be masked off
 to the appropriate number of least significant bits.
 (4) The code is easily generalized for 2 or 4 bpp.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16 or 32 bpp</param>
	<param name="left">amount to set</param>
	<param name="right">amount to set</param>
	<param name="top">amount to set</param>
	<param name="bot">amount to set</param>
	<param name="val">value to set at each border pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetBorderRingVal(System.IntPtr,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) The rings are single-pixel-wide rectangular sets of
 pixels at a given distance from the edge of the pix.
 This sets all pixels in a given ring to a value.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; cmap OK</param>
	<param name="dist">distance from outside; must be GT 0; first ring is 1</param>
	<param name="val">value to set at each border pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetMirroredBorder(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This applies what is effectively mirror boundary conditions
 to a border region in the image.  It is in-place.
 (2) This is useful for setting pixels near the border to a
 value representative of the near pixels to the interior.
 (3) The general pixRasterop() is used for an in-place operation here
 because there is no overlap between the src and dest rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels to set</param>
	<param name="right">number of pixels to set</param>
	<param name="top">number of pixels to set</param>
	<param name="bot">number of pixels to set</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCopyBorder(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) pixd can be null, but otherwise it must be the same size
 and depth as pixs.  Always returns pixd.
 (2) This is useful in situations where by setting a few border
 pixels we can avoid having to copy all pixels in pixs into
 pixd as an initialization step for some operation.
 Nevertheless, for safety, if making a new pixd, all the
 non-border pixels are initialized to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">all depths; colormap ok; can be NULL</param>
	<param name="pixs">same depth and size as pixd</param>
	<param name="left">number of pixels to copy</param>
	<param name="right">number of pixels to copy</param>
	<param name="top">number of pixels to copy</param>
	<param name="bot">number of pixels to copy</param>
	<returns>pixd, or NULL on error if pixd is not defined</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddBorder(System.IntPtr,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) See pixGetBlackOrWhiteVal() for values of black and white pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="npix">number of pixels to be added to each side</param>
	<param name="val">value of added border pixels</param>
	<returns>pixd with the added exterior pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddBlackOrWhiteBorder(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixGetBlackOrWhiteVal() for possible side effect (adding
 a color to a colormap).
 (2) The only complication is that pixs may have a colormap.
 There are two ways to add the black or white border
 (a) As done here (simplest, most efficient)
 (b) l_int32 ws, hs, d;
 pixGetDimensions(pixs, ws, hs, d);
 Pix pixd = pixCreate(ws + left + right, hs + top + bot, d);
 PixColormap cmap = pixGetColormap(pixs);
 if (cmap != NULL)
 pixSetColormap(pixd, pixcmapCopy(cmap));
 pixSetBlackOrWhite(pixd, L_SET_WHITE);  // uses cmap
 pixRasterop(pixd, left, top, ws, hs, PIX_SET, pixs, 0, 0);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels added</param>
	<param name="right">number of pixels added</param>
	<param name="top">number of pixels added</param>
	<param name="bot">number of pixels added</param>
	<param name="op">L_GET_BLACK_VAL, L_GET_WHITE_VAL</param>
	<returns>pixd with the added exterior pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddBorderGeneral(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) For binary images
 white  val = 0
 black  val = 1
 For grayscale images
 white  val = 2  d - 1
 black  val = 0
 For rgb color images
 white  val = 0xffffff00
 black  val = 0
 For colormapped images, set val to the appropriate colormap index.
 (2) If the added border is either black or white, you can use
 pixAddBlackOrWhiteBorder()
 The black and white values for all images can be found with
 pixGetBlackOrWhiteVal()
 which, if pixs is cmapped, may add an entry to the colormap.
 Alternatively, if pixs has a colormap, you can find the index
 of the pixel whose intensity is closest to white or black
 white pixcmapGetRankIntensity(cmap, 1.0, index);
 black pixcmapGetRankIntensity(cmap, 0.0, index);
 and use that for val.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels added</param>
	<param name="right">number of pixels added</param>
	<param name="top">number of pixels added</param>
	<param name="bot">number of pixels added</param>
	<param name="val">value of added border pixels</param>
	<returns>pixd with the added exterior pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRemoveBorder(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="npix">number to be removed from each of the 4 sides</param>
	<returns>pixd with pixels removed around border, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRemoveBorderGeneral(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels removed</param>
	<param name="right">number of pixels removed</param>
	<param name="top">number of pixels removed</param>
	<param name="bot">number of pixels removed</param>
	<returns>pixd with pixels removed around border, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRemoveBorderToSize(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Removes pixels as evenly as possible from the sides of the
 image, leaving the central part.
 (2) Returns clone if no pixels requested removed, or the target
 sizes are larger than the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="wd">target width; use 0 if only removing from height</param>
	<param name="hd">target height; use 0 if only removing from width</param>
	<returns>pixd with pixels removed around border, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddMirroredBorder(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This applies what is effectively mirror boundary conditions.
 For the added border pixels in pixd, the pixels in pixs
 near the border are mirror-copied into the border region.
 (2) This is useful for avoiding special operations near
 boundaries when doing image processing operations
 such as rank filters and convolution.  In use, one first
 adds mirrored pixels to each side of the image.  The number
 of pixels added on each side is half the filter dimension.
 Then the image processing operations proceed over a
 region equal to the size of the original image, and
 write directly into a dest pix of the same size as pixs.
 (3) The general pixRasterop() is used for an in-place operation here
 because there is no overlap between the src and dest rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels added</param>
	<param name="right">number of pixels added</param>
	<param name="top">number of pixels added</param>
	<param name="bot">number of pixels added</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddRepeatedBorder(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This applies a repeated border, as if the central part of
 the image is tiled over the plane.  So, for example, the
 pixels in the left border come from the right side of the image.
 (2) The general pixRasterop() is used for an in-place operation here
 because there is no overlap between the src and dest rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels added</param>
	<param name="right">number of pixels added</param>
	<param name="top">number of pixels added</param>
	<param name="bot">number of pixels added</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddMixedBorder(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This applies mirrored boundary conditions horizontally
 and repeated b.c. vertically.
 (2) It is specifically used for avoiding special operations
 near boundaries when convolving a hue-saturation histogram
 with a given window size.  The repeated b.c. are used
 vertically for hue, and the mirrored b.c. are used
 horizontally for saturation.  The number of pixels added
 on each side is approximately (but not quite) half the
 filter dimension.  The image processing operations can
 then proceed over a region equal to the size of the original
 image, and write directly into a dest pix of the same
 size as pixs.
 (3) The general pixRasterop() can be used for an in-place
 operation here because there is no overlap between the
 src and dest rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels added</param>
	<param name="right">number of pixels added</param>
	<param name="top">number of pixels added</param>
	<param name="bot">number of pixels added</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddContinuedBorder(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This adds pixels on each side whose values are equal to
 the value on the closest boundary pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">pixels on each side to be added</param>
	<param name="right">pixels on each side to be added</param>
	<param name="top">pixels on each side to be added</param>
	<param name="bot">pixels on each side to be added</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixShiftAndTransferAlpha(System.IntPtr,System.IntPtr,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp</param>
	<param name="pixs">32 bpp</param>
	<param name="shiftx"></param>
	<param name="shifty"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDisplayLayersRGBA(System.IntPtr,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) Use %val == 0xffffff00 for white background.
 (2) Three views are given
 ~ the image with a fully opaque alpha
 ~ the alpha layer
 ~ the image as it would appear with a white background.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">cmap or 32 bpp rgba</param>
	<param name="val">32 bit unsigned color to use as background</param>
	<param name="maxw">max output image width; 0 for no scaling</param>
	<returns>pixd showing various image views, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCreateRGBImage(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) the 4th byte, sometimes called the "alpha channel",
 and which is often used for blending between different
 images, is left with 0 value.
 (2) see Note (4) in pix.h for details on storage of
 8-bit samples within each 32-bit word.
 (3) This implementation, setting the r, g and b components
 sequentially, is much faster than setting them in parallel
 by constructing an RGB dest pixel and writing it to dest.
 The reason is there are many more cache misses when reading
 from 3 input images simultaneously.
 </summary>
	<remarks>
	</remarks>
	<param name="pixr">8 bpp red pix</param>
	<param name="pixg">8 bpp green pix</param>
	<param name="pixb">8 bpp blue pix</param>
	<returns>32 bpp pix, interleaved with 4 samples/pixel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRGBComponent(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Three calls to this function generate the r, g and b 8 bpp
 component images.  This is much faster than generating the
 three images in parallel, by extracting a src pixel and setting
 the pixels of each component image from it.  The reason is
 there are many more cache misses when writing to three
 output images simultaneously.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, or colormapped</param>
	<param name="comp">one of {COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL}</param>
	<returns>pixd the selected 8 bpp component image of the input 32 bpp image or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetRGBComponent(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This places the 8 bpp pixel in pixs into the
 specified component (properly interleaved) in pixd,
 (2) The two images are registered to the UL corner; the sizes
 need not be the same, but a warning is issued if they differ.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp</param>
	<param name="pixs">8 bpp</param>
	<param name="comp">one of the set {COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL}</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRGBComponentCmap(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) In leptonica, we do not support alpha in colormaps.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped</param>
	<param name="comp">one of the set {COLOR_RED, COLOR_GREEN, COLOR_BLUE}</param>
	<returns>pixd  the selected 8 bpp component image of the input cmapped image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCopyRGBComponent(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The two images are registered to the UL corner.  The sizes
 are usually the same, and a warning is issued if they differ.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp</param>
	<param name="pixs">32 bpp</param>
	<param name="comp">one of the set {COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL}</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.composeRGBPixel(System.Int32,System.Int32,System.Int32,System.UInt32@)">
	<summary>
 Notes
 (1) All channels are 8 bits the input values must be between
 0 and 255.  For speed, this is not enforced by masking
 with 0xff before shifting.
 (2) A slower implementation uses macros
 SET_DATA_BYTE(ppixel, COLOR_RED, rval);
 SET_DATA_BYTE(ppixel, COLOR_GREEN, gval);
 SET_DATA_BYTE(ppixel, COLOR_BLUE, bval);
 </summary>
	<remarks>
	</remarks>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="ppixel">32-bit pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.composeRGBAPixel(System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32@)">
	<summary>
 Notes
 (1) All channels are 8 bits the input values must be between
 0 and 255.  For speed, this is not enforced by masking
 with 0xff before shifting.
 </summary>
	<remarks>
	</remarks>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="aval"></param>
	<param name="ppixel">32-bit pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.extractRGBValues(System.UInt32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) A slower implementation uses macros
 prval = GET_DATA_BYTE(pixel, COLOR_RED);
 pgval = GET_DATA_BYTE(pixel, COLOR_GREEN);
 pbval = GET_DATA_BYTE(pixel, COLOR_BLUE);
 </summary>
	<remarks>
	</remarks>
	<param name="pixel">32 bit</param>
	<param name="prval">red component</param>
	<param name="pgval">green component</param>
	<param name="pbval">blue component</param>
</member><member name="M:LeptonicaSharp.Natives.extractRGBAValues(System.UInt32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixel">32 bit</param>
	<param name="prval">red component</param>
	<param name="pgval">green component</param>
	<param name="pbval">blue component</param>
	<param name="paval">alpha component</param>
</member><member name="M:LeptonicaSharp.Natives.extractMinMaxComponent(System.UInt32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixel">32 bpp RGB</param>
	<param name="type">L_CHOOSE_MIN or L_CHOOSE_MAX</param>
	<returns>component in range [0 ... 255], or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRGBLine(System.IntPtr,System.Int32,System.Byte[],System.Byte[],System.Byte[])">
	<summary>
 Notes
 (1) This puts rgb components from the input line in pixs
 into the given buffers.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="row"></param>
	<param name="bufr">array of red samples; size w bytes</param>
	<param name="bufg">array of green samples; size w bytes</param>
	<param name="bufb">array of blue samples; size w bytes</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixEndianByteSwapNew(System.IntPtr)">
	<summary>
 Notes
 (1) This is used to convert the data in a pix to a
 serialized byte buffer in raster order, and, for RGB,
 in order RGBA.  This requires flipping bytes within
 each 32-bit word for little-endian platforms, because the
 words have a MSB-to-the-left rule, whereas byte raster-order
 requires the left-most byte in each word to be byte 0.
 For big-endians, no swap is necessary, so this returns a clone.
 (2) Unlike pixEndianByteSwap(), which swaps the bytes in-place,
 this returns a new pix (or a clone).  We provide this
 because often when serialization is done, the source
 pix needs to be restored to canonical little-endian order,
 and this requires a second byte swap.  In such a situation,
 it is twice as fast to make a new pix in big-endian order,
 use it, and destroy it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixEndianByteSwap(System.IntPtr)">
	<summary>
 Notes
 (1) This is used on little-endian platforms to swap
 the bytes within a word; bytes 0 and 3 are swapped,
 and bytes 1 and 2 are swapped.
 (2) This is required for little-endians in situations
 where we convert from a serialized byte order that is
 in raster order, as one typically has in file formats,
 to one with MSB-to-the-left in each 32-bit word, or v.v.
 See pix.h for a description of the canonical format
 (MSB-to-the left) that is used for both little-endian
 and big-endian platforms.   For big-endians, the
 MSB-to-the-left word order has the bytes in raster
 order when serialized, so no byte flipping is required.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lineEndianByteSwap(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is used on little-endian platforms to swap
 the bytes within each word in the line of image data.
 Bytes 0 LT==GT 3 and 1 LT==GT 2 are swapped in the dest
 byte array data8d, relative to the pix data in datas.
 (2) The bytes represent 8 bit pixel values.  They are swapped
 for little endians so that when the dest array datad
 is addressed by bytes, the pixels are chosen sequentially
 from left to right in the image.
 </summary>
	<remarks>
	</remarks>
	<param name="datad">dest byte array data, reordered on little-endians</param>
	<param name="datas">a src line of pix data)</param>
	<param name="wpl">number of 32 bit words in the line</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixEndianTwoByteSwapNew(System.IntPtr)">
	<summary>
 Notes
 (1) This is used on little-endian platforms to swap the
 2-byte entities within a 32-bit word.
 (2) This is equivalent to a full byte swap, as performed
 by pixEndianByteSwap(), followed by byte swaps in
 each of the 16-bit entities separately.
 (3) Unlike pixEndianTwoByteSwap(), which swaps the shorts in-place,
 this returns a new pix (or a clone).  We provide this
 to avoid having to swap twice in situations where the input
 pix must be restored to canonical little-endian order.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixEndianTwoByteSwap(System.IntPtr)">
	<summary>
 Notes
 (1) This is used on little-endian platforms to swap the
 2-byte entities within a 32-bit word.
 (2) This is equivalent to a full byte swap, as performed
 by pixEndianByteSwap(), followed by byte swaps in
 each of the 16-bit entities separately.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRasterData(System.IntPtr,System.IntPtr@,System.UInt32@)">
	<summary>
 Notes
 (1) This returns the raster data as a byte string, padded to the
 byte.  For 1 bpp, the first pixel is the MSbit in the first byte.
 For rgb, the bytes are in (rgb) order.  This is the format
 required for flate encoding of pixels in a PostScript file.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8, 32 bpp</param>
	<param name="pdata">raster data in memory</param>
	<param name="pnbytes">number of bytes in data string</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAlphaIsOpaque(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp, spp == 4</param>
	<param name="popaque">1 if spp == 4 and all alpha component values are 255 (opaque); 0 otherwise</param>
	<returns>0 if OK, 1 on error Notes 1) On error, opaque is returned as 0 (FALSE).</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetupByteProcessing(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This is a simple helper for processing 8 bpp images with
 direct byte access.  It can swap byte order within each word.
 (2) After processing, you must call pixCleanupByteProcessing(),
 which frees the lineptr array and restores byte order.
 (3) Usage
 l_uint8 lineptrs = pixSetupByteProcessing(pix, w, h);
 for (i = 0; i LT h; i++) {
 l_uint8 line = lineptrs[i];
 for (j = 0; j LT w; j++) {
 val = line[j];
 ...
 }
 }
 pixCleanupByteProcessing(pix, lineptrs);
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp, no colormap</param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<returns>line ptr array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCleanupByteProcessing(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This must be called after processing that was initiated
 by pixSetupByteProcessing() has finished.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp, no colormap</param>
	<param name="lineptrs">ptrs to the beginning of each raster line of data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_setAlphaMaskBorder(System.Single,System.Single)">
	<summary>
 Notes
 (1) This sets the opacity values used to generate the two outer
 boundary rings in the alpha mask associated with geometric
 transforms such as pixRotateWithAlpha().
 (2) The default values are val1 = 0.0 (completely transparent
 in the outermost ring) and val2 = 0.5 (half transparent
 in the second ring).  When the image is blended, this
 completely removes the outer ring (shrinking the image by
 2 in each direction), and alpha-blends with 0.5 the second ring.
 Using val1 = 0.25 and val2 = 0.75 gives a slightly more
 blurred border, with no perceptual difference at screen resolution.
 (3) The actual mask values are found by multiplying these
 normalized opacity values by 255.
 </summary>
	<remarks>
	</remarks>
	<param name="val1">in [0.0 ... 1.0]</param>
	<param name="val2">in [0.0 ... 1.0]</param>
</member><member name="M:LeptonicaSharp.Natives.pixSetMasked(System.IntPtr,System.IntPtr,System.UInt32)">
	<summary>
 Notes
 (1) In-place operation.
 (2) NOTE For cmapped images, this calls pixSetMaskedCmap().
 %val must be the 32-bit color representation of the RGB pixel.
 It is not the index into the colormap!
 (2) If pixm == NULL, a warning is given.
 (3) This is an implicitly aligned operation, where the UL
 corners of pixd and pixm coincide.  A warning is
 issued if the two image sizes differ significantly,
 but the operation proceeds.
 (4) Each pixel in pixd that co-locates with an ON pixel
 in pixm is set to the specified input value.
 Other pixels in pixd are not changed.
 (5) You can visualize this as painting the color through
 the mask, as a stencil.
 (6) If you do not want to have the UL corners aligned,
 use the function pixSetMaskedGeneral(), which requires
 you to input the UL corner of pixm relative to pixd.
 (7) Implementation details see comments in pixPaintThroughMask()
 for when we use rasterop to do the painting.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">1, 2, 4, 8, 16 or 32 bpp; or colormapped</param>
	<param name="pixm">1 bpp mask; no operation if NULL</param>
	<param name="val">value to set at each masked pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetMaskedGeneral(System.IntPtr,System.IntPtr,System.UInt32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) Alignment is explicit.  If you want the UL corners of
 the two images to be aligned, use pixSetMasked().
 (3) A typical use would be painting through the foreground
 of a small binary mask pixm, located somewhere on a
 larger pixd.  Other pixels in pixd are not changed.
 (4) You can visualize this as painting the color through
 the mask, as a stencil.
 (5) This uses rasterop to handle clipping and different depths of pixd.
 (6) If pixd has a colormap, you should call pixPaintThroughMask().
 (7) Why is this function here, if pixPaintThroughMask() does the
 same thing, and does it more generally?  I've retained it here
 to show how one can paint through a mask using only full
 image rasterops, rather than pixel peeking in pixm and poking
 in pixd.  It's somewhat baroque, but I found it amusing.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8, 16 or 32 bpp</param>
	<param name="pixm">1 bpp mask; no operation if null</param>
	<param name="val">value to set at each masked pixel</param>
	<param name="x">location of UL corner of pixm relative to pixd; can be negative</param>
	<param name="y">location of UL corner of pixm relative to pixd; can be negative</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCombineMasked(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) In-place operation; pixd is changed.
 (2) This sets each pixel in pixd that co-locates with an ON
 pixel in pixm to the corresponding value of pixs.
 (3) pixs and pixd must be the same depth and not colormapped.
 (4) All three input pix are aligned at the UL corner, and the
 operation is clipped to the intersection of all three images.
 (5) If pixm == NULL, it's a no-op.
 (6) Implementation see notes in pixCombineMaskedGeneral().
 For 8 bpp selective masking, you might guess that it
 would be faster to generate an 8 bpp version of pixm,
 using pixConvert1To8(pixm, 0, 255), and then use a
 general combine operation
 d = (d  ~m) | (s  m)
 on a word-by-word basis.  Not always.  The word-by-word
 combine takes a time that is independent of the mask data.
 If the mask is relatively sparse, the byte-check method
 is actually faster!
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">1 bpp, 8 bpp gray or 32 bpp rgb; no cmap</param>
	<param name="pixs">1 bpp, 8 bpp gray or 32 bpp rgb; no cmap</param>
	<param name="pixm">1 bpp mask; no operation if NULL</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCombineMaskedGeneral(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) In-place operation; pixd is changed.
 (2) This is a generalized version of pixCombinedMasked(), where
 the source and mask can be placed at the same (arbitrary)
 location relative to pixd.
 (3) pixs and pixd must be the same depth and not colormapped.
 (4) The UL corners of both pixs and pixm are aligned with
 the point (x, y) of pixd, and the operation is clipped to
 the intersection of all three images.
 (5) If pixm == NULL, it's a no-op.
 (6) Implementation.  There are two ways to do these.  In the first,
 we use rasterop, ORing the part of pixs under the mask
 with pixd (which has been appropriately cleared there first).
 In the second, the mask is used one pixel at a time to
 selectively replace pixels of pixd with those of pixs.
 Here, we use rasterop for 1 bpp and pixel-wise replacement
 for 8 and 32 bpp.  To use rasterop for 8 bpp, for example,
 we must first generate an 8 bpp version of the mask.
 The code is simple
 Pix pixm8 = pixConvert1To8(NULL, pixm, 0, 255);
 Pix pixt = pixAnd(NULL, pixs, pixm8);
 pixRasterop(pixd, x, y, wmin, hmin, PIX_DST  PIX_NOT(PIX_SRC),
 pixm8, 0, 0);
 pixRasterop(pixd, x, y, wmin, hmin, PIX_SRC | PIX_DST,
 pixt, 0, 0);
 pixDestroy(pixt);
 pixDestroy(pixm8);
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">1 bpp, 8 bpp gray or 32 bpp rgb</param>
	<param name="pixs">1 bpp, 8 bpp gray or 32 bpp rgb</param>
	<param name="pixm">1 bpp mask</param>
	<param name="x">origin of pixs and pixm relative to pixd; can be negative</param>
	<param name="y">origin of pixs and pixm relative to pixd; can be negative</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixPaintThroughMask(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) In-place operation.  Calls pixSetMaskedCmap() for colormapped
 images.
 (2) For 1, 2, 4, 8 and 16 bpp gray, we take the appropriate
 number of least significant bits of val.
 (3) If pixm == NULL, it's a no-op.
 (4) The mask origin is placed at (x,y) on pixd, and the
 operation is clipped to the intersection of rectangles.
 (5) For rgb, the components in val are in the canonical locations,
 with red in location COLOR_RED, etc.
 (6) Implementation detail 1
 For painting with val == 0 or val == maxval, you can use rasterop.
 If val == 0, invert the mask so that it's 0 over the region
 into which you want to write, and use PIX_SRC  PIX_DST to
 clear those pixels.  To write with val = maxval (all 1's),
 use PIX_SRC | PIX_DST to set all bits under the mask.
 (7) Implementation detail 2
 The rasterop trick can be used for depth GT 1 as well.
 For val == 0, generate the mask for depth d from the binary
 mask using
 pixmd = pixUnpackBinary(pixm, d, 1);
 and use pixRasterop() with PIX_MASK.  For val == maxval,
 pixmd = pixUnpackBinary(pixm, d, 0);
 and use pixRasterop() with PIX_PAINT.
 But note that if d == 32 bpp, it is about 3x faster to use
 the general implementation (not pixRasterop()).
 (8) Implementation detail 3
 It might be expected that the switch in the inner loop will
 cause large branching delays and should be avoided.
 This is not the case, because the entrance is always the
 same and the compiler can correctly predict the jump.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">1, 2, 4, 8, 16 or 32 bpp; or colormapped</param>
	<param name="pixm">1 bpp mask</param>
	<param name="x">origin of pixm relative to pixd; can be negative</param>
	<param name="y">origin of pixm relative to pixd; can be negative</param>
	<param name="val">pixel value to set at each masked pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixPaintSelfThroughMask(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) In-place operation; pixd is changed.
 (2) If pixm == NULL, it's a no-op.
 (3) The mask origin is placed at (x,y) on pixd, and the
 operation is clipped to the intersection of pixd and the
 fg of the mask.
 (4) %tsize is the the requested size for tiling.  The actual
 actual size for each c.c. will be bounded by the minimum
 dimension of the c.c.
 (5) For %mindist, %searchdir and %ntiles, see pixFindRepCloseTile().
 They determine the set of possible tiles that can be used
 to build a larger mirrored tile to paint onto pixd through
 the c.c. of pixm.
 (6) %distblend is used for alpha blending.  It is only applied
 if there is exactly one c.c. in the mask.  Use distblend == 0
 to skip blending and just paint through the 1 bpp mask.
 (7) To apply blending to more than 1 component, call this function
 repeatedly with %pixm, %x and %y representing one component of
 the mask each time.  This would be done as follows, for an
 underlying image pixs and mask pixm of components to fill
 Boxa boxa = pixConnComp(pixm, pixa, 8);
 n = boxaGetCount(boxa);
 for (i = 0; i LT n; i++) {
 Pix pix = pixaGetPix(pixa, i, L_CLONE);
 Box box = pixaGetBox(pixa, i, L_CLONE);
 boxGetGeometry(box, bx, by, bw, bh);
 pixPaintSelfThroughMask(pixs, pix, bx, by, searchdir,
 mindist, tilesize, ntiles, distblend);
 pixDestroy(pix);
 boxDestroy(box);
 }
 pixaDestroy(pixa);
 boxaDestroy(boxa);
 (8) If no tiles can be found, this falls back to estimating the
 color near the boundary of the region to be textured.
 (9) This can be used to replace the pixels in some regions of
 an image by selected neighboring pixels.  The mask represents
 the pixels to be replaced.  For each connected component in
 the mask, this function selects up to two tiles of neighboring
 pixels to be used for replacement of pixels represented by
 the component (i.e., under the FG of that component in the mask).
 After selection, mirror replication is used to generate an
 image that is large enough to cover the component.  Alpha
 blending can also be used outside of the component, but near the
 edge, to blur the transition between painted and original pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8 bpp gray or 32 bpp rgb; not colormapped</param>
	<param name="pixm">1 bpp mask</param>
	<param name="x">origin of pixm relative to pixd; must not be negative</param>
	<param name="y">origin of pixm relative to pixd; must not be negative</param>
	<param name="searchdir">L_HORIZ, L_VERT or L_BOTH_DIRECTIONS</param>
	<param name="mindist">min distance of nearest tile edge to box; GT= 0</param>
	<param name="tilesize">requested size for tiling; may be reduced</param>
	<param name="ntiles">number of tiles tested in each row/column</param>
	<param name="distblend">distance outside the fg used for blending with pixs</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMakeMaskFromVal(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This generates a 1 bpp mask image, where a 1 is written in
 the mask for each pixel in pixs that has a value %val.
 (2) If no pixels have the value, an empty mask is generated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp; can be colormapped</param>
	<param name="val">pixel value</param>
	<returns>pixd 1 bpp mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMakeMaskFromLUT(System.IntPtr,System.Int32[])">
	<summary>
 Notes
 (1) This generates a 1 bpp mask image, where a 1 is written in
 the mask for each pixel in pixs that has a value corresponding
 to a 1 in the LUT.
 (2) The LUT should be of size 256.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp; can be colormapped</param>
	<param name="tab">256-entry LUT; 1 means to write to mask</param>
	<returns>pixd 1 bpp mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMakeArbMaskFromRGB(System.IntPtr,System.Single,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This generates a 1 bpp mask image, where a 1 is written in
 the mask for each pixel in pixs that satisfies
 rc  rval + gc  gval + bc  bval GT thresh
 where rval is the red component, etc.
 (2) Unlike with pixConvertToGray(), there are no constraints
 on the color coefficients, which can be negative.  For
 example, a mask that discriminates against red and in favor
 of blue will have rc LT 0.0 and bc GT 0.0.
 (3) To make the result independent of intensity (the 'V' in HSV),
 select coefficients so that %thresh = 0.  Then the result
 is not changed when all components are multiplied by the
 same constant (as long as nothing saturates).  This can be
 useful if, for example, the illumination is not uniform.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<param name="rc">arithmetic factors; can be negative</param>
	<param name="gc">arithmetic factors; can be negative</param>
	<param name="bc">arithmetic factors; can be negative</param>
	<param name="thresh">lower threshold on weighted sum of components</param>
	<returns>pixd 1 bpp mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetUnderTransparency(System.IntPtr,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) This sets the r, g and b components under every fully
 transparent alpha component to %val.  The alpha components
 are unchanged.
 (2) Full transparency is denoted by alpha == 0.  Setting
 all pixels to a constant %val where alpha is transparent
 can improve compressibility by reducing the entropy.
 (3) The visual result depends on how the image is displayed.
 (a) For display devices that respect the use of the alpha
 layer, this will not affect the appearance.
 (b) For typical leptonica operations, alpha is ignored,
 so there will be a change in appearance because this
 resets the rgb values in the fully transparent region.
 (4) pixRead() and pixWrite() will, by default, read and write
 4-component (rgba) pix in png format.  To ignore the alpha
 component after reading, or omit it on writing, pixSetSpp(..., 3).
 (5) Here are some examples
 To convert all fully transparent pixels in a 4 component
 (rgba) png file to white
 pixs = pixRead(LTinfileGT);
 pixd = pixSetUnderTransparency(pixs, 0xffffff00, 0);
 To write pixd with the alpha component
 pixWrite(LToutfileGT, pixd, IFF_PNG);
 To write and rgba image without the alpha component, first do
 pixSetSpp(pixd, 3);
 If you later want to use the alpha, spp must be reset to 4.
 (fancier) To remove the alpha by blending the image over
 a white background
 pixRemoveAlpha()
 This changes all pixel values where the alpha component is
 not opaque (255).
 (6) Caution.  rgb images in leptonica typically have value 0 in
 the alpha channel, which is fully transparent.  If spp for
 such an image were changed from 3 to 4, the image becomes
 fully transparent, and this function will set each pixel to %val.
 If you really want to set every pixel to the same value,
 use pixSetAllArbitrary().
 (7) This is useful for compressing an RGBA image where the part
 of the image that is fully transparent is random junk; compression
 is typically improved by setting that region to a constant.
 For rendering as a 3 component RGB image over a uniform
 background of arbitrary color, use pixAlphaBlendUniform().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgba</param>
	<param name="val">32 bit unsigned color to use where alpha == 0</param>
	<param name="debug">displays layers of pixs</param>
	<returns>pixd 32 bpp rgba, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMakeAlphaFromMask(System.IntPtr,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) This generates a 8 bpp alpha layer that is opaque (256)
 over the FG of pixs, and goes transparent linearly away
 from the FG pixels, decaying to 0 (transparent) is an
 8-connected distance given by %dist.  If %dist == 0,
 this does a simple conversion from 1 to 8 bpp.
 (2) If box == NULL, this returns an alpha mask that is the
 full size of pixs.  Otherwise, the returned mask pixd covers
 just the FG pixels of pixs, expanded by %dist in each
 direction (if possible), and the returned box gives the
 location of the returned mask relative to pixs.
 (3) This is useful for painting through a mask and allowing
 blending of the painted image with an underlying image
 in the mask background for pixels near foreground mask pixels.
 For example, with an underlying rgb image pix1, an overlaying
 image rgb pix2, binary mask pixm, and dist GT 0, this
 blending is achieved with
 pix3 = pixMakeAlphaFromMask(pixm, dist, box);
 boxGetGeometry(box, x, y, NULL, NULL);
 pix4 = pixBlendWithGrayMask(pix1, pix2, pix3, x, y);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="dist">blending distance; typically 10 - 30</param>
	<param name="pbox">use NULL to get the full size</param>
	<returns>pixd (8 bpp gray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetColorNearMaskBoundary(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.UInt32@,System.Int32)">
	<summary>
 Notes
 (1) This finds the average color in a set of pixels that are
 roughly a distance %dist from the c.c. boundary and in the
 background of the mask image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="pixm">1 bpp mask, full image</param>
	<param name="box">region of mask; typically b.b. of a component</param>
	<param name="dist">distance into BG from mask boundary to use</param>
	<param name="pval">average pixel value</param>
	<param name="debug">1 to output mask images</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixInvert(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This inverts pixs, for all pixel depths.
 (2) There are 3 cases
 (a) pixd == null,   ~src --GT new pixd
 (b) pixd == pixs,   ~src --GT src  (in-place)
 (c) pixd != pixs,   ~src --GT input pixd
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixInvert(NULL, pixs);
 (b) pixInvert(pixs, pixs);
 (c) pixInvert(pixd, pixs);
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs"></param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixOr(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This gives the union of two images with equal depth,
 aligning them to the the UL corner.  pixs1 and pixs2
 need not have the same width and height.
 (2) There are 3 cases
 (a) pixd == null,   (src1 | src2) --GT new pixd
 (b) pixd == pixs1,  (src1 | src2) --GT src1  (in-place)
 (c) pixd != pixs1,  (src1 | src2) --GT input pixd
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixOr(NULL, pixs1, pixs2);
 (b) pixOr(pixs1, pixs1, pixs2);
 (c) pixOr(pixd, pixs1, pixs2);
 (4) The size of the result is determined by pixs1.
 (5) The depths of pixs1 and pixs2 must be equal.
 (6) Note carefully that the order of pixs1 and pixs2 only matters
 for the in-place case.  For in-place, you must have
 pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
 result the copy puts pixs1 image data in pixs2, and
 the rasterop is then between pixs2 and pixs2 (a no-op).
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs1, different from pixs1</param>
	<param name="pixs1">can be == pixd</param>
	<param name="pixs2">must be != pixd</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAnd(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This gives the intersection of two images with equal depth,
 aligning them to the the UL corner.  pixs1 and pixs2
 need not have the same width and height.
 (2) There are 3 cases
 (a) pixd == null,   (src1  src2) --GT new pixd
 (b) pixd == pixs1,  (src1  src2) --GT src1  (in-place)
 (c) pixd != pixs1,  (src1  src2) --GT input pixd
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixAnd(NULL, pixs1, pixs2);
 (b) pixAnd(pixs1, pixs1, pixs2);
 (c) pixAnd(pixd, pixs1, pixs2);
 (4) The size of the result is determined by pixs1.
 (5) The depths of pixs1 and pixs2 must be equal.
 (6) Note carefully that the order of pixs1 and pixs2 only matters
 for the in-place case.  For in-place, you must have
 pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
 result the copy puts pixs1 image data in pixs2, and
 the rasterop is then between pixs2 and pixs2 (a no-op).
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs1, different from pixs1</param>
	<param name="pixs1">can be == pixd</param>
	<param name="pixs2">must be != pixd</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixXor(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This gives the XOR of two images with equal depth,
 aligning them to the the UL corner.  pixs1 and pixs2
 need not have the same width and height.
 (2) There are 3 cases
 (a) pixd == null,   (src1 ^ src2) --GT new pixd
 (b) pixd == pixs1,  (src1 ^ src2) --GT src1  (in-place)
 (c) pixd != pixs1,  (src1 ^ src2) --GT input pixd
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixXor(NULL, pixs1, pixs2);
 (b) pixXor(pixs1, pixs1, pixs2);
 (c) pixXor(pixd, pixs1, pixs2);
 (4) The size of the result is determined by pixs1.
 (5) The depths of pixs1 and pixs2 must be equal.
 (6) Note carefully that the order of pixs1 and pixs2 only matters
 for the in-place case.  For in-place, you must have
 pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
 result the copy puts pixs1 image data in pixs2, and
 the rasterop is then between pixs2 and pixs2 (a no-op).
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs1, different from pixs1</param>
	<param name="pixs1">can be == pixd</param>
	<param name="pixs2">must be != pixd</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSubtract(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This gives the set subtraction of two images with equal depth,
 aligning them to the the UL corner.  pixs1 and pixs2
 need not have the same width and height.
 (2) Source pixs2 is always subtracted from source pixs1.
 The result is
 pixs1 \ pixs2 = pixs1  (~pixs2)
 (3) There are 4 cases
 (a) pixd == null,   (src1 - src2) --GT new pixd
 (b) pixd == pixs1,  (src1 - src2) --GT src1  (in-place)
 (c) pixd == pixs2,  (src1 - src2) --GT src2  (in-place)
 (d) pixd != pixs1  pixd != pixs2),
 (src1 - src2) --GT input pixd
 (4) For clarity, if the case is known, use these patterns
 (a) pixd = pixSubtract(NULL, pixs1, pixs2);
 (b) pixSubtract(pixs1, pixs1, pixs2);
 (c) pixSubtract(pixs2, pixs1, pixs2);
 (d) pixSubtract(pixd, pixs1, pixs2);
 (5) The size of the result is determined by pixs1.
 (6) The depths of pixs1 and pixs2 must be equal.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs1, equal to pixs2, or different from both pixs1 and pixs2</param>
	<param name="pixs1">can be == pixd</param>
	<param name="pixs2">can be == pixd</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixZero(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) For a binary image, if there are no fg (black) pixels, empty = 1.
 (2) For a grayscale image, if all pixels are black (0), empty = 1.
 (3) For an RGB image, if all 4 components in every pixel is 0,
 empty = 1.
 (4) For a colormapped image, pixel values are 0.  The colormap
 is ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; colormap OK</param>
	<param name="pempty">1 if all bits in image data field are 0; 0 otherwise</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixForegroundFraction(System.IntPtr,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="pfract">fraction of ON pixels</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaCountPixels(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa">array of 1 bpp pix</param>
	<returns>na of ON pixels in each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCountPixels(System.IntPtr,System.Int32@,System.Int32[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pcount">count of ON pixels</param>
	<param name="tab8">8-bit pixel lookup table</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCountPixelsInRect(System.IntPtr,System.IntPtr,System.Int32@,System.Int32[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="box">(can be null)</param>
	<param name="pcount">count of ON pixels</param>
	<param name="tab8">8-bit pixel lookup table</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCountByRow(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="box">clipping box for count; can be null</param>
	<returns>na of number of ON pixels by row, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCountByColumn(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="box">clipping box for count; can be null</param>
	<returns>na of number of ON pixels by column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCountPixelsByRow(System.IntPtr,System.Int32[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="tab8">8-bit pixel lookup table</param>
	<returns>na of counts, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCountPixelsByColumn(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<returns>na of counts in each column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCountPixelsInRow(System.IntPtr,System.Int32,System.Int32@,System.Int32[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="row">number</param>
	<param name="pcount">sum of ON pixels in raster line</param>
	<param name="tab8">8-bit pixel lookup table</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetMomentByColumn(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="order">of moment, either 1 or 2</param>
	<returns>na of first moment of fg pixels, by column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixThresholdPixelSum(System.IntPtr,System.Int32,System.Int32@,System.Int32[])">
	<summary>
 Notes
 (1) This sums the ON pixels and returns immediately if the count
 goes above threshold.  It is therefore more efficient
 for matching images (by running this function on the xor of
 the 2 images) than using pixCountPixels(), which counts all
 pixels before returning.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="thresh">threshold</param>
	<param name="pabove">1 if above threshold; 0 if equal to or less than threshold</param>
	<param name="tab8">8-bit pixel lookup table</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makePixelSumTab8">
	<summary>
 Notes
 (1) This table of integers gives the number of 1 bits
 in the 8 bit index.
 </summary>
	<remarks>
	</remarks>
	<returns>table of 256 l_int32, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makePixelCentroidTab8">
	<summary>
 Notes
 (1) This table of integers gives the centroid weight of the 1 bits
 in the 8 bit index.  In other words, if sumtab is obtained by
 makePixelSumTab8, and centroidtab is obtained by
 makePixelCentroidTab8, then, for 1 LT= i LT= 255,
 centroidtab[i] / (float)sumtab[i]
 is the centroid of the 1 bits in the 8-bit index i, where the
 MSB is considered to have position 0 and the LSB is considered
 to have position 7.
 </summary>
	<remarks>
	</remarks>
	<returns>table of 256 l_int32, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAverageByRow(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 (2) If type == L_BLACK_IS_MAX, black pixels get the maximum
 value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 or 16 bpp; no colormap</param>
	<param name="box">clipping box for sum; can be null</param>
	<param name="type">L_WHITE_IS_MAX, L_BLACK_IS_MAX</param>
	<returns>na of pixel averages by row, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAverageByColumn(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 (2) If type == L_BLACK_IS_MAX, black pixels get the maximum
 value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 or 16 bpp; no colormap</param>
	<param name="box">clipping box for sum; can be null</param>
	<param name="type">L_WHITE_IS_MAX, L_BLACK_IS_MAX</param>
	<returns>na of pixel averages by column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAverageInRect(System.IntPtr,System.IntPtr,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1, 2, 4, 8 bpp; not cmapped</param>
	<param name="box">if null, use entire image</param>
	<param name="pave">average of pixel values in region</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixVarianceByRow(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 (2) We are actually computing the RMS deviation in each row.
 This is the square root of the variance.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 or 16 bpp; no colormap</param>
	<param name="box">clipping box for variance; can be null</param>
	<returns>na of rmsdev by row, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixVarianceByColumn(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 (2) We are actually computing the RMS deviation in each row.
 This is the square root of the variance.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 or 16 bpp; no colormap</param>
	<param name="box">clipping box for variance; can be null</param>
	<returns>na of rmsdev by column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixVarianceInRect(System.IntPtr,System.IntPtr,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1, 2, 4, 8 bpp; not cmapped</param>
	<param name="box">if null, use entire image</param>
	<param name="prootvar">sqrt variance of pixel values in region</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAbsDiffByRow(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This is an average over differences of adjacent pixels along
 each row.
 (2) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; no colormap</param>
	<param name="box">clipping box for region; can be null</param>
	<returns>na of abs val pixel difference averages by row, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAbsDiffByColumn(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This is an average over differences of adjacent pixels along
 each column.
 (2) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; no colormap</param>
	<param name="box">clipping box for region; can be null</param>
	<returns>na of abs val pixel difference averages by column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAbsDiffInRect(System.IntPtr,System.IntPtr,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) This gives the average over the abs val of differences of
 adjacent pixels values, along either each
 row  dir == L_HORIZONTAL_LINE
 column  dir == L_VERTICAL_LINE
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; not cmapped</param>
	<param name="box">if null, use entire image</param>
	<param name="dir">differences along L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
	<param name="pabsdiff">average of abs diff pixel values in region</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAbsDiffOnLine(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) This gives the average over the abs val of differences of
 adjacent pixels values, along a line that is either horizontal
 or vertical.
 (2) If horizontal, require x1 LT x2; if vertical, require y1 LT y2.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; not cmapped</param>
	<param name="x1">first point; x1 LT= x2, y1 LT= y2</param>
	<param name="y1">first point; x1 LT= x2, y1 LT= y2</param>
	<param name="x2">first point</param>
	<param name="y2">first point</param>
	<param name="pabsdiff">average of abs diff pixel values on line</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCountArbInRect(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) If pixs is cmapped, %val is compared to the colormap index;
 otherwise, %val is compared to the grayscale value.
 (2) Set the subsampling %factor GT 1 to reduce the amount of computation.
 If %factor GT 1, multiply the count by %factor  %factor.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, or colormapped</param>
	<param name="box">over which count is made; use entire image if NULL</param>
	<param name="val">pixel value to count</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="pcount">count; estimate it if factor GT 1</param>
	<returns>na histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMirroredTiling(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This uses mirrored tiling, where each row alternates
 with LR flips and every column alternates with TB
 flips, such that the result is a tiling with identical
 2 x 2 tiles, each of which is composed of these transforms
 -----------------
 | 1 |  LR |
 -----------------
 | TB   |  LR/TB |
 -----------------
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp, small tile; to be replicated</param>
	<param name="w">dimensions of output pix</param>
	<param name="h">dimensions of output pix</param>
	<returns>pixd usually larger pix, mirror-tiled with pixs, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindRepCloseTile(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This looks for one or two square tiles with conforming median
 intensity and low variance, that is outside but near the input box.
 (2) %mindist specifies the gap between the box and the
 potential tiles.  The tiles are given an overlap of 50%.
 %ntiles specifies the number of tiles that are tested
 beyond %mindist for each row or column.
 (3) For example, if %mindist = 20, %tilesize = 50 and %ntiles = 3,
 a horizontal search to the right will have 3 tiles in each row,
 with left edges at 20, 45 and 70 from the right edge of the
 input %box.  The number of rows of tiles is determined by
 the height of %box and %tsize, with the 50% overlap..
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="box">region of pixs to search around</param>
	<param name="searchdir">L_HORIZ or L_VERT; direction to search</param>
	<param name="mindist">min distance of selected tile edge from box; GT= 0</param>
	<param name="tsize">tile size; GT 1; even; typically ~50</param>
	<param name="ntiles">number of tiles tested in each row/column</param>
	<param name="pboxtile">region of best tile</param>
	<param name="debug">1    for debug output</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetGrayHistogram(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If pixs has a colormap, it is converted to 8 bpp gray.
 If you want a histogram of the colormap indices, use
 pixGetCmapHistogram().
 (2) If pixs does not have a colormap, the output histogram is
 of size 2^d, where d is the depth of pixs.
 (3) Set the subsampling factor GT 1 to reduce the amount of computation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 bpp; can be colormapped</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>na histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetGrayHistogramMasked(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If pixs is cmapped, it is converted to 8 bpp gray.
 If you want a histogram of the colormap indices, use
 pixGetCmapHistogramMasked().
 (2) This always returns a 256-value histogram of pixel values.
 (3) Set the subsampling factor GT 1 to reduce the amount of computation.
 (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
 (5) Input x,y are ignored unless pixm exists.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, or colormapped</param>
	<param name="pixm">1 bpp mask over which histogram is to be computed; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>na histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetGrayHistogramInRect(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If pixs is cmapped, it is converted to 8 bpp gray.
 If you want a histogram of the colormap indices, use
 pixGetCmapHistogramInRect().
 (2) This always returns a 256-value histogram of pixel values.
 (3) Set the subsampling %factor GT 1 to reduce the amount of computation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, or colormapped</param>
	<param name="box">over which histogram is to be computed; use full image if NULL</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>na histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetGrayHistogramTiled(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If pixs is cmapped, it is converted to 8 bpp gray.
 (2) This returns a set of 256-value histograms of pixel values.
 (3) Set the subsampling factor GT 1 to reduce the amount of computation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, colormap OK</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="nx">tiling; GT= 1; typically small</param>
	<param name="ny">tiling; GT= 1; typically small</param>
	<returns>naa set of histograms, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetColorHistogram(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This generates a set of three 256 entry histograms,
 one for each color component (r,g,b).
 (2) Set the subsampling %factor GT 1 to reduce the amount of computation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">rgb or colormapped</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="pnar">red histogram</param>
	<param name="pnag">green histogram</param>
	<param name="pnab">blue histogram</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetColorHistogramMasked(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This generates a set of three 256 entry histograms,
 (2) Set the subsampling %factor GT 1 to reduce the amount of computation.
 (3) Clipping of pixm (if it exists) to pixs is done in the inner loop.
 (4) Input x,y are ignored unless pixm exists.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb, or colormapped</param>
	<param name="pixm">1 bpp mask over which histogram is to be computed; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="pnar">red histogram</param>
	<param name="pnag">green histogram</param>
	<param name="pnab">blue histogram</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetCmapHistogram(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This generates a histogram of colormap pixel indices,
 and is of size 2^d.
 (2) Set the subsampling %factor GT 1 to reduce the amount of computation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped d = 2, 4 or 8</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>na histogram of cmap indices, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetCmapHistogramMasked(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates a histogram of colormap pixel indices,
 and is of size 2^d.
 (2) Set the subsampling %factor GT 1 to reduce the amount of computation.
 (3) Clipping of pixm to pixs is done in the inner loop.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped d = 2, 4 or 8</param>
	<param name="pixm">1 bpp mask over which histogram is to be computed; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>na histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetCmapHistogramInRect(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This generates a histogram of colormap pixel indices,
 and is of size 2^d.
 (2) Set the subsampling %factor GT 1 to reduce the amount of computation.
 (3) Clipping to the box is done in the inner loop.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped d = 2, 4 or 8</param>
	<param name="box">over which histogram is to be computed; use full image if NULL</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>na histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCountRGBColors(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">rgb or rgba</param>
	<returns>ncolors, or -1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetColorAmapHistogram(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This generates an ordered map from pixel value to histogram count.
 (2) Use amapGetCountForColor() to use the map to look up a count.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">rgb or rgba</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>amap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.amapGetCountForColor(System.IntPtr,System.UInt32)">
	<summary>
 Notes
 (1) The ordered map is made by pixGetColorAmapHistogram().
 </summary>
	<remarks>
	</remarks>
	<param name="amap">map from pixel value to count</param>
	<param name="val">rgb or rgba pixel value</param>
	<returns>count, or -1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRankValue(System.IntPtr,System.Int32,System.Single,System.UInt32@)">
	<summary>
 Notes
 (1) Simple function to get rank values of an image.
 For a color image, the median value (rank = 0.5) can be
 used to linearly remap the colors based on the median
 of a target image, using pixLinearMapToTargetColor().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, 32 bpp or colormapped</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="rank">between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest</param>
	<param name="pvalue">pixel value corresponding to input rank</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRankValueMaskedRGB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) Computes the rank component values of pixels in pixs that
 are under the fg of the optional mask.  If the mask is null, it
 computes the average of the pixels in pixs.
 (2) Set the subsampling %factor GT 1 to reduce the amount of
 computation.
 (4) Input x,y are ignored unless pixm exists.
 (5) The rank must be in [0.0 ... 1.0], where the brightest pixel
 has rank 1.0.  For the median pixel value, use 0.5.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="pixm">1 bpp mask over which rank val is to be taken; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="rank">between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest</param>
	<param name="prval">red component val for input rank</param>
	<param name="pgval">green component val for input rank</param>
	<param name="pbval">blue component val for input rank</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRankValueMasked(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) Computes the rank value of pixels in pixs that are under
 the fg of the optional mask.  If the mask is null, it
 computes the average of the pixels in pixs.
 (2) Set the subsampling %factor GT 1 to reduce the amount of
 computation.
 (3) Clipping of pixm (if it exists) to pixs is done in the inner loop.
 (4) Input x,y are ignored unless pixm exists.
 (5) The rank must be in [0.0 ... 1.0], where the brightest pixel
 has rank 1.0.  For the median pixel value, use 0.5.
 (6) The histogram can optionally be returned, so that other rank
 values can be extracted without recomputing the histogram.
 In that case, just use
 numaHistogramGetValFromRank(na, rank, val);
 on the returned Numa for additional rank values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, or colormapped</param>
	<param name="pixm">1 bpp mask, over which the rank val is to be taken; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="rank">between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest</param>
	<param name="pval">pixel value corresponding to input rank</param>
	<param name="pna">of histogram</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetPixelAverage(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.UInt32@)">
	<summary>
 Notes
 (1) For rgb pix, this is a more direct computation of the
 average value of the pixels in %pixs that are under the
 mask %pixm. It is faster than pixGetPixelStats(), which
 calls pixGetAverageMaskedRGB() and has the overhead of
 generating a temporary pix of each of the three components;
 this can take most of the time if %factor GT 1.
 (2) If %pixm is null, this gives the average value of all
 pixels in %pixs.  The returned value is an integer.
 (3) For color %pixs, the returned pixel value is in the standard
 uint32 RGBA packing.
 (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
 (5) Input x,y are ignored if %pixm does not exist.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp, or colormapped</param>
	<param name="pixm">1 bpp mask over which average is to be taken; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="pval">average pixel value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetPixelStats(System.IntPtr,System.Int32,System.Int32,System.UInt32@)">
	<summary>
 Notes
 (1) Simple function to get one of four statistical values of an image.
 (2) It does not take a mask it uses the entire image.
 (3) To get the average pixel value of an RGB image, suggest using
 pixGetPixelAverage(), which is considerably faster.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, 32 bpp or colormapped</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="type">L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION, L_VARIANCE</param>
	<param name="pvalue">pixel value corresponding to input type</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetAverageMaskedRGB(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) For usage, see pixGetAverageMasked().
 (2) If there is a colormap, it is removed before the 8 bpp
 component images are extracted.
 (3) A better name for this would be pixGetPixelStatsRGB()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, or colormapped</param>
	<param name="pixm">1 bpp mask over which average is to be taken; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="type">L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION, L_VARIANCE</param>
	<param name="prval">measured red value of given 'type'</param>
	<param name="pgval">measured green value of given 'type'</param>
	<param name="pbval">measured blue value of given 'type'</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetAverageMasked(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) Use L_MEAN_ABSVAL to get the average value of pixels in pixs
 that are under the fg of the optional mask.  If the mask
 is null, it finds the average of the pixels in pixs.
 (2) Likewise, use L_ROOT_MEAN_SQUARE to get the rms value of
 pixels in pixs, either masked or not; L_STANDARD_DEVIATION
 to get the standard deviation from the mean of the pixels;
 L_VARIANCE to get the average squared difference from the
 expected value.  The variance is the square of the stdev.
 For the standard deviation, we use
 sqrt([([x] - x)]^2) = sqrt([x^2] - [x]^2)
 (3) Set the subsampling %factor GT 1 to reduce the amount of
 computation.
 (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
 (5) Input x,y are ignored unless pixm exists.
 (6) A better name for this would be pixGetPixelStatsGray()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 16 bpp, or colormapped</param>
	<param name="pixm">1 bpp mask over which average is to be taken; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="type">L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION, L_VARIANCE</param>
	<param name="pval">measured value of given 'type'</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetAverageTiledRGB(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) For usage, see pixGetAverageTiled().
 (2) If there is a colormap, it is removed before the 8 bpp
 component images are extracted.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, or colormapped</param>
	<param name="sx">tile size; must be at least 2 x 2</param>
	<param name="sy">tile size; must be at least 2 x 2</param>
	<param name="type">L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION</param>
	<param name="ppixr">tiled 'average' of red component</param>
	<param name="ppixg">tiled 'average' of green component</param>
	<param name="ppixb">tiled 'average' of blue component</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetAverageTiled(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Only computes for tiles that are entirely contained in pixs.
 (2) Use L_MEAN_ABSVAL to get the average abs value within the tile;
 L_ROOT_MEAN_SQUARE to get the rms value within each tile;
 L_STANDARD_DEVIATION to get the standard dev. from the average
 within each tile.
 (3) If colormapped, converts to 8 bpp gray.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, or colormapped</param>
	<param name="sx">tile size; must be at least 2 x 2</param>
	<param name="sy">tile size; must be at least 2 x 2</param>
	<param name="type">L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION</param>
	<returns>pixd average values in each tile, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRowStats(System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This computes numas that represent column vectors of statistics,
 with each of its values derived from the corresponding row of a Pix.
 (2) Use NULL on input to prevent computation of any of the 5 numas.
 (3) Other functions that compute pixel row statistics are
 pixCountPixelsByRow()
 pixAverageByRow()
 pixVarianceByRow()
 pixGetRowStats()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; not cmapped</param>
	<param name="box">clipping box; can be null</param>
	<param name="pnamean">numa of mean values</param>
	<param name="pnamedian">numa of median values</param>
	<param name="pnamode">numa of mode intensity values</param>
	<param name="pnamodecount">numa of mode counts</param>
	<param name="pnavar">numa of variance</param>
	<param name="pnarootvar">numa of square root of variance</param>
	<returns>na numa of requested statistic for each row, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColumnStats(System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This computes numas that represent row vectors of statistics,
 with each of its values derived from the corresponding col of a Pix.
 (2) Use NULL on input to prevent computation of any of the 5 numas.
 (3) Other functions that compute pixel column statistics are
 pixCountPixelsByColumn()
 pixAverageByColumn()
 pixVarianceByColumn()
 pixGetColumnStats()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; not cmapped</param>
	<param name="box">clipping box; can be null</param>
	<param name="pnamean">numa of mean values</param>
	<param name="pnamedian">numa of median values</param>
	<param name="pnamode">numa of mode intensity values</param>
	<param name="pnamodecount">numa of mode counts</param>
	<param name="pnavar">numa of variance</param>
	<param name="pnarootvar">numa of square root of variance</param>
	<returns>na numa of requested statistic for each column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRangeValues(System.IntPtr,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If pixs is 8 bpp grayscale, the color selection type is ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, 32 bpp rgb, or colormapped</param>
	<param name="factor">subsampling factor; GT= 1; ignored if colormapped</param>
	<param name="color">L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE</param>
	<param name="pminval">minimum value of component</param>
	<param name="pmaxval">maximum value of component</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetExtremeValue(System.IntPtr,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If pixs is grayscale, the result is returned in grayval.
 Otherwise, if there is a colormap or d == 32,
 each requested color component is returned.  At least
 one color component (address) must be input.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, 32 bpp rgb, or colormapped</param>
	<param name="factor">subsampling factor; GT= 1; ignored if colormapped</param>
	<param name="type">L_SELECT_MIN or L_SELECT_MAX</param>
	<param name="prval">red component</param>
	<param name="pgval">green component</param>
	<param name="pbval">blue component</param>
	<param name="pgrayval">min or max gray value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetMaxValueInRect(System.IntPtr,System.IntPtr,System.UInt32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This can be used to find the maximum and its location
 in a 2-dimensional histogram, where the x and y directions
 represent two color components (e.g., saturation and hue).
 (2) Note that here a 32 bpp pixs has pixel values that are simply
 numbers.  They are not 8 bpp components in a colorspace.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16 or 32 bpp grayscale; no color space components</param>
	<param name="box">region; set box = NULL to use entire pixs</param>
	<param name="pmaxval">max value in region</param>
	<param name="pxmax">x location of max value</param>
	<param name="pymax">y location of max value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetBinnedComponentRange(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This returns the min and max average values of the
 selected color component in the set of rank bins,
 where the ranking is done using the specified component.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="nbins">number of equal population bins; must be GT 1</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="color">L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE</param>
	<param name="pminval">minimum value of component</param>
	<param name="pmaxval">maximum value of component</param>
	<param name="pcarray">color array of bins</param>
	<param name="fontsize">0 for no debug; for debug, valid set is {4,6,8,10,12,14,16,18,20}.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRankColorArray(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The color selection flag is one of L_SELECT_RED, L_SELECT_GREEN,
 L_SELECT_BLUE, L_SELECT_MIN, L_SELECT_MAX, L_SELECT_AVERAGE,
 L_SELECT_HUE, L_SELECT_SATURATION.
 (2) Then it finds the histogram of the selected color type in each
 RGB pixel.  For each of the %nbins sets of pixels,
 ordered by this color type value, find the average RGB color,
 and return this as a "rank color" array.  The output array
 has %nbins colors.
 (3) Set the subsampling factor GT 1 to reduce the amount of
 computation.  Typically you want at least 10,000 pixels
 for reasonable statistics.
 (4) The rank color as a function of rank can then be found from
 rankint = (l_int32)(rank  (nbins - 1) + 0.5);
 extractRGBValues(array[rankint], rval, gval, bval);
 where the rank is in [0.0 ... 1.0].
 This function is meant to be simple and approximate.
 (5) Compare this with pixGetBinnedColor(), which generates equal
 width intensity bins and finds the average color in each bin.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp or cmapped</param>
	<param name="nbins">number of equal population bins; must be GT 1</param>
	<param name="type">color selection flag</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="pcarray">array of colors, ranked by intensity</param>
	<param name="debugflag">1 to display color squares and plots of color components; 2 to write them as png to file</param>
	<param name="fontsize">0 for no debug; for debug, valid set is {4,6,8,10,12,14,16,18,20}.  Ignored if debugflag == 0.  fontsize == 6 is typical.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetBinnedColor(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This takes a color image, a grayscale (intensity) version,
 a LUT from intensity to bin number, and the number of bins.
 It computes the average color for pixels whose intensity
 is in each bin.  This is returned as an array of l_uint32
 colors in our standard RGBA ordering.
 (2) This function generates equal width intensity bins and
 finds the average color in each bin.  Compare this with
 pixGetRankColorArray(), which rank orders the pixels
 by the value of the selected component in each pixel,
 sets up bins with equal population (not intensity width!),
 and gets the average color in each bin.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="pixg">8 bpp grayscale version of pixs</param>
	<param name="factor">sampling factor along pixel counting direction</param>
	<param name="nbins">number of intensity bins</param>
	<param name="nalut">LUT for mapping from intensity to bin number</param>
	<param name="pcarray">array of average color values in each bin</param>
	<param name="debugflag">1 to display output debug plots of color components; 2 to write them as png to file</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDisplayColorArray(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="carray">array of colors 0xrrggbb00</param>
	<param name="ncolors">size of array</param>
	<param name="side">size of each color square; suggest 200</param>
	<param name="ncols">number of columns in output color matrix</param>
	<param name="fontsize">to label each square with text.  Valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	<returns>pixd color array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRankBinByStrip(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates a pix where each column represents a strip of
 the input image.  If %direction == L_SCAN_HORIZONTAL, the
 input impage is tiled into vertical strips of width %size,
 where %size is a compromise between getting better spatial
 columnwise resolution (small %size) and getting better
 columnwise statistical information (larger %size).  Likewise
 with rows of the image if %direction == L_SCAN_VERTICAL.
 (2) For L_HORIZONTAL_SCAN, the output pix contains rank binned
 median colors in each column that correspond to a vertical
 strip of width %size in the input image.
 (3) The color selection flag is one of L_SELECT_RED, L_SELECT_GREEN,
 L_SELECT_BLUE, L_SELECT_MIN, L_SELECT_MAX, L_SELECT_AVERAGE.
 It determines how the rank ordering is done.
 (4) Typical input values might be %size = 5, %nbins = 10.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp or cmapped</param>
	<param name="direction">L_SCAN_HORIZONTAL or L_SCAN_VERTICAL</param>
	<param name="size">of strips in scan direction</param>
	<param name="nbins">number of equal population bins; must be GT 1</param>
	<param name="type">color selection flag</param>
	<returns>pixd result, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaGetAlignedStats(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Each pixel in the returned pix represents an average
 (or median, or mode) over the corresponding pixels in each
 pix in the pixa.
 (2) The %thresh parameter works with L_MODE_VAL only, and
 sets a minimum occupancy of the mode bin.
 If the occupancy of the mode bin is less than %thresh, the
 mode value is returned as 0.  To always return the actual
 mode value, set %thresh = 0.  See pixGetRowStats().
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of identically sized, 8 bpp pix; not cmapped</param>
	<param name="type">L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT</param>
	<param name="nbins">of histogram for median and mode; ignored for mean</param>
	<param name="thresh">on histogram for mode val; ignored for all other types</param>
	<returns>pix with pixelwise aligned stats, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaExtractColumnFromEachPix(System.IntPtr,System.Int32,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa">of identically sized, 8 bpp; not cmapped</param>
	<param name="col">column index</param>
	<param name="pixd">pix into which each column is inserted</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRowStats(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single[])">
	<summary>
 Notes
 (1) This computes a column vector of statistics using each
 row of a Pix.  The result is put in %colvect.
 (2) The %thresh parameter works with L_MODE_VAL only, and
 sets a minimum occupancy of the mode bin.
 If the occupancy of the mode bin is less than %thresh, the
 mode value is returned as 0.  To always return the actual
 mode value, set %thresh = 0.
 (3) What is the meaning of this %thresh parameter?
 For each row, the total count in the histogram is w, the
 image width.  So %thresh, relative to w, gives a measure
 of the ratio of the bin width to the width of the distribution.
 The larger %thresh, the narrower the distribution must be
 for the mode value to be returned (instead of returning 0).
 (4) If the Pix consists of a set of corresponding columns,
 one for each Pix in a Pixa, the width of the Pix is the
 number of Pix in the Pixa and the column vector can
 be stored as a column in a Pix of the same size as
 each Pix in the Pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; not cmapped</param>
	<param name="type">L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT</param>
	<param name="nbins">of histogram for median and mode; ignored for mean</param>
	<param name="thresh">on histogram for mode; ignored for mean and median</param>
	<param name="colvect">vector of results gathered across the rows of pixs</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetColumnStats(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single[])">
	<summary>
 Notes
 (1) This computes a row vector of statistics using each
 column of a Pix.  The result is put in %rowvect.
 (2) The %thresh parameter works with L_MODE_VAL only, and
 sets a minimum occupancy of the mode bin.
 If the occupancy of the mode bin is less than %thresh, the
 mode value is returned as 0.  To always return the actual
 mode value, set %thresh = 0.
 (3) What is the meaning of this %thresh parameter?
 For each column, the total count in the histogram is h, the
 image height.  So %thresh, relative to h, gives a measure
 of the ratio of the bin width to the width of the distribution.
 The larger %thresh, the narrower the distribution must be
 for the mode value to be returned (instead of returning 0).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; not cmapped</param>
	<param name="type">L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT</param>
	<param name="nbins">of histogram for median and mode; ignored for mean</param>
	<param name="thresh">on histogram for mode val; ignored for all other types</param>
	<param name="rowvect">vector of results gathered down the columns of pixs</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetPixelColumn(System.IntPtr,System.Int32,System.Single[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; not cmapped</param>
	<param name="col">column index</param>
	<param name="colvect">vector of floats</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixThresholdForFgBg(System.IntPtr,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; cmapped ok</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="thresh">threshold for generating foreground mask</param>
	<param name="pfgval">average foreground value</param>
	<param name="pbgval">average background value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSplitDistributionFgBg(System.IntPtr,System.Single,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.IntPtr@)">
	<summary>
 Notes
 (1) See numaSplitDistribution() for details on the underlying
 method of choosing a threshold.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; cmapped ok</param>
	<param name="scorefract">fraction of the max score, used to determine the range over which the histogram min is searched</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="pthresh">best threshold for separating</param>
	<param name="pfgval">average foreground value</param>
	<param name="pbgval">average background value</param>
	<param name="ppixdb">plot of distribution and split point</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaFindDimensions(System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pnaw">numa of pix widths</param>
	<param name="pnah">numa of pix heights</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindAreaPerimRatio(System.IntPtr,System.Int32[],System.Single[]@)">
	<summary>
 Notes
 (1) The area is the number of fg pixels that are not on the
 boundary (i.e., are not 8-connected to a bg pixel), and the
 perimeter is the number of fg boundary pixels.  Returns
 0.0 if there are no fg pixels.
 (2) This function is retained because clients are using it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="tab">pixel sum table, can be NULL</param>
	<param name="pfract">area/perimeter ratio</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaFindPerimToAreaRatio(System.IntPtr)">
	<summary>
 Notes
 (1) This is typically used for a pixa consisting of
 1 bpp connected components.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp pix</param>
	<returns>na   of perimeter/arear ratio for each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindPerimToAreaRatio(System.IntPtr,System.Int32[],System.Single[]@)">
	<summary>
 Notes
 (1) The perimeter is the number of fg boundary pixels, and the
 area is the number of fg pixels.  This returns 0.0 if
 there are no fg pixels.
 (2) Unlike pixFindAreaPerimRatio(), this uses the full set of
 fg pixels for the area, and the ratio is taken in the opposite
 order.
 (3) This is typically used for a single connected component.
 This always has a value LT= 1.0, and if the average distance
 of a fg pixel from the nearest bg pixel is d, this has
 a value ~1/d.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="tab">pixel sum table, can be NULL</param>
	<param name="pfract">perimeter/area ratio</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaFindPerimSizeRatio(System.IntPtr)">
	<summary>
 Notes
 (1) This is typically used for a pixa consisting of
 1 bpp connected components.
 (2) This has a minimum value for a circle of pi/4; a value for
 a rectangle component of approx. 1.0; and a value much larger
 than 1.0 for a component with a highly irregular boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp pix</param>
	<returns>na   of fg perimeter/(2(w+h)) ratio for each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindPerimSizeRatio(System.IntPtr,System.Int32[],System.Single[]@)">
	<summary>
 Notes
 (1) We take the 'size' as twice the sum of the width and
 height of pixs, and the perimeter is the number of fg
 boundary pixels.  We use the fg pixels of the boundary
 because the pix may be clipped to the boundary, so an
 erosion is required to count all boundary pixels.
 (2) This has a large value for dendritic, fractal-like components
 with highly irregular boundaries.
 (3) This is typically used for a single connected component.
 It has a value of about 1.0 for rectangular components with
 relatively smooth boundaries.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="tab">pixel sum table, can be NULL</param>
	<param name="pratio">perimeter/size ratio</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaFindAreaFraction(System.IntPtr)">
	<summary>
 Notes
 (1) This is typically used for a pixa consisting of
 1 bpp connected components.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp pix</param>
	<returns>na  of area fractions for each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindAreaFraction(System.IntPtr,System.Int32[],System.Single[]@)">
	<summary>
 Notes
 (1) This finds the ratio of the number of fg pixels to the
 size of the pix (w  h).  It is typically used for a
 single connected component.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="tab">pixel sum table, can be NULL</param>
	<param name="pfract">fg area/size ratio</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaFindAreaFractionMasked(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is typically used for a pixa consisting of
 1 bpp connected components, which has an associated
 boxa giving the location of the components relative
 to the mask origin.
 (2) The debug flag displays in green and red the masked and
 unmasked parts of the image from which pixa was derived.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp pix</param>
	<param name="pixm">mask image</param>
	<param name="debug">1 for output, 0 to suppress</param>
	<returns>na of ratio masked/total fractions for each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindAreaFractionMasked(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32[],System.Single[]@)">
	<summary>
 Notes
 (1) This finds the ratio of the number of masked fg pixels
 in pixs to the total number of fg pixels in pixs.
 It is typically used for a single connected component.
 If there are no fg pixels, this returns a ratio of 0.0.
 (2) The box gives the location of the pix relative to that
 of the UL corner of the mask.  Therefore, the rasterop
 is performed with the pix translated to its location
 (x, y) in the mask before ANDing.
 If box == NULL, the UL corners of pixs and pixm are aligned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, typically a single component</param>
	<param name="box">for pixs relative to pixm</param>
	<param name="pixm">1 bpp mask, typically over the entire image from which the component pixs was extracted</param>
	<param name="tab">pixel sum table, can be NULL</param>
	<param name="pfract">fg area/size ratio</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaFindWidthHeightRatio(System.IntPtr)">
	<summary>
 Notes
 (1) This is typically used for a pixa consisting of
 1 bpp connected components.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp pix</param>
	<returns>na of width/height ratios for each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaFindWidthHeightProduct(System.IntPtr)">
	<summary>
 Notes
 (1) This is typically used for a pixa consisting of
 1 bpp connected components.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp pix</param>
	<returns>na of widthheight products for each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindOverlapFraction(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32[],System.Single[]@,System.Int32@)">
	<summary>
 Notes
 (1) The UL corner of pixs2 is placed at (x2, y2) in pixs1.
 (2) This measure is similar to the correlation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">1 bpp</param>
	<param name="pixs2">1 bpp</param>
	<param name="x2">location in pixs1 of UL corner of pixs2</param>
	<param name="y2">location in pixs1 of UL corner of pixs2</param>
	<param name="tab">pixel sum table, can be null</param>
	<param name="pratio">ratio fg intersection to fg union</param>
	<param name="pnoverlap">number of overlapping pixels</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindRectangleComps(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This applies the function pixConformsToRectangle() to
 each 8-c.c. in pixs, and returns a boxa containing the
 regions of all components that are conforming.
 (2) Conforming components must satisfy both the size constraint
 given by %minsize and the slop in conforming to a rectangle
 determined by %dist.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="dist">max distance allowed between bounding box and nearest foreground pixel within it</param>
	<param name="minw">minimum size in each direction as a requirement for a conforming rectangle</param>
	<param name="minh">minimum size in each direction as a requirement for a conforming rectangle</param>
	<returns>boxa of components that conform, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConformsToRectangle(System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) There are several ways to test if a connected component has
 an essentially rectangular boundary, such as
 a. Fraction of fill into the bounding box
 b. Max-min distance of fg pixel from periphery of bounding box
 c. Max depth of bg intrusions into component within bounding box
 The weakness of (a) is that it is highly sensitive to holes
 within the c.c.  The weakness of (b) is that it can have
 arbitrarily large intrusions into the c.c.  Method (c) tests
 the integrity of the outer boundary of the c.c., with respect
 to the enclosing bounding box, so we use it.
 (2) This tests if the connected component within the box conforms
 to the box at all points on the periphery within %dist.
 Inside, at a distance from the box boundary that is greater
 than %dist, we don't care about the pixels in the c.c.
 (3) We can think of the conforming condition as follows
 No pixel inside a distance %dist from the boundary
 can connect to the boundary through a path through the bg.
 To implement this, we need to do a flood fill.  We can go
 either from inside toward the boundary, or the other direction.
 It's easiest to fill from the boundary, and then verify that
 there are no filled pixels farther than %dist from the boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="box">if null, use the entire pixs</param>
	<param name="dist">max distance allowed between bounding box and nearest foreground pixel within it</param>
	<param name="pconforms">0 (false) if not conforming; 1 (true) if conforming</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixClipRectangles(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) The returned pixa includes the actual regions clipped out from
 the input pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="boxa">requested clipping regions</param>
	<returns>pixa consisting of requested regions, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixClipRectangle(System.IntPtr,System.IntPtr,System.IntPtr@)">
	<summary>
 Notes
 This should be simple, but there are choices to be made.
 The box is defined relative to the pix coordinates.  However,
 if the box is not contained within the pix, we have two choices
 (1) clip the box to the pix
 (2) make a new pix equal to the full box dimensions,
 but let rasterop do the clipping and positioning
 of the src with respect to the dest
 Choice (2) immediately brings up the problem of what pixel values
 to use that were not taken from the src.  For example, on a grayscale
 image, do you want the pixels not taken from the src to be black
 or white or something else?  To implement choice 2, one needs to
 specify the color of these extra pixels.
 So we adopt (1), and clip the box first, if necessary,
 before making the dest pix and doing the rasterop.  But there
 is another issue to consider.  If you want to paste the
 clipped pix back into pixs, it must be properly aligned, and
 it is necessary to use the clipped box for alignment.
 Accordingly, this function has a third (optional) argument, which is
 the input box clipped to the src pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="box">requested clipping region; const</param>
	<param name="pboxc">actual box of clipped region</param>
	<returns>clipped pix, or NULL on error or if rectangle doesn't intersect pixs</returns>
</member><member name="M:LeptonicaSharp.Natives.pixClipMasked(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) If pixs has a colormap, it is preserved in pixd.
 (2) The depth of pixd is the same as that of pixs.
 (3) If the depth of pixs is 1, use %outval = 0 for white background
 and 1 for black; otherwise, use the max value for white
 and 0 for black.  If pixs has a colormap, the max value for
 %outval is 0xffffffff; otherwise, it is 2^d - 1.
 (4) When using 1 bpp pixs, this is a simple clip and
 blend operation.  For example, if both pix1 and pix2 are
 black text on white background, and you want to OR the
 fg on the two images, let pixm be the inverse of pix2.
 Then the operation takes all of pix1 that's in the bg of
 pix2, and for the remainder (which are the pixels
 corresponding to the fg of the pix2), paint them black
 (1) in pix1.  The function call looks like
 pixClipMasked(pix2, pixInvert(pix1, pix1), x, y, 1);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp; colormap ok</param>
	<param name="pixm">clipping mask, 1 bpp</param>
	<param name="x">origin of clipping mask relative to pixs</param>
	<param name="y">origin of clipping mask relative to pixs</param>
	<param name="outval">val to use for pixels that are outside the mask</param>
	<returns>pixd, clipped pix or NULL on error or if pixm doesn't intersect pixs</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCropToMatch(System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This resizes pixs1 and/or pixs2 by cropping at the right
 and bottom, so that they're the same size.
 (2) If a pix doesn't need to be cropped, a clone is returned.
 (3) Note the images are implicitly aligned to the UL corner.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">any depth, colormap OK</param>
	<param name="pixs2">any depth, colormap OK</param>
	<param name="ppixd1">may be a clone</param>
	<param name="ppixd2">may be a clone</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCropToSize(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If either w or h is smaller than the corresponding dimension
 of pixs, this returns a cropped image; otherwise it returns
 a clone of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, colormap OK</param>
	<param name="w">max dimensions of cropped image</param>
	<param name="h">max dimensions of cropped image</param>
	<returns>pixd cropped if necessary or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixResizeToMatch(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This resizes pixs to make pixd, without scaling, by either
 cropping or extending separately in both width and height.
 Extension is done by replicating the last row or column.
 This is useful in a situation where, due to scaling
 operations, two images that are expected to be the
 same size can differ slightly in each dimension.
 (2) You can use either an existing pixt or specify
 both %w and %h.  If pixt is defined, the values
 in %w and %h are ignored.
 (3) If pixt is larger than pixs (or if w and/or d is larger
 than the dimension of pixs, replicate the outer row and
 column of pixels in pixs into pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp; colormap ok</param>
	<param name="pixt">; we use only the size</param>
	<param name="w">ignored if pixt is defined</param>
	<param name="h">ignored if pixt is defined</param>
	<returns>pixd resized to match or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMakeFrameMask(System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This makes an arbitrary 1-component mask with a centered fg
 frame, which can have both an inner and an outer boundary.
 All input fractional distances are measured from the image
 border to the frame boundary, in units of the image half-width
 for hf1 and hf2 and the image half-height for vf1 and vf2.
 The distances to the outer frame boundary are given by hf1
 and vf1; to the inner frame boundary, by hf2 and vf2.
 Input fractions are thus in [0.0 ... 1.0], with hf1 LT= hf2
 and vf1 LT= vf2.  Horizontal and vertical frame widths are
 thus independently specified.
 (2) Special cases
 full fg mask hf1 = vf1 = 0.0, hf2 = vf2 = 1.0.
 empty fg (zero width) mask set  hf1 = hf2  and vf1 = vf2.
 fg rectangle with no hole set hf2 = vf2 = 1.0.
 frame touching outer boundary set hf1 = vf1 = 0.0.
 (3) The vertical thickness of the horizontal mask parts
 is 0.5  (vf2 - vf1)  h.  The horizontal thickness of the
 vertical mask parts is 0.5  (hf2 - hf1)  w.
 </summary>
	<remarks>
	</remarks>
	<param name="w">dimensions of output 1 bpp pix</param>
	<param name="h">dimensions of output 1 bpp pix</param>
	<param name="hf1">horizontal fraction of half-width at outer frame bdry</param>
	<param name="hf2">horizontal fraction of half-width at inner frame bdry</param>
	<param name="vf1">vertical fraction of half-width at outer frame bdry</param>
	<param name="vf2">vertical fraction of half-width at inner frame bdry</param>
	<returns>pixd 1 bpp, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMakeCoveringOfRectangles(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This iteratively finds the bounding boxes of the connected
 components and generates a mask from them.  Two iterations
 should suffice for most situations.
 (2) Returns an empty pix if %pixs is empty.
 (3) If there are many small components in proximity, it may
 be useful to merge them with a morphological closing before
 calling this one.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="maxiters">max iterations use 0 to iterate to completion</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFractionFgInMask(System.IntPtr,System.IntPtr,System.Single[]@)">
	<summary>
 Notes
 (1) This gives the fraction of fg pixels in pix1 that are in
 the intersection (i.e., under the fg) of pix2
 |1  2|/|1|, where |...| means the number of fg pixels.
 Note that this is different from the situation where
 pix1 and pix2 are reversed.
 (2) Both pix1 and pix2 are registered to the UL corners.  A warning
 is issued if pix1 and pix2 have different sizes.
 (3) This can also be used to find the fraction of fg pixels in pix1
 that are NOT under the fg of pix2 1.0 - |1  2|/|1|
 (4) If pix1 or pix2 are empty, this returns %fract = 0.0.
 (5) For example, pix2 could be a frame around the outside of the
 image, made from pixMakeFrameMask().
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">1 bpp</param>
	<param name="pix2">1 bpp</param>
	<param name="pfract">fraction of fg pixels in 1 that are aligned with the fg of 2</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixClipToForeground(System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) At least one of {pixd, box} must be specified.
 (2) If there are no fg pixels, the returned ptrs are null.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="ppixd">clipped pix returned</param>
	<param name="pbox">bounding box</param>
	<returns>0 if OK; 1 on error or if there are no fg pixels</returns>
</member><member name="M:LeptonicaSharp.Natives.pixTestClipToForeground(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) This is a lightweight test to determine if a 1 bpp image
 can be further cropped without loss of fg pixels.
 If it cannot, canclip is set to 0.
 (2) It does not test for the existence of any fg pixels.
 If there are no fg pixels, it will return %canclip = 1.
 Check the output of the subsequent call to pixClipToForeground().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pcanclip">1 if fg does not extend to all four edges</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixClipBoxToForeground(System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) At least one of {pixd, boxd} must be specified.
 (2) If there are no fg pixels, the returned ptrs are null.
 (3) Do not use pixs for the 3rd arg or boxs for the 4th arg;
 this will leak memory.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="boxs">use full image if null</param>
	<param name="ppixd">clipped pix returned</param>
	<param name="pboxd">bounding box</param>
	<returns>0 if OK; 1 on error or if there are no fg pixels</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScanForForeground(System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) If there are no fg pixels, the position is set to 0.
 Caller must check the return value!
 (2) Use %box == NULL to scan from edge of pixs
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="box">within which the search is conducted</param>
	<param name="scanflag">direction of scan; e.g., L_FROM_LEFT</param>
	<param name="ploc">location in scan direction of first black pixel</param>
	<returns>0 if OK; 1 on error or if no fg pixels are found</returns>
</member><member name="M:LeptonicaSharp.Natives.pixClipBoxToEdges(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) At least one of {pixd, boxd} must be specified.
 (2) If there are no fg pixels, the returned ptrs are null.
 (3) This function attempts to locate rectangular "image" regions
 of high-density fg pixels, that have well-defined edges
 on the four sides.
 (4) Edges are searched for on each side, iterating in order
 from left, right, top and bottom.  As each new edge is
 found, the search box is resized to use that location.
 Once an edge is found, it is held.  If no more edges
 are found in one iteration, the search fails.
 (5) See pixScanForEdge() for usage of the thresholds and %maxwidth.
 (6) The thresholds must be at least 1, and the low threshold
 cannot be larger than the high threshold.
 (7) If the low and high thresholds are both 1, this is equivalent
 to pixClipBoxToForeground().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="boxs">; use full image if null</param>
	<param name="lowthresh">threshold to choose clipping location</param>
	<param name="highthresh">threshold required to find an edge</param>
	<param name="maxwidth">max allowed width between low and high thresh locs</param>
	<param name="factor">sampling factor along pixel counting direction</param>
	<param name="ppixd">clipped pix returned</param>
	<param name="pboxd">bounding box</param>
	<returns>0 if OK; 1 on error or if a fg edge is not found from all four sides.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScanForEdge(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) If there are no fg pixels, the position is set to 0.
 Caller must check the return value!
 (2) Use %box == NULL to scan from edge of pixs
 (3) As the scan progresses, the location where the sum of
 pixels equals or excees %lowthresh is noted (loc).  The
 scan is stopped when the sum of pixels equals or exceeds
 %highthresh.  If the scan distance between loc and that
 point does not exceed %maxwidth, an edge is found and
 its position is taken to be loc.  %maxwidth implicitly
 sets a minimum on the required gradient of the edge.
 (4) The thresholds must be at least 1, and the low threshold
 cannot be larger than the high threshold.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="box">within which the search is conducted</param>
	<param name="lowthresh">threshold to choose clipping location</param>
	<param name="highthresh">threshold required to find an edge</param>
	<param name="maxwidth">max allowed width between low and high thresh locs</param>
	<param name="factor">sampling factor along pixel counting direction</param>
	<param name="scanflag">direction of scan; e.g., L_FROM_LEFT</param>
	<param name="ploc">location in scan direction of first black pixel</param>
	<returns>0 if OK; 1 on error or if the edge is not found</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExtractOnLine(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Input end points are clipped to the pix.
 (2) If the line is either horizontal, or closer to horizontal
 than to vertical, the points will be extracted from left
 to right in the pix.  Likewise, if the line is vertical,
 or closer to vertical than to horizontal, the points will
 be extracted from top to bottom.
 (3) Can be used with numaCountReverals(), for example, to
 characterize the intensity smoothness along a line.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp or 8 bpp; no colormap</param>
	<param name="x1">one end point for line</param>
	<param name="y1">one end point for line</param>
	<param name="x2">another end pt for line</param>
	<param name="y2">another end pt for line</param>
	<param name="factor">sampling; GT= 1</param>
	<returns>na of pixel values along line, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAverageOnLine(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The line must be either horizontal or vertical, so either
 y1 == y2 (horizontal) or x1 == x2 (vertical).
 (2) If horizontal, x1 must be LT= x2.
 If vertical, y1 must be LT= y2.
 characterize the intensity smoothness along a line.
 (3) Input end points are clipped to the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp or 8 bpp; no colormap</param>
	<param name="x1">starting pt for line</param>
	<param name="y1">starting pt for line</param>
	<param name="x2">end pt for line</param>
	<param name="y2">end pt for line</param>
	<param name="factor">sampling; GT= 1</param>
	<returns>average of pixel values along line, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAverageIntensityProfile(System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If d != 1 bpp, colormaps are removed and the result
 is converted to 8 bpp.
 (2) If %dir == L_HORIZONTAL_LINE, the intensity is averaged
 along each horizontal raster line (sampled by %factor1),
 and the profile is the array of these averages in the
 vertical direction between %first and %last raster lines,
 and sampled by %factor2.
 (3) If %dir == L_VERTICAL_LINE, the intensity is averaged
 along each vertical line (sampled by %factor1),
 and the profile is the array of these averages in the
 horizontal direction between %first and %last columns,
 and sampled by %factor2.
 (4) The averages are measured over the central %fract of the image.
 Use %fract == 1.0 to average across the entire width or height.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; colormap OK</param>
	<param name="fract">fraction of image width or height to be used</param>
	<param name="dir">averaging direction L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
	<param name="first">last span of rows or columns to measure</param>
	<param name="factor1">sampling along fast scan direction; GT= 1</param>
	<param name="factor2">sampling along slow scan direction; GT= 1</param>
	<returns>na of reversal profile, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReversalProfile(System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If d != 1 bpp, colormaps are removed and the result
 is converted to 8 bpp.
 (2) If %dir == L_HORIZONTAL_LINE, the the reversals are counted
 along each horizontal raster line (sampled by %factor1),
 and the profile is the array of these sums in the
 vertical direction between %first and %last raster lines,
 and sampled by %factor2.
 (3) If %dir == L_VERTICAL_LINE, the the reversals are counted
 along each vertical column (sampled by %factor1),
 and the profile is the array of these sums in the
 horizontal direction between %first and %last columns,
 and sampled by %factor2.
 (4) For each row or column, the reversals are summed over the
 central %fract of the image.  Use %fract == 1.0 to sum
 across the entire width (of row) or height (of column).
 (5) %minreversal is the relative change in intensity that is
 required to resolve peaks and valleys.  A typical number for
 locating text in 8 bpp might be 50.  For 1 bpp, minreversal
 must be 1.
 (6) The reversal profile is simply the number of reversals
 in a row or column, vs the row or column index.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; colormap OK</param>
	<param name="fract">fraction of image width or height to be used</param>
	<param name="dir">profile direction L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
	<param name="first">span of rows or columns to measure</param>
	<param name="last">span of rows or columns to measure</param>
	<param name="minreversal">minimum change in intensity to trigger a reversal</param>
	<param name="factor1">sampling along raster line (fast scan); GT= 1</param>
	<param name="factor2">sampling of raster lines (slow scan); GT= 1</param>
	<returns>na of reversal profile, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWindowedVarianceOnLine(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) The returned variance array traverses the line starting
 from the smallest coordinate, min(c1,c2).
 (2) Line end points are clipped to pixs.
 (3) The reference point for the variance calculation is the center of
 the window.  Therefore, the numa start parameter from
 pixExtractOnLine() is incremented by %size/2,
 to align the variance values with the pixel coordinate.
 (4) The square root of the variance is the RMS deviation from the mean.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="dir">L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
	<param name="loc">location of the constant coordinate for the line</param>
	<param name="c1">end point coordinates for the line</param>
	<param name="c2">end point coordinates for the line</param>
	<param name="size">window size; must be GT 1</param>
	<param name="pnad">windowed square root of variance</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMinMaxNearLine(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) If the line is more horizontal than vertical, the values
 are computed for [x1, x2], and the pixels are taken
 below and/or above the local y-value.  Otherwise, the
 values are computed for [y1, y2] and the pixels are taken
 to the left and/or right of the local x value.
 (2) %direction specifies which side (or both sides) of the
 line are scanned for min and max values.
 (3) There are two ways to tell if the returned values of min
 and max averages are valid the returned values cannot be
 negative and the function must return 0.
 (4) All accessed pixels are clipped to the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="x1">starting pt for line</param>
	<param name="y1">starting pt for line</param>
	<param name="x2">end pt for line</param>
	<param name="y2">end pt for line</param>
	<param name="dist">distance to search from line in each direction</param>
	<param name="direction">L_SCAN_NEGATIVE, L_SCAN_POSITIVE, L_SCAN_BOTH</param>
	<param name="pnamin">minimum values</param>
	<param name="pnamax">maximum values</param>
	<param name="pminave">average of minimum values</param>
	<param name="pmaxave">average of maximum values</param>
	<returns>0 if OK; 1 on error or if there are no sampled points within the image.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRankRowTransform(System.IntPtr)">
	<summary>
 Notes
 (1) The time is O(n) in the number of pixels and runs about
 100 Mpixels/sec on a 3 GHz machine.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<returns>pixd with pixels sorted in each row, from min to max value</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRankColumnTransform(System.IntPtr)">
	<summary>
 Notes
 (1) The time is O(n) in the number of pixels and runs about
 50 Mpixels/sec on a 3 GHz machine.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<returns>pixd with pixels sorted in each column, from min to max value</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaCreate(System.Int32)">
	<summary>
 Notes
 (1) This creates an empty boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="n">initial number of ptrs</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaCreateFromPix(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For bpp = 1, we truncate each retrieved pix to the ON
 pixels, which we assume for now start at (0,0)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">with individual components on a lattice</param>
	<param name="n">number of components</param>
	<param name="cellw">width of each cell</param>
	<param name="cellh">height of each cell</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaCreateFromBoxa(System.IntPtr,System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) This simply extracts from pixs the region corresponding to each
 box in the boxa.
 (2) The 3rd arg is optional.  If the extent of the boxa exceeds the
 size of the pixa, so that some boxes are either clipped
 or entirely outside the pix, a warning is returned as TRUE.
 (3) pixad will have only the properly clipped elements, and
 the internal boxa will be correct.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="boxa"></param>
	<param name="pcropwarn">TRUE if the boxa extent is larger than pixs.</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSplitPix(System.IntPtr,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) This is a variant on pixaCreateFromPix(), where we
 simply divide the image up into (approximately) equal
 subunits.  If you want the subimages to have essentially
 the same aspect ratio as the input pix, use nx = ny.
 (2) If borderwidth is 0, we ignore the input bordercolor and
 redefine it to white.
 (3) The bordercolor is always used to initialize each tiled pix,
 so that if the src is clipped, the unblitted part will
 be this color.  This avoids 1 pixel wide black stripes at the
 left and lower edges.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">with individual components on a lattice</param>
	<param name="nx">number of mosaic cells horizontally</param>
	<param name="ny">number of mosaic cells vertically</param>
	<param name="borderwidth">of added border on all sides</param>
	<param name="bordercolor">in our RGBA format 0xrrggbbaa</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the pixa.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppixa">ed</param>
</member><member name="M:LeptonicaSharp.Natives.pixaCopy(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="copyflag">see pix.h for details L_COPY makes a new pixa and copies each pix and each box; L_CLONE gives a new ref-counted handle to the input pixa; L_COPY_CLONE makes a new pixa and inserts clones of all pix and boxes</param>
	<returns>new pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaAddPix(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pix">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaAddBox(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="box"></param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaExtendArrayToSize(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If necessary, reallocs new pixa and boxa ptrs arrays to %size.
 The pixa and boxa ptr arrays must always be equal in size.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="size"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<returns>count, or 0 if no pixa</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaChangeRefcount(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="delta"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaGetPix(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">to the index-th pix</param>
	<param name="accesstype">L_COPY or L_CLONE</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaGetPixDimensions(System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">to the index-th box</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<param name="pd">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaGetBoxa(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="accesstype">L_COPY, L_CLONE, L_COPY_CLONE</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaGetBoxaCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaGetBox(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) There is always a boxa with a pixa, and it is initialized so
 that each box ptr is NULL.
 (2) In general, we expect that there is either a box associated
 with each pix, or no boxes at all in the boxa.
 (3) Having no boxes is thus not an automatic error.  Whether it
 is an actual error is determined by the calling program.
 If the caller expects to get a box, it is an error; see, e.g.,
 pixaGetBoxGeometry().
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">to the index-th pix</param>
	<param name="accesstype">L_COPY or L_CLONE</param>
	<returns>box if null, not automatically an error, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaGetBoxGeometry(System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">to the index-th box</param>
	<param name="px">each can be null</param>
	<param name="py">each can be null</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSetBoxa(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This destroys the existing boxa in the pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="boxa"></param>
	<param name="accesstype">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaGetPixArray(System.IntPtr)">
	<summary>
 Notes
 (1) This returns a ptr to the actual array.  The array is
 owned by the pixa, so it must not be destroyed.
 (2) The caller should always check if the return value is NULL
 before accessing any of the pix ptrs in this array!
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<returns>pix array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaVerifyDepth(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) It is considered to be an error if there are no pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="psame">1 if depth is the same for all pix; 0 otherwise</param>
	<param name="pmaxd">max depth of all pix</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaVerifyDimensions(System.IntPtr,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) It is considered to be an error if there are no pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="psame">1 if dimensions are the same for all pix; 0 otherwise</param>
	<param name="pmaxw">max width of all pix</param>
	<param name="pmaxh">max height of all pix</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaIsFull(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) A pixa is "full" if the array of pix is fully
 occupied from index 0 to index (pixa-GTn - 1).
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pfullpa">1 if pixa is full</param>
	<param name="pfullba">1 if boxa is full</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaCountText(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) All pix have non-empty text strings if the returned value %ntext
 equals the pixa count.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pntext">number of pix with non-empty text strings</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSetText(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) To clear all the text fields, use sa == NULL;
 (2) If sa is defined, it must be the same size as %pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="sa">array of text strings, to insert in each pix</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaGetLinePtrs(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) See pixGetLinePtrs() for details.
 (2) It is best if all pix in the pixa are the same size.
 The size of each line ptr array is equal to the height
 of the pix that it refers to.
 (3) This is an array of arrays.  To destroy it
 for (i = 0; i LT size; i++)
 LEPT_FREE(lineset[i]);
 LEPT_FREE(lineset);
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of pix that all have the same depth</param>
	<param name="psize">number of pix in the pixa</param>
	<returns>array of array of line ptrs, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaWriteStreamInfo(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) For each pix in the pixa, write out the pix dimensions, spp,
 text string (if it exists), and cmap info.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pixa"></param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaReplacePix(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) In-place replacement of one pix.
 (2) The previous pix at that location is destroyed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">to the index-th pix</param>
	<param name="pix">insert to replace existing one</param>
	<param name="box">insert to replace existing</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaInsertPix(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This shifts pixa[i] --GT pixa[i + 1] for all i GT= index,
 and then inserts at pixa[index].
 (2) To insert at the beginning of the array, set index = 0.
 (3) It should not be used repeatedly on large arrays,
 because the function is O(n).
 (4) To append a pix to a pixa, it's easier to use pixaAddPix().
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">at which pix is to be inserted</param>
	<param name="pixs">new pix to be inserted</param>
	<param name="box">new box to be inserted</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaRemovePix(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This shifts pixa[i] --GT pixa[i - 1] for all i GT index.
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 (3) The corresponding box is removed as well, if it exists.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">of pix to be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaRemovePixAndSave(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This shifts pixa[i] --GT pixa[i - 1] for all i GT index.
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 (3) The corresponding box is removed as well, if it exists.
 (4) The removed pix and box can either be retained or destroyed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">of pix to be removed</param>
	<param name="ppix">removed pix</param>
	<param name="pbox">removed box</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaInitFull(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This initializes a pixa by filling up the entire pix ptr array
 with copies of %pix.  If %pix == NULL, we use a tiny placeholder
 pix (w = h = d = 1).  Any existing pix are destroyed.
 It also optionally fills the boxa with copies of %box.
 After this operation, the numbers of pix and (optionally)
 boxes are equal to the number of allocated ptrs.
 (2) Note that we use pixaReplacePix() instead of pixaInsertPix().
 They both have the same effect when inserting into a NULL ptr
 in the pixa ptr array
 (3) If the boxa is not initialized (i.e., filled with boxes),
 later insertion of boxes will cause an error, because the
 'n' field is 0.
 (4) Example usage.  This function is useful to prepare for a
 random insertion (or replacement) of pix into a pixa.
 To randomly insert pix into a pixa, without boxes, up to
 some index "max"
 Pixa pixa = pixaCreate(max);
 pixaInitFull(pixa, NULL, NULL);
 An existing pixa with a smaller ptr array can also be reused
 pixaExtendArrayToSize(pixa, max);
 pixaInitFull(pixa, NULL, NULL);
 The initialization allows the pixa to always be properly
 filled, even if all pix (and boxes) are not later replaced.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">typically empty</param>
	<param name="pix">to be replicated into the entire pixa ptr array</param>
	<param name="box">to be replicated into the entire boxa ptr array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaClear(System.IntPtr)">
	<summary>
 Notes
 (1) This destroys all pix in the pixa, as well as
 all boxes in the boxa.  The ptrs in the pix ptr array
 are all null'd.  The number of allocated pix, n, is set to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaJoin(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This appends a clone of each indicated pix in pixas to pixad
 (2) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (3) iend LT 0 means 'read to the end'
 (4) If pixas is NULL or contains no pix, this is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="pixad">dest pixa; add to this one</param>
	<param name="pixas">source pixa; add from this one</param>
	<param name="istart">starting index in pixas</param>
	<param name="iend">ending index in pixas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaInterleave(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) %copyflag determines if the pix are copied or cloned.
 The boxes, if they exist, are copied.
 (2) If the two pixa have different sizes, a warning is issued,
 and the number of pairs returned is the minimum size.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa1">first src pixa</param>
	<param name="pixa2">second src pixa</param>
	<param name="copyflag">L_CLONE, L_COPY</param>
	<returns>pixa  interleaved from sources, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaJoin(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This appends a clone of each indicated pixa in paas to pixaad
 (2) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (3) iend LT 0 means 'read to the end'
 </summary>
	<remarks>
	</remarks>
	<param name="paad">dest pixaa; add to this one</param>
	<param name="paas">source pixaa; add from this one</param>
	<param name="istart">starting index in pixaas</param>
	<param name="iend">ending index in pixaas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaCreate(System.Int32)">
	<summary>
 Notes
 (1) A pixaa provides a 2-level hierarchy of images.
 A common use is for segmentation masks, which are
 inexpensive to store in png format.
 (2) For example, suppose you want a mask for each textline
 in a two-column page.  The textline masks for each column
 can be represented by a pixa, of which there are 2 in the pixaa.
 The boxes for the textline mask components within a column
 can have their origin referred to the column rather than the page.
 Then the boxa field can be used to represent the two box (regions)
 for the columns, and the (x,y) components of each box can
 be used to get the absolute position of the textlines on
 the page.
 </summary>
	<remarks>
	</remarks>
	<param name="n">initial number of pixa ptrs</param>
	<returns>paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaCreateFromPixa(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This subdivides a pixa into a set of smaller pixa that
 are accumulated into a pixaa.
 (2) If type == L_CHOOSE_CONSECUTIVE, the first 'n' pix are
 put in a pixa and added to pixaa, then the next 'n', etc.
 If type == L_CHOOSE_SKIP_BY, the first pixa is made by
 aggregating pix[0], pix[n], pix[2n], etc.
 (3) The copyflag specifies if each new pix is a copy or a clone.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="n">number specifying subdivision of pixa</param>
	<param name="type">L_CHOOSE_CONSECUTIVE, L_CHOOSE_SKIP_BY</param>
	<param name="copyflag">L_CLONE, L_COPY</param>
	<returns>paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ppaa">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.pixaaAddPixa(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="pixa">to be added</param>
	<param name="copyflag">L_INSERT inserts the pixa directly; L_COPY makes a new pixa and copies each pix and each box; L_CLONE gives a new handle to the input pixa; L_COPY_CLONE makes a new pixa and inserts clones of all pix and boxes</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaExtendArray(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaAddPix(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="paa">input paa</param>
	<param name="index">index of pixa in paa</param>
	<param name="pix">to be added</param>
	<param name="box">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaAddBox(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The box can be used, for example, to hold the support region
 of a pixa that is being added to the pixaa.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="box"></param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaGetCount(System.IntPtr,System.IntPtr@)">
	<summary>
 Notes
 (1) If paa is empty, a returned na will also be empty.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="pna">number of pix in each pixa</param>
	<returns>count, or 0 if no pixaa</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaGetPixa(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) L_COPY makes a new pixa with a copy of every pix
 (2) L_CLONE just makes a new reference to the pixa,
 and bumps the counter.  You would use this, for example,
 when you need to extract some data from a pix within a
 pixa within a pixaa.
 (3) L_COPY_CLONE makes a new pixa with a clone of every pix
 and box
 (4) In all cases, you must invoke pixaDestroy() on the returned pixa
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="index">to the index-th pixa</param>
	<param name="accesstype">L_COPY, L_CLONE, L_COPY_CLONE</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaGetBoxa(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) L_COPY returns a copy; L_CLONE returns a new reference to the boxa.
 (2) In both cases, invoke boxaDestroy() on the returned boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="accesstype">L_COPY, L_CLONE</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaGetPix(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="index">index into the pixa array in the pixaa</param>
	<param name="ipix">index into the pix array in the pixa</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaVerifyDepth(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) It is considered to be an error if any pixa have no pix.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="psame">1 if all pix have the same depth; 0 otherwise</param>
	<param name="pmaxd">max depth of all pix in pixaa</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaVerifyDimensions(System.IntPtr,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) It is considered to be an error if any pixa have no pix.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="psame">1 if all pix have the same depth; 0 otherwise</param>
	<param name="pmaxw">max width of all pix in pixaa</param>
	<param name="pmaxh">max height of all pix in pixaa</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaIsFull(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) Does not require boxa associated with each pixa to be full.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="pfull">1 if all pixa in the paa have full pix arrays</param>
	<returns>return 0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaInitFull(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This initializes a pixaa by filling up the entire pixa ptr array
 with copies of %pixa.  Any existing pixa are destroyed.
 (2) Example usage.  This function is useful to prepare for a
 random insertion (or replacement) of pixa into a pixaa.
 To randomly insert pixa into a pixaa, up to some index "max"
 Pixaa paa = pixaaCreate(max);
 Pixa pixa = pixaCreate(1);  // if you want little memory
 pixaaInitFull(paa, pixa);  // copy it to entire array
 pixaDestroy(pixa);  // no longer needed
 The initialization allows the pixaa to always be properly filled.
 </summary>
	<remarks>
	</remarks>
	<param name="paa">typically empty</param>
	<param name="pixa">to be replicated into the entire pixa ptr array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaReplacePixa(System.IntPtr,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) This allows random insertion of a pixa into a pixaa, with
 destruction of any existing pixa at that location.
 The input pixa is now owned by the pixaa.
 (2) No other pixa in the array are affected.
 (3) The index must be within the allowed set.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="index">to the index-th pixa</param>
	<param name="pixa">insert to replace existing one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaClear(System.IntPtr)">
	<summary>
 Notes
 (1) This destroys all pixa in the pixaa, and nulls the ptrs
 in the pixa ptr array.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaTruncate(System.IntPtr)">
	<summary>
 Notes
 (1) This identifies the largest index containing a pixa that
 has any pix within it, destroys all pixa above that index,
 and resets the count.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaRead(System.String)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaReadStream(System.IntPtr)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">of serialized pixa</param>
	<param name="size">of data in bytes</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaWriteDebug(System.String,System.IntPtr)">
	<summary>
 Notes
 (1) Debug version, intended for use in the library when writing
 to files in a temp directory with names that are compiled in.
 This is used instead of pixaWrite() for all such library calls.
 (2) The global variable LeptDebugOK defaults to 0, and can be set
 or cleared by the function setLeptDebugOK().
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="pixa"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaWrite(System.String,System.IntPtr)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pixa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="pixa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a pixa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized pixa</param>
	<param name="psize">size of returned data</param>
	<param name="pixa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaReadBoth(System.String)">
	<summary>
 Notes
 (1) This reads serialized files of either a pixa or a pixacomp,
 and returns a pixa in memory.  It requires png and jpeg libraries.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaReadFromFiles(System.String,System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The files must be serialized pixa files (e.g., .pa)
 If some files cannot be read, warnings are issued.
 (2) Use %substr to filter filenames in the directory.  If
 %substr == NULL, this takes all files.
 (3) After filtering, use %first and %nfiles to select
 a contiguous set of files, that have been lexically
 sorted in increasing order.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="first">0-based</param>
	<param name="nfiles">use 0 for everything from %first to the end</param>
	<returns>paa, or NULL on error or if no pixa files are found.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaRead(System.String)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaReadStream(System.IntPtr)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">of serialized pixaa</param>
	<param name="size">of data in bytes</param>
	<returns>paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaWrite(System.String,System.IntPtr)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="paa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="paa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a pixaa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized pixaa</param>
	<param name="psize">size of returned data</param>
	<param name="paa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaccCreate(System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Use %negflag = 1 for safety if any negative numbers are going
 to be used in the chain of operations.  Negative numbers
 arise, e.g., by subtracting a pix, or by adding a pix
 that has been pre-multiplied by a negative number.
 (2) Initializes the internal 32 bpp pix, similarly to the
 initialization in pixInitAccumulate().
 </summary>
	<remarks>
	</remarks>
	<param name="w">of 32 bpp internal Pix</param>
	<param name="h">of 32 bpp internal Pix</param>
	<param name="negflag">0 if only positive numbers are involved; 1 if there will be negative numbers</param>
	<returns>pixacc, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaccCreateFromPix(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) See pixaccCreate()
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="negflag">0 if only positive numbers are involved; 1 if there will be negative numbers</param>
	<returns>pixacc, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaccDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppixacc">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.pixaccFinal(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<param name="outdepth">8, 16 or 32 bpp</param>
	<returns>pixd 8 , 16 or 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaccGetPix(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaccGetOffset(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<returns>offset, or -1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaccAdd(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<param name="pix">to be added</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaccSubtract(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<param name="pix">to be subtracted</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaccMultConst(System.IntPtr,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<param name="factor"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaccMultConstAccumulate(System.IntPtr,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) This creates a temp pix that is %pix multiplied by the
 constant %factor.  It then adds that into %pixacc.
 </summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<param name="pix"></param>
	<param name="factor"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSelectBySize(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) If unchanged, returns a copy of pixs.  Otherwise,
 returns a new pix with the filtered components.
 (3) If the selection type is L_SELECT_WIDTH, the input
 height is ignored, and v.v.
 (4) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="width">threshold dimensions</param>
	<param name="height">threshold dimensions</param>
	<param name="connectivity">4 or 8</param>
	<param name="type">L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 otherwise</param>
	<returns>filtered pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSelectBySize(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) Uses pix and box clones in the new pixa.
 (3) If the selection type is L_SELECT_WIDTH, the input
 height is ignored, and v.v.
 (4) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="width">threshold dimensions</param>
	<param name="height">threshold dimensions</param>
	<param name="type">L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 otherwise</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaMakeSizeIndicator(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) If the selection type is L_SELECT_WIDTH, the input
 height is ignored, and v.v.
 (3) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="width">threshold dimensions</param>
	<param name="height">threshold dimensions</param>
	<param name="type">L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns>na indicator array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSelectByPerimToAreaRatio(System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) If unchanged, returns a copy of pixs.  Otherwise,
 returns a new pix with the filtered components.
 (3) This filters "thick" components, where a thick component
 is defined to have a ratio of boundary to interior pixels
 that is smaller than a given threshold value.
 (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the thicker
 components, and L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="thresh">threshold ratio of fg boundary to fg pixels</param>
	<param name="connectivity">4 or 8</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSelectByPerimToAreaRatio(System.IntPtr,System.Single,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa clone if no components are removed.
 (2) Uses pix and box clones in the new pixa.
 (3) See pixSelectByPerimToAreaRatio().
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="thresh">threshold ratio of fg boundary to fg pixels</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSelectByPerimSizeRatio(System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) If unchanged, returns a copy of pixs.  Otherwise,
 returns a new pix with the filtered components.
 (3) This filters components with smooth vs. dendritic shape, using
 the ratio of the fg boundary pixels to the circumference of
 the bounding box, and comparing it to a threshold value.
 (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the smooth
 boundary components, and L_SELECT_IF_GT or L_SELECT_IF_GTE
 to remove them.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="thresh">threshold ratio of fg boundary to fg pixels</param>
	<param name="connectivity">4 or 8</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSelectByPerimSizeRatio(System.IntPtr,System.Single,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa clone if no components are removed.
 (2) Uses pix and box clones in the new pixa.
 (3) See pixSelectByPerimSizeRatio().
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="thresh">threshold ratio of fg boundary to b.b. circumference</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSelectByAreaFraction(System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the amount of foreground
 coverage of the components that are kept.
 (2) If unchanged, returns a copy of pixs.  Otherwise,
 returns a new pix with the filtered components.
 (3) This filters components based on the fraction of fg pixels
 of the component in its bounding box.
 (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
 with less than the threshold fraction of foreground, and
 L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="thresh">threshold ratio of fg pixels to (w  h)</param>
	<param name="connectivity">4 or 8</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSelectByAreaFraction(System.IntPtr,System.Single,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa clone if no components are removed.
 (2) Uses pix and box clones in the new pixa.
 (3) This filters components based on the fraction of fg pixels
 of the component in its bounding box.
 (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
 with less than the threshold fraction of foreground, and
 L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="thresh">threshold ratio of fg pixels to (w  h)</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSelectByWidthHeightRatio(System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the width-to-height ratio
 for components that are kept.
 (2) If unchanged, returns a copy of pixs.  Otherwise,
 returns a new pix with the filtered components.
 (3) This filters components based on the width-to-height ratios.
 (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
 with less than the threshold ratio, and
 L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="thresh">threshold ratio of width/height</param>
	<param name="connectivity">4 or 8</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSelectByWidthHeightRatio(System.IntPtr,System.Single,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa clone if no components are removed.
 (2) Uses pix and box clones in the new pixa.
 (3) This filters components based on the width-to-height ratio
 of each pix.
 (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
 with less than the threshold ratio, and
 L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="thresh">threshold ratio of width/height</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSelectByNumConnComp(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa clone if no components are removed.
 (2) Uses pix and box clones in the new pixa.
 (3) This filters by the number of connected components in
 a given range.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="nmin">minimum number of components</param>
	<param name="nmax">maximum number of components</param>
	<param name="connectivity">4 or 8</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSelectWithIndicator(System.IntPtr,System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa clone if no components are removed.
 (2) Uses pix and box clones in the new pixa.
 (3) The indicator numa has values 0 (ignore) and 1 (accept).
 (4) If the source boxa is not fully populated, it is left
 empty in the dest pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="na">indicator numa</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRemoveWithIndicator(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This complements pixAddWithIndicator().   Here, the selected
 components are set subtracted from pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp pix from which components are removed; in-place</param>
	<param name="pixa">of connected components in pixs</param>
	<param name="na">numa indicator remove components corresponding to 1s</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddWithIndicator(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This complements pixRemoveWithIndicator().   Here, the selected
 components are added to pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp pix from which components are added; in-place</param>
	<param name="pixa">of connected components, some of which will be put into pixs</param>
	<param name="na">numa indicator add components corresponding to 1s</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSelectWithString(System.IntPtr,System.String,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa with copies of selected pix.
 (2) Associated boxes are also copied, if fully populated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="str">string of indices into pixa, giving the pix to be selected</param>
	<param name="perror">1 if any indices are invalid; 0 if all indices are valid</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaRenderComponent(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If pixs is null, this generates an empty pix of a size determined
 by union of the component bounding boxes, and including the origin.
 (2) The selected component is blitted into pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp pix</param>
	<param name="pixa">of 1 bpp connected components, one of which will be rendered in pixs, with its origin determined by the associated box.</param>
	<param name="index">of component to be rendered</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSort(System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This sorts based on the data in the boxa.  If the boxa
 count is not the same as the pixa count, this returns an error.
 (2) If the boxa is empty, it makes one corresponding to the
 dimensions of each pix, which allows meaningful sorting on
 all types except x and y.
 (3) The copyflag refers to the pix and box copies that are
 inserted into the sorted pixa.  These are either L_COPY
 or L_CLONE.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER, L_SORT_BY_AREA, L_SORT_BY_ASPECT_RATIO</param>
	<param name="sortorder">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<param name="pnaindex">index of sorted order into original array</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>pixad sorted version of pixas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaBinSort(System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This sorts based on the data in the boxa.  If the boxa
 count is not the same as the pixa count, this returns an error.
 (2) The copyflag refers to the pix and box copies that are
 inserted into the sorted pixa.  These are either L_COPY
 or L_CLONE.
 (3) For a large number of boxes (say, greater than 1000), this
 O(n) binsort is much faster than the O(nlogn) shellsort.
 For 5000 components, this is over 20x faster than boxaSort().
 (4) Consequently, pixaSort() calls this function if it will
 likely go much faster.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_PERIMETER</param>
	<param name="sortorder">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<param name="pnaindex">index of sorted order into original array</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>pixad sorted version of pixas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSortByIndex(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="naindex">na that maps from the new pixa to the input pixa</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>pixad sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSort2dByIndex(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="naa">numaa that maps from the new pixaa to the input pixas</param>
	<param name="copyflag">L_CLONE or L_COPY</param>
	<returns>paa sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSelectRange(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The copyflag specifies what we do with each pix from pixas.
 Specifically, L_CLONE inserts a clone into pixad of each
 selected pix from pixas.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="first">use 0 to select from the beginning</param>
	<param name="last">use 0 to select to the end</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaSelectRange(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The copyflag specifies what we do with each pixa from paas.
 Specifically, L_CLONE inserts a clone into paad of each
 selected pixa from paas.
 </summary>
	<remarks>
	</remarks>
	<param name="paas"></param>
	<param name="first">use 0 to select from the beginning</param>
	<param name="last">use 0 to select to the end</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>paad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaScaleToSize(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This guarantees that each output scaled image has the
 dimension(s) you specify.
 ~ To specify the width with isotropic scaling, set %hd = 0.
 ~ To specify the height with isotropic scaling, set %wd = 0.
 ~ If both %wd and %hd are specified, the image is scaled
 (in general, anisotropically) to that size.
 ~ It is an error to set both %wd and %hd to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="paas"></param>
	<param name="wd">target width; use 0 if using height as target</param>
	<param name="hd">target height; use 0 if using width as target</param>
	<returns>paad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaScaleToSizeVar(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This guarantees that the scaled images in each pixa have the
 dimension(s) you specify in the numas.
 ~ To specify the width with isotropic scaling, set %nahd = NULL.
 ~ To specify the height with isotropic scaling, set %nawd = NULL.
 ~ If both %nawd and %nahd are specified, the image is scaled
 (in general, anisotropically) to that size.
 ~ It is an error to set both %nawd and %nahd to NULL.
 (2) If either nawd and/or nahd is defined, it must have the same
 count as the number of pixa in paas.
 </summary>
	<remarks>
	</remarks>
	<param name="paas"></param>
	<param name="nawd">target widths; use NULL if using height</param>
	<param name="nahd">target height; use NULL if using width</param>
	<returns>paad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaScaleToSize(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixaaScaleToSize()
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="wd">target width; use 0 if using height as target</param>
	<param name="hd">target height; use 0 if using width as target</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaScaleToSizeRel(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If a requested change in a pix is not possible because
 either the requested width or height is LT= 0, issue a
 warning and return a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="delw">change in width, in pixels; 0 means no change</param>
	<param name="delh">change in height, in pixels; 0 means no change return  pixad, or NULL on error</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixaScale(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) If pixas has a full boxes, it is scaled as well.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaScaleBySampling(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) If pixas has a full boxes, it is scaled as well.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaRotate(System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Each pix is rotated about its center.  See pixRotate() for details.
 (2) The boxa array is copied.  Why is it not rotated?
 If a boxa exists, the array of boxes is in 1-to-1
 correspondence with the array of pix, and each box typically
 represents the location of the pix relative to an image from
 which it has been extracted.  Like the pix, we could rotate
 each box around its center, and then generate a box that
 contains all four corners, as is done in boxaRotate(), but
 this seems unnecessary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">1, 2, 4, 8, 32 bpp rgb</param>
	<param name="angle">rotation angle in radians; clockwise is positive</param>
	<param name="type">L_ROTATE_AREA_MAP, L_ROTATE_SHEAR, L_ROTATE_SAMPLING</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<param name="width">original width; use 0 to avoid embedding</param>
	<param name="height">original height; use 0 to avoid embedding</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaRotateOrth(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Rotates each pix in the pixa.  Rotates and saves the boxes in
 the boxa if the boxa is full.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="rotation">0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg; all rotations are clockwise</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaTranslate(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="hshift">horizontal shift; hshift GT 0 is to right</param>
	<param name="vshift">vertical shift; vshift GT 0 is down</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixad, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaAddBorderGeneral(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) For binary images
 white  val = 0
 black  val = 1
 For grayscale images
 white  val = 2  d - 1
 black  val = 0
 For rgb color images
 white  val = 0xffffff00
 black  val = 0
 For colormapped images, use 'index' found this way
 white pixcmapGetRankIntensity(cmap, 1.0, index);
 black pixcmapGetRankIntensity(cmap, 0.0, index);
 (2) For in-place replacement of each pix with a bordered version,
 use %pixad = %pixas.  To make a new pixa, use %pixad = NULL.
 (3) In both cases, the boxa has sides adjusted as if it were
 expanded by the border.
 </summary>
	<remarks>
	</remarks>
	<param name="pixad">or equal to pixas</param>
	<param name="pixas">containing pix of all depths; colormap ok</param>
	<param name="left">number of pixels added</param>
	<param name="right">number of pixels added</param>
	<param name="top">number of pixels added</param>
	<param name="bot">number of pixels added</param>
	<param name="val">value of added border pixels</param>
	<returns>pixad with border added to each pix, including on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaFlattenToPixa(System.IntPtr,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This 'flattens' the pixaa to a pixa, taking the pix in
 order in the first pixa, then the second, etc.
 (2) If naindex is defined, we generate a Numa that gives, for
 each pix in the pixaa, the index of the pixa to which it belongs.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="pnaindex">the pixa index in the pixaa</param>
	<param name="copyflag">L_COPY or L_CLONE</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaSizeRange(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="pminw">range of dimensions of all boxes</param>
	<param name="pminh">range of dimensions of all boxes</param>
	<param name="pmaxw">range of dimensions of all boxes</param>
	<param name="pmaxh">range of dimensions of all boxes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSizeRange(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pminw">range of dimensions of pix in the array</param>
	<param name="pminh">range of dimensions of pix in the array</param>
	<param name="pmaxw">range of dimensions of pix in the array</param>
	<param name="pmaxh">range of dimensions of pix in the array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaClipToPix(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This is intended for use in situations where pixas
 was originally generated from the input pixs.
 (2) Returns a pixad where each pix in pixas is ANDed
 with its associated region of the input pixs.  This
 region is specified by the the box that is associated
 with the pix.
 (3) In a typical application of this function, pixas has
 a set of region masks, so this generates a pixa of
 the parts of pixs that correspond to each region
 mask component, along with the bounding box for
 the region.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="pixs"></param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaClipToForeground(System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) At least one of [pixd, boxa] must be specified.
 (2) Any pix with no fg pixels is skipped.
 (3) See pixClipToForeground().
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="ppixad">pixa of clipped pix returned</param>
	<param name="pboxa">clipping boxes returned</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaGetRenderingDepth(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pdepth">depth required to render if all colormaps are removed</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaHasColor(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="phascolor">1 if any pix is rgb or has a colormap with color; 0 otherwise</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaAnyColormaps(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="phascmap">1 if any pix has a colormap; 0 otherwise</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaGetDepthInfo(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pmaxdepth">max pixel depth of pix in pixa</param>
	<param name="psame">true if all depths are equal</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaConvertToSameDepth(System.IntPtr)">
	<summary>
 Notes
 (1) If any pix has a colormap, they are all converted to rgb.
 Otherwise, they are all converted to the maximum depth of
 all the pix.
 (2) This can be used to allow lossless rendering onto a single pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaEqual(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr@,System.Int32@)">
	<summary>
 Notes
 (1) The two pixa are the "same" if they contain the same
 boxa and the same ordered set of pix.  However, if they
 have boxa, the pix in each pixa can differ in ordering
 by an amount given by the parameter %maxdist.  If they
 don't have a boxa, the %maxdist parameter is ignored,
 and the ordering must be identical.
 (2) This applies only to boxa geometry, pixels and ordering;
 other fields in the pix are ignored.
 (3) naindex[i] gives the position of the box in pixa2 that
 corresponds to box i in pixa1.  It is only returned if the
 pixa have boxa and the boxa are equal.
 (4) In situations where the ordering is very different, so that
 a large %maxdist is required for "equality", this should be
 implemented with a hash function for efficiency.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa1"></param>
	<param name="pixa2"></param>
	<param name="maxdist"></param>
	<param name="pnaindex">index array of correspondences</param>
	<param name="psame">1 if equal; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSetFullSizeBoxa(System.IntPtr)">
	<summary>
 Notes
 (1) Replaces the existing boxa.  Each box gives the dimensions
 of the corresponding pix.  This is needed for functions
 like pixaSort() that sort based on the boxes.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplay(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This uses the boxes to place each pix in the rendered composite.
 (2) Set w = h = 0 to use the b.b. of the components to determine
 the size of the returned pix.
 (3) Uses the first pix in pixa to determine the depth.
 (4) The background is written "white".  On 1 bpp, each successive
 pix is "painted" (adding foreground), whereas for grayscale
 or color each successive pix is blitted with just the src.
 (5) If the pixa is empty, returns an empty 1 bpp pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="w">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<param name="h">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplayOnColor(System.IntPtr,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) This uses the boxes to place each pix in the rendered composite.
 (2) Set w = h = 0 to use the b.b. of the components to determine
 the size of the returned pix.
 (3) If any pix in %pixa are colormapped, or if the pix have
 different depths, it returns a 32 bpp pix.  Otherwise,
 the depth of the returned pixa equals that of the pix in %pixa.
 (4) If the pixa is empty, return null.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="w">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<param name="h">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<param name="bgcolor">background color to use</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplayRandomCmap(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This uses the boxes to place each pix in the rendered composite.
 The fg of each pix in %pixa, such as a single connected
 component or a line of text, is given a random color.
 (2) By default, the background color is black (cmap index 0).
 This can be changed by pixcmapResetColor()
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">1 bpp regions, with boxa delineating those regions</param>
	<param name="w">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<param name="h">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<returns>pix   8 bpp, cmapped, with random colors assigned to each region, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplayLinearly(System.IntPtr,System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) This puts each pix, sequentially, in a line, either horizontally
 or vertically.
 (2) If any pix has a colormap, all pix are rendered in rgb.
 (3) The boxa gives the location of each image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="direction">L_HORIZ or L_VERT</param>
	<param name="scalefactor">applied to every pix; use 1.0 for no scaling</param>
	<param name="background">0 for white, 1 for black; this is the color of the spacing between the images</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of black border added to each image; use 0 for no border</param>
	<param name="pboxa">location of images in output pix</param>
	<returns>pix of composite images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplayOnLattice(System.IntPtr,System.Int32,System.Int32,System.Int32@,System.IntPtr@)">
	<summary>
 Notes
 (1) This places each pix on sequentially on a regular lattice
 in the rendered composite.  If a pix is too large to fit in the
 allocated lattice space, it is not rendered.
 (2) If any pix has a colormap, all pix are rendered in rgb.
 (3) This is useful when putting bitmaps of components,
 such as characters, into a single image.
 (4) The boxa gives the location of each image.  The UL corner
 of each image is on a lattice cell corner.  Omitted images
 (due to size) are assigned an invalid width and height of 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="cellw">lattice cell width</param>
	<param name="cellh">lattice cell height</param>
	<param name="pncols">number of columns in output lattice</param>
	<param name="pboxa">location of images in lattice</param>
	<returns>pix of composite images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplayUnsplit(System.IntPtr,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) This is a logical inverse of pixaSplitPix().  It
 constructs a pix from a mosaic of tiles, all of equal size.
 (2) For added generality, a border of arbitrary color can
 be added to each of the tiles.
 (3) In use, pixa will typically have either been generated
 from pixaSplitPix() or will derived from a pixa that
 was so generated.
 (4) All pix in the pixa must be of equal depth, and, if
 colormapped, have the same colormap.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="nx">number of mosaic cells horizontally</param>
	<param name="ny">number of mosaic cells vertically</param>
	<param name="borderwidth">of added border on all sides</param>
	<param name="bordercolor">in our RGBA format 0xrrggbbaa</param>
	<returns>pix of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplayTiled(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This renders a pixa to a single image of width not to
 exceed maxwidth, with background color either white or black,
 and with each subimage spaced on a regular lattice.
 (2) The lattice size is determined from the largest width and height,
 separately, of all pix in the pixa.
 (3) All pix in the pixa must be of equal depth.
 (4) If any pix has a colormap, all pix are rendered in rgb.
 (5) Careful because no components are omitted, this is
 dangerous if there are thousands of small components and
 one or more very large one, because the size of the
 resulting pix can be huge!
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="maxwidth">of output image</param>
	<param name="background">0 for white, 1 for black</param>
	<param name="spacing"></param>
	<returns>pix of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplayTiledInRows(System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This renders a pixa to a single image of width not to
 exceed maxwidth, with background color either white or black,
 and with each row tiled such that the top of each pix is
 aligned and separated by 'spacing' from the next one.
 A black border can be added to each pix.
 (2) All pix are converted to outdepth; existing colormaps are removed.
 (3) This does a reasonably spacewise-efficient job of laying
 out the individual pix images into a tiled composite.
 (4) A serialized boxa giving the location in pixd of each input
 pix (without added border) is stored in the text string of pixd.
 This allows, e.g., regeneration of a pixa from pixd, using
 pixaCreateFromBoxa().  If there is no scaling and the depth of
 each input pix in the pixa is the same, this tiling operation
 can be inverted using the boxa (except for loss of text in
 each of the input pix)
 pix1 = pixaDisplayTiledInRows(pixa1, 1, 1500, 1.0, 0, 30, 0);
 char boxatxt = pixGetText(pix1);
 boxa1 = boxaReadMem((l_uint8 )boxatxt, strlen(boxatxt));
 pixa2 = pixaCreateFromBoxa(pix1, boxa1, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="outdepth">output depth 1, 8 or 32 bpp</param>
	<param name="maxwidth">of output image</param>
	<param name="scalefactor">applied to every pix; use 1.0 for no scaling</param>
	<param name="background">0 for white, 1 for black; this is the color of the spacing between the images</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of black border added to each image; use 0 for no border</param>
	<returns>pixd of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplayTiledInColumns(System.IntPtr,System.Int32,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This renders a pixa to a single image with nx columns of
 subimages.  The background color is white, and each row
 is tiled such that the top of each pix is aligned and
 each pix is separated by 'spacing' from the next one.
 A black border can be added to each pix.
 (2) The output depth is determined by the largest depth
 required by the pix in the pixa.  Colormaps are removed.
 (3) A serialized boxa giving the location in pixd of each input
 pix (without added border) is stored in the text string of pixd.
 This allows, e.g., regeneration of a pixa from pixd, using
 pixaCreateFromBoxa().  If there is no scaling and the depth of
 each input pix in the pixa is the same, this tiling operation
 can be inverted using the boxa (except for loss of text in
 each of the input pix)
 pix1 = pixaDisplayTiledInColumns(pixa1, 3, 1.0, 0, 30, 2);
 char boxatxt = pixGetText(pix1);
 boxa1 = boxaReadMem((l_uint8 )boxatxt, strlen(boxatxt));
 pixa2 = pixaCreateFromBoxa(pix1, boxa1, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="nx">number of columns in output image</param>
	<param name="scalefactor">applied to every pix; use 1.0 for no scaling</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of black border added to each image; use 0 for no border</param>
	<returns>pixd of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplayTiledAndScaled(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This can be used to tile a number of renderings of
 an image that are at different scales and depths.
 (2) Each image, after scaling and optionally adding the
 black border, has width 'tilewidth'.  Thus, the border does
 not affect the spacing between the image tiles.  The
 maximum allowed border width is tilewidth / 5.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="outdepth">output depth 1, 8 or 32 bpp</param>
	<param name="tilewidth">each pix is scaled to this width</param>
	<param name="ncols">number of tiles in each row</param>
	<param name="background">0 for white, 1 for black; this is the color of the spacing between the images</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<returns>pix of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplayTiledWithText(System.IntPtr,System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) This is a version of pixaDisplayTiledInRows() that prints, below
 each pix, the text in the pix text field.  Up to 127 chars
 of text in the pix text field are rendered below each pix.
 (2) It renders a pixa to a single image of width not to
 exceed %maxwidth, with white background color, with each row
 tiled such that the top of each pix is aligned and separated
 by %spacing from the next one.
 (3) All pix are converted to 32 bpp.
 (4) This does a reasonably spacewise-efficient job of laying
 out the individual pix images into a tiled composite.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="maxwidth">of output image</param>
	<param name="scalefactor">applied to every pix; use 1.0 for no scaling</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of black border added to each image; use 0 for no border</param>
	<param name="fontsize">4, 6, ... 20</param>
	<param name="textcolor">0xrrggbb00</param>
	<returns>pixd of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplayTiledByIndex(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) This renders a pixa to a single image with white
 background color, where the pix are placed in columns
 given by the index value in the numa.  Each pix
 is separated by %spacing from the adjacent ones, and
 an optional border is placed around them.
 (2) Up to 127 chars of text in the pix text field are rendered
 below each pix.  Use newlines in the text field to write
 the text in multiple lines that fit within the pix width.
 (3) To avoid having empty columns, if there are N different
 index values, they should be in [0 ... N-1].
 (4) All pix are converted to 32 bpp.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="na">numa with indices corresponding to the pix in pixa</param>
	<param name="width">each pix is scaled to this width</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of black border added to each image; use 0 for no border</param>
	<param name="fontsize">4, 6, ... 20</param>
	<param name="textcolor">0xrrggbb00</param>
	<returns>pixd of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaDisplay(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Each pix of the paa is displayed at the location given by
 its box, translated by the box of the containing pixa
 if it exists.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="w">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<param name="h">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaDisplayByPixa(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Displays each pixa on a line (or set of lines),
 in order from top to bottom.  Within each pixa,
 the pix are displayed in order from left to right.
 (2) The sizes and depths of each pix can differ.  The output pix
 has a depth equal to the max depth of all the pix.
 (3) This ignores the boxa of the paa.
 </summary>
	<remarks>
	</remarks>
	<param name="paa">with pix that may have different depths</param>
	<param name="xspace">between pix in pixa</param>
	<param name="yspace">between pixa</param>
	<param name="maxw">max width of output pix</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaaDisplayTiledAndScaled(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For each pixa, this generates from all the pix a
 tiled/scaled output pix, and puts it in the output pixa.
 (2) See comments in pixaDisplayTiledAndScaled().
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="outdepth">output depth 1, 8 or 32 bpp</param>
	<param name="tilewidth">each pix is scaled to this width</param>
	<param name="ncols">number of tiles in each row</param>
	<param name="background">0 for white, 1 for black; this is the color of the spacing between the images</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<returns>pixa of tiled images, one image for each pixa in the paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaConvertTo1(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="thresh">threshold for final binarization from 8 bpp gray</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaConvertTo8(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) See notes for pixConvertTo8(), applied to each pix in pixas.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="cmapflag">1 to give pixd a colormap; 0 otherwise</param>
	<returns>pixad each pix is 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaConvertTo8Colormap(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) See notes for pixConvertTo8Colormap(), applied to each pix in pixas.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="dither">1 to dither if necessary; 0 otherwise</param>
	<returns>pixad each pix is 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaConvertTo32(System.IntPtr)">
	<summary>
 Notes
 (1) See notes for pixConvertTo32(), applied to each pix in pixas.
 (2) This can be used to allow 1 bpp pix in a pixa to be displayed
 with color.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<returns>pixad 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaConstrainedSelect(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See notes in genConstrainedNumaInRange() for how selection
 is made.
 (2) This returns a selection of the pix in the input pixa.
 (3) Use copyflag == L_COPY if you don't want changes in the pix
 in the returned pixa to affect those in the input pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="first">first index to choose; GT= 0</param>
	<param name="last">biggest possible index to reach; use -1 to go to the end; otherwise, last GT= first</param>
	<param name="nmax">maximum number of pix to select; GT 0</param>
	<param name="use_pairs">1 = select pairs of adjacent pix; 0 = select individual pix</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>pixad if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSelectToPdf(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,System.UInt32,System.Int32,System.String)">
	<summary>
 Notes
 (1) This writes a pdf of the selected images from %pixas, one to
 a page.  They are optionally scaled and annotated with the
 index printed to the left of the image.
 (2) If the input images are 1 bpp and you want the numbers to be
 in color, first promote each pix to 8 bpp with a colormap
 pixa1 = pixaConvertTo8(pixas, 1);
 and then call this function with the specified color
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="first">first index to choose; GT= 0</param>
	<param name="last">biggest possible index to reach; use -1 to go to the end; otherwise, last GT= first</param>
	<param name="res">override the resolution of each input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="color">of numbers added to each image (e.g., 0xff000000)</param>
	<param name="fontsize">to print number below each image.  The valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaDisplayMultiTiled(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Each set of %nx  %ny images is optionally scaled and saved
 into a new pix, and then aggregated.
 (2) Set %maxw = %maxh = 0 if you want to include all pix from %pixs.
 (3) This is useful for generating a pdf from the output pixa, where
 each page is a tile of (%nx  %ny) images from the input pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="nx">in [1, ... 50], tiling factors in each direction</param>
	<param name="ny">in [1, ... 50], tiling factors in each direction</param>
	<param name="maxw">max sizes to keep</param>
	<param name="maxh">max sizes to keep</param>
	<param name="scalefactor">scale each image by this</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<returns>pixad if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSplitIntoFiles(System.IntPtr,System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For each requested output, %nsplit files are written into
 directory /tmp/lept/split/.
 (2) This is useful when a pixa is so large that the images
 are not conveniently displayed as a single tiled image at
 full resolution.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="nsplit">split pixas into this number of pixa; GT= 2</param>
	<param name="scale">scalefactor applied to each pix</param>
	<param name="outwidth">the maxwidth parameter of tiled images for write_pix</param>
	<param name="write_pixa">1 to write the split pixa as separate files</param>
	<param name="write_pix">1 to write tiled images of the split pixa</param>
	<param name="write_pdf">1 to write pdfs of the split pixa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertToNUpFiles(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) Each set of %nx  %ny images is scaled and tiled into a single
 image, that is written out to %outdir.
 (2) All images in each %nx  %ny set are scaled to the same
 width, %tw.  This is typically used when all images are
 roughly the same size.
 (3) This is useful for generating a pdf from the set of input
 files, where each page is a tile of (%nx  %ny) input images.
 Typical values for %nx and %ny are in the range [2 ... 5].
 (4) If %fontsize != 0, each image has the tail of its filename
 rendered below it.
 </summary>
	<remarks>
	</remarks>
	<param name="dir">full path to directory of images</param>
	<param name="substr">can be null</param>
	<param name="nx">in [1, ... 50], tiling factors in each direction</param>
	<param name="ny">in [1, ... 50], tiling factors in each direction</param>
	<param name="tw">target width, in pixels; must be GT= 20</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<param name="fontsize">to print tail of filename with image.  Valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	<param name="outdir">subdirectory of /tmp to put N-up tiled images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertToNUpPixa(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See notes for convertToNUpFiles()
 </summary>
	<remarks>
	</remarks>
	<param name="dir">full path to directory of images</param>
	<param name="substr">can be null</param>
	<param name="nx">in [1, ... 50], tiling factors in each direction</param>
	<param name="ny">in [1, ... 50], tiling factors in each direction</param>
	<param name="tw">target width, in pixels; must be GT= 20</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<param name="fontsize">to print tail of filename with image.  Valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaConvertToNUpPixa(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This takes an input pixa and an optional array of strings, and
 generates a pixa of NUp tiles from the input, labeled with
 the strings if they exist and %fontsize != 0.
 (2) See notes for convertToNUpFiles()
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="sa">array of strings associated with each pix</param>
	<param name="nx">in [1, ... 50], tiling factors in each direction</param>
	<param name="ny">in [1, ... 50], tiling factors in each direction</param>
	<param name="tw">target width, in pixels; must be GT= 20</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<param name="fontsize">to print string with each image.  Valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaCompareInPdf(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) This takes two pixa and renders them interleaved, side-by-side
 in a pdf.  A warning is issued if the input pixa arrays
 have different lengths.
 (2) %nx and %ny specify how many side-by-side pairs are displayed
 on each pdf page.  For example, if %nx = 1 and %ny = 2, then
 two pairs are shown, one above the other, on each page.
 (3) The input pix are scaled to a target width of %tw, and
 then paired with optional %spacing between and optional
 black border of width %border.
 (4) After a pixa is generated of these tiled images, it is
 written to %fileout as a pdf.
 (5) Typical numbers for the input parameters are
 %nx = small integer (1 - 4)
 %ny = 2  %nx
 %tw = 200 - 500 pixels
 %spacing = 10
 %border = 2
 %fontsize = 10
 (6) If %fontsize != 0, the index of the pix pair in their pixa
 is printed out below each pair.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa1"></param>
	<param name="pixa2"></param>
	<param name="nx">in [1, ... 20], tiling factors in each direction</param>
	<param name="ny">in [1, ... 20], tiling factors in each direction</param>
	<param name="tw">target width, in pixels; must be GT= 20</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image and on each pair; use 0 for no border</param>
	<param name="fontsize">to print index of each pair of images.  Valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	<param name="fileout">output pdf file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pmsCreate(System.UInt32,System.UInt32,System.IntPtr,System.String)">
	<summary>
 Notes
 (1) This computes the size of the block of memory required
 and allocates it.  Each chunk starts on a 32-bit word boundary.
 The chunk sizes are in powers of 2, starting at %smallest,
 and the number of levels and chunks at each level is
 specified by %numalloc.
 (2) This is intended to manage the image data for a small number
 of relatively large pix.  The system malloc is expected to
 handle very large numbers of small chunks efficiently.
 (3) Important set the allocators and call this function
 before any pix have been allocated.  Destroy all the pix
 in the normal way before calling pmsDestroy().
 (4) The pms struct is stored in a static global, so this function
 is not thread-safe.  When used, there must be only one thread
 per process.
 </summary>
	<remarks>
	</remarks>
	<param name="minsize">of data chunk that can be supplied by pms</param>
	<param name="smallest">bytes of the smallest pre-allocated data chunk.</param>
	<param name="numalloc">array with the number of data chunks for each size that are in the memory store</param>
	<param name="logfile">use for debugging; null otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pmsDestroy">
	<summary>
 Notes
 (1) Important call this function at the end of the program, after
 the last pix has been destroyed.
 </summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.pmsCustomAlloc(System.UInt32)">
	<summary>
 Notes
 (1) This attempts to find a suitable pre-allocated chunk.
 If not found, it dynamically allocates the chunk.
 (2) If logging is turned on, the allocations that are not taken
 from the memory store, and are at least as large as the
 minimum size the store can handle, are logged to file.
 </summary>
	<remarks>
	</remarks>
	<param name="nbytes">min number of bytes in the chunk to be retrieved</param>
	<returns>data ptr to chunk</returns>
</member><member name="M:LeptonicaSharp.Natives.pmsCustomDealloc(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">to be freed or returned to the storage</param>
</member><member name="M:LeptonicaSharp.Natives.pmsGetAlloc(System.UInt32)">
	<summary>
 Notes
 (1) This is called when a request for pix data cannot be
 obtained from the preallocated memory store.  After use it
 is freed like normal memory.
 (2) If logging is on, only write out allocs that are as large as
 the minimum size handled by the memory store.
 (3) size_t is %lu on 64 bit platforms and %u on 32 bit platforms.
 The C99 platform-independent format specifier for size_t is %zu,
 but windows hasn't conformed, so we are forced to go back to
 C89, use %lu, and cast to get platform-independence.  Ugh.
 </summary>
	<remarks>
	</remarks>
	<param name="nbytes"></param>
	<returns>data</returns>
</member><member name="M:LeptonicaSharp.Natives.pmsGetLevelForAlloc(System.UInt32,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nbytes">min number of bytes in the chunk to be retrieved</param>
	<param name="plevel">-1 if either too small or too large</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pmsGetLevelForDealloc(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">ptr to memory chunk</param>
	<param name="plevel">level in memory store; -1 if allocated outside the store</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pmsLogInfo">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.pixAddConstantGray(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) In-place operation.
 (2) No clipping for 32 bpp.
 (3) For 8 and 16 bpp, if val GT 0 the result is clipped
 to 0xff and 0xffff, rsp.
 (4) For 8 and 16 bpp, if val LT 0 the result is clipped to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16 or 32 bpp</param>
	<param name="val">amount to add to each pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMultConstantGray(System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) In-place operation; val must be GT= 0.
 (2) No clipping for 32 bpp.
 (3) For 8 and 16 bpp, the result is clipped to 0xff and 0xffff, rsp.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16 or 32 bpp</param>
	<param name="val">GT= 0.0; amount to multiply by each pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddGray(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Arithmetic addition of two 8, 16 or 32 bpp images.
 (2) For 8 and 16 bpp, we do explicit clipping to 0xff and 0xffff,
 respectively.
 (3) Alignment is to UL corner.
 (4) There are 3 cases.  The result can go to a new dest,
 in-place to pixs1, or to an existing input dest
 pixd == null   (src1 + src2) --GT new pixd
 pixd == pixs1  (src1 + src2) --GT src1  (in-place)
 pixd != pixs1  (src1 + src2) --GT input pixd
 (5) pixs2 must be different from both pixd and pixs1.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs1, or different from pixs1</param>
	<param name="pixs1">can be == to pixd</param>
	<param name="pixs2"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSubtractGray(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Arithmetic subtraction of two 8, 16 or 32 bpp images.
 (2) Source pixs2 is always subtracted from source pixs1.
 (3) Do explicit clipping to 0.
 (4) Alignment is to UL corner.
 (5) There are 3 cases.  The result can go to a new dest,
 in-place to pixs1, or to an existing input dest
 (a) pixd == null   (src1 - src2) --GT new pixd
 (b) pixd == pixs1  (src1 - src2) --GT src1  (in-place)
 (d) pixd != pixs1  (src1 - src2) --GT input pixd
 (6) pixs2 must be different from both pixd and pixs1.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs1, or different from pixs1</param>
	<param name="pixs1">can be == to pixd</param>
	<param name="pixs2"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixThresholdToValue(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 ~ operation can be in-place (pixs == pixd) or to a new pixd
 ~ if setval GT threshval, sets pixels with a value GT= threshval to setval
 ~ if setval LT threshval, sets pixels with a value LT= threshval to setval
 ~ if setval == threshval, no-op
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; if not null, must be equal to pixs</param>
	<param name="pixs">8, 16, 32 bpp</param>
	<param name="threshval"></param>
	<param name="setval"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixInitAccumulate(System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) The offset must be GT= 0.
 (2) The offset is used so that we can do arithmetic
 with negative number results on l_uint32 data; it
 prevents the l_uint32 data from going negative.
 (3) Because we use l_int32 intermediate data results,
 these should never exceed the max of l_int32 (0x7fffffff).
 We do not permit the offset to be above 0x40000000,
 which is half way between 0 and the max of l_int32.
 (4) The same offset should be used for initialization,
 multiplication by a constant, and final extraction!
 (5) If you're only adding positive values, offset can be 0.
 </summary>
	<remarks>
	</remarks>
	<param name="w">of accumulate array</param>
	<param name="h">of accumulate array</param>
	<param name="offset">initialize the 32 bpp to have this value; not more than 0x40000000</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFinalAccumulate(System.IntPtr,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) The offset must be GT= 0 and should not exceed 0x40000000.
 (2) The offset is subtracted from the src 32 bpp image
 (3) For 8 bpp dest, the result is clipped to [0, 0xff]
 (4) For 16 bpp dest, the result is clipped to [0, 0xffff]
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="offset">same as used for initialization</param>
	<param name="depth">8, 16 or 32 bpp, of destination</param>
	<returns>pixd 8, 16 or 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFinalAccumulateThreshold(System.IntPtr,System.UInt32,System.UInt32)">
	<summary>
 Notes
 (1) The offset must be GT= 0 and should not exceed 0x40000000.
 (2) The offset is subtracted from the src 32 bpp image
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="offset">same as used for initialization</param>
	<param name="threshold">values less than this are set in the destination</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAccumulate(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This adds or subtracts each pixs value from pixd.
 (2) This clips to the minimum of pixs and pixd, so they
 do not need to be the same size.
 (3) The alignment is to the origin [UL corner] of pixs  pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp</param>
	<param name="pixs">1, 8, 16 or 32 bpp</param>
	<param name="op">L_ARITH_ADD or L_ARITH_SUBTRACT</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMultConstAccumulate(System.IntPtr,System.Single,System.UInt32)">
	<summary>
 Notes
 (1) The offset must be GT= 0 and should not exceed 0x40000000.
 (2) This multiplies each pixel, relative to offset, by the input factor
 (3) The result is returned with the offset back in place.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="factor"></param>
	<param name="offset">same as used for initialization</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAbsDifference(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) The depth of pixs1 and pixs2 must be equal.
 (2) Clips computation to the min size, aligning the UL corners
 (3) For 8 and 16 bpp, assumes one gray component.
 (4) For 32 bpp, assumes 3 color components, and ignores the
 LSB of each word (the alpha channel)
 (5) Computes the absolute value of the difference between
 each component value.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">both either 8 or 16 bpp gray, or 32 bpp RGB</param>
	<param name="pixs2">both either 8 or 16 bpp gray, or 32 bpp RGB</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddRGB(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Clips computation to the minimum size, aligning the UL corners.
 (2) Removes any colormap to RGB, and ignores the LSB of each
 pixel word (the alpha channel).
 (3) Adds each component value, pixelwise, clipping to 255.
 (4) This is useful to combine two images where most of the
 pixels are essentially black, such as in pixPerceptualDiff().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">32 bpp RGB, or colormapped</param>
	<param name="pixs2">32 bpp RGB, or colormapped</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMinOrMax(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This gives the min or max of two images, component-wise.
 (2) The depth can be 8 or 16 bpp for 1 component, and 32 bpp
 for a 3 component image.  For 32 bpp, ignore the LSB
 of each word (the alpha channel)
 (3) There are 3 cases
 ~  if pixd == null,   Min(src1, src2) --GT new pixd
 ~  if pixd == pixs1,  Min(src1, src2) --GT src1  (in-place)
 ~  if pixd != pixs1,  Min(src1, src2) --GT input pixd
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">destination this can be null, equal to pixs1, or different from pixs1</param>
	<param name="pixs1">can be == to pixd</param>
	<param name="pixs2"></param>
	<param name="type">L_CHOOSE_MIN, L_CHOOSE_MAX</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMaxDynamicRange(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Scales pixel values to fit maximally within the dest 8 bpp pixd
 (2) Assumes the source 'pixels' are a 1-component scalar.  For
 a 32 bpp source, each pixel is treated as a single number --
 not as a 3-component rgb pixel value.
 (3) Uses a LUT for log scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">4, 8, 16 or 32 bpp source</param>
	<param name="type">L_LINEAR_SCALE or L_LOG_SCALE</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMaxDynamicRangeRGB(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Scales pixel values to fit maximally within a 32 bpp dest pixd
 (2) All color components are scaled with the same factor, based
 on the maximum r,g or b component in the image.  This should
 not be used if the 32-bit value is a single number (e.g., a
 count in a histogram generated by pixMakeHistoHS()).
 (3) Uses a LUT for log scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb source</param>
	<param name="type">L_LINEAR_SCALE or L_LOG_SCALE</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.linearScaleRGBVal(System.UInt32,System.Single)">
	<summary>
 Notes
 (1) %factor must be chosen to be not greater than (255 / maxcomp),
 where maxcomp is the maximum value of the pixel components.
 Otherwise, the product will overflow a uint8.  In use, factor
 is the same for all pixels in a pix.
 (2) No scaling is performed on the transparency ("A") component.
 </summary>
	<remarks>
	</remarks>
	<param name="sval">32-bit rgb pixel value</param>
	<param name="factor">multiplication factor on each component</param>
	<returns>dval  linearly scaled version of %sval</returns>
</member><member name="M:LeptonicaSharp.Natives.logScaleRGBVal(System.UInt32,System.Single[],System.Single)">
	<summary>
 Notes
 (1) %tab is made with makeLogBase2Tab().
 (2) %factor must be chosen to be not greater than
 255.0 / log[base2](maxcomp), where maxcomp is the maximum
 value of the pixel components.  Otherwise, the product
 will overflow a uint8.  In use, factor is the same for
 all pixels in a pix.
 (3) No scaling is performed on the transparency ("A") component.
 </summary>
	<remarks>
	</remarks>
	<param name="sval">32-bit rgb pixel value</param>
	<param name="tab">256 entry log-base-2 table</param>
	<param name="factor">multiplication factor on each component</param>
	<returns>dval  log scaled version of %sval</returns>
</member><member name="M:LeptonicaSharp.Natives.makeLogBase2Tab">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.getLogBase2(System.Int32,System.Single[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixcompCreateFromPix(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Use %comptype == IFF_DEFAULT to have the compression
 type automatically determined.
 (2) To compress jpeg with a quality other than the default (75), use
 l_jpegSetQuality()
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>pixc, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcompCreateFromString(System.Byte[],System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) This works when the compressed string is png, jpeg or tiffg4.
 (2) The copyflag determines if the data in the new Pixcomp is
 a copy of the input data.
 </summary>
	<remarks>
	</remarks>
	<param name="data">compressed string</param>
	<param name="size">number of bytes</param>
	<param name="copyflag">L_INSERT or L_COPY</param>
	<returns>pixc, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcompCreateFromFile(System.String,System.Int32)">
	<summary>
 Notes
 (1) Use %comptype == IFF_DEFAULT to have the compression
 type automatically determined.
 (2) If the comptype is invalid for this file, the default will
 be substituted.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>pixc, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcompDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppixc">will be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.pixcompCopy(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixcs"></param>
	<returns>pixcd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcompGetDimensions(System.IntPtr,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixc"></param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pd"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcompGetParameters(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixc"></param>
	<param name="pxres"></param>
	<param name="pyres"></param>
	<param name="pcomptype"></param>
	<param name="pcmapflag"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcompDetermineFormat(System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This determines the best format for a pix, given both
 the request (%comptype) and the image characteristics.
 (2) If %comptype == IFF_DEFAULT, this does not necessarily result
 in png encoding.  Instead, it returns one of the three formats
 that is both valid and most likely to give best compression.
 (3) If the pix cannot be compressed by the input value of
 %comptype, this selects IFF_PNG, which can compress all pix.
 </summary>
	<remarks>
	</remarks>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<param name="d">pix depth</param>
	<param name="cmapflag">1 if pix to be compressed as a colormap; 0 otherwise</param>
	<param name="pformat">return IFF_TIFF, IFF_PNG or IFF_JFIF_JPEG</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixCreateFromPixcomp(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixc"></param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">initial number of ptrs</param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompCreateWithInit(System.Int32,System.Int32,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Initializes a pixacomp to be fully populated with %pix,
 compressed using %comptype.  If %pix == NULL, %comptype
 is ignored.
 (2) Typically, the array is initialized with a tiny pix.
 This is most easily done by setting %pix == NULL, causing
 initialization of each array element with a tiny placeholder
 pix (w = h = d = 1), using comptype = IFF_TIFF_G4 .
 (3) Example usage
 // Generate pixacomp for pages 30 - 49.  This has an array
 // size of 20 and the page number offset is 30.
 PixaComp pixac = pixacompCreateWithInit(20, 30, NULL,
 IFF_TIFF_G4);
 // Now insert png-compressed images into the initialized array
 for (pageno = 30; pageno LT 50; pageno++) {
 Pix pixt = ...   // derived from image[pageno]
 if (pixt)
 pixacompReplacePix(pixac, pageno, pixt, IFF_PNG);
 pixDestroy(pixt);
 }
 The result is a pixac with 20 compressed strings, and with
 selected pixt replacing the placeholders.
 To extract the image for page 38, which is decompressed
 from element 8 in the array, use
 pixt = pixacompGetPix(pixac, 38);
 </summary>
	<remarks>
	</remarks>
	<param name="n">initial number of ptrs</param>
	<param name="offset">difference accessor index - pixacomp array index</param>
	<param name="pix">initialize each ptr in pixacomp to this pix; can be NULL</param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompCreateFromPixa(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If %format == IFF_DEFAULT, the conversion format for each
 image is chosen automatically.  Otherwise, we use the
 specified format unless it can't be done (e.g., jpeg
 for a 1, 2 or 4 bpp pix, or a pix with a colormap),
 in which case we use the default (assumed best) compression.
 (2) %accesstype is used to extract a boxa from %pixa.
 (3) To compress jpeg with a quality other than the default (75), use
 l_jpegSetQuality()
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<param name="accesstype">L_COPY, L_CLONE, L_COPY_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompCreateFromFiles(System.String,System.String,System.Int32)">
	<summary>
 Notes
 (1) %dirname is the full path for the directory.
 (2) %substr is the part of the file name (excluding
 the directory) that is to be matched.  All matching
 filenames are read into the Pixa.  If substr is NULL,
 all filenames are read into the Pixa.
 (3) Use %comptype == IFF_DEFAULT to have the compression
 type automatically determined for each file.
 (4) If the comptype is invalid for a file, the default will
 be substituted.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname"></param>
	<param name="substr">substring filter on filenames; can be null</param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompCreateFromSA(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Use %comptype == IFF_DEFAULT to have the compression
 type automatically determined for each file.
 (2) If the comptype is invalid for a file, the default will
 be substituted.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">full pathnames for all files</param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppixac">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.pixacompAddPix(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The array is filled up to the (n-1)-th element, and this
 converts the input pix to a pixc and adds it at
 the n-th position.
 (2) The pixc produced from the pix is owned by the pixac.
 The input pix is not affected.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="pix">to be added</param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompAddPixcomp(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Anything added to a pixac is owned by the pixac.
 So do not L_INSERT a pixc that is owned by another pixac,
 or destroy a pixc that has been L_INSERTed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="pixc">to be added by insertion</param>
	<param name="copyflag">L_INSERT, L_COPY</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompReplacePix(System.IntPtr,System.Int32,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 (2) The input %pix is converted to a pixc, which is then inserted
 into the pixac.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<param name="pix">owned by the caller</param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompReplacePixcomp(System.IntPtr,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 (2) The inserted %pixc is now owned by the pixac.  The caller
 must not destroy it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<param name="pixc">to replace existing one, which is destroyed</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompAddBox(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="box"></param>
	<param name="copyflag">L_INSERT, L_COPY</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<returns>count, or 0 if no pixa</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompGetPixcomp(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 (2) If copyflag == L_NOCOPY, the pixc is owned by %pixac; do
 not destroy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<param name="copyflag">L_NOCOPY, L_COPY</param>
	<returns>pixc, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompGetPix(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompGetPixDimensions(System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<param name="pd">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompGetBoxa(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="accesstype">L_COPY, L_CLONE, L_COPY_CLONE</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompGetBoxaCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompGetBox(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 (2) There is always a boxa with a pixac, and it is initialized so
 that each box ptr is NULL.
 (3) In general, we expect that there is either a box associated
 with each pixc, or no boxes at all in the boxa.
 (4) Having no boxes is thus not an automatic error.  Whether it
 is an actual error is determined by the calling program.
 If the caller expects to get a box, it is an error; see, e.g.,
 pixacGetBoxGeometry().
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<param name="accesstype">L_COPY or L_CLONE</param>
	<returns>box if null, not automatically an error, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompGetBoxGeometry(System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<param name="px">each can be null</param>
	<param name="py">each can be null</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompGetOffset(System.IntPtr)">
	<summary>
 Notes
 (1) The offset is the difference between the caller's view of
 the index into the array and the actual array index.
 By default it is 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<returns>offset, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompSetOffset(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The offset is the difference between the caller's view of
 the index into the array and the actual array index.
 By default it is 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="offset">non-negative</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaCreateFromPixacomp(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Because the pixa has no notion of offset, the offset must
 be set to 0 before the conversion, so that pixacompGetPix()
 fetches all the pixcomps.  It is reset at the end.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="accesstype">L_COPY, L_CLONE, L_COPY_CLONE; for boxa</param>
	<returns>pixa if OK, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompJoin(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This appends a clone of each indicated pixc in pixcas to pixcad
 (2) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (3) iend LT 0 means 'read to the end'
 (4) If pixacs is NULL or contains no pixc, this is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="pixacd">dest pixac; add to this one</param>
	<param name="pixacs">source pixac; add from this one</param>
	<param name="istart">starting index in pixacs</param>
	<param name="iend">ending index in pixacs; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompInterleave(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) If the two pixac have different sizes, a warning is issued,
 and the number of pairs returned is the minimum size.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac1">first src pixac</param>
	<param name="pixac2">second src pixac</param>
	<returns>pixacd  interleaved from sources, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompRead(System.String)">
	<summary>
 Notes
 (1) Unlike the situation with serialized Pixa, where the image
 data is stored in png format, the Pixacomp image data
 can be stored in tiffg4, png and jpg formats.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompReadMem(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) Deseralizes a buffer of pixacomp data into a pixac in memory.
 </summary>
	<remarks>
	</remarks>
	<param name="data">const; pixacomp format</param>
	<param name="size">of data</param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompWrite(System.String,System.IntPtr)">
	<summary>
 Notes
 (1) Unlike the situation with serialized Pixa, where the image
 data is stored in png format, the Pixacomp image data
 can be stored in tiffg4, png and jpg formats.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pixac"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pixac"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a pixac in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">serialized data of pixac</param>
	<param name="psize">size of serialized data</param>
	<param name="pixac"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompConvertToPdf(System.IntPtr,System.Int32,System.Single,System.Int32,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) This follows closely the function pixaConvertToPdf() in pdfio.c.
 (2) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without
 colormap and many colors, or 32 bpp; FLATE for anything else.
 (3) The scalefactor must be GT 0.0; otherwise it is set to 1.0.
 (4) Specifying one of the three encoding types for %type forces
 all images to be compressed with that type.  Use 0 to have
 the type determined for each image based on depth and whether
 or not it has a colormap.
 (5) If all images are jpeg compressed, don't require scaling
 and have the same resolution, it is much faster to skip
 transcoding with pixacompFastConvertToPdfData(), and then
 write the data out to file.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac">containing images all at the same resolution</param>
	<param name="res">override the resolution of each input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or L_DEFAULT_ENCODE for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompConvertToPdfData(System.IntPtr,System.Int32,System.Single,System.Int32,System.Int32,System.String,System.IntPtr@,System.UInt32@)">
	<summary>
 Notes
 (1) See pixacompConvertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="pixac">containing images all at the same resolution</param>
	<param name="res">input resolution of all images</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or L_DEFAULT_ENCODE for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title</param>
	<param name="pdata">output pdf data (of all images</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompFastConvertToPdfData(System.IntPtr,System.String,System.IntPtr@,System.UInt32@)">
	<summary>
 Notes
 (1) This generates the pdf without transcoding if all the
 images in %pixac are compressed with jpeg.
 Images not jpeg compressed are skipped.
 (2) It assumes all images have the same resolution, and that
 the resolution embedded in each jpeg file is correct.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac">containing images all at the same resolution</param>
	<param name="title">pdf title</param>
	<param name="pdata">output pdf data (of all images</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompWriteStreamInfo(System.IntPtr,System.IntPtr,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pixac"></param>
	<param name="text">identifying string; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcompWriteStreamInfo(System.IntPtr,System.IntPtr,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pixc"></param>
	<param name="text">identifying string; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompDisplayTiledAndScaled(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is the same function as pixaDisplayTiledAndScaled(),
 except it works on a Pixacomp instead of a Pix.  It is particularly
 useful for showing the images in a Pixacomp at reduced resolution.
 (2) See pixaDisplayTiledAndScaled() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="outdepth">output depth 1, 8 or 32 bpp</param>
	<param name="tilewidth">each pix is scaled to this width</param>
	<param name="ncols">number of tiles in each row</param>
	<param name="background">0 for white, 1 for black; this is the color of the spacing between the images</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<returns>pix of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixacompWriteFiles(System.IntPtr,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="subdir">(subdirectory of /tmp)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixcompWriteFile(System.String,System.IntPtr)">
	<summary>
 Notes
 (1) The compressed data is written to file, and the filename is
 generated by appending the format extension to %rootname.
 </summary>
	<remarks>
	</remarks>
	<param name="rootname"></param>
	<param name="pixc"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixThreshold8(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This uses, by default, equally spaced "target" values
 that depend on the number of levels, with thresholds
 halfway between.  For N levels, with separation (N-1)/255,
 there are N-1 fixed thresholds.
 (2) For 1 bpp destination, the number of levels can only be 2
 and if a cmap is made, black is (0,0,0) and white
 is (255,255,255), which is opposite to the convention
 without a colormap.
 (3) For 1, 2 and 4 bpp, the nlevels arg is used if a colormap
 is made; otherwise, we take the most significant bits
 from the src that will fit in the dest.
 (4) For 8 bpp, the input pixs is quantized to nlevels.  The
 dest quantized with that mapping, either through a colormap
 table or directly with 8 bit values.
 (5) Typically you should not use make a colormap for 1 bpp dest.
 (6) This is not dithering.  Each pixel is treated independently.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="d">destination depth 1, 2, 4 or 8</param>
	<param name="nlevels">number of levels to be used for colormap</param>
	<param name="cmapflag">1 if makes colormap; 0 otherwise</param>
	<returns>pixd thresholded with standard dest thresholds, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRemoveColormapGeneral(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Convenience function that allows choice between returning
 a clone or a copy if pixs does not have a colormap.
 (2) See pixRemoveColormap().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, with or without colormap</param>
	<param name="type">REMOVE_CMAP_TO_BINARY, REMOVE_CMAP_TO_GRAYSCALE, REMOVE_CMAP_TO_FULL_COLOR, REMOVE_CMAP_WITH_ALPHA, REMOVE_CMAP_BASED_ON_SRC</param>
	<param name="ifnocmap">L_CLONE, L_COPY</param>
	<returns>pixd always a new pix; without colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRemoveColormap(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If pixs does not have a colormap, a clone is returned.
 (2) Otherwise, the input pixs is restricted to 1, 2, 4 or 8 bpp.
 (3) Use REMOVE_CMAP_TO_BINARY only on 1 bpp pix.
 (4) For grayscale conversion from RGB, use a weighted average
 of RGB values, and always return an 8 bpp pix, regardless
 of whether the input pixs depth is 2, 4 or 8 bpp.
 (5) REMOVE_CMAP_TO_FULL_COLOR ignores the alpha component and
 returns a 32 bpp pix with spp == 3 and the alpha bytes are 0.
 (6) For REMOVE_CMAP_BASED_ON_SRC, if there is no color, this
 returns either a 1 bpp or 8 bpp grayscale pix.
 If there is color, this returns a 32 bpp pix, with either
 3 spp, if the alpha values are all 255 (opaque), or
 4 spp (preserving the alpha), if any alpha values are not 255.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">see restrictions below</param>
	<param name="type">REMOVE_CMAP_TO_BINARY, REMOVE_CMAP_TO_GRAYSCALE, REMOVE_CMAP_TO_FULL_COLOR, REMOVE_CMAP_WITH_ALPHA, REMOVE_CMAP_BASED_ON_SRC</param>
	<returns>pixd without colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddGrayColormap8(System.IntPtr)">
	<summary>
 Notes
 (1) If pixs has a colormap, this is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddMinimalGrayColormap8(System.IntPtr)">
	<summary>
 Notes
 (1) This generates a colormapped version of the input image
 that has the same number of colormap entries as the
 input image has unique gray levels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToLuminance(System.IntPtr)">
	<summary>
 Notes
 (1) Use a standard luminance conversion.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<returns>8 bpp pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToGray(System.IntPtr,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) Use a weighted average of the RGB values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<param name="rwt">non-negative; these should add to 1.0, or use 0.0 for default</param>
	<param name="gwt">non-negative; these should add to 1.0, or use 0.0 for default</param>
	<param name="bwt">non-negative; these should add to 1.0, or use 0.0 for default</param>
	<returns>8 bpp pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToGrayFast(System.IntPtr)">
	<summary>
 Notes
 (1) This function should be used if speed of conversion
 is paramount, and the green channel can be used as
 a fair representative of the RGB intensity.  It is
 several times faster than pixConvertRGBToGray().
 (2) To combine RGB to gray conversion with subsampling,
 use pixScaleRGBToGrayFast() instead.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<returns>8 bpp pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToGrayMinMax(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This chooses various components or combinations of them,
 from the three RGB sample values.  In addition to choosing
 the min, max, and maxdiff (difference between max and min),
 this also allows boosting the min and max about a reference
 value.
 (2) The default reference value for boosting the min and max
 is 200.  This can be changed with l_setNeutralBoostVal()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<param name="type">L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF, L_CHOOSE_MIN_BOOST, L_CHOOSE_MAX_BOOST</param>
	<returns>8 bpp pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToGraySatBoost(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This returns the max component value, boosted by
 the saturation. The maximum boost occurs where
 the maximum component value is equal to some reference value.
 This particular weighting is due to Dany Qumsiyeh.
 (2) For gray pixels (zero saturation), this returns
 the intensity of any component.
 (3) For fully saturated pixels ('fullsat'), this rises linearly
 with the max value and has a slope equal to 255 divided
 by the reference value; for a max value greater than
 the reference value, it is clipped to 255.
 (4) For saturation values in between, the output is a linear
 combination of (2) and (3), weighted by saturation.
 It falls between these two curves, and does not exceed 255.
 (5) This can be useful for distinguishing an object that has nonzero
 saturation from a gray background.  For this, the refval
 should be chosen near the expected value of the background,
 to achieve maximum saturation boost there.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="refval">between 1 and 255; typ. less than 128</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToGrayArb(System.IntPtr,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This converts to gray using an arbitrary linear combination
 of the rgb color components.  It differs from pixConvertToGray(),
 which uses only positive coefficients that sum to 1.
 (2) The gray output values are clipped to 0 and 255.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<param name="rc">arithmetic factors; can be negative</param>
	<param name="gc">arithmetic factors; can be negative</param>
	<param name="bc">arithmetic factors; can be negative</param>
	<returns>8 bpp pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToBinaryArb(System.IntPtr,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This makes a 1 bpp mask from an RGB image, using an arbitrary
 linear combination of the rgb color components, along with
 a threshold and a selection choice of the gray value relative
 to %thresh.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<param name="rc">arithmetic factors; can be negative</param>
	<param name="gc">arithmetic factors; can be negative</param>
	<param name="bc">arithmetic factors; can be negative</param>
	<param name="thresh">binarization threshold</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns>1 bpp pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertGrayToColormap(System.IntPtr)">
	<summary>
 Notes
 (1) This is a simple interface for adding a colormap to a
 2, 4 or 8 bpp grayscale image without causing any
 quantization.  There is some similarity to operations
 in grayquant.c, such as pixThresholdOn8bpp(), where
 the emphasis is on quantization with an arbitrary number
 of levels, and a colormap is an option.
 (2) Returns a copy if pixs already has a colormap.
 (3) For 8 bpp src, this is a lossless transformation.
 (4) For 2 and 4 bpp src, this generates a colormap that
 assumes full coverage of the gray space, with equally spaced
 levels 4 levels for d = 2 and 16 levels for d = 4.
 (5) In all cases, the depth of the dest is the same as the src.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp grayscale</param>
	<returns>pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertGrayToColormap8(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Returns a copy if pixs already has a colormap.
 (2) This is a lossless transformation; there is no quantization.
 We compute the number of different gray values in pixs,
 and construct a colormap that has exactly these values.
 (3) 'mindepth' is the minimum depth of pixd.  If mindepth == 8,
 pixd will always be 8 bpp.  Let the number of different
 gray values in pixs be ngray.  If mindepth == 4, we attempt
 to save pixd as a 4 bpp image, but if ngray GT 16,
 pixd must be 8 bpp.  Likewise, if mindepth == 2,
 the depth of pixd will be 2 if ngray LT= 4 and 4 if ngray GT 4
 but LT= 16.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="mindepth">of pixd; valid values are 2, 4 and 8</param>
	<returns>pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixColorizeGray(System.IntPtr,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) This applies the specific color to the grayscale image.
 (2) If pixs already has a colormap, it is removed to gray
 before colorizing.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray; 2, 4 or 8 bpp colormapped</param>
	<param name="color">32 bit rgba pixel</param>
	<param name="cmapflag">1 for result to have colormap; 0 for RGB</param>
	<returns>pixd 8 bpp colormapped or 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertRGBToColormap(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This function has two relatively simple modes of color
 quantization
 (a) If the image is made orthographically and has not more
 than 256 'colors' at the level 4 octcube leaves,
 it is quantized nearly exactly.  The ditherflag
 is ignored.
 (b) Most natural images have more than 256 different colors;
 in that case we use adaptive octree quantization,
 with dithering if requested.
 (2) If there are not more than 256 occupied level 4 octcubes,
 the color in the colormap that represents all pixels in
 one of those octcubes is given by the first pixel that
 falls into that octcube.
 (3) If there are more than 256 colors, we use adaptive octree
 color quantization.
 (4) Dithering gives better visual results on images where
 there is a color wash (a slow variation of color), but it
 is about twice as slow and results in significantly larger
 files when losslessly compressed (e.g., into png).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="ditherflag">1 to dither, 0 otherwise</param>
	<returns>pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertCmapTo1(System.IntPtr)">
	<summary>
 Notes
 (1) This is an extreme color quantizer.  It decides which
 colors map to FG (black) and which to BG (white).
 (2) This uses two heuristics to make the decision
 (a) colors similar to each other are likely to be in the same class
 (b) there is usually much less FG than BG.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">cmapped</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixQuantizeIfFewColors(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) This is a wrapper that tests if the pix can be quantized
 with good quality using a small number of colors.  If so,
 it does the quantization, defining a colormap and using
 pixels whose value is an index into the colormap.
 (2) If the image has color, it is quantized with 8 bpp pixels.
 If the image is essentially grayscale, the pixels are
 either 4 or 8 bpp, depending on the size of the required
 colormap.
 (3) %octlevel = 4 generates a larger colormap and larger
 compressed image than %octlevel = 3.  If image quality is
 important, you should use %octlevel = 4.
 (4) If the image already has a colormap, it returns a clone.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb</param>
	<param name="maxcolors">max number of colors allowed to be returned from pixColorsForQuantization(); use 0 for default</param>
	<param name="mingraycolors">min number of gray levels that a grayscale image is quantized to; use 0 for default</param>
	<param name="octlevel">for octcube quantization 3 or 4</param>
	<param name="ppixd">2,4 or 8 bpp quantized; null if too many colors</param>
	<returns>0 if OK, 1 on error or if pixs can't be quantized into a small number of colors.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert16To8(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) With L_AUTO_BYTE, if the max pixel value is greater than 255,
 use the MSB; otherwise, use the LSB.
 (2) With L_CLIP_TO_FF, use min(pixel-value, 0xff) for each
 16-bit src pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">16 bpp</param>
	<param name="type">L_LS_BYTE, L_MS_BYTE, L_AUTO_BYTE, L_CLIP_TO_FF</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertGrayToFalseColor(System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) For 8 bpp input, this simply adds a colormap to the input image.
 (2) For 16 bpp input, it first converts to 8 bpp, using the MSB,
 and then adds the colormap.
 (3) The colormap is modeled after the Matlab "jet" configuration.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 16 bpp grayscale</param>
	<param name="gamma">(factor) 0.0 or 1.0 for default; GT 1.0 for brighter; 2.0 is quite nice</param>
	<returns>pixd 8 bpp with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixUnpackBinary(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This function calls special cases of pixConvert1To(),
 for 2, 4, 8, 16 and 32 bpp destinations.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="depth">of destination 2, 4, 8, 16 or 32 bpp</param>
	<param name="invert">0  binary 0 --GT grayscale 0 binary 1 --GT grayscale 0xff... 1  binary 0 --GT grayscale 0xff... binary 1 --GT grayscale 0</param>
	<returns>pixd 2, 4, 8, 16 or 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert1To16(System.IntPtr,System.IntPtr,System.UInt16,System.UInt16)">
	<summary>
 Notes
 (1) If pixd is null, a new pix is made.
 (2) If pixd is not null, it must be of equal width and height
 as pixs.  It is always returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">16 bpp, can be null</param>
	<param name="pixs">1 bpp</param>
	<param name="val0">16 bit value to be used for 0s in pixs</param>
	<param name="val1">16 bit value to be used for 1s in pixs</param>
	<returns>pixd 16 bpp</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert1To32(System.IntPtr,System.IntPtr,System.UInt32,System.UInt32)">
	<summary>
 Notes
 (1) If pixd is null, a new pix is made.
 (2) If pixd is not null, it must be of equal width and height
 as pixs.  It is always returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp, can be null</param>
	<param name="pixs">1 bpp</param>
	<param name="val0">32 bit value to be used for 0s in pixs</param>
	<param name="val1">32 bit value to be used for 1s in pixs</param>
	<returns>pixd 32 bpp</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert1To2Cmap(System.IntPtr)">
	<summary>
 Notes
 (1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 2 bpp, cmapped</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert1To2(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If pixd is null, a new pix is made.
 (2) If pixd is not null, it must be of equal width and height
 as pixs.  It is always returned.
 (3) A simple unpacking might use val0 = 0 and val1 = 3.
 (4) If you want a colormapped pixd, use pixConvert1To2Cmap().
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">2 bpp, can be null</param>
	<param name="pixs">1 bpp</param>
	<param name="val0">2 bit value to be used for 0s in pixs</param>
	<param name="val1">2 bit value to be used for 1s in pixs</param>
	<returns>pixd 2 bpp</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert1To4Cmap(System.IntPtr)">
	<summary>
 Notes
 (1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 4 bpp, cmapped</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert1To4(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If pixd is null, a new pix is made.
 (2) If pixd is not null, it must be of equal width and height
 as pixs.  It is always returned.
 (3) A simple unpacking might use val0 = 0 and val1 = 15, or v.v.
 (4) If you want a colormapped pixd, use pixConvert1To4Cmap().
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">4 bpp, can be null</param>
	<param name="pixs">1 bpp</param>
	<param name="val0">4 bit value to be used for 0s in pixs</param>
	<param name="val1">4 bit value to be used for 1s in pixs</param>
	<returns>pixd 4 bpp</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert1To8Cmap(System.IntPtr)">
	<summary>
 Notes
 (1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, cmapped</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert1To8(System.IntPtr,System.IntPtr,System.Byte,System.Byte)">
	<summary>
 Notes
 (1) If pixd is null, a new pix is made.
 (2) If pixd is not null, it must be of equal width and height
 as pixs.  It is always returned.
 (3) A simple unpacking might use val0 = 0 and val1 = 255, or v.v.
 (4) To have a colormap associated with the 8 bpp pixd,
 use pixConvert1To8Cmap().
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8 bpp, can be null</param>
	<param name="pixs">1 bpp</param>
	<param name="val0">8 bit value to be used for 0s in pixs</param>
	<param name="val1">8 bit value to be used for 1s in pixs</param>
	<returns>pixd 8 bpp</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert2To8(System.IntPtr,System.Byte,System.Byte,System.Byte,System.Byte,System.Int32)">
	<summary>
 Notes
 ~ A simple unpacking might use val0 = 0,
 val1 = 85 (0x55), val2 = 170 (0xaa), val3 = 255.
 ~ If cmapflag is TRUE
 ~ The 8 bpp image is made with a colormap.
 ~ If pixs has a colormap, the input values are ignored and
 the 8 bpp image is made using the colormap
 ~ If pixs does not have a colormap, the input values are
 used to build the colormap.
 ~ If cmapflag is FALSE
 ~ The 8 bpp image is made without a colormap.
 ~ If pixs has a colormap, the input values are ignored,
 the colormap is removed, and the values stored in the 8 bpp
 image are from the colormap.
 ~ If pixs does not have a colormap, the input values are
 used to populate the 8 bpp image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2 bpp</param>
	<param name="val0">8 bit value to be used for 00 in pixs</param>
	<param name="val1">8 bit value to be used for 01 in pixs</param>
	<param name="val2">8 bit value to be used for 10 in pixs</param>
	<param name="val3">8 bit value to be used for 11 in pixs</param>
	<param name="cmapflag">TRUE if pixd is to have a colormap; FALSE otherwise</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert4To8(System.IntPtr,System.Int32)">
	<summary>
 Notes
 ~ If cmapflag is TRUE
 ~ pixd is made with a colormap.
 ~ If pixs has a colormap, it is copied and the colormap
 index values are placed in pixd.
 ~ If pixs does not have a colormap, a colormap with linear
 trc is built and the pixel values in pixs are placed in
 pixd as colormap index values.
 ~ If cmapflag is FALSE
 ~ pixd is made without a colormap.
 ~ If pixs has a colormap, it is removed and the values stored
 in pixd are from the colormap (converted to gray).
 ~ If pixs does not have a colormap, the pixel values in pixs
 are used, with shift replication, to populate pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">4 bpp</param>
	<param name="cmapflag">TRUE if pixd is to have a colormap; FALSE otherwise</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert8To16(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) For left shift of 8, the 8 bit value is replicated in both
 the MSB and the LSB of the pixels in pixd.  That way, we get
 proportional mapping, with a correct map from 8 bpp white
 (0xff) to 16 bpp white (0xffff).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; colormap removed to gray</param>
	<param name="leftshift">number of bits 0 is no shift; 8 replicates in MSB and LSB of dest</param>
	<returns>pixd 16 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertTo2(System.IntPtr)">
	<summary>
 Notes
 (1) This is a top-level function, with simple default values
 used in pixConvertTo8() if unpacking is necessary.
 (2) Any existing colormap is removed; the result is always gray.
 (3) If the input image has 2 bpp and no colormap, the operation is
 lossless and a copy is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp; colormap OK but will be removed</param>
	<returns>pixd   2 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert8To2(System.IntPtr)">
	<summary>
 Notes
 (1) Any existing colormap is removed to gray.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; colormap OK</param>
	<returns>pixd  2 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertTo4(System.IntPtr)">
	<summary>
 Notes
 (1) This is a top-level function, with simple default values
 used in pixConvertTo8() if unpacking is necessary.
 (2) Any existing colormap is removed; the result is always gray.
 (3) If the input image has 4 bpp and no colormap, the operation is
 lossless and a copy is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp; colormap OK but will be removed</param>
	<returns>pixd   4 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert8To4(System.IntPtr)">
	<summary>
 Notes
 (1) Any existing colormap is removed to gray.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; colormap OK</param>
	<returns>pixd  4 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertTo1(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is a top-level function, with simple default values
 used in pixConvertTo8() if unpacking is necessary.
 (2) Any existing colormap is removed.
 (3) If the input image has 1 bpp and no colormap, the operation is
 lossless and a copy is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="threshold">for final binarization, relative to 8 bpp</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertTo1BySampling(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a quick and dirty, top-level converter.
 (2) See pixConvertTo1() for default values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="factor">submsampling factor; integer GT= 1</param>
	<param name="threshold">for final binarization, relative to 8 bpp</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertTo8(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is a top-level function, with simple default values
 for unpacking.
 (2) The result, pixd, is made with a colormap if specified.
 It is always a new image -- never a clone.  For example,
 if d == 8, and cmapflag matches the existence of a cmap
 in pixs, the operation is lossless and it returns a copy.
 (3) The default values used are
 ~ 1 bpp val0 = 255, val1 = 0
 ~ 2 bpp 4 bpp  even increments over dynamic range
 ~ 8 bpp lossless if cmap matches cmapflag
 ~ 16 bpp use most significant byte
 (4) If 32 bpp RGB, this is converted to gray.  If you want
 to do color quantization, you must specify the type
 explicitly, using the color quantization code.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="cmapflag">TRUE if pixd is to have a colormap; FALSE otherwise</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertTo8BySampling(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a fast, quick/dirty, top-level converter.
 (2) See pixConvertTo8() for default values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="factor">submsampling factor; integer GT= 1</param>
	<param name="cmapflag">TRUE if pixd is to have a colormap; FALSE otherwise</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertTo8Colormap(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is a top-level function, with simple default values
 for unpacking.
 (2) The result, pixd, is always made with a colormap.
 (3) If d == 8, the operation is lossless and it returns a copy.
 (4) The default values used for increasing depth are
 ~ 1 bpp val0 = 255, val1 = 0
 ~ 2 bpp 4 bpp  even increments over dynamic range
 (5) For 16 bpp, use the most significant byte.
 (6) For 32 bpp RGB, use octcube quantization with optional dithering.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="dither">1 to dither if necessary; 0 otherwise</param>
	<returns>pixd 8 bpp, cmapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertTo16(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 bpp</param>
	<returns>pixd 16 bpp, or NULL on error Usage Top-level function, with simple default values for unpacking. 1 bpp  val0 = 0xffff, val1 = 0 8 bpp  replicates the 8 bit value in both the MSB and LSB of the 16 bit pixel.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertTo32(System.IntPtr)">
	<summary>
 Notes
 (1) Never returns a clone of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<returns>pixd 32 bpp, or NULL on error Usage Top-level function, with simple default values for unpacking. 1 bpp  val0 = 255, val1 = 0 and then replication into R, G and B components 2 bpp  if colormapped, use the colormap values; otherwise, use val0 = 0, val1 = 0x55, val2 = 0xaa, val3 = 255 and replicate gray into R, G and B components 4 bpp  if colormapped, use the colormap values; otherwise, replicate 2 nybs into a byte, and then into R,G,B components 8 bpp  if colormapped, use the colormap values; otherwise, replicate gray values into R, G and B components 16 bpp replicate MSB into R, G and B components 24 bpp unpack the pixels, maintaining word alignment on each scanline 32 bpp makes a copy</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertTo32BySampling(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is a fast, quick/dirty, top-level converter.
 (2) See pixConvertTo32() for default values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="factor">submsampling factor; integer GT= 1</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert8To32(System.IntPtr)">
	<summary>
 Notes
 (1) If there is no colormap, replicates the gray value
 into the 3 MSB of the dest pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<returns>32 bpp rgb pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertTo8Or32(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If there is a colormap, the colormap is removed to 8 or 32 bpp,
 depending on whether the colors in the colormap are all gray.
 (2) If the input is either rgb or 8 bpp without a colormap,
 this returns either a clone or a copy, depending on %copyflag.
 (3) Otherwise, the pix is converted to 8 bpp grayscale.
 In all cases, pixd does not have a colormap.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, with or without colormap; or 32 bpp rgb</param>
	<param name="copyflag">L_CLONE or L_COPY</param>
	<param name="warnflag">1 to issue warning if colormap is removed; else 0</param>
	<returns>pixd 8 bpp grayscale or 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert24To32(System.IntPtr)">
	<summary>
 Notes
 (1) 24 bpp rgb pix are not supported in leptonica, except for a small
 number of formatted write operations.  The data is a byte array,
 with pixels in order r,g,b, and padded to 32 bit boundaries
 in each line.
 (2) Because 24 bpp rgb pix are conveniently generated by programs
 such as xpdf (which has SplashBitmaps that store the raster
 data in consecutive 24-bit rgb pixels), it is useful to provide
 24 bpp pix that simply incorporate that data.  The only things
 we can do with these are
 (a) write them to file in png, jpeg, tiff and pnm
 (b) interconvert between 24 and 32 bpp in memory (for testing).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">24 bpp rgb</param>
	<returns>pixd 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert32To24(System.IntPtr)">
	<summary>
 Notes
 (1) See pixconvert24To32().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<returns>pixd 24 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert32To16(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The data in pixs is typically used for labelling.
 It is an array of l_uint32 values, not rgb or rgba.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, single component</param>
	<param name="type">L_LS_TWO_BYTES, L_MS_TWO_BYTES, L_CLIP_TO_FFFF</param>
	<returns>pixd 16 bpp , or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvert32To8(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, single component</param>
	<param name="type16">L_LS_TWO_BYTES, L_MS_TWO_BYTES, L_CLIP_TO_FFFF</param>
	<param name="type8">L_LS_BYTE, L_MS_BYTE, L_CLIP_TO_FF</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRemoveAlpha(System.IntPtr)">
	<summary>
 Notes
 (1) This is a wrapper on pixAlphaBlendUniform()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<returns>pixd        if 32 bpp rgba, pixs blended over a white background; a clone of pixs otherwise, and NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddAlphaTo1bpp(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) We don't use 1 bpp colormapped images with alpha in leptonica,
 but we support generating them (here), writing to png, and reading
 the png.  On reading, they are converted to 32 bpp RGBA.
 (2) The background (0) pixels in pixs become fully transparent, and the
 foreground (1) pixels are fully opaque.  Thus, pixd is a 1 bpp
 representation of a stencil, that can be used to paint over pixels
 of a backing image that are masked by the foreground in pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">1 bpp, can be null or equal to pixs</param>
	<param name="pixs">1 bpp</param>
	<returns>pixd 1 bpp with colormap and non-opaque alpha, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertLossless(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is a lossless unpacking (depth-increasing)
 conversion.  If ds is the depth of pixs, then
 ~ if d LT ds, returns NULL
 ~ if d == ds, returns a copy
 ~ if d GT ds, does the unpacking conversion
 (2) If pixs has a colormap, this is an error.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8 bpp, not cmapped</param>
	<param name="d">destination depth 2, 4 or 8</param>
	<returns>pixd 2, 4 or 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertForPSWrap(System.IntPtr)">
	<summary>
 Notes
 (1) For wrapping in PostScript, we convert pixs to
 1 bpp, 8 bpp (gray) and 32 bpp (RGB color).
 (2) Colormaps are removed.  For pixs with colormaps, the
 images are converted to either 8 bpp gray or 32 bpp
 RGB, depending on whether the colormap has color content.
 (3) Images without colormaps, that are not 1 bpp or 32 bpp,
 are converted to 8 bpp gray.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp</param>
	<returns>pixd    1, 8, or 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertToSubpixelRGB(System.IntPtr,System.Single,System.Single,System.Int32)">
	<summary>
 Notes
 (1) If pixs has a colormap, it is removed based on its contents
 to either 8 bpp gray or rgb.
 (2) For horizontal subpixel splitting, the input image
 is rescaled by %scaley vertically and by 3.0 times
 %scalex horizontally.  Then each horizontal triplet
 of pixels is mapped back to a single rgb pixel, with the
 r, g and b values being assigned based on the pixel triplet.
 For gray triplets, the r, g, and b values are set equal to
 the three gray values.  For color triplets, the r, g and b
 values are set equal to the components from the appropriate
 subpixel.  Vertical subpixel splitting is handled similarly.
 (3) See pixConvertGrayToSubpixelRGB() and
 pixConvertColorToSubpixelRGB() for further details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, 32 bpp rgb, or colormapped</param>
	<param name="scalex">anisotropic scaling permitted between source and destination</param>
	<param name="scaley">anisotropic scaling permitted between source and destination</param>
	<param name="order">of subpixel rgb color components in composition of pixd L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR, L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertGrayToSubpixelRGB(System.IntPtr,System.Single,System.Single,System.Int32)">
	<summary>
 Notes
 (1) If pixs has a colormap, it is removed to 8 bpp.
 (2) For horizontal subpixel splitting, the input gray image
 is rescaled by %scaley vertically and by 3.0 times
 %scalex horizontally.  Then each horizontal triplet
 of pixels is mapped back to a single rgb pixel, with the
 r, g and b values being assigned from the triplet of gray values.
 Similar operations are used for vertical subpixel splitting.
 (3) This is a form of subpixel rendering that tends to give the
 resulting text a sharper and somewhat chromatic display.
 For horizontal subpixel splitting, the observable difference
 between %order=L_SUBPIXEL_ORDER_RGB and
 %order=L_SUBPIXEL_ORDER_BGR is reduced by optical diffusers
 in the display that make the pixel color appear to emerge
 from the entire pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp or colormapped</param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<param name="order">of subpixel rgb color components in composition of pixd L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR, L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConvertColorToSubpixelRGB(System.IntPtr,System.Single,System.Single,System.Int32)">
	<summary>
 Notes
 (1) If pixs has a colormap, it is removed to 32 bpp rgb.
 If the colormap has no color, pixConvertGrayToSubpixelRGB()
 should be called instead, because it will give the same result
 more efficiently.  The function pixConvertToSubpixelRGB()
 will do the best thing for all cases.
 (2) For horizontal subpixel splitting, the input rgb image
 is rescaled by %scaley vertically and by 3.0 times
 %scalex horizontally.  Then for each horizontal triplet
 of pixels, the r component of the final pixel is selected
 from the r component of the appropriate pixel in the triplet,
 and likewise for g and b.  Vertical subpixel splitting is
 handled similarly.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp or colormapped</param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<param name="order">of subpixel rgb color components in composition of pixd L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR, L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_setNeutralBoostVal(System.Int32)">
	<summary>
 Notes
 (1) This raises or lowers the selected min or max RGB component value,
 depending on if that component is above or below this value.
 </summary>
	<remarks>
	</remarks>
	<param name="val">between 1 and 255; typical value is 180</param>
</member><member name="M:LeptonicaSharp.Natives.pixConnCompTransform(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) pixd is 8, 16 or 32 bpp, and the pixel values label the
 fg component, starting with 1.  Pixels in the bg are labelled 0.
 (2) If %depth = 0, the depth of pixd is 8 if the number of c.c.
 is less than 254, 16 if the number of c.c is less than 0xfffe,
 and 32 otherwise.
 (3) If %depth = 8, the assigned label for the n-th component is
 1 + n % 254.  We use mod 254 because 0 is uniquely assigned
 to black e.g., see pixcmapCreateRandom().  Likewise,
 if %depth = 16, the assigned label uses mod(2^16 - 2), and
 if %depth = 32, no mod is taken.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connect">connectivity 4 or 8</param>
	<param name="depth">of pixd 8 or 16 bpp; use 0 for auto determination</param>
	<returns>pixd 8, 16 or 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConnCompAreaTransform(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The pixel values in pixd label the area of the fg component
 to which the pixel belongs.  Pixels in the bg are labelled 0.
 (2) For purposes of visualization, the output can be converted
 to 8 bpp, using pixConvert32To8() or pixMaxDynamicRange().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connect">connectivity 4 or 8</param>
	<returns>pixd 32 bpp, 1 spp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConnCompIncrInit(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@,System.Int32@)">
	<summary>
 Notes
 (1) This labels the connected components in a 1 bpp pix, and
 additionally sets up a ptaa that lists the locations of pixels
 in each of the components.
 (2) It can be used to initialize the output image and arrays for
 an application that maintains information about connected
 components incrementally as pixels are added.
 (3) pixs can be empty or have some foreground pixels.
 (4) The connectivity is stored in pixd-GTspecial.
 (5) Always initialize with the first pta in ptaa being empty
 and representing the background value (index 0) in the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="conn">connectivity 4 or 8</param>
	<param name="ppixd">32 bpp, with c.c. labelled</param>
	<param name="pptaa">with pixel locations indexed by c.c.</param>
	<param name="pncc">initial number of c.c.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixConnCompIncrAdd(System.IntPtr,System.IntPtr,System.Int32@,System.Single,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This adds a pixel and updates the labeled connected components.
 Before calling this function, initialize the process using
 pixConnCompIncrInit().
 (2) As a result of adding a pixel, one of the following can happen,
 depending on the number of neighbors with non-zero value
 (a) nothing the pixel is already a member of a c.c.
 (b) no neighbors a new component is added, increasing the
 number of c.c.
 (c) one neighbor the pixel is added to an existing c.c.
 (d) more than one neighbor the added pixel causes joining of
 two or more c.c., reducing the number of c.c.  A maximum
 of 4 c.c. can be joined.
 (3) When two c.c. are joined, the pixels in the larger index are
 relabeled to those of the smaller in pixs, and their locations
 are transferred to the pta with the smaller index in the ptaa.
 The pta corresponding to the larger index is then deleted.
 (4) This is an efficient implementation of a "union-find" operation,
 which supports the generation and merging of disjoint sets
 of pixels.  This function can be called about 1.3 million times
 per second.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, with pixels labeled by c.c.</param>
	<param name="ptaa">with each pta of pixel locations indexed by c.c.</param>
	<param name="pncc">number of c.c</param>
	<param name="x">,y location of added pixel</param>
	<param name="debug">0 for no output; otherwise output whenever debug LT= nvals, up to debug == 3</param>
	<returns>-1 if nothing happens; 0 if a pixel is added; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetSortedNeighborValues(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr@,System.Int32@)">
	<summary>
 Notes
 (1) The returned %neigh array is the unique set of neighboring
 pixel values, of size nvals, sorted from smallest to largest.
 The value 0, which represents background pixels that do
 not belong to any set of connected components, is discarded.
 (2) If there are no neighbors, this returns %neigh = NULL; otherwise,
 the caller must free the array.
 (3) For either 4 or 8 connectivity, the maximum number of unique
 neighbor values is 4.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16 or 32 bpp, with pixels labeled by c.c.</param>
	<param name="x">location of pixel</param>
	<param name="y">location of pixel</param>
	<param name="conn">4 or 8 connected neighbors</param>
	<param name="pneigh">array of integers, to be filled with the values of the neighbors, if any</param>
	<param name="pnvals">the number of unique neighbor values found</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixLocToColorTransform(System.IntPtr)">
	<summary>
 Notes
 (1) This generates an RGB image where each component value
 is coded depending on the (x.y) location and the size
 of the fg connected component that the pixel in pixs belongs to.
 It is independent of the 4-fold orthogonal orientation, and
 only weakly depends on translations and small angle rotations.
 Background pixels are black.
 (2) Such encodings can be compared between two 1 bpp images
 by performing this transform and calculating the
 "earth-mover" distance on the resulting R,G,B histograms.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixTilingCreate(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) We put a clone of pixs in the PixTiling.
 (2) The input to pixTilingCreate() for horizontal tiling can be
 either the number of tiles across the image or the approximate
 width of the tiles.  If the latter, the actual width will be
 determined by making all tiles but the last of equal width, and
 making the last as close to the others as possible.  The same
 consideration is applied independently to the vertical tiling.
 To specify tile width, set nx = 0; to specify the number of
 tiles horizontally across the image, set w = 0.
 (3) If pixs is to be tiled in one-dimensional strips, use ny = 1 for
 vertical strips and nx = 1 for horizontal strips.
 (4) The overlap must not be larger than the width or height of
 the leftmost or topmost tile(s).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">pix to be tiled; any depth; colormap OK</param>
	<param name="nx">number of tiles across image</param>
	<param name="ny">number of tiles down image</param>
	<param name="w">desired width of each tile</param>
	<param name="h">desired height of each tile</param>
	<param name="xoverlap">overlap into neighboring tiles on each side</param>
	<param name="yoverlap">overlap into neighboring tiles above and below</param>
	<returns>pixtiling, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixTilingDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ppt">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp.Natives.pixTilingGetCount(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pt">pixtiling</param>
	<param name="pnx">nx; can be null</param>
	<param name="pny">ny; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixTilingGetSize(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pt">pixtiling</param>
	<param name="pw">tile width; can be null</param>
	<param name="ph">tile height; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixTilingGetTile(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pt">pixtiling</param>
	<param name="i">tile row index</param>
	<param name="j">tile column index</param>
	<returns>pixd tile with appropriate boundary (overlap) pixels added, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixTilingNoStripOnPaint(System.IntPtr)">
	<summary>
 Notes
 (1) The default for paint is to strip out the overlap pixels
 that are added by pixTilingGetTile().  However, some
 operations will generate an image with these pixels
 stripped off.  This tells the paint operation not
 to strip the added boundary pixels when painting.
 </summary>
	<remarks>
	</remarks>
	<param name="pt">pixtiling</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixTilingPaintTile(System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd">dest paint tile onto this, without overlap</param>
	<param name="i">tile row index</param>
	<param name="j">tile column index</param>
	<param name="pixs">source tile to be painted from</param>
	<param name="pt">pixtiling struct</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadStreamPng(System.IntPtr)">
	<summary>
 Notes
 (1) If called from pixReadStream(), the stream is positioned
 at the beginning of the file.
 (2) To do sequential reads of png format images from a stream,
 use pixReadStreamPng()
 (3) Any image with alpha is converted to RGBA (spp = 4, with
 equal red, green and blue channels) on reading.
 There are three important cases with alpha
 (a) grayscale-with-alpha (spp = 2), where bpp = 8, and each
 pixel has an associated alpha (transparency) value
 in the second component of the image data.
 (b) spp = 1, d = 1 with colormap and alpha in the trans array.
 Transparency is usually associated with the white background.
 (c) spp = 1, d = 8 with colormap and alpha in the trans array.
 Each color in the colormap has a separate transparency value.
 (4) We use the high level png interface, where the transforms are set
 up in advance and the header and image are read with a single
 call.  The more complicated interface, where the header is
 read first and the buffers for the raster image are user-
 allocated before reading the image, works for single images,
 but I could not get it to work properly for the successive
 png reads that are required by pixaReadStream().
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.readHeaderPng(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If there is a colormap, iscmap is returned as 1; else 0.
 (2) For gray+alpha, although the png records bps = 16, we
 consider this as two 8 bpp samples (gray and alpha).
 When a gray+alpha is read, it is converted to 32 bpp RGBA.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<param name="piscmap"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.freadHeaderPng(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) See readHeaderPng().  We only need the first 40 bytes in the file.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<param name="piscmap"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.readHeaderMemPng(System.Byte[],System.UInt32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) See readHeaderPng().
 (2) png colortypes (see png.h PNG_COLOR_TYPE_)
 0  gray; fully transparent (with tRNS) (1 spp)
 2  RGB (3 spp)
 3  colormap; colormap+alpha (with tRNS) (1 spp)
 4  gray + alpha (2 spp)
 6  RGBA (4 spp)
 Note
 0 and 3 have the alpha information in a tRNS chunk
 4 and 6 have separate alpha samples with each pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="data"></param>
	<param name="size">40 bytes is sufficient</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<param name="piscmap">input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fgetPngResolution(System.IntPtr,System.Object,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.isPngInterlaced(System.String,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pinterlaced">1 if interlaced png; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fgetPngColormapInfo(System.IntPtr,System.IntPtr,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixWritePng(System.String,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) Special version for writing png with a specified gamma.
 When using pixWrite(), no field is given for gamma.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pix"></param>
	<param name="gamma"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamPng(System.IntPtr,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) If called from pixWriteStream(), the stream is positioned
 at the beginning of the file.
 (2) To do sequential writes of png format images to a stream,
 use pixWriteStreamPng() directly.
 (3) gamma is an optional png chunk.  If no gamma value is to be
 placed into the file, use gamma = 0.0.  Otherwise, if
 gamma GT 0.0, its value is written into the header.
 (4) The use of gamma in png is highly problematic.  For an illuminating
 discussion, see  http//hsivonen.iki.fi/png-gamma/
 (5) What is the effect/meaning of gamma in the png file?  This
 gamma, which we can call the 'source' gamma, is the
 inverse of the gamma that was used in enhance.c to brighten
 or darken images.  The 'source' gamma is supposed to indicate
 the intensity mapping that was done at the time the
 image was captured.  Display programs typically apply a
 'display' gamma of 2.2 to the output, which is intended
 to linearize the intensity based on the response of
 thermionic tubes (CRTs).  Flat panel LCDs have typically
 been designed to give a similar response as CRTs (call it
 "backward compatibility").  The 'display' gamma is
 in some sense the inverse of the 'source' gamma.
 jpeg encoders attached to scanners and cameras will lighten
 the pixels, applying a gamma corresponding to approximately
 a square-root relation of output vs input
 output = input^(gamma)
 where gamma is often set near 0.4545  (1/gamma is 2.2).
 This is stored in the image file.  Then if the display
 program reads the gamma, it will apply a display gamma,
 typically about 2.2; the product is 1.0, and the
 display program produces a linear output.  This works because
 the dark colors were appropriately boosted by the scanner,
 as described by the 'source' gamma, so they should not
 be further boosted by the display program.
 (6) As an example, with xv and display, if no gamma is stored,
 the program acts as if gamma were 0.4545, multiplies this by 2.2,
 and does a linear rendering.  Taking this as a baseline
 brightness, if the stored gamma is
 GT 0.4545, the image is rendered lighter than baseline
 LT 0.4545, the image is rendered darker than baseline
 In contrast, gqview seems to ignore the gamma chunk in png.
 (7) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16
 and 32.  However, it is possible, and in some cases desirable,
 to write out a png file using an rgb pix that has 24 bpp.
 For example, the open source xpdf SplashBitmap class generates
 24 bpp rgb images.  Consequently, we enable writing 24 bpp pix.
 To generate such a pix, you can make a 24 bpp pix without data
 and assign the data array to the pix; e.g.,
 pix = pixCreateHeader(w, h, 24);
 pixSetData(pix, rgbdata);
 See pixConvert32To24() for an example, where we get rgbdata
 from the 32 bpp pix.  Caution do not call pixSetPadBits(),
 because the alignment is wrong and you may erase part of the
 last pixel on each line.
 (8) If the pix has a colormap, it is written to file.  In most
 situations, the alpha component is 255 for each colormap entry,
 which is opaque and indicates that it should be ignored.
 However, if any alpha component is not 255, it is assumed that
 the alpha values are valid, and they are written to the png
 file in a tRNS segment.  On readback, the tRNS segment is
 identified, and the colormapped image with alpha is converted
 to a 4 spp rgba image.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix"></param>
	<param name="gamma">use 0.0 if gamma is not defined</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetZlibCompression(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Valid zlib compression values are in the interval [0 ... 9],
 where, as defined in zlib.h
 0   Z_NO_COMPRESSION
 1   Z_BEST_SPEED (poorest compression)
 9   Z_BEST_COMPRESSION
 For the default value, use either of these
 6   Z_DEFAULT_COMPRESSION
 -1   (resolves to Z_DEFAULT_COMPRESSION)
 (2) If you use the defined constants in zlib.h instead of the
 compression integers given above, you must include zlib.h.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="compval">zlib compression value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_pngSetReadStrip16To8(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="flag">1 for stripping 16 bpp to 8 bpp on reading; 0 for leaving 16 bpp</param>
</member><member name="M:LeptonicaSharp.Natives.pixReadMemPng(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) See pixReastreamPng().
 </summary>
	<remarks>
	</remarks>
	<param name="filedata">png compressed data in memory</param>
	<param name="filesize">number of bytes in data</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMemPng(System.IntPtr@,System.UInt32@,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) See pixWriteStreamPng()
 </summary>
	<remarks>
	</remarks>
	<param name="pfiledata">png encoded data of pix</param>
	<param name="pfilesize">size of png encoded data</param>
	<param name="pix"></param>
	<param name="gamma">use 0.0 if gamma is not defined</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadStreamPnm(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for read</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.readHeaderPnm(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pd"></param>
	<param name="ptype">pnm type</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.freadHeaderPnm(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for read</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pd"></param>
	<param name="ptype">pnm type</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamPnm(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This writes "raw" packed format only
 1 bpp --GT pbm (P4)
 2, 4, 8, 16 bpp, no colormap or grayscale colormap --GT pgm (P5)
 2, 4, 8 bpp with color-valued colormap, or rgb --GT rgb ppm (P6)
 (2) 24 bpp rgb are not supported in leptonica, but this will
 write them out as a packed array of bytes (3 to a pixel).
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for write</param>
	<param name="pix"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamAsciiPnm(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for write</param>
	<param name="pix"></param>
	<returns>0 if OK; 1 on error Writes "ASCII" format only 1 bpp --GT pbm P1 2, 4, 8, 16 bpp, no colormap or grayscale colormap --GT pgm P2 2, 4, 8 bpp with color-valued colormap, or rgb --GT rgb ppm P3</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamPam(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This writes arbitrary PAM (P7) packed format.
 (2) 24 bpp rgb are not supported in leptonica, but this will
 write them out as a packed array of bytes (3 to a pixel).
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for write</param>
	<param name="pix"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadMemPnm(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) The %size byte of %data must be a null character.
 </summary>
	<remarks>
	</remarks>
	<param name="data">const; pnm-encoded</param>
	<param name="size">of data</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.readHeaderMemPnm(System.Byte[],System.UInt32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">const; pnm-encoded</param>
	<param name="size">of data</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pd"></param>
	<param name="ptype">pnm type</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMemPnm(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) See pixWriteStreamPnm() for usage.  This version writes to
 memory instead of to a file stream.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of PNM image</param>
	<param name="psize">size of returned data</param>
	<param name="pix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMemPam(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) See pixWriteStreamPnm() for usage.  This version writes to
 memory instead of to a file stream.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of PAM image</param>
	<param name="psize">size of returned data</param>
	<param name="pix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixProjectiveSampledPta(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary.
 (2) Retains colormap, which you can do for a sampled transform..
 (3) No 3 of the 4 points may be collinear.
 (4) For 8 and 32 bpp pix, better quality is obtained by the
 somewhat slower pixProjectivePta().  See that
 function for relative timings between sampled and interpolated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixProjectiveSampled(System.IntPtr,System.Single[],System.Int32)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary.
 (2) Retains colormap, which you can do for a sampled transform..
 (3) For 8 or 32 bpp, much better quality is obtained by the
 somewhat slower pixProjective().  See that function
 for relative timings between sampled and interpolated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="vc">vector of 8 coefficients for projective transformation</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixProjectivePta(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary
 (2) Removes any existing colormap, if necessary, before transforming
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixProjective(System.IntPtr,System.Single[],System.Int32)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary
 (2) Removes any existing colormap, if necessary, before transforming
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="vc">vector of 8 coefficients for projective transformation</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixProjectivePtaColor(System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixProjectiveColor(System.IntPtr,System.Single[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="vc">vector of 8 coefficients for projective transformation</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixProjectivePtaGray(System.IntPtr,System.IntPtr,System.IntPtr,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixProjectiveGray(System.IntPtr,System.Single[],System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="vc">vector of 8 coefficients for projective transformation</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixProjectivePtaWithAlpha(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) The alpha channel is transformed separately from pixs,
 and aligns with it, being fully transparent outside the
 boundary of the transformed pixs.  For pixels that are fully
 transparent, a blending function like pixBlendWithGrayMask()
 will give zero weight to corresponding pixels in pixs.
 (2) If pixg is NULL, it is generated as an alpha layer that is
 partially opaque, using %fract.  Otherwise, it is cropped
 to pixs if required and %fract is ignored.  The alpha channel
 in pixs is never used.
 (3) Colormaps are removed.
 (4) When pixs is transformed, it doesn't matter what color is brought
 in because the alpha channel will be transparent (0) there.
 (5) To avoid losing source pixels in the destination, it may be
 necessary to add a border to the source pix before doing
 the projective transformation.  This can be any non-negative
 number.
 (6) The input %ptad and %ptas are in a coordinate space before
 the border is added.  Internally, we compensate for this
 before doing the projective transform on the image after
 the border is added.
 (7) The default setting for the border values in the alpha channel
 is 0 (transparent) for the outermost ring of pixels and
 (0.5  fract  255) for the second ring.  When blended over
 a second image, this
 (a) shrinks the visible image to make a clean overlap edge
 with an image below, and
 (b) softens the edges by weakening the aliasing there.
 Use l_setAlphaMaskBorder() to change these values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="pixg">8 bpp, for alpha channel, can be null</param>
	<param name="fract">between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	<param name="border">of pixels added to capture transformed source pixels</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getProjectiveXformCoeffs(System.IntPtr,System.IntPtr,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas">source 4 points; unprimed</param>
	<param name="ptad">transformed 4 points; primed</param>
	<param name="pvc">vector of coefficients of transform</param>
	<returns>0 if OK; 1 on error We have a set of 8 equations, describing the projective transformation that takes 4 points ptas into 4 other points ptad.  These equations are x1' = c[0]x1 + c[1]y1 + c[2]) / (c[6]x1 + c[7]y1 + 1 y1' = c[3]x1 + c[4]y1 + c[5]) / (c[6]x1 + c[7]y1 + 1 x2' = c[0]x2 + c[1]y2 + c[2]) / (c[6]x2 + c[7]y2 + 1 y2' = c[3]x2 + c[4]y2 + c[5]) / (c[6]x2 + c[7]y2 + 1 x3' = c[0]x3 + c[1]y3 + c[2]) / (c[6]x3 + c[7]y3 + 1 y3' = c[3]x3 + c[4]y3 + c[5]) / (c[6]x3 + c[7]y3 + 1 x4' = c[0]x4 + c[1]y4 + c[2]) / (c[6]x4 + c[7]y4 + 1 y4' = c[3]x4 + c[4]y4 + c[5]) / (c[6]x4 + c[7]y4 + 1 Multiplying both sides of each eqn by the denominator, we get AC = B where B and C are column vectors B = [ x1' y1' x2' y2' x3' y3' x4' y4' ] C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] c[7] ] and A is the 8x8 matrix x1   y1     1     0   0    0   -x1x1'  -y1x1' 0    0     0    x1   y1   1   -x1y1'  -y1y1' x2   y2     1     0   0    0   -x2x2'  -y2x2' 0    0     0    x2   y2   1   -x2y2'  -y2y2' x3   y3     1     0   0    0   -x3x3'  -y3x3' 0    0     0    x3   y3   1   -x3y3'  -y3y3' x4   y4     1     0   0    0   -x4x4'  -y4x4' 0    0     0    x4   y4   1   -x4y4'  -y4y4' These eight equations are solved here for the coefficients C. These eight coefficients can then be used to find the mapping x,y) --GT (x',y' x' = c[0]x + c[1]y + c[2]) / (c[6]x + c[7]y + 1 y' = c[3]x + c[4]y + c[5]) / (c[6]x + c[7]y + 1 that is implemented in projectiveXformSampled and projectiveXFormInterpolated.</returns>
</member><member name="M:LeptonicaSharp.Natives.projectiveXformSampledPt(System.Single[],System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This finds the nearest pixel coordinates of the transformed point.
 (2) It does not check ptrs for returned data!
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 8 coefficients</param>
	<param name="x">initial point</param>
	<param name="y">initial point</param>
	<param name="pxp">transformed point</param>
	<param name="pyp">transformed point</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.projectiveXformPt(System.Single[],System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This computes the floating point location of the transformed point.
 (2) It does not check ptrs for returned data!
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 8 coefficients</param>
	<param name="x">initial point</param>
	<param name="y">initial point</param>
	<param name="pxp">transformed point</param>
	<param name="pyp">transformed point</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertFilesToPS(System.String,System.String,System.Int32,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayConvertFilesToPS(System.IntPtr,System.Int32,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.convertFilesFittedToPS(System.String,System.String,System.Single,System.Single,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayConvertFilesFittedToPS(System.IntPtr,System.Single,System.Single,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.writeImageCompressedToPSFile(System.String,System.String,System.Int32,System.Object,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.convertSegmentedPagesToPS(System.String,System.String,System.Int32,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteSegmentedPageToPS(System.IntPtr,System.IntPtr,System.Single,System.Single,System.Int32,System.Int32,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMixedToPS(System.IntPtr,System.IntPtr,System.Single,System.Int32,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.convertToPSEmbed(System.String,System.String,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixaWriteCompressedToPS(System.IntPtr,System.String,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixWritePSEmbed(System.String,System.String)">
	<summary>
 Notes
 (1) This is a simple wrapper function that generates an
 uncompressed PS file, with a bounding box.
 (2) The bounding box is required when a program such as TeX
 (through epsf) places and rescales the image.
 (3) The bounding box is sized for fitting the image to an
 8.5 x 11.0 inch page.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input file, all depths, colormap OK</param>
	<param name="fileout">output ps file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamPS(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This writes image in PS format, optionally scaled,
 adjusted for the printer resolution, and with
 a bounding box.
 (2) For details on use of parameters, see pixWriteStringPS().
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix"></param>
	<param name="box"></param>
	<param name="res">can use 0 for default of 300 ppi</param>
	<param name="scale">to prevent scaling, use either 1.0 or 0.0</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStringPS(System.IntPtr,System.IntPtr,System.Int32,System.Single)">
	<summary>
 a) If %box == NULL, image is placed, optionally scaled,
 in a standard b.b. at the center of the page.
 This is to be used when another program like
 TeX through epsf places the image.
 b) If %box != NULL, image is placed without a
 b.b. at the specified page location and with
 optional scaling.  This is to be used when
 you want to specify exactly where and optionally
 how big you want the image to be.
 Note that all coordinates are in PS convention,
 with 0,0 at LL corner of the page
 x,y location of LL corner of image, in mils.
 w,h scaled size, in mils.  Use 0 to
 scale with "scale" and "res" input.
 %scale If no scaling is desired, use either 1.0 or 0.0.
 Scaling just resets the resolution parameter; the actual
 scaling is done in the interpreter at rendering time.
 This is important  it allows you to scale the image up
 without increasing the file size.
 Notes
 (1) OK, this seems a bit complicated, because there are various
 ways to scale and not to scale.  Here's a summary
 (2) If you don't want any scaling at all
 if you are using a box
 set w = 0, h = 0, and use scale = 1.0; it will print
 each pixel unscaled at printer resolution
 if you are not using a box
 set scale = 1.0; it will print at printer resolution
 (3) If you want the image to be a certain size in inches
 you must use a box and set the box (w,h) in mils
 (4) If you want the image to be scaled by a scale factor != 1.0
 if you are using a box
 set w = 0, h = 0, and use the desired scale factor;
 the higher the printer resolution, the smaller the
 image will actually appear.
 if you are not using a box
 set the desired scale factor; the higher the printer
 resolution, the smaller the image will actually appear.
 (5) Another complication is the proliferation of distance units
 The interface distances are in milli-inches.
 Three different units are used internally
 ~ pixels  (units of 1/res inch)
 ~ printer pts (units of 1/72 inch)
 ~ inches
 Here is a quiz on volume units from a reviewer
 How many UK milli-cups in a US kilo-teaspoon?
 (Hint 1.0 US cup = 0.75 UK cup + 0.2 US gill;
 1.0 US gill = 24.0 US teaspoons)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths, colormap OK</param>
	<param name="box">bounding box; can be NULL</param>
	<param name="res">resolution, in printer ppi.  Use 0 for default 300 ppi.</param>
	<param name="scale">scale factor.  If no scaling is desired, use either 1.0 or 0.0.   Scaling just resets the resolution parameter; the actual scaling is done in the interpreter at rendering time.  This is important it allows you to scale the image up without increasing the file size.</param>
	<returns>ps string if OK, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generateUncompressedPS(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Int32)">
	<summary>
 Notes
 (1) Low-level function.
 </summary>
	<remarks>
	</remarks>
	<param name="hexdata"></param>
	<param name="w">raster image size in pixels</param>
	<param name="h">raster image size in pixels</param>
	<param name="d">image depth in bpp; rgb is 32</param>
	<param name="psbpl">raster bytes/line, when packed to the byte boundary</param>
	<param name="bps">bits/sample either 1 or 8</param>
	<param name="xpt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="ypt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="wpt">rendered image size in pts</param>
	<param name="hpt">rendered image size in pts</param>
	<param name="boxflag">1 to print out bounding box hint; 0 to skip</param>
	<returns>PS string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getScaledParametersPS(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) The image is always scaled, depending on res and scale.
 (2) If no box, the image is centered on the page.
 (3) If there is a box, the image is placed within it.
 </summary>
	<remarks>
	</remarks>
	<param name="box">location of image in mils; with x,y being the LL corner</param>
	<param name="wpix">pix width in pixels</param>
	<param name="hpix">pix height in pixels</param>
	<param name="res">of printer; use 0 for default</param>
	<param name="scale">use 1.0 or 0.0 for no scaling</param>
	<param name="pxpt">location of llx in pts</param>
	<param name="pypt">location of lly in pts</param>
	<param name="pwpt">image width in pts</param>
	<param name="phpt">image height in pts</param>
</member><member name="M:LeptonicaSharp.Natives.convertByteToHexAscii(System.Byte,System.String@,System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="byteval">input byte</param>
	<param name="pnib1">two hex ascii characters</param>
	<param name="pnib2">two hex ascii characters</param>
</member><member name="M:LeptonicaSharp.Natives.convertJpegToPSEmbed(System.String,System.String)">
	<summary>
 Notes
 (1) This function takes a jpeg file as input and generates a DCT
 compressed, ascii85 encoded PS file, with a bounding box.
 (2) The bounding box is required when a program such as TeX
 (through epsf) places and rescales the image.
 (3) The bounding box is sized for fitting the image to an
 8.5 x 11.0 inch page.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input jpeg file</param>
	<param name="fileout">output ps file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertJpegToPS(System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is simpler to use than pixWriteStringPS(), and
 it outputs in level 2 PS as compressed DCT (overlaid
 with ascii85 encoding).
 (2) An output file can contain multiple pages, each with
 multiple images.  The arguments to convertJpegToPS()
 allow you to control placement of jpeg images on multiple
 pages within a PostScript file.
 (3) For the first image written to a file, use "w", which
 opens for write and clears the file.  For all subsequent
 images written to that file, use "a".
 (4) The (x, y) parameters give the LL corner of the image
 relative to the LL corner of the page.  They are in
 units of pixels if scale = 1.0.  If you use (e.g.)
 scale = 2.0, the image is placed at (2x, 2y) on the page,
 and the image dimensions are also doubled.
 (5) Display vs printed resolution
 If your display is 75 ppi and your image was created
 at a resolution of 300 ppi, you can get the image
 to print at the same size as it appears on your display
 by either setting scale = 4.0 or by setting  res = 75.
 Both tell the printer to make a 4x enlarged image.
 If your image is generated at 150 ppi and you use scale = 1,
 it will be rendered such that 150 pixels correspond
 to 72 pts (1 inch on the printer).  This function does
 the conversion from pixels (with or without scaling) to
 pts, which are the units that the printer uses.
 The printer will choose its own resolution to use
 in rendering the image, which will not affect the size
 of the rendered image.  That is because the output
 PostScript file describes the geometry in terms of pts,
 which are defined to be 1/72 inch.  The printer will
 only see the size of the image in pts, through the
 scale and translate parameters and the affine
 transform (the ImageMatrix) of the image.
 (6) To render multiple images on the same page, set
 endpage = FALSE for each image until you get to the
 last, for which you set endpage = TRUE.  This causes the
 "showpage" command to be invoked.  Showpage outputs
 the entire page and clears the raster buffer for the
 next page to be added.  Without a "showpage",
 subsequent images from the next page will overlay those
 previously put down.
 (7) For multiple pages, increment the page number, starting
 with page 1.  This allows PostScript (and PDF) to build
 a page directory, which viewers use for navigation.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input jpeg file</param>
	<param name="fileout">output ps file</param>
	<param name="operation">"w" for write; "a" for append</param>
	<param name="x">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="y">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="res">resolution of the input image, in ppi; use 0 for default</param>
	<param name="scale">scaling by printer; use 0.0 or 1.0 for no scaling</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertJpegToPSString(System.String,System.IntPtr@,System.Int32@,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For usage, see convertJpegToPS()
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input jpeg file</param>
	<param name="poutstr">PS string</param>
	<param name="pnbytes">number of bytes in PS string</param>
	<param name="x">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="y">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="res">resolution of the input image, in ppi; use 0 for default</param>
	<param name="scale">scaling by printer; use 0.0 or 1.0 for no scaling</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generateJpegPS(System.String,System.IntPtr,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Low-level function.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input jpeg filename; can be null</param>
	<param name="cid">jpeg compressed image data</param>
	<param name="xpt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="ypt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="wpt">rendered image size in pts</param>
	<param name="hpt">rendered image size in pts</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page.</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>PS string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertG4ToPSEmbed(System.String,System.String)">
	<summary>
 Notes
 (1) This function takes a g4 compressed tif file as input and
 generates a g4 compressed, ascii85 encoded PS file, with
 a bounding box.
 (2) The bounding box is required when a program such as TeX
 (through epsf) places and rescales the image.
 (3) The bounding box is sized for fitting the image to an
 8.5 x 11.0 inch page.
 (4) We paint this through a mask, over whatever is below.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input tiff file</param>
	<param name="fileout">output ps file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertG4ToPS(System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See the usage comments in convertJpegToPS(), some of
 which are repeated here.
 (2) This is a wrapper for tiff g4.  The PostScript that
 is generated is expanded by about 5/4 (due to the
 ascii85 encoding.  If you convert to pdf (ps2pdf), the
 ascii85 decoder is automatically invoked, so that the
 pdf wrapped g4 file is essentially the same size as
 the original g4 file.  It's useful to have the PS
 file ascii85 encoded, because many printers will not
 print binary PS files.
 (3) For the first image written to a file, use "w", which
 opens for write and clears the file.  For all subsequent
 images written to that file, use "a".
 (4) To render multiple images on the same page, set
 endpage = FALSE for each image until you get to the
 last, for which you set endpage = TRUE.  This causes the
 "showpage" command to be invoked.  Showpage outputs
 the entire page and clears the raster buffer for the
 next page to be added.  Without a "showpage",
 subsequent images from the next page will overlay those
 previously put down.
 (5) For multiple images to the same page, where you are writing
 both jpeg and tiff-g4, you have two options
 (a) write the g4 first, as either image (maskflag == FALSE)
 or imagemask (maskflag == TRUE), and then write the
 jpeg over it.
 (b) write the jpeg first and as the last item, write
 the g4 as an imagemask (maskflag == TRUE), to paint
 through the foreground only.
 We have this flexibility with the tiff-g4 because it is 1 bpp.
 (6) For multiple pages, increment the page number, starting
 with page 1.  This allows PostScript (and PDF) to build
 a page directory, which viewers use for navigation.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input tiff g4 file</param>
	<param name="fileout">output ps file</param>
	<param name="operation">"w" for write; "a" for append</param>
	<param name="x">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="y">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="res">resolution of the input image, in ppi; typ. values are 300 and 600; use 0 for automatic determination based on image size</param>
	<param name="scale">scaling by printer; use 0.0 or 1.0 for no scaling</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page.</param>
	<param name="maskflag">boolean use TRUE if just painting through fg; FALSE if painting both fg and bg.</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertG4ToPSString(System.String,System.IntPtr@,System.Int32@,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Generates PS string in G4 compressed tiff format from G4 tiff file.
 (2) For usage, see convertG4ToPS().
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input tiff g4 file</param>
	<param name="poutstr">PS string</param>
	<param name="pnbytes">number of bytes in PS string</param>
	<param name="x">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="y">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="res">resolution of the input image, in ppi; typ. values are 300 and 600; use 0 for automatic determination based on image size</param>
	<param name="scale">scaling by printer; use 0.0 or 1.0 for no scaling</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page.</param>
	<param name="maskflag">boolean use TRUE if just painting through fg; FALSE if painting both fg and bg.</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generateG4PS(System.String,System.IntPtr,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Low-level function.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input tiff g4 file; can be null</param>
	<param name="cid">g4 compressed image data</param>
	<param name="xpt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="ypt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="wpt">rendered image size in pts</param>
	<param name="hpt">rendered image size in pts</param>
	<param name="maskflag">boolean use TRUE if just painting through fg; FALSE if painting both fg and bg.</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page.</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>PS string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertTiffMultipageToPS(System.String,System.String,System.Single)">
	<summary>
 Notes
 (1) This converts a multipage tiff file of binary page images
 into a ccitt g4 compressed PS file.
 (2) If the images are generated from a standard resolution fax,
 the vertical resolution is doubled to give a normal-looking
 aspect ratio.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input tiff multipage file</param>
	<param name="fileout">output ps file</param>
	<param name="fillfract">factor for filling 8.5 x 11 inch page; use 0.0 for DEFAULT_FILL_FRACTION</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertFlateToPSEmbed(System.String,System.String)">
	<summary>
 Notes
 (1) This function takes any image file as input and generates a
 flate-compressed, ascii85 encoded PS file, with a bounding box.
 (2) The bounding box is required when a program such as TeX
 (through epsf) places and rescales the image.
 (3) The bounding box is sized for fitting the image to an
 8.5 x 11.0 inch page.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input file -- any format</param>
	<param name="fileout">output ps file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertFlateToPS(System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This outputs level 3 PS as flate compressed (overlaid
 with ascii85 encoding).
 (2) An output file can contain multiple pages, each with
 multiple images.  The arguments to convertFlateToPS()
 allow you to control placement of png images on multiple
 pages within a PostScript file.
 (3) For the first image written to a file, use "w", which
 opens for write and clears the file.  For all subsequent
 images written to that file, use "a".
 (4) The (x, y) parameters give the LL corner of the image
 relative to the LL corner of the page.  They are in
 units of pixels if scale = 1.0.  If you use (e.g.)
 scale = 2.0, the image is placed at (2x, 2y) on the page,
 and the image dimensions are also doubled.
 (5) Display vs printed resolution
 If your display is 75 ppi and your image was created
 at a resolution of 300 ppi, you can get the image
 to print at the same size as it appears on your display
 by either setting scale = 4.0 or by setting  res = 75.
 Both tell the printer to make a 4x enlarged image.
 If your image is generated at 150 ppi and you use scale = 1,
 it will be rendered such that 150 pixels correspond
 to 72 pts (1 inch on the printer).  This function does
 the conversion from pixels (with or without scaling) to
 pts, which are the units that the printer uses.
 The printer will choose its own resolution to use
 in rendering the image, which will not affect the size
 of the rendered image.  That is because the output
 PostScript file describes the geometry in terms of pts,
 which are defined to be 1/72 inch.  The printer will
 only see the size of the image in pts, through the
 scale and translate parameters and the affine
 transform (the ImageMatrix) of the image.
 (6) To render multiple images on the same page, set
 endpage = FALSE for each image until you get to the
 last, for which you set endpage = TRUE.  This causes the
 "showpage" command to be invoked.  Showpage outputs
 the entire page and clears the raster buffer for the
 next page to be added.  Without a "showpage",
 subsequent images from the next page will overlay those
 previously put down.
 (7) For multiple pages, increment the page number, starting
 with page 1.  This allows PostScript (and PDF) to build
 a page directory, which viewers use for navigation.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input file -- any format</param>
	<param name="fileout">output ps file</param>
	<param name="operation">"w" for write; "a" for append</param>
	<param name="x">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="y">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="res">resolution of the input image, in ppi; use 0 for default</param>
	<param name="scale">scaling by printer; use 0.0 or 1.0 for no scaling</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page.</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertFlateToPSString(System.String,System.IntPtr@,System.Int32@,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The returned PS character array is a null-terminated
 ascii string.  All the raster data is ascii85 encoded, so
 there are no null bytes embedded in it.
 (2) The raster encoding is made with gzip, the same as that
 in a png file that is compressed without prediction.
 The raster data itself is 25% larger than that in the
 binary form, due to the ascii85 encoding.
 Usage  See convertFlateToPS()
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input image file</param>
	<param name="poutstr">PS string</param>
	<param name="pnbytes">number of bytes in PS string</param>
	<param name="x">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="y">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="res">resolution of the input image, in ppi; use 0 for default</param>
	<param name="scale">scaling by printer; use 0.0 or 1.0 for no scaling</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page.</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.generateFlatePS(System.String,System.IntPtr,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filein">input filename; can be null</param>
	<param name="cid">flate compressed image data</param>
	<param name="xpt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="ypt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="wpt">rendered image size in pts</param>
	<param name="hpt">rendered image size in pts</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>PS string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMemPS(System.IntPtr@,System.UInt32@,System.IntPtr,System.IntPtr,System.Int32,System.Single)">
	<summary>
 Notes
 (1) See pixWriteStringPS() for usage.
 (2) This is just a wrapper for pixWriteStringPS(), which
 writes uncompressed image data to memory.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of tiff compressed image</param>
	<param name="psize">size of returned data</param>
	<param name="pix"></param>
	<param name="box"></param>
	<param name="res">can use 0 for default of 300 ppi</param>
	<param name="scale">to prevent scaling, use either 1.0 or 0.0</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getResLetterPage(System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="w">image width, pixels</param>
	<param name="h">image height, pixels</param>
	<param name="fillfract">fraction in linear dimension of full page, not to be exceeded; use 0 for default</param>
	<returns>resolution</returns>
</member><member name="M:LeptonicaSharp.Natives.getResA4Page(System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="w">image width, pixels</param>
	<param name="h">image height, pixels</param>
	<param name="fillfract">fraction in linear dimension of full page, not to be exceeded; use 0 for default</param>
	<returns>resolution</returns>
</member><member name="M:LeptonicaSharp.Natives.l_psWriteBoundingBox(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.ptaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">initial array sizes</param>
	<returns>pta, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaCreateFromNuma(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nax">can be null</param>
	<param name="nay"></param>
	<returns>pta, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the pta.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppta">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.ptaCopy(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>copy of pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaCopyRange(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="istart">starting index in ptas</param>
	<param name="iend">ending index in ptas; use 0 to copy to end</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaClone(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>ptr to same pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaEmpty(System.IntPtr)">
	<summary>
 Notes
 This only resets the Ptan field, for reuse
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaAddPt(System.IntPtr,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="x"></param>
	<param name="y"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaInsertPt(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="index">at which pt is to be inserted</param>
	<param name="x">point values</param>
	<param name="y">point values</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaRemovePt(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This shifts pta[i] --GT pta[i - 1] for all i GT index.
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="index">of point to be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetRefcount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.ptaChangeRefcount(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>count, or 0 if no pta</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetPt(System.IntPtr,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="index">into arrays</param>
	<param name="px">float x value</param>
	<param name="py">float y value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetIPt(System.IntPtr,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="index">into arrays</param>
	<param name="px">integer x value</param>
	<param name="py">integer y value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaSetPt(System.IntPtr,System.Int32,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="index">into arrays</param>
	<param name="x"></param>
	<param name="y"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetArrays(System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This copies the internal arrays into new Numas.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pnax">numa of x array</param>
	<param name="pnay">numa of y array</param>
	<returns>0 if OK; 1 on error or if pta is empty</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization in ascii</param>
	<param name="size">of data in bytes; can use strlen to get it</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaWriteDebug(System.String,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Debug version, intended for use in the library when writing
 to files in a temp directory with names that are compiled in.
 This is used instead of ptaWrite() for all such library calls.
 (2) The global variable LeptDebugOK defaults to 0, and can be set
 or cleared by the function setLeptDebugOK().
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pta"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaWrite(System.String,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pta"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaWriteStream(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pta"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Serializes a pta in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized pta; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="pta"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">initial number of ptrs</param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pptaa">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.ptaaAddPta(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<param name="pta">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<returns>count, or 0 if no ptaa</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaGetPta(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<param name="index">to the i-th pta</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaGetPt(System.IntPtr,System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<param name="ipta">to the i-th pta</param>
	<param name="jpt">index to the j-th pt in the pta</param>
	<param name="px">float x value</param>
	<param name="py">float y value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaInitFull(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaa">can have non-null ptrs in the ptr array</param>
	<param name="pta">to be replicated into the entire ptr array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaReplacePta(System.IntPtr,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) Any existing pta is destroyed, and the input one
 is inserted in its place.
 (2) If the index is invalid, return 1 (error)
 </summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<param name="index">to the index-th pta</param>
	<param name="pta">insert and replace any existing one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaAddPt(System.IntPtr,System.Int32,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<param name="ipta">to the i-th pta</param>
	<param name="x">,y point coordinates</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaTruncate(System.IntPtr)">
	<summary>
 Notes
 (1) This identifies the largest index containing a pta that
 has any points within it, destroys all pta above that index,
 and resets the count.
 </summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization in ascii</param>
	<param name="size">of data in bytes; can use strlen to get it</param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaWriteDebug(System.String,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Debug version, intended for use in the library when writing
 to files in a temp directory with names that are compiled in.
 This is used instead of ptaaWrite() for all such library calls.
 (2) The global variable LeptDebugOK defaults to 0, and can be set
 or cleared by the function setLeptDebugOK().
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="ptaa"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaWrite(System.String,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="ptaa"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaWriteStream(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="ptaa"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Serializes a ptaa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized ptaa; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="ptaa"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaSubsample(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="subfactor">subsample factor, GT= 1</param>
	<returns>ptad evenly sampled pt values from ptas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaJoin(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (2) iend LT 0 means 'read to the end'
 (3) if ptas == NULL, this is a no-op
 </summary>
	<remarks>
	</remarks>
	<param name="ptad">dest pta; add to this one</param>
	<param name="ptas">source pta; add from this one</param>
	<param name="istart">starting index in ptas</param>
	<param name="iend">ending index in ptas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaJoin(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (2) iend LT 0 means 'read to the end'
 (3) if ptas == NULL, this is a no-op
 </summary>
	<remarks>
	</remarks>
	<param name="ptaad">dest ptaa; add to this one</param>
	<param name="ptaas">source ptaa; add from this one</param>
	<param name="istart">starting index in ptaas</param>
	<param name="iend">ending index in ptaas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaReverse(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>ptad reversed pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaTranspose(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<returns>ptad with x and y values swapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaCyclicPerm(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Check to insure that (a) ptas is a closed path where
 the first and last points are identical, and (b) the
 resulting pta also starts and ends on the same point
 (which in this case is (xs, ys).
 </summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="xs">start point; must be in ptas</param>
	<param name="ys">start point; must be in ptas</param>
	<returns>ptad cyclic permutation, starting and ending at (xs, ys, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaSelectRange(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="first">use 0 to select from the beginning</param>
	<param name="last">use 0 to select to the end</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetBoundingRegion(System.IntPtr)">
	<summary>
 Notes
 (1) This is used when the pta represents a set of points in
 a two-dimensional image.  It returns the box of minimum
 size containing the pts in the pta.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetRange(System.IntPtr,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) We can use pts to represent pairs of floating values, that
 are not necessarily tied to a two-dimension region.  For
 example, the pts can represent a general function y(x).
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pminx">min value of x</param>
	<param name="pmaxx">max value of x</param>
	<param name="pminy">min value of y</param>
	<param name="pmaxy">max value of y</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetInsideBox(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas">input pts</param>
	<param name="box"></param>
	<returns>ptad of pts in ptas that are inside the box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindCornerPixels(System.IntPtr)">
	<summary>
 Notes
 (1) Finds the 4 corner-most pixels, as defined by a search
 inward from each corner, using a 45 degree line.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaContainsPt(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="x">point</param>
	<param name="y">point</param>
	<returns>1 if contained, 0 otherwise or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaTestIntersection(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta1"></param>
	<param name="pta2"></param>
	<returns>bval which is 1 if they have any elements in common; 0 otherwise or on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaTransform(System.IntPtr,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) Shift first, then scale.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="shiftx"></param>
	<param name="shifty"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaPtInsidePolygon(System.IntPtr,System.Single,System.Single,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta">vertices of a polygon</param>
	<param name="x">point to be tested</param>
	<param name="y">point to be tested</param>
	<param name="pinside">1 if inside; 0 if outside or on boundary</param>
	<returns>1 if OK, 0 on error The abs value of the sum of the angles subtended from a point by the sides of a polygon, when taken in order traversing the polygon, is 0 if the point is outside the polygon and 2pi if inside. The sign will be positive if traversed cw and negative if ccw.</returns>
</member><member name="M:LeptonicaSharp.Natives.l_angleBetweenVectors(System.Single,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This gives the angle between two vectors, going between
 vector1 (x1,y1) and vector2 (x2,y2).  The angle is swept
 out from 1 --GT 2.  If this is clockwise, the angle is
 positive, but the result is folded into the interval [-pi, pi].
 </summary>
	<remarks>
	</remarks>
	<param name="x1">end point of first vector</param>
	<param name="y1">end point of first vector</param>
	<param name="x2">end point of second vector</param>
	<param name="y2">end point of second vector</param>
	<returns>angle radians, or 0.0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetMinMax(System.IntPtr,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pxmin">min of x</param>
	<param name="pymin">min of y</param>
	<param name="pxmax">max of x</param>
	<param name="pymax">max of y</param>
	<returns>0 if OK, 1 on error.  If pta is empty, requested values are returned as -1.0.</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaSelectByValue(System.IntPtr,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="xth">threshold values</param>
	<param name="yth">threshold values</param>
	<param name="type">L_SELECT_XVAL, L_SELECT_YVAL, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns>ptad filtered set, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaCropToMask(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas">input pta</param>
	<param name="pixm">1 bpp mask</param>
	<returns>ptad  with only pts under the mask fg, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetLinearLSF(System.IntPtr,System.Single[]@,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) Either or both a and b must be input.  They determine the
 type of line that is fit.
 (2) If both a and b are defined, this returns a and b that minimize
 sum (yi - axi -b)^2
 i
 The method is simple differentiate this expression w/rt a and b,
 and solve the resulting two equations for a and b in terms of
 various sums over the input data (xi, yi).
 (3) We also allow two special cases, where either a = 0 or b = 0
 (a) If a is given and b = null, find the linear LSF that
 goes through the origin (b = 0).
 (b) If b is given and a = null, find the linear LSF with
 zero slope (a = 0).
 (4) If nafit is defined, this returns an array of fitted values,
 corresponding to the two implicit Numa arrays (nax and nay) in pta.
 Thus, just as you can plot the data in pta as nay vs. nax,
 you can plot the linear least square fit as nafit vs. nax.
 Get the nax array using ptaGetArrays(pta, nax, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pa">slope a of least square fit y = ax + b</param>
	<param name="pb">intercept b of least square fit</param>
	<param name="pnafit">numa of least square fit</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetQuadraticLSF(System.IntPtr,System.Single[]@,System.Single[]@,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) This does a quadratic least square fit to the set of points
 in %pta.  That is, it finds coefficients a, b and c that minimize
 sum (yi - axixi -bxi -c)^2
 i
 The method is simple differentiate this expression w/rt
 a, b and c, and solve the resulting three equations for these
 coefficients in terms of various sums over the input data (xi, yi).
 The three equations are in the form
 f[0][0]a + f[0][1]b + f[0][2]c = g[0]
 f[1][0]a + f[1][1]b + f[1][2]c = g[1]
 f[2][0]a + f[2][1]b + f[2][2]c = g[2]
 (2) If nafit is defined, this returns an array of fitted values,
 corresponding to the two implicit Numa arrays (nax and nay) in pta.
 Thus, just as you can plot the data in pta as nay vs. nax,
 you can plot the linear least square fit as nafit vs. nax.
 Get the nax array using ptaGetArrays(pta, nax, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pa">coeff a of LSF y = ax^2 + bx + c</param>
	<param name="pb">coeff b of LSF y = ax^2 + bx + c</param>
	<param name="pc">coeff c of LSF y = ax^2 + bx + c</param>
	<param name="pnafit">numa of least square fit</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetCubicLSF(System.IntPtr,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) This does a cubic least square fit to the set of points
 in %pta.  That is, it finds coefficients a, b, c and d
 that minimize
 sum (yi - axixixi -bxixi -cxi - d)^2
 i
 Differentiate this expression w/rt a, b, c and d, and solve
 the resulting four equations for these coefficients in
 terms of various sums over the input data (xi, yi).
 The four equations are in the form
 f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] = g[0]
 f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] = g[1]
 f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] = g[2]
 f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] = g[3]
 (2) If nafit is defined, this returns an array of fitted values,
 corresponding to the two implicit Numa arrays (nax and nay) in pta.
 Thus, just as you can plot the data in pta as nay vs. nax,
 you can plot the linear least square fit as nafit vs. nax.
 Get the nax array using ptaGetArrays(pta, nax, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pa">coeff a of LSF y = ax^3 + bx^2 + cx + d</param>
	<param name="pb">coeff b of LSF</param>
	<param name="pc">coeff c of LSF</param>
	<param name="pd">coeff d of LSF</param>
	<param name="pnafit">numa of least square fit</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetQuarticLSF(System.IntPtr,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) This does a quartic least square fit to the set of points
 in %pta.  That is, it finds coefficients a, b, c, d and 3
 that minimize
 sum (yi - axixixixi -bxixixi -cxixi - dxi - e)^2
 i
 Differentiate this expression w/rt a, b, c, d and e, and solve
 the resulting five equations for these coefficients in
 terms of various sums over the input data (xi, yi).
 The five equations are in the form
 f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] + f[0][4] = g[0]
 f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] + f[1][4] = g[1]
 f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] + f[2][4] = g[2]
 f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] + f[3][4] = g[3]
 f[4][0]a + f[4][1]b + f[4][2]c + f[4][3] + f[4][4] = g[4]
 (2) If nafit is defined, this returns an array of fitted values,
 corresponding to the two implicit Numa arrays (nax and nay) in pta.
 Thus, just as you can plot the data in pta as nay vs. nax,
 you can plot the linear least square fit as nafit vs. nax.
 Get the nax array using ptaGetArrays(pta, nax, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pa">coeff a of LSF y = ax^4 + bx^3 + cx^2 + dx + e</param>
	<param name="pb">coeff b of LSF</param>
	<param name="pc">coeff c of LSF</param>
	<param name="pd">coeff d of LSF</param>
	<param name="pe">coeff e of LSF</param>
	<param name="pnafit">numa of least square fit</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaNoisyLinearLSF(System.IntPtr,System.Single,System.IntPtr@,System.Single[]@,System.Single[]@,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) This does a linear least square fit to the set of points
 in %pta.  It then evaluates the errors and removes points
 whose error is GT= factor  median_error.  It then re-runs
 the linear LSF on the resulting points.
 (2) Either or both a and b must be input.  They determine the
 type of line that is fit.
 (3) The median error can give an indication of how good the fit
 is likely to be.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="factor">reject outliers with error greater than this number of medians; typically ~ 3</param>
	<param name="pptad">with outliers removed</param>
	<param name="pa">slope a of least square fit y = ax + b</param>
	<param name="pb">intercept b of least square fit</param>
	<param name="pmederr">median error</param>
	<param name="pnafit">numa of least square fit to ptad</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaNoisyQuadraticLSF(System.IntPtr,System.Single,System.IntPtr@,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) This does a quadratic least square fit to the set of points
 in %pta.  It then evaluates the errors and removes points
 whose error is GT= factor  median_error.  It then re-runs
 a quadratic LSF on the resulting points.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="factor">reject outliers with error greater than this number of medians; typically ~ 3</param>
	<param name="pptad">with outliers removed</param>
	<param name="pa">coeff a of LSF y = ax^2 + bx + c</param>
	<param name="pb">coeff b of LSF y = ax^2 + bx + c</param>
	<param name="pc">coeff c of LSF y = ax^2 + bx + c</param>
	<param name="pmederr">median error</param>
	<param name="pnafit">numa of least square fit to ptad</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.applyLinearFit(System.Single,System.Single,System.Single,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="a">linear fit coefficients</param>
	<param name="b">linear fit coefficients</param>
	<param name="x"></param>
	<param name="py">y = a  x + b</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.applyQuadraticFit(System.Single,System.Single,System.Single,System.Single,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="a">quadratic fit coefficients</param>
	<param name="b">quadratic fit coefficients</param>
	<param name="c">quadratic fit coefficients</param>
	<param name="x"></param>
	<param name="py">y = a  x^2 + b  x + c</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.applyCubicFit(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="a">cubic fit coefficients</param>
	<param name="b">cubic fit coefficients</param>
	<param name="c">cubic fit coefficients</param>
	<param name="d">cubic fit coefficients</param>
	<param name="x"></param>
	<param name="py">y = a  x^3 + b  x^2  + c  x + d</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.applyQuarticFit(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="a">quartic fit coefficients</param>
	<param name="b">quartic fit coefficients</param>
	<param name="c">quartic fit coefficients</param>
	<param name="d">quartic fit coefficients</param>
	<param name="e">quartic fit coefficients</param>
	<param name="x"></param>
	<param name="py">y = a  x^4 + b  x^3  + c  x^2 + d  x + e</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixPlotAlongPta(System.IntPtr,System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) This is a debugging function.
 (2) Removes existing colormaps and clips the pta to the input %pixs.
 (3) If the image is RGB, three separate plots are generated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="pta">set of points on which to plot</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="title">for plot; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetPixelsFromPix(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Generates a pta of fg pixels in the pix, within the box.
 If box == NULL, it uses the entire pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="box">can be null</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenerateFromPta(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Points are rounded to nearest ints.
 (2) Any points outside (w,h) are silently discarded.
 (3) Output 1 bpp pix has values 1 for each point in the pta.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="w">of pix</param>
	<param name="h">of pix</param>
	<returns>pix 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetBoundaryPixels(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This generates a pta of either fg or bg boundary pixels.
 (2) See also pixGeneratePtaBoundary() for rendering of
 fg boundary pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="type">L_BOUNDARY_FG, L_BOUNDARY_BG</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaGetBoundaryPixels(System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This generates a ptaa of either fg or bg boundary pixels,
 where each pta has the boundary pixels for a connected
 component.
 (2) We can't simply find all the boundary pixels and then select
 those within the bounding box of each component, because
 bounding boxes can overlap.  It is necessary to extract and
 dilate or erode each component separately.  Note also that
 special handling is required for bg pixels when the
 component touches the pix boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="type">L_BOUNDARY_FG, L_BOUNDARY_BG</param>
	<param name="connectivity">4 or 8</param>
	<param name="pboxa">bounding boxes of the c.c.</param>
	<param name="ppixa">pixa of the c.c.</param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaIndexLabeledPixels(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) The pixel values in %pixs are the index of the connected component
 to which the pixel belongs; %pixs is typically generated from
 a 1 bpp pix by pixConnCompTransform().  Background pixels in
 the generating 1 bpp pix are represented in %pixs by 0.
 We do not check that the pixel values are correctly labelled.
 (2) Each pta in the returned ptaa gives the pixel locations
 correspnding to a connected component, with the label of each
 given by the index of the pta into the ptaa.
 (3) Initialize with the first pta in ptaa being empty and
 representing the background value (index 0) in the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, of indices of c.c.</param>
	<param name="pncc">number of connected components</param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetNeighborPixLocs(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Generates a pta of all valid neighbor pixel locations,
 or NULL on error.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="x">pixel from which we search for nearest neighbors</param>
	<param name="y">pixel from which we search for nearest neighbors</param>
	<param name="conn">4 or 8 connectivity</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaConvertToPta1(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">numa with implicit y(x)</param>
	<returns>pta if OK; null on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaConvertToPta2(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nax"></param>
	<param name="nay"></param>
	<returns>pta if OK; null on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaConvertToNuma(System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pnax">addr of nax</param>
	<param name="pnay">addr of nay</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDisplayPta(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) To write on an existing pixs, pixs must be 32 bpp and
 call with pixd == pixs
 pixDisplayPta(pixs, pixs, pta);
 To write to a new pix, use pixd == NULL and call
 pixd = pixDisplayPta(NULL, pixs, pta);
 (2) On error, returns pixd to avoid losing pixs if called as
 pixs = pixDisplayPta(pixs, pixs, pta);
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be same as pixs or NULL; 32 bpp if in-place</param>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="pta">of path to be plotted</param>
	<returns>pixd 32 bpp RGB version of pixs, with path in green.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDisplayPtaaPattern(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) To write on an existing pixs, pixs must be 32 bpp and
 call with pixd == pixs
 pixDisplayPtaPattern(pixs, pixs, pta, ...);
 To write to a new pix, use pixd == NULL and call
 pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...);
 (2) Puts a random color on each pattern associated with a pta.
 (3) On error, returns pixd to avoid losing pixs if called as
 pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...);
 (4) A typical pattern to be used is a circle, generated with
 generatePtaFilledCircle()
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp</param>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp; 32 bpp if in place</param>
	<param name="ptaa">giving locations at which the pattern is displayed</param>
	<param name="pixp">1 bpp pattern to be placed such that its reference point co-locates with each point in pta</param>
	<param name="cx">reference point in pattern</param>
	<param name="cy">reference point in pattern</param>
	<returns>pixd 32 bpp RGB version of pixs.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDisplayPtaPattern(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) To write on an existing pixs, pixs must be 32 bpp and
 call with pixd == pixs
 pixDisplayPtaPattern(pixs, pixs, pta, ...);
 To write to a new pix, use pixd == NULL and call
 pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...);
 (2) On error, returns pixd to avoid losing pixs if called as
 pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...);
 (3) A typical pattern to be used is a circle, generated with
 generatePtaFilledCircle()
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be same as pixs or NULL; 32 bpp if in-place</param>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="pta">giving locations at which the pattern is displayed</param>
	<param name="pixp">1 bpp pattern to be placed such that its reference point co-locates with each point in pta</param>
	<param name="cx">reference point in pattern</param>
	<param name="cy">reference point in pattern</param>
	<param name="color">in 0xrrggbb00 format</param>
	<returns>pixd 32 bpp RGB version of pixs.</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaReplicatePattern(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) You can use either the image %pixp or the set of pts %ptap.
 (2) The pattern is placed with its reference point at each point
 in ptas, and all the fg pixels are colleced into ptad.
 For %pixp, this is equivalent to blitting pixp at each point
 in ptas, and then converting the resulting pix to a pta.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">"sparse" input pta</param>
	<param name="pixp">1 bpp pattern, to be replicated in output pta</param>
	<param name="ptap">set of pts, to be replicated in output pta</param>
	<param name="cx">reference point in pattern</param>
	<param name="cy">reference point in pattern</param>
	<param name="w">clipping sizes for output pta</param>
	<param name="h">clipping sizes for output pta</param>
	<returns>ptad with all points of replicated pattern, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDisplayPtaa(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="ptaa">array of paths to be plotted</param>
	<returns>pixd 32 bpp RGB version of pixs, with paths plotted in different colors, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaSort(System.IntPtr,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y</param>
	<param name="sortorder">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<param name="pnaindex">index of sorted order into original array</param>
	<returns>ptad sorted version of ptas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetSortIndex(System.IntPtr,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y</param>
	<param name="sortorder">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<param name="pnaindex">index of sorted order into original array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaSortByIndex(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="naindex">na that maps from the new pta to the input pta</param>
	<returns>ptad sorted, or NULL on  error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaaSortByIndex(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaas"></param>
	<param name="naindex">na that maps from the new ptaa to the input ptaa</param>
	<returns>ptaad sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaGetRankValue(System.IntPtr,System.Single,System.IntPtr,System.Int32,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="fract">use 0.0 for smallest, 1.0 for largest</param>
	<param name="ptasort">version of %pta sorted by %sorttype</param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y</param>
	<param name="pval">rankval the x or y value at %fract</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaUnionByAset(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) See sarrayRemoveDupsByAset() for the approach.
 (2) The key is a 64-bit hash from the (x,y) pair.
 (3) This is slower than ptaUnionByHash(), mostly because of the
 nlogn sort to build up the rbtree.  Do not use for large
 numbers of points (say, GT 1M).
 (4) The Aset() functions use the sorted l_Aset, which is just
 an rbtree in disguise.
 </summary>
	<remarks>
	</remarks>
	<param name="pta1"></param>
	<param name="pta2"></param>
	<returns>ptad with the union of the set of points, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaRemoveDupsByAset(System.IntPtr)">
	<summary>
 Notes
 (1) This is slower than ptaRemoveDupsByHash(), mostly because
 of the nlogn sort to build up the rbtree.  Do not use for
 large numbers of points (say, GT 1M).
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">assumed to be integer values</param>
	<returns>ptad with duplicates removed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaIntersectionByAset(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) See sarrayIntersectionByAset() for the approach.
 (2) The key is a 64-bit hash from the (x,y) pair.
 (3) This is slower than ptaIntersectionByHash(), mostly because
 of the nlogn sort to build up the rbtree.  Do not use for
 large numbers of points (say, GT 1M).
 </summary>
	<remarks>
	</remarks>
	<param name="pta1"></param>
	<param name="pta2"></param>
	<returns>ptad intersection of the point sets, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_asetCreateFromPta(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>set using a 64-bit hash of (x,y) as the key</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaUnionByHash(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This is faster than ptaUnionByAset(), because the
 bucket lookup is O(n).  It should be used if the pts are
 integers (e.g., representing pixel positions).
 </summary>
	<remarks>
	</remarks>
	<param name="pta1"></param>
	<param name="pta2"></param>
	<returns>ptad with the union of the set of points, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaRemoveDupsByHash(System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) Generates a pta with unique values.
 (2) The dnahash is built up with ptad to assure uniqueness.
 It can be used to find if a point is in the set
 ptaFindPtByHash(ptad, dahash, x, y, index)
 (3) The hash of the (x,y) location is simple and fast.  It scales
 up with the number of buckets to insure a fairly random
 bucket selection for adjacent points.
 (4) A Dna is used rather than a Numa because we need accurate
 representation of 32-bit integers that are indices into ptas.
 Integer --GT float --GT integer conversion makes errors for
 integers larger than 10M.
 (5) This is faster than ptaRemoveDupsByAset(), because the
 bucket lookup is O(n), although there is a double-loop
 lookup within the dna in each bucket.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">assumed to be integer values</param>
	<param name="pptad">unique set of pts; duplicates removed</param>
	<param name="pdahash">dnahash used for lookup</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaIntersectionByHash(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This is faster than ptaIntersectionByAset(), because the
 bucket lookup is O(n).  It should be used if the pts are
 integers (e.g., representing pixel positions).
 </summary>
	<remarks>
	</remarks>
	<param name="pta1"></param>
	<param name="pta2"></param>
	<returns>ptad intersection of the point sets, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptaFindPtByHash(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Fast lookup in dnaHash associated with a pta, to see if a
 random point (x,y) is already stored in the hash table.
 (2) We use a strong hash function to minimize the chance that
 two different points hash to the same key value.
 (3) We select the number of buckets to be about 5% of the size
 of the input %pta, so that when fully populated, each
 bucket (dna) will have about 20 entries, each being an index
 into %pta.  In lookup, after hashing to the key, and then
 again to the bucket, we traverse the bucket (dna), using the
 index into %pta to check if the point (x,y) has been found before.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="dahash">built from pta</param>
	<param name="x">arbitrary points</param>
	<param name="y">arbitrary points</param>
	<param name="pindex">index into pta if (x,y) is in pta; -1 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaHashCreateFromPta(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>dahash, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of ptr array to be alloc'd 0 for default</param>
	<returns>pa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraDestroy(System.IntPtr@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If %freeflag == TRUE, frees each item in the array.
 (2) If %freeflag == FALSE and %warnflag == TRUE, and there are
 items on the array, this gives a warning and destroys the array.
 If these items are not owned elsewhere, this will cause
 a memory leak of all the items that were on the array.
 So if the items are not owned elsewhere and require their
 own destroy function, they must be destroyed before the ptra.
 (3) If %warnflag == FALSE, no warnings will be issued.  This is
 useful if the items are owned elsewhere, such as a
 PixMemoryStore().
 (4) To destroy the ptra, we destroy the ptr array, then
 the ptra, and then null the contents of the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppa">ptra to be nulled</param>
	<param name="freeflag">TRUE to free each remaining item in the array</param>
	<param name="warnflag">TRUE to warn if any remaining items are not destroyed</param>
</member><member name="M:LeptonicaSharp.Natives.ptraAdd(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This adds the element to the next location beyond imax,
 which is the largest occupied ptr in the array.  This is
 what you expect from a stack, where all ptrs up to and
 including imax are occupied, but here the occuption of
 items in the array is entirely arbitrary.
 </summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="item">generic ptr to a struct</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraInsert(System.IntPtr,System.Int32,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This checks first to see if the location is valid, and
 then if there is presently an item there.  If there is not,
 it is simply inserted into that location.
 (2) If there is an item at the insert location, items must be
 moved down to make room for the insert.  In the downward
 shift there are three options, given by %shiftflag.
 ~ If %shiftflag == L_AUTO_DOWNSHIFT, a decision is made
 whether, in a cascade of items, to downshift a minimum
 amount or for all items above %index.  The decision is
 based on the expectation of finding holes (null ptrs)
 between %index and the bottom of the array.
 Assuming the holes are distributed uniformly, if 2 or more
 holes are expected, we do a minimum shift.
 ~ If %shiftflag == L_MIN_DOWNSHIFT, the downward shifting
 cascade of items progresses a minimum amount, until
 the first empty slot is reached.  This mode requires
 some computation before the actual shifting is done.
 ~ If %shiftflag == L_FULL_DOWNSHIFT, a shifting cascade is
 performed where pa[i] --GT pa[i + 1] for all i GT= index.
 Then, the item is inserted at pa[index].
 (3) If you are not using L_AUTO_DOWNSHIFT, the rule of thumb is
 to use L_FULL_DOWNSHIFT if the array is compacted (each
 element points to an item), and to use L_MIN_DOWNSHIFT
 if there are a significant number of null pointers.
 There is no penalty to using L_MIN_DOWNSHIFT for a
 compacted array, however, because the full shift is required
 and we don't do the O(n) computation to look for holes.
 (4) This should not be used repeatedly on large arrays,
 because the function is generally O(n).
 (5) However, it can be used repeatedly if we start with an empty
 ptr array and insert only once at each location.  For example,
 you can support an array of Numa, where at each ptr location
 you store either 0 or 1 Numa, and the Numa can be added
 randomly to the ptr array.
 </summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="index">location in ptra to insert new value</param>
	<param name="item">generic ptr to a struct; can be null</param>
	<param name="shiftflag">L_AUTO_DOWNSHIFT, L_MIN_DOWNSHIFT, L_FULL_DOWNSHIFT</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraRemove(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If flag == L_NO_COMPACTION, this removes the item and
 nulls the ptr on the array.  If it takes the last item
 in the array, pa-GTn is reduced to the next item.
 (2) If flag == L_COMPACTION, this compacts the array for
 for all i GT= index.  It should not be used repeatedly on
 large arrays, because compaction is O(n).
 (3) The ability to remove without automatic compaction allows
 removal with cost O(1).
 </summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="index">element to be removed</param>
	<param name="flag">L_NO_COMPACTION, L_COMPACTION</param>
	<returns>item, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraRemoveLast(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<returns>item, or NULL on error or if the array is empty</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraReplace(System.IntPtr,System.Int32,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="index">element to be replaced</param>
	<param name="item">new generic ptr to a struct; can be null</param>
	<param name="freeflag">TRUE to free old item; FALSE to return it</param>
	<returns>item  old item, if it exists and is not freed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraSwap(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="index1"></param>
	<param name="index2"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraCompactArray(System.IntPtr)">
	<summary>
 Notes
 (1) This compacts the items on the array, filling any empty ptrs.
 (2) This does not change the size of the array of ptrs.
 </summary>
	<remarks>
	</remarks>
	<param name="pa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraReverse(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraJoin(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pa1">add to this one</param>
	<param name="pa2">appended to pa1, and emptied of items; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraGetMaxIndex(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) The largest index to an item in the array is %maxindex.
 %maxindex is one less than the number of items that would be
 in the array if there were no null pointers between 0
 and %maxindex - 1.  However, because the internal ptr array
 need not be compacted, there may be NULL pointers at
 indices below %maxindex; for example, if items have
 been removed.
 (2) When an item is added to the end of the array, it goes
 into pa-GTarray[maxindex + 1], and maxindex is then
 incremented by 1.
 (3) If there are no items in the array, this returns %maxindex = -1.
 </summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="pmaxindex">index of last item in the array;</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraGetActualCount(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) The actual number of items on the ptr array, pa-GTnactual,
 will be smaller than pa-GTn if the array is not compacted.
 </summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="pcount">actual number of items on the ptr array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraGetPtrToItem(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This returns a ptr to the item.  You must cast it to
 the type of item.  Do not destroy it; the item belongs
 to the Ptra.
 (2) This can access all possible items on the ptr array.
 If an item doesn't exist, it returns null.
 </summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="index">of element to be retrieved</param>
	<returns>a ptr to the element, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraaCreate(System.Int32)">
	<summary>
 Notes
 (1) The ptraa is generated with a fixed size, that can not change.
 The ptra can be generated and inserted randomly into this array.
 </summary>
	<remarks>
	</remarks>
	<param name="n">size of ptr array to be alloc'd</param>
	<returns>paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraaDestroy(System.IntPtr@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See ptraDestroy() for use of %freeflag and %warnflag.
 (2) To destroy the ptraa, we destroy each ptra, then the ptr array,
 then the ptraa, and then null the contents of the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppaa">to be nulled</param>
	<param name="freeflag">TRUE to free each remaining item in each ptra</param>
	<param name="warnflag">TRUE to warn if any remaining items are not destroyed</param>
</member><member name="M:LeptonicaSharp.Natives.ptraaGetSize(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="psize">size of ptr array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraaInsertPtra(System.IntPtr,System.Int32,System.IntPtr)">
	<summary>
 Notes
 (1) Caller should check return value.  On success, the Ptra
 is inserted in the Ptraa and is owned by it.  However,
 on error, the Ptra remains owned by the caller.
 </summary>
	<remarks>
	</remarks>
	<param name="paa">ptraa</param>
	<param name="index">location in array for insertion</param>
	<param name="pa">to be inserted</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraaGetPtra(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This returns the ptra ptr.  If %accessflag == L_HANDLE_ONLY,
 the ptra is left on the ptraa.  If %accessflag == L_REMOVE,
 the ptr in the ptraa is set to NULL, and the caller
 is responsible for disposing of the ptra (either putting it
 back on the ptraa, or destroying it).
 (2) This returns NULL if there is no Ptra at the index location.
 </summary>
	<remarks>
	</remarks>
	<param name="paa">ptraa</param>
	<param name="index">location in array</param>
	<param name="accessflag">L_HANDLE_ONLY, L_REMOVE</param>
	<returns>ptra at index location, or NULL on error or if there is no ptra there.</returns>
</member><member name="M:LeptonicaSharp.Natives.ptraaFlattenToPtra(System.IntPtr)">
	<summary>
 Notes
 (1) This 'flattens' the ptraa to a ptra, taking the items in
 each ptra, in order, starting with the first ptra, etc.
 (2) As a side-effect, the ptra are all removed from the ptraa
 and destroyed, leaving an empty ptraa.
 </summary>
	<remarks>
	</remarks>
	<param name="paa">ptraa</param>
	<returns>ptra, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixQuadtreeMean(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr@)">
	<summary>
 Notes
 (1) The returned fpixa has %nlevels of fpix, each containing
 the mean values at its level.  Level 0 has a
 single value; level 1 has 4 values; level 2 has 16; etc.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, no colormap</param>
	<param name="nlevels">in quadtree; max allowed depends on image size</param>
	<param name="pix_ma">input mean accumulator; can be null</param>
	<param name="pfpixa">mean values in quadtree</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixQuadtreeVariance(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The returned fpixav and fpixarv have %nlevels of fpix,
 each containing at the respective levels the variance
 and root variance values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, no colormap</param>
	<param name="nlevels">in quadtree</param>
	<param name="pix_ma">input mean accumulator; can be null</param>
	<param name="dpix_msa">input mean square accumulator; can be null</param>
	<param name="pfpixa_v">variance values in quadtree</param>
	<param name="pfpixa_rv">root variance values in quadtree</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMeanInRectangle(System.IntPtr,System.IntPtr,System.IntPtr,System.Single[]@)">
	<summary>
 Notes
 (1) This function is intended to be used for many rectangles
 on the same image.  It can find the mean within a
 rectangle in O(1), independent of the size of the rectangle.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="box">region to compute mean value</param>
	<param name="pixma">mean accumulator</param>
	<param name="pval">mean value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixVarianceInRectangle(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This function is intended to be used for many rectangles
 on the same image.  It can find the variance and/or the
 square root of the variance within a rectangle in O(1),
 independent of the size of the rectangle.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="box">region to compute variance and/or root variance</param>
	<param name="pix_ma">mean accumulator</param>
	<param name="dpix_msa">mean square accumulator</param>
	<param name="pvar">variance</param>
	<param name="prvar">root variance</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.boxaaQuadtreeRegions(System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The returned boxaa has %nlevels of boxa, each containing
 the set of rectangles at that level.  The rectangle at
 level 0 is the entire region; at level 1 the region is
 divided into 4 rectangles, and at level n there are n^4
 rectangles.
 (2) At each level, the rectangles in the boxa are in "raster"
 order, with LR (fast scan) and TB (slow scan).
 </summary>
	<remarks>
	</remarks>
	<param name="w">size of pix that is being quadtree-ized</param>
	<param name="h">size of pix that is being quadtree-ized</param>
	<param name="nlevels">number of levels in quadtree</param>
	<returns>baa for quadtree regions at each level, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.quadtreeGetParent(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) Check return value for error.  On error, val is returned as 0.0.
 (2) The parent is located at
 level - 1
 (x/2, y/2)
 </summary>
	<remarks>
	</remarks>
	<param name="fpixa">mean, variance or root variance</param>
	<param name="level">x, y of current pixel</param>
	<param name="pval">parent pixel value, or 0.0 on error</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.quadtreeGetChildren(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) Check return value for error.  On error, all return vals are 0.0.
 (2) The returned child pixels are located at
 level + 1
 (2x, 2y), (2x+1, 2y), (2x, 2y+1), (2x+1, 2y+1)
 </summary>
	<remarks>
	</remarks>
	<param name="fpixa">mean, variance or root variance</param>
	<param name="level">x, y of current pixel</param>
	<param name="pval00">four child pixel values</param>
	<param name="pval10">four child pixel values</param>
	<param name="pval01">four child pixel values</param>
	<param name="pval11">four child pixel values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.quadtreeMaxLevels(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The criterion for maxlevels is that the subdivision not
 go down below the single pixel level.  The 1.5 factor
 is intended to keep any rectangle from accidentally
 having zero dimension due to integer truncation.
 </summary>
	<remarks>
	</remarks>
	<param name="w">dimensions of image</param>
	<param name="h">dimensions of image</param>
	<returns>maxlevels maximum number of levels allowed, or -1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fpixaDisplayQuadtree(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The mean and root variance fall naturally in the 8 bpp range,
 but the variance is typically outside the range.  This
 function displays 8 bpp pix clipped to 255, so the image
 pixels will mostly be 255 (white).
 </summary>
	<remarks>
	</remarks>
	<param name="fpixa">mean, variance or root variance</param>
	<param name="factor">replication factor at lowest level</param>
	<param name="fontsize">4, ... 20</param>
	<returns>pixd 8 bpp, mosaic of quadtree images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lqueueCreate(System.Int32)">
	<summary>
 Notes
 (1) Allocates a ptr array of given size, and initializes counters.
 </summary>
	<remarks>
	</remarks>
	<param name="nalloc">size of ptr array to be alloc'd; 0 for default</param>
	<returns>lqueue, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lqueueDestroy(System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) If freeflag is TRUE, frees each struct in the array.
 (2) If freeflag is FALSE but there are elements on the array,
 gives a warning and destroys the array.  This will
 cause a memory leak of all the items that were on the queue.
 So if the items require their own destroy function, they
 must be destroyed before the queue.  The same applies to the
 auxiliary stack, if it is used.
 (3) To destroy the L_Queue, we destroy the ptr array, then
 the lqueue, and then null the contents of the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="plq">to be nulled</param>
	<param name="freeflag">TRUE to free each remaining struct in the array</param>
</member><member name="M:LeptonicaSharp.Natives.lqueueAdd(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) The algorithm is as follows.  If the queue is populated
 to the end of the allocated array, shift all ptrs toward
 the beginning of the array, so that the head of the queue
 is at the beginning of the array.  Then, if the array is
 more than 0.75 full, realloc with double the array size.
 Finally, add the item to the tail of the queue.
 </summary>
	<remarks>
	</remarks>
	<param name="lq">lqueue</param>
	<param name="item">to be added to the tail of the queue</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lqueueRemove(System.IntPtr)">
	<summary>
 Notes
 (1) If this is the last item on the queue, so that the queue
 becomes empty, nhead is reset to the beginning of the array.
 </summary>
	<remarks>
	</remarks>
	<param name="lq">lqueue</param>
	<returns>ptr to item popped from the head of the queue, or NULL if the queue is empty or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lqueueGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lq">lqueue</param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lqueuePrint(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="lq">lqueue</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRankFilter(System.IntPtr,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This defines, for each pixel in pixs, a neighborhood of
 pixels given by a rectangle "centered" on the pixel.
 This set of wfhf pixels has a distribution of values.
 For each component, if the values are sorted in increasing
 order, we choose the component such that rank(wfhf-1)
 pixels have a lower or equal value and
 (1-rank)(wfhf-1) pixels have an equal or greater value.
 (2) See notes in pixRankFilterGray() for further details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp; no colormap</param>
	<param name="wf">width and height of filter; each is GT= 1</param>
	<param name="hf">width and height of filter; each is GT= 1</param>
	<param name="rank">in [0.0 ... 1.0]</param>
	<returns>pixd of rank values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRankFilterRGB(System.IntPtr,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This defines, for each pixel in pixs, a neighborhood of
 pixels given by a rectangle "centered" on the pixel.
 This set of wfhf pixels has a distribution of values.
 For each component, if the values are sorted in increasing
 order, we choose the component such that rank(wfhf-1)
 pixels have a lower or equal value and
 (1-rank)(wfhf-1) pixels have an equal or greater value.
 (2) Apply gray rank filtering to each component independently.
 (3) See notes in pixRankFilterGray() for further details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="wf">width and height of filter; each is GT= 1</param>
	<param name="hf">width and height of filter; each is GT= 1</param>
	<param name="rank">in [0.0 ... 1.0]</param>
	<returns>pixd of rank values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRankFilterGray(System.IntPtr,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This defines, for each pixel in pixs, a neighborhood of
 pixels given by a rectangle "centered" on the pixel.
 This set of wfhf pixels has a distribution of values,
 and if they are sorted in increasing order, we choose
 the pixel such that rank(wfhf-1) pixels have a lower
 or equal value and (1-rank)(wfhf-1) pixels have an equal
 or greater value.
 (2) By this definition, the rank = 0.0 pixel has the lowest
 value, and the rank = 1.0 pixel has the highest value.
 (3) We add mirrored boundary pixels to avoid boundary effects,
 and put the filter center at (0, 0).
 (4) This dispatches to grayscale erosion or dilation if the
 filter dimensions are odd and the rank is 0.0 or 1.0, rsp.
 (5) Returns a copy if both wf and hf are 1.
 (6) Uses row-major or column-major incremental updates to the
 histograms depending on whether hf GT wf or hv LT= wf, rsp.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="wf">width and height of filter; each is GT= 1</param>
	<param name="hf">width and height of filter; each is GT= 1</param>
	<param name="rank">in [0.0 ... 1.0]</param>
	<returns>pixd of rank values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixMedianFilter(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp; no colormap</param>
	<param name="wf">width and height of filter; each is GT= 1</param>
	<param name="hf">width and height of filter; each is GT= 1</param>
	<returns>pixd of median values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRankFilterWithScaling(System.IntPtr,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) This is a convenience function that downscales, does
 the rank filtering, and upscales.  Because the down-
 and up-scaling functions are very fast compared to
 rank filtering, the time it takes is reduced from that
 for the simple rank filtering operation by approximately
 the square of the scaling factor.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp; no colormap</param>
	<param name="wf">width and height of filter; each is GT= 1</param>
	<param name="hf">width and height of filter; each is GT= 1</param>
	<param name="rank">in [0.0 ... 1.0]</param>
	<param name="scalefactor">scale factor; must be GT= 0.2 and LT= 0.7</param>
	<returns>pixd of rank values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_rbtreeCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="keytype">defined by an enum for an RB_TYPE union</param>
	<returns>rbtree    container with empty ptr to the root</returns>
</member><member name="M:LeptonicaSharp.Natives.l_rbtreeLookup(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="t">rbtree, including root node</param>
	<param name="key">find a node with this key</param>
	<returns>value     a pointer to a union, if the node exists; else NULL</returns>
</member><member name="M:LeptonicaSharp.Natives.l_rbtreeInsert(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) If a node with the key already exists, this just updates the value.
 </summary>
	<remarks>
	</remarks>
	<param name="t">rbtree, including root node</param>
	<param name="key">insert a node with this key, if the key does not already exist in the tree</param>
	<param name="value">typically an int, used for an index</param>
</member><member name="M:LeptonicaSharp.Natives.l_rbtreeDelete(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="t">rbtree, including root node</param>
	<param name="key">(delete the node with this key</param>
</member><member name="M:LeptonicaSharp.Natives.l_rbtreeDestroy(System.IntPtr)">
	<summary>
 Notes
 (1) Destroys the tree and nulls the input tree ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pt">ptr to rbtree</param>
</member><member name="M:LeptonicaSharp.Natives.l_rbtreeGetFirst(System.IntPtr)">
	<summary>
 Notes
 (1) This is the first node in an in-order traversal.
 </summary>
	<remarks>
	</remarks>
	<param name="t">rbtree, including root node</param>
	<returns>void</returns>
</member><member name="M:LeptonicaSharp.Natives.l_rbtreeGetNext(System.IntPtr)">
	<summary>
 Notes
 (1) This finds the next node, in an in-order traversal, from
 the current node.
 (2) It is useful as an iterator for a map.
 (3) Call l_rbtreeGetFirst() to get the first node.
 </summary>
	<remarks>
	</remarks>
	<param name="n">current node</param>
	<returns>next node, or NULL if it's the last node</returns>
</member><member name="M:LeptonicaSharp.Natives.l_rbtreeGetLast(System.IntPtr)">
	<summary>
 Notes
 (1) This is the last node in an in-order traversal.
 </summary>
	<remarks>
	</remarks>
	<param name="t">rbtree, including root node</param>
	<returns>void</returns>
</member><member name="M:LeptonicaSharp.Natives.l_rbtreeGetPrev(System.IntPtr)">
	<summary>
 Notes
 (1) This finds the previous node, in an in-order traversal, from
 the current node.
 (2) It is useful as an iterator for a map.
 (3) Call l_rbtreeGetLast() to get the last node.
 </summary>
	<remarks>
	</remarks>
	<param name="n">current node</param>
	<returns>next node, or NULL if it's the first node</returns>
</member><member name="M:LeptonicaSharp.Natives.l_rbtreeGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="t">rbtree</param>
	<returns>count  the number of nodes in the tree, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_rbtreePrint(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="t">rbtree</param>
</member><member name="M:LeptonicaSharp.Natives.pixProcessBarcodes(System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="format">L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...</param>
	<param name="method">L_USE_WIDTHS, L_USE_WINDOWS</param>
	<param name="psaw">sarray of bar widths</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>sarray text of barcodes, or NULL if none found or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExtractBarcodes(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, no colormap</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>pixa deskewed and cropped barcodes, or NULL if none found or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadBarcodes(System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa">of 8 bpp deskewed and cropped barcodes</param>
	<param name="format">L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...</param>
	<param name="method">L_USE_WIDTHS, L_USE_WINDOWS;</param>
	<param name="psaw">sarray of bar widths</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>sa sarray of widths, one string for each barcode found, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadBarcodeWidths(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">of 8 bpp deskewed and cropped barcode</param>
	<param name="method">L_USE_WIDTHS, L_USE_WINDOWS;</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>na numa of widths (each in set {1,2,3,4}, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixLocateBarcodes(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="thresh">for binarization of edge filter output; typ. 20</param>
	<param name="ppixb">binarized edge filtered input image</param>
	<param name="ppixm">mask over barcodes</param>
	<returns>boxa location of barcodes, or NULL if none found or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDeskewBarcode(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) The (optional) angle returned is the angle in degrees (cw positive)
 necessary to rotate the image so that it is deskewed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image; 8 bpp</param>
	<param name="pixb">binarized edge-filtered input image</param>
	<param name="box">identified region containing barcode</param>
	<param name="margin">of extra pixels around box to extract</param>
	<param name="threshold">for binarization; ~20</param>
	<param name="pangle">in degrees, clockwise is positive</param>
	<param name="pconf">confidence</param>
	<returns>pixd deskewed barcode, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExtractBarcodeWidths1(System.IntPtr,System.Single,System.Single,System.IntPtr@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) The widths are alternating black/white, starting with black
 and ending with black.
 (2) This method uses the widths of the bars directly, in terms
 of the (float) number of pixels between transitions.
 The histograms of these widths for black and white bars is
 generated and interpreted.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image; 8 bpp</param>
	<param name="thresh">estimated pixel threshold for crossing white LT--GT black; typ. ~120</param>
	<param name="binfract">histo binsize as a fraction of minsize; e.g., 0.25</param>
	<param name="pnaehist">histogram of black widths; NULL ok</param>
	<param name="pnaohist">histogram of white widths; NULL ok</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>nad numa of barcode widths in encoded integer units, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExtractBarcodeWidths2(System.IntPtr,System.Single,System.Single[]@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) The widths are alternating black/white, starting with black
 and ending with black.
 (2) The optional best decoding window width is the width of the window
 that is used to make a decision about whether a transition occurs.
 It is approximately the average width in pixels of the narrowest
 white and black bars (i.e., those corresponding to unit width).
 (3) The optional return signal %nac is a sequence of 0s, 1s,
 and perhaps a few 2s, giving the number of crossings in each window.
 On the occasion where there is a '2', it is interpreted as
 as ending two runs the previous one and another one that has length 1.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image; 8 bpp</param>
	<param name="thresh">estimated pixel threshold for crossing white LT--GT black; typ. ~120</param>
	<param name="pwidth">best decoding window width, in pixels</param>
	<param name="pnac">number of transitions in each window</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>nad numa of barcode widths in encoded integer units, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExtractBarcodeCrossings(System.IntPtr,System.Single,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">input image; 8 bpp</param>
	<param name="thresh">estimated pixel threshold for crossing white LT--GT black; typ. ~120</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>numa of crossings, in pixel units, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaQuantizeCrossingsByWidth(System.IntPtr,System.Single,System.IntPtr@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This first computes the histogram of black and white bar widths,
 binned in appropriate units.  There should be well-defined
 peaks, each corresponding to a specific width.  The sequence
 of barcode widths (namely, the integers from the set {1,2,3,4})
 is returned.
 (2) The optional returned histograms are binned in width units
 that are inversely proportional to %binfract.  For example,
 if %binfract = 0.25, there are 4.0 bins in the distance of
 the width of the narrowest bar.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">numa of crossing locations, in pixel units</param>
	<param name="binfract">histo binsize as a fraction of minsize; e.g., 0.25</param>
	<param name="pnaehist">histo of even (black) bar widths</param>
	<param name="pnaohist">histo of odd (white) bar widths</param>
	<param name="debugflag">1 to generate plots of histograms of bar widths</param>
	<returns>nad sequence of widths, in unit sizes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.numaQuantizeCrossingsByWindow(System.IntPtr,System.Single,System.Single[]@,System.Single[]@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) The minimum size of the window is set by the minimum
 distance between zero crossings.
 (2) The optional return signal %nac is a sequence of 0s, 1s,
 and perhaps a few 2s, giving the number of crossings in each window.
 On the occasion where there is a '2', it is interpreted as
 ending two runs the previous one and another one that has length 1.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">numa of crossing locations</param>
	<param name="ratio">of max window size over min window size in search; typ. 2.0</param>
	<param name="pwidth">best window width</param>
	<param name="pfirstloc">center of window for first xing</param>
	<param name="pnac">array of window crossings (0, 1, 2)</param>
	<param name="debugflag">1 to generate various plots of intermediate results</param>
	<returns>nad sequence of widths, in unit sizes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaReadFiles(System.String,System.String)">
	<summary>
 Notes
 (1) %dirname is the full path for the directory.
 (2) %substr is the part of the file name (excluding
 the directory) that is to be matched.  All matching
 filenames are read into the Pixa.  If substr is NULL,
 all filenames are read into the Pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname"></param>
	<param name="substr">substring filter on filenames; can be null</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaReadFilesSA(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">full pathnames for all files</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRead(System.String)">
	<summary>
 Notes
 (1) See at top of file for supported formats.
 </summary>
	<remarks>
	</remarks>
	<param name="filename">with full pathname or in local directory</param>
	<returns>pix if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadWithHint(System.String,System.Int32)">
	<summary>
 Notes
 (1) The hint is not binding, but may be used to optimize jpeg decoding.
 Use 0 for no hinting.
 </summary>
	<remarks>
	</remarks>
	<param name="filename">with full pathname or in local directory</param>
	<param name="hint">bitwise OR of L_HINT_ values for jpeg; use 0 for no hint</param>
	<returns>pix if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadIndexed(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This function is useful for selecting image files from a
 directory, where the integer %index is embedded into
 the file name.
 (2) This is typically done by generating the sarray using
 getNumberedPathnamesInDirectory(), so that the %index
 pathname would have the number %index in it.  The size
 of the sarray should be the largest number (plus 1) appearing
 in the file names, respecting the constraints in the
 call to getNumberedPathnamesInDirectory().
 (3) Consequently, for some indices into the sarray, there may
 be no pathnames in the directory containing that number.
 By convention, we place empty C strings ("") in those
 locations in the sarray, and it is not an error if such
 a string is encountered and no pix is returned.
 Therefore, the caller must verify that a pix is returned.
 (4) See convertSegmentedPagesToPS() in src/psio1.c for an
 example of usage.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of full pathnames</param>
	<param name="index">into pathname array</param>
	<returns>pix if OK; null if not found</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadStream(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The hint only applies to jpeg.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="hint">bitwise OR of L_HINT_ values for jpeg; use 0 for no hint</param>
	<returns>pix if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadHeader(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This reads the actual headers for jpeg, png, tiff and pnm.
 For bmp and gif, we cheat and read the entire file into a pix,
 from which we extract the "header" information.
 </summary>
	<remarks>
	</remarks>
	<param name="filename">with full pathname or in local directory</param>
	<param name="pformat">file format</param>
	<param name="pw">width and height</param>
	<param name="ph">width and height</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel 1, 3 or 4</param>
	<param name="piscmap">1 if cmap exists; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.findFileFormat(System.String,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pformat">found format</param>
	<returns>0 if OK, 1 on error or if format is not recognized</returns>
</member><member name="M:LeptonicaSharp.Natives.findFileFormatStream(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) Important Side effect -- this resets fp to BOF.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pformat">found format</param>
	<returns>0 if OK, 1 on error or if format is not recognized</returns>
</member><member name="M:LeptonicaSharp.Natives.findFileFormatBuffer(System.Byte[],System.Int32@)">
	<summary>
 Notes
 (1) This determines the file format from the first 12 bytes in
 the compressed data stream, which are stored in memory.
 (2) For tiff files, this returns IFF_TIFF.  The specific tiff
 compression is then determined using findTiffCompression().
 </summary>
	<remarks>
	</remarks>
	<param name="buf">byte buffer at least 12 bytes in size; we can't check</param>
	<param name="pformat">found format</param>
	<returns>0 if OK, 1 on error or if format is not recognized</returns>
</member><member name="M:LeptonicaSharp.Natives.fileFormatIsTiff(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>1 if file is tiff; 0 otherwise or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadMem(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) This is a variation of pixReadStream(), where the data is read
 from a memory buffer rather than a file.
 (2) On windows, this only reads tiff formatted files directly from
 memory.  For other formats, it writes to a temp file and
 decompresses from file.
 (3) findFileFormatBuffer() requires up to 12 bytes to decide on
 the format.  That determines the constraint here.  But in
 fact the data must contain the entire compressed string for
 the image.
 </summary>
	<remarks>
	</remarks>
	<param name="data">const; encoded</param>
	<param name="size">size of data</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadHeaderMem(System.Byte[],System.UInt32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This reads the actual headers for jpeg, png, tiff, jp2k and pnm.
 For bmp and gif, we cheat and read all the data into a pix,
 from which we extract the "header" information.
 (2) The amount of data required depends on the format.  For
 png, it requires less than 30 bytes, but for jpeg it can
 require most of the compressed file.  In practice, the data
 is typically the entire compressed file in memory.
 (3) findFileFormatBuffer() requires up to 8 bytes to decide on
 the format, which we require.
 </summary>
	<remarks>
	</remarks>
	<param name="data">const; encoded</param>
	<param name="size">size of data</param>
	<param name="pformat">image format</param>
	<param name="pw">width and height</param>
	<param name="ph">width and height</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel 1, 3 or 4</param>
	<param name="piscmap">1 if cmap exists; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.writeImageFileInfo(System.String,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If headeronly == 0 and the image has spp == 4,this will
 also call pixDisplayLayersRGBA() to display the image
 in three views.
 (2) This is a debug function that changes the value of
 var_PNG_STRIP_16_TO_8 to 1 (the default).
 </summary>
	<remarks>
	</remarks>
	<param name="filename">input file</param>
	<param name="fpout">output file stream</param>
	<param name="headeronly">1 to read only the header; 0 to read both the header and the input file</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.ioFormatTest(System.String)">
	<summary>
 Notes
 (1) This writes and reads a set of output files losslessly
 in different formats to /tmp/format/, and tests that the
 result before and after is unchanged.
 (2) This should work properly on input images of any depth,
 with and without colormaps.
 (3) All supported formats are tested for bmp, png, tiff and
 non-ascii pnm.  Ascii pnm also works (but who'd ever want
 to use it?)   We allow 2 bpp bmp, although it's not
 supported elsewhere.  And we don't support reading
 16 bpp png, although this can be turned on in pngio.c.
 (4) This silently skips png or tiff testing if HAVE_LIBPNG
 or HAVE_LIBTIFF are 0, respectively.
 </summary>
	<remarks>
	</remarks>
	<param name="filename">input file</param>
	<returns>0 if OK; 1 on error or if the test fails</returns>
</member><member name="M:LeptonicaSharp.Natives.recogCreateFromRecog(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a convenience function that generates a recog using
 the unscaled training data in an existing recog.
 (2) It is recommended to use %maxyshift = 1 (the default value)
 (3) See recogCreate() for use of %scalew, %scaleh and %linew.
 </summary>
	<remarks>
	</remarks>
	<param name="recs">source recog with arbitrary input parameters</param>
	<param name="scalew">scale all widths to this; use 0 otherwise</param>
	<param name="scaleh">scale all heights to this; use 0 otherwise</param>
	<param name="linew">width of normalized strokes; use 0 to skip</param>
	<param name="threshold">for binarization; typically ~128</param>
	<param name="maxyshift">from nominal centroid alignment; default is 1</param>
	<returns>recd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogCreateFromPixa(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a convenience function for training from labeled data.
 The pixa can be read from file.
 (2) The pixa should contain the unscaled bitmaps used for training.
 (3) See recogCreate() for use of %scalew, %scaleh and %linew.
 (4) It is recommended to use %maxyshift = 1 (the default value)
 (5) All examples in the same class (i.e., with the same character
 label) should be similar.  They can be made similar by invoking
 recogRemoveOutliers[1,2]() on %pixa before calling this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of labeled, 1 bpp images</param>
	<param name="scalew">scale all widths to this; use 0 otherwise</param>
	<param name="scaleh">scale all heights to this; use 0 otherwise</param>
	<param name="linew">width of normalized strokes; use 0 to skip</param>
	<param name="threshold">for binarization; typically ~150</param>
	<param name="maxyshift">from nominal centroid alignment; default is 1</param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogCreateFromPixaNoFinish(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See recogCreateFromPixa() for details.
 (2) This is also used to generate a pixaa with templates
 in each class within a pixa.  For that, all args except for
 %pixa are ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of labeled, 1 bpp images</param>
	<param name="scalew">scale all widths to this; use 0 otherwise</param>
	<param name="scaleh">scale all heights to this; use 0 otherwise</param>
	<param name="linew">width of normalized strokes; use 0 to skip</param>
	<param name="threshold">for binarization; typically ~150</param>
	<param name="maxyshift">from nominal centroid alignment; default is 1</param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogCreate(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If %scalew == 0 and %scaleh == 0, no scaling is done.
 If one of these is 0 and the other is GT 0, scaling is isotropic
 to the requested size.  We typically do not set both GT 0.
 (2) Use linew GT 0 to convert the templates to images with fixed
 width strokes.  linew == 0 skips the conversion.
 (3) The only valid values for %maxyshift are 0, 1 and 2.
 It is recommended to use %maxyshift == 1 (default value).
 Using %maxyshift == 0 is much faster than %maxyshift == 1, but
 it is much less likely to find the template with the best
 correlation.  Use of anything but 1 results in a warning.
 (4) Scaling is used for finding outliers and for training a
 book-adapted recognizer (BAR) from a bootstrap recognizer (BSR).
 Scaling the height to a fixed value and scaling the width
 accordingly (e.g., %scaleh = 40, %scalew = 0) is recommended.
 (5) The storage for most of the arrays is allocated when training
 is finished.
 </summary>
	<remarks>
	</remarks>
	<param name="scalew">scale all widths to this; use 0 otherwise</param>
	<param name="scaleh">scale all heights to this; use 0 otherwise</param>
	<param name="linew">width of normalized strokes; use 0 to skip</param>
	<param name="threshold">for binarization; typically ~128; 0 for default</param>
	<param name="maxyshift">from nominal centroid alignment; default is 1</param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="precog">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp.Natives.recogGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>count of classes in recog; 0 if no recog or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogSetParams(System.IntPtr,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) This is called when a recog is created.
 (2) Default %min_nopad value allows for some padding.
 To disable padding, set %min_nopad = 0.  To pad only when
 no samples are available for the class, set %min_nopad = 1.
 (3) The %max_wh_ratio limits the width/height ratio for components
 that we attempt to split.  Splitting long components is expensive.
 (4) The %max_ht_ratio is a quality requirement on the training data.
 The recognizer will not run if the averages are computed and
 the templates do not satisfy it.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">to be padded, if necessary</param>
	<param name="type">type of char set; -1 for default; see enum in recog.h</param>
	<param name="min_nopad">min number in a class without padding; use -1 for default</param>
	<param name="max_wh_ratio">max width/height ratio allowed for splitting; use -1.0 for default</param>
	<param name="max_ht_ratio">max of max/min averaged template height ratio; use -1.0 for default</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogGetClassIndex(System.IntPtr,System.Int32,System.String,System.Int32@)">
	<summary>
 Notes
 (1) This is used during training.  There is one entry in
 recog-GTdna_tochar (integer value, e.g., ascii) and
 one in recog-GTsa_text (e.g, ascii letter in a string)
 for each character class.
 (2) This searches the dna character array for %val.  If it is
 not found, the template represents a character class not
 already seen it increments setsize (the number of character
 classes) by 1, and augments both the index (dna_tochar)
 and text (sa_text) arrays.
 (3) Returns the index in index, except on error.
 (4) Caller must check the function return value.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with LUT's pre-computed</param>
	<param name="val">integer value; can be up to 3 bytes for UTF-8</param>
	<param name="text">text from which %val was derived; used if not found</param>
	<param name="pindex">index into dna_tochar</param>
	<returns>0 if found; 1 if not found and added; 2 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.recogStringToIndex(System.IntPtr,System.String,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="text">text string for some class</param>
	<param name="pindex">index for that class; -1 if not found</param>
	<returns>0 if OK, 1 on error not finding the string is an error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogGetClassString(System.IntPtr,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) Extracts a copy of the string from sa_text, which
 the caller must free.
 (2) Caller must check the function return value.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="index">into array of char types</param>
	<param name="pcharstr">string representation; returns an empty string on error</param>
	<returns>0 if found, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_convertCharstrToInt(System.String,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="str">input string representing one UTF-8 character; not more than 4 bytes</param>
	<param name="pval">integer value for the input.  Think of it as a 1-to-1 hash code.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogRead(System.String)">
	<summary>
 Notes
 (1) When a recog is serialized, a pixaa of the templates that are
 actually used for correlation is saved in the pixaa_u array
 of the recog.  These can be different from the templates that
 were used to generate the recog, because those original templates
 can be scaled and turned into normalized lines.  When recog1
 is deserialized to recog2, these templates are put in both the
 unscaled array (pixaa_u) and the modified array (pixaa) in recog2.
 Why not put it in only the unscaled array and let
 recogTrainingFinalized() regenerate the modified templates?
 The reason is that with normalized lines, the operation of
 thinning to a skeleton and dilating back to a fixed width
 is not idempotent.  Thinning to a skeleton saves pixels at
 the end of a line segment, and thickening the skeleton puts
 additional pixels at the end of the lines.  This tends to
 close gaps.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization of recog (not ascii)</param>
	<param name="size">of data in bytes</param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogWrite(System.String,System.IntPtr)">
	<summary>
 Notes
 (1) The pixaa of templates that is written is the modified one
 in the pixaa field. It is the pixaa that is actually used
 for correlation. This is not the unscaled array of labeled
 bitmaps, in pixaa_u, that was used to generate the recog in the
 first place.  See the notes in recogRead() for the rationale.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="recog"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="recog"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a recog in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized recog (not ascii)</param>
	<param name="psize">size of returned data</param>
	<param name="recog"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogExtractPixa(System.IntPtr)">
	<summary>
 Notes
 (1) This generates a pixa of all the unscaled images in the
 recognizer, where each one has its character class label in
 the pix text field, by flattening pixaa_u to a pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>pixa if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogDecode(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) The input pixs has been filtered so that it is likely to be
 composed of more than one touching character.  Specifically,
 its height can only slightly exceed that of the tallest
 unscaled template, the width is somewhat larger than the
 width of the widest unscaled template, and the w/h aspect ratio
 is bounded by max_wh_ratio.
 (2) This uses the DID mechanism with labeled templates to
 segment the input %pixs.  The resulting segmentation is
 returned.  (It is given by did-GTboxa).
 (3) In debug mode, the Viterbi path is rescored based on all
 the templates.  In non-debug mode, the same procedure is
 carried out by recogIdentifyPix() on the result of the
 segmentation.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with LUT's pre-computed</param>
	<param name="pixs">typically of multiple touching characters, 1 bpp</param>
	<param name="nlevels">of templates; 2 for now</param>
	<param name="ppixdb">debug result; can be null</param>
	<returns>boxa  segmentation of pixs into characters, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogCreateDid(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pixs">of 1 bpp image to match</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogDestroyDid(System.IntPtr)">
	<summary>
 Notes
 (1) As the signature indicates, this is owned by the recog, and can
 only be destroyed using this function.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogDidExists(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>1 if recog-GTdid exists; 0 if not or on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.recogGetDid(System.IntPtr)">
	<summary>
 Notes
 (1) This also makes sure the arrays are defined.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>did still owned by the recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogSetChannelParams(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This converts the independent bit-flip probabilities in the
 "channel" into log-likelihood coefficients on image sums.
 These coefficients are only defined for the non-background
 template levels.  Thus for nlevels = 2 (one fg, one bg),
 only beta[1] and gamma[1] are used.  For nlevels = 4 (three
 fg templates), we use beta[1-3] and gamma[1-3].
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="nlevels"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogIdentifyMultiple(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This filters the input pixa and calls recogIdentifyPixa()
 (2) Splitting is relatively slow, because it tries to match all
 character templates to all locations.  This step can be skipped.
 (3) An attempt is made to order the (optionally) returned images
 and boxes in 2-dimensional sorted order.  These can then
 be used to aggregate identified characters into numbers or words.
 One typically wants the pixa, which contains a boxa of the
 extracted subimages.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with training finished</param>
	<param name="pixs">containing typically a small number of characters</param>
	<param name="minh">remove shorter components; use 0 for default</param>
	<param name="skipsplit">1 to skip the splitting step</param>
	<param name="pboxa">locations of identified components</param>
	<param name="ppixa">images of identified components</param>
	<param name="ppixdb">debug pix inputs and best fits</param>
	<param name="debugsplit">1 returns pix split debugging images</param>
	<returns>0 if OK; 1 if nothing is found; 2 for other errors.</returns>
</member><member name="M:LeptonicaSharp.Natives.recogSplitIntoCharacters(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) This can be given an image that has an arbitrary number
 of text characters.  It optionally splits connected
 components based on document image decoding in recogDecode().
 The returned pixa includes the boxes from which the
 (possibly split) components are extracted.
 (2) After noise filtering, the resulting components are put in
 row-major (2D) order, and the smaller of overlapping
 components are removed if they satisfy conditions of
 relative size and fractional overlap.
 (3) Note that the splitting function uses unscaled templates
 and does not bother returning the class results and scores.
 These are more accurately found later using the scaled templates.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pixs">1 bpp, contains only mostly deskewed text</param>
	<param name="minh">remove shorter components; use 0 for default</param>
	<param name="skipsplit">1 to skip the splitting step</param>
	<param name="pboxa">character bounding boxes</param>
	<param name="ppixa">character images</param>
	<param name="debug">1 for results written to pixadb_split</param>
	<returns>0 if OK, 1 on error or if no components are returned</returns>
</member><member name="M:LeptonicaSharp.Natives.recogCorrelationBestRow(System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) Supervises character matching for (in general) a c.c with
 multiple touching characters.  Finds the best match greedily.
 Rejects small parts that are left over after splitting.
 (2) Matching is to the average, and without character scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with LUT's pre-computed</param>
	<param name="pixs">typically of multiple touching characters, 1 bpp</param>
	<param name="pboxa">bounding boxs of best fit character</param>
	<param name="pnascore">correlation scores</param>
	<param name="pnaindex">indices of classes</param>
	<param name="psachar">array of character strings</param>
	<param name="debug">1 for results written to pixadb_split</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogCorrelationBestChar(System.IntPtr,System.IntPtr,System.IntPtr@,System.Single[]@,System.Int32@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) Basic matching character splitter.  Finds the best match among
 all templates to some region of the image.  This can result
 in splitting the image into two parts.  This is "image decoding"
 without dynamic programming, because we don't use a setwidth
 and compute the best matching score for the entire image.
 (2) Matching is to the average templates, without character scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with LUT's pre-computed</param>
	<param name="pixs">can be of multiple touching characters, 1 bpp</param>
	<param name="pbox">bounding box of best fit character</param>
	<param name="pscore">correlation score</param>
	<param name="pindex">index of class</param>
	<param name="pcharstr">character string of class</param>
	<param name="ppixdb">debug pix showing input and best fit</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogIdentifyPixa(System.IntPtr,System.IntPtr,System.IntPtr@)">
	<summary>
 Notes
 (1) This should be called by recogIdentifyMuliple(), which
 binarizes and splits characters before sending %pixa here.
 (2) This calls recogIdentifyPix(), which does the same operation
 on each pix in %pixa, and optionally returns the arrays
 of results (scores, class index and character string)
 for the best correlation match.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pixa">of 1 bpp images to match</param>
	<param name="ppixdb">pix showing inputs and best fits</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogIdentifyPix(System.IntPtr,System.IntPtr,System.IntPtr@)">
	<summary>
 Notes
 (1) Basic recognition function for a single character.
 (2) If templ_use == L_USE_ALL_TEMPLATES, which is the default
 situation, matching is attempted to every bitmap in the recog,
 and the identify of the best match is returned.
 (3) For finding outliers, templ_use == L_USE_AVERAGE_TEMPLATES, and
 matching is only attemplted to the averaged bitmaps.  For this
 case, the index of the bestsample is meaningless (0 is returned
 if requested).
 (4) The score is related to the confidence (probability of correct
 identification), in that a higher score is correlated with
 a higher probability.  However, the actual relation between
 the correlation (score) and the probability is not known;
 we call this a "score" because "confidence" can be misinterpreted
 as an actual probability.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with LUT's pre-computed</param>
	<param name="pixs">of a single character, 1 bpp</param>
	<param name="ppixdb">debug pix showing input and best fit</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogSkipIdentify(System.IntPtr)">
	<summary>
 Notes
 (1) This just writes a "dummy" result with 0 score and empty
 string id into the rch.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.rchaDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="prcha">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.rchDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="prch">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.rchaExtract(System.IntPtr,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This returns clones of the number and string arrays.  They must
 be destroyed by the caller.
 </summary>
	<remarks>
	</remarks>
	<param name="rcha"></param>
	<param name="pnaindex">indices of best templates</param>
	<param name="pnascore">correl scores of best templates</param>
	<param name="psatext">character strings of best templates</param>
	<param name="pnasample">indices of best samples</param>
	<param name="pnaxloc">x-locations of templates</param>
	<param name="pnayloc">y-locations of templates</param>
	<param name="pnawidth">widths of best templates</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.rchExtract(System.IntPtr,System.Int32@,System.Single[]@,System.IntPtr@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="rch"></param>
	<param name="pindex">index of best template</param>
	<param name="pscore">correlation score of best template</param>
	<param name="ptext">character string of best template</param>
	<param name="psample">index of best sample</param>
	<param name="pxloc">x-location of template</param>
	<param name="pyloc">y-location of template</param>
	<param name="pwidth">width of best template</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogProcessToIdentify(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is a lightweight operation to insure that the input
 image is 1 bpp, properly cropped, and padded on each side.
 If bpp GT 1, the image is thresholded.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with LUT's pre-computed</param>
	<param name="pixs">typ. single character, possibly d GT 1 and uncropped</param>
	<param name="pad">extra pixels added to left and right sides</param>
	<returns>pixd 1 bpp, clipped to foreground, or NULL if there are no fg pixels or on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.recogExtractNumbers(System.IntPtr,System.IntPtr,System.Single,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This extracts digit data after recogaIdentifyMultiple() or
 lower-level identification has taken place.
 (2) Each string in the returned sa contains a sequence of ascii
 digits in a number.
 (3) The horizontal distance between boxes (limited by %spacethresh)
 is the negative of the horizontal overlap.
 (4) Components with a score less than %scorethresh, which may
 be hyphens or other small characters, will signal the
 end of the current sequence of digits in the number.  A typical
 value for %scorethresh is 0.60.
 (5) We allow two digits to be combined if these conditions apply
 (a) the first is to the left of the second
 (b) the second has a horizontal separation less than %spacethresh
 (c) the vertical overlap GT= 0 (vertical separation LT 0)
 (d) both have a score that exceeds %scorethresh
 (6) Each numa in the optionally returned naa contains the digit
 scores of a number.  Each boxa in the optionally returned baa
 contains the bounding boxes of the digits in the number.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="boxas">location of components</param>
	<param name="scorethresh">min score for which we accept a component</param>
	<param name="spacethresh">max horizontal distance allowed between digits, use -1 for default</param>
	<param name="pbaa">bounding boxes of identified numbers</param>
	<param name="pnaa">scores of identified digits</param>
	<returns>sa of identified numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.showExtractNumbers(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr@)">
	<summary>
 Notes
 (1) This is a debugging routine on digit identification; e.g.
 recogIdentifyMultiple(recog, pixs, 0, 1, boxa, NULL, NULL, 0);
 sa = recogExtractNumbers(recog, boxa, 0.8, -1, baa, naa);
 pixa = showExtractNumbers(pixs, sa, baa, naa, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input 1 bpp image</param>
	<param name="sa">recognized text strings</param>
	<param name="baa">boxa array for location of characters in each string</param>
	<param name="naa">numa array for scores of characters in each string</param>
	<param name="ppixdb">input pixs with identified chars outlined</param>
	<returns>pixa   of identified strings with text and scores, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogTrainLabeled(System.IntPtr,System.IntPtr,System.IntPtr,System.String,System.Int32)">
	<summary>
 Notes
 (1) Training is restricted to the addition of a single
 character in an arbitrary (e.g., UTF8) charset
 (2) If box != null, it should represent the location in %pixs
 of the character image.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">in training mode</param>
	<param name="pixs">if depth GT 1, will be thresholded to 1 bpp</param>
	<param name="box">cropping box</param>
	<param name="text">if null, use text field in pix</param>
	<param name="debug">1 to display images of samples not captured</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogProcessLabeled(System.IntPtr,System.IntPtr,System.IntPtr,System.String,System.IntPtr@)">
	<summary>
 Notes
 (1) This crops and binarizes the input image, generating a pix
 of one character where the charval is inserted into the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">in training mode</param>
	<param name="pixs">if depth GT 1, will be thresholded to 1 bpp</param>
	<param name="box">cropping box</param>
	<param name="text">if null, use text field in pix</param>
	<param name="ppix">addr of pix, 1 bpp, labeled</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogAddSample(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The pix is 1 bpp, with the character string label embedded.
 (2) The pixaa_u array of the recog is initialized to accept
 up to 256 different classes.  When training is finished,
 the arrays are truncated to the actual number of classes.
 To pad an existing recog from the boot recognizers, training
 is started again; if samples from a new class are added,
 the pixaa_u array is extended by adding a pixa to hold them.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pix">a single character, 1 bpp</param>
	<param name="debug"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogModifyTemplate(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pixs">1 bpp, to be optionally scaled and turned into strokes of fixed width</param>
	<returns>pixd   modified pix if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogAverageSamples(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is only called in two situations
 (a) When splitting characters using either the DID method
 recogDecode() or the the greedy splitter
 recogCorrelationBestRow()
 (b) By a special recognizer that is used to remove outliers.
 Both unscaled and scaled inputs are averaged.
 (2) If the data in any class is nonexistent (no samples), or
 very bad (no fg pixels in the average), or if the ratio
 of max/min average unscaled class template heights is
 greater than max_ht_ratio, this destroys the recog.
 The caller must check the return value of the recog.
 (3) Set debug = 1 to view the resulting templates and their centroids.
 </summary>
	<remarks>
	</remarks>
	<param name="precog">addr of existing recog; may be destroyed</param>
	<param name="debug"></param>
	<returns>0 on success, 1 on failure</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaAccumulateSamples(System.IntPtr,System.IntPtr,System.IntPtr@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This generates an aligned (by centroid) sum of the input pix.
 (2) We use only the first 256 samples; that's plenty.
 (3) If pta is not input, we generate two tables, and discard
 after use.  If this is called many times, it is better
 to precompute the pta.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of samples from the same class, 1 bpp</param>
	<param name="pta">of centroids of the samples</param>
	<param name="ppixd">accumulated samples, 8 bpp</param>
	<param name="px">average x coordinate of centroids</param>
	<param name="py">average y coordinate of centroids</param>
	<returns>0 on success, 1 on failure</returns>
</member><member name="M:LeptonicaSharp.Natives.recogTrainingFinished(System.IntPtr,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This must be called after all training samples have been added.
 (2) If the templates are not good enough, the recog input is destroyed.
 (3) Usually, %modifyflag == 1, because we want to apply
 recogModifyTemplate() to generate the actual templates
 that will be used.  The one exception is when reading a
 serialized recog there we want to put the same set of
 templates in both the unscaled and modified pixaa.
 See recogReadStream() to see why we do this.
 (4) See recogTemplatesAreOK() for %minsize and %minfract usage.
 (5) The following things are done here
 (a) Allocate (or reallocate) storage for (possibly) modified
 bitmaps, centroids, and fg areas.
 (b) Generate the (possibly) modified bitmaps.
 (c) Compute centroid and fg area data for both unscaled and
 modified bitmaps.
 (d) Truncate the pixaa, ptaa and numaa arrays down from
 256 to the actual size.
 (6) Putting these operations here makes it simple to recompute
 the recog with different modifications on the bitmaps.
 (7) Call recogShowContent() to display the templates, both
 unscaled and modified.
 </summary>
	<remarks>
	</remarks>
	<param name="precog">addr of recog</param>
	<param name="modifyflag">1 to use recogModifyTemplate(); 0 otherwise</param>
	<param name="minsize">set to -1 for default</param>
	<param name="minfract">set to -1.0 for default</param>
	<returns>0 if OK, 1 on error (input recog will be destroyed)</returns>
</member><member name="M:LeptonicaSharp.Natives.recogFilterPixaBySize(System.IntPtr,System.Int32,System.Int32,System.Single,System.IntPtr@)">
	<summary>
 Notes
 (1) The basic assumption is that the most common and larger
 templates in each class are more likely to represent the
 characters we are interested in.  For example, larger digits
 are more likely to represent page numbers, and smaller digits
 could be data in tables.  Therefore, we bias the first
 stage of filtering toward the larger characters by removing
 very small ones, and select based on proximity of the
 remaining characters to median height.
 (2) For each of the %setsize classes, order the templates
 increasingly by height.  Take the rank 0.9 height.  Eliminate
 all templates that are shorter by more than %max_ht_ratio.
 Of the remaining ones, select up to %maxkeep that are closest
 in rank order height to the median template.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">labeled templates</param>
	<param name="setsize">size of character set (number of classes)</param>
	<param name="maxkeep">max number of templates to keep in a class</param>
	<param name="max_ht_ratio">max allowed height ratio (see below)</param>
	<param name="pna">debug output, giving the number in each class after filtering; use NULL to skip</param>
	<returns>pixa   filtered templates, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogSortPixaByClass(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa">labeled templates</param>
	<param name="setsize">size of character set (number of classes)</param>
	<returns>paa   pixaa where each pixa has templates for one class, or null on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogRemoveOutliers1(System.IntPtr,System.Single,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This is a convenience wrapper when using default parameters
 for the recog.  See pixaRemoveOutliers1() for details.
 (2) If this succeeds, the new recog replaces the input recog;
 if it fails, the input recog is destroyed.
 </summary>
	<remarks>
	</remarks>
	<param name="precog">addr of recog with unscaled labeled templates</param>
	<param name="minscore">keep everything with at least this score</param>
	<param name="mintarget">minimum desired number to retain if possible</param>
	<param name="minsize">minimum number of samples required for a class</param>
	<param name="ppixsave">saved templates, with scores</param>
	<param name="ppixrem">removed templates, with scores</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaRemoveOutliers1(System.IntPtr,System.Single,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) Removing outliers is particularly important when recognition
 goes against all the samples in the training set, as opposed
 to the averages for each class.  The reason is that we get
 an identification error if a mislabeled template is a best
 match for an input sample.
 (2) Because the score values depend strongly on the quality
 of the character images, to avoid losing too many samples
 we supplement a minimum score for retention with a score
 necessary to acquire the minimum target number of templates.
 To do this we are willing to use a lower threshold,
 LOWER_SCORE_THRESHOLD, on the score.  Consequently, with
 poor quality templates, we may keep samples with a score
 less than %minscore, but never less than LOWER_SCORE_THRESHOLD.
 And if the number of samples is less than %minsize, we do
 not use any.
 (3) This is meant to be used on a BAR, where the templates all
 come from the same book; use minscore ~0.75.
 (4) Method make a scaled recog from the input %pixas.  Then,
 for each class generate the averages, match each
 scaled template against the average, and save unscaled
 templates that had a sufficiently good match.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">unscaled labeled templates</param>
	<param name="minscore">keep everything with at least this score; use -1.0 for default.</param>
	<param name="mintarget">minimum desired number to retain if possible; use -1 for default.</param>
	<param name="minsize">minimum number of samples required for a class; use -1 for default.</param>
	<param name="ppixsave">saved templates, with scores</param>
	<param name="ppixrem">removed templates, with scores</param>
	<returns>pixa   of unscaled templates to be kept, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogRemoveOutliers2(System.IntPtr,System.Single,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This is a convenience wrapper when using default parameters
 for the recog.  See pixaRemoveOutliers2() for details.
 (2) If this succeeds, the new recog replaces the input recog;
 if it fails, the input recog is destroyed.
 </summary>
	<remarks>
	</remarks>
	<param name="precog">addr of recog with unscaled labeled templates</param>
	<param name="minscore">keep everything with at least this score</param>
	<param name="minsize">minimum number of samples required for a class</param>
	<param name="ppixsave">saved templates, with scores</param>
	<param name="ppixrem">removed templates, with scores</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaRemoveOutliers2(System.IntPtr,System.Single,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) Removing outliers is particularly important when recognition
 goes against all the samples in the training set, as opposed
 to the averages for each class.  The reason is that we get
 an identification error if a mislabeled template is a best
 match for an input sample.
 (2) This method compares each template against the average templates
 of each class, and discards any template that has a higher
 correlation to a class different from its own.  It also
 sets a lower bound on correlation scores with its class average.
 (3) This is meant to be used on a BAR, where the templates all
 come from the same book; use minscore ~0.75.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">unscaled labeled templates</param>
	<param name="minscore">keep everything with at least this score; use -1.0 for default.</param>
	<param name="minsize">minimum number of samples required for a class; use -1 for default.</param>
	<param name="ppixsave">saved templates, with scores</param>
	<param name="ppixrem">removed templates, with scores</param>
	<returns>pixa   of unscaled templates to be kept, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogTrainFromBoot(System.IntPtr,System.IntPtr,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This takes %pixas of unscaled single characters and %recboot,
 a bootstrep recognizer (BSR) that has been set up with parameters
 scaleh scale all templates to this height
 linew width of normalized strokes, or 0 if using
 the input image
 It modifies the pix in %pixas accordingly and correlates
 with the templates in the BSR.  It returns those input
 images in %pixas whose best correlation with the BSR is at
 or above %minscore.  The returned pix have added text labels
 for the text string of the class to which the best
 correlated template belongs.
 (2) Identification occurs in scaled mode (typically with h = 40),
 optionally using a width-normalized line images derived
 from those in %pixas.
 </summary>
	<remarks>
	</remarks>
	<param name="recogboot">labeled boot recognizer</param>
	<param name="pixas">set of unlabeled input characters</param>
	<param name="minscore">min score for accepting the example; e.g., 0.75</param>
	<param name="threshold">for binarization, if needed</param>
	<param name="debug">1 for debug output saved to recogboot; 0 otherwise</param>
	<returns>pixad   labeled version of input pixas, trained on a BSR, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogPadDigitTrainingSet(System.IntPtr@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a no-op if padding is not needed.  However,
 if it is, this replaces the input recog with a new recog,
 padded appropriately with templates from a boot recognizer,
 and set up with correlation templates derived from
 %scaleh and %linew.
 </summary>
	<remarks>
	</remarks>
	<param name="precog">trained; if padding is needed, it is replaced by a a new padded recog</param>
	<param name="scaleh">must be GT 0; suggest ~40.</param>
	<param name="linew">use 0 for original scanned images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogIsPaddingNeeded(System.IntPtr,System.IntPtr@)">
	<summary>
 Notes
 (1) This returns a string array in sa containing character values
 for which extra templates are needed; this sarray is
 used by recogGetPadTemplates().  It returns NULL
 if no padding templates are needed.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">trained</param>
	<param name="psa">addr of returned string containing text value</param>
	<returns>1 on error; 0 if OK, whether or not additional padding templates are required.</returns>
</member><member name="M:LeptonicaSharp.Natives.recogAddDigitPadTemplates(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Call recogIsPaddingNeeded() first, which returns %sa of
 template text strings for classes where more templates
 are needed.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">trained</param>
	<param name="sa">set of text strings that need to be padded</param>
	<returns>pixa   of all templates from %recog and the additional pad templates from a boot recognizer; or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogMakeBootDigitRecog(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This takes a set of pre-computed, labeled pixa of single
 digits, and generates a recognizer where the character templates
 that will be used are derived from the boot-generated pixa
 - extending by replicating the set with different widths,
 keeping the height the same
 - scaling (isotropically to fixed height)
 - optionally generating a skeleton and thickening so that
 all strokes have the same width.
 (2) The resulting templates are scaled versions of either the
 input bitmaps or images with fixed line widths.  To use the
 input bitmaps, set %linew = 0; otherwise, set %linew to the
 desired line width.
 </summary>
	<remarks>
	</remarks>
	<param name="scaleh">scale all heights to this; typ. use 40</param>
	<param name="linew">normalized line width; typ. use 5; 0 to skip</param>
	<param name="maxyshift">from nominal centroid alignment; typically 0 or 1</param>
	<param name="debug">1 for showing templates; 0 otherwise</param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogMakeBootDigitTemplates(System.Int32)">
	<summary>
 Notes
 (1) See recogMakeBootDigitRecog().
 </summary>
	<remarks>
	</remarks>
	<param name="debug">1 for display of templates</param>
	<returns>pixa   of templates; or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogShowContent(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file  stream</param>
	<param name="recog"></param>
	<param name="index">for naming of output files of template images</param>
	<param name="display">1 for showing template images, 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogDebugAverages(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Generates an image that pairs each of the input images used
 in training with the average template that it is best
 correlated to.  This is written into the recog.
 (2) It also generates pixa_tr of all the input training images,
 which can be used, e.g., in recogShowMatchesInRange().
 (3) Destroys the recog if the averaging function finds any bad classes.
 </summary>
	<remarks>
	</remarks>
	<param name="precog">addr of recog</param>
	<param name="debug">0 no output; 1 for images; 2 for text; 3 for both</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogShowAverageTemplates(System.IntPtr)">
	<summary>
 Notes
 (1) This debug routine generates a display of the averaged templates,
 both scaled and unscaled, with the centroid visible in red.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>0 on success, 1 on failure</returns>
</member><member name="M:LeptonicaSharp.Natives.recogShowMatchesInRange(System.IntPtr,System.IntPtr,System.Single,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This gives a visual output of the best matches for a given
 range of scores.  Each pair of images can optionally be
 labeled with the index of the best match and the correlation.
 (2) To use this, save a set of 1 bpp images (labeled or
 unlabeled) that can be given to a recognizer in a pixa.
 Then call this function with the pixa and parameters
 to filter a range of scores.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pixa">of 1 bpp images to match</param>
	<param name="minscore">range to include output</param>
	<param name="maxscore">range to include output</param>
	<param name="display">to display the result</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.recogShowMatch(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Single)">
	<summary>
 Notes
 (1) pix1 can be one of these
 (a) The input pix alone, which can be either a single character
 (box == NULL) or several characters that need to be
 segmented.  If more than character is present, the box
 region is displayed with an outline.
 (b) Both the input pix and the matching template.  In this case,
 pix2 and box will both be null.
 (2) If the bmf has been made (by a call to recogMakeBmf())
 and the index GT= 0, the text field, match score and index
 will be rendered; otherwise their values will be ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pix1">input pix; several possibilities</param>
	<param name="pix2">matching template</param>
	<param name="box">region in pix1 for which pix2 matches</param>
	<param name="index">index of matching template; use -1 to disable printing</param>
	<param name="score">score of match</param>
	<returns>pixd pair of images, showing input pix and best template, optionally with matching information, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.regTestSetup(System.Int32,System.IntPtr,System.IntPtr@)">
	<summary>
 Notes
 (1) Call this function with the args to the reg test.  The first arg
 is the name of the reg test.  There are three cases
 Case 1
 There is either only one arg, or the second arg is "compare".
 This is the mode in which you run a regression test
 (or a set of them), looking for failures and logging
 the results to a file.  The output, which includes
 logging of all reg test failures plus a SUCCESS or
 FAILURE summary for each test, is appended to the file
 "/tmp/lept/reg_results.txt.  For this case, as in Case 2,
 the display field in rp is set to FALSE, preventing
 image display.
 Case 2
 The second arg is "generate".  This will cause
 generation of new golden files for the reg test.
 The results of the reg test are not recorded, and
 the display field in rp is set to FALSE.
 Case 3
 The second arg is "display".  The test will run and
 files will be written.  Comparisons with golden files
 will not be carried out, so the only notion of success
 or failure is with tests that do not involve golden files.
 The display field in rp is TRUE, and this is used by
 pixDisplayWithTitle().
 (2) See regutils.h for examples of usage.
 </summary>
	<remarks>
	</remarks>
	<param name="argc">from invocation; can be either 1 or 2</param>
	<param name="argv">to regtest %argv[1] is one of these "generate", "compare", "display"</param>
	<param name="prp">all regression params</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.regTestCleanup(System.IntPtr)">
	<summary>
 Notes
 (1) This copies anything written to the temporary file to the
 output file /tmp/lept/reg_results.txt.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regression test parameters</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.regTestCompareValues(System.IntPtr,System.Single,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="val1">typ. the golden value</param>
	<param name="val2">typ. the value computed</param>
	<param name="delta">allowed max absolute difference</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp.Natives.regTestCompareStrings(System.IntPtr,System.Byte[],System.UInt32,System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="string1">typ. the expected string</param>
	<param name="bytes1">size of string1</param>
	<param name="string2">typ. the computed string</param>
	<param name="bytes2">size of string2</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp.Natives.regTestComparePix(System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This function compares two pix for equality.  On failure,
 this writes to stderr.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="pix1">to be tested for equality</param>
	<param name="pix2">to be tested for equality</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp.Natives.regTestCompareSimilarPix(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This function compares two pix for near equality.  On failure,
 this writes to stderr.
 (2) The pix are similar if the fraction of non-conforming pixels
 does not exceed %maxfract.  Pixels are non-conforming if
 the difference in pixel values equals or exceeds %mindiff.
 Typical values might be %mindiff = 15 and %maxfract = 0.01.
 (3) The input images must have the same size and depth.  The
 pixels for comparison are typically subsampled from the images.
 (4) Normally, use %printstats = 0.  In debugging mode, to see
 the relation between %mindiff and the minimum value of
 %maxfract for success, set this to 1.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="pix1">to be tested for near equality</param>
	<param name="pix2">to be tested for near equality</param>
	<param name="mindiff">minimum pixel difference to be counted; GT 0</param>
	<param name="maxfract">maximum fraction of pixels allowed to have diff greater than or equal to mindiff</param>
	<param name="printstats">use 1 to print normalized histogram to stderr</param>
	<returns>0 if OK, 1 on error a failure in similarity comparison is not an error</returns>
</member><member name="M:LeptonicaSharp.Natives.regTestCheckFile(System.IntPtr,System.String)">
	<summary>
 Notes
 (1) This function does one of three things, depending on the mode
 "generate" makes a "golden" file as a copy %localname.
 "compare" compares %localname contents with the golden file
 "display" makes the %localname file but does no comparison
 (2) The canonical format of the golden filenames is
 /tmp/lept/golden/[root of main name]_golden.[index].
 [ext of localname]
 e.g.,
 /tmp/lept/golden/maze_golden.0.png
 It is important to add an extension to the local name, because
 the extension is added to the name of the golden file.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="localname">name of output file from reg test</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp.Natives.regTestCompareFiles(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This only does something in "compare" mode.
 (2) The canonical format of the golden filenames is
 /tmp/lept/golden/[root of main name]_golden.[index].
 [ext of localname]
 e.g.,
 /tmp/lept/golden/maze_golden.0.png
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="index1">of one output file from reg test</param>
	<param name="index2">of another output file from reg test</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp.Natives.regTestWritePixAndCheck(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This function makes it easy to write the pix in a numbered
 sequence of files, and either to
 (a) write the golden file ("generate" arg to regression test)
 (b) make a local file and "compare" with the golden file
 (c) make a local file and "display" the results
 (2) The canonical format of the local filename is
 /tmp/lept/regout/[root of main name].[count].[format extension]
 e.g., for scale_reg,
 /tmp/lept/regout/scale.0.png
 The golden file name mirrors this in the usual way.
 (3) The check is done between the written files, which requires
 the files to be identical. The exception is for GIF, which
 only requires that all pixels in the decoded pix are identical.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="pix">to be written</param>
	<param name="format">of output pix</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp.Natives.regTestWriteDataAndCheck(System.IntPtr,System.IntPtr,System.UInt32,System.String)">
	<summary>
 Notes
 (1) This function makes it easy to write data in a numbered
 sequence of files, and either to
 (a) write the golden file ("generate" arg to regression test)
 (b) make a local file and "compare" with the golden file
 (c) make a local file and "display" the results
 (2) The canonical format of the local filename is
 /tmp/lept/regout/[root of main name].[count].[ext]
 e.g., for the first boxaa in quadtree_reg,
 /tmp/lept/regout/quadtree.0.baa
 The golden file name mirrors this in the usual way.
 (3) The data can be anything.  It is most useful for serialized
 output of data, such as boxa, pta, etc.
 (4) The file extension is arbitrary.  It is included simply
 to make the content type obvious when examining written files.
 (5) The check is done between the written files, which requires
 the files to be identical.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="data">to be written</param>
	<param name="nbytes">of data to be written</param>
	<param name="ext">filename extension (e.g. "ba", "pta")</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp.Natives.regTestGenLocalFilename(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is used to get the name of a file in the regout
 subdirectory, that has been made and is used to test against
 the golden file.  You can either specify a particular index
 value, or with %index == -1, this returns the most recently
 written file.  The latter case lets you read a pix from a
 file that has just been written with regTestWritePixAndCheck(),
 which is useful for testing formatted read/write functions.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="index">use -1 for current index</param>
	<param name="format">of image; e.g., IFF_PNG</param>
	<returns>filename if OK, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRasterop(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This has the standard set of 9 args for rasterop.
 This function is your friend; it is worth memorizing!
 (2) If the operation involves only dest, this calls
 rasteropUniLow().  Otherwise, checks depth of the
 src and dest, and if they match, calls rasteropLow().
 (3) For the two-image operation, where both pixs and pixd
 are defined, they are typically different images.  However
 there are cases, such as pixSetMirroredBorder(), where
 in-place operations can be done, blitting pixels from
 one part of pixd to another.  Consequently, we permit
 such operations.  If you use them, be sure that there
 is no overlap between the source and destination rectangles
 in pixd (!)
 Background
 -----------
 There are 18 operations, described by the op codes in pix.h.
 One, PIX_DST, is a no-op.
 Three, PIX_CLR, PIX_SET, and PIX_NOT(PIX_DST) operate only on the dest.
 These are handled by the low-level rasteropUniLow().
 The other 14 involve the both the src and the dest, and depend on
 the bit values of either just the src or the bit values of both
 src and dest.  They are handled by rasteropLow()
 PIX_SRC  s
 PIX_NOT(PIX_SRC)    ~s
 PIX_SRC | PIX_DST    s | d
 PIX_SRC  PIX_DST    s  d
 PIX_SRC ^ PIX_DST    s ^ d
 PIX_NOT(PIX_SRC) | PIX_DST   ~s | d
 PIX_NOT(PIX_SRC)  PIX_DST   ~s  d
 PIX_NOT(PIX_SRC) ^ PIX_DST   ~s ^ d
 PIX_SRC | PIX_NOT(PIX_DST) s | ~d
 PIX_SRC  PIX_NOT(PIX_DST) s  ~d
 PIX_SRC ^ PIX_NOT(PIX_DST) s ^ ~d
 PIX_NOT(PIX_SRC | PIX_DST)   ~(s | d)
 PIX_NOT(PIX_SRC  PIX_DST)   ~(s  d)
 PIX_NOT(PIX_SRC ^ PIX_DST)   ~(s ^ d)
 Each of these is implemented with one of three low-level
 functions, depending on the alignment of the left edge
 of the src and dest rectangles
 a fastest implementation if both left edges are
 (32-bit) word aligned
 a very slightly slower implementation if both left
 edges have the same relative (32-bit) word alignment
 the general routine that is invoked when
 both left edges have different word alignment
 Of the 14 binary rasterops above, only 12 are unique
 logical combinations (out of a possible 16) of src
 and dst bits
 (sd)   (11)   (10)   (01)   (00)
 -----------------------------------------------
 s   1   1   0   0
 ~s   0   1   0   1
 s | d 1   1   1   0
 s  d 1   0   0   0
 s ^ d 0   1   1   0
 ~s | d 1   0   1   1
 ~s  d 0   0   1   0
 ~s ^ d 1   0   0   1
 s | ~d   1   1   0   1
 s  ~d   0   1   0   0
 s ^ ~d   1   0   0   1
 ~(s | d)  0   0   0   1
 ~(s  d)  0   1   1   1
 ~(s ^ d)  1   0   0   1
 Note that the following three operations are equivalent
 ~(s ^ d)
 ~s ^ d
 s ^ ~d
 and in the implementation, we call them out with the first form;
 namely, ~(s ^ d).
 Of the 16 possible binary combinations of src and dest bits,
 the remaining 4 unique ones are independent of the src bit.
 They depend on either just the dest bit or on neither
 the src nor dest bits
 d   1   0   1   0 (indep. of s)
 ~d   0   1   0   1 (indep. of s)
 CLR  0   0   0   0 (indep. of both s  d)
 SET  1   1   1   1 (indep. of both s  d)
 As mentioned above, three of these are implemented by
 rasteropUniLow(), and one is a no-op.
 How can these operation codes be represented by bits
 in such a way that when the basic operations are performed
 on the bits the results are unique for unique
 operations, and mimic the logic table given above?
 The answer is to choose a particular order of the pairings
 (sd)   (11)   (10)   (01)   (00)
 (which happens to be the same as in the above table)
 and to translate the result into 4-bit representations
 of s and d.  For example, the Sun rasterop choice
 (omitting the extra bit for clipping) is
 PIX_SRC   0xc
 PIX_DST   0xa
 This corresponds to our pairing order given above
 (sd)   (11)   (10)   (01)   (00)
 where for s = 1 we get the bit pattern
 PIX_SRC  1   1   0   0  (0xc)
 and for d = 1 we get the pattern
 PIX_DST   1   0   1   0 (0xa)
 OK, that's the pairing order that Sun chose.  How many different
 ways can we assign bit patterns to PIX_SRC and PIX_DST to get
 the boolean ops to work out?  Any of the 4 pairs can be put
 in the first position, any of the remaining 3 pairs can go
 in the second; and one of the remaining 2 pairs can go the the third.
 There is a total of 432 = 24 ways these pairs can be permuted.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">dest pix</param>
	<param name="dx">x val of UL corner of dest rectangle</param>
	<param name="dy">y val of UL corner of dest rectangle</param>
	<param name="dw">width of dest rectangle</param>
	<param name="dh">height of dest rectangle</param>
	<param name="op">op code</param>
	<param name="pixs">src pix</param>
	<param name="sx">x val of UL corner of src rectangle</param>
	<param name="sy">y val of UL corner of src rectangle</param>
	<returns>0 if OK; 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRasteropVip(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This rasterop translates a vertical band of the
 image either up or down, bringing in either white
 or black pixels from outside the image.
 (2) The vertical band extends the full height of pixd.
 (3) If a colormap exists, the nearest color to white or black
 is brought in.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">in-place</param>
	<param name="bx">left edge of vertical band</param>
	<param name="bw">width of vertical band</param>
	<param name="vshift">vertical shift of band; vshift GT 0 is down</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRasteropHip(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This rasterop translates a horizontal band of the
 image either left or right, bringing in either white
 or black pixels from outside the image.
 (2) The horizontal band extends the full width of pixd.
 (3) If a colormap exists, the nearest color to white or black
 is brought in.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">in-place operation</param>
	<param name="by">top of horizontal band</param>
	<param name="bh">height of horizontal band</param>
	<param name="hshift">horizontal shift of band; hshift GT 0 is to right</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixTranslate(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The general pattern is
 pixd = pixTranslate(pixd, pixs, ...);
 For clarity, when you know the case, use one of these
 pixd = pixTranslate(NULL, pixs, ...);  // new
 pixTranslate(pixs, pixs, ...);   // in-place
 pixTranslate(pixd, pixs, ...);   // to existing pixd
 (2) If an existing pixd is not the same size as pixs, the
 image data will be reallocated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">destination this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs"></param>
	<param name="hshift">horizontal shift; hshift GT 0 is to right</param>
	<param name="vshift">vertical shift; vshift GT 0 is down</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRasteropIP(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd">in-place translation</param>
	<param name="hshift">horizontal shift; hshift GT 0 is to right</param>
	<param name="vshift">vertical shift; vshift GT 0 is down</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRasteropFullImage(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 ~ this is a wrapper for a common 2-image raster operation
 ~ both pixs and pixd must be defined
 ~ the operation is performed with aligned UL corners of pixs and pixd
 ~ the operation clips to the smallest pix; if the width or height
 of pixd is larger than pixs, some pixels in pixd will be unchanged
 </summary>
	<remarks>
	</remarks>
	<param name="pixd"></param>
	<param name="pixs"></param>
	<param name="op">any of the op-codes</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.rasteropUniLow(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="datad">ptr to dest image data</param>
	<param name="dpixw">width of dest</param>
	<param name="dpixh">height of dest</param>
	<param name="depth">depth of src and dest</param>
	<param name="dwpl">wpl of dest</param>
	<param name="dx">x val of UL corner of dest rectangle</param>
	<param name="dy">y val of UL corner of dest rectangle</param>
	<param name="dw">width of dest rectangle</param>
	<param name="dh">height of dest rectangle</param>
	<param name="op">op code</param>
</member><member name="M:LeptonicaSharp.Natives.rasteropLow(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="datad">ptr to dest image data</param>
	<param name="dpixw">width of dest</param>
	<param name="dpixh">height of dest</param>
	<param name="depth">depth of src and dest</param>
	<param name="dwpl">wpl of dest</param>
	<param name="dx">x val of UL corner of dest rectangle</param>
	<param name="dy">y val of UL corner of dest rectangle</param>
	<param name="dw">width of dest rectangle</param>
	<param name="dh">height of dest rectangle</param>
	<param name="op">op code</param>
	<param name="datas">ptr to src image data</param>
	<param name="spixw">width of src</param>
	<param name="spixh">height of src</param>
	<param name="swpl">wpl of src</param>
	<param name="sx">x val of UL corner of src rectangle</param>
	<param name="sy">y val of UL corner of src rectangle</param>
</member><member name="M:LeptonicaSharp.Natives.rasteropVipLow(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This clears the pixels that are left exposed after the
 translation.  You can consider them as pixels that are
 shifted in from outside the image.  This can be later
 overridden by the incolor parameter in higher-level functions
 that call this.  For example, for images with depth GT 1,
 these pixels are cleared to black; to be white they
 must later be SET to white.  See, e.g., pixRasteropVip().
 (2) This function scales the width to accommodate any depth,
 performs clipping, and then does the in-place rasterop.
 </summary>
	<remarks>
	</remarks>
	<param name="data">ptr to image data</param>
	<param name="pixw">width</param>
	<param name="pixh">height</param>
	<param name="depth">depth</param>
	<param name="wpl">wpl</param>
	<param name="x">x val of UL corner of rectangle</param>
	<param name="w">width of rectangle</param>
	<param name="shift">+ shifts data downward in vertical column</param>
</member><member name="M:LeptonicaSharp.Natives.rasteropHipLow(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This clears the pixels that are left exposed after the rasterop.
 Therefore, for Pix with depth GT 1, these pixels become black,
 and must be subsequently SET if they are to be white.
 For example, see pixRasteropHip().
 (2) This function performs clipping and calls shiftDataHorizontalLow()
 to do the in-place rasterop on each line.
 </summary>
	<remarks>
	</remarks>
	<param name="data">ptr to image data</param>
	<param name="pixh">height</param>
	<param name="depth">depth</param>
	<param name="wpl">wpl</param>
	<param name="y">y val of UL corner of rectangle</param>
	<param name="h">height of rectangle</param>
	<param name="shift">+ shifts data to the left in a horizontal column</param>
</member><member name="M:LeptonicaSharp.Natives.pixRotate(System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a high-level, simple interface for rotating images
 about their center.
 (2) For very small rotations, just return a clone.
 (3) Rotation brings either white or black pixels in
 from outside the image.
 (4) The rotation type is adjusted if necessary for the image
 depth and size of rotation angle.  For 1 bpp images, we
 rotate either by shear or sampling.
 (5) Colormaps are removed for rotation by area mapping.
 (6) The dest can be expanded so that no image pixels
 are lost.  To invoke expansion, input the original
 width and height.  For repeated rotation, use of the
 original width and height allows the expansion to
 stop at the maximum required size, which is a square
 with side = sqrt(ww + hh).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp rgb</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="type">L_ROTATE_AREA_MAP, L_ROTATE_SHEAR, L_ROTATE_SAMPLING</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<param name="width">original width; use 0 to avoid embedding</param>
	<param name="height">original height; use 0 to avoid embedding</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixEmbedForRotation(System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For very small rotations, just return a clone.
 (2) Generate larger image to embed pixs if necessary, and
 place the center of the input image in the center.
 (3) Rotation brings either white or black pixels in
 from outside the image.  For colormapped images where
 there is no white or black, a new color is added if
 possible for these pixels; otherwise, either the
 lightest or darkest color is used.  In most cases,
 the colormap will be removed prior to rotation.
 (4) The dest is to be expanded so that no image pixels
 are lost after rotation.  Input of the original width
 and height allows the expansion to stop at the maximum
 required size, which is a square with side equal to
 sqrt(ww + hh).
 (5) For an arbitrary angle, the expansion can be found by
 considering the UL and UR corners.  As the image is
 rotated, these move in an arc centered at the center of
 the image.  Normalize to a unit circle by dividing by half
 the image diagonal.  After a rotation of T radians, the UL
 and UR corners are at points T radians along the unit
 circle.  Compute the x and y coordinates of both these
 points and take the max of absolute values; these represent
 the half width and half height of the containing rectangle.
 The arithmetic is done using formulas for sin(a+b) and cos(a+b),
 where b = T.  For the UR corner, sin(a) = h/d and cos(a) = w/d.
 For the UL corner, replace a by (pi - a), and you have
 sin(pi - a) = h/d, cos(pi - a) = -w/d.  The equations
 given below follow directly.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp rgb</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<param name="width">original width; use 0 to avoid embedding</param>
	<param name="height">original height; use 0 to avoid embedding</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateBySampling(System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) For very small rotations, just return a clone.
 (2) Rotation brings either white or black pixels in
 from outside the image.
 (3) Colormaps are retained.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp rgb; can be cmapped</param>
	<param name="xcen">x value of center of rotation</param>
	<param name="ycen">y value of center of rotation</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateBinaryNice(System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) For very small rotations, just return a clone.
 (2) This does a computationally expensive rotation of 1 bpp images.
 The fastest rotators (using shears or subsampling) leave
 visible horizontal and vertical shear lines across which
 the image shear changes by one pixel.  To ameliorate the
 visual effect one can introduce random dithering.  One
 way to do this in a not-too-random fashion is given here.
 We convert to 8 bpp, do a very small blur, rotate using
 linear interpolation (same as area mapping), do a
 small amount of sharpening to compensate for the initial
 blur, and threshold back to binary.  The shear lines
 are magically removed.
 (3) This operation is about 5x slower than rotation by sampling.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="angle">radians; clockwise is positive; about the center</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateWithAlpha(System.IntPtr,System.Single,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) The alpha channel is transformed separately from pixs,
 and aligns with it, being fully transparent outside the
 boundary of the transformed pixs.  For pixels that are fully
 transparent, a blending function like pixBlendWithGrayMask()
 will give zero weight to corresponding pixels in pixs.
 (2) Rotation is about the center of the image; for very small
 rotations, just return a clone.  The dest is automatically
 expanded so that no image pixels are lost.
 (3) Rotation is by area mapping.  It doesn't matter what
 color is brought in because the alpha channel will
 be transparent (black) there.
 (4) If pixg is NULL, it is generated as an alpha layer that is
 partially opaque, using %fract.  Otherwise, it is cropped
 to pixs if required and %fract is ignored.  The alpha
 channel in pixs is never used.
 (4) Colormaps are removed to 32 bpp.
 (5) The default setting for the border values in the alpha channel
 is 0 (transparent) for the outermost ring of pixels and
 (0.5  fract  255) for the second ring.  When blended over
 a second image, this
 (a) shrinks the visible image to make a clean overlap edge
 with an image below, and
 (b) softens the edges by weakening the aliasing there.
 Use l_setAlphaMaskBorder() to change these values.
 (6) A subtle use of gamma correction is to remove gamma correction
 before rotation and restore it afterwards.  This is done
 by sandwiching this function between a gamma/inverse-gamma
 photometric transform
 pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);
 pixd = pixRotateWithAlpha(pixt, angle, NULL, fract);
 pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);
 pixDestroy(pixt);
 This has the side-effect of producing artifacts in the very
 dark regions.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb or cmapped</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="pixg">8 bpp, can be null</param>
	<param name="fract">between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	<returns>pixd 32 bpp rgba, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateAM(System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) Rotates about image center.
 (2) A positive angle gives a clockwise rotation.
 (3) Brings in either black or white pixels from the boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4, 8 bpp gray or colormapped, or 32 bpp RGB</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateAMColor(System.IntPtr,System.Single,System.UInt32)">
	<summary>
 Notes
 (1) Rotates about image center.
 (2) A positive angle gives a clockwise rotation.
 (3) Specify the color to be brought in from outside the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateAMGray(System.IntPtr,System.Single,System.Byte)">
	<summary>
 Notes
 (1) Rotates about image center.
 (2) A positive angle gives a clockwise rotation.
 (3) Specify the grayvalue to be brought in from outside the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateAMCorner(System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) Rotates about the UL corner of the image.
 (2) A positive angle gives a clockwise rotation.
 (3) Brings in either black or white pixels from the boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8 bpp gray or colormapped, or 32 bpp RGB</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateAMColorCorner(System.IntPtr,System.Single,System.UInt32)">
	<summary>
 Notes
 (1) Rotates the image about the UL corner.
 (2) A positive angle gives a clockwise rotation.
 (3) Specify the color to be brought in from outside the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="fillval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateAMGrayCorner(System.IntPtr,System.Single,System.Byte)">
	<summary>
 Notes
 (1) Rotates the image about the UL corner.
 (2) A positive angle gives a clockwise rotation.
 (3) Specify the grayvalue to be brought in from outside the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateAMColorFast(System.IntPtr,System.Single,System.UInt32)">
	<summary>
 Notes
 (1) This rotates a color image about the image center.
 (2) A positive angle gives a clockwise rotation.
 (3) It uses area mapping, dividing each pixel into
 16 subpixels.
 (4) It is about 10% to 20% faster than the more accurate linear
 interpolation function pixRotateAMColor(),
 which uses 256 subpixels.
 (5) For some reason it shifts the image center.
 No attempt is made to rotate the alpha component.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateOrth(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="quads">0-3; number of 90 degree cw rotations</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotate180(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This does a 180 rotation of the image about the center,
 which is equivalent to a left-right flip about a vertical
 line through the image center, followed by a top-bottom
 flip about a horizontal line through the image center.
 (2) There are 3 cases for input
 (a) pixd == null (creates a new pixd)
 (b) pixd == pixs (in-place operation)
 (c) pixd != pixs (existing pixd)
 (3) For clarity, use these three patterns, respectively
 (a) pixd = pixRotate180(NULL, pixs);
 (b) pixRotate180(pixs, pixs);
 (c) pixRotate180(pixd, pixs);
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">all depths</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotate90(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This does a 90 degree rotation of the image about the center,
 either cw or ccw, returning a new pix.
 (2) The direction must be either 1 (cw) or -1 (ccw).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="direction">1 = clockwise,  -1 = counter-clockwise</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFlipLR(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This does a left-right flip of the image, which is
 equivalent to a rotation out of the plane about a
 vertical line through the image center.
 (2) There are 3 cases for input
 (a) pixd == null (creates a new pixd)
 (b) pixd == pixs (in-place operation)
 (c) pixd != pixs (existing pixd)
 (3) For clarity, use these three patterns, respectively
 (a) pixd = pixFlipLR(NULL, pixs);
 (b) pixFlipLR(pixs, pixs);
 (c) pixFlipLR(pixd, pixs);
 (4) If an existing pixd is not the same size as pixs, the
 image data will be reallocated.
 (5) The pixel access routines allow a trivial implementation.
 However, for d LT 8, it is more efficient to right-justify
 each line to a 32-bit boundary and then extract bytes and
 do pixel reversing.   In those cases, as in the 180 degree
 rotation, we right-shift the data (if necessary) to
 right-justify on the 32 bit boundary, and then read the
 bytes off each raster line in reverse order, reversing
 the pixels in each byte using a table.  These functions
 for 1, 2 and 4 bpp were tested against the "trivial"
 version (shown here for 4 bpp)
 for (i = 0; i LT h; i++) {
 line = data + i  wpl;
 memcpy(buffer, line, bpl);
 for (j = 0; j LT w; j++) {
 val = GET_DATA_QBIT(buffer, w - 1 - j);
 SET_DATA_QBIT(line, j, val);
 }
 }
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">all depths</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFlipTB(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This does a top-bottom flip of the image, which is
 equivalent to a rotation out of the plane about a
 horizontal line through the image center.
 (2) There are 3 cases for input
 (a) pixd == null (creates a new pixd)
 (b) pixd == pixs (in-place operation)
 (c) pixd != pixs (existing pixd)
 (3) For clarity, use these three patterns, respectively
 (a) pixd = pixFlipTB(NULL, pixs);
 (b) pixFlipTB(pixs, pixs);
 (c) pixFlipTB(pixd, pixs);
 (4) If an existing pixd is not the same size as pixs, the
 image data will be reallocated.
 (5) This is simple and fast.  We use the memcpy function
 to do all the work on aligned data, regardless of pixel
 depth.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">all depths</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateShear(System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This rotates an image about the given point, using
 either 2 or 3 shears.
 (2) A positive angle gives a clockwise rotation.
 (3) This brings in 'incolor' pixels from outside the image.
 (4) For rotation angles larger than about 0.35 radians, we issue
 a warning because you should probably be using another method
 (either sampling or area mapping)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="xcen">x value for which there is no horizontal shear</param>
	<param name="ycen">y value for which there is no vertical shear</param>
	<param name="angle">radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotate2Shear(System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This rotates the image about the given point, using the 2-shear
 method.  It should only be used for angles smaller than
 MAX_2_SHEAR_ANGLE.  For larger angles, a warning is issued.
 (2) A positive angle gives a clockwise rotation.
 (3) 2-shear rotation by a specified angle is equivalent
 to the sequential transformations
 x' = x + tan(angle)  (y - ycen)  for x-shear
 y' = y + tan(angle)  (x - xcen)  for y-shear
 (4) Computation of tan(angle) is performed within the shear operation.
 (5) This brings in 'incolor' pixels from outside the image.
 (6) If the image has an alpha layer, it is rotated separately by
 two shears.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="xcen">center of rotation</param>
	<param name="ycen">center of rotation</param>
	<param name="angle">radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotate3Shear(System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This rotates the image about the given point, using the 3-shear
 method.  It should only be used for angles smaller than
 LIMIT_SHEAR_ANGLE.  For larger angles, a warning is issued.
 (2) A positive angle gives a clockwise rotation.
 (3) 3-shear rotation by a specified angle is equivalent
 to the sequential transformations
 y' = y + tan(angle/2)  (x - xcen)  for first y-shear
 x' = x + sin(angle)  (y - ycen) for x-shear
 y' = y + tan(angle/2)  (x - xcen)  for second y-shear
 (4) Computation of tan(angle) is performed in the shear operations.
 (5) This brings in 'incolor' pixels from outside the image.
 (6) If the image has an alpha layer, it is rotated separately by
 two shears.
 (7) The algorithm was published by Alan Paeth "A Fast Algorithm
 for General Raster Rotation," Graphics Interface '86,
 pp. 77-81, May 1986.  A description of the method, along with
 an implementation, can be found in Graphics Gems, p. 179,
 edited by Andrew Glassner, published by Academic Press, 1990.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="xcen">center of rotation</param>
	<param name="ycen">center of rotation</param>
	<param name="angle">radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateShearIP(System.IntPtr,System.Int32,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This does an in-place rotation of the image about the
 specified point, using the 3-shear method.  It should only
 be used for angles smaller than LIMIT_SHEAR_ANGLE.
 For larger angles, a warning is issued.
 (2) A positive angle gives a clockwise rotation.
 (3) 3-shear rotation by a specified angle is equivalent
 to the sequential transformations
 y' = y + tan(angle/2)  (x - xcen)   for first y-shear
 x' = x + sin(angle)  (y - ycen)  for x-shear
 y' = y + tan(angle/2)  (x - xcen)   for second y-shear
 (4) Computation of tan(angle) is performed in the shear operations.
 (5) This brings in 'incolor' pixels from outside the image.
 (6) The pix cannot be colormapped, because the in-place operation
 only blits in 0 or 1 bits, not an arbitrary colormap index.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; not colormapped</param>
	<param name="xcen">center of rotation</param>
	<param name="ycen">center of rotation</param>
	<param name="angle">radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateShearCenter(System.IntPtr,System.Single,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="angle">radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRotateShearCenterIP(System.IntPtr,System.Single,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="angle">radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixStrokeWidthTransform(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The dest Pix is 8 or 16 bpp, with the pixel values
 equal to the stroke width in which it is a member.
 The values are clipped to the max pixel value if necessary.
 (2) The color determines if we're labelling white or black strokes.
 (3) A pixel that is not a member of the chosen color gets
 value 0; it belongs to a width of length 0 of the
 chosen color.
 (4) This chooses, for each dest pixel, the minimum of sets
 of runlengths through each pixel.  Here are the sets
 nangles increment set
 ------- --------- --------------------------------
 2 90 {0, 90}
 4 45 {0, 45, 90, 135}
 6 30 {0, 30, 60, 90, 120, 150}
 8 22.5  {0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5}
 (5) Runtime scales linearly with (nangles - 2).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="color">0 for white runs, 1 for black runs</param>
	<param name="depth">of pixd 8 or 16 bpp</param>
	<param name="nangles">2, 4, 6 or 8</param>
	<returns>pixd 8 or 16 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRunlengthTransform(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The dest Pix is 8 or 16 bpp, with the pixel values
 equal to the runlength in which it is a member.
 The length is clipped to the max pixel value if necessary.
 (2) The color determines if we're labelling white or black runs.
 (3) A pixel that is not a member of the chosen color gets
 value 0; it belongs to a run of length 0 of the
 chosen color.
 (4) To convert for maximum dynamic range, either linear or
 log, use pixMaxDynamicRange().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="color">0 for white runs, 1 for black runs</param>
	<param name="direction">L_HORIZONTAL_RUNS, L_VERTICAL_RUNS</param>
	<param name="depth">8 or 16 bpp</param>
	<returns>pixd 8 or 16 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindHorizontalRuns(System.IntPtr,System.Int32,System.Int32[],System.Int32[],System.Int32@)">
	<summary>
 Notes
 (1) This finds foreground horizontal runs on a single scanline.
 (2) To find background runs, use pixInvert() before applying
 this function.
 (3) The xstart and xend arrays are input.  They should be
 of size w/2 + 1 to insure that they can hold
 the maximum number of runs in the raster line.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="y">line to traverse</param>
	<param name="xstart">returns array of start positions for fg runs</param>
	<param name="xend">returns array of end positions for fg runs</param>
	<param name="pn">the number of runs found</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindVerticalRuns(System.IntPtr,System.Int32,System.Int32[],System.Int32[],System.Int32@)">
	<summary>
 Notes
 (1) This finds foreground vertical runs on a single scanline.
 (2) To find background runs, use pixInvert() before applying
 this function.
 (3) The ystart and yend arrays are input.  They should be
 of size h/2 + 1 to insure that they can hold
 the maximum number of runs in the raster line.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="x">line to traverse</param>
	<param name="ystart">returns array of start positions for fg runs</param>
	<param name="yend">returns array of end positions for fg runs</param>
	<param name="pn">the number of runs found</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindMaxRuns(System.IntPtr,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) This finds the longest foreground runs by row or column
 (2) To find background runs, use pixInvert() before applying
 this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="direction">L_HORIZONTAL_RUNS or L_VERTICAL_RUNS</param>
	<param name="pnastart">start locations of longest runs</param>
	<returns>na of lengths of runs, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindMaxHorizontalRunOnLine(System.IntPtr,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This finds the longest foreground horizontal run on a scanline.
 (2) To find background runs, use pixInvert() before applying
 this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="y">line to traverse</param>
	<param name="pxstart">start position</param>
	<param name="psize">the size of the run</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindMaxVerticalRunOnLine(System.IntPtr,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This finds the longest foreground vertical run on a scanline.
 (2) To find background runs, use pixInvert() before applying
 this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="x">column to traverse</param>
	<param name="pystart">start position</param>
	<param name="psize">the size of the run</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.runlengthMembershipOnLine(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Object,System.Int32)">
	<summary>
 Notes
 (1) Converts a set of runlengths into a buffer of
 runlength membership values.
 (2) Initialization of the array gives pixels that are
 not within a run the value 0.
 </summary>
	<remarks>
	</remarks>
	<param name="buffer">into which full line of data is placed</param>
	<param name="size">full size of line; w or h</param>
	<param name="depth">8 or 16 bpp</param>
	<param name="start">array of start positions for fg runs</param>
	<param name="n">the number of runs</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makeMSBitLocTab(System.Int32)">
	<summary>
 Notes
 (1) If bitval == 1, it finds the leftmost ON pixel in a byte;
 otherwise if bitval == 0, it finds the leftmost OFF pixel.
 (2) If there are no pixels of the indicated color in the byte,
 this returns 8.
 </summary>
	<remarks>
	</remarks>
	<param name="bitval">either 0 or 1</param>
	<returns>table giving, for an input byte, the MS bit location, starting at 0 with the MSBit in the byte, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of string ptr array to be alloc'd; use 0 for default</param>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayCreateInitialized(System.Int32,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of string ptr array to be alloc'd</param>
	<param name="initstr">string to be initialized on the full array</param>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayCreateWordsFromString(System.String)">
	<summary>
 Notes
 (1) This finds the number of word substrings, creates an sarray
 of this size, and puts copies of each substring into the sarray.
 </summary>
	<remarks>
	</remarks>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayCreateLinesFromString(System.String,System.Int32)">
	<summary>
 Notes
 (1) This finds the number of line substrings, each of which
 ends with a newline, and puts a copy of each substring
 in a new sarray.
 (2) The newline characters are removed from each substring.
 </summary>
	<remarks>
	</remarks>
	<param name="blankflag">0 to exclude blank lines; 1 to include</param>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayDestroy(System.IntPtr@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the sarray.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="psa">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.sarrayCopy(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<returns>copy of sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayClone(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<returns>ptr to same sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayAddString(System.IntPtr,System.String,System.Int32)">
	<summary>
 Notes
 (1) See usage comments at the top of this file.  L_INSERT is
 equivalent to L_NOCOPY.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="copyflag">L_INSERT, L_NOCOPY or L_COPY</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayRemoveString(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="index">of string within sarray</param>
	<returns>removed string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayReplaceString(System.IntPtr,System.Int32,System.String,System.Int32)">
	<summary>
 Notes
 (1) This destroys an existing string and replaces it with
 the new string or a copy of it.
 (2) By design, an sarray is always compacted, so there are
 never any holes (null ptrs) in the ptr array up to the
 current count.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="index">of string within sarray to be replaced</param>
	<param name="newstr">string to replace existing one</param>
	<param name="copyflag">L_INSERT, L_COPY</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayClear(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<returns>count, or 0 if no strings or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayGetArray(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) Caution the returned array is not a copy, so caller
 must not destroy it!
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="pnalloc">number allocated string ptrs</param>
	<param name="pn">number allocated strings</param>
	<returns>ptr to string array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayGetString(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See usage comments at the top of this file.
 (2) To get a pointer to the string itself, use L_NOCOPY.
 To get a copy of the string, use L_COPY.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="index">to the index-th string</param>
	<param name="copyflag">L_NOCOPY or L_COPY</param>
	<returns>string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayGetRefcount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<returns>refcount, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayChangeRefcount(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="delta">change to be applied</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayToString(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Concatenates all the strings in the sarray, preserving
 all white space.
 (2) If addnlflag != 0, adds either a '\n' or a ' ' after
 each substring.
 (3) This function was NOT implemented as
 for (i = 0; i LT n; i++)
 strcat(dest, sarrayGetString(sa, i, L_NOCOPY));
 Do you see why?
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="addnlflag">flag 0 adds nothing to each substring 1 adds '\n' to each substring 2 adds ' ' to each substring</param>
	<returns>dest string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayToStringRange(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Concatenates the specified strings inthe sarray, preserving
 all white space.
 (2) If addnlflag != 0, adds either a '\n' or a ' ' after
 each substring.
 (3) If the sarray is empty, this returns a string with just
 the character corresponding to %addnlflag.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="first">index of first string to use; starts with 0</param>
	<param name="nstrings">number of strings to append into the result; use 0 to append to the end of the sarray</param>
	<param name="addnlflag">flag 0 adds nothing to each substring 1 adds '\n' to each substring 2 adds ' ' to each substring</param>
	<returns>dest string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayJoin(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Copies of the strings in sarray2 are added to sarray1.
 </summary>
	<remarks>
	</remarks>
	<param name="sa1">to be added to</param>
	<param name="sa2">append to sa1</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayAppendRange(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Copies of the strings in sarray2 are added to sarray1.
 (2) The [start ... end] range is truncated if necessary.
 (3) Use end == -1 to append to the end of sa2.
 </summary>
	<remarks>
	</remarks>
	<param name="sa1">to be added to</param>
	<param name="sa2">append specified range of strings in sa2 to sa1</param>
	<param name="start">index of first string of sa2 to append</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayPadToSameSize(System.IntPtr,System.IntPtr,System.String)">
	<summary>
 Notes
 (1) If two sarrays have different size, this adds enough
 instances of %padstring to the smaller so that they are
 the same size.  It is useful when two or more sarrays
 are being sequenced in parallel, and it is necessary to
 find a valid string at each index.
 </summary>
	<remarks>
	</remarks>
	<param name="sa1"></param>
	<param name="sa2"></param>
	<param name="padstring"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayConvertWordsToLines(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">sa of individual words</param>
	<param name="linesize">max num of chars in each line</param>
	<returns>saout sa of formatted lines, or NULL on error This is useful for re-typesetting text to a specific maximum line length.  The individual words in the input sarray are concatenated into textlines.  An input word string of zero length is taken to be a paragraph separator.  Each time such a string is found, the current line is ended and a new line is also produced that contains just the string of zero length "".  When the output sarray of lines is eventually converted to a string with newlines typically appended to each line string, the empty strings are just converted to newlines, producing the visible paragraph separation. What happens when a word is larger than linesize? We write it out as a single line anyway!  Words preceding or following this long word are placed on lines preceding or following the line with the long word.  Why this choice? Long "words" found in text documents are typically URLs, and it's often desirable not to put newlines in the middle of a URL. The text display program e.g., text editor will typically wrap the long "word" to fit in the window.</returns>
</member><member name="M:LeptonicaSharp.Natives.sarraySplitString(System.IntPtr,System.String,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.sarraySelectBySubstring(System.IntPtr,System.String)">
	<summary>
 Notes
 (1) This selects all strings in sain that have substr as a substring.
 Note that we can't use strncmp() because we're looking for
 a match to the substring anywhere within each filename.
 (2) If substr == NULL, returns a copy of the sarray.
 </summary>
	<remarks>
	</remarks>
	<param name="sain">input sarray</param>
	<param name="substr">substring for matching; can be NULL</param>
	<returns>saout output sarray, filtered with substring or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarraySelectByRange(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This makes %saout consisting of copies of all strings in %sain
 in the index set [first ... last].  Use %last == 0 to get all
 strings from %first to the last string in the sarray.
 </summary>
	<remarks>
	</remarks>
	<param name="sain">input sarray</param>
	<param name="first">index of first string to be selected</param>
	<param name="last">index of last string to be selected; use 0 to go to the end of the sarray</param>
	<returns>saout output sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayParseRange(System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.String,System.Int32)">
	<summary>
 Notes
 (1) This finds the range of the next set of strings in SA,
 beginning the search at 'start', that does NOT have
 the substring 'substr' either at the indicated location
 in the string or anywhere in the string.  The input
 variable 'loc' is the specified offset within the string;
 use -1 to indicate 'anywhere in the string'.
 (2) Always check the return value to verify that a valid range
 was found.
 (3) If a valid range is not found, the values of actstart,
 end and newstart are all set to the size of sa.
 (4) If this is the last valid range, newstart returns the value n.
 In use, this should be tested before calling the function.
 (5) Usage example.  To find all the valid ranges in a file
 where the invalid lines begin with two dashes, copy each
 line in the file to a string in an sarray, and do
 start = 0;
 while (!sarrayParseRange(sa, start, actstart, end, start,
 "--", 0))
 fprintf(stderr, "start = %d, end = %d\n", actstart, end);
 </summary>
	<remarks>
	</remarks>
	<param name="sa">input sarray</param>
	<param name="start">index to start range search</param>
	<param name="pactualstart">index of actual start; may be GT 'start'</param>
	<param name="pend">index of end</param>
	<param name="pnewstart">index of start of next range</param>
	<param name="substr">substring for matching at beginning of string</param>
	<param name="loc">byte offset within the string for the pattern; use -1 if the location does not matter;</param>
	<returns>0 if valid range found; 1 otherwise</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayReadStream(System.IntPtr)">
	<summary>
 Notes
 (1) We store the size of each string along with the string.
 The limit on the number of strings is 2^24.
 The limit on the size of any string is 2^30 bytes.
 (2) This allows a string to have embedded newlines.  By reading
 the entire string, as determined by its size, we are
 not affected by any number of embedded newlines.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization in ascii</param>
	<param name="size">of data; can use strlen to get it</param>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="sa">string array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This appends a '\n' to each string, which is stripped
 off by sarrayReadStream().
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="sa">string array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) Serializes a sarray in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized sarray; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="sa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayAppend(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="sa"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getNumberedPathnamesInDirectory(System.String,System.String,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Returns the full pathnames of the numbered filenames in
 the directory.  The number in the filename is the index
 into the sarray.  For indices for which there are no filenames,
 an empty string ("") is placed into the sarray.
 This makes reading numbered files very simple.  For example,
 the image whose filename includes number N can be retrieved using
 pixReadIndexed(sa, N);
 (2) If %substr is not NULL, only filenames that contain
 the substring can be included.  If %substr is NULL,
 all matching filenames are used.
 (3) If no numbered files are found, it returns an empty sarray,
 with no initialized strings.
 (4) It is assumed that the page number is contained within
 the basename (the filename without directory or extension).
 %numpre is the number of characters in the basename
 preceding the actual page number; %numpost is the number
 following the page number, up to either the end of the
 basename or a ".", whichever comes first.
 (5) This is useful when all filenames contain numbers that are
 not necessarily consecutive.  0-padding is not required.
 (6) To use a O(n) matching algorithm, the largest page number
 is found and two internal arrays of this size are created.
 This maximum is constrained not to exceed %maxsum,
 to make sure that an unrealistically large number is not
 accidentally used to determine the array sizes.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="numpre">number of characters in name before number</param>
	<param name="numpost">number of characters in name after the number, up to a dot before an extension</param>
	<param name="maxnum">only consider page numbers up to this value</param>
	<returns>sarray of numbered pathnames, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getSortedPathnamesInDirectory(System.String,System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Use %substr to filter filenames in the directory.  If
 %substr == NULL, this takes all files.
 (2) The files in the directory, after optional filtering by
 the substring, are lexically sorted in increasing order.
 Use %first and %nfiles to select a contiguous set of files.
 (3) The full pathnames are returned for the requested sequence.
 If no files are found after filtering, returns an empty sarray.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="first">0-based</param>
	<param name="nfiles">use 0 for all to the end</param>
	<returns>sarray of sorted pathnames, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertSortedToNumberedPathnames(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Typically, numpre = numpost = 0; e.g., when the filename
 just has a number followed by an optional extension.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">sorted pathnames including zero-padded integers</param>
	<param name="numpre">number of characters in name before number</param>
	<param name="numpost">number of characters in name after the number, up to a dot before an extension</param>
	<param name="maxnum">only consider page numbers up to this value</param>
	<returns>sarray of numbered pathnames, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getFilenamesInDirectory(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.sarraySort(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Set saout = sain for in-place; otherwise, set naout = NULL.
 (2) Shell sort, modified from KR, 2nd edition, p.62.
 Slow but simple O(n logn) sort.
 </summary>
	<remarks>
	</remarks>
	<param name="saout">output sarray; can be NULL or equal to sain</param>
	<param name="sain">input sarray</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>saout output sarray, sorted by ascii value, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarraySortByIndex(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sain"></param>
	<param name="naindex">na that maps from the new sarray to the input sarray</param>
	<returns>saout sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.stringCompareLexical(System.String,System.String)">
	<summary>
 Notes
 (1) If the lexical values are identical, return a 0, to
 indicate that no swapping is required to sort the strings.
 </summary>
	<remarks>
	</remarks>
	<param name="str1"></param>
	<param name="str2"></param>
	<returns>1 if str1 GT str2 lexically; 0 otherwise</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayUnionByAset(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Duplicates are removed from the concatenation of the two arrays.
 (2) The key for each string is a 64-bit hash.
 (2) Algorithm Concatenate the two sarrays.  Then build a set,
 using hashed strings as keys.  As the set is built, first do
 a find; if not found, add the key to the set and add the string
 to the output sarray.  This is O(nlogn).
 </summary>
	<remarks>
	</remarks>
	<param name="sa1"></param>
	<param name="sa2"></param>
	<returns>sad with the union of the string set, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayRemoveDupsByAset(System.IntPtr)">
	<summary>
 Notes
 (1) This is O(nlogn), considerably slower than
 sarrayRemoveDupsByHash() for large string arrays.
 (2) The key for each string is a 64-bit hash.
 (3) Build a set, using hashed strings as keys.  As the set is
 built, first do a find; if not found, add the key to the
 set and add the string to the output sarray.
 </summary>
	<remarks>
	</remarks>
	<param name="sas"></param>
	<returns>sad with duplicates removed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayIntersectionByAset(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Algorithm put the larger sarray into a set, using the string
 hashes as the key values.  Then run through the smaller sarray,
 building an output sarray and a second set from the strings
 in the larger array if a string is in the first set but
 not in the second, add the string to the output sarray and hash
 it into the second set.  The second set is required to make
 sure only one instance of each string is put into the output sarray.
 This is O(mlogn), {m,n} = sizes of {smaller,larger} input arrays.
 </summary>
	<remarks>
	</remarks>
	<param name="sa1"></param>
	<param name="sa2"></param>
	<returns>sad with the intersection of the string set, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_asetCreateFromSarray(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa"></param>
	<returns>set using a string hash into a uint64 as the key</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayRemoveDupsByHash(System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) Generates a sarray with unique values.
 (2) The dnahash is built up with sad to assure uniqueness.
 It can be used to find if a string is in the set
 sarrayFindValByHash(sad, dahash, str, index)
 (3) The hash of the string location is simple and fast.  It scales
 up with the number of buckets to insure a fairly random
 bucket selection input strings.
 (4) This is faster than sarrayRemoveDupsByAset(), because the
 bucket lookup is O(n), although there is a double-loop
 lookup within the dna in each bucket.
 </summary>
	<remarks>
	</remarks>
	<param name="sas"></param>
	<param name="psad">unique set of strings; duplicates removed</param>
	<param name="pdahash">dnahash used for lookup</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayIntersectionByHash(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) This is faster than sarrayIntersectionByAset(), because the
 bucket lookup is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="sa1"></param>
	<param name="sa2"></param>
	<returns>sad intersection of the strings, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayFindStringByHash(System.IntPtr,System.IntPtr,System.String,System.Int32@)">
	<summary>
 Notes
 (1) Fast lookup in dnaHash associated with a sarray, to see if a
 random string %str is already stored in the hash table.
 (2) We use a strong hash function to minimize the chance that
 two different strings hash to the same key value.
 (3) We select the number of buckets to be about 5% of the size
 of the input sarray, so that when fully populated, each
 bucket (dna) will have about 20 entries, each being an index
 into sa.  In lookup, after hashing to the key, and then
 again to the bucket, we traverse the bucket (dna), using the
 index into sa to check if %str has been found before.
 </summary>
	<remarks>
	</remarks>
	<param name="sa"></param>
	<param name="dahash">built from sa</param>
	<param name="str">arbitrary string</param>
	<param name="pindex">index into %sa if %str is in %sa; -1 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_dnaHashCreateFromSarray(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa"></param>
	<returns>dahash, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayGenerateIntegers(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n"></param>
	<returns>sa  (of printed numbers, 1 - n, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sarrayLookupCSKV(System.IntPtr,System.String,System.IntPtr@)">
	<summary>
 Notes
 (1) The input %sa can have other strings that are not in
 comma-separated key-value format.  These will be ignored.
 (2) This returns a copy of the first value string in %sa whose
 key string matches the input %keystring.
 (3) White space is not ignored; all white space before the ','
 is used for the keystring in matching.  This allows the
 key and val strings to have white space (e.g., multiple words).
 </summary>
	<remarks>
	</remarks>
	<param name="sa">(of strings, each being a comma-separated pair of strings, the first being a key and the second a value)</param>
	<param name="keystring">(an input string to match with each key in %sa</param>
	<param name="pvalstring">(the returned value string corresponding to the input key string, if found; otherwise NULL)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScale(System.IntPtr,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 and 32 bpp</param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<returns>pixd, or NULL on error This function scales 32 bpp RGB; 2, 4 or 8 bpp palette color; 2, 4, 8 or 16 bpp gray; and binary images. When the input has palette color, the colormap is removed and the result is either 8 bpp gray or 32 bpp RGB, depending on whether the colormap has color entries.  Images with 2, 4 or 16 bpp are converted to 8 bpp. Because pixScale is meant to be a very simple interface to a number of scaling functions, including the use of unsharp masking, the type of scaling and the sharpening parameters are chosen by default.  Grayscale and color images are scaled using one of four methods, depending on the scale factors 1 antialiased subsampling (lowpass filtering followed by subsampling, implemented here by area mapping), for scale factors less than 0.2 2 antialiased subsampling with sharpening, for scale factors between 0.2 and 0.7 3 linear interpolation with sharpening, for scale factors between 0.7 and 1.4 4 linear interpolation without sharpening, for scale factors GT= 1.4. One could use subsampling for scale factors very close to 1.0, because it preserves sharp edges.  Linear interpolation blurs edges because the dest pixels will typically straddle two src edge pixels.  Subsmpling removes entire columns and rows, so the edge is not blurred.  However, there are two reasons for not doing this. First, it moves edges, so that a straight line at a large angle to both horizontal and vertical will have noticeable kinks where horizontal and vertical rasters are removed.  Second, although it is very fast, you get good results on sharp edges by applying a sharpening filter. For images with sharp edges, sharpening substantially improves the image quality for scale factors between about 0.2 and about 2.0. pixScale uses a small amount of sharpening by default because it strengthens edge pixels that are weak due to anti-aliasing. The default sharpening factors are for scaling factors LT 0.7   sharpfract = 0.2    sharpwidth = 1 for scaling factors GT= 0.7  sharpfract = 0.4    sharpwidth = 2 The cases where the sharpening halfwidth is 1 or 2 have special implementations and are about twice as fast as the general case. However, sharpening is computationally expensive, and one needs to consider the speed-quality tradeoff For upscaling of RGB images, linear interpolation plus default sharpening is about 5 times slower than upscaling alone. For downscaling, area mapping plus default sharpening is about 10 times slower than downscaling alone. When the scale factor is larger than 1.4, the cost of sharpening, which is proportional to image area, is very large compared to the incremental quality improvement, so we cut off the default use of sharpening at 1.4.  Thus, for scale factors greater than 1.4, pixScale only does linear interpolation. In many situations you will get a satisfactory result by scaling without sharpening call pixScaleGeneral with %sharpfract = 0.0. Alternatively, if you wish to sharpen but not use the default value, first call pixScaleGeneral with %sharpfract = 0.0, and then sharpen explicitly using pixUnsharpMasking. Binary images are scaled to binary by sampling the closest pixel, without any low-pass filtering averaging of neighboring pixels. This will introduce aliasing for reductions.  Aliasing can be prevented by using pixScaleToGray instead.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleToSizeRel(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="delw">change in width, in pixels; 0 means no change</param>
	<param name="delh">change in height, in pixels; 0 means no change</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleToSize(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The output scaled image has the dimension(s) you specify
 To specify the width with isotropic scaling, set %hd = 0.
 To specify the height with isotropic scaling, set %wd = 0.
 If both %wd and %hd are specified, the image is scaled
 (in general, anisotropically) to that size.
 It is an error to set both %wd and %hd to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 and 32 bpp</param>
	<param name="wd">target width; use 0 if using height as target</param>
	<param name="hd">target height; use 0 if using width as target</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleGeneral(System.IntPtr,System.Single,System.Single,System.Single,System.Int32)">
	<summary>
 Notes
 (1) See pixScale() for usage.
 (2) This interface may change in the future, as other special
 cases are added.
 (3) The actual sharpening factors used depend on the maximum
 of the two scale factors (maxscale)
 maxscale LT= 0.2  no sharpening
 0.2 LT maxscale LT 1.4   uses the input parameters
 maxscale GT= 1.4  no sharpening
 (4) To avoid sharpening for grayscale and color images with
 scaling factors between 0.2 and 1.4, call this function
 with %sharpfract == 0.0.
 (5) To use arbitrary sharpening in conjunction with scaling,
 call this function with %sharpfract = 0.0, and follow this
 with a call to pixUnsharpMasking() with your chosen parameters.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 and 32 bpp</param>
	<param name="scalex">both GT 0.0</param>
	<param name="scaley">both GT 0.0</param>
	<param name="sharpfract">use 0.0 to skip sharpening</param>
	<param name="sharpwidth">halfwidth of low-pass filter; typ. 1 or 2</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleLI(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) This function should only be used when the scale factors are
 greater than or equal to 0.7, and typically greater than 1.
 If either scale factor is larger than 0.7, we issue a warning
 and call pixScaleGeneral(), which will invoke area mapping
 without sharpening.
 (2) This works on 2, 4, 8, 16 and 32 bpp images, as well as on
 2, 4 and 8 bpp images that have a colormap.  If there is a
 colormap, it is removed to either gray or RGB, depending
 on the colormap.
 (3) This does a linear interpolation on the src image.
 (4) It dispatches to much faster implementations for
 the special cases of 2x and 4x expansion.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4, 8 or 32 bpp; with or without colormap</param>
	<param name="scalex">must both be GT= 0.7</param>
	<param name="scaley">must both be GT= 0.7</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleColorLI(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) If either scale factor is larger than 0.7, we issue a warning
 and call pixScaleGeneral(), which will invoke area mapping
 without sharpening.  This is particularly important for
 document images with sharp edges.
 (2) For the general case, it's about 4x faster to manipulate
 the color pixels directly, rather than to make images
 out of each of the 3 components, scale each component
 using the pixScaleGrayLI(), and combine the results back
 into an rgb image.
 (3) The speed on intel hardware for the general case (not 2x)
 is about 10  10^6 dest-pixels/sec/GHz.  (The special 2x
 case runs at about 80  10^6 dest-pixels/sec/GHz.)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, representing rgb</param>
	<param name="scalex">must both be GT= 0.7</param>
	<param name="scaley">must both be GT= 0.7</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleColor2xLI(System.IntPtr)">
	<summary>
 Notes
 (1) This is a special case of linear interpolated scaling,
 for 2x upscaling.  It is about 8x faster than using
 the generic pixScaleColorLI(), and about 4x faster than
 using the special 2x scale function pixScaleGray2xLI()
 on each of the three components separately.
 (2) The speed on intel hardware is about
 80  10^6 dest-pixels/sec/GHz.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, representing rgb</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleColor4xLI(System.IntPtr)">
	<summary>
 Notes
 (1) This is a special case of color linear interpolated scaling,
 for 4x upscaling.  It is about 3x faster than using
 the generic pixScaleColorLI().
 (2) The speed on intel hardware is about
 30  10^6 dest-pixels/sec/GHz
 (3) This scales each component separately, using pixScaleGray4xLI().
 It would be about 4x faster to inline the color code properly,
 in analogy to scaleColor4xLILow(), and I leave this as
 an exercise for someone who really needs it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, representing rgb</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleGrayLI(System.IntPtr,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, no cmap</param>
	<param name="scalex">must both be GT= 0.7</param>
	<param name="scaley">must both be GT= 0.7</param>
	<returns>pixd, or NULL on error This function is appropriate for upscaling magnification, where the scale factor is GT 1, as well as for a small amount of downscaling reduction, with scale factor GT 0.7.  If the scale factor is LT 0.7, the best result is obtained by area mapping, but this is relatiely expensive.  A less expensive alternative with scale factor LT 0.7 is low-pass filtering followed by subsampling (pixScaleSmooth()), which is effectively a cheap form of area mapping. Some more details follow. For each pixel in the dest, this does a linear interpolation of 4 neighboring pixels in the src. Specifically, consider the UL corner of src and dest pixels.  The UL corner of the dest falls within a src pixel, whose four corners are the UL corners of 4 adjacent src pixels.  The value of the dest is taken by linear interpolation using the values of the four src pixels and the distance of the UL corner of the dest from each corner. If the image is expanded so that the dest pixel is smaller than the src pixel, such interpolation is a reasonable approach.  This interpolation is also good for a small image reduction factor that is not more than a 2x reduction. Note that the linear interpolation algorithm for scaling is identical in form to the area-mapping algorithm for grayscale rotation.  The latter corresponds to a translation of each pixel without scaling. This function is NOT optimal if the scaling involves a large reduction.    If the image is significantly reduced, so that the dest pixel is much larger than the src pixels, this interpolation, which is over src pixels only near the UL corner of the dest pixel, is not going to give a good area-mapping average. Because area mapping for image scaling is considerably more computationally intensive than linear interpolation, we choose not to use it.   For large image reduction, linear interpolation over adjacent src pixels degenerates asymptotically to subsampling.  But subsampling without a low-pass pre-filter causes aliasing by the nyquist theorem.  To avoid aliasing, a low-pass filter e.g., an averaging filter of size roughly equal to the dest pixel i.e., the reduction factor should be applied to the src before subsampling. As an alternative to low-pass filtering and subsampling for large reduction factors, linear interpolation can also be done between the widely separated src pixels in which the corners of the dest pixel lie.  This also is not optimal, as it samples src pixels only near the corners of the dest pixel, and it is not implemented. The speed on circa 2005 Intel hardware for the general case (not 2x) is about 13  10^6 dest-pixels/sec/GHz.  The special 2x case runs at about 100  10^6 dest-pixels/sec/GHz.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleGray2xLI(System.IntPtr)">
	<summary>
 Notes
 (1) This is a special case of gray linear interpolated scaling,
 for 2x upscaling.  It is about 6x faster than using
 the generic pixScaleGrayLI().
 (2) The speed on intel hardware is about
 100  10^6 dest-pixels/sec/GHz
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, not cmapped</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleGray4xLI(System.IntPtr)">
	<summary>
 Notes
 (1) This is a special case of gray linear interpolated scaling,
 for 4x upscaling.  It is about 12x faster than using
 the generic pixScaleGrayLI().
 (2) The speed on intel hardware is about
 160  10^6 dest-pixels/sec/GHz.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, not cmapped</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleGray2xLIThresh(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This does 2x upscale on pixs, using linear interpolation,
 followed by thresholding to binary.
 (2) Buffers are used to avoid making a large grayscale image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="thresh">between 0 and 256</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleGray2xLIDither(System.IntPtr)">
	<summary>
 Notes
 (1) This does 2x upscale on pixs, using linear interpolation,
 followed by Floyd-Steinberg dithering to binary.
 (2) Buffers are used to avoid making a large grayscale image.
 ~ Two line buffers are used for the src, required for the 2x
 LI upscale.
 ~ Three line buffers are used for the intermediate image.
 Two are filled with each 2xLI row operation; the third is
 needed because the upscale and dithering ops are out of sync.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleGray4xLIThresh(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This does 4x upscale on pixs, using linear interpolation,
 followed by thresholding to binary.
 (2) Buffers are used to avoid making a large grayscale image.
 (3) If a full 4x expanded grayscale image can be kept in memory,
 this function is only about 10% faster than separately doing
 a linear interpolation to a large grayscale image, followed
 by thresholding to binary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="thresh">between 0 and 256</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleGray4xLIDither(System.IntPtr)">
	<summary>
 Notes
 (1) This does 4x upscale on pixs, using linear interpolation,
 followed by Floyd-Steinberg dithering to binary.
 (2) Buffers are used to avoid making a large grayscale image.
 ~ Two line buffers are used for the src, required for the
 4xLI upscale.
 ~ Five line buffers are used for the intermediate image.
 Four are filled with each 4xLI row operation; the fifth
 is needed because the upscale and dithering ops are
 out of sync.
 (3) If a full 4x expanded grayscale image can be kept in memory,
 this function is only about 5% faster than separately doing
 a linear interpolation to a large grayscale image, followed
 by error-diffusion dithering to binary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleBySampling(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) This function samples from the source without
 filtering.  As a result, aliasing will occur for
 subsampling (%scalex and/or %scaley LT 1.0).
 (2) If %scalex == 1.0 and %scaley == 1.0, returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp</param>
	<param name="scalex">both GT 0.0</param>
	<param name="scaley">both GT 0.0</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleBySamplingToSize(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This guarantees that the output scaled image has the
 dimension(s) you specify.
 ~ To specify the width with isotropic scaling, set %hd = 0.
 ~ To specify the height with isotropic scaling, set %wd = 0.
 ~ If both %wd and %hd are specified, the image is scaled
 (in general, anisotropically) to that size.
 ~ It is an error to set both %wd and %hd to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 and 32 bpp</param>
	<param name="wd">target width; use 0 if using height as target</param>
	<param name="hd">target height; use 0 if using width as target</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleByIntSampling(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Simple interface to pixScaleBySampling(), for
 isotropic integer reduction.
 (2) If %factor == 1, returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp</param>
	<param name="factor">integer subsampling</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleRGBToGrayFast(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does simultaneous subsampling by an integer factor and
 extraction of the color from the RGB pix.
 (2) It is designed for maximum speed, and is used for quickly
 generating a downsized grayscale image from a higher resolution
 RGB image.  This would typically be used for image analysis.
 (3) The standard color byte order (RGBA) is assumed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="factor">integer reduction factor GT= 1</param>
	<param name="color">one of COLOR_RED, COLOR_GREEN, COLOR_BLUE</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleRGBToBinaryFast(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does simultaneous subsampling by an integer factor and
 conversion from RGB to gray to binary.
 (2) It is designed for maximum speed, and is used for quickly
 generating a downsized binary image from a higher resolution
 RGB image.  This would typically be used for image analysis.
 (3) It uses the green channel to represent the RGB pixel intensity.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<param name="factor">integer reduction factor GT= 1</param>
	<param name="thresh">binarization threshold</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleGrayToBinaryFast(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does simultaneous subsampling by an integer factor and
 thresholding from gray to binary.
 (2) It is designed for maximum speed, and is used for quickly
 generating a downsized binary image from a higher resolution
 gray image.  This would typically be used for image analysis.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="factor">integer reduction factor GT= 1</param>
	<param name="thresh">binarization threshold</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleSmooth(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) This function should only be used when the scale factors are less
 than or equal to 0.7 (i.e., more than about 1.42x reduction).
 If either scale factor is larger than 0.7, we issue a warning
 and call pixScaleGeneral(), which will invoke linear
 interpolation without sharpening.
 (2) This works only on 2, 4, 8 and 32 bpp images, and if there is
 a colormap, it is removed by converting to RGB.  In other
 cases, we issue a warning and call pixScaleGeneral().
 (3) It does simple (flat filter) convolution, with a filter size
 commensurate with the amount of reduction, to avoid antialiasing.
 (4) It does simple subsampling after smoothing, which is appropriate
 for this range of scaling.  Linear interpolation gives essentially
 the same result with more computation for these scale factors,
 so we don't use it.
 (5) The result is the same as doing a full block convolution followed by
 subsampling, but this is faster because the results of the block
 convolution are only computed at the subsampling locations.
 In fact, the computation time is approximately independent of
 the scale factor, because the convolution kernel is adjusted
 so that each source pixel is summed approximately once.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
	<param name="scalex">must both be LT 0.7</param>
	<param name="scaley">must both be LT 0.7</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleSmoothToSize(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See notes in pixScaleSmooth().
 (2) The output scaled image has the dimension(s) you specify
 To specify the width with isotropic scaling, set %hd = 0.
 To specify the height with isotropic scaling, set %wd = 0.
 If both %wd and %hd are specified, the image is scaled
 (in general, anisotropically) to that size.
 It is an error to set both %wd and %hd to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
	<param name="wd">target width; use 0 if using height as target</param>
	<param name="hd">target height; use 0 if using width as target</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleRGBToGray2(System.IntPtr,System.Single,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="rwt">must sum to 1.0</param>
	<param name="gwt">must sum to 1.0</param>
	<param name="bwt">must sum to 1.0</param>
	<returns>pixd, 8 bpp, 2x reduced, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleAreaMap(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) This function should only be used when the scale factors are less
 than or equal to 0.7 (i.e., more than about 1.42x reduction).
 If either scale factor is larger than 0.7, we issue a warning
 and call pixScaleGeneral(), which will invoke linear
 interpolation without sharpening.
 (2) This works only on 2, 4, 8 and 32 bpp images.  If there is
 a colormap, it is removed by converting to RGB.  In other
 cases, we issue a warning and call pixScaleGeneral().
 (3) This is faster than pixScale() because it does not do sharpening.
 (4) It does a relatively expensive area mapping computation, to
 avoid antialiasing.  It is about 2x slower than pixScaleSmooth(),
 but the results are much better on fine text.
 (5) This is typically about 20% faster for the special cases of
 2x, 4x, 8x and 16x reduction.
 (6) Surprisingly, there is no speedup (and a slight quality
 impairment) if you do as many successive 2x reductions as
 possible, ending with a reduction with a scale factor larger
 than 0.5.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
	<param name="scalex">must both be LT= 0.7</param>
	<param name="scaley">must both be LT= 0.7</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleAreaMap2(System.IntPtr)">
	<summary>
 Notes
 (1) This function does an area mapping (average) for 2x
 reduction.
 (2) This works only on 2, 4, 8 and 32 bpp images.  If there is
 a colormap, it is removed by converting to RGB.
 (3) Speed on 3 GHz processor
 Color 160 Mpix/sec
 Gray 700 Mpix/sec
 This contrasts with the speed of the general pixScaleAreaMap()
 Color 35 Mpix/sec
 Gray 50 Mpix/sec
 (4) From (3), we see that this special function is about 4.5x
 faster for color and 14x faster for grayscale
 (5) Consequently, pixScaleAreaMap2() is incorporated into the
 general area map scaling function, for the special cases
 of 2x, 4x, 8x and 16x reduction.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleAreaMapToSize(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See notes in pixScaleAreaMap().
 (2) The output scaled image has the dimension(s) you specify
 To specify the width with isotropic scaling, set %hd = 0.
 To specify the height with isotropic scaling, set %wd = 0.
 If both %wd and %hd are specified, the image is scaled
 (in general, anisotropically) to that size.
 It is an error to set both %wd and %hd to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
	<param name="wd">target width; use 0 if using height as target</param>
	<param name="hd">target height; use 0 if using width as target</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleBinary(System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) This function samples from the source without
 filtering.  As a result, aliasing will occur for
 subsampling (scalex and scaley LT 1.0).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="scalex">both GT 0.0</param>
	<param name="scaley">both GT 0.0</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleToGray(System.IntPtr,System.Single)">
	<summary>
 Notes
 For faster scaling in the range of scalefactors from 0.0625 to 0.5,
 with very little difference in quality, use pixScaleToGrayFast().
 Binary images have sharp edges, so they intrinsically have very
 high frequency content.  To avoid aliasing, they must be low-pass
 filtered, which tends to blur the edges.  How can we keep relatively
 crisp edges without aliasing?  The trick is to do binary upscaling
 followed by a power-of-2 scaleToGray.  For large reductions, where
 you don't end up with much detail, some corners can be cut.
 The intent here is to get high quality reduced grayscale
 images with relatively little computation.  We do binary
 pre-scaling followed by scaleToGrayN() for best results,
 esp. to avoid excess blur when the scale factor is near
 an inverse power of 2.  Where a low-pass filter is required,
 we use simple convolution kernels either the hat filter for
 linear interpolation or a flat filter for larger downscaling.
 Other choices, such as a perfect bandpass filter with infinite extent
 (the sinc) or various approximations to it (e.g., lanczos), are
 unnecessarily expensive.
 The choices made are as follows
 (1) Do binary upscaling before scaleToGrayN() for scalefactors GT 1/8
 (2) Do binary downscaling before scaleToGray8() for scalefactors
 between 1/16 and 1/8.
 (3) Use scaleToGray16() before grayscale downscaling for
 scalefactors less than 1/16
 Another reasonable choice would be to start binary downscaling
 for scalefactors below 1/4, rather than below 1/8 as we do here.
 The general scaling rules, not all of which are used here, go as follows
 (1) For grayscale upscaling, use pixScaleGrayLI().  However,
 note that edges will be visibly blurred for scalefactors
 near (but above) 1.0.  Replication will avoid edge blur,
 and should be considered for factors very near 1.0.
 (2) For grayscale downscaling with a scale factor larger than
 about 0.7, use pixScaleGrayLI().  For scalefactors near
 (but below) 1.0, you tread between Scylla and Charybdis.
 pixScaleGrayLI() again gives edge blurring, but
 pixScaleBySampling() gives visible aliasing.
 (3) For grayscale downscaling with a scale factor smaller than
 about 0.7, use pixScaleSmooth()
 (4) For binary input images, do as much scale to gray as possible
 using the special integer functions (2, 3, 4, 8 and 16).
 (5) It is better to upscale in binary, followed by scaleToGrayN()
 than to do scaleToGrayN() followed by an upscale using either
 LI or oversampling.
 (6) It may be better to downscale in binary, followed by
 scaleToGrayN() than to first use scaleToGrayN() followed by
 downscaling.  For downscaling between 8x and 16x, this is
 a reasonable option.
 (7) For reductions greater than 16x, it's reasonable to use
 scaleToGray16() followed by further grayscale downscaling.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="scalefactor">reduction must be GT 0.0 and LT 1.0</param>
	<returns>pixd 8 bpp, scaled down by scalefactor in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleToGrayFast(System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) See notes in pixScaleToGray() for the basic approach.
 (2) This function is considerably less expensive than pixScaleToGray()
 for scalefactor in the range (0.0625 ... 0.5), and the
 quality is nearly as good.
 (3) Unlike pixScaleToGray(), which does binary upscaling before
 downscaling for scale factors GT= 0.0625, pixScaleToGrayFast()
 first downscales in binary for all scale factors LT 0.5, and
 then does a 2x scale-to-gray as the final step.  For
 scale factors LT 0.0625, both do a 16x scale-to-gray, followed
 by further grayscale reduction.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="scalefactor">reduction must be GT 0.0 and LT 1.0</param>
	<returns>pixd 8 bpp, scaled down by scalefactor in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleToGray2(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, scaled down by 2x in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleToGray3(System.IntPtr)">
	<summary>
 Notes
 (1) Speed is about 100 x 10^6 src-pixels/sec/GHz.
 Another way to express this is it processes 1 src pixel
 in about 10 cycles.
 (2) The width of pixd is truncated is truncated to a factor of 8.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, scaled down by 3x in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleToGray4(System.IntPtr)">
	<summary>
 Notes
 (1) The width of pixd is truncated is truncated to a factor of 2.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, scaled down by 4x in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleToGray6(System.IntPtr)">
	<summary>
 Notes
 (1) The width of pixd is truncated is truncated to a factor of 8.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, scaled down by 6x in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleToGray8(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, scaled down by 8x in each direction, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleToGray16(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, scaled down by 16x in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleToGrayMipmap(System.IntPtr,System.Single)">
	<summary>
 Notes
 This function is here mainly for pedagogical reasons.
 Mip-mapping is widely used in graphics for texture mapping, because
 the texture changes smoothly with scale.  This is accomplished by
 constructing a multiresolution pyramid and, for each pixel,
 doing a linear interpolation between corresponding pixels in
 the two planes of the pyramid that bracket the desired resolution.
 The computation is very efficient, and is implemented in hardware
 in high-end graphics cards.
 We can use mip-mapping for scale-to-gray by using two scale-to-gray
 reduced images (we don't need the entire pyramid) selected from
 the set {2x, 4x, ... 16x}, and interpolating.  However, we get
 severe aliasing, probably because we are subsampling from the
 higher resolution image.  The method is very fast, but the result
 is very poor.  In fact, the results don't look any better than
 either subsampling off the higher-res grayscale image or oversampling
 on the lower-res image.  Consequently, this method should NOT be used
 for generating reduced images, scale-to-gray or otherwise.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="scalefactor">reduction must be GT 0.0 and LT 1.0</param>
	<returns>pixd 8 bpp, scaled down by scalefactor in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleMipmap(System.IntPtr,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) See notes in pixScaleToGrayMipmap().
 (2) This function suffers from aliasing effects that are
 easily seen in document images.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">high res 8 bpp, no cmap</param>
	<param name="pixs2">low res -- 2x reduced -- 8 bpp, no cmap</param>
	<param name="scale">reduction with respect to high res image, GT 0.5</param>
	<returns>8 bpp pix, scaled down by reduction in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExpandReplicate(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp</param>
	<param name="factor">integer scale factor for replicative expansion</param>
	<returns>pixd scaled up, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleGrayMinMax(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The downscaled pixels in pixd are the min, max or (max - min)
 of the corresponding set of xfact  yfact pixels in pixs.
 (2) Using L_CHOOSE_MIN is equivalent to a grayscale erosion,
 using a brick Sel of size (xfact  yfact), followed by
 subsampling within each (xfact  yfact) cell.  Using
 L_CHOOSE_MAX is equivalent to the corresponding dilation.
 (3) Using L_CHOOSE_MAXDIFF finds the difference between max
 and min values in each cell.
 (4) For the special case of downscaling by 2x in both directions,
 pixScaleGrayMinMax2() is about 2x more efficient.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="xfact">x downscaling factor; integer</param>
	<param name="yfact">y downscaling factor; integer</param>
	<param name="type">L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF</param>
	<returns>pixd 8 bpp</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleGrayMinMax2(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Special version for 2x reduction.  The downscaled pixels
 in pixd are the min, max or (max - min) of the corresponding
 set of 4 pixels in pixs.
 (2) The max and min operations are a special case (for levels 1
 and 4) of grayscale analog to the binary rank scaling operation
 pixReduceRankBinary2().  Note, however, that because of
 the photometric definition that higher gray values are
 lighter, the erosion-like L_CHOOSE_MIN will darken
 the resulting image, corresponding to a threshold level 1
 in the binary case.  Likewise, L_CHOOSE_MAX will lighten
 the pixd, corresponding to a threshold level of 4.
 (3) To choose any of the four rank levels in a 2x grayscale
 reduction, use pixScaleGrayRank2().
 (4) This runs at about 70 MPix/sec/GHz of source data for
 erosion and dilation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="type">L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF</param>
	<returns>pixd 8 bpp downscaled by 2x</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleGrayRankCascade(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This performs up to four cascaded 2x rank reductions.
 (2) Use level = 0 to truncate the cascade.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="level1">rank thresholds, in set {0, 1, 2, 3, 4}</param>
	<param name="level2">rank thresholds, in set {0, 1, 2, 3, 4}</param>
	<param name="level3">rank thresholds, in set {0, 1, 2, 3, 4}</param>
	<param name="level4">rank thresholds, in set {0, 1, 2, 3, 4}</param>
	<returns>pixd 8 bpp, downscaled by up to 16x</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleGrayRank2(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Rank 2x reduction.  If rank == 1(4), the downscaled pixels
 in pixd are the min(max) of the corresponding set of
 4 pixels in pixs.  Values 2 and 3 are intermediate.
 (2) This is the grayscale analog to the binary rank scaling operation
 pixReduceRankBinary2().  Here, because of the photometric
 definition that higher gray values are lighter, rank 1 gives
 the darkest pixel, whereas rank 4 gives the lightest pixel.
 This is opposite to the binary rank operation.
 (3) For rank = 1 and 4, this calls pixScaleGrayMinMax2(),
 which runs at about 70 MPix/sec/GHz of source data.
 For rank 2 and 3, this runs 3x slower, at about 25 MPix/sec/GHz.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, no cmap</param>
	<param name="rank">1 (darkest), 2, 3, 4 (lightest)</param>
	<returns>pixd 8 bpp, downscaled by 2x</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleAndTransferAlpha(System.IntPtr,System.IntPtr,System.Single,System.Single)">
	<summary>
 Notes
 (1) This scales the alpha component of pixs and inserts into pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp, scaled image</param>
	<param name="pixs">32 bpp, original unscaled image</param>
	<param name="scalex">both GT 0.0</param>
	<param name="scaley">both GT 0.0</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixScaleWithAlpha(System.IntPtr,System.Single,System.Single,System.IntPtr,System.Single)">
	<summary>
 Notes
 (1) The alpha channel is transformed separately from pixs,
 and aligns with it, being fully transparent outside the
 boundary of the transformed pixs.  For pixels that are fully
 transparent, a blending function like pixBlendWithGrayMask()
 will give zero weight to corresponding pixels in pixs.
 (2) Scaling is done with area mapping or linear interpolation,
 depending on the scale factors.  Default sharpening is done.
 (3) If pixg is NULL, it is generated as an alpha layer that is
 partially opaque, using %fract.  Otherwise, it is cropped
 to pixs if required, and %fract is ignored.  The alpha
 channel in pixs is never used.
 (4) Colormaps are removed to 32 bpp.
 (5) The default setting for the border values in the alpha channel
 is 0 (transparent) for the outermost ring of pixels and
 (0.5  fract  255) for the second ring.  When blended over
 a second image, this
 (a) shrinks the visible image to make a clean overlap edge
 with an image below, and
 (b) softens the edges by weakening the aliasing there.
 Use l_setAlphaMaskBorder() to change these values.
 (6) A subtle use of gamma correction is to remove gamma correction
 before scaling and restore it afterwards.  This is done
 by sandwiching this function between a gamma/inverse-gamma
 photometric transform
 pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);
 pixd = pixScaleWithAlpha(pixt, scalex, scaley, NULL, fract);
 pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);
 pixDestroy(pixt);
 This has the side-effect of producing artifacts in the very
 dark regions.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb or cmapped</param>
	<param name="scalex">must be GT 0.0</param>
	<param name="scaley">must be GT 0.0</param>
	<param name="pixg">8 bpp, can be null</param>
	<param name="fract">between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	<returns>pixd 32 bpp rgba, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfillBinary(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is for binary seedfill (aka "binary reconstruction").
 (2) There are 3 cases
 (a) pixd == null (make a new pixd)
 (b) pixd == pixs (in-place)
 (c) pixd != pixs
 (3) If you know the case, use these patterns for clarity
 (a) pixd = pixSeedfillBinary(NULL, pixs, ...);
 (b) pixSeedfillBinary(pixs, pixs, ...);
 (c) pixSeedfillBinary(pixd, pixs, ...);
 (4) The resulting pixd contains the filled seed.  For some
 applications you want to OR it with the inverse of
 the filling mask.
 (5) The input seed and mask images can be different sizes, but
 in typical use the difference, if any, would be only
 a few pixels in each direction.  If the sizes differ,
 the clipping is handled by the low-level function
 seedfillBinaryLow().
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs; 1 bpp</param>
	<param name="pixs">1 bpp seed</param>
	<param name="pixm">1 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfillBinaryRestricted(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See usage for pixSeedfillBinary(), which has unrestricted fill.
 In pixSeedfillBinary(), the filling distance is unrestricted
 and can be larger than pixs, depending on the topology of
 th mask.
 (2) There are occasions where it is useful not to permit the
 fill to go more than a certain distance into the mask.
 %xmax specifies the maximum horizontal distance allowed
 in the fill; %ymax does likewise in the vertical direction.
 (3) Operationally, the max "distance" allowed for the fill
 is a linear distance from the original seed, independent
 of the actual mask topology.
 (4) Another formulation of this problem, not implemented,
 would use the manhattan distance from the seed, as
 determined by a breadth-first search starting at the seed
 boundaries and working outward where the mask fg allows.
 How this might use the constraints of separate xmax and ymax
 is not clear.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs; 1 bpp</param>
	<param name="pixs">1 bpp seed</param>
	<param name="pixm">1 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<param name="xmax">max distance in x direction of fill into the mask</param>
	<param name="ymax">max distance in y direction of fill into the mask</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixHolesByFilling(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) To get 4-c.c. holes of the 8-c.c. as foreground, use
 4-connected filling; to get 8-c.c. holes of the 4-c.c.
 as foreground, use 8-connected filling.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">4 or 8</param>
	<returns>pixd  inverted image of all holes, or NULL on error Action 1 Start with 1-pixel black border on otherwise white pixd 2 Use the inverted pixs as the filling mask to fill in all the pixels from the border to the pixs foreground 3 OR the result with pixs to have an image with all ON pixels except for the holes. 4 Invert the result to get the holes as foreground</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFillClosedBorders(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Start with 1-pixel black border on otherwise white pixd
 (2) Subtract input pixs to remove border pixels that were
 also on the closed border
 (3) Use the inverted pixs as the filling mask to fill in
 all the pixels from the outer border to the closed border
 on pixs
 (4) Invert the result to get the filled component, including
 the input border
 (5) If the borders are 4-c.c., use 8-c.c. filling, and v.v.
 (6) Closed borders within c.c. that represent holes, etc., are filled.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">filling connectivity 4 or 8</param>
	<returns>pixd  all topologically outer closed borders are filled as connected comonents, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixExtractBorderConnComps(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">filling connectivity 4 or 8</param>
	<returns>pixd  all pixels in the src that are in connected components touching the border, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRemoveBorderConnComps(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This removes all fg components touching the border.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">filling connectivity 4 or 8</param>
	<returns>pixd  all pixels in the src that are not touching the border or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFillBgFromBorder(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This fills all bg components touching the border to fg.
 It is the photometric inverse of pixRemoveBorderConnComps().
 (2) Invert the result to get the "holes" left after this fill.
 This can be done multiple times, extracting holes within
 holes after each pair of fillings.  Specifically, this code
 peels away n successive embeddings of components
 \code
 pix1 = LTinitial imageGT
 for (i = 0; i LT 2  n; i++) {
 pix2 = pixFillBgFromBorder(pix1, 8);
 pixInvert(pix2, pix2);
 pixDestroy(pix1);
 pix1 = pix2;
 }
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">filling connectivity 4 or 8</param>
	<returns>pixd with the background c.c. touching the border filled to foreground, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFillHolesToBoundingRect(System.IntPtr,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) This does not fill holes that are smaller in area than 'minsize'.
 (2) This does not fill holes with an area larger than
 'maxhfract' times the fg area of the c.c.
 (3) This does not expand the fg of the c.c. to bounding rect if
 the fg area is less than 'minfgfract' times the area of the
 bounding rect.
 (4) The decisions are made as follows
 ~ Decide if we are filling the holes; if so, when using
 the fg area, include the filled holes.
 ~ Decide based on the fg area if we are filling to a bounding rect.
 If so, do it.
 If not, fill the holes if the condition is satisfied.
 (5) The choice of minsize depends on the resolution.
 (6) For solidifying image mask regions on printed materials,
 which tend to be rectangular, values for maxhfract
 and minfgfract around 0.5 are reasonable.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="minsize">min number of pixels in the hole</param>
	<param name="maxhfract">max hole area as fraction of fg pixels in the cc</param>
	<param name="minfgfract">min fg area as fraction of bounding rectangle</param>
	<returns>pixd pixs, with some holes possibly filled and some c.c. possibly expanded to their bounding rects, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfillGray(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place filling operation on the seed, pixs,
 where the clipping mask is always above or at the level
 of the seed as it is filled.
 (2) For details of the operation, see the description in
 seedfillGrayLow() and the code there.
 (3) As an example of use, see the description in pixHDome().
 There, the seed is an image where each pixel is a fixed
 amount smaller than the corresponding mask pixel.
 (4) Reference paper 
 L. Vincent, Morphological grayscale reconstruction in image
 analysis applications and efficient algorithms, IEEE Transactions
 on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp seed; filled in place</param>
	<param name="pixm">8 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfillGrayInv(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place filling operation on the seed, pixs,
 where the clipping mask is always below or at the level
 of the seed as it is filled.  Think of filling up a basin
 to a particular level, given by the maximum seed value
 in the basin.  Outside the filled region, the mask
 is above the filling level.
 (2) Contrast this with pixSeedfillGray(), where the clipping mask
 is always above or at the level of the fill.  An example
 of its use is the hdome fill, where the seed is an image
 where each pixel is a fixed amount smaller than the
 corresponding mask pixel.
 (3) The basin fill, pixSeedfillGrayBasin(), is a special case
 where the seed pixel values are generated from the mask,
 and where the implementation uses pixSeedfillGray() by
 inverting both the seed and mask.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp seed; filled in place</param>
	<param name="pixm">8 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfillGraySimple(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place filling operation on the seed, pixs,
 where the clipping mask is always above or at the level
 of the seed as it is filled.
 (2) For details of the operation, see the description in
 seedfillGrayLowSimple() and the code there.
 (3) As an example of use, see the description in pixHDome().
 There, the seed is an image where each pixel is a fixed
 amount smaller than the corresponding mask pixel.
 (4) Reference paper 
 L. Vincent, Morphological grayscale reconstruction in image
 analysis applications and efficient algorithms, IEEE Transactions
 on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp seed; filled in place</param>
	<param name="pixm">8 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfillGrayInvSimple(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place filling operation on the seed, pixs,
 where the clipping mask is always below or at the level
 of the seed as it is filled.  Think of filling up a basin
 to a particular level, given by the maximum seed value
 in the basin.  Outside the filled region, the mask
 is above the filling level.
 (2) Contrast this with pixSeedfillGraySimple(), where the clipping mask
 is always above or at the level of the fill.  An example
 of its use is the hdome fill, where the seed is an image
 where each pixel is a fixed amount smaller than the
 corresponding mask pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp seed; filled in place</param>
	<param name="pixm">8 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedfillGrayBasin(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This fills from a seed within basins defined by a filling mask.
 The seed value(s) are greater than the corresponding
 filling mask value, and the result has the bottoms of
 the basins raised by the initial seed value.
 (2) The seed has value 255 except where pixb has fg (1), which
 are the seed 'locations'.  At the seed locations, the seed
 value is the corresponding value of the mask pixel in pixm
 plus %delta.  If %delta == 0, we return a copy of pixm.
 (3) The actual filling is done using the standard grayscale filling
 operation on the inverse of the mask and using the inverse
 of the seed image.  After filling, we return the inverse of
 the filled seed.
 (4) As an example of use pixm can describe a grayscale image
 of text, where the (dark) text pixels are basins of
 low values; pixb can identify the local minima in pixm (say, at
 the bottom of the basins); and delta is the amount that we wish
 to raise (lighten) the basins.  We construct the seed
 (a.k.a marker) image from pixb, pixm and %delta.
 </summary>
	<remarks>
	</remarks>
	<param name="pixb">binary mask giving seed locations</param>
	<param name="pixm">8 bpp basin-type filling mask</param>
	<param name="delta">amount of seed value above mask</param>
	<param name="connectivity">4 or 8</param>
	<returns>pixd filled seed if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDistanceFunction(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This computes the distance of each pixel from the nearest
 background pixel.  All bg pixels therefore have a distance of 0,
 and the fg pixel distances increase linearly from 1 at the
 boundary.  It can also be used to compute the distance of
 each pixel from the nearest fg pixel, by inverting the input
 image before calling this function.  Then all fg pixels have
 a distance 0 and the bg pixel distances increase linearly
 from 1 at the boundary.
 (2) The algorithm, described in Leptonica on the page on seed
 filling and connected components, is due to Luc Vincent.
 In brief, we generate an 8 or 16 bpp image, initialized
 with the fg pixels of the input pix set to 1 and the
 1-boundary pixels (i.e., the boundary pixels of width 1 on
 the four sides set as either
 L_BOUNDARY_BG 0
 L_BOUNDARY_FG  max
 where max = 0xff for 8 bpp and 0xffff for 16 bpp.
 Then do raster/anti-raster sweeps over all pixels interior
 to the 1-boundary, where the value of each new pixel is
 taken to be 1 more than the minimum of the previously-seen
 connected pixels (using either 4 or 8 connectivity).
 Finally, set the 1-boundary pixels using the mirrored method;
 this removes the max values there.
 (3) Using L_BOUNDARY_BG clamps the distance to 0 at the
 boundary.  Using L_BOUNDARY_FG allows the distance
 at the image boundary to "float".
 (4) For 4-connected, one could initialize only the left and top
 1-boundary pixels, and go all the way to the right
 and bottom; then coming back reset left and top.  But we
 instead use a method that works for both 4- and 8-connected.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp source</param>
	<param name="connectivity">4 or 8</param>
	<param name="outdepth">8 or 16 bits for pixd</param>
	<param name="boundcond">L_BOUNDARY_BG, L_BOUNDARY_FG</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSeedspread(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) The raster/anti-raster method for implementing this filling
 operation was suggested by Ray Smith.
 (2) This takes an arbitrary set of nonzero pixels in pixs, which
 can be sparse, and spreads (extrapolates) the values to
 fill all the pixels in pixd with the nonzero value it is
 closest to in pixs.  This is similar (though not completely
 equivalent) to doing a Voronoi tiling of the image, with a
 tile surrounding each pixel that has a nonzero value.
 All pixels within a tile are then closer to its "central"
 pixel than to any others.  Then assign the value of the
 "central" pixel to each pixel in the tile.
 (3) This is implemented by computing a distance function in parallel
 with the fill.  The distance function uses free boundary
 conditions (assumed maxval outside), and it controls the
 propagation of the pixels in pixd away from the nonzero
 (seed) values.  This is done in 2 traversals (raster/antiraster).
 In the raster direction, whenever the distance function
 is nonzero, the spread pixel takes on the value of its
 predecessor that has the minimum distance value.  In the
 antiraster direction, whenever the distance function is nonzero
 and its value is replaced by a smaller value, the spread
 pixel takes the value of the predecessor with the minimum
 distance value.
 (4) At boundaries where a pixel is equidistant from two
 nearest nonzero (seed) pixels, the decision of which value
 to use is arbitrary (greedy in search for minimum distance).
 This can give rise to strange-looking results, particularly
 for 4-connectivity where the L1 distance is computed from
 steps in N,S,E and W directions (no diagonals).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp source</param>
	<param name="connectivity">4 or 8</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixLocalExtrema(System.IntPtr,System.Int32,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This gives the actual local minima and maxima.
 A local minimum is a pixel whose surrounding pixels all
 have values at least as large, and likewise for a local
 maximum.  For the local minima, %maxmin is the upper
 bound for the value of pixs.  Likewise, for the local maxima,
 %minmax is the lower bound for the value of pixs.
 (2) The minima are found by starting with the erosion-and-equality
 approach of pixSelectedLocalExtrema().  This is followed
 by a qualification step, where each c.c. in the resulting
 minimum mask is extracted, the pixels bordering it are
 located, and they are queried.  If all of those pixels
 are larger than the value of that minimum, it is a true
 minimum and its c.c. is saved; otherwise the c.c. is
 rejected.  Note that if a bordering pixel has the
 same value as the minimum, it must then have a
 neighbor that is smaller, so the component is not a
 true minimum.
 (3) The maxima are found by inverting the image and looking
 for the minima there.
 (4) The generated masks can be used as markers for
 further operations.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="maxmin">max allowed for the min in a 3x3 neighborhood; use 0 for default which is to have no upper bound</param>
	<param name="minmax">min allowed for the max in a 3x3 neighborhood; use 0 for default which is to have no lower bound</param>
	<param name="ppixmin">mask of local minima</param>
	<param name="ppixmax">mask of local maxima</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSelectedLocalExtrema(System.IntPtr,System.Int32,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This selects those local 3x3 minima that are at least a
 specified distance from the nearest local 3x3 maxima, and v.v.
 for the selected set of local 3x3 maxima.
 The local 3x3 minima is the set of pixels whose value equals
 the value after a 3x3 brick erosion, and the local 3x3 maxima
 is the set of pixels whose value equals the value after
 a 3x3 brick dilation.
 (2) mindist is the minimum distance allowed between
 local 3x3 minima and local 3x3 maxima, in an 8-connected sense.
 mindist == 1 keeps all pixels found in step 1.
 mindist == 0 removes all pixels from each mask that are
 both a local 3x3 minimum and a local 3x3 maximum.
 mindist == 1 removes any local 3x3 minimum pixel that touches a
 local 3x3 maximum pixel, and likewise for the local maxima.
 To make the decision, visualize each local 3x3 minimum pixel
 as being surrounded by a square of size (2  mindist + 1)
 on each side, such that no local 3x3 maximum pixel is within
 that square; and v.v.
 (3) The generated masks can be used as markers for further operations.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="mindist">-1 for keeping all pixels; GT= 0 specifies distance</param>
	<param name="ppixmin">mask of local minima</param>
	<param name="ppixmax">mask of local maxima</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindEqualValues(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) The two images are aligned at the UL corner, and the returned
 image has ON pixels where the pixels in pixs1 and pixs2
 have equal values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">8 bpp</param>
	<param name="pixs2">8 bpp</param>
	<returns>pixd 1 bpp mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSelectMinInConnComp(System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) For each 8 connected component in pixm, this finds
 a pixel in pixs that has the lowest value, and saves
 it in a Pta.  If several pixels in pixs have the same
 minimum value, it picks the first one found.
 (2) For a mask pixm of true local minima, all pixels in each
 connected component have the same value in pixs, so it is
 fastest to select one of them using a special seedfill
 operation.  Not yet implemented.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="pixm">1 bpp</param>
	<param name="ppta">pta of min pixel locations</param>
	<param name="pnav">numa of minima values</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRemoveSeededComponents(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This removes each component in pixm for which there is
 at least one seed in pixs.  If pixd == NULL, this returns
 the result in a new pixd.  Otherwise, it is an in-place
 operation on pixm.  In no situation is pixs altered,
 because we do the filling with a copy of pixs.
 (2) If bordersize GT 0, it also clears all pixels within a
 distance %bordersize of the edge of pixd.  This is here
 because pixLocalExtrema() typically finds local minima
 at the border.  Use %bordersize GT= 2 to remove these.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null or equal to pixm; 1 bpp</param>
	<param name="pixs">1 bpp seed</param>
	<param name="pixm">1 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<param name="bordersize">amount of border clearing</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">initial number of sel ptrs; use 0 for default</param>
	<returns>sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="psela">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.selCreate(System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) selCreate() initializes all values to 0.
 (2) After this call, (cy,cx) and nonzero data values must be
 assigned.  If a text name is not assigned here, it will
 be needed later when the sel is put into a sela.
 </summary>
	<remarks>
	</remarks>
	<param name="height"></param>
	<param name="width"></param>
	<param name="name">sel name; can be null</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="psel">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.selCopy(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<returns>a copy of the sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selCreateBrick(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a rectangular sel of all hits, misses or don't cares.
 </summary>
	<remarks>
	</remarks>
	<param name="h">height, width</param>
	<param name="w">height, width</param>
	<param name="cy">origin, relative to UL corner at 0,0</param>
	<param name="cx">origin, relative to UL corner at 0,0</param>
	<param name="type">SEL_HIT, SEL_MISS, or SEL_DONT_CARE</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selCreateComb(System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates a comb Sel of hits with the origin as
 near the center as possible.
 (2) In use, this is complemented by a brick sel of size %factor1,
 Both brick and comb sels are made by selectComposableSels().
 </summary>
	<remarks>
	</remarks>
	<param name="factor1">contiguous space between comb tines</param>
	<param name="factor2">number of comb tines</param>
	<param name="direction">L_HORIZ, L_VERT</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.create2dIntArray(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The array[sy][sx] is indexed in standard "matrix notation",
 with the row index first.
 </summary>
	<remarks>
	</remarks>
	<param name="sy">rows == height</param>
	<param name="sx">columns == width</param>
	<returns>doubly indexed array i.e., an array of sy row pointers, each of which points to an array of sx ints</returns>
</member><member name="M:LeptonicaSharp.Natives.selaAddSel(System.IntPtr,System.IntPtr,System.String,System.Int32)">
	<summary>
 Notes
 (1) This adds a sel, either inserting or making a copy.
 (2) Because every sel in a sela must have a name, it copies
 the input name if necessary.  You can input NULL for
 selname if the sel already has a name.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="sel">to be added</param>
	<param name="selname">ignored if already defined in sel; req'd in sel when added to a sela</param>
	<param name="copyflag">L_INSERT or L_COPY</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaGetSel(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This returns a ptr to the sel, not a copy, so the caller
 must not destroy it!
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="i">index of sel to be retrieved not copied</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selGetName(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<returns>sel name not copied, or NULL if no name or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selSetName(System.IntPtr,System.String)">
	<summary>
 Notes
 (1) Always frees the existing sel name, if defined.
 (2) If name is not defined, just clears any existing sel name.
 </summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="name">; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaFindSelByName(System.IntPtr,System.String,System.Int32@,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="name">sel name</param>
	<param name="pindex"></param>
	<param name="psel">sel (not a copy)</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selGetElement(System.IntPtr,System.Int32,System.Int32,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="row"></param>
	<param name="col"></param>
	<param name="ptype">SEL_HIT, SEL_MISS, SEL_DONT_CARE</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selSetElement(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Because we use row and column to index into an array,
 they are always non-negative.  The location of the origin
 (and the type of operation) determine the actual
 direction of the rasterop.
 </summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="row"></param>
	<param name="col"></param>
	<param name="type">SEL_HIT, SEL_MISS, SEL_DONT_CARE</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selGetParameters(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="psy">each can be null</param>
	<param name="psx">each can be null</param>
	<param name="pcy">each can be null</param>
	<param name="pcx">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selSetOrigin(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="cy"></param>
	<param name="cx"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selGetTypeAtOrigin(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="ptype">SEL_HIT, SEL_MISS, SEL_DONT_CARE</param>
	<returns>0 if OK; 1 on error or if origin is not found</returns>
</member><member name="M:LeptonicaSharp.Natives.selaGetBrickName(System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="hsize">of brick sel</param>
	<param name="vsize">of brick sel</param>
	<returns>sel name new string, or NULL if no name or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaGetCombName(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Combs are by definition 1-dimensional, either horiz or vert.
 (2) Use this with comb Sels; e.g., from selaAddDwaCombs().
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="size">the product of sizes of the brick and comb parts</param>
	<param name="direction">L_HORIZ, L_VERT</param>
	<returns>sel name new string, or NULL if name not found or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getCompositeParameters(System.Int32,System.Int32@,System.Int32@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) This uses the big lookup table at the top of this file.
 (2) All returned strings are copies that must be freed.
 </summary>
	<remarks>
	</remarks>
	<param name="size"></param>
	<param name="psize1">brick factor size</param>
	<param name="psize2">comb factor size</param>
	<param name="pnameh1">name of horiz brick</param>
	<param name="pnameh2">name of horiz comb</param>
	<param name="pnamev1">name of vert brick</param>
	<param name="pnamev2">name of vert comb</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaGetSelnames(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sa of all sel names, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selFindMaxTranslations(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
  These are the maximum shifts for the erosion operation.
 For example, when j LT cx, the shift of the image
 is +x to the cx.  This is a positive xp shift.
 </summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="pxp">max shifts</param>
	<param name="pyp">max shifts</param>
	<param name="pxn">max shifts</param>
	<param name="pyn">max shifts</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selRotateOrth(System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="quads">0 - 4; number of 90 degree cw rotations</param>
	<returns>seld, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">filename</param>
	<returns>sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">filename</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selReadStream(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">filename</param>
	<param name="sela"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="sela"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selWrite(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">filename</param>
	<param name="sel"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selWriteStream(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="sel"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selCreateFromString(System.String,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) The text is an array of chars (in row-major order) where
 each char can be one of the following
 'x' hit
 'o' miss
 ' ' don't-care
 (2) When the origin falls on a hit or miss, use an upper case
 char (e.g., 'X' or 'O') to indicate it.  When the origin
 falls on a don't-care, indicate this with a 'C'.
 The string must have exactly one origin specified.
 (3) The advantage of this method is that the text can be input
 in a format that shows the 2D layout of the Sel; e.g.,
 \code
 static const char seltext = "x "
 "x Oo "
 "x "
 "xxxxx";
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="text"></param>
	<param name="h">height, width</param>
	<param name="w">height, width</param>
	<param name="name">sel name; can be null</param>
	<returns>sel of the given size, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selPrintToString(System.IntPtr)">
	<summary>
 Notes
 (1) This is an inverse function of selCreateFromString.
 It prints a textual representation of the SEL to a malloc'd
 string.  The format is the same as selCreateFromString
 except that newlines are inserted into the output
 between rows.
 (2) This is useful for debugging.  However, if you want to
 save some Sels in a file, put them in a Sela and write
 them out with selaWrite().  They can then be read in
 with selaRead().
 </summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<returns>str string; caller must free</returns>
</member><member name="M:LeptonicaSharp.Natives.selaCreateFromFile(System.String)">
	<summary>
 Notes
 (1) The file contains a sequence of Sel descriptions.
 (2) Each Sel is formatted as follows
 ~ Any number of comment lines starting with '#' are ignored
 ~ The next line contains the selname
 ~ The next lines contain the Sel data.  They must be
 formatted similarly to the string format in
 selCreateFromString(), with each line beginning and
 ending with a double-quote, and showing the 2D layout.
 ~ Each Sel ends when a blank line, a comment line, or
 the end of file is reached.
 (3) See selCreateFromString() for a description of the string
 format for the Sel data.  As an example, here are the lines
 of is a valid file for a single Sel.  In the file, all lines
 are left-justified
 # diagonal sel
 sel_5diag
 "x "
 " x   "
 "  X  "
 "   x "
 " x"
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selCreateFromPta(System.IntPtr,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) The origin and all points in the pta must be positive.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="cy">origin of sel</param>
	<param name="cx">origin of sel</param>
	<param name="name">sel name; can be null</param>
	<returns>sel of minimum required size, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selCreateFromPix(System.IntPtr,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) The origin must be positive.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="cy">origin of sel</param>
	<param name="cx">origin of sel</param>
	<param name="name">sel name; can be null</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selReadFromColorImage(System.String)">
	<summary>
 Notes
 (1) Loads an image from a file and creates a (hit-miss) sel.
 (2) The sel name is taken from the pathname without the directory
 and extension.
 </summary>
	<remarks>
	</remarks>
	<param name="pathname"></param>
	<returns>sel if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selCreateFromColorPix(System.IntPtr,System.String)">
	<summary>
 Notes
 (1) The sel size is given by the size of pixs.
 (2) In pixs, hits are represented by green pixels, misses by red
 pixels, and don't-cares by white pixels.
 (3) In pixs, there may be no misses, but there must be at least 1 hit.
 (4) At most there can be only one origin pixel, which is optionally
 specified by using a lower-intensity pixel
 if a hit  dark green
 if a miss dark red
 if a don't care gray
 If there is no such pixel, the origin defaults to the approximate
 center of the sel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">cmapped or rgb</param>
	<param name="selname">sel name; can be null</param>
	<returns>sel if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selDisplayInPix(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This gives a visual representation of a general (hit-miss) sel.
 (2) The empty sel is represented by a grid of intersecting lines.
 (3) Three different patterns are generated for the sel elements
 ~ hit (solid black circle)
 ~ miss (black ring; inner radius is radius2)
 ~ origin (cross, XORed with whatever is there)
 </summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="size">of grid interiors; odd; minimum size of 13 is enforced</param>
	<param name="gthick">grid thickness; minimum size of 2 is enforced</param>
	<returns>pix display of sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaDisplayInPix(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This gives a visual representation of all the sels in a sela.
 (2) See notes in selDisplayInPix() for display params of each sel.
 (3) This gives the nicest results when all sels in the sela
 are the same size.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="size">of grid interiors; odd; minimum size of 13 is enforced</param>
	<param name="gthick">grid thickness; minimum size of 2 is enforced</param>
	<param name="spacing">between sels, both horizontally and vertically</param>
	<param name="ncols">number of sels per "line"</param>
	<returns>pix display of all sels in sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaAddBasic(System.IntPtr)">
	<summary>
 Notes
 (1) Adds the following sels
 ~ all linear (horiz, vert) brick sels that are
 necessary for decomposable sels up to size 63
 ~ square brick sels up to size 10
 ~ 4 diagonal sels
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaAddHitMiss(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaAddDwaLinear(System.IntPtr)">
	<summary>
 Notes
 (1) Adds all linear (horizontal, vertical) sels from
 2 to 63 pixels in length, which are the sizes over
 which dwa code can be generated.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaAddDwaCombs(System.IntPtr)">
	<summary>
 Notes
 (1) Adds all comb (horizontal, vertical) Sels that are
 used in composite linear morphological operations
 up to 63 pixels in length, which are the sizes over
 which dwa code can be generated.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaAddCrossJunctions(System.IntPtr,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Adds hitmiss Sels for the intersection of two lines.
 If the lines are very thin, they must be nearly orthogonal
 to register.
 (2) The number of Sels generated is equal to %norient.
 (3) If %norient == 2, this generates 2 Sels of crosses, each with
 two perpendicular lines of hits.  One Sel has horizontal and
 vertical hits; the other has hits along lines at +-45 degrees.
 Likewise, if %norient == 3, this generates 3 Sels of crosses
 oriented at 30 degrees with each other.
 (4) It is suggested that %hlsize be chosen at least 1 greater
 than %mdist.  Try values of (%hlsize, %mdist) such as
 (6,5), (7,6), (8,7), (9,7), etc.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="hlsize">length of each line of hits from origin</param>
	<param name="mdist">distance of misses from the origin</param>
	<param name="norient">number of orientations; max of 8</param>
	<param name="debugflag">1 for debug output</param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.selaAddTJunctions(System.IntPtr,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Adds hitmiss Sels for the T-junction of two lines.
 If the lines are very thin, they must be nearly orthogonal
 to register.
 (2) The number of Sels generated is 4  %norient.
 (3) It is suggested that %hlsize be chosen at least 1 greater
 than %mdist.  Try values of (%hlsize, %mdist) such as
 (6,5), (7,6), (8,7), (9,7), etc.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="hlsize">length of each line of hits from origin</param>
	<param name="mdist">distance of misses from the origin</param>
	<param name="norient">number of orientations; max of 8</param>
	<param name="debugflag">1 for debug output</param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sela4ccThin(System.IntPtr)">
	<summary>
 Notes
 (1) Adds the 9 basic sels for 4-cc thinning.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sela8ccThin(System.IntPtr)">
	<summary>
 Notes
 (1) Adds the 9 basic sels for 8-cc thinning.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sela4and8ccThin(System.IntPtr)">
	<summary>
 Notes
 (1) Adds the 2 basic sels for either 4-cc or 8-cc thinning.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenerateSelWithRuns(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) The horizontal and vertical lines along which elements are
 selected are roughly equally spaced.  The actual locations of
 the hits and misses are the centers of respective run-lengths.
 (2) No elements are selected that are less than 'distance' pixels away
 from a boundary pixel of the same color.  This makes the
 match much more robust to edge noise.  Valid inputs of
 'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or
 greater than 4, we reset it to the default value.
 (3) The 4 numbers for adding rectangles of pixels outside the fg
 can be use if the pattern is expected to be surrounded by bg
 (white) pixels.  On the other hand, if the pattern may be near
 other fg (black) components on some sides, use 0 for those sides.
 (4) The pixels added to a side allow you to have miss elements there.
 There is a constraint between distance, minlength, and
 the added pixels for this to work.  We illustrate using the
 default values.  If you add 5 pixels to the top, and use a
 distance of 1, then you end up with a vertical run of at least
 4 bg pixels along the top edge of the image.  If you use a
 minimum runlength of 3, each vertical line will always find
 a miss near the center of its run.  However, if you use a
 minimum runlength of 5, you will not get a miss on every vertical
 line.  As another example, if you have 7 added pixels and a
 distance of 2, you can use a runlength up to 5 to guarantee
 that the miss element is recorded.  We give a warning if the
 constraint does not guarantee a miss element outside the
 image proper.
 (5) The input pix, as extended by the extra pixels on selected sides,
 can optionally be returned.  For debugging, call
 pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
 on the generating bitmap.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, typically small, to be used as a pattern</param>
	<param name="nhlines">number of hor lines along which elements are found</param>
	<param name="nvlines">number of vert lines along which elements are found</param>
	<param name="distance">min distance from boundary pixel; use 0 for default</param>
	<param name="minlength">min runlength to set hit or miss; use 0 for default</param>
	<param name="toppix">number of extra pixels of bg added above</param>
	<param name="botpix">number of extra pixels of bg added below</param>
	<param name="leftpix">number of extra pixels of bg added to left</param>
	<param name="rightpix">number of extra pixels of bg added to right</param>
	<param name="ppixe">input pix expanded by extra pixels</param>
	<returns>sel hit-miss for input pattern, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenerateSelRandom(System.IntPtr,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) Either of hitfract and missfract can be zero.  If both are zero,
 the sel would be empty, and NULL is returned.
 (2) No elements are selected that are less than 'distance' pixels away
 from a boundary pixel of the same color.  This makes the
 match much more robust to edge noise.  Valid inputs of
 'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or
 greater than 4, we reset it to the default value.
 (3) The 4 numbers for adding rectangles of pixels outside the fg
 can be use if the pattern is expected to be surrounded by bg
 (white) pixels.  On the other hand, if the pattern may be near
 other fg (black) components on some sides, use 0 for those sides.
 (4) The input pix, as extended by the extra pixels on selected sides,
 can optionally be returned.  For debugging, call
 pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
 on the generating bitmap.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, typically small, to be used as a pattern</param>
	<param name="hitfract">fraction of allowable fg pixels that are hits</param>
	<param name="missfract">fraction of allowable bg pixels that are misses</param>
	<param name="distance">min distance from boundary pixel; use 0 for default</param>
	<param name="toppix">number of extra pixels of bg added above</param>
	<param name="botpix">number of extra pixels of bg added below</param>
	<param name="leftpix">number of extra pixels of bg added to left</param>
	<param name="rightpix">number of extra pixels of bg added to right</param>
	<param name="ppixe">input pix expanded by extra pixels</param>
	<returns>sel hit-miss for input pattern, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGenerateSelBoundary(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) All fg elements selected are exactly hitdist pixels away from
 the nearest fg boundary pixel, and ditto for bg elements.
 Valid inputs of hitdist and missdist are 0, 1, 2, 3 and 4.
 For example, a hitdist of 0 puts the hits at the fg boundary.
 Usually, the distances should be GT 0 avoid the effect of
 noise at the boundary.
 (2) Set hitskip LT 0 if no hits are to be used.  Ditto for missskip.
 If both hitskip and missskip are LT 0, the sel would be empty,
 and NULL is returned.
 (3) The 4 flags determine whether the sel is increased on that side
 to allow bg misses to be placed all along that boundary.
 The increase in sel size on that side is the minimum necessary
 to allow the misses to be placed at mindist.  For text characters,
 the topflag and botflag are typically set to 1, and the leftflag
 and rightflag to 0.
 (4) The input pix, as extended by the extra pixels on selected sides,
 can optionally be returned.  For debugging, call
 pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
 on the generating bitmap.
 (5) This is probably the best of the three sel generators, in the
 sense that you have the most flexibility with the smallest number
 of hits and misses.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, typically small, to be used as a pattern</param>
	<param name="hitdist">min distance from fg boundary pixel</param>
	<param name="missdist">min distance from bg boundary pixel</param>
	<param name="hitskip">number of boundary pixels skipped between hits</param>
	<param name="missskip">number of boundary pixels skipped between misses</param>
	<param name="topflag">flag for extra pixels of bg added above</param>
	<param name="botflag">flag for extra pixels of bg added below</param>
	<param name="leftflag">flag for extra pixels of bg added to left</param>
	<param name="rightflag">flag for extra pixels of bg added to right</param>
	<param name="ppixe">input pix expanded by extra pixels</param>
	<returns>sel hit-miss for input pattern, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRunCentersOnLine(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Action this function computes the fg (black) and bg (white)
 pixel runlengths along the specified horizontal or vertical line,
 and returns a Numa of the "center" pixels of each fg run
 whose length equals or exceeds the minimum length.
 (2) This only works on horizontal and vertical lines.
 (3) For horizontal runs, set x = -1 and y to the value
 for all points along the raster line.  For vertical runs,
 set y = -1 and x to the value for all points along the
 pixel column.
 (4) For horizontal runs, the points in the Numa are the x
 values in the center of fg runs that are of length at
 least 'minlength'.  For vertical runs, the points in the
 Numa are the y values in the center of fg runs, again
 of length 'minlength' or greater.
 (5) If there are no fg runs along the line that satisfy the
 minlength constraint, the returned Numa is empty.  This
 is not an error.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="x">set one of these to -1; see notes</param>
	<param name="y">set one of these to -1; see notes</param>
	<param name="minlength">minimum length of acceptable run</param>
	<returns>numa of fg runs, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetRunsOnLine(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Action this function uses the bresenham algorithm to compute
 the pixels along the specified line.  It returns a Numa of the
 runlengths of the fg (black) and bg (white) runs, always
 starting with a white run.
 (2) If the first pixel on the line is black, the length of the
 first returned run (which is white) is 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="x1"></param>
	<param name="y1"></param>
	<param name="x2"></param>
	<param name="y2"></param>
	<returns>numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSubsampleBoundaryPixels(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) If skip = 0, we take all the fg pixels.
 (2) We try to traverse the boundaries in a regular way.
 Some pixels may be missed, and these are then subsampled
 randomly with a fraction determined by 'skip'.
 (3) The most natural approach is to use a depth first (stack-based)
 method to find the fg pixels.  However, the pixel runs are
 4-connected and there are relatively few branches.  So
 instead of doing a proper depth-first search, we get nearly
 the same result using two nested while loops the outer
 one continues a raster-based search for the next fg pixel,
 and the inner one does a reasonable job running along
 each 4-connected coutour.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, with only boundary pixels in fg</param>
	<param name="skip">number to skip between samples as you traverse boundary</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.adjacentOnPixelInRaster(System.IntPtr,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) Search is in 4-connected directions first; then on diagonals.
 This allows traversal along a 4-connected boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="x">current pixel</param>
	<param name="y">current pixel</param>
	<param name="pxa">adjacent ON pixel, found by simple CCW search</param>
	<param name="pya">adjacent ON pixel, found by simple CCW search</param>
	<returns>1 if a pixel is found; 0 otherwise or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDisplayHitMissSel(System.IntPtr,System.IntPtr,System.Int32,System.UInt32,System.UInt32)">
	<summary>
 Notes
 (1) We don't allow scalefactor to be larger than MAX_SEL_SCALEFACTOR
 (2) The colors are conveniently given as 4 bytes in hex format,
 such as 0xff008800.  The least significant byte is ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="sel">hit-miss in general</param>
	<param name="scalefactor">an integer GT= 1; use 0 for default</param>
	<param name="hitcolor">RGB0 color for center of hit pixels</param>
	<param name="misscolor">RGB0 color for center of miss pixels</param>
	<returns>pixd RGB showing both pixs and sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixHShear(System.IntPtr,System.IntPtr,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) There are 3 cases
 (a) pixd == null (make a new pixd)
 (b) pixd == pixs (in-place)
 (c) pixd != pixs
 (2) For these three cases, use these patterns, respectively
 pixd = pixHShear(NULL, pixs, ...);
 pixHShear(pixs, pixs, ...);
 pixHShear(pixd, pixs, ...);
 (3) This shear leaves the horizontal line of pixels at y = yloc
 invariant.  For a positive shear angle, pixels above this
 line are shoved to the right, and pixels below this line
 move to the left.
 (4) With positive shear angle, this can be used, along with
 pixVShear(), to perform a cw rotation, either with 2 shears
 (for small angles) or in the general case with 3 shears.
 (5) Changing the value of yloc is equivalent to translating
 the result horizontally.
 (6) This brings in 'incolor' pixels from outside the image.
 (7) For in-place operation, pixs cannot be colormapped,
 because the in-place operation only blits in 0 or 1 bits,
 not an arbitrary colormap index.
 (8) The angle is brought into the range [-pi, -pi].  It is
 not permitted to be within MIN_DIFF_FROM_HALF_PI radians
 from either -pi/2 or pi/2.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">, this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">no restrictions on depth</param>
	<param name="yloc">location of horizontal line, measured from origin</param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, always</returns>
</member><member name="M:LeptonicaSharp.Natives.pixVShear(System.IntPtr,System.IntPtr,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) There are 3 cases
 (a) pixd == null (make a new pixd)
 (b) pixd == pixs (in-place)
 (c) pixd != pixs
 (2) For these three cases, use these patterns, respectively
 pixd = pixVShear(NULL, pixs, ...);
 pixVShear(pixs, pixs, ...);
 pixVShear(pixd, pixs, ...);
 (3) This shear leaves the vertical line of pixels at x = xloc
 invariant.  For a positive shear angle, pixels to the right
 of this line are shoved downward, and pixels to the left
 of the line move upward.
 (4) With positive shear angle, this can be used, along with
 pixHShear(), to perform a cw rotation, either with 2 shears
 (for small angles) or in the general case with 3 shears.
 (5) Changing the value of xloc is equivalent to translating
 the result vertically.
 (6) This brings in 'incolor' pixels from outside the image.
 (7) For in-place operation, pixs cannot be colormapped,
 because the in-place operation only blits in 0 or 1 bits,
 not an arbitrary colormap index.
 (8) The angle is brought into the range [-pi, -pi].  It is
 not permitted to be within MIN_DIFF_FROM_HALF_PI radians
 from either -pi/2 or pi/2.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">, this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">no restrictions on depth</param>
	<param name="xloc">location of vertical line, measured from origin</param>
	<param name="radang">angle in radians; not too close to +-(pi / 2)</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixHShearCorner(System.IntPtr,System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) See pixHShear() for usage.
 (2) This does a horizontal shear about the UL corner, with (+) shear
 pushing increasingly leftward (-x) with increasing y.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">, if not null, must be equal to pixs</param>
	<param name="pixs"></param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixVShearCorner(System.IntPtr,System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) See pixVShear() for usage.
 (2) This does a vertical shear about the UL corner, with (+) shear
 pushing increasingly downward (+y) with increasing x.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">, if not null, must be equal to pixs</param>
	<param name="pixs"></param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixHShearCenter(System.IntPtr,System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) See pixHShear() for usage.
 (2) This does a horizontal shear about the center, with (+) shear
 pushing increasingly leftward (-x) with increasing y.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">, if not null, must be equal to pixs</param>
	<param name="pixs"></param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixVShearCenter(System.IntPtr,System.IntPtr,System.Single,System.Int32)">
	<summary>
 Notes
 (1) See pixVShear() for usage.
 (2) This does a vertical shear about the center, with (+) shear
 pushing increasingly downward (+y) with increasing x.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">, if not null, must be equal to pixs</param>
	<param name="pixs"></param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixHShearIP(System.IntPtr,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place version of pixHShear(); see comments there.
 (2) This brings in 'incolor' pixels from outside the image.
 (3) pixs cannot be colormapped, because the in-place operation
 only blits in 0 or 1 bits, not an arbitrary colormap index.
 (4) Does a horizontal full-band shear about the line with (+) shear
 pushing increasingly leftward (-x) with increasing y.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="yloc">location of horizontal line, measured from origin</param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixVShearIP(System.IntPtr,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place version of pixVShear(); see comments there.
 (2) This brings in 'incolor' pixels from outside the image.
 (3) pixs cannot be colormapped, because the in-place operation
 only blits in 0 or 1 bits, not an arbitrary colormap index.
 (4) Does a vertical full-band shear about the line with (+) shear
 pushing increasingly downward (+y) with increasing x.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; not colormapped</param>
	<param name="xloc">location of vertical line, measured from origin</param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixHShearLI(System.IntPtr,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This does horizontal shear with linear interpolation for
 accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.
 It is relatively slow compared to the sampled version
 implemented by rasterop, but the result is much smoother.
 (2) This shear leaves the horizontal line of pixels at y = yloc
 invariant.  For a positive shear angle, pixels above this
 line are shoved to the right, and pixels below this line
 move to the left.
 (3) Any colormap is removed.
 (4) The angle is brought into the range [-pi/2 + del, pi/2 - del],
 where del == MIN_DIFF_FROM_HALF_PI.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp or 32 bpp, or colormapped</param>
	<param name="yloc">location of horizontal line, measured from origin</param>
	<param name="radang">angle in radians, in range (-pi/2 ... pi/2)</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd sheared, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixVShearLI(System.IntPtr,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This does vertical shear with linear interpolation for
 accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.
 It is relatively slow compared to the sampled version
 implemented by rasterop, but the result is much smoother.
 (2) This shear leaves the vertical line of pixels at x = xloc
 invariant.  For a positive shear angle, pixels to the right
 of this line are shoved downward, and pixels to the left
 of the line move upward.
 (3) Any colormap is removed.
 (4) The angle is brought into the range [-pi/2 + del, pi/2 - del],
 where del == MIN_DIFF_FROM_HALF_PI.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp or 32 bpp, or colormapped</param>
	<param name="xloc">location of vertical line, measured from origin</param>
	<param name="radang">angle in radians, in range (-pi/2 ... pi/2)</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd sheared, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDeskewBoth(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This binarizes if necessary and does both horizontal
 and vertical deskewing, using the default parameters in
 the underlying pixDeskew().  See usage there.
 (2) This may return a clone.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="redsearch">for binary search reduction factor = 1, 2 or 4; use 0 for default</param>
	<returns>pixd deskewed pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDeskew(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This binarizes if necessary and finds the skew angle.  If the
 angle is large enough and there is sufficient confidence,
 it returns a deskewed image; otherwise, it returns a clone.
 (2) Typical values at 300 ppi for %redsearch are 2 and 4.
 At 75 ppi, one should use %redsearch = 1.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="redsearch">for binary search reduction factor = 1, 2 or 4; use 0 for default</param>
	<returns>pixd deskewed pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindSkewAndDeskew(System.IntPtr,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This binarizes if necessary and finds the skew angle.  If the
 angle is large enough and there is sufficient confidence,
 it returns a deskewed image; otherwise, it returns a clone.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="redsearch">for binary search reduction factor = 1, 2 or 4; use 0 for default</param>
	<param name="pangle">angle required to deskew, in degrees; use NULL to skip</param>
	<param name="pconf">conf value is ratio of max/min scores; use NULL to skip</param>
	<returns>pixd deskewed pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDeskewGeneral(System.IntPtr,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This binarizes if necessary and finds the skew angle.  If the
 angle is large enough and there is sufficient confidence,
 it returns a deskewed image; otherwise, it returns a clone.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="redsweep">for linear search reduction factor = 1, 2 or 4; use 0 for default</param>
	<param name="sweeprange">in degrees in each direction from 0; use 0.0 for default</param>
	<param name="sweepdelta">in degrees; use 0.0 for default</param>
	<param name="redsearch">for binary search reduction factor = 1, 2 or 4; use 0 for default;</param>
	<param name="thresh">for binarizing the image; use 0 for default</param>
	<param name="pangle">angle required to deskew, in degrees; use NULL to skip</param>
	<param name="pconf">conf value is ratio of max/min scores; use NULL to skip</param>
	<returns>pixd deskewed pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindSkew(System.IntPtr,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This is a simple high-level interface, that uses default
 values of the parameters for reasonable speed and accuracy.
 (2) The angle returned is the negative of the skew angle of
 the image.  It is the angle required for deskew.
 Clockwise rotations are positive angles.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pangle">angle required to deskew, in degrees</param>
	<param name="pconf">confidence value is ratio max/min scores</param>
	<returns>0 if OK, 1 on error or if angle measurement not valid</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindSkewSweep(System.IntPtr,System.Single[]@,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) This examines the 'score' for skew angles with equal intervals.
 (2) Caller must check the return value for validity of the result.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pangle">angle required to deskew, in degrees</param>
	<param name="reduction">factor = 1, 2, 4 or 8</param>
	<param name="sweeprange">half the full range; assumed about 0; in degrees</param>
	<param name="sweepdelta">angle increment of sweep; in degrees</param>
	<returns>0 if OK, 1 on error or if angle measurement not valid</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindSkewSweepAndSearch(System.IntPtr,System.Single[]@,System.Single[]@,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This finds the skew angle, doing first a sweep through a set
 of equal angles, and then doing a binary search until
 convergence.
 (2) Caller must check the return value for validity of the result.
 (3) In computing the differential line sum variance score, we sum
 the result over scanlines, but we always skip
 ~ at least one scanline
 ~ not more than 10% of the image height
 ~ not more than 5% of the image width
 (4) See also notes in pixFindSkewSweepAndSearchScore()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pangle">angle required to deskew; in degrees</param>
	<param name="pconf">confidence given by ratio of max/min score</param>
	<param name="redsweep">sweep reduction factor = 1, 2, 4 or 8</param>
	<param name="redsearch">binary search reduction factor = 1, 2, 4 or 8; and must not exceed redsweep</param>
	<param name="sweeprange">half the full range, assumed about 0; in degrees</param>
	<param name="sweepdelta">angle increment of sweep; in degrees</param>
	<param name="minbsdelta">min binary search increment angle; in degrees</param>
	<returns>0 if OK, 1 on error or if angle measurement not valid</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindSkewSweepAndSearchScore(System.IntPtr,System.Single[]@,System.Single[]@,System.Single[]@,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This finds the skew angle, doing first a sweep through a set
 of equal angles, and then doing a binary search until convergence.
 (2) There are two built-in constants that determine if the
 returned confidence is nonzero
 ~ MIN_VALID_MAXSCORE (minimum allowed maxscore)
 ~ MINSCORE_THRESHOLD_CONSTANT (determines minimum allowed
 minscore, by multiplying by (height  width^2)
 If either of these conditions is not satisfied, the returned
 confidence value will be zero.  The maxscore is optionally
 returned in this function to allow evaluation of the
 resulting angle by a method that is independent of the
 returned confidence value.
 (3) The larger the confidence value, the greater the probability
 that the proper alignment is given by the angle that maximizes
 variance.  It should be compared to a threshold, which depends
 on the application.  Values between 3.0 and 6.0 are common.
 (4) By default, the shear is about the UL corner.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pangle">angle required to deskew; in degrees</param>
	<param name="pconf">confidence given by ratio of max/min score</param>
	<param name="pendscore">max score; use NULL to ignore</param>
	<param name="redsweep">sweep reduction factor = 1, 2, 4 or 8</param>
	<param name="redsearch">binary search reduction factor = 1, 2, 4 or 8; and must not exceed redsweep</param>
	<param name="sweepcenter">angle about which sweep is performed; in degrees</param>
	<param name="sweeprange">half the full range, taken about sweepcenter; in degrees</param>
	<param name="sweepdelta">angle increment of sweep; in degrees</param>
	<param name="minbsdelta">min binary search increment angle; in degrees</param>
	<returns>0 if OK, 1 on error or if angle measurement not valid</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindSkewSweepAndSearchScorePivot(System.IntPtr,System.Single[]@,System.Single[]@,System.Single[]@,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Int32)">
	<summary>
 Notes
 (1) See notes in pixFindSkewSweepAndSearchScore().
 (2) This allows choice of shear pivoting from either the UL corner
 or the center.  For small angles, the ability to discriminate
 angles is better with shearing from the UL corner.  However,
 for large angles (say, greater than 20 degrees), it is better
 to shear about the center because a shear from the UL corner
 loses too much of the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pangle">angle required to deskew; in degrees</param>
	<param name="pconf">confidence given by ratio of max/min score</param>
	<param name="pendscore">max score; use NULL to ignore</param>
	<param name="redsweep">sweep reduction factor = 1, 2, 4 or 8</param>
	<param name="redsearch">binary search reduction factor = 1, 2, 4 or 8; and must not exceed redsweep</param>
	<param name="sweepcenter">angle about which sweep is performed; in degrees</param>
	<param name="sweeprange">half the full range, taken about sweepcenter; in degrees</param>
	<param name="sweepdelta">angle increment of sweep; in degrees</param>
	<param name="minbsdelta">min binary search increment angle; in degrees</param>
	<param name="pivot">L_SHEAR_ABOUT_CORNER, L_SHEAR_ABOUT_CENTER</param>
	<returns>0 if OK, 1 on error or if angle measurement not valid</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindSkewOrthogonalRange(System.IntPtr,System.Single[],System.Single[],System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindDifferentialSquareSum(System.IntPtr,System.Single[]@)">
	<summary>
 Notes
 (1) At the top and bottom, we skip
 ~ at least one scanline
 ~ not more than 10% of the image height
 ~ not more than 5% of the image width
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="psum">result</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindNormalizedSquareSum(System.IntPtr,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) Let the image have h scanlines and N fg pixels.
 If the pixels were uniformly distributed on scanlines,
 the sum of squares of fg pixels on each scanline would be
 h  (N / h)^2.  However, if the pixels are not uniformly
 distributed (e.g., for text), the sum of squares of fg
 pixels will be larger.  We return in hratio and vratio the
 ratio of these two values.
 (2) If there are no fg pixels, hratio and vratio are returned as 0.0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="phratio">ratio of normalized horiz square sum to result if the pixel distribution were uniform</param>
	<param name="pvratio">ratio of normalized vert square sum to result if the pixel distribution were uniform</param>
	<param name="pfract">ratio of fg pixels to total pixels</param>
	<returns>0 if OK, 1 on error or if there are no fg pixels</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadStreamSpix(System.IntPtr)">
	<summary>
 Notes
 (1) If called from pixReadStream(), the stream is positioned
 at the beginning of the file.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>pix, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.readHeaderSpix(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If there is a colormap, iscmap is returned as 1; else 0.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pwidth">width</param>
	<param name="pheight">height</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<param name="piscmap">input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.freadHeaderSpix(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If there is a colormap, iscmap is returned as 1; else 0.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pwidth">width</param>
	<param name="pheight">height</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<param name="piscmap">input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sreadHeaderSpix(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If there is a colormap, iscmap is returned as 1; else 0.
 </summary>
	<remarks>
	</remarks>
	<param name="data"></param>
	<param name="pwidth">width</param>
	<param name="pheight">height</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<param name="piscmap">input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamSpix(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadMemSpix(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">const; uncompressed</param>
	<param name="size">bytes of data</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMemSpix(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized, uncompressed pix</param>
	<param name="psize">size of returned data</param>
	<param name="pix">all depths; colormap OK</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSerializeToMemory(System.IntPtr,System.IntPtr@,System.UInt32@)">
	<summary>
 Notes
 (1) This does a fast serialization of the principal elements
 of the pix, as follows
 "spix" (4 bytes) -- ID for file type
 w   (4 bytes)
 h   (4 bytes)
 d   (4 bytes)
 wpl (4 bytes)
 ncolors   (4 bytes) -- in colormap; 0 if there is no colormap
 cdata  (4  ncolors)  -- size of serialized colormap array
 rdatasize (4 bytes) -- size of serialized raster data
 = 4  wpl  h
 rdata  (rdatasize)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths, colormap OK</param>
	<param name="pdata">serialized data in memory</param>
	<param name="pnbytes">number of bytes in data string</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDeserializeFromMemory(System.IntPtr,System.UInt32)">
	<summary>
 Notes
 (1) See pixSerializeToMemory() for the binary format.
 (2) Note the image size limits.
 </summary>
	<remarks>
	</remarks>
	<param name="data">serialized data in memory</param>
	<param name="nbytes">number of bytes in data string</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lstackCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nalloc">initial ptr array size; use 0 for default</param>
	<returns>lstack, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lstackDestroy(System.IntPtr@,System.Int32)">
	<summary>
 Notes
 (1) If freeflag is TRUE, frees each struct in the array.
 (2) If freeflag is FALSE but there are elements on the array,
 gives a warning and destroys the array.  This will
 cause a memory leak of all the items that were on the lstack.
 So if the items require their own destroy function, they
 must be destroyed before the lstack.
 (3) To destroy the lstack, we destroy the ptr array, then
 the lstack, and then null the contents of the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="plstack">to be nulled</param>
	<param name="freeflag">TRUE to free each remaining struct in the array</param>
</member><member name="M:LeptonicaSharp.Natives.lstackAdd(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lstack"></param>
	<param name="item">to be added to the lstack</param>
	<returns>0 if OK; 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.lstackRemove(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lstack"></param>
	<returns>ptr to item popped from the top of the lstack, or NULL if the lstack is empty or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lstackGetCount(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lstack"></param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lstackPrint(System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="lstack"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.strcodeCreate(System.Int32)">
	<summary>
 Notes
 (1) This struct exists to build two files containing code for
 any number of data objects.  The two files are named
 autogen.[fileno].c
 autogen.[fileno].h
 </summary>
	<remarks>
	</remarks>
	<param name="fileno">integer that labels the two output files</param>
	<returns>initialized L_StrCode, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.strcodeCreateFromFile(System.String,System.Int32,System.String)">
	<summary>
 Notes
 (1) The %filein has one filename on each line.
 Comment lines begin with "#".
 (2) The output is 2 files
 autogen.[fileno].c
 autogen.[fileno].h
 </summary>
	<remarks>
	</remarks>
	<param name="filein">containing filenames of serialized data</param>
	<param name="fileno">integer that labels the two output files</param>
	<param name="outdir">if null, files are made in /tmp/lept/auto</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.strcodeGenerate(System.IntPtr,System.String,System.String)">
	<summary>
 Notes
 (1) The generated function name is
 l_autodecode_[fileno]()
 where [fileno] is the index label for the pair of output files.
 (2) To deserialize this data, the function is called with the
 argument 'ifunc', which increments each time strcodeGenerate()
 is called.
 </summary>
	<remarks>
	</remarks>
	<param name="strcode">for accumulating data</param>
	<param name="filein">input file with serialized data</param>
	<param name="type">of data; use the typedef string</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.strcodeFinalize(System.IntPtr@,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pstrcode">destroys after .c and .h files have been generated</param>
	<param name="outdir">if NULL, files are made in /tmp/lept/auto</param>
	<returns>void</returns>
</member><member name="M:LeptonicaSharp.Natives.l_getStructStrFromFile(System.String,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) For example, if %field == L_STR_NAME, and the file is a serialized
 pixa, this will return "Pixa", the name of the struct.
 (2) Caller must free the returned string.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="field">(L_STR_TYPE, L_STR_NAME, L_STR_READER, L_STR_MEMREADER)</param>
	<param name="pstr">struct string for this file</param>
	<returns>0 if found, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindStrokeLength(System.IntPtr,System.Int32[],System.Int32@)">
	<summary>
 Notes
 (1) Returns half the number of fg boundary pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="tab8">table for counting fg pixels; can be NULL</param>
	<param name="plength">estimated length of the strokes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixFindStrokeWidth(System.IntPtr,System.Single,System.Int32[],System.Single[]@,System.IntPtr@)">
	<summary>
 Notes
 (1) This uses two methods to estimate the stroke width
 (a) half the fg boundary length
 (b) a value derived from the histogram of the fg distance transform
 (2) Distance is measured in 8-connected
 (3) %thresh is the minimum fraction N(dist=d)/N(dist=1) of pixels
 required to determine if the pixels at distance d are above
 the noise. It is typically about 0.15.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="thresh">fractional count threshold relative to distance 1</param>
	<param name="tab8">table for counting fg pixels; can be NULL</param>
	<param name="pwidth">estimated width of the strokes</param>
	<param name="pnahisto">histo of pixel distances from bg</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaFindStrokeWidth(System.IntPtr,System.Single,System.Int32[],System.Int32)">
	<summary>
 Notes
 (1) See pixFindStrokeWidth() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp images</param>
	<param name="thresh">fractional count threshold relative to distance 1</param>
	<param name="tab8">table for counting fg pixels; can be NULL</param>
	<param name="debug">1 for debug output; 0 to skip</param>
	<returns>na  array of stroke widths for each pix in %pixa; NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaModifyStrokeWidth(System.IntPtr,System.Single@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixas">of 1 bpp pix</param>
	<param name="targetw">desired width for strokes in each pix</param>
	<returns>pixa  with modified stroke widths, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixModifyStrokeWidth(System.IntPtr,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">of 1 bpp pix</param>
	<param name="width">measured average stroke width</param>
	<param name="targetw">desired stroke width</param>
	<returns>pix  with modified stroke width, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaSetStrokeWidth(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If %thinfirst == 1, thin to a skeleton using the specified
 %connectivity.  Use %thinfirst == 0 if all pix in pixas
 have already been thinned as far as possible.
 (2) The image is dilated to the required %width.  This dilation
 is not connectivity preserving, so this is typically
 used in a situation where merging of c.c. in the individual
 pix is not a problem; e.g., where each pix is a single c.c.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">of 1 bpp pix</param>
	<param name="width">set stroke width to this value, in [1 ... 100].</param>
	<param name="thinfirst">1 to thin all pix to a skeleton first; 0 to skip</param>
	<param name="connectivity">4 or 8, to be used if %thinfirst == 1</param>
	<returns>pixa  with all stroke widths being %width, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetStrokeWidth(System.IntPtr,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See notes in pixaSetStrokeWidth().
 (2) A white border of sufficient width to avoid boundary
 artifacts in the thickening step is added before thinning.
 (3) %connectivity == 8 usually gives a slightly smoother result.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp pix</param>
	<param name="width">set stroke width to this value, in [1 ... 100].</param>
	<param name="thinfirst">1 to thin all pix to a skeleton first; 0 to skip</param>
	<param name="connectivity">4 or 8, to be used if %thinfirst == 1</param>
	<returns>pixd  with stroke width set to %width, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sudokuReadFile(System.String)">
	<summary>
 Notes
 (1) The file format has
 any number of comment lines beginning with '#'
 a set of 9 lines, each having 9 digits (0-9) separated
 by a space
 </summary>
	<remarks>
	</remarks>
	<param name="filename">of formatted sudoku file</param>
	<returns>array of 81 numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sudokuReadString(System.String)">
	<summary>
 Notes
 (1) The string is formatted as 81 single digits, each separated
 by 81 spaces.
 </summary>
	<remarks>
	</remarks>
	<param name="str">of input data</param>
	<returns>array of 81 numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sudokuCreate(System.Int32[])">
	<summary>
 Notes
 (1) The input array has 0 for the unknown values, and 1-9
 for the known initial values.  It is generated from
 a file using sudokuReadInput(), which checks that the file
 data has 81 numbers in 9 rows.
 </summary>
	<remarks>
	</remarks>
	<param name="array">of 81 numbers, 9 rows of 9 numbers each</param>
	<returns>l_sudoku, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sudokuDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="psud">to be nulled</param>
</member><member name="M:LeptonicaSharp.Natives.sudokuSolve(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sud">l_sudoku starting in initial state</param>
	<returns>1 on success, 0 on failure to solve note reversal of typical unix returns</returns>
</member><member name="M:LeptonicaSharp.Natives.sudokuTestUniqueness(System.Int32[],System.Int32@)">
	<summary>
 Notes
 (1) This applies the brute force method to all four 90 degree
 rotations.  If there is more than one solution, it is highly
 unlikely that all four results will be the same;
 consequently, if they are the same, the solution is
 most likely to be unique.
 </summary>
	<remarks>
	</remarks>
	<param name="array">of 81 numbers, 9 lines of 9 numbers each</param>
	<param name="punique">1 if unique, 0 if not</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sudokuGenerate(System.Int32[],System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a brute force generator.  It starts with a completed
 sudoku solution and, by removing elements (setting them to 0),
 generates a valid (unique) sudoku initial condition.
 (2) The process stops when either %minelems, the minimum
 number of non-zero elements, is reached, or when the
 number of attempts to remove the next element exceeds %maxtries.
 (3) No sudoku is known with less than 17 nonzero elements.
 </summary>
	<remarks>
	</remarks>
	<param name="array">of 81 numbers, 9 rows of 9 numbers each</param>
	<param name="seed">random number</param>
	<param name="minelems">min non-zero elements allowed; LT= 80</param>
	<param name="maxtries">max tries to remove a number and get a valid sudoku</param>
	<returns>l_sudoku, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.sudokuOutput(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Prints either the initial array or the current state
 of the solution.
 </summary>
	<remarks>
	</remarks>
	<param name="sud">l_sudoku at any stage</param>
	<param name="arraytype">L_SUDOKU_INIT, L_SUDOKU_STATE</param>
	<returns>void</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddSingleTextblock(System.IntPtr,System.IntPtr,System.String,System.UInt32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This function paints a set of lines of text over an image.
 If %location is L_ADD_ABOVE or L_ADD_BELOW, the pix size
 is expanded with a border and rendered over the border.
 (2) %val is the pixel value to be painted through the font mask.
 It should be chosen to agree with the depth of pixs.
 If it is out of bounds, an intermediate value is chosen.
 For RGB, use hex notation 0xRRGGBB00, where RR is the
 hex representation of the red intensity, etc.
 (3) If textstr == NULL, use the text field in the pix.
 (4) If there is a colormap, this does the best it can to use
 the requested color, or something similar to it.
 (5) Typical usage is for labelling a pix with some text data.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input pix; colormap ok</param>
	<param name="bmf">bitmap font data</param>
	<param name="textstr">text string to be added</param>
	<param name="val">color to set the text</param>
	<param name="location">L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW</param>
	<param name="poverflow">1 if text overflows allocated region and is clipped; 0 otherwise</param>
	<returns>pixd new pix with rendered text, or either a copy or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixAddTextlines(System.IntPtr,System.IntPtr,System.String,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) This function expands an image as required to paint one or
 more lines of text adjacent to the image.  If %bmf == NULL,
 this returns a copy.  If above or below, the lines are
 centered with respect to the image; if left or right, they
 are left justified.
 (2) %val is the pixel value to be painted through the font mask.
 It should be chosen to agree with the depth of pixs.
 If it is out of bounds, an intermediate value is chosen.
 For RGB, use hex notation 0xRRGGBB00, where RR is the
 hex representation of the red intensity, etc.
 (3) If textstr == NULL, use the text field in the pix.  The
 text field contains one or most "lines" of text, where newlines
 are used as line separators.
 (4) If there is a colormap, this does the best it can to use
 the requested color, or something similar to it.
 (5) Typical usage is for labelling a pix with some text data.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input pix; colormap ok</param>
	<param name="bmf">bitmap font data</param>
	<param name="textstr">text string to be added</param>
	<param name="val">color to set the text</param>
	<param name="location">L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
	<returns>pixd new pix with rendered text, or either a copy or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetTextblock(System.IntPtr,System.IntPtr,System.String,System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This function paints a set of lines of text over an image.
 (2) %val is the pixel value to be painted through the font mask.
 It should be chosen to agree with the depth of pixs.
 If it is out of bounds, an intermediate value is chosen.
 For RGB, use hex notation 0xRRGGBB00, where RR is the
 hex representation of the red intensity, etc.
 The last two hex digits are 00 (byte value 0), assigned to
 the A component.  Note that, as usual, RGBA proceeds from
 left to right in the order from MSB to LSB (see pix.h
 for details).
 (3) If there is a colormap, this does the best it can to use
 the requested color, or something similar to it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image</param>
	<param name="bmf">bitmap font data</param>
	<param name="textstr">block text string to be set</param>
	<param name="val">color to set the text</param>
	<param name="x0">left edge for each line of text</param>
	<param name="y0">baseline location for the first text line</param>
	<param name="wtext">max width of each line of generated text</param>
	<param name="firstindent">indentation of first line, in x-widths</param>
	<param name="poverflow">0 if text is contained in input pix; 1 if it is clipped</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSetTextline(System.IntPtr,System.IntPtr,System.String,System.UInt32,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This function paints a line of text over an image.
 (2) %val is the pixel value to be painted through the font mask.
 It should be chosen to agree with the depth of pixs.
 If it is out of bounds, an intermediate value is chosen.
 For RGB, use hex notation 0xRRGGBB00, where RR is the
 hex representation of the red intensity, etc.
 The last two hex digits are 00 (byte value 0), assigned to
 the A component.  Note that, as usual, RGBA proceeds from
 left to right in the order from MSB to LSB (see pix.h
 for details).
 (3) If there is a colormap, this does the best it can to use
 the requested color, or something similar to it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image</param>
	<param name="bmf">bitmap font data</param>
	<param name="textstr">text string to be set on the line</param>
	<param name="val">color to set the text</param>
	<param name="x0">left edge for first char</param>
	<param name="y0">baseline location for all text on line</param>
	<param name="pwidth">width of generated text</param>
	<param name="poverflow">0 if text is contained in input pix; 1 if it is clipped</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaAddTextNumber(System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) Typical usage is for labelling each pix in a pixa with a number.
 (2) This function paints numbers external to each pix, in a position
 given by %location.  In all cases, the pix is expanded on
 on side and the number is painted over white in the added region.
 (3) %val is the pixel value to be painted through the font mask.
 It should be chosen to agree with the depth of pixs.
 If it is out of bounds, an intermediate value is chosen.
 For RGB, use hex notation 0xRRGGBB00, where RR is the
 hex representation of the red intensity, etc.
 (4) If na == NULL, number each pix sequentially, starting with 1.
 (5) If there is a colormap, this does the best it can to use
 the requested color, or something similar to it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">input pixa; colormap ok</param>
	<param name="bmf">bitmap font data</param>
	<param name="na">number array; use 1 ... n if null</param>
	<param name="val">color to set the text</param>
	<param name="location">L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
	<returns>pixad new pixa with rendered numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaAddTextlines(System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) This function adds one or more lines of text externally to
 each pix, in a position given by %location.  In all cases,
 the pix is expanded as necessary to accommodate the text.
 (2) %val is the pixel value to be painted through the font mask.
 It should be chosen to agree with the depth of pixs.
 If it is out of bounds, an intermediate value is chosen.
 For RGB, use hex notation 0xRRGGBB00, where RR is the
 hex representation of the red intensity, etc.
 (3) If sa == NULL, use the text embedded in each pix.  In all
 cases, newlines in the text string are used to separate the
 lines of text that are added to the pix.
 (4) If sa has a smaller count than pixa, issue a warning
 and do not use any embedded text.
 (5) If there is a colormap, this does the best it can to use
 the requested color, or something similar to it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">input pixa; colormap ok</param>
	<param name="bmf">bitmap font data</param>
	<param name="sa">sarray; use text embedded in each pix if null</param>
	<param name="val">color to set the text</param>
	<param name="location">L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
	<returns>pixad new pixa with rendered text, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaAddPixWithText(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr,System.String,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) This function generates a new pix with added text, and adds
 it by insertion into the pixa.
 (2) If the input pixs is not cmapped and not 32 bpp, it is
 converted to 32 bpp rgb.  %val is a standard 32 bpp pixel,
 expressed as 0xrrggbb00.  If there is a colormap, this does
 the best it can to use the requested color, or something close.
 (3) if %bmf == NULL, generate an 8 pt font; this takes about 5 msec.
 (4) If %textstr == NULL, use the text field in the pix.
 (5) In general, the text string can be written in multiple lines;
 use newlines as the separators.
 (6) Typical usage is for debugging, where the pixa of labeled images
 is used to generate a pdf.  Suggest using 1.0 for scalefactor.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pixs">any depth, colormap ok</param>
	<param name="reduction">integer subsampling factor</param>
	<param name="bmf">bitmap font data</param>
	<param name="textstr">text string to be added</param>
	<param name="val">color to set the text</param>
	<param name="location">L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.bmfGetLineStrings(System.IntPtr,System.String,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Divides the input text string into an array of text strings,
 each of which will fit within maxw bits of width.
 </summary>
	<remarks>
	</remarks>
	<param name="bmf"></param>
	<param name="textstr"></param>
	<param name="maxw">max width of a text line in pixels</param>
	<param name="firstindent">indentation of first line, in x-widths</param>
	<param name="ph">height required to hold text bitmap</param>
	<returns>sarray of text strings for each line, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.bmfGetWordWidths(System.IntPtr,System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bmf"></param>
	<param name="textstr"></param>
	<param name="sa">of individual words</param>
	<returns>numa of word lengths in pixels for the font represented by the bmf, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.bmfGetStringWidth(System.IntPtr,System.String,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bmf"></param>
	<param name="textstr"></param>
	<param name="pw">width of text string, in pixels for the font represented by the bmf</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.splitStringToParagraphs(System.String,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="textstr">text string</param>
	<param name="splitflag">see enum in bmf.h; valid values in {1,2,3}</param>
	<returns>sarray where each string is a paragraph of the input, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadTiff(System.String,System.Int32)">
	<summary>
 Notes
 (1) This is a version of pixRead(), specialized for tiff
 files, that allows specification of the page to be returned
 (2) No warning messages on failure, because of how multi-page
 TIFF reading works. You are supposed to keep trying until
 it stops working.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="n">page number 0 based</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadStreamTiff(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) No warning messages on failure, because of how multi-page
 TIFF reading works. You are supposed to keep trying until
 it stops working.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="n">page number 0 based</param>
	<returns>pix, or NULL on error or if there are no more images in the file</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteTiff(System.String,System.IntPtr,System.Int32,System.String)">
	<summary>
 Notes
 (1) For multipage tiff, write the first pix with mode "w" and
 all subsequent pix with mode "a".
 (2) For multipage tiff, there is considerable overhead in the
 machinery to append an image and add the directory entry,
 and the time required for each image increases linearly
 with the number of images in the file.
 </summary>
	<remarks>
	</remarks>
	<param name="filename">to write to</param>
	<param name="pix"></param>
	<param name="comptype">IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	<param name="modestr">"a" or "w"</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteTiffCustom(System.String,System.IntPtr,System.Int32,System.String,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename">to write to</param>
	<param name="pix"></param>
	<param name="comptype">IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	<param name="modestr">"a" or "w"</param>
	<param name="natags">NUMA of custom tiff tags</param>
	<param name="savals">SARRAY of values</param>
	<param name="satypes">SARRAY of types</param>
	<param name="nasizes">NUMA of sizes</param>
	<returns>0 if OK, 1 on error Usage 1 This writes a page image to a tiff file, with optional extra tags defined in tiff.h 2 For multipage tiff, write the first pix with mode "w" and all subsequent pix with mode "a". 3 For the custom tiff tags a The three arrays {natags, savals, satypes} must all be either NULL or defined and of equal size. b If they are defined, the tags are an array of integers, the vals are an array of values in string format, and the types are an array of types in string format. c All valid tags are definined in tiff.h. d The types allowed are the set of strings "char" "l_uint8" "l_uint16" "l_uint32" "l_int32" "l_float64" "l_uint16-l_uint16" note the dash; use it between the two l_uint16 vals in the val string Of these, "char" and "l_uint16" are the most commonly used. e The last array, nasizes, is also optional.  It is for tags that take an array of bytes for a value, a number of elements in the array, and a type that is either "char" or "l_uint8" probably either will work. Use NULL if there are no such tags. f VERY IMPORTANT if there are any tags that require the extra size value, stored in nasizes, they must be written first!</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamTiff(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) This writes a single image to a file stream opened for writing.
 (2) For images with bpp GT 1, this resets the comptype, if
 necessary, to write uncompressed data.
 (3) G3 and G4 are only defined for 1 bpp.
 (4) We only allow PACKBITS for bpp = 1, because for bpp GT 1
 it typically expands images that are not synthetically generated.
 (5) G4 compression is typically about twice as good as G3.
 G4 is excellent for binary compression of text/line-art,
 but terrible for halftones and dithered patterns.  (In
 fact, G4 on halftones can give a file that is larger
 than uncompressed!)  If a binary image has dithered
 regions, it is usually better to compress with png.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix"></param>
	<param name="comptype">IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamTiffWA(System.IntPtr,System.IntPtr,System.Int32,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for append or write</param>
	<param name="pix"></param>
	<param name="comptype">IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	<param name="modestr">"w" or "a"</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadFromMultipageTiff(System.String,System.UInt32@)">
	<summary>
 Notes
 (1) This allows overhead for traversal of a multipage tiff file
 to be linear in the number of images.  This will also work
 with a singlepage tiff file.
 (2) No TIFF internal data structures are exposed to the caller
 (thanks to Jeff Breidenbach).
 (3) offset is the byte offset of a particular image in a multipage
 tiff file. To get the first image in the file, input the
 special offset value of 0.
 (4) The offset is updated to point to the next image, for a
 subsequent call.
 (5) On the last image, the offset returned is 0.  Exit the loop
 when the returned offset is 0.
 (6) For reading a multipage tiff from a memory buffer, see
 pixReadMemFromMultipageTiff()
 (7) Example usage for reading all the images in the tif file
 size_t offset = 0;
 do {
 Pix pix = pixReadFromMultipageTiff(filename, offset);
 // do something with pix
 } while (offset != 0);
 </summary>
	<remarks>
	</remarks>
	<param name="fname">filename</param>
	<param name="poffset">set offset to 0 for first image</param>
	<returns>pix, or NULL on error or if previous call returned the last image</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaReadMultipageTiff(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename">input tiff file</param>
	<returns>pixa of page images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaWriteMultipageTiff(System.String,System.IntPtr)">
	<summary>
 Notes
 (1) The tiff directory overhead is O(n^2).  I have not been
 able to reduce it to O(n).  The overhead for n = 2000 is
 about 1 second.
 </summary>
	<remarks>
	</remarks>
	<param name="fname">input tiff file</param>
	<param name="pixa">any depth; colormap will be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.writeMultipageTiff(System.String,System.String,System.String)">
	<summary>
 Notes
 (1) This writes a set of image files in a directory out
 as a multipage tiff file.  The images can be in any
 initial file format.
 (2) Images with a colormap have the colormap removed before
 re-encoding as tiff.
 (3) All images are encoded losslessly.  Those with 1 bpp are
 encoded 'g4'.  The rest are encoded as 'zip' (flate encoding).
 Because it is lossless, this is an expensive method for
 saving most rgb images.
 (4) The tiff directory overhead is quadratic in the number of
 images.  To avoid this for very large numbers of images to be
 written, apply the method used in pixaWriteMultipageTiff().
 </summary>
	<remarks>
	</remarks>
	<param name="dirin">input directory</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="fileout">output multipage tiff file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.writeMultipageTiffSA(System.IntPtr,System.String)">
	<summary>
 Notes
 (1) See writeMultipageTiff()
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of full path names</param>
	<param name="fileout">output ps file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fprintTiffInfo(System.IntPtr,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpout">stream for output of tag data</param>
	<param name="tiffile">input</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.tiffGetCount(System.IntPtr,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for read</param>
	<param name="pn">number of images</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getTiffResolution(System.IntPtr,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If neither resolution field is set, this is not an error;
 the returned resolution values are 0 (designating 'unknown').
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for read</param>
	<param name="pxres">resolution in ppi</param>
	<param name="pyres">resolution in ppi</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.readHeaderTiff(System.String,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If there is a colormap, cmap is returned as 1; else 0.
 (2) If %n is equal to or greater than the number of images, returns 1.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="n">page image number 0-based</param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<param name="pbps">bits per sample -- 1, 2, 4 or 8</param>
	<param name="pspp">samples per pixel -- 1 or 3</param>
	<param name="pres">resolution in x dir; NULL to ignore</param>
	<param name="pcmap">colormap exists; input NULL to ignore</param>
	<param name="pformat">tiff format; input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.freadHeaderTiff(System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If there is a colormap, cmap is returned as 1; else 0.
 (2) If %n is equal to or greater than the number of images, returns 1.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="n">page image number 0-based</param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<param name="pbps">bits per sample -- 1, 2, 4 or 8</param>
	<param name="pspp">samples per pixel -- 1 or 3</param>
	<param name="pres">resolution in x dir; NULL to ignore</param>
	<param name="pcmap">colormap exists; input NULL to ignore</param>
	<param name="pformat">tiff format; input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.readHeaderMemTiff(System.Byte[],System.UInt32,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.
 </summary>
	<remarks>
	</remarks>
	<param name="cdata">const; tiff-encoded</param>
	<param name="size">size of data</param>
	<param name="n">page image number 0-based</param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<param name="pbps">bits per sample -- 1, 2, 4 or 8</param>
	<param name="pspp">samples per pixel -- 1 or 3</param>
	<param name="pres">resolution in x dir; NULL to ignore</param>
	<param name="pcmap">colormap exists; input NULL to ignore</param>
	<param name="pformat">tiff format; input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.findTiffCompression(System.IntPtr,System.Int32@)">
	<summary>
 Notes
 (1) The returned compression type is that defined in
 the enum in imageio.h.  It is not the tiff flag value.
 (2) The compression type is initialized to IFF_UNKNOWN.
 If it is not one of the specified types, the returned
 type is IFF_TIFF, which indicates no compression.
 (3) When this function is called, the stream must be at BOF.
 If the opened stream is to be used again to read the
 file, it must be rewound to BOF after calling this function.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream; must be rewound to BOF</param>
	<param name="pcomptype">compression type</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.extractG4DataFromFile(System.String,System.IntPtr@,System.UInt32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filein"></param>
	<param name="pdata">binary data of ccitt g4 encoded stream</param>
	<param name="pnbytes">size of binary data</param>
	<param name="pw">image width</param>
	<param name="ph">image height</param>
	<param name="pminisblack">boolean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadMemTiff(System.Byte[],System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) This is a version of pixReadTiff(), where the data is read
 from a memory buffer and uncompressed.
 (2) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.
 (3) No warning messages on failure, because of how multi-page
 TIFF reading works. You are supposed to keep trying until
 it stops working.
 (4) Tiff directory overhead is linear in the input page number.
 If reading many images, use pixReadMemFromMultipageTiff().
 </summary>
	<remarks>
	</remarks>
	<param name="cdata">const; tiff-encoded</param>
	<param name="size">size of cdata</param>
	<param name="n">page image number 0-based</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadMemFromMultipageTiff(System.Byte[],System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) This is a read-from-memory version of pixReadFromMultipageTiff().
 See that function for usage.
 (2) If reading sequentially from the tiff data, this is more
 efficient than pixReadMemTiff(), which has an overhead
 proportional to the image index n.
 (3) Example usage for reading all the images
 size_t offset = 0;
 do {
 Pix pix = pixReadMemFromMultipageTiff(data, size, offset);
 // do something with pix
 } while (offset != 0);
 </summary>
	<remarks>
	</remarks>
	<param name="cdata">const; tiff-encoded</param>
	<param name="size">size of cdata</param>
	<param name="poffset">set offset to 0 for first image</param>
	<returns>pix, or NULL on error or if previous call returned the last image</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaReadMemMultipageTiff(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) This is an O(n) read-from-memory version of pixaReadMultipageTiff().
 </summary>
	<remarks>
	</remarks>
	<param name="data">const; multiple pages; tiff-encoded</param>
	<param name="size">size of cdata</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixaWriteMemMultipageTiff(System.IntPtr@,System.UInt32@,System.IntPtr)">
	<summary>
 Notes
 (1) fopenTiffMemstream() does not work in append mode, so we
 must work-around with a temporary file.
 (2) Getting a file stream from
 open_memstream((char )pdata, psize)
 does not work with the tiff directory.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">const; tiff-encoded</param>
	<param name="psize">size of data</param>
	<param name="pixa">any depth; colormap will be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMemTiff(System.IntPtr@,System.UInt32@,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdata">data of tiff compressed image</param>
	<param name="psize">size of returned data</param>
	<param name="pix"></param>
	<param name="comptype">IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	<returns>0 if OK, 1 on error Usage 1) See pixWriteTiff(.  This version writes to memory instead of to a file.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMemTiffCustom(System.IntPtr@,System.UInt32@,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdata">data of tiff compressed image</param>
	<param name="psize">size of returned data</param>
	<param name="pix"></param>
	<param name="comptype">IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	<param name="natags">NUMA of custom tiff tags</param>
	<param name="savals">SARRAY of values</param>
	<param name="satypes">SARRAY of types</param>
	<param name="nasizes">NUMA of sizes</param>
	<returns>0 if OK, 1 on error Usage 1) See pixWriteTiffCustom(.  This version writes to memory instead of to a file. 2) Use TIFFClose(); TIFFCleanup( doesn't free internal memstream.</returns>
</member><member name="M:LeptonicaSharp.Natives.setMsgSeverity(System.Int32)">
	<summary>
 Notes
 (1) setMsgSeverity() allows the user to specify the desired
 message severity threshold.  Messages of equal or greater
 severity will be output.  The previous message severity is
 returned when the new severity is set.
 (2) If L_SEVERITY_EXTERNAL is passed, then the severity will be
 obtained from the LEPT_MSG_SEVERITY environment variable.
 </summary>
	<remarks>
	</remarks>
	<param name="newsev"></param>
	<returns>oldsev</returns>
</member><member name="M:LeptonicaSharp.Natives.returnErrorInt(System.String,System.String,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="msg">error message</param>
	<param name="procname"></param>
	<param name="ival">return val</param>
	<returns>ival typically 1 for an error return</returns>
</member><member name="M:LeptonicaSharp.Natives.returnErrorFloat(System.String,System.String,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="msg">error message</param>
	<param name="procname"></param>
	<param name="fval">return val</param>
	<returns>fval</returns>
</member><member name="M:LeptonicaSharp.Natives.returnErrorPtr(System.String,System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="msg">error message</param>
	<param name="procname"></param>
	<param name="pval">return val</param>
	<returns>pval typically null</returns>
</member><member name="M:LeptonicaSharp.Natives.filesAreIdentical(System.String,System.String,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname1"></param>
	<param name="fname2"></param>
	<param name="psame">1 if identical; 0 if different</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertOnLittleEnd16(System.UInt16)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.convertOnBigEnd16(System.UInt16)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.convertOnLittleEnd32(System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.convertOnBigEnd32(System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.fileCorruptByDeletion(System.String,System.Single,System.Single,System.String)">
	<summary>
 Notes
 (1) %loc and %size are expressed as a fraction of the file size.
 (2) This makes a copy of the data in %filein, where bytes in the
 specified region have deleted.
 (3) If (%loc + %size) GT= 1.0, this deletes from the position
 represented by %loc to the end of the file.
 (4) It is useful for testing robustness of I/O wrappers when the
 data is corrupted, by simulating data corruption by deletion.
 </summary>
	<remarks>
	</remarks>
	<param name="filein"></param>
	<param name="loc">fractional location of start of deletion</param>
	<param name="size">fractional size of deletion</param>
	<param name="fileout">corrupted file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fileCorruptByMutation(System.String,System.Single,System.Single,System.String)">
	<summary>
 Notes
 (1) %loc and %size are expressed as a fraction of the file size.
 (2) This makes a copy of the data in %filein, where bytes in the
 specified region have been replaced by random data.
 (3) If (%loc + %size) GT= 1.0, this modifies data from the position
 represented by %loc to the end of the file.
 (4) It is useful for testing robustness of I/O wrappers when the
 data is corrupted, by simulating data corruption.
 </summary>
	<remarks>
	</remarks>
	<param name="filein"></param>
	<param name="loc">fractional location of start of randomization</param>
	<param name="size">fractional size of randomization</param>
	<param name="fileout">corrupted file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.genRandomIntegerInRange(System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) For example, to choose a rand integer between 0 and 99,
 use %range = 100.
 </summary>
	<remarks>
	</remarks>
	<param name="range">size of range; must be GT= 2</param>
	<param name="seed">use 0 to skip; otherwise call srand</param>
	<param name="pval">random integer in range {0 ... range-1}</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lept_roundftoi(System.Single)">
	<summary>
 Notes
 (1) For fval GT= 0, fval --GT round(fval) == floor(fval + 0.5)
 For fval LT 0, fval --GT -round(-fval))
 This is symmetric around 0.
 e.g., for fval in (-0.5 ... 0.5), fval --GT 0
 </summary>
	<remarks>
	</remarks>
	<param name="fval"></param>
	<returns>value rounded to int</returns>
</member><member name="M:LeptonicaSharp.Natives.l_hashStringToUint64(System.String,System.IntPtr@)">
	<summary>
 Notes
 (1) The intent of the hash is to avoid collisions by mapping
 the string as randomly as possible into 64 bits.
 (2) To the extent that the hashes are random, the probability of
 a collision can be approximated by the square of the number
 of strings divided by 2^64.  For 1 million strings, the
 collision probability is about 1 in 16 million.
 (3) I expect non-randomness of the distribution to be most evident
 for small text strings.  This hash function has been tested
 for all 5-character text strings composed of 26 letters,
 of which there are 26^5 = 12356630.  There are no hash
 collisions for this set.
 </summary>
	<remarks>
	</remarks>
	<param name="str"></param>
	<param name="phash">hash vale</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_hashPtToUint64(System.Int32,System.Int32,System.IntPtr@)">
	<summary>
 Notes
 (1) I found that a simple hash function has no collisions for
 any of 400 million points with x and y up to 20000.
 (2) Previously used a much more complicated and slower function
 mulp = 26544357894361;
 hash = 104395301;
 hash += (x  mulp) ^ (hash GTGT 5);
 hash ^= (hash LTLT 7);
 hash += (y  mulp) ^ (hash GTGT 7);
 hash = hash ^ (hash LTLT 11);
 Such logical gymnastics to get coverage over the 2^64
 values are not required.
 </summary>
	<remarks>
	</remarks>
	<param name="x"></param>
	<param name="y"></param>
	<param name="phash">hash value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_hashFloat64ToUint64(System.Int32,System.Double,System.IntPtr@)">
	<summary>
 Notes
 (1) Simple, fast hash for using dnaHash with 64-bit data
 (e.g., sets and histograms).
 (2) The resulting hash is called a "key" in a lookup
 operation.  The bucket for %val in a dnaHash is simply
 found by taking the mod of the hash with the number of
 buckets (which is prime).  What gets stored in the
 dna in that bucket could depend on use, but for the most
 flexibility, we store an index into the associated dna.
 This is all that is required for generating either a hash set
 or a histogram (an example of a hash map).
 (3) For example, to generate a histogram, the histogram dna,
 a histogram of unique values aligned with the histogram dna,
 and a dnahash hashmap are built.  See l_dnaMakeHistoByHash().
 </summary>
	<remarks>
	</remarks>
	<param name="nbuckets"></param>
	<param name="val"></param>
	<param name="phash">hash value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.findNextLargerPrime(System.Int32,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="start"></param>
	<param name="pprime">first prime larger than %start</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lept_isPrime(System.UInt64,System.Int32@,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">64-bit unsigned</param>
	<param name="pis_prime">1 if prime, 0 otherwise</param>
	<param name="pfactor">smallest divisor, or 0 on error or if prime</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertIntToGrayCode(System.UInt32)">
	<summary>
 Notes
 (1) Gray code values corresponding to integers differ by
 only one bit transition between successive integers.
 </summary>
	<remarks>
	</remarks>
	<param name="val">integer value</param>
	<returns>corresponding gray code value</returns>
</member><member name="M:LeptonicaSharp.Natives.convertGrayCodeToInt(System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="val">gray code value</param>
	<returns>corresponding integer value</returns>
</member><member name="M:LeptonicaSharp.Natives.getLeptonicaVersion">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.startTimer">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.stopTimer">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.startTimerNested">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.stopTimerNested(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_getCurrentTime(System.Object,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.startWallTimer">
	<summary>
 Notes
 (1) These measure the wall clock time  elapsed between the two calls
 L_WALLTIMER timer = startWallTimer();
 ....
 fprintf(stderr, "Elapsed time = %f sec\n", stopWallTimer(timer);
 (2) Note that the timer object is destroyed by stopWallTimer().
 </summary>
	<remarks>
	</remarks>
	<returns>walltimer-ptr</returns>
</member><member name="M:LeptonicaSharp.Natives.stopWallTimer(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptimer">walltimer-ptr</param>
	<returns>time wall time elapsed in seconds</returns>
</member><member name="M:LeptonicaSharp.Natives.l_getFormattedDate">
	<summary>
 Notes
 (1) This is used in pdf, in the form specified in section 3.8.2 of
 http//partners.adobe.com/public/developer/en/pdf/PDFReference.pdf
 (2) Contributed by Dave Bryan.  Works on all platforms.
 </summary>
	<remarks>
	</remarks>
	<returns>formatted date string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.stringNew(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="src">string</param>
	<returns>dest copy of src string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.stringCopy(System.String,System.String,System.Int32)">
	<summary>
 Notes
 (1) Relatively safe wrapper for strncpy, that checks the input,
 and does not complain if %src is null or %n LT 1.
 If %n LT 1, this is a no-op.
 (2) %dest needs to be at least %n bytes in size.
 (3) We don't call strncpy() because valgrind complains about
 use of uninitialized values.
 </summary>
	<remarks>
	</remarks>
	<param name="dest">existing byte buffer</param>
	<param name="src">string [optional] can be null</param>
	<param name="n">max number of characters to copy</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.stringReplace(System.IntPtr@,System.String)">
	<summary>
 Notes
 (1) Frees any existing dest string
 (2) Puts a copy of src string in the dest
 (3) If either or both strings are null, does something reasonable.
 </summary>
	<remarks>
	</remarks>
	<param name="pdest">string copy</param>
	<param name="src">string [optional] can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.stringLength(System.String,System.UInt32)">
	<summary>
 Notes
 (1) Safe implementation of strlen that only checks size bytes
 for trailing NUL.
 (2) Valid returned string lengths are between 0 and size - 1.
 If size bytes are checked without finding a NUL byte, then
 an error is indicated by returning size.
 </summary>
	<remarks>
	</remarks>
	<param name="src">string can be null or NULL-terminated string</param>
	<param name="size">size of src buffer</param>
	<returns>length of src in bytes.</returns>
</member><member name="M:LeptonicaSharp.Natives.stringCat(System.String,System.UInt32,System.String)">
	<summary>
 Notes
 (1) Alternative implementation of strncat, that checks the input,
 is easier to use (since the size of the dest buffer is specified
 rather than the number of bytes to copy), and does not complain
 if %src is null.
 (2) Never writes past end of dest.
 (3) If it can't append src (an error), it does nothing.
 (4) N.B. The order of 2nd and 3rd args is reversed from that in
 strncat, as in the Windows function strcat_s().
 </summary>
	<remarks>
	</remarks>
	<param name="dest">null-terminated byte buffer</param>
	<param name="size">size of dest</param>
	<param name="src">string can be null or NULL-terminated string</param>
	<returns>number of bytes added to dest; -1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.stringConcatNew(System.String)">
	<summary>
 Notes
 (1) The last arg in the list of strings must be NULL.
 (2) Caller must free the returned string.
 </summary>
	<remarks>
	</remarks>
	<param name="first">first string in list</param>
	<returns>result new string concatenating the input strings, or NULL if first == NULL</returns>
</member><member name="M:LeptonicaSharp.Natives.stringJoin(System.String,System.String)">
	<summary>
 Notes
 (1) This is a safe version of strcat; it makes a new string.
 (2) It is not an error if either or both of the strings
 are empty, or if either or both of the pointers are null.
 </summary>
	<remarks>
	</remarks>
	<param name="src1">string [optional] can be null</param>
	<param name="src2">string [optional] can be null</param>
	<returns>concatenated string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.stringJoinIP(System.IntPtr@,System.String)">
	<summary>
 Notes
 (1) This is a safe in-place version of strcat.  The contents of
 src1 is replaced by the concatenation of src1 and src2.
 (2) It is not an error if either or both of the strings
 are empty (""), or if the pointers to the strings (psrc1, src2)
 are null.
 (3) src1 should be initialized to null or an empty string
 before the first call.  Use one of these
 char src1 = NULL;
 char src1 = stringNew("");
 Then call with
 stringJoinIP(src1, src2);
 (4) This can also be implemented as a macro
 \code
 #define stringJoinIP(src1, src2) \
 {tmpstr = stringJoin((src1),(src2)); \
 LEPT_FREE(src1); \
 (src1) = tmpstr;}
 \endcode
 (5) Another function to consider for joining many strings is
 stringConcatNew().
 </summary>
	<remarks>
	</remarks>
	<param name="psrc1">string address of src1; cannot be on the stack</param>
	<param name="src2">string [optional] can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.stringReverse(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="src">string</param>
	<returns>dest newly-allocated reversed string</returns>
</member><member name="M:LeptonicaSharp.Natives.strtokSafe(System.String,System.String,System.IntPtr@)">
	<summary>
 Notes
 (1) This is a thread-safe implementation of strtok.
 (2) It has the same interface as strtok_r.
 (3) It differs from strtok_r in usage in two respects
 (a) the input string is not altered
 (b) each returned substring is newly allocated and must
 be freed after use.
 (4) Let me repeat that.  This is "safe" because the input
 string is not altered and because each returned string
 is newly allocated on the heap.
 (5) It is here because, surprisingly, some C libraries don't
 include strtok_r.
 (6) Important usage points
 ~ Input the string to be parsed on the first invocation.
 ~ Then input NULL after that; the value returned in saveptr
 is used in all subsequent calls.
 (7) This is only slightly slower than strtok_r.
 </summary>
	<remarks>
	</remarks>
	<param name="seps">a string of character separators</param>
	<param name="psaveptr">ptr to the next char after the last encountered separator</param>
	<returns>substr a new string that is copied from the previous saveptr up to but not including the next separator character, or NULL if end of cstr.</returns>
</member><member name="M:LeptonicaSharp.Natives.stringSplitOnToken(System.String,System.String,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) The input string is not altered; all split parts are new strings.
 (2) The split occurs around the first consecutive sequence of
 tokens encountered.
 (3) The head goes from the beginning of the string up to
 but not including the first token found.
 (4) The tail contains the second part of the string, starting
 with the first char in that part that is NOT a token.
 (5) If no separator token is found, 'head' contains a copy
 of the input string and 'tail' is null.
 </summary>
	<remarks>
	</remarks>
	<param name="seps">a string of character separators</param>
	<param name="phead">ptr to copy of the input string, up to the first separator token encountered</param>
	<param name="ptail">ptr to copy of the part of the input string starting with the first non-separator character that occurs after the first separator is found</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.stringCheckForChars(System.String,System.String,System.Int32@)">
	<summary>
 Notes
 (1) This can be used to sanitize an operation by checking for
 special characters that don't belong in a string.
 </summary>
	<remarks>
	</remarks>
	<param name="src">input string; can be of zero length</param>
	<param name="chars">string of chars to be searched for in %src</param>
	<param name="pfound">1 if any characters are found; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.stringRemoveChars(System.String,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="src">input string; can be of zero length</param>
	<param name="remchars">string of chars to be removed from src</param>
	<returns>dest string with specified chars removed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.stringFindSubstr(System.String,System.String,System.Int32@)">
	<summary>
 Notes
 (1) This is a wrapper around strstr().
 (2) Both %src and %sub must be defined, and %sub must have
 length of at least 1.
 (3) If the substring is not found and loc is returned, it has
 the value -1.
 </summary>
	<remarks>
	</remarks>
	<param name="src">input string; can be of zero length</param>
	<param name="ploc">location of substring in src</param>
	<returns>1 if found; 0 if not found or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.stringReplaceSubstr(System.String,System.String,System.String,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) Replaces the first instance.
 (2) To only remove sub1, use "" for sub2
 (3) Returns a new string if sub1 and sub2 are the same.
 (4) The optional loc is input as the byte offset within the src
 from which the search starts, and after the search it is the
 char position in the string of the next character after
 the substituted string.
 (5) N.B. If ploc is not null, loc must always be initialized.
 To search the string from the beginning, set loc = 0.
 </summary>
	<remarks>
	</remarks>
	<param name="src">input string; can be of zero length</param>
	<param name="sub1">substring to be replaced</param>
	<param name="sub2">substring to put in; can be ""</param>
	<param name="pfound">1 if sub1 is found; 0 otherwise</param>
	<param name="ploc">location of ptr after replacement</param>
	<returns>dest string with substring replaced, or NULL if the substring not found or on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.stringReplaceEachSubstr(System.String,System.String,System.String,System.Int32@)">
	<summary>
 Notes
 (1) Replaces every instance.
 (2) To only remove each instance of sub1, use "" for sub2
 (3) Returns NULL if sub1 and sub2 are the same.
 </summary>
	<remarks>
	</remarks>
	<param name="src">input string; can be of zero length</param>
	<param name="sub1">substring to be replaced</param>
	<param name="sub2">substring to put in; can be ""</param>
	<param name="pcount">the number of times that sub1 is found in src; 0 if not found</param>
	<returns>dest string with substring replaced, or NULL if the substring not found or on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.arrayFindEachSequence(System.Byte[],System.UInt32,System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) The byte arrays %data and %sequence are not C strings,
 as they can contain null bytes.  Therefore, for each
 we must give the length of the array.
 (2) This finds every occurrence in %data of %sequence.
 </summary>
	<remarks>
	</remarks>
	<param name="data">byte array</param>
	<param name="datalen">length of data, in bytes</param>
	<param name="sequence">subarray of bytes to find in data</param>
	<param name="seqlen">length of sequence, in bytes</param>
	<returns>dna of offsets where the sequence is found, or NULL if none are found or on error</returns>
</member><member name="M:LeptonicaSharp.Natives.arrayFindSequence(System.Byte[],System.UInt32,System.Byte[],System.UInt32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The byte arrays 'data' and 'sequence' are not C strings,
 as they can contain null bytes.  Therefore, for each
 we must give the length of the array.
 (2) This searches for the first occurrence in %data of %sequence,
 which consists of %seqlen bytes.  The parameter %seqlen
 must not exceed the actual length of the %sequence byte array.
 (3) If the sequence is not found, the offset will be 0, so you
 must check %found.
 </summary>
	<remarks>
	</remarks>
	<param name="data">byte array</param>
	<param name="datalen">length of data, in bytes</param>
	<param name="sequence">subarray of bytes to find in data</param>
	<param name="seqlen">length of sequence, in bytes</param>
	<param name="poffset">offset from beginning of data where the sequence begins</param>
	<param name="pfound">1 if sequence is found; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.reallocNew(System.IntPtr@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If newsize LT=0, just frees input data and nulls ptr
 (2) If input ptr is null, just callocs new memory
 (3) This differs from realloc in that it always allocates
 new memory (if newsize GT 0) and initializes it to 0,
 it requires the amount of old data to be copied,
 and it takes the address of the input ptr and
 nulls the handle.
 </summary>
	<remarks>
	</remarks>
	<param name="pindata">; nulls indata</param>
	<param name="oldsize">size of input data to be copied, in bytes</param>
	<param name="newsize">size of data to be reallocated in bytes</param>
	<returns>ptr to new data, or NULL on error Action !N.B. 3) and (4! 1 Allocates memory, initialized to 0 2 Copies as much of the input data as possible to the new block, truncating the copy if necessary 3 Frees the input data 4 Zeroes the input data ptr</returns>
</member><member name="M:LeptonicaSharp.Natives.l_binaryRead(System.String,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pnbytes">number of bytes read</param>
	<returns>data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_binaryReadStream(System.IntPtr,System.UInt32@)">
	<summary>
 Notes
 (1) The returned array is terminated with a null byte so that it can
 be used to read ascii data from a file into a proper C string.
 (2) This can be used to capture data that is piped in via stdin,
 because it does not require seeking within the file.
 (3) For example, you can read an image from stdin into memory
 using shell redirection, with one of these shell commands
 \code
 cat LTimagefileGT | readprog
 readprog LT LTimagefileGT
 \endcode
 where readprog is
 \code
 l_uint8 data = l_binaryReadStream(stdin, nbytes);
 Pix pix = pixReadMem(data, nbytes);
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened to read; can be stdin</param>
	<param name="pnbytes">number of bytes read</param>
	<returns>null-terminated array, or NULL on error reading 0 bytes is not an error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_binaryReadSelect(System.String,System.UInt32,System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) The returned array is terminated with a null byte so that it can
 be used to read ascii data from a file into a proper C string.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="start">first byte to read</param>
	<param name="nbytes">number of bytes to read; use 0 to read to end of file</param>
	<param name="pnread">number of bytes actually read</param>
	<returns>data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_binaryReadSelectStream(System.IntPtr,System.UInt32,System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) The returned array is terminated with a null byte so that it can
 be used to read ascii data from a file into a proper C string.
 If the file to be read is empty and %start == 0, an array
 with a single null byte is returned.
 (2) Side effect the stream pointer is re-positioned to the
 beginning of the file.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="start">first byte to read</param>
	<param name="nbytes">number of bytes to read; use 0 to read to end of file</param>
	<param name="pnread">number of bytes actually read</param>
	<returns>null-terminated array, or NULL on error reading 0 bytes is not an error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_binaryWrite(System.String,System.String,System.IntPtr,System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename">output</param>
	<param name="operation">"w" for write; "a" for append</param>
	<param name="data">binary data to be written</param>
	<param name="nbytes">size of data array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.nbytesInFile(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>nbytes in file; 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fnbytesInFile(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>nbytes in file; 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_binaryCopy(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) We add 4 bytes to the zeroed output because in some cases
 (e.g., string handling) it is important to have the data
 be null terminated.  This guarantees that after the memcpy,
 the result is automatically null terminated.
 </summary>
	<remarks>
	</remarks>
	<param name="datas"></param>
	<param name="size">of data array</param>
	<returns>datad on heap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fileCopy(System.String,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="srcfile">copy this file</param>
	<param name="newfile">to this file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fileConcatenate(System.String,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="srcfile">file to append</param>
	<param name="destfile">file to add to</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fileAppendString(System.String,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="str">string to append to file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fopenReadStream(System.String)">
	<summary>
 Notes
 (1) This should be used whenever you want to run fopen() to
 read from a stream.  Never call fopen() directory.
 (2) This handles the temp directory pathname conversion on windows
 /tmp  ==GT  [Windows Temp directory]
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>stream, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fopenWriteStream(System.String,System.String)">
	<summary>
 Notes
 (1) This should be used whenever you want to run fopen() to
 write or append to a stream.  Never call fopen() directory.
 (2) This handles the temp directory pathname conversion on windows
 /tmp  ==GT  [Windows Temp directory]
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="modestring"></param>
	<returns>stream, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fopenReadFromMemory(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) Work-around if fmemopen() not available.
 (2) Windows tmpfile() writes into the root C\ directory, which
 requires admin privileges.  This also works around that.
 </summary>
	<remarks>
	</remarks>
	<param name="data"></param>
	<param name="size"></param>
	<returns>file stream, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.fopenWriteWinTempfile">
	<summary>
 Notes
 (1) The Windows version of tmpfile() writes into the root
 C\ directory, which requires admin privileges.  This
 function provides an alternative implementation.
 </summary>
	<remarks>
	</remarks>
	<returns>file stream, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lept_fopen(System.String,System.String)">
	<summary>
 Notes
 (1) This must be used by any application that passes
 a file handle to a leptonica Windows DLL.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="mode">same as for fopen(); e.g., "rb"</param>
	<returns>stream or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lept_fclose(System.IntPtr)">
	<summary>
 Notes
 (1) This should be used by any application that accepts
 a file handle generated by a leptonica Windows DLL.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lept_calloc(System.UInt32,System.UInt32)">
	<summary>
 Notes
 (1) For safety with windows DLLs, this can be used in conjunction
 with lept_free() to avoid C-runtime boundary problems.
 Just use these two functions throughout your application.
 </summary>
	<remarks>
	</remarks>
	<param name="nmemb">number of members</param>
	<param name="size">of each member</param>
	<returns>void ptr, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.lept_free(System.IntPtr)">
	<summary>
 Notes
 (1) This should be used by any application that accepts
 heap data allocated by a leptonica Windows DLL.
 </summary>
	<remarks>
	</remarks>
	<param name="ptr"></param>
</member><member name="M:LeptonicaSharp.Natives.lept_mkdir(System.String)">
	<summary>
 Notes
 (1) %subdir is a partial path that can consist of one or more
 directories.
 (2) This makes any subdirectories of /tmp that are required.
 (3) The root temp directory is
 /tmp (unix)  [default]
 [Temp]  (windows)
 </summary>
	<remarks>
	</remarks>
	<param name="subdir">of /tmp or its equivalent on Windows</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp.Natives.lept_rmdir(System.String)">
	<summary>
 Notes
 (1) %subdir is a partial path that can consist of one or more
 directories.
 (2) This removes all files from the specified subdirectory of
 the root temp directory
 /tmp (unix)
 [Temp]  (windows)
 and then removes the subdirectory.
 (3) The combination
 lept_rmdir(subdir);
 lept_mkdir(subdir);
 is guaranteed to give you an empty subdirectory.
 </summary>
	<remarks>
	</remarks>
	<param name="subdir">of /tmp or its equivalent on Windows</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp.Natives.lept_direxists(System.String,System.Int32@)">
	<summary>
 Notes
 (1) Always use unix pathname separators.
 (2) By calling genPathname(), if the pathname begins with "/tmp"
 this does an automatic directory translation on windows
 to a path in the windows [Temp] directory
 "/tmp"  ==GT  [Temp] (windows)
 </summary>
	<remarks>
	</remarks>
	<param name="dir"></param>
	<param name="pexists">1 if it exists; 0 otherwise</param>
</member><member name="M:LeptonicaSharp.Natives.lept_rm_match(System.String,System.String)">
	<summary>
 Notes
 (1) This removes the matched files in /tmp or a subdirectory of /tmp.
 Use NULL for %subdir if the files are in /tmp.
 (2) If %substr == NULL, this removes all files in the directory.
 If %substr == "" (empty), this removes no files.
 If both %subdir == NULL and %substr == NULL, this removes
 all files in /tmp.
 (3) Use unix pathname separators.
 (4) By calling genPathname(), if the pathname begins with "/tmp"
 this does an automatic directory translation on windows
 to a path in the windows [Temp] directory
 "/tmp"  ==GT  [Temp] (windows)
 (5) Error conditions
 returns -1 if the directory is not found
 returns the number of files (GT 0) that it was unable to remove.
 </summary>
	<remarks>
	</remarks>
	<param name="subdir">If NULL, the removed files are in /tmp</param>
	<param name="substr">pattern to match in filename</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp.Natives.lept_rm(System.String,System.String)">
	<summary>
 Notes
 (1) By calling genPathname(), this does an automatic directory
 translation on windows to a path in the windows [Temp] directory
 "/tmp/..."  ==GT  [Temp]/... (windows)
 </summary>
	<remarks>
	</remarks>
	<param name="subdir">of '/tmp'; can be NULL</param>
	<param name="tail">filename without the directory</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp.Natives.lept_rmfile(System.String)">
	<summary>
 Notes
 (1) This removes the named file.
 (2) Use unix pathname separators.
 (3) There is no name translation.
 (4) Unlike the other lept_ functions in this section, this can remove
 any file -- it is not restricted to files that are in /tmp or a
 subdirectory of it.
 </summary>
	<remarks>
	</remarks>
	<param name="filepath">full path to file including the directory</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp.Natives.lept_mv(System.String,System.String,System.String,System.IntPtr@)">
	<summary>
 Notes
 (1) This moves %srcfile to /tmp or to a subdirectory of /tmp.
 (2) %srcfile can either be a full path or relative to the
 current directory.
 (3) %newdir can either specify an existing subdirectory of /tmp
 or can be NULL.  In the latter case, the file will be written
 into /tmp.
 (4) %newtail can either specify a filename tail or, if NULL,
 the filename is taken from src-tail, the tail of %srcfile.
 (5) For debugging, the computed newpath can be returned.  It must
 be freed by the caller.
 (6) Reminders
 (a) specify files using unix pathnames
 (b) for windows, translates
 /tmp  ==GT  [Temp]
 where [Temp] is the windows temp directory
 (7) Examples
 newdir = NULL, newtail = NULL ==GT /tmp/src-tail
 newdir = NULL, newtail = abc  ==GT /tmp/abc
 newdir = def/ghi, newtail = NULL ==GT /tmp/def/ghi/src-tail
 newdir = def/ghi, newtail = abc  ==GT /tmp/def/ghi/abc
 </summary>
	<remarks>
	</remarks>
	<param name="srcfile"></param>
	<param name="newdir">; can be NULL</param>
	<param name="newtail">; can be NULL</param>
	<param name="pnewpath">of actual path; can be NULL</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp.Natives.lept_cp(System.String,System.String,System.String,System.IntPtr@)">
	<summary>
 Notes
 (1) This copies %srcfile to /tmp or to a subdirectory of /tmp.
 (2) %srcfile can either be a full path or relative to the
 current directory.
 (3) %newdir can either specify an existing subdirectory of /tmp,
 or can be NULL.  In the latter case, the file will be written
 into /tmp.
 (4) %newtail can either specify a filename tail or, if NULL,
 the filename is taken from src-tail, the tail of %srcfile.
 (5) For debugging, the computed newpath can be returned.  It must
 be freed by the caller.
 (6) Reminders
 (a) specify files using unix pathnames
 (b) for windows, translates
 /tmp  ==GT  [Temp]
 where [Temp] is the windows temp directory
 (7) Examples
 newdir = NULL, newtail = NULL ==GT /tmp/src-tail
 newdir = NULL, newtail = abc  ==GT /tmp/abc
 newdir = def/ghi, newtail = NULL ==GT /tmp/def/ghi/src-tail
 newdir = def/ghi, newtail = abc  ==GT /tmp/def/ghi/abc
 </summary>
	<remarks>
	</remarks>
	<param name="srcfile"></param>
	<param name="newdir">; can be NULL</param>
	<param name="newtail">; can be NULL</param>
	<param name="pnewpath">of actual path; can be NULL</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp.Natives.callSystemDebug(System.String)">
	<summary>
 Notes
 (1) The C library 'system' call is only made through this function.
 It only works in debug/test mode, where the global variable
 LeptDebugOK == TRUE.  This variable is set to FALSE in the
 library as distributed, and calling this function will
 generate an error message.
 </summary>
	<remarks>
	</remarks>
	<param name="cmd">command to be exec'd</param>
</member><member name="M:LeptonicaSharp.Natives.splitPathAtDirectory(System.String,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) If you only want the tail, input null for the root directory ptr.
 (2) If you only want the root directory name, input null for the
 tail ptr.
 (3) This function makes decisions based only on the lexical
 structure of the input.  Examples
 /usr/tmp/abc  --GT  dir /usr/tmp/ tail abc
 /usr/tmp/  --GT  dir /usr/tmp/ tail [empty string]
 /usr/tmp   --GT  dir /usr/  tail tmp
 abc  --GT  dir [empty string]  tail abc
 (4) The input can have either forward (unix) or backward (win)
 slash separators.  The output has unix separators.
 Note that Win32 pathname functions generally accept both
 slash forms, but the windows command line interpreter
 only accepts backward slashes, because forward slashes are
 used to demarcate switches (vs. dashes in unix).
 </summary>
	<remarks>
	</remarks>
	<param name="pathname">full path; can be a directory</param>
	<param name="pdir">root directory name of input path, including trailing '/'</param>
	<param name="ptail">path tail, which is either the file name within the root directory or the last sub-directory in the path</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.splitPathAtExtension(System.String,System.IntPtr@,System.IntPtr@)">
	<summary>
 Notes
 (1) If you only want the extension, input null for the basename ptr.
 (2) If you only want the basename without extension, input null
 for the extension ptr.
 (3) This function makes decisions based only on the lexical
 structure of the input.  Examples
 /usr/tmp/abc.jpg  --GT  basename /usr/tmp/abc ext .jpg
 /usr/tmp/.jpg  --GT  basename /usr/tmp/ ext .jpg
 /usr/tmp.jpg/  --GT  basename /usr/tmp.jpg/   ext [empty str]
 ./.jpg   --GT  basename ./  ext .jpg
 (4) The input can have either forward (unix) or backward (win)
 slash separators.  The output has unix separators.
 </summary>
	<remarks>
	</remarks>
	<param name="pathname">full path; can be a directory</param>
	<param name="pbasename">pathname not including the last dot and characters after that</param>
	<param name="pextension">path extension, which is the last dot and the characters after it.  If there is no extension, it returns the empty string</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pathJoin(System.String,System.String)">
	<summary>
 Notes
 (1) Use unix-style pathname separators ('/').
 (2) %fname can be the entire path, or part of the path containing
 at least one directory, or a tail without a directory, or NULL.
 (3) It produces a path that strips multiple slashes to a single
 slash, joins %dir and %fname by a slash, and has no trailing
 slashes (except in the cases where %dir == "/" and
 %fname == NULL, or v.v.).
 (4) If both %dir and %fname are null, produces an empty string.
 (5) Neither %dir nor %fname can begin with '..'.
 (6) The result is not canonicalized or tested for correctness
 garbage in (e.g., /%), garbage out.
 (7) Examples
 //tmp// + //abc/  --GT  /tmp/abc
 tmp/ + /abc/   --GT  tmp/abc
 tmp/ + abc/ --GT  tmp/abc
 /tmp/ + /// --GT  /tmp
 /tmp/ + NULL   --GT  /tmp
 // + /abc// --GT  /abc
 // + NULL   --GT  /
 NULL + /abc/def/  --GT  /abc/def
 NULL + abc//   --GT  abc
 NULL + //   --GT  /
 NULL + NULL --GT  (empty string)
 "" + ""  --GT  (empty string)
 "" + /   --GT  /
 ".." + /etc/foo   --GT  NULL
 /tmp + ".." --GT  NULL
 </summary>
	<remarks>
	</remarks>
	<param name="dir">can be null</param>
	<param name="fname">can be null</param>
	<returns>specially concatenated path, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.appendSubdirs(System.String,System.String)">
	<summary>
 Notes
 (1) Use unix pathname separators
 (2) Allocates a new string  [basedir]/[subdirs]
 </summary>
	<remarks>
	</remarks>
	<param name="basedir"></param>
	<param name="subdirs"></param>
	<returns>concatenated full directory path without trailing slash, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.convertSepCharsInPath(System.String,System.Int32)">
	<summary>
 Notes
 (1) In-place conversion.
 (2) Type is the resulting type
 UNIX_PATH_SEPCHAR  '\\' ==GT '/'
 WIN_PATH_SEPCHAR   '/' ==GT '\\'
 (3) Virtually all path operations in leptonica use unix separators.
 </summary>
	<remarks>
	</remarks>
	<param name="path"></param>
	<param name="type">UNIX_PATH_SEPCHAR, WIN_PATH_SEPCHAR</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.genPathname(System.String,System.String)">
	<summary>
 Notes
 (1) This function generates actual paths in the following ways
 from two sub-parts (e.g., a directory and a file name).
 from a single path full path, placed in %dir, with
 %fname == NULL.
 from the name of a file in the local directory placed in
 %fname, with %dir == NULL.
 if in a "/tmp" directory and on windows, the windows
 temp directory is used.
 (2) On windows, if the root of %dir is '/tmp', this does a name
 translation
 "/tmp"  ==GT  [Temp] (windows)
 where [Temp] is the windows temp directory.
 (3) On unix, the TMPDIR variable is ignored.  No rewriting
 of temp directories is permitted.
 (4) There are four cases for the input
 (a) %dir is a directory and %fname is defined result is a full path
 (b) %dir is a directory and %fname is null result is a directory
 (c) %dir is a full path and %fname is null result is a full path
 (d) %dir is null or an empty string start in the current dir;
 result is a full path
 (5) In all cases, the resulting pathname is not terminated with a slash
 (6) The caller is responsible for freeing the returned pathname.
 </summary>
	<remarks>
	</remarks>
	<param name="dir">directory or full path name, with or without trailing '/'</param>
	<param name="fname">file name within a directory</param>
	<returns>pathname either a directory or full path, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.makeTempDirname(System.String,System.UInt32,System.String)">
	<summary>
 Notes
 (1) This generates the directory path for output temp files,
 written into %result with unix separators.
 (2) Caller allocates %result, large enough to hold the path,
 which is
 /tmp/%subdir (unix)
 [Temp]/%subdir  (windows)
 where [Temp] is a path on windows determined by GenTempPath()
 and %subdir is in general a set of nested subdirectories
 dir1/dir2/.../dirN
 which in use would not typically exceed 2 levels.
 (3) Usage example
 \code
 char  result[256];
 makeTempDirname(result, 256, "lept/golden");
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="result">preallocated on stack or heap and passed in</param>
	<param name="nbytes">size of %result array, in bytes</param>
	<param name="subdir">; can be NULL or an empty string</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.modifyTrailingSlash(System.String,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) This carries out the requested action if necessary.
 </summary>
	<remarks>
	</remarks>
	<param name="path">preallocated on stack or heap and passed in</param>
	<param name="nbytes">size of %path array, in bytes</param>
	<param name="flag">L_ADD_TRAIL_SLASH or L_REMOVE_TRAIL_SLASH</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_makeTempFilename">
	<summary>
 Notes
 (1) On unix, this makes a filename of the form
 "/tmp/lept.XXXXXX",
 where each X is a random character.
 (2) On windows, this makes a filename of the form
 "/[Temp]/lp.XXXXXX".
 (3) On all systems, this fails if the file is not writable.
 (4) Safest usage is to write to a subdirectory in debug code.
 (5) The returned filename must be freed by the caller, using lept_free.
 (6) The tail of the filename has a '.', so that cygwin interprets
 the file as having an extension.  Otherwise, cygwin assumes it
 is an executable and appends ".exe" to the filename.
 (7) On unix, whenever possible use tmpfile() instead.  tmpfile()
 hides the file name, returns a stream opened for write,
 and deletes the temp file when the stream is closed.
 </summary>
	<remarks>
	</remarks>
	<returns>fname  heap allocated filename; returns NULL on failure.</returns>
</member><member name="M:LeptonicaSharp.Natives.extractNumberFromFilename(System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The number is to be found in the basename, which is the
 filename without either the directory or the last extension.
 (2) When a number is found, it is non-negative.  If no number
 is found, this returns -1, without an error message.  The
 caller needs to check.
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="numpre">number of characters before the digits to be found</param>
	<param name="numpost">number of characters after the digits to be found</param>
	<returns>num number embedded in the filename; -1 on error or if not found</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSimpleCaptcha(System.IntPtr,System.Int32,System.Int32,System.UInt32,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) This uses typical default values for generating captchas.
 The magnitudes of the harmonic warp are typically to be
 smaller when more terms are used, even though the phases
 are random.  See, for example, prog/warptest.c.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="border">added white pixels on each side</param>
	<param name="nterms">number of x and y harmonic terms</param>
	<param name="seed">of random number generator</param>
	<param name="color">for colorizing; in 0xrrggbb00 format; use 0 for black</param>
	<param name="cmapflag">1 for colormap output; 0 for rgb</param>
	<returns>pixd 8 bpp cmap or 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixRandomHarmonicWarp(System.IntPtr,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) To generate the warped image p(x',y'), set up the transforms
 that are in getWarpTransform().  For each (x',y') in the
 dest, the warp function computes the originating location
 (x, y) in the src.  The differences (x - x') and (y - y')
 are given as a sum of products of sinusoidal terms.  Each
 term is multiplied by a maximum amplitude (in pixels), and the
 angle is determined by a frequency and phase, and depends
 on the (x', y') value of the dest.  Random numbers with
 a variable input seed are used to allow the warping to be
 unpredictable.  A linear interpolation is used to find
 the value for the source at (x, y); this value is written
 into the dest.
 (2) This can be used to generate 'captcha's, which are somewhat
 randomly distorted images of text.  A typical set of parameters
 for a captcha are
 xmag = 4.0  ymag = 6.0
 xfreq = 0.10   yfreq = 0.13
 nx = 3   ny = 3
 Other examples can be found in prog/warptest.c.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="xmag">maximum magnitude of x and y distortion</param>
	<param name="ymag">maximum magnitude of x and y distortion</param>
	<param name="xfreq">maximum magnitude of x and y frequency</param>
	<param name="yfreq">maximum magnitude of x and y frequency</param>
	<param name="nx">number of x and y harmonic terms</param>
	<param name="ny">number of x and y harmonic terms</param>
	<param name="seed">of random number generator</param>
	<param name="grayval">color brought in from the outside; 0 for black, 255 for white</param>
	<returns>pixd 8 bpp; no colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWarpStereoscopic(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This function splits out the red channel, mucks around with
 it, then recombines with the unmolested cyan channel.
 (2) By using a quadratically increasing shift of the red
 pixels horizontally and away from the vertical centerline,
 the image appears to bend quadratically out of the image
 plane, symmetrically with respect to the vertical center
 line.  A positive value of %zbend causes the plane to be
 curved away from the viewer.  We use linearly interpolated
 stretching to avoid the appearance of kinks in the curve.
 (3) The parameters %zshiftt and %zshiftb tilt the image plane
 about a horizontal line through the center, and at the
 same time move that line either in toward the viewer or away.
 This is implemented by a combination of horizontal shear
 about the center line (for the tilt) and horizontal
 translation (to move the entire plane in or out).
 A positive value of %zshiftt moves the top of the plane
 away from the viewer, and a positive value of %zshiftb
 moves the bottom of the plane away.  We use linear interpolated
 shear to avoid visible vertical steps in the tilted image.
 (4) The image can be bent in the plane and about the vertical
 centerline.  The centerline does not shift, and the
 parameter %ybend gives the relative shift at left and right
 edges, with a downward shift for positive values of %ybend.
 (6) When writing out a steroscopic (red/cyan) image in jpeg,
 first call pixSetChromaSampling(pix, 0) to get sufficient
 resolution in the red channel.
 (7) Typical values are
 zbend = 20
 zshiftt = 15
 zshiftb = -15
 ybendt = 30
 ybendb = 0
 If the disparity z-values are too large, it is difficult for
 the brain to register the two images.
 (8) This function has been cleverly reimplemented by Jeff Breidenbach.
 The original implementation used two 32 bpp rgb images,
 and merged them at the end.  The result is somewhat faded,
 and has a parameter "thresh" that controls the amount of
 color in the result.  (The present implementation avoids these
 two problems, skipping both the colorization and the alpha
 blending at the end, and is about 3x faster)
 The basic operations with 32 bpp are as follows
 // Immediate conversion to 32 bpp
 Pix pixt1 = pixConvertTo32(pixs);
 // Do vertical shear
 Pix pixr = pixQuadraticVerticalShear(pixt1, L_WARP_TO_RIGHT,
 ybendt, ybendb,
 L_BRING_IN_WHITE);
 // Colorize two versions, toward red and cyan
 Pix pixc = pixCopy(NULL, pixr);
 l_int32 thresh = 150;  // if higher, get less original color
 pixColorGray(pixr, NULL, L_PAINT_DARK, thresh, 255, 0, 0);
 pixColorGray(pixc, NULL, L_PAINT_DARK, thresh, 0, 255, 255);
 // Shift the red pixels; e.g., by stretching
 Pix pixrs = pixStretchHorizontal(pixr, L_WARP_TO_RIGHT,
 L_QUADRATIC_WARP, zbend,
 L_INTERPOLATED,
 L_BRING_IN_WHITE);
 // Blend the shifted red and unshifted cyan 5050
 Pix pixg = pixCreate(w, h, 8);
 pixSetAllArbitrary(pixg, 128);
 pixd = pixBlendWithGrayMask(pixrs, pixc, pixg, 0, 0);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, colormap ok</param>
	<param name="zbend">horizontal separation in pixels of red and cyan at the left and right sides, that gives rise to quadratic curvature out of the image plane</param>
	<param name="zshiftt">uniform pixel translation difference between red and cyan, that pushes the top of the image plane away from the viewer (zshiftt GT 0) or towards the viewer (zshiftt LT 0)</param>
	<param name="zshiftb">uniform pixel translation difference between red and cyan, that pushes the bottom of the image plane away from the viewer (zshiftb GT 0) or towards the viewer (zshiftb LT 0)</param>
	<param name="ybendt">multiplicative parameter for in-plane vertical displacement at the left or right edge at the top y = ybendt  (2x/w - 1)^2</param>
	<param name="ybendb">same as ybendt, except at the left or right edge at the bottom</param>
	<param name="redleft">1 if the red filter is on the left; 0 otherwise</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixStretchHorizontal(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If %hmax GT 0, this is an increase in the coordinate value of
 pixels in pixd, relative to the same pixel in pixs.
 (2) If %dir == L_WARP_TO_LEFT, the pixels on the right edge of
 the image are not moved. So, for example, if %hmax GT 0
 and %dir == L_WARP_TO_LEFT, the pixels in pixd are
 contracted toward the right edge of the image, relative
 to those in pixs.
 (3) If %type == L_LINEAR_WARP, the pixel positions are moved
 to the left or right by an amount that varies linearly with
 the horizontal location.
 (4) If %operation == L_SAMPLED, the dest pixels are taken from
 the nearest src pixel.  Otherwise, we use linear interpolation
 between pairs of sampled pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 or 32 bpp</param>
	<param name="dir">L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	<param name="type">L_LINEAR_WARP or L_QUADRATIC_WARP</param>
	<param name="hmax">horizontal displacement at edge</param>
	<param name="operation">L_SAMPLED or L_INTERPOLATED</param>
	<param name="incolor">L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	<returns>pixd stretched/compressed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixStretchHorizontalSampled(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixStretchHorizontal() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 or 32 bpp</param>
	<param name="dir">L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	<param name="type">L_LINEAR_WARP or L_QUADRATIC_WARP</param>
	<param name="hmax">horizontal displacement at edge</param>
	<param name="incolor">L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	<returns>pixd stretched/compressed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixStretchHorizontalLI(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixStretchHorizontal() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 or 32 bpp</param>
	<param name="dir">L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	<param name="type">L_LINEAR_WARP or L_QUADRATIC_WARP</param>
	<param name="hmax">horizontal displacement at edge</param>
	<param name="incolor">L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	<returns>pixd stretched/compressed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixQuadraticVShear(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This gives a quadratic bending, upward or downward, as you
 move to the left or right.
 (2) If %dir == L_WARP_TO_LEFT, the right edge is unchanged, and
 the left edge pixels are moved maximally up or down.
 (3) Parameters %vmaxt and %vmaxb control the maximum amount of
 vertical pixel shear at the top and bottom, respectively.
 If %vmaxt GT 0, the vertical displacement of pixels at the
 top is downward.  Likewise, if %vmaxb GT 0, the vertical
 displacement of pixels at the bottom is downward.
 (4) If %operation == L_SAMPLED, the dest pixels are taken from
 the nearest src pixel.  Otherwise, we use linear interpolation
 between pairs of sampled pixels.
 (5) This is for quadratic shear.  For uniform (linear) shear,
 use the standard shear operators.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 or 32 bpp</param>
	<param name="dir">L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	<param name="vmaxt">max vertical displacement at edge and at top</param>
	<param name="vmaxb">max vertical displacement at edge and at bottom</param>
	<param name="operation">L_SAMPLED or L_INTERPOLATED</param>
	<param name="incolor">L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	<returns>pixd stretched, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixQuadraticVShearSampled(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixQuadraticVShear() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 or 32 bpp</param>
	<param name="dir">L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	<param name="vmaxt">max vertical displacement at edge and at top</param>
	<param name="vmaxb">max vertical displacement at edge and at bottom</param>
	<param name="incolor">L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	<returns>pixd stretched, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixQuadraticVShearLI(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixQuadraticVShear() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp, or colormapped</param>
	<param name="dir">L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	<param name="vmaxt">max vertical displacement at edge and at top</param>
	<param name="vmaxb">max vertical displacement at edge and at bottom</param>
	<param name="incolor">L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	<returns>pixd stretched, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixStereoFromPair(System.IntPtr,System.IntPtr,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) pix1 and pix2 are a pair of stereo images, ideally taken
 concurrently in the same plane, with some lateral translation.
 (2) The output red channel is determined from %pix1.
 The output green and blue channels are taken from the green
 and blue channels, respectively, of %pix2.
 (3) The weights determine how much of each component in %pix1
 goes into the output red channel.  The sum of weights
 must be 1.0.  If it's not, we scale the weights to
 satisfy this criterion.
 (4) The most general pixel mapping allowed here is
 rval = rwt  r1 + gwt  g1 + bwt  b1  (from pix1)
 gval = g2   (from pix2)
 bval = b2   (from pix2)
 (5) The simplest method is to use rwt = 1.0, gwt = 0.0, bwt = 0.0,
 but this causes unpleasant visual artifacts with red in the image.
 Use of green and blue from %pix1 in the red channel,
 instead of red, tends to fix that problem.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">32 bpp rgb</param>
	<param name="pix2">32 bpp rgb</param>
	<param name="rwt">weighting factors used for each component in                                pix1 to determine the output red channel</param>
	<param name="gwt">weighting factors used for each component in                                pix1 to determine the output red channel</param>
	<param name="bwt">weighting factors used for each component in                                pix1 to determine the output red channel</param>
	<returns>pixd stereo enhanced, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.wshedCreate(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) It is not necessary for the fg pixels in the seed image
 be at minima, or that they be isolated.  We extract a
 single pixel from each connected component, and a seed
 anywhere in a watershed will eventually label the watershed
 when the filling level reaches it.
 (2) Set mindepth to some value to ignore noise in pixs that
 can create small local minima.  Any watershed shallower
 than mindepth, even if it has a seed, will not be saved;
 It will either be incorporated in another watershed or
 eliminated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp source</param>
	<param name="pixm">1 bpp 'marker' seed</param>
	<param name="mindepth">minimum depth; anything less is not saved</param>
	<param name="debugflag">1 for debug output</param>
	<returns>WShed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.wshedDestroy(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pwshed">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp.Natives.wshedApply(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="wshed">generated from wshedCreate()</param>
	<returns>0 if OK, 1 on error Iportant note 1 This is buggy.  It seems to locate watersheds that are duplicates.  The watershed extraction after complete fill grabs some regions belonging to existing watersheds. See prog/watershedtest.c for testing.</returns>
</member><member name="M:LeptonicaSharp.Natives.wshedBasins(System.IntPtr,System.IntPtr@,System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="wshed"></param>
	<param name="ppixa">mask of watershed basins</param>
	<param name="pnalevels">watershed levels</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.wshedRenderFill(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="wshed"></param>
	<returns>pixd initial image with all basins filled, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.wshedRenderColors(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="wshed"></param>
	<returns>pixd initial image with all basins filled, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadStreamWebP(System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixReadMemWebP(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.readHeaderWebP(System.String,System.Object,System.Object,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.readHeaderMemWebP(System.Byte[],System.UInt32,System.Object,System.Object,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteWebP(System.String,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStreamWebP(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMemWebP(System.Object,System.Object,System.IntPtr,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp.Natives.l_jpegSetQuality(System.Int32)">
	<summary>
 Notes
 (1) This variable is used in pixWriteStream() and pixWriteMem(),
 to control the jpeg quality.  The default is 75.
 (2) It returns the previous quality, so for example
 l_int32  prev = l_jpegSetQuality(85);  //sets to 85
 pixWriteStream(...);
 l_jpegSetQuality(prev);   // resets to previous value
 (3) On error, logs a message and does not change the variable.
 </summary>
	<remarks>
	</remarks>
	<param name="new_quality">1 - 100; 75 is default; 0 defaults to 75</param>
	<returns>prev           previous quality</returns>
</member><member name="M:LeptonicaSharp.Natives.setLeptDebugOK(System.Int32)">
	<summary>
 Notes
 (1) This sets or clears the global variable LeptDebugOK, to
 control writing files in a temp directory with names that
 are compiled in.
 (2) The default in the library distribution is 0.  Call with
 %allow = 1 for development and debugging.
 </summary>
	<remarks>
	</remarks>
	<param name="allow">TRUE (1) or FALSE (0)</param>
</member><member name="M:LeptonicaSharp.Natives.pixaWriteFiles(System.String,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Use %format = IFF_DEFAULT to decide the output format
 individually for each pix.
 </summary>
	<remarks>
	</remarks>
	<param name="rootname"></param>
	<param name="pixa"></param>
	<param name="format">defined in imageio.h; see notes for default</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteDebug(System.String,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Debug version, intended for use in the library when writing
 to files in a temp directory with names that are compiled in.
 This is used instead of pixWrite() for all such library calls.
 (2) The global variable LeptDebugOK defaults to 0, and can be set
 or cleared by the function setLeptDebugOK().
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="pix"></param>
	<param name="format">defined in imageio.h</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWrite(System.String,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) Open for write using binary mode (with the "b" flag)
 to avoid having Windows automatically translate the NL
 into CRLF, which corrupts image files.  On non-windows
 systems this flag should be ignored, per ISO C90.
 Thanks to Dave Bryan for pointing this out.
 (2) If the default image format IFF_DEFAULT is requested
 use the input format if known; otherwise, use a lossless format.
 (3) The default jpeg quality is 75.  For some other value,
 Use l_jpegSetQuality().
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="pix"></param>
	<param name="format">defined in imageio.h</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteAutoFormat(System.String,System.IntPtr)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pix"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteStream(System.IntPtr,System.IntPtr,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix"></param>
	<param name="format"></param>
	<returns>0 if OK; 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteImpliedFormat(System.String,System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This determines the output format from the filename extension.
 (2) The last two args are ignored except for requests for jpeg files.
 (3) The jpeg default quality is 75.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pix"></param>
	<param name="quality">iff JPEG; 1 - 100, 0 for default</param>
	<param name="progressive">iff JPEG; 0 for baseline seq., 1 for progressive</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixChooseOutputFormat(System.IntPtr)">
	<summary>
 Notes
 (1) This should only be called if the requested format is IFF_DEFAULT.
 (2) If the pix wasn't read from a file, its input format value
 will be IFF_UNKNOWN, and in that case it is written out
 in a compressed but lossless format.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>output format, or 0 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getImpliedFileFormat(System.String)">
	<summary>
 Notes
 (1) This determines the output file format from the extension
 of the input filename.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>output format, or IFF_UNKNOWN on error or invalid extension.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixGetAutoFormat(System.IntPtr,System.Object)">
	<summary>
 Notes
 (1) The output formats are restricted to tiff, jpeg and png
 because these are the most commonly used image formats and
 the ones that are typically installed with leptonica.
 (2) This decides what compression to use based on the pix.
 It chooses tiff-g4 if 1 bpp without a colormap, jpeg with
 quality 75 if grayscale, rgb or rgba (where it loses
 the alpha layer), and lossless png for all other situations.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.getFormatExtension(System.Int32)">
	<summary>
 Notes
 (1) This string is NOT owned by the caller; it is just a pointer
 to a global string.  Do not free it.
 </summary>
	<remarks>
	</remarks>
	<param name="format">integer</param>
	<returns>extension string, or NULL if format is out of range</returns>
</member><member name="M:LeptonicaSharp.Natives.pixWriteMem(System.IntPtr@,System.UInt32@,System.IntPtr,System.Int32)">
	<summary>
 Notes
 (1) On windows, this will only write tiff and PostScript to memory.
 For other formats, it requires open_memstream(3).
 (2) PostScript output is uncompressed, in hex ascii.
 Most printers support level 2 compression (tiff_g4 for 1 bpp,
 jpeg for 8 and 32 bpp).
 (3) The default jpeg quality is 75.  For some other value,
 Use l_jpegSetQuality().
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of tiff compressed image</param>
	<param name="psize">size of returned data</param>
	<param name="pix"></param>
	<param name="format">defined in imageio.h</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.l_fileDisplay(System.String,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This is a convenient wrapper for displaying image files.
 (2) It does nothing unless LeptDebugOK == TRUE.
 (2) Set %scale = 0 to disable display.
 (3) This downscales 1 bpp to gray.
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="x">location of display frame on the screen</param>
	<param name="y">location of display frame on the screen</param>
	<param name="scale">scale factor (use 0 to skip display)</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDisplay(System.IntPtr,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is debugging code that displays an image on the screen.
 It uses a static internal variable to number the output files
 written by a single process.  Behavior with a shared library
 may be unpredictable.
 (2) It does nothing unless LeptDebugOK == TRUE.
 (3) It uses these programs to display the image
 On Unix xzgv, xli or xv
 On Windows i_view
 The display program must be on your $PATH variable.  It is
 chosen by setting the global var_DISPLAY_PROG, using
 l_chooseDisplayProg().  Default on Unix is xzgv.
 (4) Images with dimensions larger than MAX_DISPLAY_WIDTH or
 MAX_DISPLAY_HEIGHT are downscaled to fit those constraints.
 This is particularly important for displaying 1 bpp images
 with xv, because xv automatically downscales large images
 by subsampling, which looks poor.  For 1 bpp, we use
 scale-to-gray to get decent-looking anti-aliased images.
 In all cases, we write a temporary file to /tmp/lept/disp,
 that is read by the display program.
 (5) The temporary file is written as png if, after initial
 processing for special cases, any of these obtain
 pix dimensions are smaller than some thresholds
 pix depth is less than 8 bpp
 pix is colormapped
 (6) For spp == 4, we call pixDisplayLayersRGBA() to show 3
 versions of the image the image with a fully opaque
 alpha, the alpha, and the image as it would appear with
 a white background.
 </summary>
	<remarks>
	</remarks>
	<param name="x">location of display frame on the screen</param>
	<param name="y">location of display frame on the screen</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixDisplayWithTitle(System.IntPtr,System.Int32,System.Int32,System.String,System.Int32)">
	<summary>
 Notes
 (1) See notes for pixDisplay().
 (2) This displays the image if dispflag == 1; otherwise it punts.
 </summary>
	<remarks>
	</remarks>
	<param name="x">location of display frame</param>
	<param name="y">location of display frame</param>
	<param name="title">on frame; can be NULL;</param>
	<param name="dispflag">1 to write, else disabled</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSaveTiled(System.IntPtr,System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp</param>
	<param name="pixa">the pix are accumulated here</param>
	<param name="scalefactor">0.0 to disable; otherwise this is a scale factor</param>
	<param name="newrow">0 if placed on the same row as previous; 1 otherwise</param>
	<param name="space">horizontal and vertical spacing, in pixels</param>
	<param name="dp">depth of pixa; 8 or 32 bpp; only used on first call</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSaveTiledOutline(System.IntPtr,System.IntPtr,System.Single,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Before calling this function for the first time, use
 pixaCreate() to make the %pixa that will accumulate the pix.
 This is passed in each time pixSaveTiled() is called.
 (2) %scalefactor scales the input image.  After scaling and
 possible depth conversion, the image is saved in the input
 pixa, along with a box that specifies the location to
 place it when tiled later.  Disable saving the pix by
 setting %scalefactor == 0.0.
 (3) %newrow and %space specify the location of the new pix
 with respect to the last one(s) that were entered.
 (4) %dp specifies the depth at which all pix are saved.  It can
 be only 8 or 32 bpp.  Any colormap is removed.  This is only
 used at the first invocation.
 (5) This function uses two variables from call to call.
 If they were static, the function would not be .so or thread
 safe, and furthermore, there would be interference with two or
 more pixa accumulating images at a time.  Consequently,
 we use the first pix in the pixa to store and obtain both
 the depth and the current position of the bottom (one pixel
 below the lowest image raster line when laid out using
 the boxa).  The bottom variable is stored in the input format
 field, which is the only field available for storing an int.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp</param>
	<param name="pixa">the pix are accumulated here</param>
	<param name="scalefactor">0.0 to disable; otherwise this is a scale factor</param>
	<param name="newrow">0 if placed on the same row as previous; 1 otherwise</param>
	<param name="space">horizontal and vertical spacing, in pixels</param>
	<param name="linewidth">width of added outline for image; 0 for no outline</param>
	<param name="dp">depth of pixa; 8 or 32 bpp; only used on first call</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.pixSaveTiledWithText(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.String,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) Before calling this function for the first time, use
 pixaCreate() to make the %pixa that will accumulate the pix.
 This is passed in each time pixSaveTiled() is called.
 (2) %outwidth is the scaled width.  After scaling, the image is
 saved in the input pixa, along with a box that specifies
 the location to place it when tiled later.  Disable saving
 the pix by setting %outwidth == 0.
 (3) %newrow and %space specify the location of the new pix
 with respect to the last one(s) that were entered.
 (4) All pix are saved as 32 bpp RGB.
 (5) If both %bmf and %textstr are defined, this generates a pix
 with the additional text; otherwise, no text is written.
 (6) The text is written before scaling, so it is properly
 antialiased in the scaled pix.  However, if the pix on
 different calls have different widths, the size of the
 text will vary.
 (7) See pixSaveTiledOutline() for other implementation details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp</param>
	<param name="pixa">the pix are accumulated here; as 32 bpp</param>
	<param name="outwidth">in pixels; use 0 to disable entirely</param>
	<param name="newrow">1 to start a new row; 0 to go on same row as previous</param>
	<param name="space">horizontal and vertical spacing, in pixels</param>
	<param name="linewidth">width of added outline for image; 0 for no outline</param>
	<param name="bmf">font struct</param>
	<param name="textstr">text string to be added</param>
	<param name="val">color to set the text</param>
	<param name="location">L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp.Natives.l_chooseDisplayProg(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp.Natives.pixDisplayWrite(System.IntPtr,System.Int32)">
	<summary>
 Notes
 (0) Deprecated.
 (1) This is a simple interface for writing a set of files.
 (2) This uses jpeg output for pix that are 32 bpp or 8 bpp
 without a colormap; otherwise, it uses png.
 (3) To erase any previously written files in the output directory
 pixDisplayWrite(NULL, -1);
 (4) If reduction GT 1 and depth == 1, this does a scale-to-gray
 reduction.
 (5) This function uses a static internal variable to number
 output files written by a single process.  Behavior
 with a shared library may be unpredictable.
 (6) For 16 bpp, this displays the full dynamic range with log scale.
 Alternative image transforms to generate 8 bpp pix are
 pix8 = pixMaxDynamicRange(pixt, L_LINEAR_SCALE);
 pix8 = pixConvert16To8(pixt, 0);  // low order byte
 pix8 = pixConvert16To8(pixt, 1);  // high order byte
 </summary>
	<remarks>
	</remarks>
	<param name="reduction">-1 to reset/erase; 0 to disable; otherwise this is a reduction factor</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp.Natives.zlibCompress(System.Byte[],System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) We repeatedly read in and fill up an input buffer,
 compress the data, and read it back out.  zlib
 uses two byte buffers internally in the z_stream
 data structure.  We use the bbuffers to feed data
 into the fixed bufferin, and feed it out of bufferout,
 in the same way that a pair of streams would normally
 be used if the data were being read from one file
 and written to another.  This is done iteratively,
 compressing L_BUF_SIZE bytes of input data at a time.
 </summary>
	<remarks>
	</remarks>
	<param name="datain">byte buffer with input data</param>
	<param name="nin">number of bytes of input data</param>
	<param name="pnout">number of bytes of output data</param>
	<returns>dataout compressed data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp.Natives.zlibUncompress(System.Byte[],System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) See zlibCompress().
 </summary>
	<remarks>
	</remarks>
	<param name="datain">byte buffer with compressed input data</param>
	<param name="nin">number of bytes of input data</param>
	<param name="pnout">number of bytes of output data</param>
	<returns>dataout uncompressed data, or NULL on error</returns>
</member><member name="P:LeptonicaSharp.L_WallTimer.start_sec">
	<summary>
 Brf: 
  Loc: SRC/environ.h (309, 14)
  Org: [l_int32 start_sec]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_WallTimer.start_usec">
	<summary>
 Brf: 
  Loc: SRC/environ.h (310, 14)
  Org: [l_int32 start_usec]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_WallTimer.stop_sec">
	<summary>
 Brf: 
  Loc: SRC/environ.h (311, 14)
  Org: [l_int32 stop_sec]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_WallTimer.stop_usec">
	<summary>
 Brf: 
  Loc: SRC/environ.h (312, 14)
  Org: [l_int32 stop_usec]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Numa.nalloc">
	<summary>
 Brf: size of allocated number array
  Loc: SRC/array.h (61, 22)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Numa.n">
	<summary>
 Brf: number of numbers saved
  Loc: SRC/array.h (62, 22)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Numa.refcount">
	<summary>
 Brf: reference count (1 if no clones)
  Loc: SRC/array.h (63, 22)
  Org: [l_int32 refcount]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Numa.startx">
	<summary>
 Brf: x value assigned to array[0]
  Loc: SRC/array.h (64, 22)
  Org: [l_float32 startx]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.Numa.delx">
	<summary>
 Brf: change in x value as i -- bigger  i + 1
  Loc: SRC/array.h (65, 22)
  Org: [l_float32 delx]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.Numa.array">
	<summary>
 Brf: number array
  Loc: SRC/array.h (66, 22)
  Org: [l_float32 * array]
  Msh: l_float32 * | 2:Float |  ... = Single
 </summary>
</member><member name="P:LeptonicaSharp.Numaa.nalloc">
	<summary>
 Brf: size of allocated ptr array
  Loc: SRC/array.h (73, 22)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Numaa.n">
	<summary>
 Brf: number of Numa saved
  Loc: SRC/array.h (74, 22)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Numaa.numa">
	<summary>
 Brf: array of Numa
  Loc: SRC/array.h (75, 22)
  Org: [struct Numa ** numa]
  Msh: struct Numa ** | 3:StructDeclaration |  ... Marshal List of Class to PTR Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Dna.nalloc">
	<summary>
 Brf: size of allocated number array
  Loc: SRC/array.h (85, 22)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dna.n">
	<summary>
 Brf: number of numbers saved
  Loc: SRC/array.h (86, 22)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dna.refcount">
	<summary>
 Brf: reference count (1 if no clones)
  Loc: SRC/array.h (87, 22)
  Org: [l_int32 refcount]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dna.startx">
	<summary>
 Brf: x value assigned to array[0]
  Loc: SRC/array.h (88, 22)
  Org: [l_float64 startx]
  Msh: l_float64 | 1:Double |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dna.delx">
	<summary>
 Brf: change in x value as i -- bigger  i + 1
  Loc: SRC/array.h (89, 22)
  Org: [l_float64 delx]
  Msh: l_float64 | 1:Double |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dna.array">
	<summary>
 Brf: number array
  Loc: SRC/array.h (90, 22)
  Org: [l_float64 * array]
  Msh: l_float64 * | 2:Double |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dnaa.nalloc">
	<summary>
 Brf: size of allocated ptr array
  Loc: SRC/array.h (97, 22)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dnaa.n">
	<summary>
 Brf: number of L_Dna saved
  Loc: SRC/array.h (98, 22)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dnaa.dna">
	<summary>
 Brf: array of L_Dna
  Loc: SRC/array.h (99, 22)
  Org: [struct L_Dna ** dna]
  Msh: struct L_Dna ** | 3:StructDeclaration |  ... Marshal List of Class to PTR Typedef: L_Dna = L_Dna
 </summary>
</member><member name="P:LeptonicaSharp.L_DnaHash.nbuckets">
	<summary>
 Brf: 
  Loc: SRC/array.h (106, 22)
  Org: [l_int32 nbuckets]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_DnaHash.initsize">
	<summary>
 Brf: initial size of each dna that is made
  Loc: SRC/array.h (107, 22)
  Org: [l_int32 initsize]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_DnaHash.dna">
	<summary>
 Brf: array of L_Dna
  Loc: SRC/array.h (108, 22)
  Org: [struct L_Dna ** dna]
  Msh: struct L_Dna ** | 3:StructDeclaration |  ... Marshal List of Class to PTR Typedef: L_Dna = L_Dna
 </summary>
</member><member name="P:LeptonicaSharp.Sarray.nalloc">
	<summary>
 Brf: size of allocated ptr array
  Loc: SRC/array.h (118, 22)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Sarray.n">
	<summary>
 Brf: number of strings allocated
  Loc: SRC/array.h (119, 22)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Sarray.refcount">
	<summary>
 Brf: reference count (1 if no clones)
  Loc: SRC/array.h (120, 22)
  Org: [l_int32 refcount]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Sarray.array">
	<summary>
 Brf: string array
  Loc: SRC/array.h (121, 22)
  Org: [char ** array]
  Msh: char ** | 3:CharS | String()
 </summary>
</member><member name="P:LeptonicaSharp.L_Bytea.nalloc">
	<summary>
 Brf: number of bytes allocated in data array
  Loc: SRC/array.h (128, 22)
  Org: [size_t nalloc]
  Msh: size_t | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bytea.size">
	<summary>
 Brf: number of bytes presently used
  Loc: SRC/array.h (129, 22)
  Org: [size_t size]
  Msh: size_t | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bytea.refcount">
	<summary>
 Brf: reference count (1 if no clones)
  Loc: SRC/array.h (130, 22)
  Org: [l_int32 refcount]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bytea.data">
	<summary>
 Brf: data array
  Loc: SRC/array.h (131, 22)
  Org: [l_uint8 * data]
  Msh: l_uint8 * | 2:UChar | ([1 Byte, VB-Unsupported])
 </summary>
</member><member name="P:LeptonicaSharp.L_ByteBuffer.nalloc">
	<summary>
 Brf: size of allocated byte array
  Loc: SRC/bbuffer.h (52, 18)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_ByteBuffer.n">
	<summary>
 Brf: number of bytes read into to the array
  Loc: SRC/bbuffer.h (53, 18)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_ByteBuffer.nwritten">
	<summary>
 Brf: number of bytes written from the array
  Loc: SRC/bbuffer.h (54, 18)
  Org: [l_int32 nwritten]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_ByteBuffer.array">
	<summary>
 Brf: byte array
  Loc: SRC/bbuffer.h (55, 18)
  Org: [l_uint8 * array]
  Msh: l_uint8 * | 2:UChar | ([1 Byte, VB-Unsupported])
 </summary>
</member><member name="P:LeptonicaSharp.L_Heap.nalloc">
	<summary>
 Brf: size of allocated ptr array
  Loc: SRC/heap.h (79, 18)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Heap.n">
	<summary>
 Brf: number of elements stored in the heap
  Loc: SRC/heap.h (80, 18)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Heap.array">
	<summary>
 Brf: ptr array
  Loc: SRC/heap.h (81, 18)
  Org: [void ** array]
  Msh: void ** | 3:Void | IntPtr()
 </summary>
</member><member name="P:LeptonicaSharp.L_Heap.direction">
	<summary>
 Brf: L_SORT_INCREASING or L_SORT_DECREASING
  Loc: SRC/heap.h (82, 18)
  Org: [l_int32 direction]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.DoubleLinkedList.prev">
	<summary>
 Brf: 
  Loc: SRC/list.h (63, 33)
  Org: [struct DoubleLinkedList * prev]
  Msh: struct DoubleLinkedList * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.DoubleLinkedList._next_">
	<summary>
 Brf: 
  Loc: SRC/list.h (64, 33)
  Org: [struct DoubleLinkedList * next]
  Msh: struct DoubleLinkedList * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.DoubleLinkedList.data">
	<summary>
 Brf: 
  Loc: SRC/list.h (65, 33)
  Org: [void * data]
  Msh: void * | 2:Void |  ... Pointer auf Object = IntPtr
 </summary>
</member><member name="P:LeptonicaSharp.L_Ptra.nalloc">
	<summary>
 Brf: size of allocated ptr array
  Loc: SRC/ptra.h (53, 22)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Ptra.imax">
	<summary>
 Brf: greatest valid index
  Loc: SRC/ptra.h (54, 22)
  Org: [l_int32 imax]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Ptra.nactual">
	<summary>
 Brf: actual number of stored elements
  Loc: SRC/ptra.h (55, 22)
  Org: [l_int32 nactual]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Ptra.array">
	<summary>
 Brf: ptr array
  Loc: SRC/ptra.h (56, 22)
  Org: [void ** array]
  Msh: void ** | 3:Void | IntPtr()
 </summary>
</member><member name="P:LeptonicaSharp.L_Ptraa.nalloc">
	<summary>
 Brf: size of allocated ptr array
  Loc: SRC/ptra.h (64, 22)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Ptraa.ptra">
	<summary>
 Brf: array of ptra
  Loc: SRC/ptra.h (65, 22)
  Org: [struct L_Ptra ** ptra]
  Msh: struct L_Ptra ** | 3:StructDeclaration |  ... Marshal List of Class to PTR Typedef: L_Ptra = L_Ptra
 </summary>
</member><member name="P:LeptonicaSharp.L_Queue.nalloc">
	<summary>
 Brf: size of allocated ptr array
  Loc: SRC/queue.h (66, 22)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Queue.nhead">
	<summary>
 Brf: location of head (in ptrs) from the
  Loc: SRC/queue.h (67, 22)
  Org: [l_int32 nhead]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Queue.nelem">
	<summary>
 Brf: number of elements stored in the queue
  Loc: SRC/queue.h (69, 22)
  Org: [l_int32 nelem]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Queue.array">
	<summary>
 Brf: ptr array
  Loc: SRC/queue.h (70, 22)
  Org: [void ** array]
  Msh: void ** | 3:Void | IntPtr()
 </summary>
</member><member name="P:LeptonicaSharp.L_Queue.stack">
	<summary>
 Brf: auxiliary stack
  Loc: SRC/queue.h (71, 22)
  Org: [struct L_Stack * stack]
  Msh: struct L_Stack * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.Rb_Type.itype">
	<summary>
 Brf: 
  Loc: SRC/rbtree.h (62, 16)
  Org: [l_int64 itype]
  Msh: l_int64 | 1:LongLong |
 </summary>
</member><member name="P:LeptonicaSharp.Rb_Type.utype">
	<summary>
 Brf: 
  Loc: SRC/rbtree.h (63, 16)
  Org: [l_uint64 utype]
  Msh: l_uint64 | 1:ULongLong |
 </summary>
</member><member name="P:LeptonicaSharp.Rb_Type.ftype">
	<summary>
 Brf: 
  Loc: SRC/rbtree.h (64, 16)
  Org: [l_float64 ftype]
  Msh: l_float64 | 1:Double |
 </summary>
</member><member name="P:LeptonicaSharp.Rb_Type.ptype">
	<summary>
 Brf: 
  Loc: SRC/rbtree.h (65, 16)
  Org: [void * ptype]
  Msh: void * | 2:Void |  ... Pointer auf Object = IntPtr
 </summary>
</member><member name="P:LeptonicaSharp.L_Rbtree.root">
	<summary>
 Brf: 
  Loc: SRC/rbtree.h (70, 28)
  Org: [struct L_Rbtree_Node * root]
  Msh: struct L_Rbtree_Node * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rbtree.keytype">
	<summary>
 Brf: 
  Loc: SRC/rbtree.h (71, 28)
  Org: [l_int32 keytype]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rbtree_Node.key">
	<summary>
 Brf: 
  Loc: SRC/rbtree.h (78, 28)
  Org: [union Rb_Type key]
  Msh: Rb_Type | 1:UnionDeclaration |  Typedef: Rb_Type = Rb_Type
 </summary>
</member><member name="P:LeptonicaSharp.L_Rbtree_Node.value">
	<summary>
 Brf: 
  Loc: SRC/rbtree.h (79, 28)
  Org: [union Rb_Type value]
  Msh: Rb_Type | 1:UnionDeclaration |  Typedef: Rb_Type = Rb_Type
 </summary>
</member><member name="P:LeptonicaSharp.L_Rbtree_Node.left">
	<summary>
 Brf: 
  Loc: SRC/rbtree.h (80, 28)
  Org: [struct L_Rbtree_Node * left]
  Msh: struct L_Rbtree_Node * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rbtree_Node.right">
	<summary>
 Brf: 
  Loc: SRC/rbtree.h (81, 28)
  Org: [struct L_Rbtree_Node * right]
  Msh: struct L_Rbtree_Node * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rbtree_Node.parent">
	<summary>
 Brf: 
  Loc: SRC/rbtree.h (82, 28)
  Org: [struct L_Rbtree_Node * parent]
  Msh: struct L_Rbtree_Node * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rbtree_Node.color">
	<summary>
 Brf: 
  Loc: SRC/rbtree.h (83, 28)
  Org: [l_int32 color]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Stack.nalloc">
	<summary>
 Brf: size of ptr array
  Loc: SRC/stack.h (61, 22)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Stack.n">
	<summary>
 Brf: number of stored elements
  Loc: SRC/stack.h (62, 22)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Stack.array">
	<summary>
 Brf: ptr array
  Loc: SRC/stack.h (63, 22)
  Org: [void ** array]
  Msh: void ** | 3:Void | IntPtr()
 </summary>
</member><member name="P:LeptonicaSharp.L_Stack.auxstack">
	<summary>
 Brf: auxiliary stack
  Loc: SRC/stack.h (64, 22)
  Org: [struct L_Stack * auxstack]
  Msh: struct L_Stack * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bmf.pixa">
	<summary>
 Brf: pixa of bitmaps for 93 characters
  Loc: SRC/bmf.h (47, 19)
  Org: [struct Pixa * pixa]
  Msh: struct Pixa * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bmf.size">
	<summary>
 Brf: font size (in points at 300 ppi)
  Loc: SRC/bmf.h (48, 19)
  Org: [l_int32 size]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bmf.directory">
	<summary>
 Brf: directory containing font bitmaps
  Loc: SRC/bmf.h (49, 19)
  Org: [char * directory]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bmf.baseline1">
	<summary>
 Brf: baseline offset for ascii 33 - 57
  Loc: SRC/bmf.h (50, 19)
  Org: [l_int32 baseline1]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bmf.baseline2">
	<summary>
 Brf: baseline offset for ascii 58 - 91
  Loc: SRC/bmf.h (51, 19)
  Org: [l_int32 baseline2]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bmf.baseline3">
	<summary>
 Brf: baseline offset for ascii 93 - 126
  Loc: SRC/bmf.h (52, 19)
  Org: [l_int32 baseline3]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bmf.lineheight">
	<summary>
 Brf: max height of line of chars
  Loc: SRC/bmf.h (53, 19)
  Org: [l_int32 lineheight]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bmf.kernwidth">
	<summary>
 Brf: pixel dist between char bitmaps
  Loc: SRC/bmf.h (54, 19)
  Org: [l_int32 kernwidth]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bmf.spacewidth">
	<summary>
 Brf: pixel dist between word bitmaps
  Loc: SRC/bmf.h (55, 19)
  Org: [l_int32 spacewidth]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bmf.vertlinesep">
	<summary>
 Brf: extra vertical space between text lines
  Loc: SRC/bmf.h (56, 19)
  Org: [l_int32 vertlinesep]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bmf.fonttab">
	<summary>
 Brf: table mapping ascii -- bigger  font index
  Loc: SRC/bmf.h (57, 19)
  Org: [l_int32 * fonttab]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.L_Bmf.baselinetab">
	<summary>
 Brf: table mapping ascii -- bigger  baseline offset
  Loc: SRC/bmf.h (58, 19)
  Org: [l_int32 * baselinetab]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.L_Bmf.widthtab">
	<summary>
 Brf: table mapping ascii -- bigger  char width
  Loc: SRC/bmf.h (59, 19)
  Org: [l_int32 * widthtab]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.CCBord.pix">
	<summary>
 Brf: component bitmap (min size)
  Loc: SRC/ccbord.h (93, 26)
  Org: [struct Pix * pix]
  Msh: struct Pix * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.CCBord.boxa">
	<summary>
 Brf: regions of each closed curve
  Loc: SRC/ccbord.h (94, 26)
  Org: [struct Boxa * boxa]
  Msh: struct Boxa * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.CCBord.start">
	<summary>
 Brf: initial border pixel locations
  Loc: SRC/ccbord.h (95, 26)
  Org: [struct Pta * start]
  Msh: struct Pta * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.CCBord.refcount">
	<summary>
 Brf: number of handles; start at 1
  Loc: SRC/ccbord.h (96, 26)
  Org: [l_int32 refcount]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.CCBord.local">
	<summary>
 Brf: ptaa of chain pixels (local)
  Loc: SRC/ccbord.h (97, 26)
  Org: [struct Ptaa * local]
  Msh: struct Ptaa * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.CCBord._global_">
	<summary>
 Brf: ptaa of chain pixels (global)
  Loc: SRC/ccbord.h (98, 26)
  Org: [struct Ptaa * global]
  Msh: struct Ptaa * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.CCBord._step_">
	<summary>
 Brf: numaa of chain code (step dir)
  Loc: SRC/ccbord.h (99, 26)
  Org: [struct Numaa * step]
  Msh: struct Numaa * | 2:Struct |  Typedef: Numaa = Numaa
 </summary>
</member><member name="P:LeptonicaSharp.CCBord.splocal">
	<summary>
 Brf: pta of single chain (local)
  Loc: SRC/ccbord.h (100, 26)
  Org: [struct Pta * splocal]
  Msh: struct Pta * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.CCBord.spglobal">
	<summary>
 Brf: pta of single chain (global)
  Loc: SRC/ccbord.h (101, 26)
  Org: [struct Pta * spglobal]
  Msh: struct Pta * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.CCBorda.pix">
	<summary>
 Brf: input pix (may be null)
  Loc: SRC/ccbord.h (108, 26)
  Org: [struct Pix * pix]
  Msh: struct Pix * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.CCBorda.w">
	<summary>
 Brf: width of pix
  Loc: SRC/ccbord.h (109, 26)
  Org: [l_int32 w]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.CCBorda.h">
	<summary>
 Brf: height of pix
  Loc: SRC/ccbord.h (110, 26)
  Org: [l_int32 h]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.CCBorda.n">
	<summary>
 Brf: number of ccbord in ptr array
  Loc: SRC/ccbord.h (111, 26)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.CCBorda.nalloc">
	<summary>
 Brf: number of ccbord ptrs allocated
  Loc: SRC/ccbord.h (112, 26)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.CCBorda.ccb">
	<summary>
 Brf: ccb ptr array
  Loc: SRC/ccbord.h (113, 26)
  Org: [struct CCBord ** ccb]
  Msh: struct CCBord ** | 3:StructDeclaration |  ... Marshal List of Class to PTR Typedef: CCBord = CCBord
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.nalloc">
	<summary>
 Brf: size of dewarp ptr array
  Loc: SRC/dewarp.h (115, 24)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.maxpage">
	<summary>
 Brf: maximum page number in array
  Loc: SRC/dewarp.h (116, 24)
  Org: [l_int32 maxpage]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.dewarp">
	<summary>
 Brf: array of ptrs to page dewarp
  Loc: SRC/dewarp.h (117, 24)
  Org: [struct L_Dewarp ** dewarp]
  Msh: struct L_Dewarp ** | 3:StructDeclaration |  ... Marshal List of Class to PTR
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.dewarpcache">
	<summary>
 Brf: array of ptrs to cached dewarps
  Loc: SRC/dewarp.h (118, 24)
  Org: [struct L_Dewarp ** dewarpcache]
  Msh: struct L_Dewarp ** | 3:StructDeclaration |  ... Marshal List of Class to PTR
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.namodels">
	<summary>
 Brf: list of page numbers for pages
  Loc: SRC/dewarp.h (119, 24)
  Org: [struct Numa * namodels]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.napages">
	<summary>
 Brf: list of page numbers with either
  Loc: SRC/dewarp.h (121, 24)
  Org: [struct Numa * napages]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.redfactor">
	<summary>
 Brf: reduction factor of input: 1 or 2
  Loc: SRC/dewarp.h (123, 24)
  Org: [l_int32 redfactor]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.sampling">
	<summary>
 Brf: disparity arrays sampling factor
  Loc: SRC/dewarp.h (124, 24)
  Org: [l_int32 sampling]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.minlines">
	<summary>
 Brf: min number of long lines required
  Loc: SRC/dewarp.h (125, 24)
  Org: [l_int32 minlines]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.maxdist">
	<summary>
 Brf: max distance for getting ref page
  Loc: SRC/dewarp.h (126, 24)
  Org: [l_int32 maxdist]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.max_linecurv">
	<summary>
 Brf: maximum abs line curvature,
  Loc: SRC/dewarp.h (127, 24)
  Org: [l_int32 max_linecurv]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.min_diff_linecurv">
	<summary>
 Brf: minimum abs diff line
  Loc: SRC/dewarp.h (129, 24)
  Org: [l_int32 min_diff_linecurv]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.max_diff_linecurv">
	<summary>
 Brf: maximum abs diff line
  Loc: SRC/dewarp.h (131, 24)
  Org: [l_int32 max_diff_linecurv]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.max_edgeslope">
	<summary>
 Brf: maximum abs left or right edge
  Loc: SRC/dewarp.h (133, 24)
  Org: [l_int32 max_edgeslope]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.max_edgecurv">
	<summary>
 Brf: maximum abs left or right edge
  Loc: SRC/dewarp.h (135, 24)
  Org: [l_int32 max_edgecurv]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.max_diff_edgecurv">
	<summary>
 Brf: maximum abs diff left-right
  Loc: SRC/dewarp.h (137, 24)
  Org: [l_int32 max_diff_edgecurv]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.useboth">
	<summary>
 Brf: use both disparity arrays if
  Loc: SRC/dewarp.h (139, 24)
  Org: [l_int32 useboth]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.check_columns">
	<summary>
 Brf: if there are multiple columns,
  Loc: SRC/dewarp.h (141, 24)
  Org: [l_int32 check_columns]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarpa.modelsready">
	<summary>
 Brf: invalid models have been removed
  Loc: SRC/dewarp.h (144, 24)
  Org: [l_int32 modelsready]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.dewa">
	<summary>
 Brf: ptr to parent (not owned)
  Loc: SRC/dewarp.h (153, 24)
  Org: [struct L_Dewarpa * dewa]
  Msh: struct L_Dewarpa * | 2:Struct |  Typedef: L_Dewarpa = L_Dewarpa
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.pixs">
	<summary>
 Brf: source pix, 1 bpp
  Loc: SRC/dewarp.h (154, 24)
  Org: [struct Pix * pixs]
  Msh: struct Pix * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.sampvdispar">
	<summary>
 Brf: sampled vert disparity array
  Loc: SRC/dewarp.h (155, 24)
  Org: [struct FPix * sampvdispar]
  Msh: struct FPix * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.samphdispar">
	<summary>
 Brf: sampled horiz disparity array
  Loc: SRC/dewarp.h (156, 24)
  Org: [struct FPix * samphdispar]
  Msh: struct FPix * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.sampydispar">
	<summary>
 Brf: sampled slope h-disparity array
  Loc: SRC/dewarp.h (157, 24)
  Org: [struct FPix * sampydispar]
  Msh: struct FPix * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.fullvdispar">
	<summary>
 Brf: full vert disparity array
  Loc: SRC/dewarp.h (158, 24)
  Org: [struct FPix * fullvdispar]
  Msh: struct FPix * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.fullhdispar">
	<summary>
 Brf: full horiz disparity array
  Loc: SRC/dewarp.h (159, 24)
  Org: [struct FPix * fullhdispar]
  Msh: struct FPix * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.fullydispar">
	<summary>
 Brf: full slope h-disparity array
  Loc: SRC/dewarp.h (160, 24)
  Org: [struct FPix * fullydispar]
  Msh: struct FPix * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.namidys">
	<summary>
 Brf: sorted y val of midpoint each line
  Loc: SRC/dewarp.h (161, 24)
  Org: [struct Numa * namidys]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.nacurves">
	<summary>
 Brf: sorted curvature of each line
  Loc: SRC/dewarp.h (162, 24)
  Org: [struct Numa * nacurves]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.w">
	<summary>
 Brf: width of source image
  Loc: SRC/dewarp.h (163, 24)
  Org: [l_int32 w]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.h">
	<summary>
 Brf: height of source image
  Loc: SRC/dewarp.h (164, 24)
  Org: [l_int32 h]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.pageno">
	<summary>
 Brf: page number; important for reuse
  Loc: SRC/dewarp.h (165, 24)
  Org: [l_int32 pageno]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.sampling">
	<summary>
 Brf: sampling factor of disparity arrays
  Loc: SRC/dewarp.h (166, 24)
  Org: [l_int32 sampling]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.redfactor">
	<summary>
 Brf: reduction factor of pixs: 1 or 2
  Loc: SRC/dewarp.h (167, 24)
  Org: [l_int32 redfactor]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.minlines">
	<summary>
 Brf: min number of long lines required
  Loc: SRC/dewarp.h (168, 24)
  Org: [l_int32 minlines]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.nlines">
	<summary>
 Brf: number of long lines found
  Loc: SRC/dewarp.h (169, 24)
  Org: [l_int32 nlines]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.mincurv">
	<summary>
 Brf: min line curvature in micro-units
  Loc: SRC/dewarp.h (170, 24)
  Org: [l_int32 mincurv]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.maxcurv">
	<summary>
 Brf: max line curvature in micro-units
  Loc: SRC/dewarp.h (171, 24)
  Org: [l_int32 maxcurv]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.leftslope">
	<summary>
 Brf: left edge slope in milli-units
  Loc: SRC/dewarp.h (172, 24)
  Org: [l_int32 leftslope]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.rightslope">
	<summary>
 Brf: right edge slope in milli-units
  Loc: SRC/dewarp.h (173, 24)
  Org: [l_int32 rightslope]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.leftcurv">
	<summary>
 Brf: left edge curvature in micro-units
  Loc: SRC/dewarp.h (174, 24)
  Org: [l_int32 leftcurv]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.rightcurv">
	<summary>
 Brf: right edge curvature in micro-units
  Loc: SRC/dewarp.h (175, 24)
  Org: [l_int32 rightcurv]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.nx">
	<summary>
 Brf: number of sampling pts in x-dir
  Loc: SRC/dewarp.h (176, 24)
  Org: [l_int32 nx]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.ny">
	<summary>
 Brf: number of sampling pts in y-dir
  Loc: SRC/dewarp.h (177, 24)
  Org: [l_int32 ny]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.hasref">
	<summary>
 Brf: 0 if normal; 1 if has a refpage
  Loc: SRC/dewarp.h (178, 24)
  Org: [l_int32 hasref]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.refpage">
	<summary>
 Brf: page with disparity model to use
  Loc: SRC/dewarp.h (179, 24)
  Org: [l_int32 refpage]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.vsuccess">
	<summary>
 Brf: sets to 1 if vert disparity builds
  Loc: SRC/dewarp.h (180, 24)
  Org: [l_int32 vsuccess]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.hsuccess">
	<summary>
 Brf: sets to 1 if horiz disparity builds
  Loc: SRC/dewarp.h (181, 24)
  Org: [l_int32 hsuccess]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.ysuccess">
	<summary>
 Brf: sets to 1 if slope disparity builds
  Loc: SRC/dewarp.h (182, 24)
  Org: [l_int32 ysuccess]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.vvalid">
	<summary>
 Brf: sets to 1 if valid vert disparity
  Loc: SRC/dewarp.h (183, 24)
  Org: [l_int32 vvalid]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.hvalid">
	<summary>
 Brf: sets to 1 if valid horiz disparity
  Loc: SRC/dewarp.h (184, 24)
  Org: [l_int32 hvalid]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.skip_horiz">
	<summary>
 Brf: if 1, skip horiz disparity
  Loc: SRC/dewarp.h (185, 24)
  Org: [l_int32 skip_horiz]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Dewarp.debug">
	<summary>
 Brf: set to 1 if debug output requested
  Loc: SRC/dewarp.h (187, 24)
  Org: [l_int32 debug]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.rootname">
	<summary>
 Brf: for cmd, data, output
  Loc: SRC/gplot.h (77, 20)
  Org: [char * rootname]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.cmdname">
	<summary>
 Brf: command file name
  Loc: SRC/gplot.h (78, 20)
  Org: [char * cmdname]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.cmddata">
	<summary>
 Brf: command file contents
  Loc: SRC/gplot.h (79, 20)
  Org: [struct Sarray * cmddata]
  Msh: struct Sarray * | 2:Struct |  Typedef: Sarray = Sarray
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.datanames">
	<summary>
 Brf: data file names
  Loc: SRC/gplot.h (80, 20)
  Org: [struct Sarray * datanames]
  Msh: struct Sarray * | 2:Struct |  Typedef: Sarray = Sarray
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.plotdata">
	<summary>
 Brf: plot data (1 string/file)
  Loc: SRC/gplot.h (81, 20)
  Org: [struct Sarray * plotdata]
  Msh: struct Sarray * | 2:Struct |  Typedef: Sarray = Sarray
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.plottitles">
	<summary>
 Brf: title for each individual plot
  Loc: SRC/gplot.h (82, 20)
  Org: [struct Sarray * plottitles]
  Msh: struct Sarray * | 2:Struct |  Typedef: Sarray = Sarray
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.plotstyles">
	<summary>
 Brf: plot style for individual plots
  Loc: SRC/gplot.h (83, 20)
  Org: [struct Numa * plotstyles]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.nplots">
	<summary>
 Brf: current number of plots
  Loc: SRC/gplot.h (84, 20)
  Org: [l_int32 nplots]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.outname">
	<summary>
 Brf: output file name
  Loc: SRC/gplot.h (85, 20)
  Org: [char * outname]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.outformat">
	<summary>
 Brf: GPLOT_OUTPUT values
  Loc: SRC/gplot.h (86, 20)
  Org: [l_int32 outformat]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.scaling">
	<summary>
 Brf: GPLOT_SCALING values
  Loc: SRC/gplot.h (87, 20)
  Org: [l_int32 scaling]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.title">
	<summary>
 Brf: optional
  Loc: SRC/gplot.h (88, 20)
  Org: [char * title]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.xlabel">
	<summary>
 Brf: optional x axis label
  Loc: SRC/gplot.h (89, 20)
  Org: [char * xlabel]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.GPlot.ylabel">
	<summary>
 Brf: optional y axis label
  Loc: SRC/gplot.h (90, 20)
  Org: [char * ylabel]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.type">
	<summary>
 Brf: encoding type: L_JPEG_ENCODE, etc
  Loc: SRC/imageio.h (168, 24)
  Org: [l_int32 type]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.datacomp">
	<summary>
 Brf: gzipped raster data
  Loc: SRC/imageio.h (169, 24)
  Org: [l_uint8 * datacomp]
  Msh: l_uint8 * | 2:UChar | ([1 Byte, VB-Unsupported])
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.nbytescomp">
	<summary>
 Brf: number of compressed bytes
  Loc: SRC/imageio.h (170, 24)
  Org: [size_t nbytescomp]
  Msh: size_t | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.data85">
	<summary>
 Brf: ascii85-encoded gzipped raster data
  Loc: SRC/imageio.h (171, 24)
  Org: [char * data85]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.nbytes85">
	<summary>
 Brf: number of ascii85 encoded bytes
  Loc: SRC/imageio.h (172, 24)
  Org: [size_t nbytes85]
  Msh: size_t | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.cmapdata85">
	<summary>
 Brf: ascii85-encoded uncompressed cmap
  Loc: SRC/imageio.h (173, 24)
  Org: [char * cmapdata85]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.cmapdatahex">
	<summary>
 Brf: hex pdf array for the cmap
  Loc: SRC/imageio.h (174, 24)
  Org: [char * cmapdatahex]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.ncolors">
	<summary>
 Brf: number of colors in cmap
  Loc: SRC/imageio.h (175, 24)
  Org: [l_int32 ncolors]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.w">
	<summary>
 Brf: image width
  Loc: SRC/imageio.h (176, 24)
  Org: [l_int32 w]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.h">
	<summary>
 Brf: image height
  Loc: SRC/imageio.h (177, 24)
  Org: [l_int32 h]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.bps">
	<summary>
 Brf: bits/sample; typ. 1, 2, 4 or 8
  Loc: SRC/imageio.h (178, 24)
  Org: [l_int32 bps]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.spp">
	<summary>
 Brf: samples/pixel; typ. 1 or 3
  Loc: SRC/imageio.h (179, 24)
  Org: [l_int32 spp]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.minisblack">
	<summary>
 Brf: tiff g4 photometry
  Loc: SRC/imageio.h (180, 24)
  Org: [l_int32 minisblack]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.predictor">
	<summary>
 Brf: flate data has PNG predictors
  Loc: SRC/imageio.h (181, 24)
  Org: [l_int32 predictor]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.nbytes">
	<summary>
 Brf: number of uncompressed raster bytes
  Loc: SRC/imageio.h (182, 24)
  Org: [size_t nbytes]
  Msh: size_t | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.L_Compressed_Data.res">
	<summary>
 Brf: resolution (ppi)
  Loc: SRC/imageio.h (183, 24)
  Org: [l_int32 res]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.title">
	<summary>
 Brf: optional title for pdf
  Loc: SRC/imageio.h (213, 24)
  Org: [char * title]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.n">
	<summary>
 Brf: number of images
  Loc: SRC/imageio.h (214, 24)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.ncmap">
	<summary>
 Brf: number of colormaps
  Loc: SRC/imageio.h (215, 24)
  Org: [l_int32 ncmap]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.cida">
	<summary>
 Brf: array of compressed image data
  Loc: SRC/imageio.h (216, 24)
  Org: [struct L_Ptra * cida]
  Msh: struct L_Ptra * | 2:Struct |  Typedef: L_Ptra = L_Ptra
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.id">
	<summary>
 Brf: %PDF-1.2 id string
  Loc: SRC/imageio.h (217, 24)
  Org: [char * id]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.obj1">
	<summary>
 Brf: catalog string
  Loc: SRC/imageio.h (218, 24)
  Org: [char * obj1]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.obj2">
	<summary>
 Brf: metadata string
  Loc: SRC/imageio.h (219, 24)
  Org: [char * obj2]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.obj3">
	<summary>
 Brf: pages string
  Loc: SRC/imageio.h (220, 24)
  Org: [char * obj3]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.obj4">
	<summary>
 Brf: page string (variable data)
  Loc: SRC/imageio.h (221, 24)
  Org: [char * obj4]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.obj5">
	<summary>
 Brf: content string (variable data)
  Loc: SRC/imageio.h (222, 24)
  Org: [char * obj5]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.poststream">
	<summary>
 Brf: post-binary-stream string
  Loc: SRC/imageio.h (223, 24)
  Org: [char * poststream]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.trailer">
	<summary>
 Brf: trailer string (variable data)
  Loc: SRC/imageio.h (224, 24)
  Org: [char * trailer]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.xy">
	<summary>
 Brf: store (xpt, ypt) array
  Loc: SRC/imageio.h (225, 24)
  Org: [struct Pta * xy]
  Msh: struct Pta * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.wh">
	<summary>
 Brf: store (wpt, hpt) array
  Loc: SRC/imageio.h (226, 24)
  Org: [struct Pta * wh]
  Msh: struct Pta * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.mediabox">
	<summary>
 Brf: bounding region for all images
  Loc: SRC/imageio.h (227, 24)
  Org: [struct Box * mediabox]
  Msh: struct Box * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.saprex">
	<summary>
 Brf: pre-binary-stream xobject strings
  Loc: SRC/imageio.h (228, 24)
  Org: [struct Sarray * saprex]
  Msh: struct Sarray * | 2:Struct |  Typedef: Sarray = Sarray
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.sacmap">
	<summary>
 Brf: colormap pdf object strings
  Loc: SRC/imageio.h (229, 24)
  Org: [struct Sarray * sacmap]
  Msh: struct Sarray * | 2:Struct |  Typedef: Sarray = Sarray
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.objsize">
	<summary>
 Brf: sizes of each pdf string object
  Loc: SRC/imageio.h (230, 24)
  Org: [struct L_Dna * objsize]
  Msh: struct L_Dna * | 2:Struct |  Typedef: L_Dna = L_Dna
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.objloc">
	<summary>
 Brf: location of each pdf string object
  Loc: SRC/imageio.h (231, 24)
  Org: [struct L_Dna * objloc]
  Msh: struct L_Dna * | 2:Struct |  Typedef: L_Dna = L_Dna
 </summary>
</member><member name="P:LeptonicaSharp.L_Pdf_Data.xrefloc">
	<summary>
 Brf: location of xref
  Loc: SRC/imageio.h (232, 24)
  Org: [l_int32 xrefloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.safiles">
	<summary>
 Brf: input page image file names
  Loc: SRC/jbclass.h (49, 22)
  Org: [struct Sarray * safiles]
  Msh: struct Sarray * | 2:Struct |  Typedef: Sarray = Sarray
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.method">
	<summary>
 Brf: JB_RANKHAUS, JB_CORRELATION
  Loc: SRC/jbclass.h (50, 22)
  Org: [l_int32 method]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.components">
	<summary>
 Brf: JB_CONN_COMPS, JB_CHARACTERS or
  Loc: SRC/jbclass.h (51, 22)
  Org: [l_int32 components]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.maxwidth">
	<summary>
 Brf: max component width allowed
  Loc: SRC/jbclass.h (53, 22)
  Org: [l_int32 maxwidth]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.maxheight">
	<summary>
 Brf: max component height allowed
  Loc: SRC/jbclass.h (54, 22)
  Org: [l_int32 maxheight]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.npages">
	<summary>
 Brf: number of pages already processed
  Loc: SRC/jbclass.h (55, 22)
  Org: [l_int32 npages]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.baseindex">
	<summary>
 Brf: number components already processed
  Loc: SRC/jbclass.h (56, 22)
  Org: [l_int32 baseindex]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.nacomps">
	<summary>
 Brf: number of components on each page
  Loc: SRC/jbclass.h (58, 22)
  Org: [struct Numa * nacomps]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.sizehaus">
	<summary>
 Brf: size of square struct elem for haus
  Loc: SRC/jbclass.h (59, 22)
  Org: [l_int32 sizehaus]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.rankhaus">
	<summary>
 Brf: rank val of haus match, each way
  Loc: SRC/jbclass.h (60, 22)
  Org: [l_float32 rankhaus]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.thresh">
	<summary>
 Brf: thresh value for correlation score
  Loc: SRC/jbclass.h (61, 22)
  Org: [l_float32 thresh]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.weightfactor">
	<summary>
 Brf: corrects thresh value for heaver
  Loc: SRC/jbclass.h (62, 22)
  Org: [l_float32 weightfactor]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.naarea">
	<summary>
 Brf: w * h of each template, without
  Loc: SRC/jbclass.h (64, 22)
  Org: [struct Numa * naarea]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.w">
	<summary>
 Brf: max width of original src images
  Loc: SRC/jbclass.h (66, 22)
  Org: [l_int32 w]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.h">
	<summary>
 Brf: max height of original src images
  Loc: SRC/jbclass.h (67, 22)
  Org: [l_int32 h]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.nclass">
	<summary>
 Brf: current number of classes
  Loc: SRC/jbclass.h (68, 22)
  Org: [l_int32 nclass]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.keep_pixaa">
	<summary>
 Brf: If zero, pixaa isn't filled
  Loc: SRC/jbclass.h (69, 22)
  Org: [l_int32 keep_pixaa]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.pixaa">
	<summary>
 Brf: instances for each class; unbordered
  Loc: SRC/jbclass.h (70, 22)
  Org: [struct Pixaa * pixaa]
  Msh: struct Pixaa * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.pixat">
	<summary>
 Brf: templates for each class; bordered
  Loc: SRC/jbclass.h (71, 22)
  Org: [struct Pixa * pixat]
  Msh: struct Pixa * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.pixatd">
	<summary>
 Brf: templates for each class; bordered
  Loc: SRC/jbclass.h (73, 22)
  Org: [struct Pixa * pixatd]
  Msh: struct Pixa * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.dahash">
	<summary>
 Brf: Hash table to find templates by size
  Loc: SRC/jbclass.h (75, 23)
  Org: [struct L_DnaHash * dahash]
  Msh: struct L_DnaHash * | 2:Struct |  Typedef: L_DnaHash = L_DnaHash
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.nafgt">
	<summary>
 Brf: fg areas of undilated templates;
  Loc: SRC/jbclass.h (76, 22)
  Org: [struct Numa * nafgt]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.ptac">
	<summary>
 Brf: centroids of all bordered cc
  Loc: SRC/jbclass.h (78, 22)
  Org: [struct Pta * ptac]
  Msh: struct Pta * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.ptact">
	<summary>
 Brf: centroids of all bordered template cc
  Loc: SRC/jbclass.h (79, 22)
  Org: [struct Pta * ptact]
  Msh: struct Pta * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.naclass">
	<summary>
 Brf: array of class ids for each component
  Loc: SRC/jbclass.h (80, 22)
  Org: [struct Numa * naclass]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.napage">
	<summary>
 Brf: array of page nums for each component
  Loc: SRC/jbclass.h (81, 22)
  Org: [struct Numa * napage]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.ptaul">
	<summary>
 Brf: array of UL corners at which the
  Loc: SRC/jbclass.h (82, 22)
  Org: [struct Pta * ptaul]
  Msh: struct Pta * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.JbClasser.ptall">
	<summary>
 Brf: similar to ptaul, but for LL corners
  Loc: SRC/jbclass.h (85, 22)
  Org: [struct Pta * ptall]
  Msh: struct Pta * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.JbData.pix">
	<summary>
 Brf: template composite for all classes
  Loc: SRC/jbclass.h (106, 22)
  Org: [struct Pix * pix]
  Msh: struct Pix * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.JbData.npages">
	<summary>
 Brf: number of pages
  Loc: SRC/jbclass.h (107, 22)
  Org: [l_int32 npages]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbData.w">
	<summary>
 Brf: max width of original page images
  Loc: SRC/jbclass.h (108, 22)
  Org: [l_int32 w]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbData.h">
	<summary>
 Brf: max height of original page images
  Loc: SRC/jbclass.h (109, 22)
  Org: [l_int32 h]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbData.nclass">
	<summary>
 Brf: number of classes
  Loc: SRC/jbclass.h (110, 22)
  Org: [l_int32 nclass]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbData.latticew">
	<summary>
 Brf: lattice width for template composite
  Loc: SRC/jbclass.h (111, 22)
  Org: [l_int32 latticew]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbData.latticeh">
	<summary>
 Brf: lattice height for template composite
  Loc: SRC/jbclass.h (112, 22)
  Org: [l_int32 latticeh]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbData.naclass">
	<summary>
 Brf: array of class ids for each component
  Loc: SRC/jbclass.h (113, 22)
  Org: [struct Numa * naclass]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.JbData.napage">
	<summary>
 Brf: array of page nums for each component
  Loc: SRC/jbclass.h (114, 22)
  Org: [struct Numa * napage]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.JbData.ptaul">
	<summary>
 Brf: array of UL corners at which the
  Loc: SRC/jbclass.h (115, 22)
  Org: [struct Pta * ptaul]
  Msh: struct Pta * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.Sel.sy">
	<summary>
 Brf: sel height
  Loc: SRC/morph.h (64, 19)
  Org: [l_int32 sy]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Sel.sx">
	<summary>
 Brf: sel width
  Loc: SRC/morph.h (65, 19)
  Org: [l_int32 sx]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Sel.cy">
	<summary>
 Brf: y location of sel origin
  Loc: SRC/morph.h (66, 19)
  Org: [l_int32 cy]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Sel.cx">
	<summary>
 Brf: x location of sel origin
  Loc: SRC/morph.h (67, 19)
  Org: [l_int32 cx]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Sel.data">
	<summary>
 Brf: {0,1,2}; data[i][j] in [row][col] order
  Loc: SRC/morph.h (68, 19)
  Org: [l_int32 ** data]
  Msh: l_int32 ** | 3:Integer | List (of Integer())
 </summary>
</member><member name="P:LeptonicaSharp.Sel.name">
	<summary>
 Brf: used to find sel by name
  Loc: SRC/morph.h (69, 19)
  Org: [char * name]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.Sela.n">
	<summary>
 Brf: number of sel actually stored
  Loc: SRC/morph.h (76, 22)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Sela.nalloc">
	<summary>
 Brf: size of allocated ptr array
  Loc: SRC/morph.h (77, 22)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Sela.sel">
	<summary>
 Brf: sel ptr array
  Loc: SRC/morph.h (78, 22)
  Org: [struct Sel ** sel]
  Msh: struct Sel ** | 3:StructDeclaration |  ... Marshal List of Class to PTR Typedef: Sel = Sel
 </summary>
</member><member name="P:LeptonicaSharp.L_Kernel.sy">
	<summary>
 Brf: kernel height
  Loc: SRC/morph.h (91, 19)
  Org: [l_int32 sy]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Kernel.sx">
	<summary>
 Brf: kernel width
  Loc: SRC/morph.h (92, 19)
  Org: [l_int32 sx]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Kernel.cy">
	<summary>
 Brf: y location of kernel origin
  Loc: SRC/morph.h (93, 19)
  Org: [l_int32 cy]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Kernel.cx">
	<summary>
 Brf: x location of kernel origin
  Loc: SRC/morph.h (94, 19)
  Org: [l_int32 cx]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Kernel.data">
	<summary>
 Brf: data[i][j] in [row][col] order
  Loc: SRC/morph.h (95, 19)
  Org: [l_float32 ** data]
  Msh: l_float32 ** | 3:Float | List (of Single())
 </summary>
</member><member name="P:LeptonicaSharp.Pix.w">
	<summary>
 Brf: width in pixels
  Loc: SRC/pix.h (136, 26)
  Org: [l_uint32 w]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.Pix.h">
	<summary>
 Brf: height in pixels
  Loc: SRC/pix.h (137, 26)
  Org: [l_uint32 h]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.Pix.d">
	<summary>
 Brf: depth in bits (bpp)
  Loc: SRC/pix.h (138, 26)
  Org: [l_uint32 d]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.Pix.spp">
	<summary>
 Brf: number of samples per pixel
  Loc: SRC/pix.h (139, 26)
  Org: [l_uint32 spp]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.Pix.wpl">
	<summary>
 Brf: 32-bit words/line
  Loc: SRC/pix.h (140, 26)
  Org: [l_uint32 wpl]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.Pix.refcount">
	<summary>
 Brf: reference count (1 if no clones)
  Loc: SRC/pix.h (141, 26)
  Org: [l_uint32 refcount]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.Pix.xres">
	<summary>
 Brf: image res (ppi) in x direction
  Loc: SRC/pix.h (142, 26)
  Org: [l_int32 xres]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Pix.yres">
	<summary>
 Brf: image res (ppi) in y direction
  Loc: SRC/pix.h (144, 26)
  Org: [l_int32 yres]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Pix.informat">
	<summary>
 Brf: input file format, IFF_*
  Loc: SRC/pix.h (146, 26)
  Org: [l_int32 informat]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Pix.special">
	<summary>
 Brf: special instructions for I/O, etc
  Loc: SRC/pix.h (147, 26)
  Org: [l_int32 special]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Pix.text">
	<summary>
 Brf: text string associated with pix
  Loc: SRC/pix.h (148, 26)
  Org: [char * text]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.Pix.colormap">
	<summary>
 Brf: colormap (may be null)
  Loc: SRC/pix.h (149, 26)
  Org: [struct PixColormap * colormap]
  Msh: struct PixColormap * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.Pix.data">
	<summary>
 Brf: the image data
  Loc: SRC/pix.h (150, 26)
  Org: [l_uint32 * data]
  Msh: l_uint32 * | 2:UInt |  ... UInt = 4 Byte * Len)
 </summary>
</member><member name="P:LeptonicaSharp.PixColormap.array">
	<summary>
 Brf: colormap table (array of RGBA_QUAD)
  Loc: SRC/pix.h (157, 22)
  Org: [void * array]
  Msh: void * | 2:Void |  ... Pointer auf Object = IntPtr
 </summary>
</member><member name="P:LeptonicaSharp.PixColormap.depth">
	<summary>
 Brf: of pix (1, 2, 4 or 8 bpp)
  Loc: SRC/pix.h (158, 22)
  Org: [l_int32 depth]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixColormap.nalloc">
	<summary>
 Brf: number of color entries allocated
  Loc: SRC/pix.h (159, 22)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixColormap.n">
	<summary>
 Brf: number of color entries used
  Loc: SRC/pix.h (160, 22)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.RGBA_Quad.blue">
	<summary>
 Brf: blue value
  Loc: SRC/pix.h (171, 17)
  Org: [l_uint8 blue]
  Msh: l_uint8 | 1:UChar |
 </summary>
</member><member name="P:LeptonicaSharp.RGBA_Quad.green">
	<summary>
 Brf: green value
  Loc: SRC/pix.h (172, 17)
  Org: [l_uint8 green]
  Msh: l_uint8 | 1:UChar |
 </summary>
</member><member name="P:LeptonicaSharp.RGBA_Quad.red">
	<summary>
 Brf: red value
  Loc: SRC/pix.h (173, 17)
  Org: [l_uint8 red]
  Msh: l_uint8 | 1:UChar |
 </summary>
</member><member name="P:LeptonicaSharp.RGBA_Quad.alpha">
	<summary>
 Brf: alpha value
  Loc: SRC/pix.h (174, 17)
  Org: [l_uint8 alpha]
  Msh: l_uint8 | 1:UChar |
 </summary>
</member><member name="P:LeptonicaSharp.Pixa.n">
	<summary>
 Brf: number of Pix in ptr array
  Loc: SRC/pix.h (456, 25)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Pixa.nalloc">
	<summary>
 Brf: number of Pix ptrs allocated
  Loc: SRC/pix.h (457, 25)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Pixa.refcount">
	<summary>
 Brf: reference count (1 if no clones)
  Loc: SRC/pix.h (458, 25)
  Org: [l_uint32 refcount]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.Pixa.pix">
	<summary>
 Brf: the array of ptrs to pix
  Loc: SRC/pix.h (459, 25)
  Org: [struct Pix ** pix]
  Msh: struct Pix ** | 3:StructDeclaration |  ... Marshal List of Class to PTR Typedef: Pix = Pix
 </summary>
</member><member name="P:LeptonicaSharp.Pixa.boxa">
	<summary>
 Brf: array of boxes
  Loc: SRC/pix.h (460, 25)
  Org: [struct Boxa * boxa]
  Msh: struct Boxa * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.Pixaa.n">
	<summary>
 Brf: number of Pixa in ptr array
  Loc: SRC/pix.h (467, 25)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Pixaa.nalloc">
	<summary>
 Brf: number of Pixa ptrs allocated
  Loc: SRC/pix.h (468, 25)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Pixaa.pixa">
	<summary>
 Brf: array of ptrs to pixa
  Loc: SRC/pix.h (469, 25)
  Org: [struct Pixa ** pixa]
  Msh: struct Pixa ** | 3:StructDeclaration |  ... Marshal List of Class to PTR Typedef: Pixa = Pixa
 </summary>
</member><member name="P:LeptonicaSharp.Pixaa.boxa">
	<summary>
 Brf: array of boxes
  Loc: SRC/pix.h (470, 25)
  Org: [struct Boxa * boxa]
  Msh: struct Boxa * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.Box.x">
	<summary>
 Brf: left coordinate
  Loc: SRC/pix.h (482, 24)
  Org: [l_int32 x]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Box.y">
	<summary>
 Brf: top coordinate
  Loc: SRC/pix.h (483, 24)
  Org: [l_int32 y]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Box.w">
	<summary>
 Brf: box width
  Loc: SRC/pix.h (484, 24)
  Org: [l_int32 w]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Box.h">
	<summary>
 Brf: box height
  Loc: SRC/pix.h (485, 24)
  Org: [l_int32 h]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Box.refcount">
	<summary>
 Brf: reference count (1 if no clones)
  Loc: SRC/pix.h (486, 24)
  Org: [l_uint32 refcount]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.Boxa.n">
	<summary>
 Brf: number of box in ptr array
  Loc: SRC/pix.h (494, 24)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Boxa.nalloc">
	<summary>
 Brf: number of box ptrs allocated
  Loc: SRC/pix.h (495, 24)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Boxa.refcount">
	<summary>
 Brf: reference count (1 if no clones)
  Loc: SRC/pix.h (496, 24)
  Org: [l_uint32 refcount]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.Boxa.box">
	<summary>
 Brf: box ptr array
  Loc: SRC/pix.h (497, 24)
  Org: [struct Box ** box]
  Msh: struct Box ** | 3:StructDeclaration |  ... Marshal List of Class to PTR Typedef: Box = Box
 </summary>
</member><member name="P:LeptonicaSharp.Boxaa.n">
	<summary>
 Brf: number of boxa in ptr array
  Loc: SRC/pix.h (504, 24)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Boxaa.nalloc">
	<summary>
 Brf: number of boxa ptrs allocated
  Loc: SRC/pix.h (505, 24)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Boxaa.boxa">
	<summary>
 Brf: boxa ptr array
  Loc: SRC/pix.h (506, 24)
  Org: [struct Boxa ** boxa]
  Msh: struct Boxa ** | 3:StructDeclaration |  ... Marshal List of Class to PTR Typedef: Boxa = Boxa
 </summary>
</member><member name="P:LeptonicaSharp.Pta.n">
	<summary>
 Brf: actual number of pts
  Loc: SRC/pix.h (519, 24)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Pta.nalloc">
	<summary>
 Brf: size of allocated arrays
  Loc: SRC/pix.h (520, 24)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Pta.refcount">
	<summary>
 Brf: reference count (1 if no clones)
  Loc: SRC/pix.h (521, 24)
  Org: [l_uint32 refcount]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.Pta.x">
	<summary>
 Brf: arrays of floats
  Loc: SRC/pix.h (522, 24)
  Org: [l_float32 * x]
  Msh: l_float32 * | 2:Float |  ... = Single
 </summary>
</member><member name="P:LeptonicaSharp.Pta.y">
	<summary>
 Brf: arrays of floats
  Loc: SRC/pix.h (522, 28)
  Org: [l_float32 * y]
  Msh: l_float32 * | 2:Float |  ... = Single
 </summary>
</member><member name="P:LeptonicaSharp.Ptaa.n">
	<summary>
 Brf: number of pta in ptr array
  Loc: SRC/pix.h (534, 26)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Ptaa.nalloc">
	<summary>
 Brf: number of pta ptrs allocated
  Loc: SRC/pix.h (535, 26)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Ptaa.pta">
	<summary>
 Brf: pta ptr array
  Loc: SRC/pix.h (536, 26)
  Org: [struct Pta ** pta]
  Msh: struct Pta ** | 3:StructDeclaration |  ... Marshal List of Class to PTR Typedef: Pta = Pta
 </summary>
</member><member name="P:LeptonicaSharp.Pixacc.w">
	<summary>
 Brf: array width
  Loc: SRC/pix.h (548, 25)
  Org: [l_int32 w]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Pixacc.h">
	<summary>
 Brf: array height
  Loc: SRC/pix.h (549, 25)
  Org: [l_int32 h]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Pixacc.offset">
	<summary>
 Brf: used to allow negative
  Loc: SRC/pix.h (550, 25)
  Org: [l_int32 offset]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.Pixacc.pix">
	<summary>
 Brf: the 32 bit accumulator pix
  Loc: SRC/pix.h (552, 25)
  Org: [struct Pix * pix]
  Msh: struct Pix * | 2:Struct |  Typedef: Pix = Pix
 </summary>
</member><member name="P:LeptonicaSharp.PixTiling.pix">
	<summary>
 Brf: input pix (a clone)
  Loc: SRC/pix.h (564, 26)
  Org: [struct Pix * pix]
  Msh: struct Pix * | 2:Struct |  Typedef: Pix = Pix
 </summary>
</member><member name="P:LeptonicaSharp.PixTiling.nx">
	<summary>
 Brf: number of tiles horizontally
  Loc: SRC/pix.h (565, 26)
  Org: [l_int32 nx]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixTiling.ny">
	<summary>
 Brf: number of tiles vertically
  Loc: SRC/pix.h (566, 26)
  Org: [l_int32 ny]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixTiling.w">
	<summary>
 Brf: tile width
  Loc: SRC/pix.h (567, 26)
  Org: [l_int32 w]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixTiling.h">
	<summary>
 Brf: tile height
  Loc: SRC/pix.h (568, 26)
  Org: [l_int32 h]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixTiling.xoverlap">
	<summary>
 Brf: overlap on left and right
  Loc: SRC/pix.h (569, 26)
  Org: [l_int32 xoverlap]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixTiling.yoverlap">
	<summary>
 Brf: overlap on top and bottom
  Loc: SRC/pix.h (570, 26)
  Org: [l_int32 yoverlap]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixTiling.strip">
	<summary>
 Brf: strip for paint; default is TRUE
  Loc: SRC/pix.h (571, 26)
  Org: [l_int32 strip]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.FPix.w">
	<summary>
 Brf: width in pixels
  Loc: SRC/pix.h (584, 26)
  Org: [l_int32 w]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.FPix.h">
	<summary>
 Brf: height in pixels
  Loc: SRC/pix.h (585, 26)
  Org: [l_int32 h]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.FPix.wpl">
	<summary>
 Brf: 32-bit words/line
  Loc: SRC/pix.h (586, 26)
  Org: [l_int32 wpl]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.FPix.refcount">
	<summary>
 Brf: reference count (1 if no clones)
  Loc: SRC/pix.h (587, 26)
  Org: [l_uint32 refcount]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.FPix.xres">
	<summary>
 Brf: image res (ppi) in x direction
  Loc: SRC/pix.h (588, 26)
  Org: [l_int32 xres]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.FPix.yres">
	<summary>
 Brf: image res (ppi) in y direction
  Loc: SRC/pix.h (590, 26)
  Org: [l_int32 yres]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.FPix.data">
	<summary>
 Brf: the float image data
  Loc: SRC/pix.h (592, 26)
  Org: [l_float32 * data]
  Msh: l_float32 * | 2:Float |  ... = Single
 </summary>
</member><member name="P:LeptonicaSharp.FPixa.n">
	<summary>
 Brf: number of fpix in ptr array
  Loc: SRC/pix.h (599, 25)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.FPixa.nalloc">
	<summary>
 Brf: number of fpix ptrs allocated
  Loc: SRC/pix.h (600, 25)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.FPixa.refcount">
	<summary>
 Brf: reference count (1 if no clones)
  Loc: SRC/pix.h (601, 25)
  Org: [l_uint32 refcount]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.FPixa.fpix">
	<summary>
 Brf: the array of ptrs to fpix
  Loc: SRC/pix.h (602, 25)
  Org: [struct FPix ** fpix]
  Msh: struct FPix ** | 3:StructDeclaration |  ... Marshal List of Class to PTR Typedef: FPix = FPix
 </summary>
</member><member name="P:LeptonicaSharp.DPix.w">
	<summary>
 Brf: width in pixels
  Loc: SRC/pix.h (615, 26)
  Org: [l_int32 w]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.DPix.h">
	<summary>
 Brf: height in pixels
  Loc: SRC/pix.h (616, 26)
  Org: [l_int32 h]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.DPix.wpl">
	<summary>
 Brf: 32-bit words/line
  Loc: SRC/pix.h (617, 26)
  Org: [l_int32 wpl]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.DPix.refcount">
	<summary>
 Brf: reference count (1 if no clones)
  Loc: SRC/pix.h (618, 26)
  Org: [l_uint32 refcount]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.DPix.xres">
	<summary>
 Brf: image res (ppi) in x direction
  Loc: SRC/pix.h (619, 26)
  Org: [l_int32 xres]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.DPix.yres">
	<summary>
 Brf: image res (ppi) in y direction
  Loc: SRC/pix.h (621, 26)
  Org: [l_int32 yres]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.DPix.data">
	<summary>
 Brf: the double image data
  Loc: SRC/pix.h (623, 26)
  Org: [l_float64 * data]
  Msh: l_float64 * | 2:Double |
 </summary>
</member><member name="P:LeptonicaSharp.PixComp.w">
	<summary>
 Brf: width in pixels
  Loc: SRC/pix.h (635, 26)
  Org: [l_int32 w]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixComp.h">
	<summary>
 Brf: height in pixels
  Loc: SRC/pix.h (636, 26)
  Org: [l_int32 h]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixComp.d">
	<summary>
 Brf: depth in bits
  Loc: SRC/pix.h (637, 26)
  Org: [l_int32 d]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixComp.xres">
	<summary>
 Brf: image res (ppi) in x direction
  Loc: SRC/pix.h (638, 26)
  Org: [l_int32 xres]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixComp.yres">
	<summary>
 Brf: image res (ppi) in y direction
  Loc: SRC/pix.h (640, 26)
  Org: [l_int32 yres]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixComp.comptype">
	<summary>
 Brf: compressed format (IFF_TIFF_G4,
  Loc: SRC/pix.h (642, 26)
  Org: [l_int32 comptype]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixComp.text">
	<summary>
 Brf: text string associated with pix
  Loc: SRC/pix.h (644, 26)
  Org: [char * text]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.PixComp.cmapflag">
	<summary>
 Brf: flag (1 for cmap, 0 otherwise)
  Loc: SRC/pix.h (645, 26)
  Org: [l_int32 cmapflag]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixComp.data">
	<summary>
 Brf: the compressed image data
  Loc: SRC/pix.h (646, 26)
  Org: [l_uint8 * data]
  Msh: l_uint8 * | 2:UChar | ([1 Byte, VB-Unsupported])
 </summary>
</member><member name="P:LeptonicaSharp.PixComp.size">
	<summary>
 Brf: size of the data array
  Loc: SRC/pix.h (647, 26)
  Org: [size_t size]
  Msh: size_t | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.PixaComp.n">
	<summary>
 Brf: number of PixComp in ptr array
  Loc: SRC/pix.h (660, 26)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixaComp.nalloc">
	<summary>
 Brf: number of PixComp ptrs allocated
  Loc: SRC/pix.h (661, 26)
  Org: [l_int32 nalloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixaComp.offset">
	<summary>
 Brf: indexing offset into ptr array
  Loc: SRC/pix.h (662, 26)
  Org: [l_int32 offset]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixaComp.pixc">
	<summary>
 Brf: the array of ptrs to PixComp
  Loc: SRC/pix.h (663, 26)
  Org: [struct PixComp ** pixc]
  Msh: struct PixComp ** | 3:StructDeclaration |  ... Marshal List of Class to PTR
 </summary>
</member><member name="P:LeptonicaSharp.PixaComp.boxa">
	<summary>
 Brf: array of boxes
  Loc: SRC/pix.h (664, 26)
  Org: [struct Boxa * boxa]
  Msh: struct Boxa * | 2:Struct |  Typedef: Boxa = Boxa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.scalew">
	<summary>
 Brf: scale all examples to this width;
  Loc: SRC/recog.h (117, 20)
  Org: [l_int32 scalew]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.scaleh">
	<summary>
 Brf: scale all examples to this height;
  Loc: SRC/recog.h (119, 20)
  Org: [l_int32 scaleh]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.linew">
	<summary>
 Brf: use a value  bigger  0 to convert the bitmap
  Loc: SRC/recog.h (121, 20)
  Org: [l_int32 linew]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.templ_use">
	<summary>
 Brf: template use: use either the average
  Loc: SRC/recog.h (123, 20)
  Org: [l_int32 templ_use]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.maxarraysize">
	<summary>
 Brf: initialize container arrays to this
  Loc: SRC/recog.h (126, 20)
  Org: [l_int32 maxarraysize]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.setsize">
	<summary>
 Brf: size of character set
  Loc: SRC/recog.h (127, 20)
  Org: [l_int32 setsize]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.threshold">
	<summary>
 Brf: for binarizing if depth  bigger  1
  Loc: SRC/recog.h (128, 20)
  Org: [l_int32 threshold]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.maxyshift">
	<summary>
 Brf: vertical jiggle on nominal centroid
  Loc: SRC/recog.h (129, 20)
  Org: [l_int32 maxyshift]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.charset_type">
	<summary>
 Brf: one of L_ARABIC_NUMERALS, etc.
  Loc: SRC/recog.h (131, 20)
  Org: [l_int32 charset_type]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.charset_size">
	<summary>
 Brf: expected number of classes in charset
  Loc: SRC/recog.h (132, 20)
  Org: [l_int32 charset_size]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.min_nopad">
	<summary>
 Brf: min number of samples without padding
  Loc: SRC/recog.h (133, 20)
  Org: [l_int32 min_nopad]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.num_samples">
	<summary>
 Brf: number of training samples
  Loc: SRC/recog.h (134, 20)
  Org: [l_int32 num_samples]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.minwidth_u">
	<summary>
 Brf: min width averaged unscaled templates
  Loc: SRC/recog.h (135, 20)
  Org: [l_int32 minwidth_u]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.maxwidth_u">
	<summary>
 Brf: max width averaged unscaled templates
  Loc: SRC/recog.h (136, 20)
  Org: [l_int32 maxwidth_u]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.minheight_u">
	<summary>
 Brf: min height averaged unscaled templates
  Loc: SRC/recog.h (137, 20)
  Org: [l_int32 minheight_u]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.maxheight_u">
	<summary>
 Brf: max height averaged unscaled templates
  Loc: SRC/recog.h (138, 20)
  Org: [l_int32 maxheight_u]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.minwidth">
	<summary>
 Brf: min width averaged scaled templates
  Loc: SRC/recog.h (139, 20)
  Org: [l_int32 minwidth]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.maxwidth">
	<summary>
 Brf: max width averaged scaled templates
  Loc: SRC/recog.h (140, 20)
  Org: [l_int32 maxwidth]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.ave_done">
	<summary>
 Brf: set to 1 when averaged bitmaps are made
  Loc: SRC/recog.h (141, 20)
  Org: [l_int32 ave_done]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.train_done">
	<summary>
 Brf: set to 1 when training is complete or
  Loc: SRC/recog.h (142, 20)
  Org: [l_int32 train_done]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.max_wh_ratio">
	<summary>
 Brf: max width/height ratio to split
  Loc: SRC/recog.h (144, 20)
  Org: [l_float32 max_wh_ratio]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.max_ht_ratio">
	<summary>
 Brf: max of max/min template height ratio
  Loc: SRC/recog.h (145, 20)
  Org: [l_float32 max_ht_ratio]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.min_splitw">
	<summary>
 Brf: min component width kept in splitting
  Loc: SRC/recog.h (146, 20)
  Org: [l_int32 min_splitw]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.max_splith">
	<summary>
 Brf: max component height kept in splitting
  Loc: SRC/recog.h (147, 20)
  Org: [l_int32 max_splith]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.sa_text">
	<summary>
 Brf: text array for arbitrary char set
  Loc: SRC/recog.h (148, 20)
  Org: [struct Sarray * sa_text]
  Msh: struct Sarray * | 2:Struct |  Typedef: Sarray = Sarray
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.dna_tochar">
	<summary>
 Brf: index-to-char lut for arbitrary charset
  Loc: SRC/recog.h (149, 20)
  Org: [struct L_Dna * dna_tochar]
  Msh: struct L_Dna * | 2:Struct |  Typedef: L_Dna = L_Dna
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.centtab">
	<summary>
 Brf: table for finding centroids
  Loc: SRC/recog.h (150, 20)
  Org: [l_int32 * centtab]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.sumtab">
	<summary>
 Brf: table for finding pixel sums
  Loc: SRC/recog.h (151, 20)
  Org: [l_int32 * sumtab]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.pixaa_u">
	<summary>
 Brf: all unscaled templates for each class
  Loc: SRC/recog.h (152, 20)
  Org: [struct Pixaa * pixaa_u]
  Msh: struct Pixaa * | 2:Struct |  Typedef: Pixaa = Pixaa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.ptaa_u">
	<summary>
 Brf: centroids of all unscaled templates
  Loc: SRC/recog.h (153, 20)
  Org: [struct Ptaa * ptaa_u]
  Msh: struct Ptaa * | 2:Struct |  Typedef: Ptaa = Ptaa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.naasum_u">
	<summary>
 Brf: area of all unscaled templates
  Loc: SRC/recog.h (154, 20)
  Org: [struct Numaa * naasum_u]
  Msh: struct Numaa * | 2:Struct |  Typedef: Numaa = Numaa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.pixaa">
	<summary>
 Brf: all (scaled) templates for each class
  Loc: SRC/recog.h (155, 20)
  Org: [struct Pixaa * pixaa]
  Msh: struct Pixaa * | 2:Struct |  Typedef: Pixaa = Pixaa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.ptaa">
	<summary>
 Brf: centroids of all (scaledl) templates
  Loc: SRC/recog.h (156, 20)
  Org: [struct Ptaa * ptaa]
  Msh: struct Ptaa * | 2:Struct |  Typedef: Ptaa = Ptaa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.naasum">
	<summary>
 Brf: area of all (scaled) templates
  Loc: SRC/recog.h (157, 20)
  Org: [struct Numaa * naasum]
  Msh: struct Numaa * | 2:Struct |  Typedef: Numaa = Numaa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.pixa_u">
	<summary>
 Brf: averaged unscaled templates per class
  Loc: SRC/recog.h (158, 20)
  Org: [struct Pixa * pixa_u]
  Msh: struct Pixa * | 2:Struct |  Typedef: Pixa = Pixa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.pta_u">
	<summary>
 Brf: centroids of unscaled ave. templates
  Loc: SRC/recog.h (159, 20)
  Org: [struct Pta * pta_u]
  Msh: struct Pta * | 2:Struct |  Typedef: Pta = Pta
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.nasum_u">
	<summary>
 Brf: area of unscaled averaged templates
  Loc: SRC/recog.h (160, 20)
  Org: [struct Numa * nasum_u]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.pixa">
	<summary>
 Brf: averaged (scaled) templates per class
  Loc: SRC/recog.h (161, 20)
  Org: [struct Pixa * pixa]
  Msh: struct Pixa * | 2:Struct |  Typedef: Pixa = Pixa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.pta">
	<summary>
 Brf: centroids of (scaled) ave. templates
  Loc: SRC/recog.h (162, 20)
  Org: [struct Pta * pta]
  Msh: struct Pta * | 2:Struct |  Typedef: Pta = Pta
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.nasum">
	<summary>
 Brf: area of (scaled) averaged templates
  Loc: SRC/recog.h (163, 20)
  Org: [struct Numa * nasum]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.pixa_tr">
	<summary>
 Brf: all input training images
  Loc: SRC/recog.h (164, 20)
  Org: [struct Pixa * pixa_tr]
  Msh: struct Pixa * | 2:Struct |  Typedef: Pixa = Pixa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.pixadb_ave">
	<summary>
 Brf: unscaled and scaled averaged bitmaps
  Loc: SRC/recog.h (165, 20)
  Org: [struct Pixa * pixadb_ave]
  Msh: struct Pixa * | 2:Struct |  Typedef: Pixa = Pixa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.pixa_id">
	<summary>
 Brf: input images for identifying
  Loc: SRC/recog.h (166, 20)
  Org: [struct Pixa * pixa_id]
  Msh: struct Pixa * | 2:Struct |  Typedef: Pixa = Pixa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.pixdb_ave">
	<summary>
 Brf: debug: best match of input against ave.
  Loc: SRC/recog.h (167, 20)
  Org: [struct Pix * pixdb_ave]
  Msh: struct Pix * | 2:Struct |  Typedef: Pix = Pix
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.pixdb_range">
	<summary>
 Brf: debug: best matches within range
  Loc: SRC/recog.h (168, 20)
  Org: [struct Pix * pixdb_range]
  Msh: struct Pix * | 2:Struct |  Typedef: Pix = Pix
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.pixadb_boot">
	<summary>
 Brf: debug: bootstrap training results
  Loc: SRC/recog.h (169, 20)
  Org: [struct Pixa * pixadb_boot]
  Msh: struct Pixa * | 2:Struct |  Typedef: Pixa = Pixa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.pixadb_split">
	<summary>
 Brf: debug: splitting results
  Loc: SRC/recog.h (170, 20)
  Org: [struct Pixa * pixadb_split]
  Msh: struct Pixa * | 2:Struct |  Typedef: Pixa = Pixa
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.bmf">
	<summary>
 Brf: bmf fonts
  Loc: SRC/recog.h (171, 20)
  Org: [struct L_Bmf * bmf]
  Msh: struct L_Bmf * | 2:Struct |  Typedef: L_Bmf = L_Bmf
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.bmf_size">
	<summary>
 Brf: font size of bmf; default is 6 pt
  Loc: SRC/recog.h (172, 20)
  Org: [l_int32 bmf_size]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.did">
	<summary>
 Brf: temp data used for image decoding
  Loc: SRC/recog.h (173, 20)
  Org: [struct L_Rdid * did]
  Msh: struct L_Rdid * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.rch">
	<summary>
 Brf: temp data used for holding best char
  Loc: SRC/recog.h (174, 20)
  Org: [struct L_Rch * rch]
  Msh: struct L_Rch * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Recog.rcha">
	<summary>
 Brf: temp data used for array of best chars
  Loc: SRC/recog.h (175, 20)
  Org: [struct L_Rcha * rcha]
  Msh: struct L_Rcha * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rch.index">
	<summary>
 Brf: index of best template
  Loc: SRC/recog.h (183, 20)
  Org: [l_int32 index]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rch.score">
	<summary>
 Brf: correlation score of best template
  Loc: SRC/recog.h (184, 20)
  Org: [l_float32 score]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rch.text">
	<summary>
 Brf: character string of best template
  Loc: SRC/recog.h (185, 20)
  Org: [char * text]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rch.sample">
	<summary>
 Brf: index of best sample (within the best
  Loc: SRC/recog.h (186, 20)
  Org: [l_int32 sample]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rch.xloc">
	<summary>
 Brf: x-location of template (delx + shiftx)
  Loc: SRC/recog.h (188, 20)
  Org: [l_int32 xloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rch.yloc">
	<summary>
 Brf: y-location of template (dely + shifty)
  Loc: SRC/recog.h (189, 20)
  Org: [l_int32 yloc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rch.width">
	<summary>
 Brf: width of best template
  Loc: SRC/recog.h (190, 20)
  Org: [l_int32 width]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rcha.naindex">
	<summary>
 Brf: indices of best templates
  Loc: SRC/recog.h (198, 20)
  Org: [struct Numa * naindex]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rcha.nascore">
	<summary>
 Brf: correlation scores of best templates
  Loc: SRC/recog.h (199, 20)
  Org: [struct Numa * nascore]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rcha.satext">
	<summary>
 Brf: character strings of best templates
  Loc: SRC/recog.h (200, 20)
  Org: [struct Sarray * satext]
  Msh: struct Sarray * | 2:Struct |  Typedef: Sarray = Sarray
 </summary>
</member><member name="P:LeptonicaSharp.L_Rcha.nasample">
	<summary>
 Brf: indices of best samples
  Loc: SRC/recog.h (201, 20)
  Org: [struct Numa * nasample]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rcha.naxloc">
	<summary>
 Brf: x-locations of templates (delx + shiftx)
  Loc: SRC/recog.h (202, 20)
  Org: [struct Numa * naxloc]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rcha.nayloc">
	<summary>
 Brf: y-locations of templates (dely + shifty)
  Loc: SRC/recog.h (203, 20)
  Org: [struct Numa * nayloc]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rcha.nawidth">
	<summary>
 Brf: widths of best templates
  Loc: SRC/recog.h (204, 20)
  Org: [struct Numa * nawidth]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.pixs">
	<summary>
 Brf: clone of pix to be decoded
  Loc: SRC/recog.h (212, 20)
  Org: [struct Pix * pixs]
  Msh: struct Pix * | 2:Struct |  Typedef: Pix = Pix
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.counta">
	<summary>
 Brf: count array for each averaged template
  Loc: SRC/recog.h (213, 20)
  Org: [l_int32 ** counta]
  Msh: l_int32 ** | 3:Integer | List (of Integer())
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.delya">
	<summary>
 Brf: best y-shift array per average template
  Loc: SRC/recog.h (214, 20)
  Org: [l_int32 ** delya]
  Msh: l_int32 ** | 3:Integer | List (of Integer())
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.narray">
	<summary>
 Brf: number of averaged templates
  Loc: SRC/recog.h (215, 20)
  Org: [l_int32 narray]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.size">
	<summary>
 Brf: size of count array (width of pixs)
  Loc: SRC/recog.h (216, 20)
  Org: [l_int32 size]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.setwidth">
	<summary>
 Brf: setwidths for each template
  Loc: SRC/recog.h (217, 20)
  Org: [l_int32 * setwidth]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.nasum">
	<summary>
 Brf: pixel count in pixs by column
  Loc: SRC/recog.h (218, 20)
  Org: [struct Numa * nasum]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.namoment">
	<summary>
 Brf: first moment of pixels in pixs by cols
  Loc: SRC/recog.h (219, 20)
  Org: [struct Numa * namoment]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.fullarrays">
	<summary>
 Brf: 1 if full arrays are made; 0 otherwise
  Loc: SRC/recog.h (220, 20)
  Org: [l_int32 fullarrays]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.beta">
	<summary>
 Brf: channel coeffs for template fg term
  Loc: SRC/recog.h (221, 20)
  Org: [l_float32 * beta]
  Msh: l_float32 * | 2:Float |  ... = Single
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.gamma">
	<summary>
 Brf: channel coeffs for bit-and term
  Loc: SRC/recog.h (222, 20)
  Org: [l_float32 * gamma]
  Msh: l_float32 * | 2:Float |  ... = Single
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.trellisscore">
	<summary>
 Brf: score on trellis
  Loc: SRC/recog.h (223, 20)
  Org: [l_float32 * trellisscore]
  Msh: l_float32 * | 2:Float |  ... = Single
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.trellistempl">
	<summary>
 Brf: template on trellis (for backtrack)
  Loc: SRC/recog.h (224, 20)
  Org: [l_int32 * trellistempl]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.natempl">
	<summary>
 Brf: indices of best path templates
  Loc: SRC/recog.h (225, 20)
  Org: [struct Numa * natempl]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.naxloc">
	<summary>
 Brf: x locations of best path templates
  Loc: SRC/recog.h (226, 20)
  Org: [struct Numa * naxloc]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.nadely">
	<summary>
 Brf: y locations of best path templates
  Loc: SRC/recog.h (227, 20)
  Org: [struct Numa * nadely]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.nawidth">
	<summary>
 Brf: widths of best path templates
  Loc: SRC/recog.h (228, 20)
  Org: [struct Numa * nawidth]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.boxa">
	<summary>
 Brf: Viterbi result for splitting input pixs
  Loc: SRC/recog.h (229, 20)
  Org: [struct Boxa * boxa]
  Msh: struct Boxa * | 2:Struct |  Typedef: Boxa = Boxa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.nascore">
	<summary>
 Brf: correlation scores: best path templates
  Loc: SRC/recog.h (230, 20)
  Org: [struct Numa * nascore]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.natempl_r">
	<summary>
 Brf: indices of best rescored templates
  Loc: SRC/recog.h (231, 20)
  Org: [struct Numa * natempl_r]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.nasample_r">
	<summary>
 Brf: samples of best scored templates
  Loc: SRC/recog.h (232, 20)
  Org: [struct Numa * nasample_r]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.naxloc_r">
	<summary>
 Brf: x locations of best rescoredtemplates
  Loc: SRC/recog.h (233, 20)
  Org: [struct Numa * naxloc_r]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.nadely_r">
	<summary>
 Brf: y locations of best rescoredtemplates
  Loc: SRC/recog.h (234, 20)
  Org: [struct Numa * nadely_r]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.nawidth_r">
	<summary>
 Brf: widths of best rescoredtemplates
  Loc: SRC/recog.h (235, 20)
  Org: [struct Numa * nawidth_r]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_Rdid.nascore_r">
	<summary>
 Brf: correlation scores: rescored templates
  Loc: SRC/recog.h (236, 20)
  Org: [struct Numa * nascore_r]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_RegParams.fp">
	<summary>
 Brf: stream to temporary output file for compare mode
  Loc: SRC/regutils.h (119, 14)
  Org: [FILE * fp]
  Msh: FILE * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_RegParams.testname">
	<summary>
 Brf: name of test, without '_reg'
  Loc: SRC/regutils.h (120, 14)
  Org: [char * testname]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_RegParams.tempfile">
	<summary>
 Brf: name of temp file for compare mode output
  Loc: SRC/regutils.h (121, 14)
  Org: [char * tempfile]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.L_RegParams.mode">
	<summary>
 Brf: generate, compare or display
  Loc: SRC/regutils.h (122, 14)
  Org: [l_int32 mode]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_RegParams.index">
	<summary>
 Brf: index into saved files for this test; 0-based
  Loc: SRC/regutils.h (123, 14)
  Org: [l_int32 index]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_RegParams.success">
	<summary>
 Brf: overall result of the test
  Loc: SRC/regutils.h (124, 14)
  Org: [l_int32 success]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_RegParams.display">
	<summary>
 Brf: 1 if in display mode; 0 otherwise
  Loc: SRC/regutils.h (125, 14)
  Org: [l_int32 display]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_RegParams.tstart">
	<summary>
 Brf: marks beginning of the reg test
  Loc: SRC/regutils.h (126, 14)
  Org: [L_TIMER tstart]
  Msh: L_TIMER | 1:Pointer |
 </summary>
</member><member name="P:LeptonicaSharp.L_StrCode.fileno">
	<summary>
 Brf: index for function and output file names
  Loc: SRC/stringcode.h (42, 19)
  Org: [l_int32 fileno]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_StrCode.ifunc">
	<summary>
 Brf: index into struct currently being stored
  Loc: SRC/stringcode.h (43, 19)
  Org: [l_int32 ifunc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_StrCode._function_">
	<summary>
 Brf: store case code for extraction
  Loc: SRC/stringcode.h (44, 19)
  Org: [SARRAY * function]
  Msh: SARRAY * | 2:Struct |  Typedef: Sarray = Sarray
 </summary>
</member><member name="P:LeptonicaSharp.L_StrCode.data">
	<summary>
 Brf: store base64 encoded data as strings
  Loc: SRC/stringcode.h (45, 19)
  Org: [SARRAY * data]
  Msh: SARRAY * | 2:Struct |  Typedef: Sarray = Sarray
 </summary>
</member><member name="P:LeptonicaSharp.L_StrCode.descr">
	<summary>
 Brf: store line in description table
  Loc: SRC/stringcode.h (46, 19)
  Org: [SARRAY * descr]
  Msh: SARRAY * | 2:Struct |  Typedef: Sarray = Sarray
 </summary>
</member><member name="P:LeptonicaSharp.L_StrCode.n">
	<summary>
 Brf: number of data strings
  Loc: SRC/stringcode.h (47, 19)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Sudoku.num">
	<summary>
 Brf: number of unknowns
  Loc: SRC/sudoku.h (54, 20)
  Org: [l_int32 num]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Sudoku.locs">
	<summary>
 Brf: location of unknowns
  Loc: SRC/sudoku.h (55, 20)
  Org: [l_int32 * locs]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.L_Sudoku.current">
	<summary>
 Brf: index into %locs of current location
  Loc: SRC/sudoku.h (56, 20)
  Org: [l_int32 current]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Sudoku.init">
	<summary>
 Brf: initial state, with 0 representing
  Loc: SRC/sudoku.h (57, 20)
  Org: [l_int32 * init]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.L_Sudoku.state">
	<summary>
 Brf: present state, including inits and
  Loc: SRC/sudoku.h (59, 20)
  Org: [l_int32 * state]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.L_Sudoku.nguess">
	<summary>
 Brf: shows current number of guesses
  Loc: SRC/sudoku.h (61, 20)
  Org: [l_int32 nguess]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Sudoku.finished">
	<summary>
 Brf: set to 1 when solved
  Loc: SRC/sudoku.h (62, 20)
  Org: [l_int32 finished]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Sudoku.failure">
	<summary>
 Brf: set to 1 if no solution is possible
  Loc: SRC/sudoku.h (63, 20)
  Org: [l_int32 failure]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.pixs">
	<summary>
 Brf: clone of input 8 bpp pixs
  Loc: SRC/watershed.h (40, 20)
  Org: [struct Pix * pixs]
  Msh: struct Pix * | 2:Struct |  Typedef: Pix = Pix
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.pixm">
	<summary>
 Brf: clone of input 1 bpp seed (marker) pixm
  Loc: SRC/watershed.h (41, 20)
  Org: [struct Pix * pixm]
  Msh: struct Pix * | 2:Struct |  Typedef: Pix = Pix
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.mindepth">
	<summary>
 Brf: minimum depth allowed for a watershed
  Loc: SRC/watershed.h (42, 20)
  Org: [l_int32 mindepth]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.pixlab">
	<summary>
 Brf: 16 bpp label pix
  Loc: SRC/watershed.h (43, 20)
  Org: [struct Pix * pixlab]
  Msh: struct Pix * | 2:Struct |  Typedef: Pix = Pix
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.pixt">
	<summary>
 Brf: scratch pix for computing wshed regions
  Loc: SRC/watershed.h (44, 20)
  Org: [struct Pix * pixt]
  Msh: struct Pix * | 2:Struct |  Typedef: Pix = Pix
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.lines8">
	<summary>
 Brf: line ptrs for pixs
  Loc: SRC/watershed.h (45, 20)
  Org: [void ** lines8]
  Msh: void ** | 3:Void | IntPtr()
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.linem1">
	<summary>
 Brf: line ptrs for pixm
  Loc: SRC/watershed.h (46, 20)
  Org: [void ** linem1]
  Msh: void ** | 3:Void | IntPtr()
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.linelab32">
	<summary>
 Brf: line ptrs for pixlab
  Loc: SRC/watershed.h (47, 20)
  Org: [void ** linelab32]
  Msh: void ** | 3:Void | IntPtr()
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.linet1">
	<summary>
 Brf: line ptrs for pixt
  Loc: SRC/watershed.h (48, 20)
  Org: [void ** linet1]
  Msh: void ** | 3:Void | IntPtr()
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.pixad">
	<summary>
 Brf: result: 1 bpp pixa of watersheds
  Loc: SRC/watershed.h (49, 20)
  Org: [struct Pixa * pixad]
  Msh: struct Pixa * | 2:Struct |  Typedef: Pixa = Pixa
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.ptas">
	<summary>
 Brf: pta of initial seed pixels
  Loc: SRC/watershed.h (50, 20)
  Org: [struct Pta * ptas]
  Msh: struct Pta * | 2:Struct |  Typedef: Pta = Pta
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.nasi">
	<summary>
 Brf: numa of seed indicators; 0 if completed
  Loc: SRC/watershed.h (51, 20)
  Org: [struct Numa * nasi]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.nash">
	<summary>
 Brf: numa of initial seed heights
  Loc: SRC/watershed.h (52, 20)
  Org: [struct Numa * nash]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.namh">
	<summary>
 Brf: numa of initial minima heights
  Loc: SRC/watershed.h (53, 20)
  Org: [struct Numa * namh]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.nalevels">
	<summary>
 Brf: result: numa of watershed levels
  Loc: SRC/watershed.h (54, 20)
  Org: [struct Numa * nalevels]
  Msh: struct Numa * | 2:Struct |  Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.nseeds">
	<summary>
 Brf: number of seeds (markers)
  Loc: SRC/watershed.h (55, 20)
  Org: [l_int32 nseeds]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.nother">
	<summary>
 Brf: number of minima different from seeds
  Loc: SRC/watershed.h (56, 20)
  Org: [l_int32 nother]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.lut">
	<summary>
 Brf: lut for pixel indices
  Loc: SRC/watershed.h (57, 20)
  Org: [l_int32 * lut]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.links">
	<summary>
 Brf: back-links into lut, for updates
  Loc: SRC/watershed.h (58, 20)
  Org: [struct Numa ** links]
  Msh: struct Numa ** | 3:StructDeclaration |  ... Marshal List of Class to PTR Typedef: Numa = Numa
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.arraysize">
	<summary>
 Brf: size of links array
  Loc: SRC/watershed.h (59, 20)
  Org: [l_int32 arraysize]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_WShed.debug">
	<summary>
 Brf: set to 1 for debug output
  Loc: SRC/watershed.h (60, 20)
  Org: [l_int32 debug]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.pixs">
	<summary>
 Brf: clone of source pix
  Loc: SRC/bilateral.h (117, 21)
  Org: [struct Pix * pixs]
  Msh: struct Pix * | 2:Struct |  Typedef: Pix = Pix
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.pixsc">
	<summary>
 Brf: downscaled pix with mirrored border
  Loc: SRC/bilateral.h (118, 21)
  Org: [struct Pix * pixsc]
  Msh: struct Pix * | 2:Struct |  Typedef: Pix = Pix
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.reduction">
	<summary>
 Brf: 1, 2 or 4x for intermediates
  Loc: SRC/bilateral.h (119, 21)
  Org: [l_int32 reduction]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.spatial_stdev">
	<summary>
 Brf: stdev of spatial gaussian
  Loc: SRC/bilateral.h (120, 21)
  Org: [l_float32 spatial_stdev]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.range_stdev">
	<summary>
 Brf: stdev of range gaussian
  Loc: SRC/bilateral.h (121, 21)
  Org: [l_float32 range_stdev]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.spatial">
	<summary>
 Brf: 1D gaussian spatial kernel
  Loc: SRC/bilateral.h (122, 21)
  Org: [l_float32 * spatial]
  Msh: l_float32 * | 2:Float |  ... = Single
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.range">
	<summary>
 Brf: one-sided gaussian range kernel
  Loc: SRC/bilateral.h (123, 21)
  Org: [l_float32 * range]
  Msh: l_float32 * | 2:Float |  ... = Single
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.minval">
	<summary>
 Brf: min value in 8 bpp pix
  Loc: SRC/bilateral.h (124, 21)
  Org: [l_int32 minval]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.maxval">
	<summary>
 Brf: max value in 8 bpp pix
  Loc: SRC/bilateral.h (125, 21)
  Org: [l_int32 maxval]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.ncomps">
	<summary>
 Brf: number of intermediate results
  Loc: SRC/bilateral.h (126, 21)
  Org: [l_int32 ncomps]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.nc">
	<summary>
 Brf: set of k values (size ncomps)
  Loc: SRC/bilateral.h (127, 21)
  Org: [l_int32 * nc]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.kindex">
	<summary>
 Brf: mapping from intensity to lower k
  Loc: SRC/bilateral.h (128, 21)
  Org: [l_int32 * kindex]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.kfract">
	<summary>
 Brf: mapping from intensity to fract k
  Loc: SRC/bilateral.h (129, 21)
  Org: [l_float32 * kfract]
  Msh: l_float32 * | 2:Float |  ... = Single
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.pixac">
	<summary>
 Brf: intermediate result images (PBC)
  Loc: SRC/bilateral.h (130, 21)
  Org: [struct Pixa * pixac]
  Msh: struct Pixa * | 2:Struct |  Typedef: Pixa = Pixa
 </summary>
</member><member name="P:LeptonicaSharp.L_Bilateral.lineset">
	<summary>
 Brf: lineptrs for pixac
  Loc: SRC/bilateral.h (131, 21)
  Org: [l_uint32 *** lineset]
  Msh: l_uint32 *** | 3:UInt | List (of List ( of List (of Byte()))) ... UInt = bigger  Byte[4]
 </summary>
</member><member name="P:LeptonicaSharp.BMP_FileHeader.bfType">
	<summary>
 Brf: file type; must be "BM"
  Loc: SRC/bmp.h (52, 20)
  Org: [l_int16 bfType]
  Msh: l_int16 | 1:Short |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_FileHeader.bfSize">
	<summary>
 Brf: length of the file; sizeof(BMP_FileHeader) + sizeof(BMP_InfoHeader) + size of color table + size of DIB bits
  Loc: SRC/bmp.h (53, 20)
  Org: [l_int16 bfSize]
  Msh: l_int16 | 1:Short |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_FileHeader.bfFill1">
	<summary>
 Brf: remainder of the bfSize field
  Loc: SRC/bmp.h (58, 20)
  Org: [l_int16 bfFill1]
  Msh: l_int16 | 1:Short |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_FileHeader.bfReserved1">
	<summary>
 Brf: don't care (set to 0)
  Loc: SRC/bmp.h (59, 20)
  Org: [l_int16 bfReserved1]
  Msh: l_int16 | 1:Short |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_FileHeader.bfReserved2">
	<summary>
 Brf: don't care (set to 0)
  Loc: SRC/bmp.h (60, 20)
  Org: [l_int16 bfReserved2]
  Msh: l_int16 | 1:Short |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_FileHeader.bfOffBits">
	<summary>
 Brf: offset from beginning of file
  Loc: SRC/bmp.h (61, 20)
  Org: [l_int16 bfOffBits]
  Msh: l_int16 | 1:Short |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_FileHeader.bfFill2">
	<summary>
 Brf: remainder of the bfOffBits field
  Loc: SRC/bmp.h (62, 20)
  Org: [l_int16 bfFill2]
  Msh: l_int16 | 1:Short |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_InfoHeader.biSize">
	<summary>
 Brf: size of the BMP_InfoHeader struct
  Loc: SRC/bmp.h (77, 20)
  Org: [l_int32 biSize]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_InfoHeader.biWidth">
	<summary>
 Brf: bitmap width in pixels
  Loc: SRC/bmp.h (78, 20)
  Org: [l_int32 biWidth]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_InfoHeader.biHeight">
	<summary>
 Brf: bitmap height in pixels
  Loc: SRC/bmp.h (79, 20)
  Org: [l_int32 biHeight]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_InfoHeader.biPlanes">
	<summary>
 Brf: number of bitmap planes
  Loc: SRC/bmp.h (80, 20)
  Org: [l_int16 biPlanes]
  Msh: l_int16 | 1:Short |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_InfoHeader.biBitCount">
	<summary>
 Brf: number of bits per pixel
  Loc: SRC/bmp.h (81, 20)
  Org: [l_int16 biBitCount]
  Msh: l_int16 | 1:Short |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_InfoHeader.biCompression">
	<summary>
 Brf: compress format (0 == uncompressed)
  Loc: SRC/bmp.h (82, 20)
  Org: [l_int32 biCompression]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_InfoHeader.biSizeImage">
	<summary>
 Brf: size of image in bytes
  Loc: SRC/bmp.h (83, 20)
  Org: [l_int32 biSizeImage]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_InfoHeader.biXPelsPerMeter">
	<summary>
 Brf: pixels per meter in x direction
  Loc: SRC/bmp.h (84, 20)
  Org: [l_int32 biXPelsPerMeter]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_InfoHeader.biYPelsPerMeter">
	<summary>
 Brf: pixels per meter in y direction
  Loc: SRC/bmp.h (85, 20)
  Org: [l_int32 biYPelsPerMeter]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_InfoHeader.biClrUsed">
	<summary>
 Brf: number of colors used
  Loc: SRC/bmp.h (86, 20)
  Org: [l_int32 biClrUsed]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.BMP_InfoHeader.biClrImportant">
	<summary>
 Brf: number of important colors used
  Loc: SRC/bmp.h (87, 20)
  Org: [l_int32 biClrImportant]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.ColorQuantCell.rc">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (160, 17)
  Org: [l_int32 rc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.ColorQuantCell.gc">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (160, 21)
  Org: [l_int32 gc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.ColorQuantCell.bc">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (160, 25)
  Org: [l_int32 bc]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.ColorQuantCell.n">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (161, 17)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.ColorQuantCell.index">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (162, 17)
  Org: [l_int32 index]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.ColorQuantCell.nleaves">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (163, 17)
  Org: [l_int32 nleaves]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.ColorQuantCell.bleaf">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (164, 17)
  Org: [l_int32 bleaf]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.OctcubeQuantCell.n">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (192, 16)
  Org: [l_float32 n]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.OctcubeQuantCell.octindex">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (193, 16)
  Org: [l_int32 octindex]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.OctcubeQuantCell.rcum">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (194, 16)
  Org: [l_int32 rcum]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.OctcubeQuantCell.gcum">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (194, 22)
  Org: [l_int32 gcum]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.OctcubeQuantCell.bcum">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (194, 28)
  Org: [l_int32 bcum]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.OctcubeQuantCell.rval">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (195, 16)
  Org: [l_int32 rval]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.OctcubeQuantCell.gval">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (195, 22)
  Org: [l_int32 gval]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.OctcubeQuantCell.bval">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (195, 28)
  Org: [l_int32 bval]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_OctcubePop.npix">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (208, 22)
  Org: [l_float32 npix]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.L_OctcubePop.index">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (209, 22)
  Org: [l_int32 index]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_OctcubePop.rval">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (210, 22)
  Org: [l_int32 rval]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_OctcubePop.gval">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (211, 22)
  Org: [l_int32 gval]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_OctcubePop.bval">
	<summary>
 Brf: 
  Loc: SRC\colorquant1.c (212, 22)
  Org: [l_int32 bval]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Box3d.sortparam">
	<summary>
 Brf: 
  Loc: SRC\colorquant2.c (180, 22)
  Org: [l_float32 sortparam]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.L_Box3d.npix">
	<summary>
 Brf: 
  Loc: SRC\colorquant2.c (181, 22)
  Org: [l_int32 npix]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Box3d.vol">
	<summary>
 Brf: 
  Loc: SRC\colorquant2.c (182, 22)
  Org: [l_int32 vol]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Box3d.r1">
	<summary>
 Brf: 
  Loc: SRC\colorquant2.c (183, 22)
  Org: [l_int32 r1]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Box3d.r2">
	<summary>
 Brf: 
  Loc: SRC\colorquant2.c (184, 22)
  Org: [l_int32 r2]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Box3d.g1">
	<summary>
 Brf: 
  Loc: SRC\colorquant2.c (185, 22)
  Org: [l_int32 g1]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Box3d.g2">
	<summary>
 Brf: 
  Loc: SRC\colorquant2.c (186, 22)
  Org: [l_int32 g2]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Box3d.b1">
	<summary>
 Brf: 
  Loc: SRC\colorquant2.c (187, 22)
  Org: [l_int32 b1]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Box3d.b2">
	<summary>
 Brf: 
  Loc: SRC\colorquant2.c (188, 22)
  Org: [l_int32 b2]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.FillSeg.xleft">
	<summary>
 Brf: left edge of run
  Loc: SRC\conncomp.c (101, 16)
  Org: [l_int32 xleft]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.FillSeg.xright">
	<summary>
 Brf: right edge of run
  Loc: SRC\conncomp.c (102, 16)
  Org: [l_int32 xright]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.FillSeg.y">
	<summary>
 Brf: run y
  Loc: SRC\conncomp.c (103, 16)
  Org: [l_int32 y]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.FillSeg.dy">
	<summary>
 Brf: parent segment direction: 1 above, -1 below)
  Loc: SRC\conncomp.c (104, 16)
  Org: [l_int32 dy]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbFindTemplatesState.classer">
	<summary>
 Brf: 
  Loc: SRC\jbclass.c (238, 22)
  Org: [JBCLASSER * classer]
  Msh: JBCLASSER * | 2:Struct |  Typedef: JbClasser = JbClasser
 </summary>
</member><member name="P:LeptonicaSharp.JbFindTemplatesState.w">
	<summary>
 Brf: 
  Loc: SRC\jbclass.c (239, 22)
  Org: [l_int32 w]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbFindTemplatesState.h">
	<summary>
 Brf: 
  Loc: SRC\jbclass.c (240, 22)
  Org: [l_int32 h]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbFindTemplatesState.i">
	<summary>
 Brf: 
  Loc: SRC\jbclass.c (241, 22)
  Org: [l_int32 i]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.JbFindTemplatesState.dna">
	<summary>
 Brf: 
  Loc: SRC\jbclass.c (242, 22)
  Org: [L_DNA * dna]
  Msh: L_DNA * | 2:Struct |  Typedef: L_Dna = L_Dna
 </summary>
</member><member name="P:LeptonicaSharp.JbFindTemplatesState.n">
	<summary>
 Brf: 
  Loc: SRC\jbclass.c (243, 22)
  Org: [l_int32 n]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.callback_data.jmpbuf">
	<summary>
 Brf: 
  Loc: SRC\jpegio.c (165, 15)
  Org: [jmp_buf jmpbuf]
  Msh: jmp_buf | 1:ConstantArray |
 </summary>
</member><member name="P:LeptonicaSharp.callback_data.comment">
	<summary>
 Brf: 
  Loc: SRC\jpegio.c (166, 15)
  Org: [l_uint8 * comment]
  Msh: l_uint8 * | 2:UChar | ([1 Byte, VB-Unsupported])
 </summary>
</member><member name="P:LeptonicaSharp.MazeElement.distance">
	<summary>
 Brf: 
  Loc: SRC\maze.c (77, 16)
  Org: [l_float32 distance]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.MazeElement.x">
	<summary>
 Brf: 
  Loc: SRC\maze.c (78, 16)
  Org: [l_int32 x]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.MazeElement.y">
	<summary>
 Brf: 
  Loc: SRC\maze.c (79, 16)
  Org: [l_int32 y]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.MazeElement.val">
	<summary>
 Brf: 
  Loc: SRC\maze.c (80, 16)
  Org: [l_uint32 val]
  Msh: l_uint32 | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.MazeElement.dir">
	<summary>
 Brf: 
  Loc: SRC\maze.c (81, 16)
  Org: [l_int32 dir]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PartitionElement.size">
	<summary>
 Brf: 
  Loc: SRC\partition.c (49, 16)
  Org: [l_float32 size]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.PartitionElement.box">
	<summary>
 Brf: 
  Loc: SRC\partition.c (50, 16)
  Org: [BOX * box]
  Msh: BOX * | 2:Struct |  Typedef: Box = Box
 </summary>
</member><member name="P:LeptonicaSharp.PartitionElement.boxa">
	<summary>
 Brf: 
  Loc: SRC\partition.c (51, 16)
  Org: [BOXA * boxa]
  Msh: BOXA * | 2:Struct |  Typedef: Boxa = Boxa
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryManager.allocator">
	<summary>
 Brf: 
  Loc: SRC\pix1.c (220, 17)
  Org: [alloc_fn allocator]
  Msh: alloc_fn | 1:Pointer |
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryManager.deallocator">
	<summary>
 Brf: 
  Loc: SRC\pix1.c (221, 17)
  Org: [dealloc_fn deallocator]
  Msh: dealloc_fn | 1:Pointer |
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.paa">
	<summary>
 Brf: Holds ptrs to allocated memory
  Loc: SRC\pixalloc.c (115, 22)
  Org: [struct L_Ptraa * paa]
  Msh: struct L_Ptraa * | 2:Struct |  Typedef: L_Ptraa = L_Ptraa
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.minsize">
	<summary>
 Brf: Pix smaller than this (in bytes)
  Loc: SRC\pixalloc.c (116, 22)
  Org: [size_t minsize]
  Msh: size_t | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.smallest">
	<summary>
 Brf: Smallest mem (in bytes) alloc'd
  Loc: SRC\pixalloc.c (118, 22)
  Org: [size_t smallest]
  Msh: size_t | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.largest">
	<summary>
 Brf: Larest mem (in bytes) alloc'd
  Loc: SRC\pixalloc.c (119, 22)
  Org: [size_t largest]
  Msh: size_t | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.nbytes">
	<summary>
 Brf: Size of allocated block w/ all chunks
  Loc: SRC\pixalloc.c (120, 22)
  Org: [size_t nbytes]
  Msh: size_t | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.nlevels">
	<summary>
 Brf: Num of power-of-2 sizes pre-alloc'd
  Loc: SRC\pixalloc.c (121, 22)
  Org: [l_int32 nlevels]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.sizes">
	<summary>
 Brf: Mem sizes at each power-of-2 level
  Loc: SRC\pixalloc.c (122, 22)
  Org: [size_t * sizes]
  Msh: size_t * | 2:UInt |  ... UInt = 4 Byte * Len)
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.allocarray">
	<summary>
 Brf: Number of mem alloc'd at each size
  Loc: SRC\pixalloc.c (123, 22)
  Org: [l_int32 * allocarray]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.baseptr">
	<summary>
 Brf: ptr to allocated array
  Loc: SRC\pixalloc.c (124, 22)
  Org: [l_uint32 * baseptr]
  Msh: l_uint32 * | 2:UInt |  ... UInt = 4 Byte * Len)
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.maxptr">
	<summary>
 Brf: ptr just beyond allocated memory
  Loc: SRC\pixalloc.c (125, 22)
  Org: [l_uint32 * maxptr]
  Msh: l_uint32 * | 2:UInt |  ... UInt = 4 Byte * Len)
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.firstptr">
	<summary>
 Brf: array of ptrs to first chunk in size
  Loc: SRC\pixalloc.c (126, 22)
  Org: [l_uint32 ** firstptr]
  Msh: l_uint32 ** | 3:UInt | List (of Byte()) ... UInt nicht Marshalbar. Verwende 4 Bytes
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.memused">
	<summary>
 Brf: log: total # of pix used (by level)
  Loc: SRC\pixalloc.c (127, 22)
  Org: [l_int32 * memused]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.meminuse">
	<summary>
 Brf: log: # of pix in use (by level)
  Loc: SRC\pixalloc.c (128, 22)
  Org: [l_int32 * meminuse]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.memmax">
	<summary>
 Brf: log: max # of pix in use (by level)
  Loc: SRC\pixalloc.c (129, 22)
  Org: [l_int32 * memmax]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.memempty">
	<summary>
 Brf: log: # of pix alloc'd because
  Loc: SRC\pixalloc.c (130, 22)
  Org: [l_int32 * memempty]
  Msh: l_int32 * | 2:Int | Integer() -  - Integer()
 </summary>
</member><member name="P:LeptonicaSharp.PixMemoryStore.logfile">
	<summary>
 Brf: log: set to null if no logging
  Loc: SRC\pixalloc.c (132, 22)
  Org: [char * logfile]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.MemIOData.m_Buffer">
	<summary>
 Brf: pointer to this node's I/O content
  Loc: SRC\pngio.c (1295, 17)
  Org: [char * m_Buffer]
  Msh: char * | 2:CharS |
 </summary>
</member><member name="P:LeptonicaSharp.MemIOData.m_Count">
	<summary>
 Brf: number of I/O content bytes read or written
  Loc: SRC\pngio.c (1296, 17)
  Org: [l_int32 m_Count]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.MemIOData.m_Size">
	<summary>
 Brf: allocated size of m_buffer
  Loc: SRC\pngio.c (1297, 17)
  Org: [l_int32 m_Size]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.MemIOData.m_Next">
	<summary>
 Brf: pointer to the next node in the list;
  Loc: SRC\pngio.c (1298, 24)
  Org: [struct MemIOData * m_Next]
  Msh: struct MemIOData * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.MemIOData.m_Last">
	<summary>
 Brf: pointer to the last node in the linked
  Loc: SRC\pngio.c (1300, 24)
  Org: [struct MemIOData * m_Last]
  Msh: struct MemIOData * | 2:Struct |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pixel.x">
	<summary>
 Brf: 
  Loc: SRC\seedfill.c (172, 16)
  Org: [l_int32 x]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Pixel.y">
	<summary>
 Brf: 
  Loc: SRC\seedfill.c (173, 16)
  Org: [l_int32 y]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.CompParameterMap.size">
	<summary>
 Brf: 
  Loc: SRC\sel1.c (154, 14)
  Org: [l_int32 size]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.CompParameterMap.size1">
	<summary>
 Brf: 
  Loc: SRC\sel1.c (155, 14)
  Org: [l_int32 size1]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.CompParameterMap.size2">
	<summary>
 Brf: 
  Loc: SRC\sel1.c (156, 14)
  Org: [l_int32 size2]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.CompParameterMap.selnameh1">
	<summary>
 Brf: 
  Loc: SRC\sel1.c (157, 14)
  Org: [char [20] selnameh1]
  Msh: char [20] | 1:ConstantArray |
 </summary>
</member><member name="P:LeptonicaSharp.CompParameterMap.selnameh2">
	<summary>
 Brf: 
  Loc: SRC\sel1.c (158, 14)
  Org: [char [20] selnameh2]
  Msh: char [20] | 1:ConstantArray |
 </summary>
</member><member name="P:LeptonicaSharp.CompParameterMap.selnamev1">
	<summary>
 Brf: 
  Loc: SRC\sel1.c (159, 14)
  Org: [char [20] selnamev1]
  Msh: char [20] | 1:ConstantArray |
 </summary>
</member><member name="P:LeptonicaSharp.CompParameterMap.selnamev2">
	<summary>
 Brf: 
  Loc: SRC\sel1.c (160, 14)
  Org: [char [20] selnamev2]
  Msh: char [20] | 1:ConstantArray |
 </summary>
</member><member name="P:LeptonicaSharp.L_GenAssoc.index">
	<summary>
 Brf: 
  Loc: SRC\stringcode.c (97, 14)
  Org: [l_int32 index]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_GenAssoc.type">
	<summary>
 Brf: 
  Loc: SRC\stringcode.c (98, 14)
  Org: [char [16] type]
  Msh: char [16] | 1:ConstantArray |
 </summary>
</member><member name="P:LeptonicaSharp.L_GenAssoc.structname">
	<summary>
 Brf: 
  Loc: SRC\stringcode.c (99, 14)
  Org: [char [16] structname]
  Msh: char [16] | 1:ConstantArray |
 </summary>
</member><member name="P:LeptonicaSharp.L_GenAssoc.reader">
	<summary>
 Brf: 
  Loc: SRC\stringcode.c (100, 14)
  Org: [char [16] reader]
  Msh: char [16] | 1:ConstantArray |
 </summary>
</member><member name="P:LeptonicaSharp.L_GenAssoc.memreader">
	<summary>
 Brf: 
  Loc: SRC\stringcode.c (101, 14)
  Org: [char [20] memreader]
  Msh: char [20] | 1:ConstantArray |
 </summary>
</member><member name="P:LeptonicaSharp.tiff_transform.vflip">
	<summary>
 Brf: 
  Loc: SRC\tiffio.c (156, 9)
  Org: [int vflip]
  Msh: int | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.tiff_transform.hflip">
	<summary>
 Brf: 
  Loc: SRC\tiffio.c (157, 9)
  Org: [int hflip]
  Msh: int | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.tiff_transform.rotate">
	<summary>
 Brf: 
  Loc: SRC\tiffio.c (158, 9)
  Org: [int rotate]
  Msh: int | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_Memstream.buffer">
	<summary>
 Brf: 
  Loc: SRC\tiffio.c (2176, 16)
  Org: [l_uint8 * buffer]
  Msh: l_uint8 * | 2:UChar | ([1 Byte, VB-Unsupported])
 </summary>
</member><member name="P:LeptonicaSharp.L_Memstream.bufsize">
	<summary>
 Brf: 
  Loc: SRC\tiffio.c (2178, 16)
  Org: [size_t bufsize]
  Msh: size_t | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.L_Memstream.offset">
	<summary>
 Brf: 
  Loc: SRC\tiffio.c (2180, 16)
  Org: [size_t offset]
  Msh: size_t | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.L_Memstream.hw">
	<summary>
 Brf: 
  Loc: SRC\tiffio.c (2181, 16)
  Org: [size_t hw]
  Msh: size_t | 1:UInt |
 </summary>
</member><member name="P:LeptonicaSharp.L_Memstream.poutdata">
	<summary>
 Brf: 
  Loc: SRC\tiffio.c (2182, 16)
  Org: [l_uint8 ** poutdata]
  Msh: l_uint8 ** | 3:UChar | Byte() ... Pointer auf ein Byte-Array
 </summary>
</member><member name="P:LeptonicaSharp.L_Memstream.poutsize">
	<summary>
 Brf: 
  Loc: SRC\tiffio.c (2183, 16)
  Org: [size_t * poutsize]
  Msh: size_t * | 2:UInt |  ... UInt = 4 Byte * Len)
 </summary>
</member><member name="P:LeptonicaSharp.L_NewPixel.x">
	<summary>
 Brf: x coordinate
  Loc: SRC\watershed.c (126, 16)
  Org: [l_int32 x]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_NewPixel.y">
	<summary>
 Brf: y coordinate
  Loc: SRC\watershed.c (127, 16)
  Org: [l_int32 y]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_WSPixel.val">
	<summary>
 Brf: pixel value
  Loc: SRC\watershed.c (134, 16)
  Org: [l_float32 val]
  Msh: l_float32 | 1:Float |
 </summary>
</member><member name="P:LeptonicaSharp.L_WSPixel.x">
	<summary>
 Brf: x coordinate
  Loc: SRC\watershed.c (135, 16)
  Org: [l_int32 x]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_WSPixel.y">
	<summary>
 Brf: y coordinate
  Loc: SRC\watershed.c (136, 16)
  Org: [l_int32 y]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.L_WSPixel.index">
	<summary>
 Brf: label for set to which pixel belongs
  Loc: SRC\watershed.c (137, 16)
  Org: [l_int32 index]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="P:LeptonicaSharp.ExtensionMap.extension">
	<summary>
 Brf: 
  Loc: SRC\writefile.c (141, 14)
  Org: [char [8] extension]
  Msh: char [8] | 1:ConstantArray |
 </summary>
</member><member name="P:LeptonicaSharp.ExtensionMap.format">
	<summary>
 Brf: 
  Loc: SRC\writefile.c (142, 14)
  Org: [l_int32 format]
  Msh: l_int32 | 1:Int |
 </summary>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCleanBackgroundToWhite(LeptonicaSharp.Pix,System.Single,System.Int32,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a simplified interface for cleaning an image.
 For comparison, see pixAdaptThresholdToBinaryGen().
 (2) The suggested default values for the input parameters are
 gamma 1.0  (reduce this to increase the contrast; e.g.,
 for light text)
 blackval   70  (a bit more than 60)
 whiteval  190  (a bit less than 200)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale or 32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="pixg">8 bpp grayscale version; can be null</param>
	<param name="gamma">gamma correction; must be GT 0.0; typically ~1.0</param>
	<param name="blackval">dark value to set to black (0)</param>
	<param name="whiteval">light value to set to white (255)</param>
	<returns>pixd 8 bpp or 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBackgroundNormSimple(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a simplified interface to pixBackgroundNorm(),
 where seven parameters are defaulted.
 (2) The input image is either grayscale or rgb.
 (3) See pixBackgroundNorm() for usage and function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale or 32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="pixg">8 bpp grayscale version; can be null</param>
	<returns>pixd 8 bpp or 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBackgroundNorm(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a top-level interface for normalizing the image intensity
 by mapping the image so that the background is near the input
 value 'bgval'.
 (2) The input image is either grayscale or rgb.
 (3) For each component in the input image, the background value
 in each tile is estimated using the values in the tile that
 are not part of the foreground, where the foreground is
 determined by the input 'thresh' argument.
 (4) An optional binary mask can be specified, with the foreground
 pixels typically over image regions.  The resulting background
 map values will be determined by surrounding pixels that are
 not under the mask foreground.  The origin (0,0) of this mask
 is assumed to be aligned with the origin of the input image.
 This binary mask must not fully cover pixs, because then there
 will be no pixels in the input image available to compute
 the background.
 (5) An optional grayscale version of the input pixs can be supplied.
 The only reason to do this is if the input is RGB and this
 grayscale version can be used elsewhere.  If the input is RGB
 and this is not supplied, it is made internally using only
 the green component, and destroyed after use.
 (6) The dimensions of the pixel tile (sx, sy) give the amount by
 by which the map is reduced in size from the input image.
 (7) The threshold is used to binarize the input image, in order to
 locate the foreground components.  If this is set too low,
 some actual foreground may be used to determine the maps;
 if set too high, there may not be enough background
 to determine the map values accurately.  Typically, it's
 better to err by setting the threshold too high.
 (8) A 'mincount' threshold is a minimum count of pixels in a
 tile for which a background reading is made, in order for that
 pixel in the map to be valid.  This number should perhaps be
 at least 1/3 the size of the tile.
 (9) A 'bgval' target background value for the normalized image.  This
 should be at least 128.  If set too close to 255, some
 clipping will occur in the result.
 (10) Two factors, 'smoothx' and 'smoothy', are input for smoothing
 the map.  Each low-pass filter kernel dimension is
 is 2  (smoothing factor) + 1, so a
 value of 0 means no smoothing. A value of 1 or 2 is recommended.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale or 32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="pixg">8 bpp grayscale version; can be null</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="smoothx">half-width of block convolution kernel width</param>
	<param name="smoothy">half-width of block convolution kernel height</param>
	<returns>pixd 8 bpp or 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBackgroundNormMorph(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a top-level interface for normalizing the image intensity
 by mapping the image so that the background is near the input
 value 'bgval'.
 (2) The input image is either grayscale or rgb.
 (3) For each component in the input image, the background value
 is estimated using a grayscale closing; hence the 'Morph'
 in the function name.
 (4) An optional binary mask can be specified, with the foreground
 pixels typically over image regions.  The resulting background
 map values will be determined by surrounding pixels that are
 not under the mask foreground.  The origin (0,0) of this mask
 is assumed to be aligned with the origin of the input image.
 This binary mask must not fully cover pixs, because then there
 will be no pixels in the input image available to compute
 the background.
 (5) The map is computed at reduced size (given by 'reduction')
 from the input pixs and optional pixim.  At this scale,
 pixs is closed to remove the background, using a square Sel
 of odd dimension.  The product of reduction  size should be
 large enough to remove most of the text foreground.
 (6) No convolutional smoothing needs to be done on the map before
 inverting it.
 (7) A 'bgval' target background value for the normalized image.  This
 should be at least 128.  If set too close to 255, some
 clipping will occur in the result.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale or 32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="reduction">at which morph closings are done; between 2 and 16</param>
	<param name="size">of square Sel for the closing; use an odd number</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBackgroundNormGrayArray(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See notes in pixBackgroundNorm().
 (2) This returns a 16 bpp pix that can be used by
 pixApplyInvBackgroundGrayMap() to generate a normalized version
 of the input pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="smoothx">half-width of block convolution kernel width</param>
	<param name="smoothy">half-width of block convolution kernel height</param>
	<param name="ppixd">16 bpp array of inverted background value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBackgroundNormRGBArrays(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See notes in pixBackgroundNorm().
 (2) This returns a set of three 16 bpp pix that can be used by
 pixApplyInvBackgroundGrayMap() to generate a normalized version
 of each component of the input pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="pixg">8 bpp grayscale version; can be null</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="smoothx">half-width of block convolution kernel width</param>
	<param name="smoothy">half-width of block convolution kernel height</param>
	<param name="ppixr">16 bpp array of inverted R background value</param>
	<param name="ppixg">16 bpp array of inverted G background value</param>
	<param name="ppixb">16 bpp array of inverted B background value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBackgroundNormGrayArrayMorph(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See notes in pixBackgroundNormMorph().
 (2) This returns a 16 bpp pix that can be used by
 pixApplyInvBackgroundGrayMap() to generate a normalized version
 of the input pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="reduction">at which morph closings are done; between 2 and 16</param>
	<param name="size">of square Sel for the closing; use an odd number</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="ppixd">16 bpp array of inverted background value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBackgroundNormRGBArraysMorph(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See notes in pixBackgroundNormMorph().
 (2) This returns a set of three 16 bpp pix that can be used by
 pixApplyInvBackgroundGrayMap() to generate a normalized version
 of each component of the input pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="reduction">at which morph closings are done; between 2 and 16</param>
	<param name="size">of square Sel for the closing; use an odd number</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="ppixr">16 bpp array of inverted R background value</param>
	<param name="ppixg">16 bpp array of inverted G background value</param>
	<param name="ppixb">16 bpp array of inverted B background value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetBackgroundGrayMap(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The background is measured in regions that don't have
 images.  It is then propagated into the image regions,
 and finally smoothed in each image region.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not cmapped</param>
	<param name="pixim">1 bpp 'image' mask; can be null; it should not have all foreground pixels</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="ppixd">8 bpp grayscale map</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetBackgroundRGBMap(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If pixg, which is a grayscale version of pixs, is provided,
 use this internally to generate the foreground mask.
 Otherwise, a grayscale version of pixs will be generated
 from the green component only, used, and destroyed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null; it should not have all foreground pixels</param>
	<param name="pixg">8 bpp grayscale version; can be null</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="ppixmr">rgb maps</param>
	<param name="ppixmg">rgb maps</param>
	<param name="ppixmb">rgb maps</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetBackgroundGrayMapMorph(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not cmapped</param>
	<param name="pixim">1 bpp 'image' mask; can be null; it should not have all foreground pixels</param>
	<param name="reduction">factor at which closing is performed</param>
	<param name="size">of square Sel for the closing; use an odd number</param>
	<param name="ppixm">grayscale map</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetBackgroundRGBMapMorph(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="pixim">1 bpp 'image' mask; can be null; it should not have all foreground pixels</param>
	<param name="reduction">factor at which closing is performed</param>
	<param name="size">of square Sel for the closing; use an odd number</param>
	<param name="ppixmr">red component map</param>
	<param name="ppixmg">green component map</param>
	<param name="ppixmb">blue component map</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFillMapHoles(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_FILL)">
	<summary>
 Notes
 (1) This is an in-place operation on pix (the map).  pix is
 typically a low-resolution version of some other image
 from which it was derived, where each pixel in pix
 corresponds to a rectangular tile (say, m x n) of pixels
 in the larger image.  All we need to know about the larger
 image is whether or not the rightmost column and bottommost
 row of pixels in pix correspond to tiles that are
 only partially covered by pixels in the larger image.
 (2) Typically, some number of pixels in the input map are
 not known, and their values must be determined by near
 pixels that are known.  These unknown pixels are the 'holes'.
 They can take on only two values, 0 and 255, and the
 instruction about which to fill is given by the filltype flag.
 (3) The "holes" can come from two sources.  The first is when there
 are not enough foreground or background pixels in a tile;
 the second is when a tile is at least partially covered
 by an image mask.  If we're filling holes in a fg mask,
 the holes are initialized to black (0) and use L_FILL_BLACK.
 For filling holes in a bg mask, initialize the holes to
 white (255) and use L_FILL_WHITE.
 (4) If w is the map width, nx = w or nx = w - 1; ditto for h and ny.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; a map, with one pixel for each tile in a larger image</param>
	<param name="nx">number of horizontal pixel tiles that are entirely covered with pixels in the original source image</param>
	<param name="ny">ditto for the number of vertical pixel tiles</param>
	<param name="filltype">L_FILL_WHITE or L_FILL_BLACK</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExtendByReplication(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The pixel values are extended to the left and down, as required.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="addw">number of extra pixels horizontally to add</param>
	<param name="addh">number of extra pixels vertically to add</param>
	<returns>pixd extended with replicated pixel values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSmoothConnectedRegions(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The pixels in pixs corresponding to those in each
 8-connected region in the mask are set to the average value.
 (2) This is required for adaptive mapping to avoid the
 generation of stripes in the background map, due to
 variations in the pixel values near the edges of mask regions.
 (3) This function is optimized for background smoothing, where
 there are a relatively small number of components.  It will
 be inefficient if used where there are many small components.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; no colormap</param>
	<param name="pixm">1 bpp; if null, this is a no-op</param>
	<param name="factor">subsampling factor for getting average; GT= 1</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetInvBackgroundMap(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) bgval should typically be GT 120 and LT 240
 (2) pixd is a normalization image; the original image is
 multiplied by pixd and the result is divided by 256.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; no colormap</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="smoothx">half-width of block convolution kernel width</param>
	<param name="smoothy">half-width of block convolution kernel height</param>
	<returns>pixd 16 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixApplyInvBackgroundGrayMap(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; no colormap</param>
	<param name="pixm">16 bpp, inverse background map</param>
	<param name="sx">tile width in pixels</param>
	<param name="sy">tile height in pixels</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixApplyInvBackgroundRGBMap(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rbg</param>
	<param name="pixmr">16 bpp, red inverse background map</param>
	<param name="pixmg">16 bpp, green inverse background map</param>
	<param name="pixmb">16 bpp, blue inverse background map</param>
	<param name="sx">tile width in pixels</param>
	<param name="sy">tile height in pixels</param>
	<returns>pixd 32 bpp rbg, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixApplyVariableGrayMap(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Suppose you have an image that you want to transform based
 on some photometric measurement at each point, such as the
 threshold value for binarization.  Representing the photometric
 measurement as an image pixg, you can threshold in input image
 using pixVarThresholdToBinary().  Alternatively, you can map
 the input image pointwise so that the threshold over the
 entire image becomes a constant, such as 128.  For example,
 if a pixel in pixg is 150 and the target is 128, the
 corresponding pixel in pixs is mapped linearly to a value
 (128/150) of the input value.  If the resulting mapped image
 pixd were then thresholded at 128, you would obtain the
 same result as a direct binarization using pixg with
 pixVarThresholdToBinary().
 (2) The sizes of pixs and pixg must be equal.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="pixg">8 bpp, variable map</param>
	<param name="target">typ. 128 for threshold</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGlobalNormRGB(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The value of pixd determines if the results are written to a
 new pix (use NULL), in-place to pixs (use pixs), or to some
 other existing pix.
 (2) This does a global normalization of an image where the
 r,g,b color components are not balanced.  Thus, white in pixs is
 represented by a set of r,g,b values that are not all 255.
 (3) The input values (rval, gval, bval) should be chosen to
 represent the gray color (mapval, mapval, mapval) in src.
 Thus, this function will map (rval, gval, bval) to that gray color.
 (4) Typically, mapval = 255, so that (rval, gval, bval)
 corresponds to the white point of src.  In that case, these
 parameters should be chosen so that few pixels have higher values.
 (5) In all cases, we do a linear TRC separately on each of the
 components, saturating at 255.
 (6) If the input pix is 8 bpp without a colormap, you can get
 this functionality with mapval = 255 by calling
 pixGammaTRC(pixd, pixs, 1.0, 0, bgval);
 where bgval is the value you want to be mapped to 255.
 Or more generally, if you want bgval to be mapped to mapval
 pixGammaTRC(pixd, pixs, 1.0, 0, 255  bgval / mapval);
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null, existing or equal to pixs</param>
	<param name="pixs">32 bpp rgb, or colormapped</param>
	<param name="rval">pixel values in pixs that are linearly mapped to mapval</param>
	<param name="gval">pixel values in pixs that are linearly mapped to mapval</param>
	<param name="bval">pixel values in pixs that are linearly mapped to mapval</param>
	<param name="mapval">use 255 for mapping to white</param>
	<returns>pixd 32 bpp rgb or colormapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGlobalNormNoSatRGB(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a version of pixGlobalNormRGB(), where the output
 intensity is scaled back so that a controlled fraction of
 pixel components is allowed to saturate.  See comments in
 pixGlobalNormRGB().
 (2) The value of pixd determines if the results are written to a
 new pix (use NULL), in-place to pixs (use pixs), or to some
 other existing pix.
 (3) This does a global normalization of an image where the
 r,g,b color components are not balanced.  Thus, white in pixs is
 represented by a set of r,g,b values that are not all 255.
 (4) The input values (rval, gval, bval) can be chosen to be the
 color that, after normalization, becomes white background.
 For images that are mostly background, the closer these values
 are to the median component values, the closer the resulting
 background will be to gray, becoming white at the brightest places.
 (5) The mapval used in pixGlobalNormRGB() is computed here to
 avoid saturation of any component in the image (save for a
 fraction of the pixels given by the input rank value).
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null, existing or equal to pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="rval">pixel values in pixs that are linearly mapped to mapval; but see below</param>
	<param name="gval">pixel values in pixs that are linearly mapped to mapval; but see below</param>
	<param name="bval">pixel values in pixs that are linearly mapped to mapval; but see below</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="rank">between 0.0 and 1.0; typ. use a value near 1.0</param>
	<returns>pixd 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixThresholdSpreadNorm(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_EDGE,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) The basis of this approach is the use of seed spreading
 on a (possibly) sparse set of estimates for the local threshold.
 The resulting dense estimates are smoothed by convolution
 and used to either threshold the input image or normalize it
 with a local transformation that linearly maps the pixels so
 that the local threshold estimate becomes constant over the
 resulting image.  This approach is one of several that
 have been suggested (and implemented) by Ray Smith.
 (2) You can use either the Sobel or TwoSided edge filters.
 The results appear to be similar, using typical values
 of edgethresh in the rang 10-20.
 (3) To skip the trc enhancement, use gamma = 1.0, minval = 0
 and maxval = 255.
 (4) For the normalized image pixd, each pixel is linearly mapped
 in such a way that the local threshold is equal to targetthresh.
 (5) The full width and height of the convolution kernel
 are (2  smoothx + 1) and (2  smoothy + 1).
 (6) This function can be used with the pixtiling utility if the
 images are too large.  See pixOtsuAdaptiveThreshold() for
 an example of this.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="filtertype">L_SOBEL_EDGE or L_TWO_SIDED_EDGE;</param>
	<param name="edgethresh">threshold on magnitude of edge filter; typ 10-20</param>
	<param name="smoothx">half-width of convolution kernel applied to spread threshold use 0 for no smoothing</param>
	<param name="smoothy">half-width of convolution kernel applied to spread threshold use 0 for no smoothing</param>
	<param name="gamma">gamma correction; typ. about 0.7</param>
	<param name="minval">input value that gives 0 for output; typ. -25</param>
	<param name="maxval">input value that gives 255 for output; typ. 255</param>
	<param name="targetthresh">target threshold for normalization</param>
	<param name="ppixth">computed local threshold value</param>
	<param name="ppixb">thresholded normalized image</param>
	<param name="ppixd">normalized image</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBackgroundNormFlex(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does adaptation flexibly to a quickly varying background.
 For that reason, all input parameters should be small.
 (2) sx and sy give the tile size; they should be in [5 - 7].
 (3) The full width and height of the convolution kernel
 are (2  smoothx + 1) and (2  smoothy + 1).  They
 should be in [1 - 2].
 (4) Basin filling is used to fill the large fg regions.  The
 parameter %delta measures the height that the black
 background is raised from the local minima.  By raising
 the background, it is possible to threshold the large
 fg regions to foreground.  If %delta is too large,
 bg regions will be lifted, causing thickening of
 the fg regions.  Use 0 to skip.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="sx">desired tile dimensions; actual size may vary; use values between 3 and 10</param>
	<param name="sy">desired tile dimensions; actual size may vary; use values between 3 and 10</param>
	<param name="smoothx">half-width of convolution kernel applied to threshold array use values between 1 and 3</param>
	<param name="smoothy">half-width of convolution kernel applied to threshold array use values between 1 and 3</param>
	<param name="delta">difference parameter in basin filling; use 0 to skip</param>
	<returns>pixd 8 bpp, background-normalized), or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixContrastNorm(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This function adaptively attempts to expand the contrast
 to the full dynamic range in each tile.  If the contrast in
 a tile is smaller than %mindiff, it uses the min and max
 pixel values from neighboring tiles.  It also can use
 convolution to smooth the min and max values from
 neighboring tiles.  After all that processing, it is
 possible that the actual pixel values in the tile are outside
 the computed [min ... max] range for local contrast
 normalization.  Such pixels are taken to be at either 0
 (if below the min) or 255 (if above the max).
 (2) pixd can be equal to pixs (in-place operation) or
 null (makes a new pixd).
 (3) sx and sy give the tile size; they are typically at least 20.
 (4) mindiff is used to eliminate results for tiles where it is
 likely that either fg or bg is missing.  A value around 50
 or more is reasonable.
 (5) The full width and height of the convolution kernel
 are (2  smoothx + 1) and (2  smoothy + 1).  Some smoothing
 is typically useful, and we limit the smoothing half-widths
 to the range from 0 to 8.
 (6) A linear TRC (gamma = 1.0) is applied to increase the contrast
 in each tile.  The result can subsequently be globally corrected,
 by applying pixGammaTRC() with arbitrary values of gamma
 and the 0 and 255 points of the mapping.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8 bpp; null or equal to pixs</param>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="sx">tile dimensions</param>
	<param name="sy">tile dimensions</param>
	<param name="mindiff">minimum difference to accept as valid</param>
	<param name="smoothx">half-width of convolution kernel applied to min and max arrays use 0 for no smoothing</param>
	<param name="smoothy">half-width of convolution kernel applied to min and max arrays use 0 for no smoothing</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMinMaxTiles(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This computes filtered and smoothed values for the min and
 max pixel values in each tile of the image.
 (2) See pixContrastNorm() for usage.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="sx">tile dimensions</param>
	<param name="sy">tile dimensions</param>
	<param name="mindiff">minimum difference to accept as valid</param>
	<param name="smoothx">half-width of convolution kernel applied to min and max arrays use 0 for no smoothing</param>
	<param name="smoothy">half-width of convolution kernel applied to min and max arrays use 0 for no smoothing</param>
	<param name="ppixmin">tiled minima</param>
	<param name="ppixmax">tiled maxima</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetLowContrast(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This compares corresponding pixels in pixs1 and pixs2.
 When they differ by less than %mindiff, set the pixel
 values to 0 in each.  Each pixel typically represents a tile
 in a larger image, and a very small difference between
 the min and max in the tile indicates that the min and max
 values are not to be trusted.
 (2) If contrast (pixel difference) detection is expected to fail,
 caller should check return value.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">8 bpp</param>
	<param name="pixs2">8 bpp</param>
	<param name="mindiff">minimum difference to accept as valid</param>
	<returns>0 if OK; 1 if no pixel diffs are large enough, or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixLinearTRCTiled(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) pixd can be equal to pixs (in-place operation) or
 null (makes a new pixd).
 (2) sx and sy give the tile size; they are typically at least 20.
 (3) pixmin and pixmax are generated by pixMinMaxTiles()
 (4) For each tile, this does a linear expansion of the dynamic
 range so that the min value in the tile becomes 0 and the
 max value in the tile becomes 255.
 (5) The LUTs that do the mapping are generated as needed
 and stored for reuse in an integer array within the ptr array iaa[].
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8 bpp</param>
	<param name="pixs">8 bpp, not colormapped</param>
	<param name="sx">tile dimensions</param>
	<param name="sy">tile dimensions</param>
	<param name="pixmin">pix of min values in tiles</param>
	<param name="pixmax">pix of max values in tiles</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAffineSampledPta(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary.
 (2) Retains colormap, which you can do for a sampled transform..
 (3) The 3 points must not be collinear.
 (4) The order of the 3 points is arbitrary; however, to compare
 with the sequential transform they must be in these locations
 and in this order origin, x-axis, y-axis.
 (5) For 1 bpp images, this has much better quality results
 than pixAffineSequential(), particularly for text.
 It is about 3x slower, but does not require additional
 border pixels.  The poor quality of pixAffineSequential()
 is due to repeated quantized transforms.  It is strongly
 recommended that pixAffineSampled() be used for 1 bpp images.
 (6) For 8 or 32 bpp, much better quality is obtained by the
 somewhat slower pixAffinePta().  See that function
 for relative timings between sampled and interpolated.
 (7) To repeat, use of the sequential transform,
 pixAffineSequential(), for any images, is discouraged.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="ptad">3 pts of final coordinate space</param>
	<param name="ptas">3 pts of initial coordinate space</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAffineSampled(LeptonicaSharp.Pix,System.Single[],LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary.
 (2) Retains colormap, which you can do for a sampled transform..
 (3) For 8 or 32 bpp, much better quality is obtained by the
 somewhat slower pixAffine().  See that function
 for relative timings between sampled and interpolated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="vc">vector of 6 coefficients for affine transformation</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAffinePta(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary
 (2) Removes any existing colormap, if necessary, before transforming
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="ptad">3 pts of final coordinate space</param>
	<param name="ptas">3 pts of initial coordinate space</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAffine(LeptonicaSharp.Pix,System.Single[],LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary
 (2) Removes any existing colormap, if necessary, before transforming
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="vc">vector of 6 coefficients for affine transformation</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAffinePtaColor(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="ptad">3 pts of final coordinate space</param>
	<param name="ptas">3 pts of initial coordinate space</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAffineColor(LeptonicaSharp.Pix,System.Single[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="vc">vector of 6 coefficients for affine transformation</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAffinePtaGray(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="ptad">3 pts of final coordinate space</param>
	<param name="ptas">3 pts of initial coordinate space</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAffineGray(LeptonicaSharp.Pix,System.Single[],System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="vc">vector of 6 coefficients for affine transformation</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAffinePtaWithAlpha(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.Single,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The alpha channel is transformed separately from pixs,
 and aligns with it, being fully transparent outside the
 boundary of the transformed pixs.  For pixels that are fully
 transparent, a blending function like pixBlendWithGrayMask()
 will give zero weight to corresponding pixels in pixs.
 (2) If pixg is NULL, it is generated as an alpha layer that is
 partially opaque, using %fract.  Otherwise, it is cropped
 to pixs if required and %fract is ignored.  The alpha channel
 in pixs is never used.
 (3) Colormaps are removed.
 (4) When pixs is transformed, it doesn't matter what color is brought
 in because the alpha channel will be transparent (0) there.
 (5) To avoid losing source pixels in the destination, it may be
 necessary to add a border to the source pix before doing
 the affine transformation.  This can be any non-negative number.
 (6) The input %ptad and %ptas are in a coordinate space before
 the border is added.  Internally, we compensate for this
 before doing the affine transform on the image after the border
 is added.
 (7) The default setting for the border values in the alpha channel
 is 0 (transparent) for the outermost ring of pixels and
 (0.5  fract  255) for the second ring.  When blended over
 a second image, this
 (a) shrinks the visible image to make a clean overlap edge
 with an image below, and
 (b) softens the edges by weakening the aliasing there.
 Use l_setAlphaMaskBorder() to change these values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="ptad">3 pts of final coordinate space</param>
	<param name="ptas">3 pts of initial coordinate space</param>
	<param name="pixg">8 bpp, can be null</param>
	<param name="fract">between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	<param name="border">of pixels added to capture transformed source pixels</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getAffineXformCoeffs(LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.Collections.Generic.List{System.Single[]}@)">
	<summary>
 We have a set of six equations, describing the affine
 transformation that takes 3 points ptas into 3 other
 points ptad.  These equations are
 x1' = c[0]x1 + c[1]y1 + c[2]
 y1' = c[3]x1 + c[4]y1 + c[5]
 x2' = c[0]x2 + c[1]y2 + c[2]
 y2' = c[3]x2 + c[4]y2 + c[5]
 x3' = c[0]x3 + c[1]y3 + c[2]
 y3' = c[3]x3 + c[4]y3 + c[5]
 This can be represented as
 AC = B
 where B and C are column vectors
 B = [ x1' y1' x2' y2' x3' y3' ]
 C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] ]
 and A is the 6x6 matrix
 x1   y1   1   0 0 0
 0 0   0   x1   y1   1
 x2   y2   1   0 0 0
 0 0   0   x2   y2   1
 x3   y3   1   0 0 0
 0 0   0   x3   y3   1
 These six equations are solved here for the coefficients C.
 These six coefficients can then be used to find the dest
 point x',y') corresponding to any src point (x,y, according
 to the equations
 x' = c[0]x + c[1]y + c[2]
 y' = c[3]x + c[4]y + c[5]
 that are implemented in affineXformPt.
 !!!!!!!!!!!!!!!!!!   Very important   !!!!!!!!!!!!!!!!!!!!!!
 When the affine transform is composed from a set of simple
 operations such as translation, scaling and rotation,
 it is built in a form to convert from the un-transformed src
 point to the transformed dest point.  However, when an
 affine transform is used on images, it is used in an inverted
 way it converts from the transformed dest point to the
 un-transformed src point.  So, for example, if you transform
 a boxa using transform A, to transform an image in the same
 way you must use the inverse of A.
 For example, if you transform a boxa with a 3x3 affine matrix
 'mat', the analogous image transformation must use 'matinv'
 \code
 boxad = boxaAffineTransform(boxas, mat);
 affineInvertXform(mat, matinv);
 pixd = pixAffine(pixs, matinv, L_BRING_IN_WHITE);
 \endcode
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">source 3 points; unprimed</param>
	<param name="ptad">transformed 3 points; primed</param>
	<param name="pvc">vector of coefficients of transform</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.affineInvertXform(System.Single[],System.Collections.Generic.List{System.Single[]}@)">
	<summary>
 Notes
 (1) The 6 affine transform coefficients are the first
 two rows of a 3x3 matrix where the last row has
 only a 1 in the third column.  We invert this
 using gaussjordan(), and select the first 2 rows
 as the coefficients of the inverse affine transform.
 (2) Alternatively, we can find the inverse transform
 coefficients by inverting the 2x2 submatrix,
 and treating the top 2 coefficients in the 3rd column as
 a RHS vector for that 2x2 submatrix.  Then the
 6 inverted transform coefficients are composed of
 the inverted 2x2 submatrix and the negative of the
 transformed RHS vector.  Why is this so?  We have
 Y = AX + R  (2 equations in 6 unknowns)
 Then
 X = A'Y - A'R
 Gauss-jordan solves
 AF = R
 and puts the solution for F, which is A'R,
 into the input R vector.
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 6 coefficients</param>
	<param name="pvci">inverted transform</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.affineXformSampledPt(System.Single[],System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This finds the nearest pixel coordinates of the transformed point.
 (2) It does not check ptrs for returned data!
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 6 coefficients</param>
	<param name="x">initial point</param>
	<param name="y">initial point</param>
	<param name="pxp">transformed point</param>
	<param name="pyp">transformed point</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.affineXformPt(System.Single[],System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This computes the floating point location of the transformed point.
 (2) It does not check ptrs for returned data!
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 6 coefficients</param>
	<param name="x">initial point</param>
	<param name="y">initial point</param>
	<param name="pxp">transformed point</param>
	<param name="pyp">transformed point</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.linearInterpolatePixelColor(System.Byte[],System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) This is a standard linear interpolation function.  It is
 equivalent to area weighting on each component, and
 avoids "jaggies" when rendering sharp edges.
 </summary>
	<remarks>
	</remarks>
	<param name="datas">ptr to beginning of image data</param>
	<param name="wpls">32-bit word/line for this data array</param>
	<param name="w">of image</param>
	<param name="h">of image</param>
	<param name="x">floating pt location for evaluation</param>
	<param name="y">floating pt location for evaluation</param>
	<param name="colorval">color brought in from the outside when the input x,y location is outside the image; in 0xrrggbb00 format)</param>
	<param name="pval">interpolated color value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.linearInterpolatePixelGray(System.Byte[],System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This is a standard linear interpolation function.  It is
 equivalent to area weighting on each component, and
 avoids "jaggies" when rendering sharp edges.
 </summary>
	<remarks>
	</remarks>
	<param name="datas">ptr to beginning of image data</param>
	<param name="wpls">32-bit word/line for this data array</param>
	<param name="w">of image</param>
	<param name="h">of image</param>
	<param name="x">floating pt location for evaluation</param>
	<param name="y">floating pt location for evaluation</param>
	<param name="grayval">color brought in from the outside when the input x,y location is outside the image</param>
	<param name="pval">interpolated gray value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gaussjordan(System.Collections.Generic.List{System.Single[]},System.Single[],System.Int32)">
	<summary>
 Notes
 (1) There are two side-effects
 The matrix a is transformed to its inverse A
 The rhs vector b is transformed to the solution x
 of the linear equation ax = b
 (2) The inverse A can then be used to solve the same equation with
 different rhs vectors c by multiplication x = Ac
 (3) Adapted from "Numerical Recipes in C, Second Edition", 1992,
 pp. 36-41 (gauss-jordan elimination)
 </summary>
	<remarks>
	</remarks>
	<param name="a">n x n matrix</param>
	<param name="b">n x 1 right-hand side column vector</param>
	<param name="n">dimension</param>
	<returns>0 if ok, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAffineSequential(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The 3 pts must not be collinear.
 (2) The 3 pts must be given in this order
 ~ origin
 ~ a location along the x-axis
 ~ a location along the y-axis.
 (3) You must guess how much border must be added so that no
 pixels are lost in the transformations from src to
 dest coordinate space.  (This can be calculated but it
 is a lot of work!)  For coordinate spaces that are nearly
 at right angles, on a 300 ppi scanned page, the addition
 of 1000 pixels on each side is usually sufficient.
 (4) This is here for pedagogical reasons.  It is about 3x faster
 on 1 bpp images than pixAffineSampled(), but the results
 on text are much inferior.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="ptad">3 pts of final coordinate space</param>
	<param name="ptas">3 pts of initial coordinate space</param>
	<param name="bw">pixels of additional border width during computation</param>
	<param name="bh">pixels of additional border height during computation</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.createMatrix2dTranslate(System.Single,System.Single)">
	<summary>
 Notes
 (1) The translation is equivalent to
 v' = Av
 where v and v' are 1x3 column vectors in the form
 v = [x, y, 1]^ ^ denotes transpose
 and the affine translation matrix is
 A = [ 1   0   tx
 0   1   ty
 0   0 1  ]
 (2) We consider translation as with respect to a fixed origin.
 In a clipping operation, the origin moves and the points
 are fixed, and you use (-tx, -ty) where (tx, ty) is the
 translation vector of the origin.
 </summary>
	<remarks>
	</remarks>
	<param name="transx">x component of translation wrt. the origin</param>
	<param name="transy">y component of translation wrt. the origin</param>
	<returns>3x3 transform matrix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.createMatrix2dScale(System.Single,System.Single)">
	<summary>
 Notes
 (1) The scaling is equivalent to
 v' = Av
 where v and v' are 1x3 column vectors in the form
 v = [x, y, 1]^ ^ denotes transpose
 and the affine scaling matrix is
 A = [ sx  0 0
 0   sy   0
 0   0 1  ]
 (2) We consider scaling as with respect to a fixed origin.
 In other words, the origin is the only point that doesn't
 move in the scaling transform.
 </summary>
	<remarks>
	</remarks>
	<param name="scalex">horizontal scale factor</param>
	<param name="scaley">vertical scale factor</param>
	<returns>3x3 transform matrix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.createMatrix2dRotate(System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) The rotation is equivalent to
 v' = Av
 where v and v' are 1x3 column vectors in the form
 v = [x, y, 1]^ ^ denotes transpose
 and the affine rotation matrix is
 A = [ cosa   -sina xc1-cosa + ycsina
 sina cosa yc1-cosa - xcsina
 0 0  1   ]
 If the rotation is about the origin, xc, yc) = (0, 0 and
 this simplifies to
 A = [ cosa   -sina 0
 sina cosa 0
 0 0  1 ]
 These relations follow from the following equations, which
 you can convince yourself are correct as follows.  Draw a
 circle centered on xc,yc) and passing through (x,y), with
 (x',y') on the arc at an angle 'a' clockwise from (x,y).
 [ Hint cosa + b = cosa  cosb - sina  sinb
 sina + b = sina  cosb + cosa  sinb ]
 x' - xc =  x - xc)  cosa - (y - yc  sina
 y' - yc =  x - xc)  sina + (y - yc  cosa
 </summary>
	<remarks>
	</remarks>
	<param name="xc">location of center of rotation</param>
	<param name="yc">location of center of rotation</param>
	<param name="angle">rotation in radians; clockwise is positive</param>
	<returns>3x3 transform matrix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaTranslate(LeptonicaSharp.Pta,System.Single,System.Single)">
	<summary>
 Notes
 (1) See createMatrix2dTranslate() for details of transform.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">for initial points</param>
	<param name="transx">x component of translation wrt. the origin</param>
	<param name="transy">y component of translation wrt. the origin</param>
	<returns>ptad  translated points, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaScale(LeptonicaSharp.Pta,System.Single,System.Single)">
	<summary>
 Notes
 (1) See createMatrix2dScale() for details of transform.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">for initial points</param>
	<param name="scalex">horizontal scale factor</param>
	<param name="scaley">vertical scale factor</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaRotate(LeptonicaSharp.Pta,System.Single,System.Single,System.Single)">
	<summary>
 Notes;
 (1) See createMatrix2dScale() for details of transform.
 (2) This transform can be thought of as composed of the
 sum of two parts
 a) an (x,y)-dependent rotation about the origin
 xr = x  cosa - y  sina
 yr = x  sina + y  cosa
 b) an (x,y)-independent translation that depends on the
 rotation center and the angle
 xt = xc - xc  cosa + yc  sina
 yt = yc - xc  sina - yc  cosa
 The translation part (xt,yt) is equal to the difference
 between the center (xc,yc) and the location of the
 center after it is rotated about the origin.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">for initial points</param>
	<param name="xc">location of center of rotation</param>
	<param name="yc">location of center of rotation</param>
	<param name="angle">rotation in radians; clockwise is positive</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaTranslate(LeptonicaSharp.Boxa,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="transx">x component of translation wrt. the origin</param>
	<param name="transy">y component of translation wrt. the origin</param>
	<returns>boxad  translated boxas, or NULL on error Notes (1) See createMatrix2dTranslate() for details of transform.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaScale(LeptonicaSharp.Boxa,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="scalex">horizontal scale factor</param>
	<param name="scaley">vertical scale factor</param>
	<returns>boxad  scaled boxas, or NULL on error Notes (1) See createMatrix2dScale() for details of transform.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaRotate(LeptonicaSharp.Boxa,System.Single,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="xc">location of center of rotation</param>
	<param name="yc">location of center of rotation</param>
	<param name="angle">rotation in radians; clockwise is positive</param>
	<returns>boxad  scaled boxas, or NULL on error Notes (1) See createMatrix2dRotate() for details of transform.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaAffineTransform(LeptonicaSharp.Pta,System.Single[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas">for initial points</param>
	<param name="mat">3x3 transform matrix; canonical form</param>
	<returns>ptad  transformed points, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaAffineTransform(LeptonicaSharp.Boxa,System.Single[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="mat">3x3 transform matrix; canonical form</param>
	<returns>boxad  transformed boxas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_productMatVec(System.Single[],System.Single[],System.Single[],System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="mat">square matrix, as a 1-dimensional %size^2 array</param>
	<param name="vecs">input column vector of length %size</param>
	<param name="vecd">result column vector</param>
	<param name="size">matrix is %size x %size; vectors are length %size</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_productMat2(System.Single[],System.Single[],System.Single[],System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="mat1">square matrix, as a 1-dimensional size^2 array</param>
	<param name="mat2">square matrix, as a 1-dimensional size^2 array</param>
	<param name="matd">square matrix; product stored here</param>
	<param name="size">of matrices</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_productMat3(System.Single[],System.Single[],System.Single[],System.Single[],System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="mat1">square matrix, as a 1-dimensional size^2 array</param>
	<param name="mat2">square matrix, as a 1-dimensional size^2 array</param>
	<param name="mat3">square matrix, as a 1-dimensional size^2 array</param>
	<param name="matd">square matrix; product stored here</param>
	<param name="size">of matrices</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_productMat4(System.Single[],System.Single[],System.Single[],System.Single[],System.Single[],System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="mat1">square matrix, as a 1-dimensional size^2 array</param>
	<param name="mat2">square matrix, as a 1-dimensional size^2 array</param>
	<param name="mat3">square matrix, as a 1-dimensional size^2 array</param>
	<param name="mat4">square matrix, as a 1-dimensional size^2 array</param>
	<param name="matd">square matrix; product stored here</param>
	<param name="size">of matrices</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_getDataBit(System.Object,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<returns>val of the nth 1-bit pixel.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_setDataBit(System.Object,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_clearDataBit(System.Object,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_setDataBitVal(System.Object,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an accessor for a 1 bpp pix.
 (2) It is actually a little slower than using
 if (val == 0)
 l_ClearDataBit(line, n);
 else
 l_SetDataBit(line, n);
 </summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<param name="val">val to be inserted 0 or 1</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_getDataDibit(System.Object,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<returns>val of the nth 2-bit pixel.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_setDataDibit(System.Object,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<param name="val">val to be inserted 0 - 3</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_clearDataDibit(System.Object,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_getDataQbit(System.Object,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<returns>val of the nth 4-bit pixel.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_setDataQbit(System.Object,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<param name="val">val to be inserted 0 - 0xf</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_clearDataQbit(System.Object,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_getDataByte(System.Object,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<returns>value of the n-th byte pixel</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_setDataByte(System.Object,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<param name="val">val to be inserted 0 - 0xff</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_getDataTwoBytes(System.Object,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<returns>value of the n-th 2-byte pixel</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_setDataTwoBytes(System.Object,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<param name="val">val to be inserted 0 - 0xffff</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_getDataFourBytes(System.Object,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<returns>value of the n-th 4-byte pixel</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_setDataFourBytes(System.Object,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of data line</param>
	<param name="n">pixel index</param>
	<param name="val">val to be inserted 0 - 0xffffffff</param>
</member><member name="M:LeptonicaSharp._AllFunctions.barcodeDispatchDecoder(System.String,LeptonicaSharp.Enumerations.L_BF,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="barstr">string of integers in set {1,2,3,4} of bar widths</param>
	<param name="format">L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>data string of decoded barcode data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.barcodeFormatIsSupported(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="format"></param>
	<returns>1 if format is one of those supported; 0 otherwise</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindBaselines(LeptonicaSharp.Pix,LeptonicaSharp.Pixa,LeptonicaSharp.Pta@)">
	<summary>
 Notes
 (1) Input binary image must have text lines already aligned
 horizontally.  This can be done by either rotating the
 image with pixDeskew(), or, if a projective transform
 is required, by doing pixDeskewLocal() first.
 (2) Input null for pta if you don't want this returned.
 The pta will come in pairs of points (left and right end
 of each baseline).
 (3) Caution this will not work properly on text with multiple
 columns, where the lines are not aligned between columns.
 If there are multiple columns, they should be extracted
 separately before finding the baselines.
 (4) This function constructs different types of output
 for baselines; namely, a set of raster line values and
 a set of end points of each baseline.
 (5) This function was designed to handle short and long text lines
 without using dangerous thresholds on the peak heights.  It does
 this by combining the differential signal with a morphological
 analysis of the locations of the text lines.  One can also
 combine this data to normalize the peak heights, by weighting
 the differential signal in the region of each baseline
 by the inverse of the width of the text line found there.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, 300 ppi</param>
	<param name="ppta">pairs of pts corresponding to approx. ends of each text line</param>
	<param name="pixadb">for debug output; use NULL to skip</param>
	<returns>na of baseline y values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDeskewLocal(LeptonicaSharp.Pix,System.Int32,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This function allows deskew of a page whose skew changes
 approximately linearly with vertical position.  It uses
 a projective transform that in effect does a differential
 shear about the LHS of the page, and makes all text lines
 horizontal.
 (2) The origin of the keystoning can be either a cheap document
 feeder that rotates the page as it is passed through, or a
 camera image taken from either the left or right side
 of the vertical.
 (3) The image transformation is a projective warping,
 not a rotation.  Apart from this function, the text lines
 must be properly aligned vertically with respect to each
 other.  This can be done by pre-processing the page; e.g.,
 by rotating or horizontally shearing it.
 Typically, this can be achieved by vertically aligning
 the page edge.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="nslices">the number of horizontal overlapping slices; must be larger than 1 and not exceed 20; use 0 for default</param>
	<param name="redsweep">sweep reduction factor 1, 2, 4 or 8; use 0 for default value</param>
	<param name="redsearch">search reduction factor 1, 2, 4 or 8, and not larger than redsweep; use 0 for default value</param>
	<param name="sweeprange">half the full range, assumed about 0; in degrees; use 0.0 for default value</param>
	<param name="sweepdelta">angle increment of sweep; in degrees; use 0.0 for default value</param>
	<param name="minbsdelta">min binary search increment angle; in degrees; use 0.0 for default value</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetLocalSkewTransform(LeptonicaSharp.Pix,System.Int32,System.Single,System.Single,System.Single,LeptonicaSharp.Pta@,LeptonicaSharp.Pta@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates two pairs of points in the src, each pair
 corresponding to a pair of points that would lie along
 the same raster line in a transformed (dewarped) image.
 (2) The sets of 4 src and 4 dest points returned by this function
 can then be used, in a projective or bilinear transform,
 to remove keystoning in the src.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="nslices">the number of horizontal overlapping slices; must be larger than 1 and not exceed 20; use 0 for default</param>
	<param name="redsweep">sweep reduction factor 1, 2, 4 or 8; use 0 for default value</param>
	<param name="redsearch">search reduction factor 1, 2, 4 or 8, and not larger than redsweep; use 0 for default value</param>
	<param name="sweeprange">half the full range, assumed about 0; in degrees; use 0.0 for default value</param>
	<param name="sweepdelta">angle increment of sweep; in degrees; use 0.0 for default value</param>
	<param name="minbsdelta">min binary search increment angle; in degrees; use 0.0 for default value</param>
	<param name="pptas">4 points in the source</param>
	<param name="pptad">the corresponding 4 pts in the dest</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetLocalSkewAngles(LeptonicaSharp.Pix,System.Int32,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Single[]@,System.Single[]@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) The local skew is measured in a set of overlapping strips.
 We then do a least square linear fit parameters to get
 the slope and intercept parameters a and b in
 skew-angle = a  y + b  (degrees)
 for the local skew as a function of raster line y.
 This is then used to make naskew, which can be interpreted
 as the computed skew angle (in degrees) at the left edge
 of each raster line.
 (2) naskew can then be used to find the baselines of text, because
 each text line has a baseline that should intersect
 the left edge of the image with the angle given by this
 array, evaluated at the raster line of intersection.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="nslices">the number of horizontal overlapping slices; must be larger than 1 and not exceed 20; 0 for default</param>
	<param name="redsweep">sweep reduction factor 1, 2, 4 or 8; use 0 for default value</param>
	<param name="redsearch">search reduction factor 1, 2, 4 or 8, and not larger than redsweep; use 0 for default value</param>
	<param name="sweeprange">half the full range, assumed about 0; in degrees; use 0.0 for default value</param>
	<param name="sweepdelta">angle increment of sweep; in degrees; use 0.0 for default value</param>
	<param name="minbsdelta">min binary search increment angle; in degrees; use 0.0 for default value</param>
	<param name="pa">slope of skew as fctn of y</param>
	<param name="pb">intercept at y=0 of skew as fctn of y</param>
	<param name="debug">1 for generating plot of skew angle vs. y; 0 otherwise</param>
	<returns>naskew, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bbufferCreate(System.Byte[],System.Int32)">
	<summary>
 Notes
 (1) If a buffer address is given, you should read all the data in.
 (2) Allocates a bbuffer with associated byte array of
 the given size.  If a buffer address is given,
 it then reads the number of bytes into the byte array.
 </summary>
	<remarks>
	</remarks>
	<param name="indata">address in memory [optional]</param>
	<param name="nalloc">size of byte array to be alloc'd 0 for default</param>
	<returns>bbuffer, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bbufferDestroy(LeptonicaSharp.L_ByteBuffer@)">
	<summary>
 Notes
 (1) Destroys the byte array in the bbuffer and then the bbuffer;
 then nulls the contents of the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pbb">buffer to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.bbufferDestroyAndSaveData(LeptonicaSharp.L_ByteBuffer@,System.UInt32@)">
	<summary>
 Notes
 (1) Copies data to newly allocated array; then destroys the bbuffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pbb">buffer to be nulled</param>
	<param name="pnbytes">number of bytes saved in array</param>
	<returns>barray newly allocated array of data</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bbufferRead(LeptonicaSharp.L_ByteBuffer,System.Byte[],System.Int32)">
	<summary>
 Notes
 (1) For a read after write, first remove the written
 bytes by shifting the unwritten bytes in the array,
 then check if there is enough room to add the new bytes.
 If not, realloc with bbufferExpandArray(), resulting
 in a second writing of the unwritten bytes.  While less
 efficient, this is simpler than making a special case
 of reallocNew().
 </summary>
	<remarks>
	</remarks>
	<param name="bb">bbuffer</param>
	<param name="src">source memory buffer from which bytes are read</param>
	<param name="nbytes">bytes to be read</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bbufferReadStream(LeptonicaSharp.L_ByteBuffer,LeptonicaSharp.FILE,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bb">bbuffer</param>
	<param name="fp">source stream from which bytes are read</param>
	<param name="nbytes">bytes to be read</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bbufferExtendArray(LeptonicaSharp.L_ByteBuffer,System.Int32)">
	<summary>
 Notes
 (1) reallocNew() copies all bb-GTnalloc bytes, even though
 only bb-GTn are data.
 </summary>
	<remarks>
	</remarks>
	<param name="bb">bbuffer</param>
	<param name="nbytes">number of bytes to extend array size</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bbufferWrite(LeptonicaSharp.L_ByteBuffer,System.Byte[],System.UInt32,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bb">bbuffer</param>
	<param name="dest">dest memory buffer to which bytes are written</param>
	<param name="nbytes">bytes requested to be written</param>
	<param name="pnout">bytes actually written</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bbufferWriteStream(LeptonicaSharp.L_ByteBuffer,LeptonicaSharp.FILE,System.UInt32,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bb">bbuffer</param>
	<param name="fp">dest stream to which bytes are written</param>
	<param name="nbytes">bytes requested to be written</param>
	<param name="pnout">bytes actually written</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBilateral(LeptonicaSharp.Pix,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This performs a relatively fast, separable bilateral
 filtering operation.  The time is proportional to ncomps
 and varies inversely approximately as the cube of the
 reduction factor.  See bilateral.h for algorithm details.
 (2) We impose minimum values for range_stdev and ncomps to
 avoid nasty artifacts when either are too small.  We also
 impose a constraint on their product
 ncomps  range_stdev GT= 100.
 So for values of range_stdev GT= 25, ncomps can be as small as 4.
 Here is a qualitative, intuitive explanation for this constraint.
 Call the difference in k values between the J(k) == 'delta', where
 'delta' ~ 200 / ncomps
 Then this constraint is roughly equivalent to the condition
 'delta' LT 2  range_stdev
 Note that at an intensity difference of (2  range_stdev), the
 range part of the kernel reduces the effect by the factor 0.14.
 This constraint requires that we have a sufficient number of
 PCBs (i.e, a small enough 'delta'), so that for any value of
 image intensity I, there exists a k (and a PCB, J(k), such that
 |I - k| LT range_stdev
 Any fewer PCBs and we don't have enough to support this condition.
 (3) The upper limit of 30 on ncomps is imposed because the
 gain in accuracy is not worth the extra computation.
 (4) The size of the gaussian kernel is twice the spatial_stdev
 on each side of the origin.  The minimum value of
 spatial_stdev, 0.5, is required to have a finite sized
 spatial kernel.  In practice, a much larger value is used.
 (5) Computation of the intermediate images goes inversely
 as the cube of the reduction factor.  If you can use a
 reduction of 2 or 4, it is well-advised.
 (6) The range kernel is defined over the absolute value of pixel
 grayscale differences, and hence must have size 256 x 1.
 Values in the array represent the multiplying weight
 depending on the absolute gray value difference between
 the source pixel and the neighboring pixel, and should
 be monotonically decreasing.
 (7) Interesting observation.  Run this on prog/fish24.jpg, with
 range_stdev = 60, ncomps = 6, and spatial_dev = {10, 30, 50}.
 As spatial_dev gets larger, we get the counter-intuitive
 result that the body of the red fish becomes less blurry.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb, no colormap</param>
	<param name="spatial_stdev">of gaussian kernel; in pixels, GT 0.5</param>
	<param name="range_stdev">of gaussian range kernel; GT 5.0; typ. 50.0</param>
	<param name="ncomps">number of intermediate sums J(k,x); in [4 ... 30]</param>
	<param name="reduction">1, 2 or 4</param>
	<returns>pixd bilateral filtered image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBilateralGray(LeptonicaSharp.Pix,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixBilateral() for constraints on the input parameters.
 (2) See pixBilateral() for algorithm details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray</param>
	<param name="spatial_stdev">of gaussian kernel; in pixels, GT 0.5</param>
	<param name="range_stdev">of gaussian range kernel; GT 5.0; typ. 50.0</param>
	<param name="ncomps">number of intermediate sums J(k,x); in [4 ... 30]</param>
	<param name="reduction">1, 2 or 4</param>
	<returns>pixd 8 bpp bilateral filtered image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBilateralExact(LeptonicaSharp.Pix,LeptonicaSharp.L_Kernel,LeptonicaSharp.L_Kernel)">
	<summary>
 Notes
 (1) The spatial_kel is a conventional smoothing kernel, typically a
 2-d Gaussian kernel or other block kernel.  It can be either
 normalized or not, but must be everywhere positive.
 (2) The range_kel is defined over the absolute value of pixel
 grayscale differences, and hence must have size 256 x 1.
 Values in the array represent the multiplying weight for each
 gray value difference between the target pixel and center of the
 kernel, and should be monotonically decreasing.
 (3) If range_kel == NULL, a constant weight is applied regardless
 of the range value difference.  This degenerates to a regular
 pixConvolve() with a normalized kernel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb</param>
	<param name="spatial_kel">gaussian kernel</param>
	<param name="range_kel">256 x 1, monotonically decreasing</param>
	<returns>pixd 8 bpp bilateral filtered image</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBilateralGrayExact(LeptonicaSharp.Pix,LeptonicaSharp.L_Kernel,LeptonicaSharp.L_Kernel)">
	<summary>
 Notes
 (1) See pixBilateralExact().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray</param>
	<param name="spatial_kel">gaussian kernel</param>
	<param name="range_kel">256 x 1, monotonically decreasing</param>
	<returns>pixd 8 bpp bilateral filtered image</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlockBilateralExact(LeptonicaSharp.Pix,System.Single,System.Single)">
	<summary>
 Notes
 (1) See pixBilateralExact().  This provides an interface using
 the standard deviations of the spatial and range filters.
 (2) The convolution window halfwidth is 2  spatial_stdev,
 and the square filter size is 4  spatial_stdev + 1.
 The kernel captures 95% of total energy.  This is compensated
 by normalization.
 (3) The range_stdev is analogous to spatial_halfwidth in the
 grayscale domain [0...255], and determines how much damping of the
 smoothing operation is applied across edges.  The larger this
 value is, the smaller the damping.  The smaller the value, the
 more edge details are preserved.  These approximations are useful
 for deciding the appropriate cutoff.
 kernel[1  stdev] ~= 0.6   kernel[0]
 kernel[2  stdev] ~= 0.14  kernel[0]
 kernel[3  stdev] ~= 0.01  kernel[0]
 If range_stdev is infinite there is no damping, and this
 becomes a conventional gaussian smoothing.
 This value does not affect the run time.
 (4) If range_stdev is negative or zero, the range kernel is
 ignored and this degenerates to a straight gaussian convolution.
 (5) This is very slow for large spatial filters.  The time
 on a 3GHz pentium is roughly
 T = 1.2  10^-8  (A  sh^2)  sec
 where A = # of pixels, sh = spatial halfwidth of filter.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb</param>
	<param name="spatial_stdev">GT 0.0</param>
	<param name="range_stdev">GT 0.0</param>
	<returns>pixd 8 bpp or 32 bpp bilateral filtered image</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeRangeKernel(System.Single)">
	<summary>
 Notes
 (1) Creates a one-sided Gaussian kernel with the given
 standard deviation.  At grayscale difference of one stdev,
 the kernel falls to 0.6, and to 0.01 at three stdev.
 (2) A typical input number might be 20.  Then pixels whose
 value differs by 60 from the center pixel have their
 weight in the convolution reduced by a factor of about 0.01.
 </summary>
	<remarks>
	</remarks>
	<param name="range_stdev">GT 0</param>
	<returns>kel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBilinearSampledPta(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary.
 (2) Retains colormap, which you can do for a sampled transform..
 (3) No 3 of the 4 points may be collinear.
 (4) For 8 and 32 bpp pix, better quality is obtained by the
 somewhat slower pixBilinearPta().  See that
 function for relative timings between sampled and interpolated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBilinearSampled(LeptonicaSharp.Pix,System.Single[],LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary.
 (2) Retains colormap, which you can do for a sampled transform..
 (3) For 8 or 32 bpp, much better quality is obtained by the
 somewhat slower pixBilinear().  See that function
 for relative timings between sampled and interpolated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="vc">vector of 8 coefficients for bilinear transformation</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBilinearPta(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary
 (2) Removes any existing colormap, if necessary, before transforming
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBilinear(LeptonicaSharp.Pix,System.Single[],LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary
 (2) Removes any existing colormap, if necessary, before transforming
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="vc">vector of 8 coefficients for bilinear transformation</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBilinearPtaColor(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBilinearColor(LeptonicaSharp.Pix,System.Single[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="vc">vector of 8 coefficients for bilinear transformation</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBilinearPtaGray(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBilinearGray(LeptonicaSharp.Pix,System.Single[],System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="vc">vector of 8 coefficients for bilinear transformation</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBilinearPtaWithAlpha(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.Single,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The alpha channel is transformed separately from pixs,
 and aligns with it, being fully transparent outside the
 boundary of the transformed pixs.  For pixels that are fully
 transparent, a blending function like pixBlendWithGrayMask()
 will give zero weight to corresponding pixels in pixs.
 (2) If pixg is NULL, it is generated as an alpha layer that is
 partially opaque, using %fract.  Otherwise, it is cropped
 to pixs if required and %fract is ignored.  The alpha channel
 in pixs is never used.
 (3) Colormaps are removed.
 (4) When pixs is transformed, it doesn't matter what color is brought
 in because the alpha channel will be transparent (0) there.
 (5) To avoid losing source pixels in the destination, it may be
 necessary to add a border to the source pix before doing
 the bilinear transformation.  This can be any non-negative number.
 (6) The input %ptad and %ptas are in a coordinate space before
 the border is added.  Internally, we compensate for this
 before doing the bilinear transform on the image after
 the border is added.
 (7) The default setting for the border values in the alpha channel
 is 0 (transparent) for the outermost ring of pixels and
 (0.5  fract  255) for the second ring.  When blended over
 a second image, this
 (a) shrinks the visible image to make a clean overlap edge
 with an image below, and
 (b) softens the edges by weakening the aliasing there.
 Use l_setAlphaMaskBorder() to change these values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="pixg">8 bpp, can be null</param>
	<param name="fract">between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	<param name="border">of pixels added to capture transformed source pixels</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getBilinearXformCoeffs(LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.Collections.Generic.List{System.Single[]}@)">
	<summary>
 We have a set of 8 equations, describing the bilinear
 transformation that takes 4 points ptas into 4 other
 points ptad.  These equations are
 x1' = c[0]x1 + c[1]y1 + c[2]x1y1 + c[3]
 y1' = c[4]x1 + c[5]y1 + c[6]x1y1 + c[7]
 x2' = c[0]x2 + c[1]y2 + c[2]x2y2 + c[3]
 y2' = c[4]x2 + c[5]y2 + c[6]x2y2 + c[7]
 x3' = c[0]x3 + c[1]y3 + c[2]x3y3 + c[3]
 y3' = c[4]x3 + c[5]y3 + c[6]x3y3 + c[7]
 x4' = c[0]x4 + c[1]y4 + c[2]x4y4 + c[3]
 y4' = c[4]x4 + c[5]y4 + c[6]x4y4 + c[7]
 This can be represented as
 AC = B
 where B and C are column vectors
 B = [ x1' y1' x2' y2' x3' y3' x4' y4' ]
 C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] c[7] ]
 and A is the 8x8 matrix
 x1   y1   x1y1   1   0 0   0  0
 0 0  0  0   x1   y1   x1y1   1
 x2   y2   x2y2   1   0 0   0  0
 0 0  0  0   x2   y2   x2y2   1
 x3   y3   x3y3   1   0 0   0  0
 0 0  0  0   x3   y3   x3y3   1
 x4   y4   x4y4   1   0 0   0  0
 0 0  0  0   x4   y4   x4y4   1
 These eight equations are solved here for the coefficients C.
 These eight coefficients can then be used to find the mapping
 x,y) --GT (x',y'
 x' = c[0]x + c[1]y + c[2]xy + c[3]
 y' = c[4]x + c[5]y + c[6]xy + c[7]
 that are implemented in bilinearXformSampledPt and
 bilinearXFormPt.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">source 4 points; unprimed</param>
	<param name="ptad">transformed 4 points; primed</param>
	<param name="pvc">vector of coefficients of transform</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bilinearXformSampledPt(System.Single[],System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This finds the nearest pixel coordinates of the transformed point.
 (2) It does not check ptrs for returned data!
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 8 coefficients</param>
	<param name="x">initial point</param>
	<param name="y">initial point</param>
	<param name="pxp">transformed point</param>
	<param name="pyp">transformed point</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bilinearXformPt(System.Single[],System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This computes the floating point location of the transformed point.
 (2) It does not check ptrs for returned data!
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 8 coefficients</param>
	<param name="x">initial point</param>
	<param name="y">initial point</param>
	<param name="pxp">transformed point</param>
	<param name="pyp">transformed point</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOtsuAdaptiveThreshold(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) The Otsu method finds a single global threshold for an image.
 This function allows a locally adapted threshold to be
 found for each tile into which the image is broken up.
 (2) The array of threshold values, one for each tile, constitutes
 a highly downscaled image.  This array is optionally
 smoothed using a convolution.  The full width and height of the
 convolution kernel are (2  %smoothx + 1) and (2  %smoothy + 1).
 (3) The minimum tile dimension allowed is 16.  If such small
 tiles are used, it is recommended to use smoothing, because
 without smoothing, each small tile determines the splitting
 threshold independently.  A tile that is entirely in the
 image bg will then hallucinate fg, resulting in a very noisy
 binarization.  The smoothing should be large enough that no
 tile is only influenced by one type (fg or bg) of pixels,
 because it will force a split of its pixels.
 (4) To get a single global threshold for the entire image, use
 input values of %sx and %sy that are larger than the image.
 For this situation, the smoothing parameters are ignored.
 (5) The threshold values partition the image pixels into two classes
 one whose values are less than the threshold and another
 whose values are greater than or equal to the threshold.
 This is the same use of 'threshold' as in pixThresholdToBinary().
 (6) The scorefract is the fraction of the maximum Otsu score, which
 is used to determine the range over which the histogram minimum
 is searched.  See numaSplitDistribution() for details on the
 underlying method of choosing a threshold.
 (7) This uses enables a modified version of the Otsu criterion for
 splitting the distribution of pixels in each tile into a
 fg and bg part.  The modification consists of searching for
 a minimum in the histogram over a range of pixel values where
 the Otsu score is within a defined fraction, %scorefract,
 of the max score.  To get the original Otsu algorithm, set
 %scorefract == 0.
 (8) N.B. This method is NOT recommended for images with weak text
 and significant background noise, such as bleedthrough, because
 of the problem noted in (3) above for tiling.  Use Sauvola.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="sx">desired tile dimensions; actual size may vary</param>
	<param name="sy">desired tile dimensions; actual size may vary</param>
	<param name="smoothx">half-width of convolution kernel applied to threshold array use 0 for no smoothing</param>
	<param name="smoothy">half-width of convolution kernel applied to threshold array use 0 for no smoothing</param>
	<param name="scorefract">fraction of the max Otsu score; typ. 0.1; use 0.0 for standard Otsu</param>
	<param name="ppixth">array of threshold values found for each tile</param>
	<param name="ppixd">thresholded input pixs, based on the threshold array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOtsuThreshOnBackgroundNorm(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,LeptonicaSharp.Pix,System.Int32@)">
	<summary>
 Notes
 (1) This does background normalization followed by Otsu
 thresholding.  Otsu binarization attempts to split the
 image into two roughly equal sets of pixels, and it does
 a very poor job when there are large amounts of dark
 background.  By doing a background normalization first,
 to get the background near 255, we remove this problem.
 Then we use a modified Otsu to estimate the best global
 threshold on the normalized image.
 (2) See pixBackgroundNorm() for meaning and typical values
 of input parameters.  For a start, you can try
 sx, sy = 10, 15
 thresh = 100
 mincount = 50
 bgval = 255
 smoothx, smoothy = 2
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="bgval">target bg val; typ. GT 128</param>
	<param name="smoothx">half-width of block convolution kernel width</param>
	<param name="smoothy">half-width of block convolution kernel height</param>
	<param name="scorefract">fraction of the max Otsu score; typ. 0.1</param>
	<param name="pthresh">threshold value that was used on the normalized image</param>
	<returns>pixd 1 bpp thresholded image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMaskedThreshOnBackgroundNorm(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,LeptonicaSharp.Pix,System.Int32@)">
	<summary>
 Notes
 (1) This begins with a standard background normalization.
 Additionally, there is a flexible background norm, that
 will adapt to a rapidly varying background, and this
 puts white pixels in the background near regions with
 significant foreground.  The white pixels are turned into
 a 1 bpp selection mask by binarization followed by dilation.
 Otsu thresholding is performed on the input image to get an
 estimate of the threshold in the non-mask regions.
 The background normalized image is thresholded with two
 different values, and the result is combined using
 the selection mask.
 (2) Note that the numbers 255 (for bgval target) and 190 (for
 thresholding on pixn) are tied together, and explicitly
 defined in this function.
 (3) See pixBackgroundNorm() for meaning and typical values
 of input parameters.  For a start, you can try
 sx, sy = 10, 15
 thresh = 100
 mincount = 50
 smoothx, smoothy = 2
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="pixim">1 bpp 'image' mask; can be null</param>
	<param name="sx">tile size in pixels</param>
	<param name="sy">tile size in pixels</param>
	<param name="thresh">threshold for determining foreground</param>
	<param name="mincount">min threshold on counts in a tile</param>
	<param name="smoothx">half-width of block convolution kernel width</param>
	<param name="smoothy">half-width of block convolution kernel height</param>
	<param name="scorefract">fraction of the max Otsu score; typ. ~ 0.1</param>
	<param name="pthresh">threshold value that was used on the normalized image</param>
	<returns>pixd 1 bpp thresholded image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSauvolaBinarizeTiled(LeptonicaSharp.Pix,System.Int32,System.Single,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) The window width and height are 2  %whsize + 1.  The minimum
 value for %whsize is 2; typically it is GT= 7..
 (2) For nx == ny == 1, this defaults to pixSauvolaBinarize().
 (3) Why a tiled version?
 (a) Because the mean value accumulator is a uint32, overflow
 can occur for an image with more than 16M pixels.
 (b) The mean value accumulator array for 16M pixels is 64 MB.
 The mean square accumulator array for 16M pixels is 128 MB.
 Using tiles reduces the size of these arrays.
 (c) Each tile can be processed independently, in parallel,
 on a multicore processor.
 (4) The Sauvola threshold is determined from the formula
 t = m  (1 - k  (1 - s / 128))
 See pixSauvolaBinarize() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, not colormapped</param>
	<param name="whsize">window half-width for measuring local statistics</param>
	<param name="factor">factor for reducing threshold due to variance; GT= 0</param>
	<param name="nx">subdivision into tiles; GT= 1</param>
	<param name="ny">subdivision into tiles; GT= 1</param>
	<param name="ppixth">Sauvola threshold values</param>
	<param name="ppixd">thresholded image</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSauvolaBinarize(LeptonicaSharp.Pix,System.Int32,System.Single,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) The window width and height are 2  %whsize + 1.  The minimum
 value for %whsize is 2; typically it is GT= 7..
 (2) The local statistics, measured over the window, are the
 average and standard deviation.
 (3) The measurements of the mean and standard deviation are
 performed inside a border of (%whsize + 1) pixels.  If pixs does
 not have these added border pixels, use %addborder = 1 to add
 it here; otherwise use %addborder = 0.
 (4) The Sauvola threshold is determined from the formula
 t = m  (1 - k  (1 - s / 128))
 where
 t = local threshold
 m = local mean
 k = %factor (GT= 0)   [ typ. 0.35 ]
 s = local standard deviation, which is maximized at
 127.5 when half the samples are 0 and half are 255.
 (5) The basic idea of Niblack and Sauvola binarization is that
 the local threshold should be less than the median value,
 and the larger the variance, the closer to the median
 it should be chosen.  Typical values for k are between
 0.2 and 0.5.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="whsize">window half-width for measuring local statistics</param>
	<param name="factor">factor for reducing threshold due to variance; GT= 0</param>
	<param name="addborder">1 to add border of width (%whsize + 1) on all sides</param>
	<param name="ppixm">local mean values</param>
	<param name="ppixsd">local standard deviation values</param>
	<param name="ppixth">threshold values</param>
	<param name="ppixd">thresholded image</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSauvolaGetThreshold(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) The Sauvola threshold is determined from the formula
 t = m  (1 - k  (1 - s / 128))
 where
 t = local threshold
 m = local mean
 k = %factor (GT= 0)   [ typ. 0.35 ]
 s = local standard deviation, which is maximized at
 127.5 when half the samples are 0 and half are 255.
 (2) See pixSauvolaBinarize() for other details.
 (3) Important definitions and relations for computing averages
 v == pixel value
 E(p) == expected value of p == average of p over some pixel set
 S(v) == square of v == v  v
 mv == E(v) == expected pixel value == mean value
 ms == E(S(v)) == expected square of pixel values
 == mean square value
 var == variance == expected square of deviation from mean
 == E(S(v - mv)) = E(S(v) - 2  S(v  mv) + S(mv))
 = E(S(v)) - S(mv)
 = ms - mv  mv
 s == standard deviation = sqrt(var)
 So for evaluating the standard deviation in the Sauvola
 threshold, we take
 s = sqrt(ms - mv  mv)
 </summary>
	<remarks>
	</remarks>
	<param name="pixm">8 bpp grayscale; not colormapped</param>
	<param name="pixms">32 bpp</param>
	<param name="factor">factor for reducing threshold due to variance; GT= 0</param>
	<param name="ppixsd">local standard deviation</param>
	<returns>pixd 8 bpp, sauvola threshold values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixApplyLocalThreshold(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; not colormapped</param>
	<param name="pixth">8 bpp array of local thresholds</param>
	<param name="redfactor">...</param>
	<returns>pixd 1 bpp, thresholded image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixThresholdByConnComp(LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Int32,System.Single,System.Single,System.Int32,LeptonicaSharp.Pix,System.Int32@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This finds a global threshold based on connected components.
 Although slow, it is reasonable to use it in a situation where
 (a) the background in the image is relatively uniform, and
 (b) the result will be fed to an OCR program that accepts 1 bpp
 images and works best with easily segmented characters.
 The reason for (b) is that this selects a threshold with a
 minimum number of both broken characters and merged characters.
 (2) If the pix has color, it is converted to gray using the
 max component.
 (3) Input 0 to use default values for any of these inputs
 %start, %end, %incr, %thresh48, %threshdiff.
 (4) This approach can be understood as follows.  When the
 binarization threshold is varied, the numbers of c.c. identify
 four regimes
 (a) For low thresholds, text is broken into small pieces, and
 the number of c.c. is large, with the 4 c.c. significantly
 exceeding the 8 c.c.
 (b) As the threshold rises toward the optimum value, the text
 characters coalesce and there is very little difference
 between the numbers of 4 and 8 c.c, which both go
 through a minimum.
 (c) Above this, the image background gets noisy because some
 pixels are(thresholded to foreground, and the numbers
 of c.c. quickly increase, with the 4 c.c. significantly
 larger than the 8 c.c.
 (d) At even higher thresholds, the image background noise
 coalesces as it becomes mostly foreground, and the
 number of c.c. drops quickly.
 (5) If there is no global threshold that distinguishes foreground
 text from background (e.g., weak text over a background that
 has significant variation and/or bleedthrough), this returns 1,
 which the caller should check.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">depth GT 1, colormap OK</param>
	<param name="pixm">1 bpp mask giving region to ignore by setting pixels to white; use NULL if no mask</param>
	<param name="start">binarization threshold levels to test</param>
	<param name="incr">binarization threshold levels to test</param>
	<param name="thresh48">threshold on normalized difference between the numbers of 4 and 8 connected components</param>
	<param name="threshdiff">threshold on normalized difference between the number of 4 cc at successive iterations</param>
	<param name="pglobthresh">best global threshold; 0 if no threshold is found</param>
	<param name="ppixd">image thresholded to binary, or null if no threshold is found</param>
	<param name="debugflag">1 for plotted results</param>
	<returns>0 if OK, 1 on error or if no threshold is found</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExpandBinaryReplicate(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="xfact">integer scale factor for horiz. replicative expansion</param>
	<param name="yfact">integer scale factor for vertical replicative expansion</param>
	<returns>pixd scaled up, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExpandBinaryPower2(LeptonicaSharp.Pix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="factor">expansion factor 1, 2, 4, 8, 16</param>
	<returns>pixd expanded 1 bpp by replication, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReduceBinary2(LeptonicaSharp.Pix,System.Byte[])">
	<summary>
 Notes
 (1) After folding, the data is in bytes 0 and 2 of the word,
 and the bits in each byte are in the following order
 (with 0 being the leftmost originating pair and 7 being
 the rightmost originating pair)
 0 4 1 5 2 6 3 7
 These need to be permuted to
 0 1 2 3 4 5 6 7
 which is done with an 8-bit table generated by makeSubsampleTab2x().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="intab">; if null, a table is made here and destroyed before exit</param>
	<returns>pixd 2x subsampled, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReduceRankBinaryCascade(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This performs up to four cascaded 2x rank reductions.
 (2) Use level = 0 to truncate the cascade.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="level1">threshold, in the set {0, 1, 2, 3, 4}</param>
	<param name="level2">threshold, in the set {0, 1, 2, 3, 4}</param>
	<param name="level3">threshold, in the set {0, 1, 2, 3, 4}</param>
	<param name="level4">threshold, in the set {0, 1, 2, 3, 4}</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReduceRankBinary2(LeptonicaSharp.Pix,System.Int32,System.Byte[])">
	<summary>
 Notes
 (1) pixd is downscaled by 2x from pixs.
 (2) The rank threshold specifies the minimum number of ON
 pixels in each 2x2 region of pixs that are required to
 set the corresponding pixel ON in pixd.
 (3) Rank filtering is done to the UL corner of each 2x2 pixel block,
 using only logical operations.  Then these pixels are chosen
 in the 2x subsampling process, subsampled, as described
 above in pixReduceBinary2().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="level">rank threshold 1, 2, 3, 4</param>
	<param name="intab">; if null, a table is made here and destroyed before exit</param>
	<returns>pixd 1 bpp, 2x rank threshold reduced, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeSubsampleTab2x">
	<summary>
 This table permutes the bits in a byte, from
 0 4 1 5 2 6 3 7
 to
 0 1 2 3 4 5 6 7
 </summary>
	<remarks>
	</remarks>
	<returns>tab table of 256 permutations, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlend(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Single)">
	<summary>
 Notes
 (1) This is a simple top-level interface.  For more flexibility,
 call directly into pixBlendMask(), etc.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">blendee</param>
	<param name="pixs2">blender; typ. smaller</param>
	<param name="x">,y  origin [UL corner] of pixs2 relative to the origin of pixs1; can be LT 0</param>
	<param name="fract">blending fraction</param>
	<returns>pixd blended image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlendMask(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Single,LeptonicaSharp.Enumerations.L_BLEND,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
 (2) If pixs1 has a colormap, it is removed.
 (3) For inplace operation (pixs1 not cmapped), call it this way
 pixBlendMask(pixs1, pixs1, pixs2, ...)
 (4) For generating a new pixd
 pixd = pixBlendMask(NULL, pixs1, pixs2, ...)
 (5) Only call in-place if pixs1 does not have a colormap.
 (6) Invalid %fract defaults to 0.5 with a warning.
 Invalid %type defaults to L_BLEND_WITH_INVERSE with a warning.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs1 for in-place</param>
	<param name="pixs1">blendee, depth GT 1</param>
	<param name="pixs2">blender, 1 bpp; typ. smaller in size than pixs1</param>
	<param name="x">,y  origin [UL corner] of pixs2 relative to the origin of pixs1; can be LT 0</param>
	<param name="fract">blending fraction</param>
	<param name="type">L_BLEND_WITH_INVERSE, L_BLEND_TO_WHITE, L_BLEND_TO_BLACK</param>
	<returns>pixd if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlendGray(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Single,LeptonicaSharp.Enumerations.L_BLEND,System.Int32,System.UInt32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For inplace operation (pixs1 not cmapped), call it this way
 pixBlendGray(pixs1, pixs1, pixs2, ...)
 (2) For generating a new pixd
 pixd = pixBlendGray(NULL, pixs1, pixs2, ...)
 (3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
 (4) If pixs1 has a colormap, it is removed; otherwise, if pixs1
 has depth LT 8, it is unpacked to generate a 8 bpp pix.
 (5) If transparent = 0, the blending fraction (fract) is
 applied equally to all pixels.
 (6) If transparent = 1, all pixels of value transpix (typically
 either 0 or 0xff) in pixs2 are transparent in the blend.
 (7) After processing pixs1, it is either 8 bpp or 32 bpp
 ~ if 8 bpp, the fraction of pixs2 is mixed with pixs1.
 ~ if 32 bpp, each component of pixs1 is mixed with
 the same fraction of pixs2.
 (8) For L_BLEND_GRAY_WITH_INVERSE, the white values of the blendee
 (cval == 255 in the code below) result in a delta of 0.
 Thus, these pixels are intrinsically transparent!
 The "pivot" value of the src, at which no blending occurs, is
 128.  Compare with the adaptive pivot in pixBlendGrayAdapt().
 (9) Invalid %fract defaults to 0.5 with a warning.
 Invalid %type defaults to L_BLEND_GRAY with a warning.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs1 for in-place</param>
	<param name="pixs1">blendee, depth GT 1</param>
	<param name="pixs2">blender, any depth; typ. smaller in size than pixs1</param>
	<param name="x">,y  origin [UL corner] of pixs2 relative to the origin of pixs1; can be LT 0</param>
	<param name="fract">blending fraction</param>
	<param name="type">L_BLEND_GRAY, L_BLEND_GRAY_WITH_INVERSE</param>
	<param name="transparent">1 to use transparency; 0 otherwise</param>
	<param name="transpix">pixel grayval in pixs2 that is to be transparent</param>
	<returns>pixd if OK; pixs1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlendGrayInverse(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Single,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For inplace operation (pixs1 not cmapped), call it this way
 pixBlendGrayInverse(pixs1, pixs1, pixs2, ...)
 (2) For generating a new pixd
 pixd = pixBlendGrayInverse(NULL, pixs1, pixs2, ...)
 (3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
 (4) If pixs1 has a colormap, it is removed; otherwise if pixs1
 has depth LT 8, it is unpacked to generate a 8 bpp pix.
 (5) This is a no-nonsense blender.  It changes the src1 pixel except
 when the src1 pixel is midlevel gray.  Use fract == 1 for the most
 aggressive blending, where, if the gray pixel in pixs2 is 0,
 we get a complete inversion of the color of the src pixel in pixs1.
 (6) The basic logic is that each component transforms by
   d  --GT  c * d + (1 - c ) * (f * (1 - d) + d * (1 - f))
 where c is the blender pixel from pixs2,
 f is %fract,
 c and d are normalized to [0...1]
 This has the property that for f == 0 (no blend) or c == 1 (white)
 d  --GT  d
 For c == 0 (black) we get maximum inversion
 d  --GT  f  (1 - d) + d  (1 - f)   [inversion by fraction f]
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs1 for in-place</param>
	<param name="pixs1">blendee, depth GT 1</param>
	<param name="pixs2">blender, any depth; typ. smaller in size than pixs1</param>
	<param name="x">,y  origin [UL corner] of pixs2 relative to the origin of pixs1; can be LT 0</param>
	<param name="fract">blending fraction</param>
	<returns>pixd if OK; pixs1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlendColor(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Single,System.Int32,System.UInt32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For inplace operation (pixs1 must be 32 bpp), call it this way
 pixBlendColor(pixs1, pixs1, pixs2, ...)
 (2) For generating a new pixd
 pixd = pixBlendColor(NULL, pixs1, pixs2, ...)
 (3) If pixs2 is not 32 bpp rgb, it is converted.
 (4) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
 (5) If pixs1 has a colormap, it is removed to generate a 32 bpp pix.
 (6) If pixs1 has depth LT 32, it is unpacked to generate a 32 bpp pix.
 (7) If transparent = 0, the blending fraction (fract) is
 applied equally to all pixels.
 (8) If transparent = 1, all pixels of value transpix (typically
 either 0 or 0xffffff00) in pixs2 are transparent in the blend.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs1 for in-place</param>
	<param name="pixs1">blendee; depth GT 1</param>
	<param name="pixs2">blender, any depth;; typ. smaller in size than pixs1</param>
	<param name="x">,y  origin [UL corner] of pixs2 relative to the origin of pixs1</param>
	<param name="fract">blending fraction</param>
	<param name="transparent">1 to use transparency; 0 otherwise</param>
	<param name="transpix">pixel color in pixs2 that is to be transparent</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlendColorByChannel(LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,System.Int32@,System.Int32@,System.Single@,System.Single@,System.Single@,System.Int32@,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlendGrayAdapt(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Single,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For inplace operation (pixs1 not cmapped), call it this way
 pixBlendGrayAdapt(pixs1, pixs1, pixs2, ...)
 For generating a new pixd
 pixd = pixBlendGrayAdapt(NULL, pixs1, pixs2, ...)
 (2) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
 (3) If pixs1 has a colormap, it is removed.
 (4) If pixs1 has depth LT 8, it is unpacked to generate a 8 bpp pix.
 (5) This does a blend with inverse.  Whereas in pixGlendGray(), the
 zero blend point is where the blendee pixel is 128, here
 the zero blend point is found adaptively, with respect to the
 median of the blendee region.  If the median is LT 128,
 the zero blend point is found from
 median + shift.
 Otherwise, if the median GT= 128, the zero blend point is
 median - shift.
 The purpose of shifting the zero blend point away from the
 median is to prevent a situation in pixBlendGray() where
 the median is 128 and the blender is not visible.
 The default value of shift is 64.
 (6) After processing pixs1, it is either 8 bpp or 32 bpp
 ~ if 8 bpp, the fraction of pixs2 is mixed with pixs1.
 ~ if 32 bpp, each component of pixs1 is mixed with
 the same fraction of pixs2.
 (7) The darker the blender, the more it mixes with the blendee.
 A blender value of 0 has maximum mixing; a value of 255
 has no mixing and hence is transparent.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs1 for in-place</param>
	<param name="pixs1">blendee, depth GT 1</param>
	<param name="pixs2">blender, any depth; typ. smaller in size than pixs1</param>
	<param name="x">,y  origin [UL corner] of pixs2 relative to the origin of pixs1; can be LT 0</param>
	<param name="fract">blending fraction</param>
	<param name="shift">GT= 0 but LT= 128 shift of zero blend value from median source; use -1 for default value;</param>
	<returns>pixd if OK; pixs1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFadeWithGray(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_BLEND)">
	<summary>
 Notes
 (1) This function combines two pix aligned to the UL corner; they
 need not be the same size.
 (2) Each pixel in pixb is multiplied by 'factor' divided by 255, and
 clipped to the range [0 ... 1].  This gives the fade fraction
 to be applied to pixs.  Fade either to white (L_BLEND_TO_WHITE)
 or to black (L_BLEND_TO_BLACK).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped or 8 bpp or 32 bpp</param>
	<param name="pixb">8 bpp blender</param>
	<param name="factor">multiplicative factor to apply to blender value</param>
	<param name="type">L_BLEND_TO_WHITE, L_BLEND_TO_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlendHardLight(LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,System.Int32@,System.Int32@,System.Single@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlendCmap(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This function combines two colormaps, and replaces the pixels
 in pixs that have a specified color value with those in pixb.
 (2) sindex must be in the existing colormap; otherwise an
 error is returned.  In use, sindex will typically be the index
 for white (255, 255, 255).
 (3) Blender colors that already exist in the colormap are used;
 others are added.  If any blender colors cannot be
 stored in the colormap, an error is returned.
 (4) In the implementation, a mapping is generated from each
 original blender colormap index to the corresponding index
 in the expanded colormap for pixs.  Then for each pixel in
 pixs with value sindex, and which is covered by a blender pixel,
 the new index corresponding to the blender pixel is substituted
 for sindex.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp, with colormap</param>
	<param name="pixb">colormapped blender</param>
	<param name="x">UL corner of blender relative to pixs</param>
	<param name="y">UL corner of blender relative to pixs</param>
	<param name="sindex">colormap index of pixels in pixs to be changed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlendWithGrayMask(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The result is 8 bpp grayscale if both pixs1 and pixs2 are
 8 bpp gray.  Otherwise, the result is 32 bpp rgb.
 (2) pixg is an 8 bpp transparency image, where 0 is transparent
 and 255 is opaque.  It determines the transparency of pixs2
 when applied over pixs1.  It can be null if pixs2 is rgba,
 in which case we use the alpha component of pixs2.
 (3) If pixg exists, it need not be the same size as pixs2.
 However, we assume their UL corners are aligned with each other,
 and placed at the location (x, y) in pixs1.
 (4) The pixels in pixd are a combination of those in pixs1
 and pixs2, where the amount from pixs2 is proportional to
 the value of the pixel (p) in pixg, and the amount from pixs1
 is proportional to (255 - p).  Thus pixg is a transparency
 image (usually called an alpha blender) where each pixel
 can be associated with a pixel in pixs2, and determines
 the amount of the pixs2 pixel in the final result.
 For example, if pixg is all 0, pixs2 is transparent and
 the result in pixd is simply pixs1.
 (5) A typical use is for the pixs2/pixg combination to be
 a small watermark that is applied to pixs1.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">8 bpp gray, rgb, rgba or colormapped</param>
	<param name="pixs2">8 bpp gray, rgb, rgba or colormapped</param>
	<param name="pixg">8 bpp gray, for transparency of pixs2; can be null</param>
	<param name="x">UL corner of pixs2 and pixg with respect to pixs1</param>
	<param name="y">UL corner of pixs2 and pixg with respect to pixs1</param>
	<returns>pixd blended image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlendBackgroundToColor(LeptonicaSharp.Pix,LeptonicaSharp.Box,System.UInt32,System.Single,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This in effect replaces light background pixels in pixs
 by the input color.  It does it by alpha blending so that
 there are no visible artifacts from hard cutoffs.
 (2) If pixd == pixs, this is done in-place.
 (3) If box == NULL, this is performed on all of pixs.
 (4) The alpha component for blending is derived from pixs,
 by converting to grayscale and enhancing with a TRC.
 (5) The last three arguments specify the TRC operation.
 Suggested values are %gamma = 0.3, %minval = 50, %maxval = 200.
 To skip the TRC, use %gamma == 1, %minval = 0, %maxval = 255.
 See pixGammaTRC() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">or pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="box">region for blending; can be NULL)</param>
	<param name="color">32 bit color in 0xrrggbb00 format</param>
	<param name="gamma">args for grayscale TRC mapping</param>
	<param name="minval">args for grayscale TRC mapping</param>
	<param name="maxval">args for grayscale TRC mapping</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMultiplyByColor(LeptonicaSharp.Pix,LeptonicaSharp.Box,System.UInt32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This filters all pixels in the specified region by
 multiplying each component by the input color.
 This leaves black invariant and transforms white to the
 input color.
 (2) If pixd == pixs, this is done in-place.
 (3) If box == NULL, this is performed on all of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">or pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="box">region for filtering; can be NULL)</param>
	<param name="color">32 bit color in 0xrrggbb00 format</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAlphaBlendUniform(LeptonicaSharp.Pix,System.UInt32)">
	<summary>
 Notes
 (1) This is a convenience function that renders 32 bpp RGBA images
 (with an alpha channel) over a uniform background of
 value %color.  To render over a white background,
 use %color = 0xffffff00.  The result is an RGB image.
 (2) If pixs does not have an alpha channel, it returns a clone
 of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgba, with alpha</param>
	<param name="color">32 bit color in 0xrrggbb00 format</param>
	<returns>pixd 32 bpp rgb pixs blended over uniform color %color, a clone of pixs if no alpha, and NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddAlphaToBlend(LeptonicaSharp.Pix,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This is a simple alpha layer generator, where typically white has
 maximum transparency and black has minimum.
 (2) If %invert == 1, generate the same alpha layer but invert
 the input image photometrically.  This is useful for blending
 over dark images, where you want dark regions in pixs, such
 as text, to be lighter in the blended image.
 (3) The fade %fract gives the minimum transparency (i.e.,
 maximum opacity).  A small fraction is useful for adding
 a watermark to an image.
 (4) If pixs has a colormap, it is removed to rgb.
 (5) If pixs already has an alpha layer, it is overwritten.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="fract">fade fraction in the alpha component</param>
	<param name="invert">1 to photometrically invert pixs</param>
	<returns>pixd 32 bpp with alpha, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetAlphaOverWhite(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The generated alpha component is transparent over white
 (background) pixels in pixs, and quickly grades to opaque
 away from the transparent parts.  This is a cheap and
 dirty alpha generator.  The 2 pixel gradation is useful
 to blur the boundary between the transparent region
 (that will render entirely from a backing image) and
 the remainder which renders from pixs.
 (2) All alpha component bits in pixs are overwritten.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped or 32 bpp rgb; no alpha</param>
	<returns>pixd new pix with meaningful alpha component, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixLinearEdgeFade(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_scan_direction,LeptonicaSharp.Enumerations.L_BLEND,System.Single,System.Single)">
	<summary>
 Notes
 (1) In-place operation.
 (2) Maximum fading fraction %maxfade occurs at the edge of the image,
 and the fraction goes to 0 at the fractional distance %distfract
 from the edge.  %maxfade must be in [0, 1].
 (3) %distrfact must be in [0, 1], and typically it would be LT= 0.5.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp; no colormap</param>
	<param name="dir">L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
	<param name="fadeto">L_BLEND_TO_WHITE, L_BLEND_TO_BLACK</param>
	<param name="distfract">fraction of width or height over which fading occurs</param>
	<param name="maxfade">fraction of fading at the edge, LT= 1.0</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bmfCreate(System.Int32,System.String)">
	<summary>
 Notes
 (1) If %dir == null, this generates the font bitmaps from a
 compiled string.
 (2) Otherwise, this tries to read a pre-computed pixa file with the
 95 ascii chars in it.  If the file is not found, it then
 attempts to generate the pixa and associated baseline
 data from a tiff image containing all the characters.  If
 that fails, it uses the compiled string.
 </summary>
	<remarks>
	</remarks>
	<param name="dir">directory holding pixa of character set</param>
	<param name="fontsize">4, 6, 8, ... , 20</param>
	<returns>bmf holding the bitmap font and associated information</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bmfDestroy(LeptonicaSharp.L_Bmf@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pbmf">set to null</param>
</member><member name="M:LeptonicaSharp._AllFunctions.bmfGetPix(LeptonicaSharp.L_Bmf,System.Char)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bmf"></param>
	<param name="chr">should be one of the 95 supported printable bitmaps</param>
	<returns>pix clone of pix in bmf, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bmfGetWidth(LeptonicaSharp.L_Bmf,System.Char,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bmf"></param>
	<param name="chr">should be one of the 95 supported bitmaps</param>
	<param name="pw">character width; -1 if not printable</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bmfGetBaseline(LeptonicaSharp.L_Bmf,System.Char,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bmf"></param>
	<param name="chr">should be one of the 95 supported bitmaps</param>
	<param name="pbaseline">distance below UL corner of bitmap char</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaGetFont(System.String,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This reads a pre-computed pixa file with the 95 ascii chars.
 </summary>
	<remarks>
	</remarks>
	<param name="dir">directory holding pixa of character set</param>
	<param name="fontsize">4, 6, 8, ... , 20</param>
	<param name="pbl0">baseline of row 1</param>
	<param name="pbl1">baseline of row 2</param>
	<param name="pbl2">baseline of row 3</param>
	<returns>pixa of font bitmaps for 95 characters, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSaveFont(System.String,System.Int32,System.String)">
	<summary>
 Notes
 (1) This saves a font of a particular size.
 (2) If %dir == null, this generates the font bitmaps from a
 compiled string.
 (3) prog/genfonts calls this function for each of the
 nine font sizes, to generate all the font pixa files.
 </summary>
	<remarks>
	</remarks>
	<param name="indir">directory holding image of character set</param>
	<param name="outdir">directory into which the output pixa file will be written</param>
	<param name="fontsize">in pts, at 300 ppi</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadStreamBmp(LeptonicaSharp.FILE)">
	<summary>
 Notes
 (1) Here are references on the bmp file format
 http//en.wikipedia.org/wiki/BMP_file_format
 http//www.fortunecity.com/skyscraper/windows/364/bmpffrmt.html
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for read</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadMemBmp(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cdata">bmp data</param>
	<param name="size">number of bytes of bmp-formatted data</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamBmp(LeptonicaSharp.FILE,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix">all depths</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMemBmp(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) 2 bpp bmp files are not valid in the spec, and are
 written as 8 bpp.
 (2) pix with depth LT= 8 bpp are written with a colormap.
 16 bpp gray and 32 bpp rgb pix are written without a colormap.
 (3) The transparency component in an rgb pix is ignored.
 All 32 bpp pix have the bmp alpha component set to 255 (opaque).
 (4) The bmp colormap entries, RGBA_QUAD, are the same as
 the ones used for colormaps in leptonica.  This allows
 a simple memcpy for bmp output.
 </summary>
	<remarks>
	</remarks>
	<param name="pfdata">data of bmp formatted image</param>
	<param name="pfsize">size of returned data</param>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_bootnum_gen1">
	<summary>
 Call this way
 PIXA  pixa = l_bootnum_gen1();   (C)
 Pixa  pixa = l_bootnum_gen1();   (C++)
 </summary>
	<remarks>
	</remarks>
	<returns>pixa  of labeled digits</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_bootnum_gen2">
	<summary>
 Call this way
 PIXA  pixa = l_bootnum_gen2();   (C)
 Pixa  pixa = l_bootnum_gen2();   (C++)
 </summary>
	<remarks>
	</remarks>
	<returns>pixa  of labeled digits</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_bootnum_gen3">
	<summary>
 Call this way
 PIXA  pixa = l_bootnum_gen3();   (C)
 Pixa  pixa = l_bootnum_gen3();   (C++)
 </summary>
	<remarks>
	</remarks>
	<returns>pixa  of labeled digits</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxCreate(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This clips the box to the +quad.  If no part of the
 box is in the +quad, this returns NULL.
 (2) We allow you to make a box with w = 0 and/or h = 0.
 This does not represent a valid region, but it is useful
 as a placeholder in a boxa for which the index of the
 box in the boxa is important.  This is an atypical
 situation; usually you want to put only valid boxes with
 nonzero width and height in a boxa.  If you have a boxa
 with invalid boxes, the accessor boxaGetValidBox()
 will return NULL on each invalid box.
 (3) If you want to create only valid boxes, use boxCreateValid(),
 which returns NULL if either w or h is 0.
 </summary>
	<remarks>
	</remarks>
	<param name="x"></param>
	<param name="y"></param>
	<param name="w"></param>
	<param name="h"></param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxCreateValid(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This returns NULL if either w = 0 or h = 0.
 </summary>
	<remarks>
	</remarks>
	<param name="x"></param>
	<param name="y"></param>
	<param name="w"></param>
	<param name="h"></param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxCopy(LeptonicaSharp.Box)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<returns>copy of box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxClone(LeptonicaSharp.Box)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<returns>ptr to same box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxDestroy(LeptonicaSharp.Box@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the box.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pbox">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp._AllFunctions.boxGetGeometry(LeptonicaSharp.Box,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="px">each can be null</param>
	<param name="py">each can be null</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxSetGeometry(LeptonicaSharp.Box,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="x">use -1 to leave unchanged</param>
	<param name="y">use -1 to leave unchanged</param>
	<param name="w">use -1 to leave unchanged</param>
	<param name="h">use -1 to leave unchanged</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxGetSideLocations(LeptonicaSharp.Box,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) All returned values are within the box.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="pl">each can be null</param>
	<param name="pr">each can be null</param>
	<param name="pt">each can be null</param>
	<param name="pb">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxSetSideLocations(LeptonicaSharp.Box,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="l">use -1 to leave unchanged</param>
	<param name="r">use -1 to leave unchanged</param>
	<param name="t">use -1 to leave unchanged</param>
	<param name="b">use -1 to leave unchanged</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxGetRefcount(LeptonicaSharp.Box)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box">ptr to Box</param>
	<returns>refcount</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxChangeRefcount(LeptonicaSharp.Box,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box">ptr to box</param>
	<param name="delta">adjustment, usually -1 or 1</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxIsValid(LeptonicaSharp.Box,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="pvalid">1 if valid; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">initial number of ptrs</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaCopy(LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) See pix.h for description of the copyflag.
 (2) The copy-clone makes a new boxa that holds clones of each box.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="copyflag">L_COPY, L_CLONE, L_COPY_CLONE</param>
	<returns>new boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaDestroy(LeptonicaSharp.Boxa@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the boxa.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pboxa">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaAddBox(LeptonicaSharp.Boxa,LeptonicaSharp.Box,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="box">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaExtendArray(LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) Reallocs with doubled size of ptr array.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaExtendArrayToSize(LeptonicaSharp.Boxa,System.Int32)">
	<summary>
 Notes
 (1) If necessary, reallocs new boxa ptr array to %size.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="size">new size of boxa array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetCount(LeptonicaSharp.Boxa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<returns>count of all boxes; 0 if no boxes or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetValidCount(LeptonicaSharp.Boxa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<returns>count of valid boxes; 0 if no valid boxes or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetBox(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">to the index-th box</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetValidBox(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) This returns NULL for an invalid box in a boxa.
 For a box to be valid, both the width and height must be GT 0.
 (2) We allow invalid boxes, with w = 0 or h = 0, as placeholders
 in boxa for which the index of the box in the boxa is important.
 This is an atypical situation; usually you want to put only
 valid boxes in a boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">to the index-th box</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>box, or NULL if box is not valid or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaFindInvalidBoxes(LeptonicaSharp.Boxa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<returns>na   numa of invalid boxes; NULL if there are none or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetBoxGeometry(LeptonicaSharp.Boxa,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">to the index-th box</param>
	<param name="px">each can be null</param>
	<param name="py">each can be null</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaIsFull(LeptonicaSharp.Boxa,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pfull">1 if boxa is full</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaReplaceBox(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) In-place replacement of one box.
 (2) The previous box at that location, if any, is destroyed.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">to the index-th box</param>
	<param name="box">insert to replace existing one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaInsertBox(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This shifts box[i] --GT box[i + 1] for all i GT= index,
 and then inserts box as box[index].
 (2) To insert at the beginning of the array, set index = 0.
 (3) To append to the array, it's easier to use boxaAddBox().
 (4) This should not be used repeatedly to insert into large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">location in boxa to insert new value</param>
	<param name="box">new box to be inserted</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaRemoveBox(LeptonicaSharp.Boxa,System.Int32)">
	<summary>
 Notes
 (1) This removes box[index] and then shifts
 box[i] --GT box[i - 1] for all i GT index.
 (2) It should not be used repeatedly to remove boxes from
 large arrays, because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">of box to be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaRemoveBoxAndSave(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Box@)">
	<summary>
 Notes
 (1) This removes box[index] and then shifts
 box[i] --GT box[i - 1] for all i GT index.
 (2) It should not be used repeatedly to remove boxes from
 large arrays, because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="index">of box to be removed</param>
	<param name="pbox">removed box</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSaveValid(LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) This makes a copy/clone of each valid box.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="copyflag">L_COPY or L_CLONE</param>
	<returns>boxad if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaInitFull(LeptonicaSharp.Boxa,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This initializes a boxa by filling up the entire box ptr array
 with copies of %box.  If %box == NULL, use a placeholder box
 of zero size.  Any existing boxes are destroyed.
 After this opepration, the number of boxes is equal to
 the number of allocated ptrs.
 (2) Note that we use boxaReplaceBox() instead of boxaInsertBox().
 They both have the same effect when inserting into a NULL ptr
 in the boxa ptr array
 (3) Example usage.  This function is useful to prepare for a
 random insertion (or replacement) of boxes into a boxa.
 To randomly insert boxes into a boxa, up to some index "max"
 Boxa boxa = boxaCreate(max);
 boxaInitFull(boxa, NULL);
 If you want placeholder boxes of non-zero size
 Boxa boxa = boxaCreate(max);
 Box box = boxCreate(...);
 boxaInitFull(boxa, box);
 boxDestroy(box);
 If we have an existing boxa with a smaller ptr array, it can
 be reused for up to max boxes
 boxaExtendArrayToSize(boxa, max);
 boxaInitFull(boxa, NULL);
 The initialization allows the boxa to always be properly
 filled, even if all the boxes are not later replaced.
 If you want to know which boxes have been replaced,
 and you initialized with invalid zero-sized boxes,
 use boxaGetValidBox() to return NULL for the invalid boxes.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">typically empty</param>
	<param name="box">to be replicated into the entire ptr array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaClear(LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) This destroys all boxes in the boxa, setting the ptrs
 to null.  The number of allocated boxes, n, is set to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of boxa ptr array to be alloc'd; 0 for default</param>
	<returns>baa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaCopy(LeptonicaSharp.Boxaa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) L_COPY makes a copy of each boxa in baas.
 L_CLONE makes a clone of each boxa in baas.
 </summary>
	<remarks>
	</remarks>
	<param name="baas">input boxaa to be copied</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>baad new boxaa, composed of copies or clones of the boxa in baas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaDestroy(LeptonicaSharp.Boxaa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pbaa">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaAddBoxa(LeptonicaSharp.Boxaa,LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="ba">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaExtendArray(LeptonicaSharp.Boxaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaExtendArrayToSize(LeptonicaSharp.Boxaa,System.Int32)">
	<summary>
 Notes
 (1) If necessary, reallocs the boxa ptr array to %size.
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="size">new size of boxa array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaGetCount(LeptonicaSharp.Boxaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<returns>count number of boxa, or 0 if no boxa or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaGetBoxCount(LeptonicaSharp.Boxaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<returns>count number of boxes, or 0 if no boxes or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaGetBoxa(LeptonicaSharp.Boxaa,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="index">to the index-th boxa</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaGetBox(LeptonicaSharp.Boxaa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="iboxa">index into the boxa array in the boxaa</param>
	<param name="ibox">index into the box array in the boxa</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaInitFull(LeptonicaSharp.Boxaa,LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) This initializes a boxaa by filling up the entire boxa ptr array
 with copies of %boxa.  Any existing boxa are destroyed.
 After this operation, the number of boxa is equal to
 the number of allocated ptrs.
 (2) Note that we use boxaaReplaceBox() instead of boxaInsertBox().
 They both have the same effect when inserting into a NULL ptr
 in the boxa ptr array
 (3) Example usage.  This function is useful to prepare for a
 random insertion (or replacement) of boxa into a boxaa.
 To randomly insert boxa into a boxaa, up to some index "max"
 Boxaa baa = boxaaCreate(max);
 // initialize the boxa
 Boxa boxa = boxaCreate(...);
 ...  [optionally fix with boxes]
 boxaaInitFull(baa, boxa);
 A typical use is to initialize the array with empty boxa,
 and to replace only a subset that must be aligned with
 something else, such as a pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="baa">typically empty</param>
	<param name="boxa">to be replicated into the entire ptr array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaExtendWithInit(LeptonicaSharp.Boxaa,System.Int32,LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) This should be used on an existing boxaa that has been
 fully loaded with boxa.  It then extends the boxaa,
 loading all the additional ptrs with copies of boxa.
 Typically, boxa will be empty.
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="maxindex"></param>
	<param name="boxa">to be replicated into the extended ptr array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaReplaceBoxa(LeptonicaSharp.Boxaa,System.Int32,LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) Any existing boxa is destroyed, and the input one
 is inserted in its place.
 (2) If the index is invalid, return 1 (error)
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="index">to the index-th boxa</param>
	<param name="boxa">insert and replace any existing one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaInsertBoxa(LeptonicaSharp.Boxaa,System.Int32,LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) This shifts boxa[i] --GT boxa[i + 1] for all i GT= index,
 and then inserts boxa as boxa[index].
 (2) To insert at the beginning of the array, set index = 0.
 (3) To append to the array, it's easier to use boxaaAddBoxa().
 (4) This should not be used repeatedly to insert into large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="index">location in boxaa to insert new boxa</param>
	<param name="boxa">new boxa to be inserted</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaRemoveBoxa(LeptonicaSharp.Boxaa,System.Int32)">
	<summary>
 Notes
 (1) This removes boxa[index] and then shifts
 boxa[i] --GT boxa[i - 1] for all i GT index.
 (2) The removed boxaa is destroyed.
 (2) This should not be used repeatedly on large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="index">of the boxa to be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaAddBox(LeptonicaSharp.Boxaa,System.Int32,LeptonicaSharp.Box,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) Adds to an existing boxa only.
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="index">of boxa with boxaa</param>
	<param name="box">to be added</param>
	<param name="accessflag">L_INSERT, L_COPY or L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaReadFromFiles(System.String,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) The files must be serialized boxa files (e.g., .ba).
 If some files cannot be read, warnings are issued.
 (2) Use %substr to filter filenames in the directory.  If
 %substr == NULL, this takes all files.
 (3) After filtering, use %first and %nfiles to select
 a contiguous set of files, that have been lexically
 sorted in increasing order.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="first">0-based</param>
	<param name="nfiles">use 0 for everything from %first to the end</param>
	<returns>baa, or NULL on error or if no boxa files are found.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>boxaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>boxaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization of boxaa; in ascii</param>
	<param name="size">of data in bytes; can use strlen to get it</param>
	<returns>baa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaWrite(System.String,LeptonicaSharp.Boxaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="baa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.Boxaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="baa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.Boxaa)">
	<summary>
 Notes
 (1) Serializes a boxaa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized boxaa; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="baa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization of boxa; in ascii</param>
	<param name="size">of data in bytes; can use strlen to get it</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaWriteDebug(System.String,LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) Debug version, intended for use in the library when writing
 to files in a temp directory with names that are compiled in.
 This is used instead of boxaWrite() for all such library calls.
 (2) The global variable LeptDebugOK defaults to 0, and can be set
 or cleared by the function setLeptDebugOK().
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="boxa"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaWrite(System.String,LeptonicaSharp.Boxa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="boxa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.Boxa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="boxa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) Serializes a boxa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized boxa; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="boxa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxPrintStreamInfo(LeptonicaSharp.FILE,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This outputs debug info.  Use serialization functions to
 write to file if you want to read the data back.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="box"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxContains(LeptonicaSharp.Box,LeptonicaSharp.Box,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box1"></param>
	<param name="box2"></param>
	<param name="presult">1 if box2 is entirely contained within box1, and 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxIntersects(LeptonicaSharp.Box,LeptonicaSharp.Box,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box1"></param>
	<param name="box2"></param>
	<param name="presult">1 if any part of box2 is contained in box1, and 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaContainedInBox(LeptonicaSharp.Boxa,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) All boxes in boxa that are entirely outside box are removed.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="box">for containment</param>
	<returns>boxad boxa with all boxes in boxas that are entirely contained in box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaContainedInBoxCount(LeptonicaSharp.Boxa,LeptonicaSharp.Box,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="box">for selecting contained boxes in %boxa</param>
	<param name="pcount">number of boxes intersecting the box</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaContainedInBoxa(LeptonicaSharp.Boxa,LeptonicaSharp.Boxa,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa1"></param>
	<param name="boxa2"></param>
	<param name="pcontained">1 if every box in boxa2 is contained in some box in boxa1; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaIntersectsBox(LeptonicaSharp.Boxa,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) All boxes in boxa that intersect with box (i.e., are completely
 or partially contained in box) are retained.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="box">for intersecting</param>
	<returns>boxad boxa with all boxes in boxas that intersect box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaIntersectsBoxCount(LeptonicaSharp.Boxa,LeptonicaSharp.Box,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="box">for selecting intersecting boxes in %boxa</param>
	<param name="pcount">number of boxes intersecting the box</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaClipToBox(LeptonicaSharp.Boxa,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) All boxes in boxa not intersecting with box are removed, and
 the remaining boxes are clipped to box.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="box">for clipping</param>
	<returns>boxad boxa with boxes in boxas clipped to box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaCombineOverlaps(LeptonicaSharp.Boxa,LeptonicaSharp.Pixa@)">
	<summary>
 Notes
 (1) If there are no overlapping boxes, it simply returns a copy
 of %boxas.
 (2) Input an empty %pixadb, using pixaCreate(0), for debug output.
 The output gives 2 visualizations of the boxes per iteration;
 boxes in red before, and added boxes in green after. Note that
 all pixels in the red boxes are contained in the green ones.
 (3) The alternative method of painting each rectangle and finding
 the 4-connected components gives a different result in
 general, because two non-overlapping (but touching)
 rectangles, when rendered, are 4-connected and will be joined.
 (4) A bad case computationally is to have n boxes, none of which
 overlap.  Then you have one iteration with O(n^2) compares.
 This is still faster than painting each rectangle and finding
 the bounding boxes of the connected components, even for
 thousands of rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="pixadb">debug output</param>
	<returns>boxad where each set of boxes in boxas that overlap are combined into a single bounding box in boxad, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaCombineOverlapsInPair(LeptonicaSharp.Boxa,LeptonicaSharp.Boxa,LeptonicaSharp.Boxa@,LeptonicaSharp.Boxa@,LeptonicaSharp.Pixa@)">
	<summary>
 Notes
 (1) One of three things happens to each box in %boxa1 and %boxa2
 it gets absorbed into a larger box that it overlaps with
 it absorbs a smaller (by area) box that it overlaps with
 and gets larger, using the bounding region of the 2 boxes
 it is unchanged (including absorbing smaller boxes that
 are contained within it).
 (2) If all the boxes from one of the input boxa are absorbed, this
 returns an empty boxa.
 (3) Input an empty %pixadb, using pixaCreate(0), for debug output
 (4) This is useful if different operations are to be carried out
 on possibly overlapping rectangular regions, and it is desired
 to have only one operation on any rectangular region.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas1">input boxa1</param>
	<param name="boxas2">input boxa2</param>
	<param name="pboxad1">output boxa1</param>
	<param name="pboxad2">output boxa2</param>
	<param name="pixadb">debug output</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxOverlapRegion(LeptonicaSharp.Box,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This is the geometric intersection of the two rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="box1">two boxes</param>
	<param name="box2">two boxes</param>
	<returns>box of overlap region between input boxes, or NULL if no overlap or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxBoundingRegion(LeptonicaSharp.Box,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This is the geometric union of the two rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="box1">two boxes</param>
	<param name="box2">two boxes</param>
	<returns>box of bounding region containing the input boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxOverlapFraction(LeptonicaSharp.Box,LeptonicaSharp.Box,System.Single[]@)">
	<summary>
 Notes
 (1) The result depends on the order of the input boxes,
 because the overlap is taken as a fraction of box2.
 </summary>
	<remarks>
	</remarks>
	<param name="box1">two boxes</param>
	<param name="box2">two boxes</param>
	<param name="pfract">the fraction of box2 overlapped by box1</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxOverlapArea(LeptonicaSharp.Box,LeptonicaSharp.Box,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box1">two boxes</param>
	<param name="box2">two boxes</param>
	<param name="parea">the number of pixels in the overlap</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaHandleOverlaps(LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_hling_overlapping_bounding_boxes_in_boxa,System.Int32,System.Single,System.Single,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) For all n(n-1)/2 box pairings, if two boxes overlap, either
 (a) op == L_COMBINE get the bounding region for the two,
 replace the larger with the bounding region, and remove
 the smaller of the two, or
 (b) op == L_REMOVE_SMALL just remove the smaller.
 (2) If boxas is 2D sorted, range can be small, but if it is
 not spatially sorted, range should be large to allow all
 pairwise comparisons to be made.
 (3) The %min_overlap parameter allows ignoring small overlaps.
 If %min_overlap == 1.0, only boxes fully contained in larger
 boxes can be considered for removal; if %min_overlap == 0.0,
 this constraint is ignored.
 (4) The %max_ratio parameter allows ignoring overlaps between
 boxes that are not too different in size.  If %max_ratio == 0.0,
 no boxes can be removed; if %max_ratio == 1.0, this constraint
 is ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="op">L_COMBINE, L_REMOVE_SMALL</param>
	<param name="range">GT 0, forward distance over which overlaps are checked</param>
	<param name="min_overlap">minimum fraction of smaller box required for overlap to count; 0.0 to ignore</param>
	<param name="max_ratio">maximum fraction of small/large areas for overlap to count; 1.0 to ignore</param>
	<param name="pnamap">combining map</param>
	<returns>boxad, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxSeparationDistance(LeptonicaSharp.Box,LeptonicaSharp.Box,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This measures horizontal and vertical separation of the
 two boxes.  If the boxes are touching but have no pixels
 in common, the separation is 0.  If the boxes overlap by
 a distance d, the returned separation is -d.
 </summary>
	<remarks>
	</remarks>
	<param name="box1">two boxes, in any order</param>
	<param name="box2">two boxes, in any order</param>
	<param name="ph_sep">horizontal separation</param>
	<param name="pv_sep">vertical separation</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxCompareSize(LeptonicaSharp.Box,LeptonicaSharp.Box,LeptonicaSharp.Enumerations.L_SORT_BY,System.Int32@)">
	<summary>
 Notes
 (1) We're re-using the SORT enum for these comparisons.
 </summary>
	<remarks>
	</remarks>
	<param name="box1"></param>
	<param name="box2"></param>
	<param name="type">L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER, L_SORT_BY_AREA,</param>
	<param name="prel">1 if box1 GT box2, 0 if the same, -1 if box1 LT box2</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxContainsPt(LeptonicaSharp.Box,System.Single,System.Single,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="x">a point</param>
	<param name="y">a point</param>
	<param name="pcontains">1 if box contains point; 0 otherwise</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetNearestToPt(LeptonicaSharp.Boxa,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Uses euclidean distance between centroid and point.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="x">point</param>
	<param name="y">point</param>
	<returns>box with centroid closest to the given point [x,y], or NULL if no boxes in boxa</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetNearestToLine(LeptonicaSharp.Boxa,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For a horizontal line at some value y, get the minimum of the
 distance |yc - y| from the box centroid yc value to y;
 likewise minimize |xc - x| for a vertical line at x.
 (2) Input y LT 0, x GT= 0 to indicate a vertical line at x, and
 x LT 0, y GT= 0 for a horizontal line at y.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="x">(y = -1 for vertical line; x = -1 for horiz line)</param>
	<param name="y">(y = -1 for vertical line; x = -1 for horiz line)</param>
	<returns>box with centroid closest to the given line, or NULL if no boxes in boxa</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaFindNearestBoxes(LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_value_,System.Int32,LeptonicaSharp.Numaa@,LeptonicaSharp.Numaa@)">
	<summary>
 Notes
 (1) See boxaGetNearestByDirection() for usage of %dist_select
 and %range.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">either unsorted, or 2D sorted in LR/TB scan order</param>
	<param name="dist_select">L_NON_NEGATIVE, L_ALL</param>
	<param name="range">search distance from box i; use 0 to search entire boxa (e.g., if it's not 2D sorted)</param>
	<param name="pnaaindex">for each box in %boxa, contains a numa of 4 box indices (per direction) of the nearest box</param>
	<param name="pnaadist">for each box in %boxa, this contains a numa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetNearestByDirection(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Enumerations.L_scan_direction,LeptonicaSharp.Enumerations.L_value_,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) For efficiency, use a LR/TD sorted %boxa, which can be
 made by flattening a 2D sorted boxaa.  In that case,
 %range can be some positive integer like 50.
 (2) If boxes overlap, the distance will be LT 0.  Use %dist_select
 to determine if these should count or not.  If L_ALL, then
 one box will match as the nearest to another in 2 or more
 directions.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">either unsorted, or 2D sorted in LR/TB scan order</param>
	<param name="i">box we test against</param>
	<param name="dir">direction to look L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
	<param name="dist_select">L_NON_NEGATIVE, L_ALL</param>
	<param name="range">search distance from box i; use 0 to search entire boxa (e.g., if it's not 2D sorted)</param>
	<param name="pindex">index in boxa of nearest box with overlapping coordinates in the indicated direction; -1 if there is no box</param>
	<param name="pdist">distance of the nearest box in the indicated direction; 100000 if no box</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxGetCenter(LeptonicaSharp.Box,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="pcx">location of center of box</param>
	<param name="pcy">location of center of box</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxIntersectByLine(LeptonicaSharp.Box,System.Int32,System.Int32,System.Single,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If the intersection is at only one point (a corner), the
 coordinates are returned in (x1, y1).
 (2) Represent a vertical line by one with a large but finite slope.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="x">point that line goes through</param>
	<param name="y">point that line goes through</param>
	<param name="slope">of line</param>
	<param name="px1">1st point of intersection with box</param>
	<param name="py1">1st point of intersection with box</param>
	<param name="px2">2nd point of intersection with box</param>
	<param name="py2">2nd point of intersection with box</param>
	<param name="pn">number of points of intersection</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxClipToRectangle(LeptonicaSharp.Box,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This can be used to clip a rectangle to an image.
 The clipping rectangle is assumed to have a UL corner at (0, 0),
 and a LR corner at (wi - 1, hi - 1).
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="wi">rectangle representing image</param>
	<param name="hi">rectangle representing image</param>
	<returns>part of box within given rectangle, or NULL on error or if box is entirely outside the rectangle</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxClipToRectangleParams(System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,LeptonicaSharp.Box,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The return value should be checked.  If it is 1, the
 returned parameter values are bogus.
 (2) This simplifies the selection of pixel locations within
 a given rectangle
 for (i = ystart; i LT yend; i++ {
 ...
 for (j = xstart; j LT xend; j++ {
 ....
 </summary>
	<remarks>
	</remarks>
	<param name="box">requested box; can be null</param>
	<param name="w">clipping box size; typ. the size of an image</param>
	<param name="h">clipping box size; typ. the size of an image</param>
	<param name="pxstart">start x coordinate</param>
	<param name="pystart">start y coordinate</param>
	<param name="pxend">one pixel beyond clipping box</param>
	<param name="pyend">one pixel beyond clipping box</param>
	<param name="pbw">clipped width</param>
	<param name="pbh">clipped height</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxRelocateOneSide(LeptonicaSharp.Box,System.Int32,LeptonicaSharp.Enumerations.L_scan_direction,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) Set boxd == NULL to get new box; boxd == boxs for in-place;
 or otherwise to resize existing boxd.
 (2) For usage, suggest one of these
 boxd = boxRelocateOneSide(NULL, boxs, ...);   // new
 boxRelocateOneSide(boxs, boxs, ...); // in-place
 boxRelocateOneSide(boxd, boxs, ...); // other
 </summary>
	<remarks>
	</remarks>
	<param name="boxd">; this can be null, equal to boxs, or different from boxs;</param>
	<param name="boxs">starting box; to have one side relocated</param>
	<param name="loc">new location of the side that is changing</param>
	<param name="sideflag">L_FROM_LEFT, etc., indicating the side that moves</param>
	<returns>boxd, or NULL on error or if the computed boxd has width or height LT= 0.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaAdjustSides(LeptonicaSharp.Boxa,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) New box dimensions are cropped at left and top to x GT= 0 and y GT= 0.
 (2) If the width or height of a box goes to 0, we generate a box with
 w == 1 and h == 1, as a placeholder.
 (3) See boxAdjustSides().
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="delleft">changes in location of each side for each box</param>
	<param name="delright">changes in location of each side for each box</param>
	<param name="deltop">changes in location of each side for each box</param>
	<param name="delbot">changes in location of each side for each box</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxAdjustSides(LeptonicaSharp.Box,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) Set boxd == NULL to get new box; boxd == boxs for in-place;
 or otherwise to resize existing boxd.
 (2) For usage, suggest one of these
 boxd = boxAdjustSides(NULL, boxs, ...);   // new
 boxAdjustSides(boxs, boxs, ...); // in-place
 boxAdjustSides(boxd, boxs, ...); // other
 (3) New box dimensions are cropped at left and top to x GT= 0 and y GT= 0.
 (4) For example, to expand in-place by 20 pixels on each side, use
 boxAdjustSides(box, box, -20, 20, -20, 20);
 </summary>
	<remarks>
	</remarks>
	<param name="boxd">; this can be null, equal to boxs, or different from boxs</param>
	<param name="boxs">starting box; to have sides adjusted</param>
	<param name="delleft">changes in location of each side</param>
	<param name="delright">changes in location of each side</param>
	<param name="deltop">changes in location of each side</param>
	<param name="delbot">changes in location of each side</param>
	<returns>boxd, or NULL on error or if the computed boxd has width or height LT= 0.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSetSide(LeptonicaSharp.Boxa,LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_box_size_adjustment_location,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sets the given side of each box.  Use boxad == NULL for a new
 boxa, and boxad == boxas for in-place.
 (2) Use one of these
 boxad = boxaSetSide(NULL, boxas, ...);   // new
 boxaSetSide(boxas, boxas, ...);  // in-place
 </summary>
	<remarks>
	</remarks>
	<param name="boxad">use NULL to get a new one; same as boxas for in-place</param>
	<param name="boxas"></param>
	<param name="side">L_SET_LEFT, L_SET_RIGHT, L_SET_TOP, L_SET_BOT</param>
	<param name="val">location to set for given side, for each box</param>
	<param name="thresh">min abs difference to cause resetting to %val</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaAdjustWidthToTarget(LeptonicaSharp.Boxa,LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_box_size_adjustment_location,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Conditionally adjusts the width of each box, by moving
 the indicated edges (left and/or right) if the width differs
 by %thresh or more from %target.
 (2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.
 Use one of these
 boxad = boxaAdjustWidthToTarget(NULL, boxas, ...);   // new
 boxaAdjustWidthToTarget(boxas, boxas, ...);  // in-place
 </summary>
	<remarks>
	</remarks>
	<param name="boxad">use NULL to get a new one; same as boxas for in-place</param>
	<param name="boxas"></param>
	<param name="sides">L_ADJUST_LEFT, L_ADJUST_RIGHT, L_ADJUST_LEFT_AND_RIGHT</param>
	<param name="target">target width if differs by more than thresh</param>
	<param name="thresh">min abs difference in width to cause adjustment</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaAdjustHeightToTarget(LeptonicaSharp.Boxa,LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_box_size_adjustment_location,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Conditionally adjusts the height of each box, by moving
 the indicated edges (top and/or bot) if the height differs
 by %thresh or more from %target.
 (2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.
 Use one of these
 boxad = boxaAdjustHeightToTarget(NULL, boxas, ...);   // new
 boxaAdjustHeightToTarget(boxas, boxas, ...);  // in-place
 </summary>
	<remarks>
	</remarks>
	<param name="boxad">use NULL to get a new one</param>
	<param name="boxas"></param>
	<param name="sides">L_ADJUST_TOP, L_ADJUST_BOT, L_ADJUST_TOP_AND_BOT</param>
	<param name="target">target height if differs by more than thresh</param>
	<param name="thresh">min abs difference in height to cause adjustment</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxEqual(LeptonicaSharp.Box,LeptonicaSharp.Box,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="box1"></param>
	<param name="box2"></param>
	<param name="psame">1 if equal; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaEqual(LeptonicaSharp.Boxa,LeptonicaSharp.Boxa,System.Int32,System.Int32@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The two boxa are the "same" if they contain the same
 boxes and each box is within %maxdist of its counterpart
 in their positions within the boxa.  This allows for
 small rearrangements.  Use 0 for maxdist if the boxa
 must be identical.
 (2) This applies only to geometry and ordering; refcounts
 are not considered.
 (3) %maxdist allows some latitude in the ordering of the boxes.
 For the boxa to be the "same", corresponding boxes must
 be within %maxdist of each other.  Note that for large
 %maxdist, we should use a hash function for efficiency.
 (4) naindex[i] gives the position of the box in boxa2 that
 corresponds to box i in boxa1.  It is only returned if the
 boxa are equal.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa1"></param>
	<param name="boxa2"></param>
	<param name="maxdist"></param>
	<param name="pnaindex">index array of correspondences</param>
	<param name="psame">(1 if equal; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxSimilar(LeptonicaSharp.Box,LeptonicaSharp.Box,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The values of leftdiff (etc) are the maximum allowed deviations
 between the locations of the left (etc) sides.  If any side
 pairs differ by more than this amount, the boxes are not similar.
 </summary>
	<remarks>
	</remarks>
	<param name="box1"></param>
	<param name="box2"></param>
	<param name="leftdiff"></param>
	<param name="rightdiff"></param>
	<param name="topdiff"></param>
	<param name="botdiff"></param>
	<param name="psimilar">1 if similar; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSimilar(LeptonicaSharp.Boxa,LeptonicaSharp.Boxa,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,LeptonicaSharp.Enumerations.DebugOnOff,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) See boxSimilar() for parameter usage.
 (2) Corresponding boxes are taken in order in the two boxa.
 (3) %nasim is an indicator array with a (0/1) for each box pair.
 (4) With %nasim or debug == 1, boxes continue to be tested
 after failure.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa1"></param>
	<param name="boxa2"></param>
	<param name="leftdiff"></param>
	<param name="rightdiff"></param>
	<param name="topdiff"></param>
	<param name="botdiff"></param>
	<param name="debug">output details of non-similar boxes</param>
	<param name="psimilar">1 if similar; 0 otherwise</param>
	<param name="pnasim">na containing 1 if similar; else 0</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaJoin(LeptonicaSharp.Boxa,LeptonicaSharp.Boxa,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This appends a clone of each indicated box in boxas to boxad
 (2) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (3) iend LT 0 means 'read to the end'
 (4) if boxas == NULL or has no boxes, this is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="boxad">dest boxa; add to this one</param>
	<param name="boxas">source boxa; add from this one</param>
	<param name="istart">starting index in boxas</param>
	<param name="iend">ending index in boxas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaJoin(LeptonicaSharp.Boxaa,LeptonicaSharp.Boxaa,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This appends a clone of each indicated boxa in baas to baad
 (2) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (3) iend LT 0 means 'read to the end'
 (4) if baas == NULL, this is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="baad">dest boxaa; add to this one</param>
	<param name="baas">source boxaa; add from this one</param>
	<param name="istart">starting index in baas</param>
	<param name="iend">ending index in baas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSplitEvenOdd(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Boxa@,LeptonicaSharp.Boxa@)">
	<summary>
 Notes
 (1) If %fillflag == 1, boxae has copies of the even boxes
 in their original location, and nvalid boxes are placed
 in the odd array locations.  And v.v.
 (2) If %fillflag == 0, boxae has only copies of the even boxes.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="fillflag">1 to put invalid boxes in place; 0 to omit</param>
	<param name="pboxae">save even and odd boxes in their separate boxa, setting the other type to invalid boxes.</param>
	<param name="pboxao">save even and odd boxes in their separate boxa, setting the other type to invalid boxes.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaMergeEvenOdd(LeptonicaSharp.Boxa,LeptonicaSharp.Boxa,System.Int32)">
	<summary>
 Notes
 (1) This is essentially the inverse of boxaSplitEvenOdd().
 Typically, boxae and boxao were generated by boxaSplitEvenOdd(),
 and the value of %fillflag needs to be the same in both calls.
 (2) If %fillflag == 1, both boxae and boxao are of the same size;
 otherwise boxae may have one more box than boxao.
 </summary>
	<remarks>
	</remarks>
	<param name="boxae">boxes to go in even positions in merged boxa</param>
	<param name="boxao">boxes to go in odd positions in merged boxa</param>
	<param name="fillflag">1 if there are invalid boxes in placeholders</param>
	<returns>boxad merged, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaTransform(LeptonicaSharp.Boxa,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) This is a very simple function that first shifts, then scales.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="shiftx"></param>
	<param name="shifty"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxTransform(LeptonicaSharp.Box,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) This is a very simple function that first shifts, then scales.
 (2) If the box is invalid, a new invalid box is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="shiftx"></param>
	<param name="shifty"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<returns>boxd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaTransformOrdered(LeptonicaSharp.Boxa,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_affine_transm_order,System.Single,System.Single)">
	<summary>
 Notes
 (1) This allows a sequence of linear transforms on each box.
 the transforms are from the affine set, composed of
 shift, scaling and rotation, and the order of the
 transforms is specified.
 (2) Although these operations appear to be on an infinite
 2D plane, in practice the region of interest is clipped
 to a finite image.  The center of rotation is usually taken
 with respect to the image (either the UL corner or the
 center).  A translation can have two very different effects
 (a) Moves the boxes across the fixed image region.
 (b) Moves the image origin, causing a change in the image
 region and an opposite effective translation of the boxes.
 This function should only be used for (a), where the image
 region is fixed on translation.  If the image region is
 changed by the translation, use instead the functions
 in affinecompose.c, where the image region and rotation
 center can be computed from the actual clipping due to
 translation of the image origin.
 (3) See boxTransformOrdered() for usage and implementation details.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="shiftx"></param>
	<param name="shifty"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<param name="xcen">center of rotation</param>
	<param name="ycen">center of rotation</param>
	<param name="angle">in radians; clockwise is positive</param>
	<param name="order">one of 6 combinations L_TR_SC_RO, ...</param>
	<returns>boxd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxTransformOrdered(LeptonicaSharp.Box,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_affine_transm_order,System.Single,System.Single)">
	<summary>
 Notes
 (1) This allows a sequence of linear transforms, composed of
 shift, scaling and rotation, where the order of the
 transforms is specified.
 (2) The rotation is taken about a point specified by (xcen, ycen).
 Let the components of the vector from the center of rotation
 to the box center be (xdif, ydif)
 xdif = (bx + 0.5  bw) - xcen
 ydif = (by + 0.5  bh) - ycen
 Then the box center after rotation has new components
 bxcen = xcen + xdif  cosa + ydif  sina
 bycen = ycen + ydif  cosa - xdif  sina
 where cosa and sina are the cos and sin of the angle,
 and the enclosing box for the rotated box has size
 rw = |bw  cosa| + |bh  sina|
 rh = |bh  cosa| + |bw  sina|
 where bw and bh are the unrotated width and height.
 Then the box UL corner (rx, ry) is
 rx = bxcen - 0.5  rw
 ry = bycen - 0.5  rh
 (3) The center of rotation specified by args %xcen and %ycen
 is the point BEFORE any translation or scaling.  If the
 rotation is not the first operation, this function finds
 the actual center at the time of rotation.  It does this
 by making the following assumptions
 (1) Any scaling is with respect to the UL corner, so
 that the center location scales accordingly.
 (2) A translation does not affect the center of
 the image; it just moves the boxes.
 We always use assumption (1).  However, assumption (2)
 will be incorrect if the apparent translation is due
 to a clipping operation that, in effect, moves the
 origin of the image.  In that case, you should NOT use
 these simple functions.  Instead, use the functions
 in affinecompose.c, where the rotation center can be
 computed from the actual clipping due to translation
 of the image origin.
 </summary>
	<remarks>
	</remarks>
	<param name="boxs"></param>
	<param name="shiftx"></param>
	<param name="shifty"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<param name="xcen">center of rotation</param>
	<param name="ycen">center of rotation</param>
	<param name="angle">in radians; clockwise is positive</param>
	<param name="order">one of 6 combinations L_TR_SC_RO, ...</param>
	<returns>boxd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaRotateOrth(LeptonicaSharp.Boxa,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See boxRotateOrth() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="w">of image in which the boxa is embedded</param>
	<param name="h">of image in which the boxa is embedded</param>
	<param name="rotation">0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg; all rotations are clockwise</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxRotateOrth(LeptonicaSharp.Box,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Rotate the image with the embedded box by the specified amount.
 (2) After rotation, the rotated box is always measured with
 respect to the UL corner of the image.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="w">of image in which the box is embedded</param>
	<param name="h">of image in which the box is embedded</param>
	<param name="rotation">0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg; all rotations are clockwise</param>
	<returns>boxd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSort(LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_SORT_BY,LeptonicaSharp.Enumerations.L_SORT_CREASING,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) An empty boxa returns a copy, with a warning.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_RIGHT, L_SORT_BY_BOT, L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER, L_SORT_BY_AREA, L_SORT_BY_ASPECT_RATIO</param>
	<param name="sortorder">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<param name="pnaindex">index of sorted order into original array</param>
	<returns>boxad sorted version of boxas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaBinSort(LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_SORT_BY,LeptonicaSharp.Enumerations.L_SORT_CREASING,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) For a large number of boxes (say, greater than 1000), this
 O(n) binsort is much faster than the O(nlogn) shellsort.
 For 5000 components, this is over 20x faster than boxaSort().
 (2) Consequently, boxaSort() calls this function if it will
 likely go much faster.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_PERIMETER</param>
	<param name="sortorder">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<param name="pnaindex">index of sorted order into original array</param>
	<returns>boxad sorted version of boxas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSortByIndex(LeptonicaSharp.Boxa,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="naindex">na that maps from the new boxa to the input boxa</param>
	<returns>boxad sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSort2d(LeptonicaSharp.Boxa,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Numaa@)">
	<summary>
 Notes
 (1) The final result is a sort where the 'fast scan' direction is
 left to right, and the 'slow scan' direction is from top
 to bottom.  Each boxa in the baa represents a sorted set
 of boxes from left to right.
 (2) Three passes are used to aggregate the boxas, which can correspond
 to characters or words in a line of text.  In pass 1, only
 taller components, which correspond to xheight or larger,
 are permitted to start a new boxa.  In pass 2, the remaining
 vertically-challenged components are allowed to join an
 existing boxa or start a new one.  In pass 3, boxa whose extent
 is overlapping are joined.  After that, the boxes in each
 boxa are sorted horizontally, and finally the boxa are
 sorted vertically.
 (3) If delta1 LT 0, the first pass allows aggregation when
 boxes in the same boxa do not overlap vertically.
 The distance by which they can miss and still be aggregated
 is the absolute value |delta1|.   Similar for delta2 on
 the second pass.
 (4) On the first pass, any component of height less than minh1
 cannot start a new boxa; it's put aside for later insertion.
 (5) On the second pass, any small component that doesn't align
 with an existing boxa can start a new one.
 (6) This can be used to identify lines of text from
 character or word bounding boxes.
 (7) Typical values for the input parameters on 300 ppi text are
 delta1 ~ 0
 delta2 ~ 0
 minh1 ~ 5
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="pnaad">numaa with sorted indices whose values are the indices of the input array</param>
	<param name="delta1">min overlap that permits aggregation of a box onto a boxa of horizontally-aligned boxes; pass 1</param>
	<param name="delta2">min overlap that permits aggregation of a box onto a boxa of horizontally-aligned boxes; pass 2</param>
	<param name="minh1">components less than this height either join an existing boxa or are set aside for pass 2</param>
	<returns>baa 2d sorted version of boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSort2dByIndex(LeptonicaSharp.Boxa,LeptonicaSharp.Numaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="naa">numaa that maps from the new baa to the input boxa</param>
	<returns>baa sorted boxaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaExtractAsNuma(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) If you are counting or sorting values, such as determining
 rank order, you must remove invalid boxes.
 (2) If you are parametrizing the values, or doing an evaluation
 where the position in the boxa sequence is important, you
 must replace the invalid boxes with valid ones before
 doing the extraction. This is easily done with boxaFillSequence().
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pnal">array of left locations</param>
	<param name="pnat">array of top locations</param>
	<param name="pnar">array of right locations</param>
	<param name="pnab">array of bottom locations</param>
	<param name="pnaw">array of widths</param>
	<param name="pnah">array of heights</param>
	<param name="keepinvalid">1 to keep invalid boxes; 0 to remove them</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaExtractAsPta(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Pta@,LeptonicaSharp.Pta@,LeptonicaSharp.Pta@,LeptonicaSharp.Pta@,LeptonicaSharp.Pta@,LeptonicaSharp.Pta@)">
	<summary>
 Notes
 (1) For most applications, such as counting, sorting, fitting
 to some parametrized form, plotting or filtering in general,
 you should remove the invalid boxes.  Each pta saves the
 box index in the x array, so replacing invalid boxes by
 filling with boxaFillSequence(), which is required for
 boxaExtractAsNuma(), is not necessary.
 (2) If invalid boxes are retained, each one will result in
 entries (typically 0) in all selected output pta.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pptal">array of left locations vs. index</param>
	<param name="pptat">array of top locations vs. index</param>
	<param name="pptar">array of right locations vs. index</param>
	<param name="pptab">array of bottom locations vs. index</param>
	<param name="pptaw">array of widths vs. index</param>
	<param name="pptah">array of heights vs. index</param>
	<param name="keepinvalid">1 to keep invalid boxes; 0 to remove them</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetRankVals(LeptonicaSharp.Boxa,System.Single,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This function does not assume that all boxes in the boxa are valid
 (2) The four box parameters are sorted independently.
 For rank order, the width and height are sorted in increasing
 order.  But what does it mean to sort x and y in "rank order"?
 If the boxes are of comparable size and somewhat
 aligned (e.g., from multiple images), it makes some sense
 to give a "rank order" for x and y by sorting them in
 decreasing order.  But in general, the interpretation of a rank
 order on x and y is highly application dependent.  In summary
 ~ x and y are sorted in decreasing order
 ~ w and h are sorted in increasing order
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="fract">use 0.0 for smallest, 1.0 for largest width and height</param>
	<param name="px">rank value of x</param>
	<param name="py">rank value of y</param>
	<param name="pw">rank value of width</param>
	<param name="ph">rank value of height</param>
	<returns>0 if OK, 1 on error or if the boxa is empty or has no valid boxes</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetMedianVals(LeptonicaSharp.Boxa,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) See boxaGetRankVals()
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="px">median value of x</param>
	<param name="py">median value of y</param>
	<param name="pw">median value of width</param>
	<param name="ph">median value of height</param>
	<returns>0 if OK, 1 on error or if the boxa is empty or has no valid boxes</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetAverageSize(LeptonicaSharp.Boxa,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pw">average width</param>
	<param name="ph">average height</param>
	<returns>0 if OK, 1 on error or if the boxa is empty</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaGetExtent(LeptonicaSharp.Boxaa,System.Int32@,System.Int32@,LeptonicaSharp.Box@,LeptonicaSharp.Boxa@)">
	<summary>
 Notes
 (1) The returned w and h are the minimum size image
 that would contain all boxes untranslated.
 (2) Each box in the returned boxa is the minimum box required to
 hold all the boxes in the respective boxa of baa.
 (3) If there are no valid boxes in a boxa, the box corresponding
 to its extent has all fields set to 0 (an invalid box).
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<param name="pbox">minimum box containing all boxa in boxaa</param>
	<param name="pboxa">boxa containing all boxes in each boxa in the boxaa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaFlattenToBoxa(LeptonicaSharp.Boxaa,LeptonicaSharp.Enumerations.L_access_storage,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This 'flattens' the baa to a boxa, taking the boxes in
 order in the first boxa, then the second, etc.
 (2) If a boxa is empty, we generate an invalid, placeholder box
 of zero size.  This is useful when converting from a baa
 where each boxa has either 0 or 1 boxes, and it is necessary
 to maintain a 11 correspondence between the initial
 boxa array and the resulting box array.
 (3) If naindex is defined, we generate a Numa that gives, for
 each box in the baa, the index of the boxa to which it belongs.
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="pnaindex">the boxa index in the baa</param>
	<param name="copyflag">L_COPY or L_CLONE</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaFlattenAligned(LeptonicaSharp.Boxaa,System.Int32,LeptonicaSharp.Enumerations.L_access_storage,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This 'flattens' the baa to a boxa, taking the first %num
 boxes from each boxa.
 (2) In each boxa, if there are less than %num boxes, we preserve
 the alignment between the input baa and the output boxa
 by inserting one or more fillerbox(es) or, if %fillerbox == NULL,
 one or more invalid placeholder boxes.
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="num">number extracted from each</param>
	<param name="fillerbox">that fills if necessary</param>
	<param name="copyflag">L_COPY or L_CLONE</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaEncapsulateAligned(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) This puts %num boxes from the input %boxa into each of a
 set of boxa within an output baa.
 (2) This assumes that the boxes in %boxa are in sets of %num each.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="num">number put into each boxa in the baa</param>
	<param name="copyflag">L_COPY or L_CLONE</param>
	<returns>baa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaTranspose(LeptonicaSharp.Boxaa)">
	<summary>
 Notes
 (1) If you think of a boxaa as a 2D array of boxes that is accessed
 row major, then each row is represented by one of the boxa.
 This function creates a new boxaa related to the input boxaa
 as a column major traversal of the input boxaa.
 (2) For example, if %baas has 2 boxa, each with 10 boxes, then
 %baad will have 10 boxa, each with 2 boxes.
 (3) Require for this transpose operation that each boxa in
 %baas has the same number of boxes.  This operation is useful
 when the i-th boxes in each boxa are meaningfully related.
 </summary>
	<remarks>
	</remarks>
	<param name="baas"></param>
	<returns>baad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaAlignBox(LeptonicaSharp.Boxaa,LeptonicaSharp.Box,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This is not greedy.  It finds the boxa whose vertical
 extent has the closest overlap with the input box.
 </summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="box">to be aligned with the bext boxa in the baa, if possible</param>
	<param name="delta">amount by which consecutive components can miss in overlap and still be included in the array</param>
	<param name="pindex">index of boxa with best overlap, or if none match, this is the index of the next boxa to be generated</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMaskConnComp(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Boxa@)">
	<summary>
 Notes
 (1) This generates a mask image with ON pixels over the
 b.b. of the c.c. in pixs.  If there are no ON pixels in pixs,
 pixd will also have no ON pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">4 or 8</param>
	<param name="pboxa">bounding boxes of c.c.</param>
	<returns>pixd 1 bpp mask over the c.c., or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMaskBoxa(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_PIXELS,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This can be used with
 pixd = NULL  (makes a new pixd)
 pixd = pixs  (in-place)
 (2) If pixd == NULL, this first makes a copy of pixs, and then
 bit-twiddles over the boxes.  Otherwise, it operates directly
 on pixs.
 (3) This simple function is typically used with 1 bpp images.
 It uses the 1-image rasterop function, rasteropUniLow(),
 to set, clear or flip the pixels in pixd.
 (4) If you want to generate a 1 bpp mask of ON pixels from the boxes
 in a Boxa, in a pix of size (w,h)
 pix = pixCreate(w, h, 1);
 pixMaskBoxa(pix, pix, boxa, L_SET_PIXELS);
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">may be NULL</param>
	<param name="pixs">any depth; not cmapped</param>
	<param name="boxa">of boxes, to paint</param>
	<param name="op">L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>pixd with masking op over the boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixPaintBoxa(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,System.UInt32)">
	<summary>
 Notes
 (1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp
 and the boxa is painted using a colormap; otherwise,
 it is converted to 32 bpp rgb.
 (2) There are several ways to display a box on an image
 Paint it as a solid color
 Draw the outline
 Blend the outline or region with the existing image
 We provide painting and drawing here; blending is in blend.c.
 When painting or drawing, the result can be either a
 cmapped image or an rgb image.  The dest will be cmapped
 if the src is either 1 bpp or has a cmap that is not full.
 To force RGB output, use pixConvertTo8(pixs, FALSE)
 before calling any of these paint and draw functions.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, can be cmapped</param>
	<param name="boxa">of boxes, to paint</param>
	<param name="val">rgba color to paint</param>
	<returns>pixd with painted boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetBlackOrWhiteBoxa(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_SET,LeptonicaSharp.Boxa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, can be cmapped</param>
	<param name="boxa">of boxes, to clear or set</param>
	<param name="op">L_SET_BLACK, L_SET_WHITE</param>
	<returns>pixd with boxes filled with white or black, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixPaintBoxaRandom(LeptonicaSharp.Pix,LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) If pixs is 1 bpp, we paint the boxa using a colormap;
 otherwise, we convert to 32 bpp.
 (2) We use up to 254 different colors for painting the regions.
 (3) If boxes overlap, the later ones paint over earlier ones.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, can be cmapped</param>
	<param name="boxa">of boxes, to paint</param>
	<returns>pixd with painted boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlendBoxaRandom(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,System.Single)">
	<summary>
 Notes
 (1) pixs is converted to 32 bpp.
 (2) This differs from pixPaintBoxaRandom(), in that the
 colors here are blended with the color of pixs.
 (3) We use up to 254 different colors for painting the regions.
 (4) If boxes overlap, the final color depends only on the last
 rect that is used.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; can be cmapped</param>
	<param name="boxa">of boxes, to blend/paint</param>
	<param name="fract">of box color to use</param>
	<returns>pixd 32 bpp, with blend/painted boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDrawBoxa(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp
 and the boxa is drawn using a colormap; otherwise,
 it is converted to 32 bpp rgb.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; can be cmapped</param>
	<param name="boxa">of boxes, to draw</param>
	<param name="width">of lines</param>
	<param name="val">rgba color to draw</param>
	<returns>pixd with outlines of boxes added, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDrawBoxaRandom(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,System.Int32)">
	<summary>
 Notes
 (1) If pixs is 1 bpp, we draw the boxa using a colormap;
 otherwise, we convert to 32 bpp.
 (2) We use up to 254 different colors for drawing the boxes.
 (3) If boxes overlap, the later ones draw over earlier ones.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, can be cmapped</param>
	<param name="boxa">of boxes, to draw</param>
	<param name="width">thickness of line</param>
	<returns>pixd with box outlines drawn, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaDisplay(LeptonicaSharp.Boxaa,System.Int32,System.Int32,System.UInt32,System.UInt32,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If %pixs exists, this renders the boxes over an 8 bpp version
 of it.  Otherwise, it renders the boxes over an empty image
 with a white background.
 (2) If %pixs exists, the dimensions of %pixd are the same,
 and input values of %w and %h are ignored.
 If %pixs is NULL, the dimensions of %pixd are determined by
 - %w and %h if both are GT 0, or
 - the minimum size required using all boxes in %baa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="baa">boxaa, typically from a 2d sort</param>
	<param name="linewba">line width to display outline of each boxa</param>
	<param name="linewb">line width to display outline of each box</param>
	<param name="colorba">color to display boxa</param>
	<param name="colorb">color to display box</param>
	<param name="w">width of outupt pix; use 0 if determined by %pixs or %baa</param>
	<param name="h">height of outupt pix; use 0 if determined by %pixs or %baa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplayBoxaa(LeptonicaSharp.Pixa,LeptonicaSharp.Boxaa,LeptonicaSharp.Enumerations.L_DRAW,System.Int32)">
	<summary>
 Notes
 (1) All pix in %pixas that are not rgb are converted to rgb.
 (2) Each boxa in %baa contains boxes that will be drawn on
 the corresponding pix in %pixas.
 (3) The color of the boxes drawn on each pix are selected with
 %colorflag
 For red, green or blue use L_DRAW_RED, etc.
 For sequential r, g, b use L_DRAW_RGB
 For random colors use L_DRAW_RANDOM
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">any depth, can be cmapped</param>
	<param name="baa">boxes to draw on input pixa</param>
	<param name="colorflag">(L_DRAW_RED, L_DRAW_GREEN, etc)</param>
	<param name="width">thickness of lines</param>
	<returns>pixa with box outlines drawn on each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSplitIntoBoxa(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates a boxa of rectangles that covers
 the fg of a mask.  For each 8-connected component in pixs,
 it does a greedy partitioning, choosing the largest
 rectangle found from each of the four directions at each iter.
 See pixSplitComponentIntoBoxa() for details.
 (2) The input parameters give some flexibility for boundary
 noise.  The resulting set of rectangles may cover some
 bg pixels.
 (3) This should be used when there are a small number of
 mask components, each of which has sides that are close
 to horizontal and vertical.  The input parameters %delta
 and %maxbg determine whether or not holes in the mask are covered.
 (4) The parameter %maxcomps gives the maximum number of allowed
 rectangles extracted from any single connected component.
 Use 0 if no limit is to be applied.
 (5) The flag %remainder specifies whether we take a final bounding
 box for anything left after the maximum number of allowed
 rectangle is extracted.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="minsum">minimum pixels to trigger propagation</param>
	<param name="skipdist">distance before computing sum for propagation</param>
	<param name="delta">difference required to stop propagation</param>
	<param name="maxbg">maximum number of allowed bg pixels in ref scan</param>
	<param name="maxcomps">use 0 for unlimited number of subdivided components</param>
	<param name="remainder">set to 1 to get b.b. of remaining stuff</param>
	<returns>boxa of rectangles covering the fg of pixs, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSplitComponentIntoBoxa(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This generates a boxa of rectangles that covers
 the fg of a mask.  It does so by a greedy partitioning of
 the mask, choosing the largest rectangle found from
 each of the four directions at each step.
 (2) The input parameters give some flexibility for boundary
 noise.  The resulting set of rectangles must cover all
 the fg pixels and, in addition, may cover some bg pixels.
 Using small input parameters on a noiseless mask (i.e., one
 that has only large vertical and horizontal edges) will
 result in a proper covering of only the fg pixels of the mask.
 (3) The input is assumed to be a single connected component, that
 may have holes.  From each side, sweep inward, counting
 the pixels.  If the count becomes greater than %minsum,
 and we have moved forward a further amount %skipdist,
 record that count ('countref'), but don't accept if the scan
 contains more than %maxbg bg pixels.  Continue the scan
 until we reach a count that differs from countref by at
 least %delta, at which point the propagation stops.  The box
 swept out gets a score, which is the sum of fg pixels
 minus a penalty.  The penalty is the number of bg pixels
 in the box.  This is done from all four sides, and the
 side with the largest score is saved as a rectangle.
 The process repeats until there is either no rectangle
 left, or there is one that can't be captured from any
 direction.  For the latter case, we simply accept the
 last rectangle.
 (4) The input box is only used to specify the location of
 the UL corner of pix, with respect to an origin that
 typically represents the UL corner of an underlying image,
 of which pix is one component.  If %box is null,
 the UL corner is taken to be (0, 0).
 (5) The parameter %maxcomps gives the maximum number of allowed
 rectangles extracted from any single connected component.
 Use 0 if no limit is to be applied.
 (6) The flag %remainder specifies whether we take a final bounding
 box for anything left after the maximum number of allowed
 rectangle is extracted.
 (7) So if %maxcomps GT 0, it specifies that we want no more than
 the first %maxcomps rectangles that satisfy the input
 criteria.  After this, we can get a final rectangle that
 bounds everything left over by setting %remainder == 1.
 If %remainder == 0, we only get rectangles that satisfy
 the input criteria.
 (8) It should be noted that the removal of rectangles can
 break the original c.c. into several c.c.
 (9) Summing up
 If %maxcomp == 0, the splitting proceeds as far as possible.
 If %maxcomp GT 0, the splitting stops when %maxcomps are
 found, or earlier if no more components can be selected.
 If %remainder == 1 and components remain that cannot be
 selected, they are returned as a single final rectangle;
 otherwise, they are ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="box">location of pix w/rt an origin</param>
	<param name="minsum">minimum pixels to trigger propagation</param>
	<param name="skipdist">distance before computing sum for propagation</param>
	<param name="delta">difference required to stop propagation</param>
	<param name="maxbg">maximum number of allowed bg pixels in ref scan</param>
	<param name="maxcomps">use 0 for unlimited number of subdivided components</param>
	<param name="remainder">set to 1 to get b.b. of remaining stuff</param>
	<returns>boxa of rectangles covering the fg of pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeMosaicStrips(System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_scan_direction,System.Int32)">
	<summary>
 Notes
 (1) For example, this can be used to generate a pixa of
 vertical strips of width 10 from an image, using
 pixGetDimensions(pix, w, h, NULL);
 boxa = makeMosaicStrips(w, h, L_SCAN_HORIZONTAL, 10);
 pixa = pixClipRectangles(pix, boxa);
 All strips except the last will be the same width.  The
 last strip will have width w % 10.
 </summary>
	<remarks>
	</remarks>
	<param name="w"></param>
	<param name="h"></param>
	<param name="direction">L_SCAN_HORIZONTAL or L_SCAN_VERTICAL</param>
	<param name="size">of strips in the scan direction</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaCompareRegions(LeptonicaSharp.Boxa,LeptonicaSharp.Boxa,System.Int32,System.Int32@,System.Single[]@,System.Single[]@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This takes 2 boxa, removes all boxes smaller than a given area,
 and compares the remaining boxes between the boxa.
 (2) The area threshold is introduced to help remove noise from
 small components.  Any box with a smaller value of w  h
 will be removed from consideration.
 (3) The xor difference is the most stringent test, requiring alignment
 of the corresponding boxes.  It is also more computationally
 intensive and is optionally returned.  Alignment is to the
 UL corner of each region containing all boxes, as given by
 boxaGetExtent().
 (4) Both fractional differences are with respect to the total
 area in the two boxa.  They range from 0.0 to 1.0.
 A perfect match has value 0.0.  If both boxa are empty,
 we return 0.0; if one is empty we return 1.0.
 (5) An example input might be the rectangular regions of a
 segmentation mask for text or images from two pages.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa1"></param>
	<param name="boxa2"></param>
	<param name="areathresh">minimum area of boxes to be considered</param>
	<param name="pnsame">true if same number of boxes</param>
	<param name="pdiffarea">fractional difference in total area</param>
	<param name="pdiffxor">fractional difference in xor of regions</param>
	<param name="ppixdb">debug pix showing two boxa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSelectLargeULComp(LeptonicaSharp.Pix,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This selects a box near the top (first) and left (second)
 of the image, from the set of all boxes that have
 area GT= %areaslop  (area of biggest box),
 where %areaslop is some fraction; say ~ 0.9.
 (2) For all boxes satisfying the above condition, select
 the left-most box that is within %yslop (say, 20) pixels
 of the box nearest the top.
 (3) This can be used to reliably select a specific one of
 the largest regions in an image, for applications where
 there are expected to be small variations in region size
 and location.
 (4) See boxSelectLargeULBox() for implementation details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="areaslop">fraction near but less than 1.0</param>
	<param name="yslop">number of pixels in y direction</param>
	<param name="connectivity">4 or 8</param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSelectLargeULBox(LeptonicaSharp.Boxa,System.Single,System.Int32)">
	<summary>
 Notes
 (1) See usage notes in pixSelectLargeULComp().
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">1 bpp</param>
	<param name="areaslop">fraction near but less than 1.0</param>
	<param name="yslop">number of pixels in y direction</param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSelectRange(LeptonicaSharp.Boxa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) The copyflag specifies what we do with each box from boxas.
 Specifically, L_CLONE inserts a clone into boxad of each
 selected box from boxas.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="first">use 0 to select from the beginning</param>
	<param name="last">use 0 to select to the end</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaSelectRange(LeptonicaSharp.Boxaa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) The copyflag specifies what we do with each boxa from baas.
 Specifically, L_CLONE inserts a clone into baad of each
 selected boxa from baas.
 </summary>
	<remarks>
	</remarks>
	<param name="baas"></param>
	<param name="first">use 0 to select from the beginning</param>
	<param name="last">use 0 to select to the end</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>baad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSelectBySize(LeptonicaSharp.Boxa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_SELECT,LeptonicaSharp.Enumerations.L_SELECT_IF,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) Uses box copies in the new boxa.
 (3) If the selection type is L_SELECT_WIDTH, the input
 height is ignored, and v.v.
 (4) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="width">threshold dimensions</param>
	<param name="height">threshold dimensions</param>
	<param name="type">L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>boxad filtered set, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaMakeSizeIndicator(LeptonicaSharp.Boxa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_SELECT,LeptonicaSharp.Enumerations.L_SELECT_IF)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) If the selection type is L_SELECT_WIDTH, the input
 height is ignored, and v.v.
 (3) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="width">threshold dimensions</param>
	<param name="height">threshold dimensions</param>
	<param name="type">L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns>na indicator array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSelectByArea(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Enumerations.L_SELECT_IF,System.Int32@)">
	<summary>
 Notes
 (1) Uses box copies in the new boxa.
 (2) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="area">threshold value of width  height</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>boxad filtered set, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaMakeAreaIndicator(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Enumerations.L_SELECT_IF)">
	<summary>
 Notes
 (1) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="area">threshold value of width  height</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns>na indicator array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSelectByWHRatio(LeptonicaSharp.Boxa,System.Single,LeptonicaSharp.Enumerations.L_SELECT_IF,System.Int32@)">
	<summary>
 Notes
 (1) Uses box copies in the new boxa.
 (2) To keep narrow components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep wide components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="ratio">width/height threshold value</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>boxad filtered set, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaMakeWHRatioIndicator(LeptonicaSharp.Boxa,System.Single,LeptonicaSharp.Enumerations.L_SELECT_IF)">
	<summary>
 Notes
 (1) To keep narrow components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep wide components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="ratio">width/height threshold value</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns>na indicator array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSelectWithIndicator(LeptonicaSharp.Boxa,LeptonicaSharp.Numa,System.Int32@)">
	<summary>
 Notes
 (1) Returns a copy of the boxa if no components are removed.
 (2) Uses box copies in the new boxa.
 (3) The indicator numa has values 0 (ignore) and 1 (accept).
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="na">indicator numa</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>boxad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaPermutePseudorandom(LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) This does a pseudorandom in-place permutation of the boxes.
 (2) The result is guaranteed not to have any boxes in their
 original position, but it is not very random.  If you
 need randomness, use boxaPermuteRandom().
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">input boxa</param>
	<returns>boxad with boxes permuted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaPermuteRandom(LeptonicaSharp.Boxa,LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) If boxad is null, make a copy of boxas and permute the copy.
 Otherwise, boxad must be equal to boxas, and the operation
 is done in-place.
 (2) If boxas is empty, return an empty boxad.
 (3) This does a random in-place permutation of the boxes,
 by swapping each box in turn with a random box.  The
 result is almost guaranteed not to have any boxes in their
 original position.
 (4) MSVC rand() has MAX_RAND = 2^15 - 1, so it will not do
 a proper permutation is the number of boxes exceeds this.
 </summary>
	<remarks>
	</remarks>
	<param name="boxad">can be null or equal to boxas</param>
	<param name="boxas">input boxa</param>
	<returns>boxad with boxes permuted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSwapBoxes(LeptonicaSharp.Boxa,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="i">two indices of boxes, that are to be swapped</param>
	<param name="j">two indices of boxes, that are to be swapped</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaConvertToPta(LeptonicaSharp.Boxa,System.Int32)">
	<summary>
 Notes
 (1) If ncorners == 2, we select the UL and LR corners.
 Otherwise we save all 4 corners in this order UL, UR, LL, LR.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="ncorners">2 or 4 for the representation of each box</param>
	<returns>pta with %ncorners points for each box in the boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaConvertToBoxa(LeptonicaSharp.Pta,System.Int32)">
	<summary>
 Notes
 (1) For 2 corners, the order of the 2 points is UL, LR.
 For 4 corners, the order of points is UL, UR, LL, LR.
 (2) Each derived box is the minimum size containing all corners.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="ncorners">2 or 4 for the representation of each box</param>
	<returns>boxa with one box for each 2 or 4 points in the pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxConvertToPta(LeptonicaSharp.Box,System.Int32)">
	<summary>
 Notes
 (1) If ncorners == 2, we select the UL and LR corners.
 Otherwise we save all 4 corners in this order UL, UR, LL, LR.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="ncorners">2 or 4 for the representation of the box</param>
	<returns>pta with %ncorners points, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaConvertToBox(LeptonicaSharp.Pta)">
	<summary>
 Notes
 (1) For 2 corners, the order of the 2 points is UL, LR.
 For 4 corners, the order of points is UL, UR, LL, LR.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>box minimum containing all points in the pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSmoothSequenceLS(LeptonicaSharp.Boxa,System.Single,LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box,LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box,LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This returns a modified version of %boxas by constructing
 for each input box a box that has been linear least square fit
 (LSF) to the entire set.  The linear fitting is done to each of
 the box sides independently, after outliers are rejected,
 and it is computed separately for sequences of even and
 odd boxes.  Once the linear LSF box is found, the output box
 (in %boxad) is constructed from the input box and the LSF
 box, depending on %subflag.  See boxaModifyWithBoxa() for
 details on the use of %subflag and %maxdiff.
 (2) This is useful if, in both the even and odd sets, the box
 edges vary roughly linearly with its index in the set.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">source boxa</param>
	<param name="factor">reject outliers with widths and heights deviating from the median by more than %factor times the median variation from the median; typically ~3</param>
	<param name="subflag">L_USE_MINSIZE, L_USE_MAXSIZE, L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	<param name="maxdiff">parameter used with L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	<param name="extrapixels">pixels added on all sides (or subtracted if %extrapixels LT 0) when using L_SUB_ON_LOC_DIFF and L_SUB_ON_SIZE_DIFF</param>
	<param name="debug">1 for debug output</param>
	<returns>boxad fitted boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSmoothSequenceMedian(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box,LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box,LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) The target width of the sliding window is 2  %halfwin + 1.
 If necessary, this will be reduced by boxaWindowedMedian().
 (2) This returns a modified version of %boxas by constructing
 for each input box a box that has been smoothed with windowed
 median filtering.  The filtering is done to each of the
 box sides independently, and it is computed separately for
 sequences of even and odd boxes.  The output %boxad is
 constructed from the input boxa and the filtered boxa,
 depending on %subflag.  See boxaModifyWithBoxa() for
 details on the use of %subflag, %maxdiff and %extrapixels.
 (3) This is useful for removing noise separately in the even
 and odd sets, where the box edge locations can have
 discontinuities but otherwise vary roughly linearly within
 intervals of size %halfwin or larger.
 (4) If you don't need to handle even and odd sets separately,
 just do this
 boxam = boxaWindowedMedian(boxas, halfwin, debug);
 boxad = boxaModifyWithBoxa(boxas, boxam, subflag, maxdiff,
 extrapixels);
 boxaDestroy(boxam);
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">source boxa</param>
	<param name="halfwin">half-width of sliding window; used to find median</param>
	<param name="subflag">L_USE_MINSIZE, L_USE_MAXSIZE, L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	<param name="maxdiff">parameter used with L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	<param name="extrapixels">pixels added on all sides (or subtracted if %extrapixels LT 0) when using L_SUB_ON_LOC_DIFF and L_SUB_ON_SIZE_DIFF</param>
	<param name="debug">1 for debug output</param>
	<returns>boxad fitted boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaLinearFit(LeptonicaSharp.Boxa,System.Single,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This finds a set of boxes (boxad) where each edge of each box is
 a linear least square fit (LSF) to the edges of the
 input set of boxes (boxas).  Before fitting, outliers in
 the boxes in boxas are removed (see below).
 (2) This is useful when each of the box edges in boxas are expected
 to vary linearly with box index in the set.  These could
 be, for example, noisy measurements of similar regions
 on successive scanned pages.
 (3) Method there are 2 steps
 (a) Find and remove outliers, separately based on the deviation
 from the median of the width and height of the box.
 Use %factor to specify tolerance to outliers; use a very
 large value of %factor to avoid rejecting any box sides
 in the linear LSF.
 (b) On the remaining boxes, do a linear LSF independently
 for each of the four sides.
 (4) Invalid input boxes are not used in computation of the LSF.
 (5) The returned boxad can then be used in boxaModifyWithBoxa()
 to selectively change the boxes in boxas.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">source boxa</param>
	<param name="factor">reject outliers with widths and heights deviating from the median by more than %factor times the median deviation from the median; typically ~3</param>
	<param name="debug">1 for debug output</param>
	<returns>boxad fitted boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaWindowedMedian(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This finds a set of boxes (boxad) where each edge of each box is
 a windowed median smoothed value to the edges of the
 input set of boxes (boxas).
 (2) Invalid input boxes are filled from nearby ones.
 (3) The returned boxad can then be used in boxaModifyWithBoxa()
 to selectively change the boxes in the source boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">source boxa</param>
	<param name="halfwin">half width of window over which the median is found</param>
	<param name="debug">1 for debug output</param>
	<returns>boxad smoothed boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaModifyWithBoxa(LeptonicaSharp.Boxa,LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box,LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box,LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box)">
	<summary>
 Notes
 (1) This takes two input boxa (boxas, boxam) and constructs boxad,
 where each box in boxad is generated from the corresponding
 boxes in boxas and boxam.  The rule for constructing each
 output box depends on %subflag and %maxdiff.  Let boxs be
 a box from %boxas and boxm be a box from %boxam.
 If %subflag == L_USE_MINSIZE the output box is the intersection
 of the two input boxes.
 If %subflag == L_USE_MAXSIZE the output box is the union of the
 two input boxes; i.e., the minimum bounding rectangle for the
 two input boxes.
 If %subflag == L_SUB_ON_LOC_DIFF each side of the output box
 is found separately from the corresponding side of boxs and boxm.
 Use the boxm side, expanded by %extrapixels, if greater than
 %maxdiff pixels from the boxs side.
 If %subflag == L_SUB_ON_SIZE_DIFF the sides of the output box
 are determined in pairs from the width and height of boxs
 and boxm.  If the boxm width differs by more than %maxdiff
 pixels from boxs, use the boxm left and right sides,
 expanded by %extrapixels.  Ditto for the height difference.
 For the last two flags, each side of the output box is found
 separately from the corresponding side of boxs and boxm,
 according to these rules, where "smaller"("bigger") mean in a
 direction that decreases(increases) the size of the output box
 If %subflag == L_USE_CAPPED_MIN use the Min of boxm
 with the Max of (boxs, boxm +- %maxdiff), where the sign
 is adjusted to make the box smaller (e.g., use "+" on left side).
 If %subflag == L_USE_CAPPED_MAX use the Max of boxm
 with the Min of (boxs, boxm +- %maxdiff), where the sign
 is adjusted to make the box bigger (e.g., use "-" on left side).
 Use of the last 2 flags is further explained in (3) and (4).
 (2) boxas and boxam must be the same size.  If boxam == NULL,
 this returns a copy of boxas with a warning.
 (3) If %subflag == L_SUB_ON_LOC_DIFF, use boxm for each side
 where the corresponding sides differ by more than %maxdiff.
 Two extreme cases
 (a) set %maxdiff == 0 to use only values from boxam in boxad.
 (b) set %maxdiff == 10000 to ignore all values from boxam;
 then boxad will be the same as boxas.
 (4) If %subflag == L_USE_CAPPED_MAX use boxm if boxs is smaller;
 use boxs if boxs is bigger than boxm by an amount up to %maxdiff;
 and use boxm +- %maxdiff (the 'capped' value) if boxs is
 bigger than boxm by an amount larger than %maxdiff.
 Similarly, with interchange of Min/Max and sign of %maxdiff,
 for %subflag == L_USE_CAPPED_MIN.
 (5) If either of corresponding boxes in boxas and boxam is invalid,
 an invalid box is copied to the result.
 (6) Typical input for boxam may be the output of boxaLinearFit().
 where outliers have been removed and each side is LS fit to a line.
 (7) Unlike boxaAdjustWidthToTarget() and boxaAdjustHeightToTarget(),
 this uses two boxes and does not specify target dimensions.
 Additional constraints on the size of each box can be enforced
 by following this operation with boxaConstrainSize(), taking
 boxad as input.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="boxam">boxa with boxes used to modify those in boxas</param>
	<param name="subflag">L_USE_MINSIZE, L_USE_MAXSIZE, L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	<param name="maxdiff">parameter used with L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN, L_USE_CAPPED_MAX</param>
	<param name="extrapixels">pixels added on all sides (or subtracted if %extrapixels LT 0) when using L_SUB_ON_LOC_DIFF and L_SUB_ON_SIZE_DIFF</param>
	<returns>boxad result after adjusting boxes in boxas, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaConstrainSize(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Enumerations.L_box_size_adjustment_location,System.Int32,LeptonicaSharp.Enumerations.L_box_size_adjustment_location)">
	<summary>
 Notes
 (1) Forces either width or height (or both) of every box in
 the boxa to a specified size, by moving the indicated sides.
 (2) Not all input boxes need to be valid.  Median values will be
 used with invalid boxes.
 (3) Typical input might be the output of boxaLinearFit(),
 where each side has been fit.
 (4) Unlike boxaAdjustWidthToTarget() and boxaAdjustHeightToTarget(),
 this is not dependent on a difference threshold to change the size.
 (5) On error, a message is issued and a copy of the input boxa
 is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="width">force width of all boxes to this size; input 0 to use the median width</param>
	<param name="widthflag">L_ADJUST_SKIP, L_ADJUST_LEFT, L_ADJUST_RIGHT, or L_ADJUST_LEFT_AND_RIGHT</param>
	<param name="height">force height of all boxes to this size; input 0 to use the median height</param>
	<param name="heightflag">L_ADJUST_SKIP, L_ADJUST_TOP, L_ADJUST_BOT, or L_ADJUST_TOP_AND_BOT</param>
	<returns>boxad adjusted so all boxes are the same size</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaReconcileEvenOddHeight(LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_box_size_adjustment_location,System.Int32,LeptonicaSharp.Enumerations.L_box_size_adjustment_location,System.Single,System.Int32)">
	<summary>
 Notes
 (1) The basic idea is to reconcile differences in box height
 in the even and odd boxes, by moving the top and/or bottom
 edges in the even and odd boxes.  Choose the edge or edges
 to be moved, whether to adjust the boxes with the min
 or the max of the medians, and the threshold on the median
 difference between even and odd box heights for the operations
 to take place.  The same threshold is also used to
 determine if each individual box edge is to be adjusted.
 (2) Boxes are conditionally reset with either the same top (y)
 value or the same bottom value, or both.  The value is
 determined by the greater or lesser of the medians of the
 even and odd boxes, with the choice depending on the value
 of %op, which selects for either min or max median height.
 If the median difference between even and odd boxes is
 greater than %dely, then any individual box edge that differs
 from the selected median by more than %dely is set to
 the selected median times a factor typically near 1.0.
 (3) Note that if selecting for minimum height, you will choose
 the largest y-value for the top and the smallest y-value for
 the bottom of the box.
 (4) Typical input might be the output of boxaSmoothSequence(),
 where even and odd boxa have been independently regulated.
 (5) Require at least 3 valid even boxes and 3 valid odd boxes.
 Median values will be used for invalid boxes.
 (6) If the median height is not representative of the boxes
 in %boxas, this can make things much worse.  In that case,
 ignore the value of %op, and force pairwise equality of the
 heights, with pairwise maximal vertical extension.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">containing at least 3 valid boxes in even and odd</param>
	<param name="sides">L_ADJUST_TOP, L_ADJUST_BOT, L_ADJUST_TOP_AND_BOT</param>
	<param name="delh">threshold on median height difference</param>
	<param name="op">L_ADJUST_CHOOSE_MIN, L_ADJUST_CHOOSE_MAX</param>
	<param name="factor">GT 0.0, typically near 1.0</param>
	<param name="start">0 if pairing (0,1), etc; 1 if pairing (1,2), etc</param>
	<returns>boxad adjusted, or a copy of boxas on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaReconcilePairWidth(LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Enumerations.L_box_size_adjustment_location,System.Single,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) This reconciles differences in the width of adjacent boxes,
 by moving one side of one of the boxes in each pair.
 If the widths in the pair differ by more than some
 threshold, move either the left side for even boxes or
 the right side for odd boxes, depending on if we're choosing
 the min or max.  If choosing min, the width of the max is
 set to factor  (width of min).  If choosing max, the width
 of the min is set to factor  (width of max).
 (2) If %na exists, it is an indicator array corresponding to the
 boxes in %boxas.  If %na != NULL, only boxes with an
 indicator value of 1 are allowed to adjust; otherwise,
 all boxes can adjust.
 (3) Typical input might be the output of boxaSmoothSequence(),
 where even and odd boxa have been independently regulated.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="delw">threshold on adjacent width difference</param>
	<param name="op">L_ADJUST_CHOOSE_MIN, L_ADJUST_CHOOSE_MAX</param>
	<param name="factor">GT 0.0, typically near 1.0</param>
	<param name="na">indicator array allowing change</param>
	<returns>boxad adjusted, or a copy of boxas on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaPlotSides(LeptonicaSharp.Boxa,System.String,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This debugging function shows the progression of the four
 sides in the boxa.  There must be at least 2 boxes.
 (2) If there are invalid boxes (e.g., if only even or odd
 indices have valid boxes), this will fill them with the
 nearest valid box before plotting.
 (3) The plotfiles are put in /tmp/lept/plots/, and are named
 either with %plotname or, if NULL, a default name.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">source boxa</param>
	<param name="plotname">, can be NULL</param>
	<param name="pnal">na of left sides</param>
	<param name="pnat">na of top sides</param>
	<param name="pnar">na of right sides</param>
	<param name="pnab">na of bottom sides</param>
	<param name="ppixd">pix of the output plot</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaPlotSizes(LeptonicaSharp.Boxa,System.String,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This debugging function shows the progression of box width
 and height in the boxa.  There must be at least 2 boxes.
 (2) If there are invalid boxes (e.g., if only even or odd
 indices have valid boxes), this will fill them with the
 nearest valid box before plotting.
 (3) The plotfiles are put in /tmp/lept/plots/, and are named
 either with %plotname or, if NULL, a default name.  Make sure
 that %plotname is a string with no whitespace characters.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">source boxa</param>
	<param name="plotname">, can be NULL</param>
	<param name="pnaw">na of widths</param>
	<param name="pnah">na of heights</param>
	<param name="ppixd">pix of the output plot</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaFillSequence(LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_USE_BOXES,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This simple function replaces invalid boxes with a copy of
 the nearest valid box, selected from either the entire
 sequence (L_USE_ALL_BOXES) or from the boxes with the
 same parity (L_USE_SAME_PARITY_BOXES).  It returns a new boxa.
 (2) This is useful if you expect boxes in the sequence to
 vary slowly with index.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">with at least 3 boxes</param>
	<param name="useflag">L_USE_ALL_BOXES, L_USE_SAME_PARITY_BOXES</param>
	<param name="debug">1 for debug output</param>
	<returns>boxad filled boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSizeVariation(LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_SELECT,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This gives several measures of the smoothness of either the
 width or height of a sequence of boxes.
 (2) Statistics can be found separately for even and odd boxes.
 Additionally, the average pair-wise difference between
 adjacent even and odd boxes can be returned.
 (3) The use case is bounding boxes for scanned page images,
 where ideally the sizes should have little variance.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">at least 4 boxes</param>
	<param name="type">L_SELECT_WIDTH, L_SELECT_HEIGHT</param>
	<param name="pdel_evenodd">average absolute value of (even - odd) size pairs</param>
	<param name="prms_even">rms deviation of even boxes</param>
	<param name="prms_odd">rms deviation of odd boxes</param>
	<param name="prms_all">rms deviation of all boxes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetExtent(LeptonicaSharp.Boxa,System.Int32@,System.Int32@,LeptonicaSharp.Box@)">
	<summary>
 Notes
 (1) The returned w and h are the minimum size image
 that would contain all boxes untranslated.
 (2) If there are no valid boxes, returned w and h are 0 and
 all parameters in the returned box are 0.  This
 is not an error, because an empty boxa is valid and
 boxaGetExtent() is required for serialization.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<param name="pbox">minimum box containing all boxes in boxa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetCoverage(LeptonicaSharp.Boxa,System.Int32,System.Int32,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) The boxes in boxa are clipped to the input rectangle.
 (2)  When %exactflag == 1, we generate a 1 bpp pix of size
 wc x hc, paint all the boxes black, and count the fg pixels.
 This can take 1 msec on a large page with many boxes.
 When %exactflag == 0, we clip each box to the wc x hc region
 and sum the resulting areas.  This is faster.
 The results are the same when none of the boxes overlap
 within the wc x hc region.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="wc">dimensions of overall clipping rectangle with UL corner at (0, 0 that is covered by the boxes.</param>
	<param name="hc">dimensions of overall clipping rectangle with UL corner at (0, 0 that is covered by the boxes.</param>
	<param name="exactflag">1 for guaranteeing an exact result; 0 for getting an exact result only if the boxes do not overlap</param>
	<param name="pfract">sum of box area as fraction of w  h</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaSizeRange(LeptonicaSharp.Boxaa,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="baa"></param>
	<param name="pminw">range of dimensions of all boxes</param>
	<param name="pminh">range of dimensions of all boxes</param>
	<param name="pmaxw">range of dimensions of all boxes</param>
	<param name="pmaxh">range of dimensions of all boxes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaSizeRange(LeptonicaSharp.Boxa,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pminw">range of dimensions of box in the array</param>
	<param name="pminh">range of dimensions of box in the array</param>
	<param name="pmaxw">range of dimensions of box in the array</param>
	<param name="pmaxh">range of dimensions of box in the array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaLocationRange(LeptonicaSharp.Boxa,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pminx">range of UL corner positions</param>
	<param name="pminy">range of UL corner positions</param>
	<param name="pmaxx">range of UL corner positions</param>
	<param name="pmaxy">range of UL corner positions</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetSizes(LeptonicaSharp.Boxa,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="pnaw">widths and heights of valid boxes</param>
	<param name="pnah">widths and heights of valid boxes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetArea(LeptonicaSharp.Boxa,System.Int32@)">
	<summary>
 Notes
 (1) Measures the total area of the boxes, without regard to overlaps.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="parea">total area of all boxes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaDisplayTiled(LeptonicaSharp.Boxa,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) Displays each box separately in a tiled 32 bpp image.
 (2) If pixa is defined, it must have the same count as the boxa,
 and it will be a background over with each box is rendered.
 If pixa is not defined, the boxes will be rendered over
 blank images of identical size.
 (3) See pixaDisplayTiledInRows() for other parameters.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas"></param>
	<param name="pixa">background for each box</param>
	<param name="maxwidth">of output image</param>
	<param name="linewidth">width of box outlines, before scaling</param>
	<param name="scalefactor">applied to every box; use 1.0 for no scaling</param>
	<param name="background">0 for white, 1 for black; this is the color of the spacing between the images</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of black border added to each image; use 0 for no border</param>
	<returns>pixd of tiled images of boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaCreate(System.UInt32)">
	<summary>
 Notes
 (1) The allocated array is n + 1 bytes.  This allows room
 for null termination.
 </summary>
	<remarks>
	</remarks>
	<param name="nbytes">determines initial size of data array</param>
	<returns>l_bytea, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaInitFromMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">to be copied to the array</param>
	<param name="size">amount of data</param>
	<returns>l_bytea, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaInitFromFile(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<returns>l_bytea, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaInitFromStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>l_bytea, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaCopy(LeptonicaSharp.L_Bytea,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) If cloning, up the refcount and return a ptr to %bas.
 </summary>
	<remarks>
	</remarks>
	<param name="bas">source lba</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>clone or copy of bas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaDestroy(LeptonicaSharp.L_Bytea@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the lba.
 (2) Always nulls the input ptr.
 (3) If the data has been previously removed, the lba will
 have been nulled, so this will do nothing.
 </summary>
	<remarks>
	</remarks>
	<param name="pba">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaGetSize(LeptonicaSharp.L_Bytea)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ba"></param>
	<returns>size of stored byte array, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaGetData(LeptonicaSharp.L_Bytea,System.UInt32@)">
	<summary>
 Notes
 (1) The returned ptr is owned by %ba.  Do not free it!
 </summary>
	<remarks>
	</remarks>
	<param name="ba"></param>
	<param name="psize">size of data in lba</param>
	<returns>ptr to existing data array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaCopyData(LeptonicaSharp.L_Bytea,System.UInt32@)">
	<summary>
 Notes
 (1) The returned data is owned by the caller.  The input %ba
 still owns the original data array.
 </summary>
	<remarks>
	</remarks>
	<param name="ba"></param>
	<param name="psize">size of data in lba</param>
	<returns>copy of data in use in the data array, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaAppendData(LeptonicaSharp.L_Bytea,System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ba"></param>
	<param name="newdata">byte array to be appended</param>
	<param name="newbytes">size of data array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaAppendString(LeptonicaSharp.L_Bytea,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ba"></param>
	<param name="str">null-terminated string to be appended</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaJoin(LeptonicaSharp.L_Bytea,LeptonicaSharp.L_Bytea@)">
	<summary>
 Notes
 (1) It is a no-op, not an error, for %ba2 to be null.
 </summary>
	<remarks>
	</remarks>
	<param name="ba1"></param>
	<param name="pba2">data array is added to the one in ba1, and then ba2 is destroyed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaSplit(LeptonicaSharp.L_Bytea,System.UInt32,LeptonicaSharp.L_Bytea@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ba1">lba to split; array bytes nulled beyond the split loc</param>
	<param name="splitloc">location in ba1 to split; ba2 begins there</param>
	<param name="pba2">with data starting at splitloc</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaFindEachSequence(LeptonicaSharp.L_Bytea,System.Byte[],System.UInt32,LeptonicaSharp.L_Dna@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ba"></param>
	<param name="sequence">subarray of bytes to find in data</param>
	<param name="seqlen">length of sequence, in bytes</param>
	<param name="pda">byte positions of each occurrence of %sequence</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaWrite(System.String,LeptonicaSharp.L_Bytea,System.UInt32,System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">output file</param>
	<param name="ba"></param>
	<param name="startloc">first byte to output</param>
	<param name="endloc">last byte to output; use 0 to write to the end of the data array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_byteaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.L_Bytea,System.UInt32,System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for binary write</param>
	<param name="ba"></param>
	<param name="startloc">first byte to output</param>
	<param name="endloc">last byte to output; use 0 to write to the end of the data array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaCreate(LeptonicaSharp.Pix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">binary image; can be null</param>
	<param name="n">initial number of ptrs</param>
	<returns>ccba, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaDestroy(LeptonicaSharp.CCBorda@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pccba">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbCreate(LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>ccb or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbDestroy(LeptonicaSharp.CCBord@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pccb">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaAddCcb(LeptonicaSharp.CCBorda,LeptonicaSharp.CCBord)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<param name="ccb">to be added by insertion</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaGetCount(LeptonicaSharp.CCBorda)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<returns>count, with 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaGetCcb(LeptonicaSharp.CCBorda,System.Int32)">
	<summary>
 Notes
 (1) This returns a clone of the ccb; it must be destroyed
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<param name="index"></param>
	<returns>ccb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetAllCCBorders(LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>ccborda, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetCCBorders(LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) We are finding the exterior and interior borders
 of an 8-connected component.   This should be used
 on a pix that has exactly one 8-connected component.
 (2) Typically, pixs is a c.c. in some larger pix.  The
 input box gives its location in global coordinates.
 This box is saved, as well as the boxes for the
 borders of any holes within the c.c., but the latter
 are given in relative coords within the c.c.
 (3) The calculations for the exterior border are done
 on a pix with a 1-pixel
 added border, but the saved pixel coordinates
 are the correct (relative) ones for the input pix
 (without a 1-pixel border)
 (4) For the definition of the three tables -- xpostab[], ypostab[]
 and qpostab[] -- see above where they are defined.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, one 8-connected component</param>
	<param name="box">xul, yul, width, height in global coords</param>
	<returns>ccbord, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetOuterBordersPtaa(LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>ptaa of outer borders, in global coords, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetOuterBorderPta(LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) We are finding the exterior border of a single 8-connected
 component.
 (2) If box is NULL, the outline returned is in the local coords
 of the input pix.  Otherwise, box is assumed to give the
 location of the pix in global coordinates, and the returned
 pta will be in those global coordinates.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, one 8-connected component</param>
	<param name="box">of pixs, in global coordinates</param>
	<returns>pta of outer border, in global coords, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetOuterBorder(LeptonicaSharp.CCBord,LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) the border is saved in relative coordinates within
 the c.c. (pixs).  Because the calculation is done
 in pixb with added 1 pixel border, we must subtract
 1 from each pixel value before storing it.
 (2) the stopping condition is that after the first pixel is
 returned to, the next pixel is the second pixel.  Having
 these 2 pixels recur in sequence proves the path is closed,
 and we do not store the second pixel again.
 </summary>
	<remarks>
	</remarks>
	<param name="ccb">unfilled</param>
	<param name="pixs">for the component at hand</param>
	<param name="box">for the component, in global coords</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetHoleBorder(LeptonicaSharp.CCBord,LeptonicaSharp.Pix,LeptonicaSharp.Box,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) we trace out hole border on pixs without addition
 of single pixel added border to pixs
 (2) therefore all coordinates are relative within the c.c. (pixs)
 (3) same position tables and stopping condition as for
 exterior borders
 </summary>
	<remarks>
	</remarks>
	<param name="ccb">the exterior border is already made</param>
	<param name="pixs">for the connected component at hand</param>
	<param name="box">for the specific hole border, in relative coordinates to the c.c.</param>
	<param name="xs">first pixel on hole border, relative to c.c.</param>
	<param name="ys">first pixel on hole border, relative to c.c.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.findNextBorderPixel(System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) qpos increases clockwise from 0 to 7, with 0 at
 location with Q to left of P   Q P
 (2) this is a low-level function that does not check input
 parameters.  All calling functions should check them.
 </summary>
	<remarks>
	</remarks>
	<param name="w"></param>
	<param name="h"></param>
	<param name="data"></param>
	<param name="wpl"></param>
	<param name="px">current P</param>
	<param name="py">current P</param>
	<param name="pqpos">input current Q; new Q</param>
	<param name="pnpx">new P</param>
	<param name="pnpy">new P</param>
	<returns>0 if next pixel found; 1 otherwise</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.locateOutsideSeedPixel(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) the first and second pixels must be 8-adjacent,
 so |dx| LT= 1 and |dy| LT= 1 and both dx and dy
 cannot be 0.  There are 8 possible cases.
 (2) the seed pixel is OUTSIDE the foreground of the c.c.
 (3) these rules are for the situation where the INSIDE
 of the c.c. is on the right as you follow the border
 cw for an exterior border and ccw for a hole border.
 </summary>
	<remarks>
	</remarks>
	<param name="fpx">location of first pixel</param>
	<param name="fpy">location of first pixel</param>
	<param name="spx">location of second pixel</param>
	<param name="spy">location of second pixel</param>
	<param name="pxs">seed pixel to be returned</param>
	<param name="pys">seed pixel to be returned</param>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaGenerateGlobalLocs(LeptonicaSharp.CCBorda)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ccba">with local chain ptaa of borders computed</param>
	<returns>0 if OK, 1 on error Action this uses the pixel locs in the local ptaa, which are all relative to each c.c., to find the global pixel locations, and stores them in the global ptaa.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaGenerateStepChains(LeptonicaSharp.CCBorda)">
	<summary>
 Notes
 (1) This uses the pixel locs in the local ptaa,
 which are all relative to each c.c., to find
 the step directions for successive pixels in
 the chain, and stores them in the step numaa.
 (2) To get the step direction, use
 1   2   3
 0   P   4
 7   6   5
 where P is the previous pixel at (px, py).  The step direction
 is the number (from 0 through 7) for each relative location
 of the current pixel at (cx, cy).  It is easily found by
 indexing into a 2-d 3x3 array (dirtab).
 </summary>
	<remarks>
	</remarks>
	<param name="ccba">with local chain ptaa of borders computed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaStepChainsToPixCoords(LeptonicaSharp.CCBorda,LeptonicaSharp.Enumerations.CCB_AL_COORDS)">
	<summary>
 Notes
 (1) This uses the step chain data in each ccb to determine
 the pixel locations, either global or local,
 and stores them in the appropriate ptaa,
 either global or local.  For the latter, the
 pixel locations are relative to the c.c.
 </summary>
	<remarks>
	</remarks>
	<param name="ccba">with step chains numaa of borders</param>
	<param name="coordtype">CCB_GLOBAL_COORDS or CCB_LOCAL_COORDS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaGenerateSPGlobalLocs(LeptonicaSharp.CCBorda,LeptonicaSharp.Enumerations.CCB_SAVE_PTS)">
	<summary>
 Notes
 (1) This calculates the splocal rep if not yet made.
 (2) It uses the local pixel values in splocal, the single
 path pta, which are all relative to each c.c., to find
 the corresponding global pixel locations, and stores
 them in the spglobal pta.
 (3) This lists only the turning points it both makes a
 valid svg file and is typically about half the size
 when all border points are listed.
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<param name="ptsflag">CCB_SAVE_ALL_PTS or CCB_SAVE_TURNING_PTS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaGenerateSinglePath(LeptonicaSharp.CCBorda)">
	<summary>
 Notes
 (1) Generates a single border in local pixel coordinates.
 For each c.c., if there is just an outer border, copy it.
 If there are also hole borders, for each hole border,
 determine the smallest horizontal or vertical
 distance from the border to the outside of the c.c.,
 and find a path through the c.c. for this cut.
 We do this in a way that guarantees a pixel from the
 hole border is the starting point of the path, and
 we must verify that the path intersects the outer
 border (if it intersects it, then it ends on it).
 One can imagine pathological cases, but they may not
 occur in images of text characters and un-textured
 line graphics.
 (2) Once it is verified that the path through the c.c.
 intersects both the hole and outer borders, we
 generate the full single path for all borders in the
 c.c.  Starting at the start point on the outer
 border, when we hit a line on a cut, we take
 the cut, do the hold border, and return on the cut
 to the outer border.  We compose a pta of the
 outer border pts that are on cut paths, and for
 every point on the outer border (as we go around),
 we check against this pta.  When we find a matching
 point in the pta, we do its cut path and hole border.
 The single path is saved in the ccb.
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getCutPathForHole(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Box,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If we don't find a path, we return a pta with no pts
 in it and len = 0.
 (2) The goal is to get a reasonably short path between the
 inner and outer borders, that goes entirely within the fg of
 the pix.  This function is cheap-and-dirty, may fail for some
 holes in complex topologies such as those you might find in a
 moderately dark scanned halftone.  If it fails to find a
 path to any particular hole, it gives a warning, and because
 that hole path is not included, the hole will not be rendered.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">of c.c.</param>
	<param name="pta">of outer border</param>
	<param name="boxinner">b.b. of hole path</param>
	<param name="pdir">direction (0-3), returned; only needed for debug</param>
	<param name="plen">length of path, returned</param>
	<returns>pta of pts on cut path from the hole border to the outer border, including end points on both borders; or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaDisplayBorder(LeptonicaSharp.CCBorda)">
	<summary>
 Notes
 (1) Uses global ptaa, which gives each border pixel in
 global coordinates, and must be computed in advance
 by calling ccbaGenerateGlobalLocs().
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<returns>pix of border pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaDisplaySPBorder(LeptonicaSharp.CCBorda)">
	<summary>
 Notes
 (1) Uses spglobal pta, which gives each border pixel in
 global coordinates, one path per c.c., and must
 be computed in advance by calling ccbaGenerateSPGlobalLocs().
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<returns>pix of border pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaDisplayImage1(LeptonicaSharp.CCBorda)">
	<summary>
 Notes
 (1) Uses local ptaa, which gives each border pixel in
 local coordinates, so the actual pixel positions must
 be computed using all offsets.
 (2) For the holes, use coordinates relative to the c.c.
 (3) This is slower than Method 2.
 (4) This uses topological properties (Method 1) to do scan
 conversion to raster
 This algorithm deserves some commentary.
 I first tried the following
 ~ outer borders 4-fill from outside, stopping at the
 border, using pixFillClosedBorders()
 ~ inner borders 4-fill from outside, stopping again
 at the border, XOR with the border, and invert
 to get the hole.  This did not work, because if
 you have a hole border that looks like
 x x x x x x
 x x
 x   x x x   x
 x x o x   x
 x  x
 x  x
 x x x
 if you 4-fill from the outside, the pixel 'o' will
 not be filled!  XORing with the border leaves it OFF.
 Inverting then gives a single bad ON pixel that is not
 actually part of the hole.
 So what you must do instead is 4-fill the holes from inside.
 You can do this from a seedfill, using a pix with the hole
 border as the filling mask.  But you need to start with a
 pixel inside the hole.  How is this determined?  The best
 way is from the contour.  We have a right-hand shoulder
 rule for inside (i.e., the filled region).   Take the
 first 2 pixels of the hole border, and compute dx and dy
 (second coord minus first coord  dx = sx - fx, dy = sy - fy).
 There are 8 possibilities, depending on the values of dx and
 dy (which can each be -1, 0, and +1, but not both 0).
 These 8 cases can be broken into 4; see the simple algorithm below.
 Once you have an interior seed pixel, you fill from the seed,
 clipping with the hole border pix by filling into its invert.
 You then successively XOR these interior filled components, in any order.
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<returns>pix of image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaDisplayImage2(LeptonicaSharp.CCBorda)">
	<summary>
 Notes
 (1) Uses local chain ptaa, which gives each border pixel in
 local coordinates, so the actual pixel positions must
 be computed using all offsets.
 (2) Treats exterior and hole borders on equivalent
 footing, and does all calculations on a pix
 that spans the c.c. with a 1 pixel added boundary.
 (3) This uses topological properties (Method 2) to do scan
 conversion to raster
 (4) The algorithm is described at the top of this file (Method 2).
 It is preferred to Method 1 because it is between 1.2x and 2x
 faster than Method 1.
 </summary>
	<remarks>
	</remarks>
	<param name="ccba"></param>
	<returns>pix of image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaWrite(System.String,LeptonicaSharp.CCBorda)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="ccba"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.CCBorda)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="ccba"></param>
	<returns>0 if OK; 1 on error Format \code ccba %7d cc\n num. c.c.) (ascii)   (18B pix width 4B pix height 4B [for i = 1, ncc] ulx  4B uly  4B w    4B       -- not req'd for reconstruction h    4B       -- not req'd for reconstruction number of borders 4B [for j = 1, nb] startx  4B starty  4B [for k = 1, nb] 2 steps 1B end in z8 or 88  1B \endcode</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>ccba, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>ccba, or NULL on error \code Format  ccba %7d cc\n num. c.c.) (ascii)   (17B pix width 4B pix height 4B [for i = 1, ncc] ulx  4B uly  4B w    4B       -- not req'd for reconstruction h    4B       -- not req'd for reconstruction number of borders 4B [for j = 1, nb] startx  4B starty  4B [for k = 1, nb] 2 steps 1B end in z8 or 88  1B \endcode</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaWriteSVG(System.String,LeptonicaSharp.CCBorda)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="ccba"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ccbaWriteSVGString(System.String,LeptonicaSharp.CCBorda)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="ccba"></param>
	<returns>string in svg-formatted, that can be written to file, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaThinConnected(LeptonicaSharp.Pixa,LeptonicaSharp.Enumerations.L_THIN_G,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See notes in pixThinConnected().
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">of 1 bpp pix</param>
	<param name="type">L_THIN_FG, L_THIN_BG</param>
	<param name="connectivity">4 or 8</param>
	<param name="maxiters">max number of iters allowed; use 0 to iterate until completion</param>
	<returns>pixds, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixThinConnected(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_THIN_G,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See "Connectivity-preserving morphological image transformations,"
 Dan S. Bloomberg, in SPIE Visual Communications and Image
 Processing, Conference 1606, pp. 320-334, November 1991,
 Boston, MA.   A web version is available at
 http//www.leptonica.com/papers/conn.pdf
 (2) This is a simple interface for two of the best iterative
 morphological thinning algorithms, for 4-c.c and 8-c.c.
 Each iteration uses a mixture of parallel operations
 (using several different 3x3 Sels) and serial operations.
 Specifically, each thinning iteration consists of
 four sequential thinnings from each of four directions.
 Each of these thinnings is a parallel composite
 operation, where the union of a set of HMTs are set
 subtracted from the input.  For 4-cc thinning, we
 use 3 HMTs in parallel, and for 8-cc thinning we use 4 HMTs.
 (3) A "good" thinning algorithm is one that generates a skeleton
 that is near the medial axis and has neither pruned
 real branches nor left extra dendritic branches.
 (4) Duality between operations on fg and bg require switching
 the connectivity.  To thin the foreground, which is the usual
 situation, use type == L_THIN_FG.  Thickening the foreground
 is equivalent to thinning the background (type == L_THIN_BG),
 where the alternate connectivity gets preserved.
 For example, to thicken the fg with 2 rounds of iterations
 using 4-c.c., thin the bg using Sels that preserve 8-connectivity
 Pix pix = pixThinConnected(pixs, L_THIN_BG, 8, 2);
 (5) This makes and destroys the sela set each time. It's not a large
 overhead, but if you are calling this thousands of times on
 very small images, you can avoid the overhead; e.g.
 Sela sela = selaMakeThinSets(1, 0);  // for 4-c.c.
 Pix pix = pixThinConnectedBySet(pixs, L_THIN_FG, sela, 0);
 using set 1 for 4-c.c. and set 5 for 8-c.c operations.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="type">L_THIN_FG, L_THIN_BG</param>
	<param name="connectivity">4 or 8</param>
	<param name="maxiters">max number of iters allowed; use 0 to iterate until completion</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixThinConnectedBySet(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_THIN_G,LeptonicaSharp.Sela,System.Int32)">
	<summary>
 Notes
 (1) See notes in pixThinConnected().
 (2) This takes a sela representing one of 11 sets of HMT Sels.
 The HMTs from this set are run in parallel and the result
 is OR'd before being subtracted from the source.  For each
 iteration, this "parallel" thin is performed four times
 sequentially, for sels rotated by 90 degrees in all four
 directions.
 (3) The "parallel" and "sequential" nomenclature is standard
 in digital filtering.  Here, "parallel" operations work on the
 same source (pixd), and accumulate the results in a temp
 image before actually applying them to the source (in this
 case, using an in-place subtraction).  "Sequential" operations
 operate directly on the source (pixd) to produce the result
 (in this case, with four sequential thinning operations, one
 from each of four directions).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="type">L_THIN_FG, L_THIN_BG</param>
	<param name="sela">of Sels for parallel composite HMTs</param>
	<param name="maxiters">max number of iters allowed; use 0 to iterate until completion</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaMakeThinSets(System.Int32,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) These are specific sets of HMTs to be used in parallel for
 for thinning from each of four directions.
 (2) The sets are indexed as follows
 For thinning (e.g., run to completion)
 index = 1  sel_4_1, sel_4_2, sel_4_3
 index = 2  sel_4_1, sel_4_5, sel_4_6
 index = 3  sel_4_1, sel_4_7, sel_4_7_rot
 index = 4  sel_48_1, sel_48_1_rot, sel_48_2
 index = 5  sel_8_2, sel_8_3, sel_8_5, sel_8_6
 index = 6  sel_8_2, sel_8_3, sel_48_2
 index = 7  sel_8_1, sel_8_5, sel_8_6
 index = 8  sel_8_2, sel_8_3, sel_8_8, sel_8_9
 index = 9  sel_8_5, sel_8_6, sel_8_7, sel_8_7_rot
 For thickening (e.g., just a few iterations)
 index = 10 sel_4_2, sel_4_3
 index = 11 sel_8_4
 (3) For a very smooth skeleton, use set 1 for 4 connected and
 set 5 for 8 connected thins.
 </summary>
	<remarks>
	</remarks>
	<param name="index">into specific sets</param>
	<param name="debug">1 to output display of sela</param>
	<returns>sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbCorrelation(System.String,System.Single,System.Single,LeptonicaSharp.Enumerations.JB_S,System.String,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The images must be 1 bpp.  If they are not, you can convert
 them using convertFilesTo1bpp().
 (2) See prog/jbcorrelation for generating more output (e.g.,
 for debugging)
 </summary>
	<remarks>
	</remarks>
	<param name="dirin">directory of input images</param>
	<param name="thresh">typically ~0.8</param>
	<param name="weight">typically ~0.6</param>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<param name="rootname">for output files</param>
	<param name="firstpage">0-based</param>
	<param name="npages">use 0 for all pages in dirin</param>
	<param name="renderflag">1 to render from templates; 0 to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbRankHaus(System.String,System.Int32,System.Single,LeptonicaSharp.Enumerations.JB_S,System.String,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See prog/jbrankhaus for generating more output (e.g.,
 for debugging)
 </summary>
	<remarks>
	</remarks>
	<param name="dirin">directory of input images</param>
	<param name="size">of Sel used for dilation; typ. 2</param>
	<param name="rank">rank value of match; typ. 0.97</param>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<param name="rootname">for output files</param>
	<param name="firstpage">0-based</param>
	<param name="npages">use 0 for all pages in dirin</param>
	<param name="renderflag">1 to render from templates; 0 to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbWordsInTextlines(System.String,System.Int32,System.Int32,System.Int32,System.Single,System.Single,LeptonicaSharp.Numa@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a high-level function.  See prog/jbwords for example
 of usage.
 (2) Typically, use input of 75 - 150 ppi for finding words.
 </summary>
	<remarks>
	</remarks>
	<param name="dirin">directory of input pages</param>
	<param name="reduction">1 for full res; 2 for half-res</param>
	<param name="maxwidth">of word mask components, to be kept</param>
	<param name="maxheight">of word mask components, to be kept</param>
	<param name="thresh">on correlation; 0.80 is reasonable</param>
	<param name="weight">for handling thick text; 0.6 is reasonable</param>
	<param name="pnatl">numa with textline index for each component</param>
	<param name="firstpage">0-based</param>
	<param name="npages">use 0 for all pages in dirin</param>
	<returns>classer for the set of pages</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetWordsInTextlines(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Boxa@,LeptonicaSharp.Pixa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The input should be at a resolution of between 75 and 150 ppi.
 (2) The four size constraints on saved components are all
 scaled by %reduction.
 (3) The result are word images (and their b.b.), extracted in
 textline order, at either full res or 2x reduction,
 and with a numa giving the textline index for each word.
 (4) The pixa and boxa interfaces should make this type of
 application simple to put together.  The steps are
 ~ generate first estimate of word masks
 ~ get b.b. of these, and remove the small and big ones
 ~ extract pixa of the word images, using the b.b.
 ~ sort actual word images in textline order (2d)
 ~ flatten them to a pixa (1d), saving the textline index
 for each pix
 (5) In an actual application, it may be desirable to pre-filter
 the input image to remove large components, to extract
 single columns of text, and to deskew them.  For example,
 to remove both large components and small noisy components
 that can interfere with the statistics used to estimate
 parameters for segmenting by words, but still retain text lines,
 the following image preprocessing can be done
 Pix pixt = pixMorphSequence(pixs, "c40.1", 0);
 Pix pixf = pixSelectBySize(pixt, 0, 60, 8,
 L_SELECT_HEIGHT, L_SELECT_IF_LT, NULL);
 pixAnd(pixf, pixf, pixs);  // the filtered image
 The closing turns text lines into long blobs, but does not
 significantly increase their height.  But if there are many
 small connected components in a dense texture, this is likely
 to generate tall components that will be eliminated in pixf.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, typ. 75 - 150 ppi</param>
	<param name="minwidth">of saved components; smaller are discarded</param>
	<param name="minheight">of saved components; smaller are discarded</param>
	<param name="maxwidth">of saved components; larger are discarded</param>
	<param name="maxheight">of saved components; larger are discarded</param>
	<param name="pboxad">word boxes sorted in textline line order</param>
	<param name="ppixad">word images sorted in textline line order</param>
	<param name="pnai">index of textline for each word</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetWordBoxesInTextlines(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Boxa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The input should be at a resolution of between 75 and 150 ppi.
 (2) This is a special version of pixGetWordsInTextlines(), that
 just finds the word boxes in line order, with a numa
 giving the textline index for each word.
 See pixGetWordsInTextlines() for more details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, typ. 300 ppi</param>
	<param name="minwidth">of saved components; smaller are discarded</param>
	<param name="minheight">of saved components; smaller are discarded</param>
	<param name="maxwidth">of saved components; larger are discarded</param>
	<param name="maxheight">of saved components; larger are discarded</param>
	<param name="pboxad">word boxes sorted in textline line order</param>
	<param name="pnai">index of textline for each word</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaExtractSortedPattern(LeptonicaSharp.Boxa,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) The input is expected to come from pixGetWordBoxesInTextlines().
 (2) Each numa in the output consists of an average y coordinate
 of the first box in the textline, followed by pairs of
 x coordinates representing the left and right edges of each
 of the boxes in the textline.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa">typ. of word bounding boxes, in textline order</param>
	<param name="na">index of textline for each box in boxa</param>
	<returns>naa NUMAA, where each numa represents one textline, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaCompareImagesByBoxes(LeptonicaSharp.Numaa,LeptonicaSharp.Numaa,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) Each input numaa describes a set of sorted bounding boxes
 (sorted by textline and, within each textline, from
 left to right) in the images from which they are derived.
 See boxaExtractSortedPattern() for a description of the data
 format in each of the input numaa.
 (2) This function does an alignment between the input
 descriptions of bounding boxes for two images. The
 input parameter %nperline specifies the number of boxes
 to consider in each line when testing for a match, and
 %nreq is the required number of lines that must be well-aligned
 to get a match.
 (3) Testing by alignment has 3 steps
 (a) Generating the location of word bounding boxes from the
 images (prior to calling this function).
 (b) Listing all possible pairs of aligned rows, based on
 tolerances in horizontal and vertical positions of
 the boxes.  Specifically, all pairs of rows are enumerated
 whose first %nperline boxes can be brought into close
 alignment, based on the delx parameter for boxes in the
 line and within the overall the %maxshiftx and %maxshifty
 constraints.
 (c) Each pair, starting with the first, is used to search
 for a set of %nreq - 1 other pairs that can all be aligned
 with a difference in global translation of not more
 than (%delx, %dely).
 </summary>
	<remarks>
	</remarks>
	<param name="naa1">for image 1, formatted by boxaExtractSortedPattern()</param>
	<param name="naa2">ditto; for image 2</param>
	<param name="nperline">number of box regions to be used in each textline</param>
	<param name="nreq">number of complete row matches required</param>
	<param name="maxshiftx">max allowed x shift between two patterns, in pixels</param>
	<param name="maxshifty">max allowed y shift between two patterns, in pixels</param>
	<param name="delx">max allowed difference in x data, after alignment</param>
	<param name="dely">max allowed difference in y data, after alignment</param>
	<param name="psame">1 if %nreq row matches are found; 0 otherwise</param>
	<param name="debugflag">1 for debug output</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorContent(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This returns the color content in each component, which is
 a measure of the deviation from gray, and is defined
 as the difference between the component and the average of
 the other two components.  See the discussion at the
 top of this file.
 (2) The three numbers (rwhite, gwhite and bwhite) can be thought
 of as the values in the image corresponding to white.
 They are used to compensate for an unbalanced color white point.
 They must either be all 0 or all non-zero.  To turn this
 off, set them all to 0.
 (3) If the maximum component after white point correction,
 max(r,g,b), is less than mingray, all color components
 for that pixel are set to zero.
 Use mingray = 0 to turn off this filtering of dark pixels.
 (4) Therefore, use 0 for all four input parameters if the color
 magnitude is to be calculated without either white balance
 correction or dark filtering.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb or 8 bpp colormapped</param>
	<param name="rwhite">color value associated with white point</param>
	<param name="gwhite">color value associated with white point</param>
	<param name="bwhite">color value associated with white point</param>
	<param name="mingray">min gray value for which color is measured</param>
	<param name="ppixr">8 bpp red 'content'</param>
	<param name="ppixg">8 bpp green 'content'</param>
	<param name="ppixb">8 bpp blue 'content'</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorMagnitude(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_MAX)">
	<summary>
 Notes
 (1) For an RGB image, a gray pixel is one where all three components
 are equal.  We define the amount of color in an RGB pixel as
 a function depending on the absolute value of the differences
 between the three color components.  Consider the two largest
 of these differences.  The pixel component in common to these
 two differences is the color farthest from the other two.
 The color magnitude in an RGB pixel can be taken as one
 of these three definitions
 (a) The average of these two differences.  This is the
 average distance from the two components that are
 nearest to each other to the third component.
 (b) The minimum value of these two differences.  This is
 the intermediate value of the three distances between
 component values.  Stated otherwise, it is the
 maximum over all components of the minimum distance
 from that component to the other two components.
 (c) The maximum difference between component values.
 (2) As an example, suppose that R and G are the closest in
 magnitude.  Then the color is determined as either
 (a) The average distance of B from these two
 (|B - R| + |B - G|) / 2
 (b) The minimum distance of B from these two
 min(|B - R|, |B - G|).
 (c) The maximum distance of B from these two
 max(|B - R|, |B - G|)
 (3) The three methods for choosing the color magnitude from
 the components are selected with these flags
 (a) L_MAX_DIFF_FROM_AVERAGE_2
 (b) L_MAX_MIN_DIFF_FROM_2
 (c) L_MAX_DIFF
 (4) The three numbers (rwhite, gwhite and bwhite) can be thought
 of as the values in the image corresponding to white.
 They are used to compensate for an unbalanced color white point.
 They must either be all 0 or all non-zero.  To turn this
 off, set them all to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb or 8 bpp colormapped</param>
	<param name="rwhite">color value associated with white point</param>
	<param name="gwhite">color value associated with white point</param>
	<param name="bwhite">color value associated with white point</param>
	<param name="type">chooses the method for calculating the color magnitude L_MAX_DIFF_FROM_AVERAGE_2, L_MAX_MIN_DIFF_FROM_2, L_MAX_DIFF</param>
	<returns>pixd 8 bpp, amount of color in each source pixel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMaskOverColorPixels(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The generated mask identifies each pixel as either color or
 non-color.  For a pixel to be color, it must satisfy two
 constraints
 (a) The max difference between the r,g and b components must
 equal or exceed a threshold %threshdiff.
 (b) It must be at least %mindist (in an 8-connected way)
 from the nearest non-color pixel.
 (2) The distance constraint (b) is only applied if %mindist GT 1.
 For example, if %mindist == 2, the color pixels identified
 by (a) are eroded by a 3x3 Sel.  In general, the Sel size
 for erosion is 2  (%mindist - 1) + 1.
 Why have this constraint?  In scanned images that are
 essentially gray, color artifacts are typically introduced
 in transition regions near sharp edges that go from dark
 to light, so this allows these transition regions to be removed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb or 8 bpp colormapped</param>
	<param name="threshdiff">threshold for minimum of the max difference between components</param>
	<param name="mindist">minimum allowed distance from nearest non-color pixel</param>
	<returns>pixd 1 bpp, mask over color pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMaskOverColorRange(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb or 8 bpp colormapped</param>
	<param name="rmin">min and max allowed values for red component</param>
	<param name="rmax">min and max allowed values for red component</param>
	<param name="gmin"></param>
	<param name="gmax"></param>
	<param name="bmin"></param>
	<param name="bmax"></param>
	<returns>pixd 1 bpp, mask over color pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorFraction(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This function is asking the question to what extent does the
 image appear to have color?   The amount of color a pixel
 appears to have depends on both the deviation of the
 individual components from their average and on the average
 intensity itself.  For example, the color will be much more
 obvious with a small deviation from white than the same
 deviation from black.
 (2) Any pixel that meets these three tests is considered a
 colorful pixel
 (a) the lightest component must equal or exceed %darkthresh
 (b) the darkest component must not exceed %lightthresh
 (c) the max difference between components must equal or
 exceed %diffthresh.
 (3) The dark pixels are removed from consideration because
 they don't appear to have color.
 (4) The very lightest pixels are removed because if an image
 has a lot of "white", the color fraction will be artificially
 low, even if all the other pixels are colorful.
 (5) If pixfract is very small, there are few pixels that are neither
 black nor white.  If colorfract is very small, the pixels
 that are neither black nor white have very little color
 content.  The product 'pixfract  colorfract' gives the
 fraction of pixels with significant color content.
 (6) One use of this function is as a preprocessing step for median
 cut quantization (colorquant2.c), which does a very poor job
 splitting the color space into rectangular volume elements when
 all the pixels are near the diagonal of the color cube.  For
 octree quantization of an image with only gray values, the
 2^(level) octcubes on the diagonal are the only ones
 that can be occupied.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="darkthresh">threshold near black; if the lightest component is below this, the pixel is not considered in the statistics; typ. 20</param>
	<param name="lightthresh">threshold near white; if the darkest component is above this, the pixel is not considered in the statistics; typ. 244</param>
	<param name="diffthresh">thresh for the maximum difference between component value; below this the pixel is not considered to have sufficient color</param>
	<param name="factor">subsampling factor</param>
	<param name="ppixfract">fraction of pixels in intermediate brightness range that were considered for color content</param>
	<param name="pcolorfract">fraction of pixels that meet the criterion for sufficient color; 0.0 on error</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindColorRegions(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single[]@,LeptonicaSharp.Pix,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pixa@)">
	<summary>
 Notes
 (1) This function tries to determine if there is a significant
 color or darker region on a scanned page image, where part
 of the image is background that is either white or reddish.
 This also allows extraction of regions of colored pixels that
 have a smaller red component than blue or green components.
 (2) If %pixm exists, pixels under its fg are combined with
 dark pixels to make a mask of pixels not to be considered
 as color candidates.
 (3) There are four thresholds.
 %lightthresh compute the average value of each rgb pixel,
 and make 10 buckets by value.  If the lightest bucket gray
 value is below %lightthresh, the image is not considered
 to have a light bg, and this returns 0.0 for %colorfract.
 %darkthresh ignore pixels darker than this (typ. fg text).
 We make a 1 bpp mask of these pixels, and then dilate it to
 remove all vestiges of fg from their vicinity.
 %mindiff consider pixels with either (b - r) or (g - r)
 being at least this value, as having color.
 %colordiff consider pixels where the (max - min) difference
 of the pixel components exceeds this value, as having color.
 (4) All components of color pixels that are touching the image
 border are removed.  Additionally, all pixels within some
 normalized distance %edgefract from the image border can
 be removed.  This insures that dark pixels near the edge
 of the image are not included.
 (5) This returns in %pcolorfract the fraction of pixels that have
 color and are not in the set consisting of an OR between
 %pixm and the dilated dark pixel mask.
 (6) No masks are returned unless light color pixels are found.
 If colorfract GT 0.0 and %pcolormask1 is defined, this returns
 a 1 bpp mask with fg pixels over the color background.
 This mask may have some holes in it.
 (7) If colorfract GT 0.0 and %pcolormask2 is defined, this returns
 a version of colormask1 where small holes have been filled.
 (8) To generate a boxa of rectangular regions from the overlap
 of components in the filtered mask
 boxa1 = pixConnCompBB(colormask2, 8);
 boxa2 = boxaCombineOverlaps(boxa1, NULL);
 This is done here in debug mode.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="pixm">1 bpp mask image</param>
	<param name="factor">subsample factor; integer GT= 1</param>
	<param name="lightthresh">threshold for component average in lightest of 10 buckets; typ. 210; -1 for default</param>
	<param name="darkthresh">threshold to eliminate dark pixels (e.g., text) from consideration; typ. 70; -1 for default.</param>
	<param name="mindiff">minimum difference (b - r) and (g - r), used to find blue or green pixels; typ. 10; -1 for default</param>
	<param name="colordiff">minimum difference in (max - min) component to qualify as a color pixel; typ. 90; -1 for default</param>
	<param name="edgefract">fraction of image half-width and half-height for which color pixels are ignored; typ. 0.05.</param>
	<param name="pcolorfract">fraction of 'color' pixels found</param>
	<param name="pcolormask1">mask over background color, if any</param>
	<param name="pcolormask2">filtered mask over background color</param>
	<param name="pixadb">debug intermediate results</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixNumSignificantGrayColors(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This function is asking the question how many perceptually
 significant gray color levels is in this pix?
 A color level must meet 3 criteria to be significant
 ~ it can't be too close to black
 ~ it can't be too close to white
 ~ it must have at least some minimum fractional population
 (2) Use -1 for default values for darkthresh, lightthresh and minfract.
 (3) Choose default of darkthresh = 20, because variations in very
 dark pixels are not visually significant.
 (4) Choose default of lightthresh = 236, because document images
 that have been jpeg'd typically have near-white pixels in the
 8x8 jpeg blocks, and these should not be counted.  It is desirable
 to obtain a clean image by quantizing this noise away.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray</param>
	<param name="darkthresh">dark threshold for minimum intensity to be considered; typ. 20</param>
	<param name="lightthresh">threshold near white, for maximum intensity to be considered; typ. 236</param>
	<param name="minfract">minimum fraction of all pixels to include a level as significant; typ. 0.0001; should be LT 0.001</param>
	<param name="factor">subsample factor; integer GT= 1</param>
	<param name="pncolors">number of significant colors; 0 on error</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorsForQuantization(LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Int32@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This function finds a measure of the number of colors that are
 found in low-gradient regions of an image.  By its
 magnitude relative to some threshold (not specified in
 this function), it gives a good indication of whether
 quantization will generate posterization.   This number
 is larger for images with regions of slowly varying
 intensity (if 8 bpp) or color (if rgb). Such images, if
 quantized, may require dithering to avoid posterization,
 and lossless compression is then expected to be poor.
 (2) If pixs has a colormap, the number of colors returned is
 the number in the colormap.
 (3) It is recommended that document images be reduced to a width
 of 800 pixels before applying this function.  Then it can
 be expected that color detection will be fairly accurate
 and the number of colors will reflect both the content and
 the type of compression to be used.  For less than 15 colors,
 there is unlikely to be a halftone image, and lossless
 quantization should give both a good visual result and
 better compression.
 (4) When using the default threshold on the gradient (15),
 images (both gray and rgb) where ncolors is greater than
 about 15 will compress poorly with either lossless
 compression or dithered quantization, and they may be
 posterized with non-dithered quantization.
 (5) For grayscale images, or images without significant color,
 this returns the number of significant gray levels in
 the low-gradient regions.  The actual number of gray levels
 can be large due to jpeg compression noise in the background.
 (6) Similarly, for color images, the actual number of different
 (r,g,b) colors in the low-gradient regions (rather than the
 number of occupied level 4 octcubes) can be quite large, e.g.,
 due to jpeg compression noise, even for regions that appear
 to be of a single color.  By quantizing to level 4 octcubes,
 most of these superfluous colors are removed from the counting.
 (7) The image is tested for color.  If there is very little color,
 it is thresholded to gray and the number of gray levels in
 the low gradient regions is found.  If the image has color,
 the number of occupied level 4 octcubes is found.
 (8) The number of colors in the low-gradient regions increases
 monotonically with the threshold %thresh on the edge gradient.
 (9) Background grayscale and color quantization is often useful
 to achieve highly compressed images with little visible
 distortion.  However, gray or color washes (regions of
 low gradient) can defeat this approach to high compression.
 How can one determine if an image is expected to compress
 well using gray or color quantization?  We use the fact that
 gray washes, when quantized with less than 50 intensities,
 have posterization (visible boundaries between regions
 of uniform 'color') and poor lossless compression
 color washes, when quantized with level 4 octcubes,
 typically result in both posterization and the occupancy
 of many level 4 octcubes.
 Images can have colors either intrinsically or as jpeg
 compression artifacts.  This function reduces but does not
 completely eliminate measurement of jpeg quantization noise
 in the white background of grayscale or color images.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb; with or without colormap</param>
	<param name="thresh">binary threshold on edge gradient; 0 for default</param>
	<param name="pncolors">the number of colors found</param>
	<param name="piscolor">1 if significant color is found; 0 otherwise.  If pixs is 8 bpp, and does not have a colormap with color entries, this is 0</param>
	<param name="debug">1 to output masked image that is tested for colors; 0 otherwise</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixNumColors(LeptonicaSharp.Pix,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This returns the actual number of colors found in the image,
 even if there is a colormap.  If %factor == 1 and the
 number of colors differs from the number of entries
 in the colormap, a warning is issued.
 (2) Use %factor == 1 to find the actual number of colors.
 Use %factor GT 1 to quickly find the approximate number of colors.
 (3) For d = 2, 4 or 8 bpp grayscale, this returns the number
 of colors found in the image in 'ncolors'.
 (4) For d = 32 bpp (rgb), if the number of colors is
 greater than 256, this returns 0 in 'ncolors'.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4, 8, 32 bpp</param>
	<param name="factor">subsampling factor; integer</param>
	<param name="pncolors">the number of colors found, or 0 if there are more than 256</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetMostPopulatedColors(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Byte[]@,LeptonicaSharp.PixColormap@)">
	<summary>
 Notes
 (1) This finds the %ncolors most populated cubes in rgb colorspace,
 where the cube size depends on %sigbits as
 cube side = (256 GTGT sigbits)
 (2) The rgb color components are found at the center of the cube.
 (3) The output array of colors can be displayed using
 pixDisplayColorArray(array, ncolors, ...);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="sigbits">2-6, significant bits retained in the quantizer for each component of the input image</param>
	<param name="factor">subsampling factor; use 1 for no subsampling</param>
	<param name="ncolors">the number of most populated colors to select</param>
	<param name="parray">array of colors, each as 0xrrggbb00</param>
	<param name="pcmap">colormap of the colors</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSimpleColorQuantize(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If you want to do color quantization for real, use octcube
 or modified median cut.  This function shows that it is
 easy to make a simple quantizer based solely on the population
 in cells of a given size in rgb color space.
 (2) The %ncolors most populated cells at the %sigbits level form
 the colormap for quantizing, and this uses octcube indexing
 under the covers to assign each pixel to the nearest color.
 (3) %sigbits is restricted to 2, 3 and 4.  At the low end, the
 color discrimination is very crude; at the upper end, a set of
 similar colors can dominate the result.  Interesting results
 are generally found for %sigbits = 3 and ncolors ~ 20.
 (4) See also pixColorSegment() for a method of quantizing the
 colors to generate regions of similar color.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="sigbits">2-4, significant bits retained in the quantizer for each component of the input image</param>
	<param name="factor">subsampling factor; use 1 for no subsampling</param>
	<param name="ncolors">the number of most populated colors to select</param>
	<returns>pixd 8 bpp cmapped or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRGBHistogram(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This uses a simple, fast method of indexing into an rgb image.
 (2) The output is a 1D histogram of count vs. rgb-index, which
 uses red sigbits as the most significant and blue as the least.
 (3) This function produces the same result as pixMedianCutHisto().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="sigbits">2-6, significant bits retained in the quantizer for each component of the input image</param>
	<param name="factor">subsampling factor; use 1 for no subsampling</param>
	<returns>numa histogram of colors, indexed by RGB components, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeRGBIndexTables(System.Byte[]@,System.Byte[]@,System.Byte[]@,System.Int32)">
	<summary>
 Notes
 (1) These tables are used to map from rgb sample values to
 an rgb index, using
 rgbindex = rtab[rval] | gtab[gval] | btab[bval]
 where, e.g., if sigbits = 3, the index is a 9 bit integer
 r7 r6 r5 g7 g6 g5 b7 b6 b5
 </summary>
	<remarks>
	</remarks>
	<param name="prtab">256-entry index tables</param>
	<param name="pgtab">256-entry index tables</param>
	<param name="pbtab">256-entry index tables</param>
	<param name="sigbits">2-6, significant bits retained in the quantizer for each component of the input image</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getRGBFromIndex(System.UInt32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The %index is expressed in bits, based on the the
 %sigbits of the r, g and b components, as
 r7 r6 ... g7 g6 ... b7 b6 ...
 (2) The computed rgb values are in the center of the quantized cube.
 The extra bit that is OR'd accomplishes this.
 </summary>
	<remarks>
	</remarks>
	<param name="index">rgbindex</param>
	<param name="sigbits">2-6, significant bits retained in the quantizer for each component of the input image</param>
	<param name="prval">rgb values</param>
	<param name="pgval">rgb values</param>
	<param name="pbval">rgb values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixHasHighlightRed(LeptonicaSharp.Pix,System.Int32,System.Single,System.Single,System.Int32@,System.Single[]@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) Pixels are identified as red if they satisfy two conditions
 (a) The components satisfy (R-B)/B GT %fthresh   (red or dark fg)
 (b) The red component satisfied R GT 128  (red or light bg)
 Masks are generated for (a) and (b), and the intersection
 gives the pixels that are red but not either light bg or
 dark fg.
 (2) A typical value for fract = 0.0001, which gives sensitivity
 to an image where a small fraction of the pixels are printed
 in red.
 (3) A typical value for fthresh = 2.5.  Higher values give less
 sensitivity to red, and fewer false positives.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="factor">subsampling; an integer GT= 1; use 1 for all pixels</param>
	<param name="fract">threshold fraction of all image pixels</param>
	<param name="fthresh">threshold on a function of the components; typ. ~2.5</param>
	<param name="phasred">1 if red pixels are above threshold</param>
	<param name="pratio">normalized fraction of threshold red pixels that is actually observed</param>
	<param name="ppixdb">seed pixel mask</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorGrayRegions(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_PAINT,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates a new image, where some of the pixels in each
 box in the boxa are colorized.  See pixColorGray() for usage
 with %type and %thresh.  Note that %thresh is only used for
 rgb; it is ignored for colormapped images.
 (2) If the input image is colormapped, the new image will be 8 bpp
 colormapped if possible; otherwise, it will be converted
 to 32 bpp rgb.  Only pixels that are strictly gray will be
 colorized.
 (3) If the input image is not colormapped, it is converted to rgb.
 A "gray" value for a pixel is determined by averaging the
 components, and the output rgb value is determined from this.
 (4) This can be used in conjunction with pixHasHighlightRed() to
 add highlight color to a grayscale image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp gray, rgb, or colormapped</param>
	<param name="boxa">of regions in which to apply color</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="thresh">average value below/above which pixel is unchanged</param>
	<param name="rval">new color to paint</param>
	<param name="gval">new color to paint</param>
	<param name="bval">new color to paint</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorGray(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_PAINT,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This is an in-place operation; pixs is modified.
 If pixs is colormapped, the operation will add colors to the
 colormap.  Otherwise, pixs will be converted to 32 bpp rgb if
 it is initially 8 bpp gray.
 (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
 preserving antialiasing.
 If type == L_PAINT_DARK, it colorizes non-white pixels,
 preserving antialiasing.
 (3) If box is NULL, applies function to the entire image; otherwise,
 clips the operation to the intersection of the box and pix.
 (4) If colormapped, calls pixColorGrayCmap(), which applies the
 coloring algorithm only to pixels that are strictly gray.
 (5) For RGB, determines a "gray" value by averaging; then uses this
 value, plus the input rgb target, to generate the output
 pixel values.
 (6) thresh is only used for rgb; it is ignored for colormapped pix.
 If type == L_PAINT_LIGHT, use thresh = 0 if all pixels are to
 be colored (black pixels will be unaltered).
 In situations where there are a lot of black pixels,
 setting thresh GT 0 will make the function considerably
 more efficient without affecting the final result.
 If type == L_PAINT_DARK, use thresh = 255 if all pixels
 are to be colored (white pixels will be unaltered).
 In situations where there are a lot of white pixels,
 setting thresh LT 255 will make the function considerably
 more efficient without affecting the final result.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray, rgb or colormapped image</param>
	<param name="box">region in which to apply color; can be NULL</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="thresh">average value below/above which pixel is unchanged</param>
	<param name="rval">new color to paint</param>
	<param name="gval">new color to paint</param>
	<param name="bval">new color to paint</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorGrayMasked(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_PAINT,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates a new image, where some of the pixels under
 FG in the mask are colorized.
 (2) See pixColorGray() for usage with %type and %thresh.  Note
 that %thresh is only used for rgb; it is ignored for
 colormapped images.  In most cases, the mask will be over
 the darker parts and %type == L_PAINT_DARK.
 (3) If pixs is colormapped this calls pixColorMaskedCmap(),
 which adds colors to the colormap for pixd; it only adds
 colors corresponding to strictly gray colors in the colormap.
 Otherwise, if pixs is 8 bpp gray, pixd will be 32 bpp rgb.
 (4) If pixs is 32 bpp rgb, for each pixel a "gray" value is
 found by averaging.  This average is then used with the
 input rgb target to generate the output pixel values.
 (5) This can be used in conjunction with pixHasHighlightRed() to
 add highlight color to a grayscale image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray, rgb or colormapped image</param>
	<param name="pixm">1 bpp mask, through which to apply color</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="thresh">average value below/above which pixel is unchanged</param>
	<param name="rval">new color to paint</param>
	<param name="gval">new color to paint</param>
	<param name="bval">new color to paint</param>
	<returns>pixd colorized, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSnapColor(LeptonicaSharp.Pix,System.UInt32,System.UInt32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For inplace operation, call it this way
 pixSnapColor(pixs, pixs, ... )
 (2) For generating a new pixd
 pixd = pixSnapColor(NULL, pixs, ...)
 (3) If pixs has a colormap, it is handled by pixSnapColorCmap().
 (4) All pixels within 'diff' of 'srcval', componentwise,
 will be changed to 'dstval'.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs for in-place</param>
	<param name="pixs">colormapped or 8 bpp gray or 32 bpp rgb</param>
	<param name="srcval">color center to be selected for change 0xrrggbb00</param>
	<param name="dstval">target color for pixels 0xrrggbb00</param>
	<param name="diff">max absolute difference, applied to all components</param>
	<returns>pixd with all pixels within diff of pixval set to pixval, or pixd on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSnapColorCmap(LeptonicaSharp.Pix,System.UInt32,System.UInt32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For inplace operation, call it this way
 pixSnapCcmap(pixs, pixs, ... )
 (2) For generating a new pixd
 pixd = pixSnapCmap(NULL, pixs, ...)
 (3) pixs must have a colormap.
 (4) All colors within 'diff' of 'srcval', componentwise,
 will be changed to 'dstval'.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs for in-place</param>
	<param name="pixs">colormapped</param>
	<param name="srcval">color center to be selected for change 0xrrggbb00</param>
	<param name="dstval">target color for pixels 0xrrggbb00</param>
	<param name="diff">max absolute difference, applied to all components</param>
	<returns>pixd with all pixels within diff of srcval set to dstval, or pixd on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixLinearMapToTargetColor(LeptonicaSharp.Pix,System.UInt32,System.UInt32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For each component (r, b, g) separately, this does a piecewise
 linear mapping of the colors in pixs to colors in pixd.
 If rs and rd are the red src and dest components in %srcval and
 %dstval, then the range [0 ... rs] in pixs is mapped to
 [0 ... rd] in pixd.  Likewise, the range [rs ... 255] in pixs
 is mapped to [rd ... 255] in pixd.  And similarly for green
 and blue.
 (2) The mapping will in general change the hue of the pixels.
 However, if the src and dst targets are related by
 a transformation given by pixelFractionalShift(), the hue
 is invariant.
 (3) For inplace operation, call it this way
 pixLinearMapToTargetColor(pixs, pixs, ... )
 (4) For generating a new pixd
 pixd = pixLinearMapToTargetColor(NULL, pixs, ...)
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs for in-place</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="srcval">source color 0xrrggbb00</param>
	<param name="dstval">target color 0xrrggbb00</param>
	<returns>pixd with all pixels mapped based on the srcval/destval mapping, or pixd on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixelLinearMapToTargetColor(System.UInt32,System.UInt32,System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) This does this does a piecewise linear mapping of each
 component of %scolor to %dcolor, based on the relation
 between the components of %srcmap and %dstmap.  It is the
 same transformation, performed on a single color, as mapped
 on every pixel in a pix by pixLinearMapToTargetColor().
 (2) For each component, if the sval is larger than the smap,
 the dval will be pushed up from dmap towards white.
 Otherwise, dval will be pushed down from dmap towards black.
 This is because you can visualize the transformation as
 a linear stretching where smap moves to dmap, and everything
 else follows linearly with 0 and 255 fixed.
 (3) The mapping will in general change the hue of %scolor.
 However, if the %srcmap and %dstmap targets are related by
 a transformation given by pixelFractionalShift(), the hue
 will be invariant.
 </summary>
	<remarks>
	</remarks>
	<param name="scolor">rgb source color 0xrrggbb00</param>
	<param name="srcmap">source mapping color 0xrrggbb00</param>
	<param name="dstmap">target mapping color 0xrrggbb00</param>
	<param name="pdcolor">rgb dest color 0xrrggbb00</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixShiftByComponent(LeptonicaSharp.Pix,System.UInt32,System.UInt32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For each component (r, b, g) separately, this does a linear
 mapping of the colors in pixs to colors in pixd.
 Let rs and rd be the red src and dest components in %srcval and
 %dstval, and rval is the red component of the src pixel.
 Then for all pixels in pixs, the mapping for the red
 component from pixs to pixd is
 if (rd LT= rs)   (shift toward black)
 rval --GT (rd/rs)  rval
 if (rd GT rs) (shift toward white)
 (255 - rval) --GT ((255 - rs)/(255 - rd))  (255 - rval)
 Thus if rd LT= rs, the red component of all pixels is
 mapped by the same fraction toward white, and if rd GT rs,
 they are mapped by the same fraction toward black.
 This is essentially a different linear TRC (gamma = 1)
 for each component.  The source and target color inputs are
 just used to generate the three fractions.
 (2) Note that this mapping differs from that in
 pixLinearMapToTargetColor(), which maps rs --GT rd and does
 a piecewise stretching in between.
 (3) For inplace operation, call it this way
 pixFractionalShiftByComponent(pixs, pixs, ... )
 (4) For generating a new pixd
 pixd = pixLinearMapToTargetColor(NULL, pixs, ...)
 (5) A simple application is to color a grayscale image.
 A light background can be colored using srcval = 0xffffff00
 and picking a target background color for dstval.
 A dark foreground can be colored by using srcval = 0x0
 and choosing a target foreground color for dstval.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; either NULL or equal to pixs for in-place</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="srcval">source color 0xrrggbb00</param>
	<param name="dstval">target color 0xrrggbb00</param>
	<returns>pixd with all pixels mapped based on the srcval/destval mapping, or pixd on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixelShiftByComponent(System.Int32,System.Int32,System.Int32,System.UInt32,System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) This is a linear transformation that gives the same result
 on a single pixel as pixShiftByComponent() gives
 on a pix.  Each component is handled separately.  If
 the dest component is larger than the src, then the
 component is pushed toward 255 by the same fraction as
 the src --GT dest shift.
 </summary>
	<remarks>
	</remarks>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="srcval">source color 0xrrggbb00</param>
	<param name="dstval">target color 0xrrggbb00</param>
	<param name="ppixel">rgb value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixelFractionalShift(System.Int32,System.Int32,System.Int32,System.Single,System.UInt32@)">
	<summary>
 Notes
 (1) This transformation leaves the hue invariant, while changing
 the saturation and intensity.  It can be used for that
 purpose in pixLinearMapToTargetColor().
 (2) %fraction is in the range [-1 .... +1].  If %fraction LT 0,
 saturation is increased and brightness is reduced.  The
 opposite results if %fraction GT 0.  If %fraction == -1,
 the resulting pixel is black; %fraction == 1 results in white.
 </summary>
	<remarks>
	</remarks>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fraction">negative toward black; positive toward white</param>
	<param name="ppixel">rgb value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="depth">bpp, of pix</param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapCreateRandom(System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This sets up a colormap with random colors,
 where the first color is optionally black, the last color
 is optionally white, and the remaining colors are
 chosen randomly.
 (2) The number of randomly chosen colors is
 2^(depth) - haswhite - hasblack
 (3) Because rand() is seeded, it might disrupt otherwise
 deterministic results if also used elsewhere in a program.
 (4) rand() is not threadsafe, and will generate garbage if run
 on multiple threads at once -- though garbage is generally
 what you want from a random number generator!
 (5) Modern rand()s have equal randomness in low and high order
 bits, but older ones don't.  Here, we're just using rand()
 to choose colors for output.
 </summary>
	<remarks>
	</remarks>
	<param name="depth">bpp, of pix; 2, 4 or 8</param>
	<param name="hasblack">1 if the first color is black; 0 if no black</param>
	<param name="haswhite">1 if the last color is white; 0 if no white</param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapCreateLinear(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Colormap has equally spaced gray color values
 from black (0, 0, 0) to white (255, 255, 255).
 </summary>
	<remarks>
	</remarks>
	<param name="d">depth of pix for this colormap; 1, 2, 4 or 8</param>
	<param name="nlevels">valid in range [2, 2^d]</param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapCopy(LeptonicaSharp.PixColormap)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmaps"></param>
	<returns>cmapd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapDestroy(LeptonicaSharp.PixColormap@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pcmap">set to null</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapAddColor(LeptonicaSharp.PixColormap,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This always adds the color if there is room.
 (2) The alpha component is 255 (opaque)
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="gval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="bval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapAddRGBA(LeptonicaSharp.PixColormap,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This always adds the color if there is room.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="gval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="bval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="aval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapAddNewColor(LeptonicaSharp.PixColormap,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This only adds color if not already there.
 (2) The alpha component is 255 (opaque)
 (3) This returns the index of the new (or existing) color.
 (4) Returns 2 with a warning if unable to add this color;
 the caller should check the return value.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="gval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="bval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="pindex">index of color</param>
	<returns>0 if OK, 1 on error; 2 if unable to add color</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapAddNearestColor(LeptonicaSharp.PixColormap,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This only adds color if not already there.
 (2) The alpha component is 255 (opaque)
 (3) If it's not in the colormap and there is no room to add
 another color, this returns the index of the nearest color.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="gval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="bval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="pindex">index of color</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapUsableColor(LeptonicaSharp.PixColormap,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This checks if the color already exists or if there is
 room to add it.  It makes no change in the colormap.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="gval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="bval">colormap entry to be added; each number is in range [0, ... 255]</param>
	<param name="pusable">1 if usable; 0 if not</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapAddBlackOrWhite(LeptonicaSharp.PixColormap,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This only adds color if not already there.
 (2) The alpha component is 255 (opaque)
 (3) This sets index to the requested color.
 (4) If there is no room in the colormap, returns the index
 of the closest color.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="color">0 for black, 1 for white</param>
	<param name="pindex">index of color; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapSetBlackAndWhite(LeptonicaSharp.PixColormap,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="setblack">0 for no operation; 1 to set darkest color to black</param>
	<param name="setwhite">0 for no operation; 1 to set lightest color to white</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetCount(LeptonicaSharp.PixColormap)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetFreeCount(LeptonicaSharp.PixColormap)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<returns>free entries, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetDepth(LeptonicaSharp.PixColormap)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<returns>depth, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetMinDepth(LeptonicaSharp.PixColormap,System.Int32@)">
	<summary>
 Notes
 (1) On error, mindepth is returned as 0.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="pmindepth">minimum depth to support the colormap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapClear(LeptonicaSharp.PixColormap)">
	<summary>
 Notes
 (1) This removes the colors by setting the count to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetColor(LeptonicaSharp.PixColormap,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="prval">each color value</param>
	<param name="pgval">each color value</param>
	<param name="pbval">each color value</param>
	<returns>0 if OK, 1 if not accessible caller should check</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetColor32(LeptonicaSharp.PixColormap,System.Int32,System.UInt32@)">
	<summary>
 Notes
 (1) The returned alpha channel value is 255.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="pval32">32-bit rgb color value</param>
	<returns>0 if OK, 1 if not accessible caller should check</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetRGBA(LeptonicaSharp.PixColormap,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="prval">each color value</param>
	<param name="pgval">each color value</param>
	<param name="pbval">each color value</param>
	<param name="paval">each color value</param>
	<returns>0 if OK, 1 if not accessible caller should check</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetRGBA32(LeptonicaSharp.PixColormap,System.Int32,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="pval32">32-bit rgba color value</param>
	<returns>0 if OK, 1 if not accessible caller should check</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapResetColor(LeptonicaSharp.PixColormap,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This resets sets the color of an entry that has already
 been set and included in the count of colors.
 (2) The alpha component is 255 (opaque)
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="rval">colormap entry to be reset; each number is in range [0, ... 255]</param>
	<param name="gval">colormap entry to be reset; each number is in range [0, ... 255]</param>
	<param name="bval">colormap entry to be reset; each number is in range [0, ... 255]</param>
	<returns>0 if OK, 1 if not accessible caller should check</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapSetAlpha(LeptonicaSharp.PixColormap,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This modifies the transparency of one entry in a colormap.
 The alpha component by default is 255 (opaque).
 This is used when extracting the colormap from a PNG file
 without decoding the image.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="aval">in range [0, ... 255]</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetIndex(LeptonicaSharp.PixColormap,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap colors to search for; each number is in range [0, ... 255]</param>
	<param name="gval">colormap colors to search for; each number is in range [0, ... 255]</param>
	<param name="bval">colormap colors to search for; each number is in range [0, ... 255]</param>
	<param name="pindex">found index</param>
	<returns>0 if found, 1 if not found caller must check</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapHasColor(LeptonicaSharp.PixColormap,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="pcolor">TRUE if cmap has color; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapIsOpaque(LeptonicaSharp.PixColormap,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="popaque">TRUE if fully opaque all entries are 255</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapIsBlackAndWhite(LeptonicaSharp.PixColormap,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="pblackwhite">TRUE if the cmap has only two colors black (0,0,0) and white (255,255,255)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapCountGrayColors(LeptonicaSharp.PixColormap,System.Int32@)">
	<summary>
 Notes
 (1) This counts the unique gray colors, including black and white.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="pngray">number of gray colors</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetRankIntensity(LeptonicaSharp.PixColormap,System.Single,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rankval">0.0 for darkest, 1.0 for lightest color</param>
	<param name="pindex">the index into the colormap that corresponds to the rank intensity color</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetNearestIndex(LeptonicaSharp.PixColormap,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Returns the index of the exact color if possible, otherwise the
 index of the color closest to the target color.
 (2) Nearest color is that which is the least sum-of-squares distance
 from the target color.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="rval">colormap colors to search for; each number is in range [0, ... 255]</param>
	<param name="gval">colormap colors to search for; each number is in range [0, ... 255]</param>
	<param name="bval">colormap colors to search for; each number is in range [0, ... 255]</param>
	<param name="pindex">the index of the nearest color</param>
	<returns>0 if OK, 1 on error caller must check</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetNearestGrayIndex(LeptonicaSharp.PixColormap,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This should be used on gray colormaps.  It uses only the
 green value of the colormap.
 (2) Returns the index of the exact color if possible, otherwise the
 index of the color closest to the target color.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="val">gray value to search for; in range [0, ... 255]</param>
	<param name="pindex">the index of the nearest color</param>
	<returns>0 if OK, 1 on error caller must check</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetDistanceToColor(LeptonicaSharp.PixColormap,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Returns the L2 distance (squared) between the color at index i
 and the target color.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="index"></param>
	<param name="rval">target color</param>
	<param name="gval">target color</param>
	<param name="bval">target color</param>
	<param name="pdist">the distance from the cmap entry to target</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGetRangeValues(LeptonicaSharp.PixColormap,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) Returns, for selected components (or the average), the
 the extreme values (min and/or max) and their indices
 that are found in the cmap.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="pminval">minimum value of component</param>
	<param name="pmaxval">maximum value of component</param>
	<param name="pminindex">index of minimum value</param>
	<param name="pmaxindex">index of maximum value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGrayToColor(System.UInt32)">
	<summary>
 Notes
 (1) This creates a colormap that maps from gray to
 a specific color.  In the mapping, each component
 is faded to white, depending on the gray value.
 (2) In use, this is simply attached to a grayscale pix
 to give it the input color.
 </summary>
	<remarks>
	</remarks>
	<param name="color"></param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapColorToGray(LeptonicaSharp.PixColormap,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This creates a gray colormap from an arbitrary colormap.
 (2) In use, attach the output gray colormap to the pix
 (or a copy of it) that provided the input colormap.
 </summary>
	<remarks>
	</remarks>
	<param name="cmaps"></param>
	<param name="rwt">non-negative; these should add to 1.0</param>
	<param name="gwt">non-negative; these should add to 1.0</param>
	<param name="bwt">non-negative; these should add to 1.0</param>
	<returns>cmap gray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapConvertTo4(LeptonicaSharp.PixColormap)">
	<summary>
 Notes
 (1) This converts a 2 bpp colormap to 4 bpp.  The colors
 are the same; the output colormap entry array has size 16.
 </summary>
	<remarks>
	</remarks>
	<param name="cmaps">colormap for 2 bpp pix</param>
	<returns>cmapd   (4 bpp)</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapConvertTo8(LeptonicaSharp.PixColormap)">
	<summary>
 Notes
 (1) This converts a 2 bpp or 4 bpp colormap to 8 bpp.  The colors
 are the same; the output colormap entry array has size 256.
 </summary>
	<remarks>
	</remarks>
	<param name="cmaps">colormap for 2 bpp or 4 bpp pix</param>
	<returns>cmapd   (8 bpp)</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization of pixcmap; in ascii</param>
	<param name="size">of data in bytes; can use strlen to get it</param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapWrite(System.String,LeptonicaSharp.PixColormap)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="cmap"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.PixColormap@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream    \param[in]    cmap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.PixColormap)">
	<summary>
 Notes
 (1) Serializes a pixcmap in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized pixcmap; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="cmap"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapToArrays(LeptonicaSharp.PixColormap,System.Collections.Generic.List{System.Int32[]}@,System.Collections.Generic.List{System.Int32[]}@,System.Collections.Generic.List{System.Int32[]}@,System.Collections.Generic.List{System.Int32[]}@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="prmap">colormap arrays</param>
	<param name="pgmap">colormap arrays</param>
	<param name="pbmap">colormap arrays</param>
	<param name="pamap">alpha array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapToRGBTable(LeptonicaSharp.PixColormap,System.Byte[]@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="ptab">table of rgba values for the colormap</param>
	<param name="pncolors">size of table</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapSerializeToMemory(LeptonicaSharp.PixColormap,System.Int32,System.Int32@,System.Byte[]@)">
	<summary>
 Notes
 (1) When serializing to store in a pdf, use %cpc = 3.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="cpc">components/color 3 for rgb, 4 for rgba</param>
	<param name="pncolors">number of colors in table</param>
	<param name="pdata">binary string, cpc bytes per color</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapDeserializeFromMemory(System.Byte[],System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">binary string, 3 or 4 bytes per color</param>
	<param name="cpc">components/color 3 for rgb, 4 for rgba</param>
	<param name="ncolors"></param>
	<returns>cmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapConvertToHex(System.Byte[],System.Int32)">
	<summary>
 Notes
 (1) The number of bytes in %data is 3  ncolors.
 (2) Output is in form
 LT r0g0b0 r1g1b1 ... rngnbn GT
 where r0, g0, b0 ... are each 2 bytes of hex ascii
 (3) This is used in pdf files to express the colormap as an
 array in ascii (human-readable) format.
 </summary>
	<remarks>
	</remarks>
	<param name="data">binary serialized data</param>
	<param name="ncolors">in colormap</param>
	<returns>hexdata bracketed, space-separated ascii hex string, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapGammaTRC(LeptonicaSharp.PixColormap,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place transform
 (2) See pixGammaTRC() and numaGammaTRC() in enhance.c
 for description and use of transform
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="gamma">gamma correction; must be GT 0.0</param>
	<param name="minval">input value that gives 0 for output; can be LT 0</param>
	<param name="maxval">input value that gives 255 for output; can be GT 255</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapContrastTRC(LeptonicaSharp.PixColormap,System.Single)">
	<summary>
 Notes
 (1) This is an in-place transform
 (2) See pixContrastTRC() and numaContrastTRC() in enhance.c
 for description and use of transform
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="factor">generally between 0.0 [no enhancement] and 1.0, but can be larger than 1.0</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapShiftIntensity(LeptonicaSharp.PixColormap,System.Single)">
	<summary>
 Notes
 (1) This is an in-place transform
 (2) It does a proportional shift of the intensity for each color.
 (3) If fraction LT 0.0, it moves all colors towards (0,0,0).
 This darkens the image.
 If fraction GT 0.0, it moves all colors towards (255,255,255)
 This fades the image.
 (4) The equivalent transform can be accomplished with pixcmapGammaTRC(),
 but it is considerably more difficult (see numaGammaTRC()).
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="fraction">between -1.0 and +1.0</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapShiftByComponent(LeptonicaSharp.PixColormap,System.UInt32,System.UInt32)">
	<summary>
 Notes
 (1) This is an in-place transform
 (2) It implements pixelShiftByComponent() for each color.
 The mapping is specified by srcval and dstval.
 (3) If a component decreases, the component in the colormap
 decreases by the same ratio.  Likewise for increasing, except
 all ratios are taken with respect to the distance from 255.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<param name="srcval">source color 0xrrggbb00</param>
	<param name="dstval">target color 0xrrggbb00</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorMorph(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_MORPH,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does the morph operation on each component separately,
 and recombines the result.
 (2) Sel is a brick with all elements being hits.
 (3) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="type">L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, or L_MORPH_CLOSE</param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOctreeColorQuant(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 I found one description in the literature of octree color
 quantization, using progressive truncation of the octree,
 by M. Gervautz and W. Purgathofer in Graphics Gems, pp.
 287-293, ed. A. Glassner, Academic Press, 1990.
 Rather than setting up a fixed partitioning of the color
 space ab initio, as we do here, they allow the octree to be
 progressively truncated as new pixels are added.  They
 need to set up some data structures that are traversed
 with the addition of each 24 bit pixel, in order to decide
 either 1) in which cluster (sub-branch of the octree to put
 the pixel, or 2 whether to truncate the octree further
 to place the pixel in an existing cluster, or 3 which
 two existing clusters should be merged so that the pixel
 can be left to start a truncated leaf of the octree.  Such dynamic
 truncation is considerably more complicated, and Gervautz et
 al. did not explain how they did it in anywhere near the
 detail required to check their implementation.
 The simple method in pixFixedOctcubeQuant256 is very
 fast, and with dithering the results are good, but you
 can do better if the color clusters are selected adaptively
 from the image.  We want a method that makes much better
 use of color samples in regions of color space with high
 pixel density, while also fairly representing small numbers
 of color pixels in low density regions.  Such adaptation
 requires two passes through the image the first for generating
 the pruned tree of color cubes and the second for computing the index
 into the color table for each pixel.
 A relatively simple adaptive method is pixOctreeQuantByPopulation.
 That function first determines if the image has very few colors,
 and, if so, quantizes to those colors.  If there are more than
 256 colors, it generates a histogram of octcube leaf occupancy
 at level 4, chooses the 192 most populated such leaves as
 the first 192 colors, and sets the remaining 64 colors to the
 residual average pixel values in each of the 64 level 2 octcubes.
 This is a bit faster than pixOctreeColorQuant, and does very
 well without dithering, but for most images with dithering it
 is clearly inferior.
 We now describe pixOctreeColorQuant.  The first pass is done
 on a subsampled image, because we do not need to use all the
 pixels in the image to generate the tree.  Subsampling
 down to 0.25 1/16 of the pixels makes the program run
 about 1.3 times faster.
 Instead of dividing the color space into 256 equal-sized
 regions, we initially divide it into 2^12 or 2^15 or 2^18
 equal-sized octcubes.  Suppose we choose to use 2^18 octcubes.
 This gives us 6 octree levels.  We then prune back,
 starting from level 6.  For every cube at level 6, there
 are 8 cubes at level 5.  Call the operation of putting a
 cube aside as a color table entry CTE a "saving."
 We use a in general level-dependent threshold, and save
 those level 6 cubes that are above threshold.
 The rest are combined into the containing level 5 cube.
 If between 1 and 7 level 6 cubes within a level 5
 cube have been saved by thresholding, then the remaining
 level 6 cubes in that level 5 cube are automatically
 saved as well, without applying a threshold.  This greatly
 simplifies both the description of the CTEs and the later
 classification of each pixel as belonging to a CTE.
 This procedure is iterated through every cube, starting at
 level 5, and then 4, 3, and 2, successively.  The result is that
 each CTE contains the entirety of a set of from 1 to 7 cubes
 from a given level that all belong to a single cube at the
 level above.   We classify the CTEs in terms of the
 condition in which they are made as either being "threshold"
 or "residual."  They are "threshold" CTEs if no subcubes
 are CTEs that is, they contain every pixel within the cube
 and the number of pixels exceeds the threshold for making
 a CTE.  They are "residual" CTEs if at least one but not more
 than 7 of the subcubes have already been determined to be CTEs;
 this happens automatically -- no threshold is applied.
 If all 8 subcubes are determined to be CTEs, the cube is
 marked as having all pixels accounted for 'bleaf' = 1 but
 is not saved as a CTE.
 We stop the pruning at level 2, at which there are 64
 sub-cubes.  Any pixels not already claimed in a CTE are
 put in these cubes.
 As the cubes are saved as color samples in the color table,
 the number of remaining pixels P and the number of
 remaining colors in the color table N are recomputed,
 along with the average number of pixels P/N ppc to go in
 each of the remaining colors.  This running average number is
 used to set the threshold at the current level.
 Because we are going to very small cubes at levels 6 or 5,
 and will dither the colors for errors, it is not necessary
 to compute the color center of each cluster; we can simply
 use the center of the cube.  This gives us a minimax error
 condition the maximum error is half the width of the
 level 2 cubes -- 32 color values out of 256 -- for each color
 sample.  In practice, most of the pixels will be very much
 closer to the center of their cells.  And with dithering,
 the average pixel color in a small region will be closer still.
 Thus with the octree quantizer, we are able to capture
 regions of high color pdf probability density function in small
 but accurate CTEs, and to have only a small number of pixels
 that end up a significant distance with a guaranteed maximum
 from their true color.
 How should the threshold factor vary?  Threshold factors
 are required for levels 2, 3, 4 and 5 in the pruning stage.
 The threshold for level 5 is actually applied to cubes at
 level 6, etc.  From various experiments, it appears that
 the results do not vary appreciably for threshold values near 1.0.
 If you want more colors in smaller cubes, the threshold
 factors can be set lower than 1.0 for cubes at levels 4 and 5.
 However, if the factor is set much lower than 1.0 for
 levels 2 and 3, we can easily run out of colors.
 We put aside 64 colors in the calculation of the threshold
 values, because we must have 64 color centers at level 2,
 that will have very few pixels in most of them.
 If we reduce the factor for level 5 to 0.4, this will
 generate many level 6 CTEs, and consequently
 many residual cells will be formed up from those leaves,
 resulting in the possibility of running out of colors.
 Remember, the residual CTEs are mandatory, and are formed
 without using the threshold, regardless of the number of
 pixels that are absorbed.
 The implementation logically has four parts
 1 accumulation into small, fixed cells
 2 pruning back into selected CTE cubes
 3 organizing the CTEs for fast search to find
 the CTE to which any image pixel belongs
 4 doing a second scan to code the image pixels by CTE
 Step 1 is straightforward; we use 2^15 cells.
 We've already discussed how the pruning step 2 will be performed.
 Steps 3) and (4 are related, in that the organization
 used by step 3 determines how the search actually
 takes place for each pixel in step 4.
 There are many ways to do step 3.  Let's explore a few.
 a The simplest is to order the cubes from highest occupancy
 to lowest, and traverse the list looking for the deepest
 match.  To make this more efficient, so that we know when
 to stop looking, any cube that has separate CTE subcubes
 would be marked as such, so that we know when we hit a
 true leaf.
 b Alternatively, we can order the cubes by highest
 occupancy separately each level, and work upward,
 starting at level 5, so that when we find a match we
 know that it will be correct.
 c Another approach would be to order the cubes by
 "address" and use a hash table to find the cube
 corresponding to a pixel color.  I don't know how to
 do this with a variable length address, as each CTE
 will have 3n bits, where n is the level.
 d Another approach entirely is to put the CTE cubes into
 a tree, in such a way that starting from the root, and
 using 3 bits of address at a time, the correct branch of
 each octree can be taken until a leaf is found.  Because
 a given cube can be both a leaf and also have branches
 going to sub-cubes, the search stops only when no
 marked subcubes have addresses that match the given pixel.
 In the tree method, we can start with a dense infrastructure,
 and place the leaves corresponding to the N colors
 in the tree, or we can grow from the root only those
 branches that end directly on leaves.
 What we do here is to take approach d, and implement the tree
 "virtually", as a set of arrays, one array for each level
 of the tree.   Initially we start at level 5, an array with
 2^15 cubes, each with 8 subcubes.  We then build nodes at
 levels closer to the root; at level 4 there are 2^12 nodes
 each with 8 subcubes; etc.  Using these arrays has
 several advantages
 ~  We don't need to keep track of links between cubes
 and subcubes, because we can use the canonical
 addressing on the cell arrays directly to determine
 which nodes are parent cubes and which are sub-cubes.
 ~  We can prune directly on this tree
 ~  We can navigate the pruned tree quickly to classify
 each pixel in the image.
 Canonical addressing guarantees that the i-th node at level k
 has 8 subnodes given by the 8i ... 8i+7 nodes at level k+1.
 The pruning step works as follows.  We go from the lowest
 level up.  At each level, the threshold is found from the
 product of a factor near 1.0 and the ratio of unmarked pixels
 to remaining colors minus the 64.  We march through
 the space, sequentially considering a cube and its 8 subcubes.
 We first check those subcubes that are not already
 marked as CTE to see if any are above threshold, and if so,
 generate a CTE and mark them as such.
 We then determine if any of the subcubes have been marked.
 If so, and there are subcubes that are not marked,
 we generate a CTE for the cube from the remaining unmarked
 subcubes; this is mandatory and does not depend on how many
 pixels are in the set of subcubes.  If none of the subcubes
 are marked, we aggregate their pixels into the cube
 containing them, but do not mark it as a CTE; that
 will be determined when iterating through the next level up.
 When all the pixels in a cube are accounted for in one or more
 colors, we set the boolean 'bleaf' to true.  This is the
 flag used to mark the cubes in the pruning step.  If a cube
 is marked, and all 8 subcubes are marked, then it is not
 itself given a CTE because all pixels have already been
 accounted for.
 Note that the pruning of the tree and labelling of the CTEs
 step 2 accomplishes step 3 implicitly, because the marked
 and pruned tree is ready for use in labelling each pixel
 in step 4.  We now, for every pixel in the image, traverse
 the tree from the root, looking for the lowest cube that is a leaf.
 At each level we have a cube and subcube.  If we reach a subcube
 leaf that is marked 0, we know that the color is stored in the
 cube above, and we've found the CTE.  Otherwise, the subcube
 leaf is marked 1.  If we're at the last level, we've reached
 the final leaf and must use it.  Otherwise, continue the
 process at the next level down.
 For robustness, efficiency and high quality output, we do the following
 (1) Measure the color content of the image.  If there is very little
 color, quantize in grayscale.
 (2) For efficiency, build the octree with a subsampled image if the
 image is larger than some threshold size.
 (3) Reserve an extra set of colors to prevent running out of colors
 when pruning the octree; specifically, during the assignment
 of those level 2 cells out of the 64 that have unassigned
 pixels.  The problem of running out is more likely to happen
 with small images, because the estimation we use for the
 number of pixels available is not accurate.
 (4) In the unlikely event that we run out of colors, the dithered
 image can be very poor.  As this would only happen with very
 small images, and dithering is not particularly noticeable with
 such images, turn it off.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; 24-bit color</param>
	<param name="colors">in colormap; some number in range [128 ... 256]; the actual number of colors used will be smaller</param>
	<param name="ditherflag">1 to dither, 0 otherwise</param>
	<returns>pixd 8 bpp with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOctreeColorQuantGeneral(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) The parameters %validthresh and %colorthresh are used to
 determine if color quantization should be used on an image,
 or whether, instead, it should be quantized in grayscale.
 If the image has very few non-white and non-black pixels, or
 if those pixels that are non-white and non-black are all
 very close to either white or black, it is usually better
 to treat the color as accidental and to quantize the image
 to gray only.  These parameters are useful if you know
 something a priori about the image.  Perhaps you know that
 there is only a very small fraction of color pixels, but they're
 important to preserve; then you want to use a smaller value for
 these parameters.  To disable conversion to gray and force
 color quantization, use %validthresh = 0.0 and %colorthresh = 0.0.
 (2) See pixOctreeColorQuant() for algorithmic and implementation
 details.  This function has a more general interface.
 (3) See pixColorFraction() for computing the fraction of pixels
 that are neither white nor black, and the fraction of those
 pixels that have little color.  From the documentation there
 If pixfract is very small, there are few pixels that are
 neither black nor white.  If colorfract is very small,
 the pixels that are neither black nor white have very
 little color content.  The product 'pixfract  colorfract'
 gives the fraction of pixels with significant color content.
 We test against the product %validthresh  %colorthresh
 to find color in images that have either very few
 intermediate gray pixels or that have many such gray pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; 24-bit color</param>
	<param name="colors">in colormap; some number in range [128 ... 240]; the actual number of colors used will be smaller</param>
	<param name="ditherflag">1 to dither, 0 otherwise</param>
	<param name="validthresh">minimum fraction of pixels neither near white nor black, required for color quantization; typically ~0.01, but smaller for images that have color but are nearly all white</param>
	<param name="colorthresh">minimum fraction of pixels with color that are not near white or black, that are required for color quantization; typ. ~0.01, but smaller for images that have color along with a significant fraction of gray</param>
	<returns>pixd 8 bit with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeRGBToIndexTables(System.Byte[]@,System.Byte[]@,System.Byte[]@,System.Int32)">
	<summary>
 Set up tables.  e.g., for cqlevels = 5, we need an integer 0 LT i LT 2^15
 rtab = 0  i7  0   0  i6  0   0  i5  0   0   i4  0   0   i3  0   0
 gtab = 0  0   i7  0   0  i6  0   0  i5  0   0   i4  0   0   i3  0
 btab = 0  0   0   i7  0  0   i6  0  0   i5  0   0   i4  0   0   i3
 The tables are then used to map from rbg --GT index as follows
 index = 0  r7  g7  b7  r6  g6  b6  r5  g5  b5  r4  g4  b4  r3  g3  b3
 e.g., for cqlevels = 4, we map to
 index = 0  0   0   0   r7  g7  b7  r6  g6  b6  r5  g5  b5  r4  g4  b4
 This may look a bit strange.  The notation 'r7' means the MSBit of
 the r value which has 8 bits, going down from r7 to r0.
 Keep in mind that r7 is actually the r component bit for level 1 of
 the octtree.  Level 1 is composed of 8 octcubes, represented by
 the bits r7 g7 b7, which divide the entire color space into
 8 cubes.  At level 2, each of these 8 octcubes is further divided into
 8 cubes, each labeled by the second most significant bits r6 g6 b6
 of the rgb color.
 </summary>
	<remarks>
	</remarks>
	<param name="prtab">tables</param>
	<param name="pgtab">tables</param>
	<param name="pbtab">tables</param>
	<param name="cqlevels">can be 1, 2, 3, 4, 5 or 6</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getOctcubeIndexFromRGB(System.Int32,System.Int32,System.Int32,System.Byte[],System.Byte[],System.Byte[],System.UInt32@)">
	<summary>
 Notes
 No error checking!
 </summary>
	<remarks>
	</remarks>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="rtab">generated with makeRGBToIndexTables()</param>
	<param name="gtab">generated with makeRGBToIndexTables()</param>
	<param name="btab">generated with makeRGBToIndexTables()</param>
	<param name="pindex">found index</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOctreeQuantByPopulation(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This color quantization method works very well without
 dithering, using octcubes at two different levels
 (a) the input %level, which is either 3 or 4
 (b) level 2 (64 octcubes to cover the entire color space)
 (2) For best results, using %level = 4 is recommended.
 Why do we provide an option for using level 3?  Because
 there are 512 octcubes at level 3, and for many images
 not more than 256 are filled.  As a result, on some images
 a very accurate quantized representation is possible using
 %level = 3.
 (3) This first breaks up the color space into octcubes at the
 input %level, and computes, for each octcube, the average
 value of the pixels that are in it.
 (4) Then there are two possible situations
 (a) If there are not more than 256 populated octcubes,
 it returns a cmapped pix with those values assigned.
 (b) Otherwise, it selects 192 octcubes containing the largest
 number of pixels and quantizes pixels within those octcubes
 to their average.  Then, to handle the residual pixels
 that are not in those 192 octcubes, it generates a
 level 2 octree consisting of 64 octcubes, and within
 each octcube it quantizes the residual pixels to their
 average within each of those level 2 octcubes.
 (5) Unpopulated level 2 octcubes are represented in the colormap
 by their centers.  This, of course, has no effect unless
 dithering is used for the output image.
 (6) The depth of pixd is the minimum required to support the
 number of colors found at %level; namely, 2, 4 or 8.
 (7) This function works particularly well on images such as maps,
 where there are a relatively small number of well-populated
 colors, but due to antialiasing and compression artifacts
 there may be a large number of different colors.  This will
 pull out and represent accurately the highly populated colors,
 while still making a reasonable approximation for the others.
 (8) The highest level of octcubes allowed is 4.  Use of higher
 levels typically results in having a small fraction of
 pixels in the most populated 192 octcubes.  As a result,
 most of the pixels are represented at level 2, which is
 not sufficiently accurate.
 (9) Dithering shows artifacts on some images.  If you plan to
 dither, pixOctreeColorQuant() and pixFixedOctcubeQuant256()
 usually give better results.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="level">significant bits for each of RGB; valid for {3,4}, Use 0 for default (level 4; recommended</param>
	<param name="ditherflag">1 to dither, 0 otherwise</param>
	<returns>pixd quantized to octcubes or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOctreeQuantNumColors(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 pixOctreeColorQuant is very flexible in terms of the relative
 depth of different cubes of the octree.   By contrast, this function,
 pixOctreeQuantNumColors is also adaptive, but it supports octcube
 leaves at only two depths a smaller depth that guarantees
 full coverage of the color space and octcubes at one level
 deeper for more accurate colors.  Its main virutes are simplicity
 and speed, which are both derived from the natural indexing of
 the octcubes from the RGB values.
 Before describing pixOctreeQuantNumColors, consider an even simpler
 approach for 4 bpp with either 8 or 16 colors.  With 8 colors,
 you simply go to level 1 octcubes and use the average color
 found in each cube.  For 16 colors, you find which of the three
 colors has the largest variance at the second level, and use two
 indices for that color.  The result is quite poor, because 1 some
 of the cubes are nearly empty and 2 you don't get much color
 differentiation for the extra 8 colors.  Trust me, this method may
 be simple, but it isn't worth anything.
 In pixOctreeQuantNumColors, we generate colormapped images at
 either 4 bpp or 8 bpp.  For 4 bpp, we have a minimum of 8 colors
 for the level 1 octcubes, plus up to 8 additional colors that
 are determined from the level 2 popularity.  If the number of colors
 is between 8 and 16, the output is a 4 bpp image.  If the number of
 colors is greater than 16, the output is a 8 bpp image.
 We use a priority queue, implemented with a heap, to select the
 requisite number of most populated octcubes at the deepest level
 level 2 for 64 or fewer colors; level 3 for more than 64 colors.
 These are combined with one color for each octcube one level above,
 which is used to span the color space of octcubes that were not
 included at the deeper level.
 If the deepest level is 2, we combine the popular level 2 octcubes
 out of a total of 64 with the 8 level 1 octcubes.  If the deepest
 level is 3, we combine the popular level 3 octcubes out of a
 total 512 with the 64 level 2 octcubes that span the color space.
 In the latter case, we require a minimum of 64 colors for the level 2
 octcubes, plus up to 192 additional colors determined from level 3
 popularity.
 The parameter 'maxlevel' is the deepest octcube level that is used.
 The implementation also uses two LUTs, which are employed in
 two successive traversals of the dest image.  The first maps
 from the src octindex at 'maxlevel' to the color table index,
 which is the value that is stored in the 4 or 8 bpp dest pixel.
 The second LUT maps from that colormap value in the dest to a
 new colormap value for a minimum sized colormap, stored back in
 the dest.  It is used to remove any color map entries that
 correspond to color space regions that have no pixels in the
 source image.  These regions can be either from the higher level
 e.g., level 1 for 4 bpp, or from octcubes at 'maxlevel' that
 are unoccupied.  This remapping results in the minimum number
 of colors used according to the constraints induced by the
 input 'maxcolors'.  We also compute the average R, G and B color
 values in each region of the color space represented by a
 colormap entry, and store them in the colormap.
 The maximum number of colors is input, which determines the
 following properties of the dest image and octcube regions used
 Number of colors   dest image depth   maxlevel
 ----------------   ----------------   --------
 8 to 16   4 bpp   2
 17 to 64  8 bpp   2
 65 to 256 8 bpp   3
 It may turn out that the number of extra colors, beyond the
 minimum 8 and 64 for maxlevel 2 and 3, respectively, is larger
 than the actual number of occupied cubes at these levels
 In that case, all the pixels are contained in this
 subset of cubes at maxlevel, and no colormap colors are needed
 to represent the remainder pixels one level above.  Thus, for
 example, in use one often finds that the pixels in an image
 occupy less than 192 octcubes at level 3, so they can be represented
 by a colormap for octcubes at level 3 only.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="maxcolors">8 to 256; the actual number of colors used may be less than this</param>
	<param name="subsample">factor for computing color distribution; use 0 for default</param>
	<returns>pixd 4 or 8 bpp, colormapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOctcubeQuantMixedWithGray(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Generates a colormapped image, where the colormap table values
 have two components octcube values representing pixels with
 color content, and grayscale values for the rest.
 (2) The threshold (delta) is the maximum allowable difference of
 the max abs value of | r - g |, | r - b | and | g - b |.
 (3) The octcube values are the averages of all pixels that are
 found in the octcube, and that are far enough from gray to
 be considered color.  This can roughly be visualized as all
 the points in the rgb color cube that are not within a "cylinder"
 of diameter approximately 'delta' along the main diagonal.
 (4) We want to guarantee full coverage of the rgb color space; thus,
 if the output depth is 4, the octlevel is 1 (2 x 2 x 2 = 8 cubes)
 and if the output depth is 8, the octlevel is 2 (4 x 4 x 4
 = 64 cubes).
 (5) Consequently, we have the following constraint on the number
 of allowed gray levels for 4 bpp, 8; for 8 bpp, 192.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="depth">of output pix</param>
	<param name="graylevels">graylevels (must be GT 1)</param>
	<param name="delta">threshold for deciding if a pix is color or gray</param>
	<returns>pixd     quantized to octcube and gray levels or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFixedOctcubeQuant256(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 This simple 1-pass color quantization works by breaking the
 color space into 256 pieces, with 3 bits quantized for each of
 red and green, and 2 bits quantized for blue.  We shortchange
 blue because the eye is least sensitive to blue.  This
 division of the color space is into two levels of octrees,
 followed by a further division by 4 not 8, where both
 blue octrees have been combined in the third level.
 The color map is generated from the 256 color centers by
 taking the representative color to be the center of the
 cell volume.  This gives a maximum error in the red and
 green values of 16 levels, and a maximum error in the
 blue sample of 32 levels.
 Each pixel in the 24-bit color image is placed in its containing
 cell, given by the relevant MSbits of the red, green and blue
 samples.  An error-diffusion dithering is performed on each
 color sample to give the appearance of good average local color.
 Dithering is required; without it, the contouring and visible
 color errors are very bad.
 I originally implemented this algorithm in two passes,
 where the first pass was used to compute the weighted average
 of each sample in each pre-allocated region of color space.
 The idea was to use these centroids in the dithering algorithm
 of the second pass, to reduce the average error that was
 being dithered.  However, with dithering, there is
 virtually no difference, so there is no reason to make the
 first pass.  Consequently, this 1-pass version just assigns
 the pixels to the centers of the pre-allocated cells.
 We use dithering to spread the difference between the sample
 value and the location of the center of the cell.  For speed
 and simplicity, we use integer dithering and propagate only
 to the right, down, and diagonally down-right, with ratios
 3/8, 3/8 and 1/4, respectively.  The results should be nearly
 as good, and a bit faster, with propagation only to the right
 and down.
 The algorithm is very fast, because there is no search,
 only fast generation of the cell index for each pixel.
 We use a simple mapping from the three 8 bit rgb samples
 to the 8 bit cell index; namely, r7 r6 r5 g7 g6 g5 b7 b6.
 This is not in an octcube format, but it doesn't matter.
 There are no storage requirements.  We could keep a
 running average of the center of each sample in each
 cluster, rather than using the center of the cell, but
 this is just extra work, esp. with dithering.
 This method gives surprisingly good results with dithering.
 However, without dithering, the loss of color accuracy is
 evident in regions that are very light or that have subtle
 blending of colors.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; 24-bit color</param>
	<param name="ditherflag">1 for dithering; 0 for no dithering</param>
	<returns>pixd 8 bit with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFewColorsOctcubeQuant1(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Generates a colormapped image, where the colormap table values
 are the averages of all pixels that are found in the octcube.
 (2) This fails if there are more than 256 colors (i.e., more
 than 256 occupied octcubes).
 (3) Often level 3 (512 octcubes) will succeed because not more
 than half of them are occupied with 1 or more pixels.
 (4) The depth of the result, which is either 2, 4 or 8 bpp,
 is the minimum required to hold the number of colors that
 are found.
 (5) This can be useful for quantizing orthographically generated
 images such as color maps, where there may be more than 256 colors
 because of aliasing or jpeg artifacts on text or lines, but
 there are a relatively small number of solid colors.  Then,
 use with level = 3 can often generate a compact and accurate
 representation of the original RGB image.  For this purpose,
 it is better than pixFewColorsOctcubeQuant2(), because it
 uses the average value of pixels in the octcube rather
 than the first found pixel.  It is also simpler to use,
 because it generates the histogram internally.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="level">significant bits for each of RGB; valid in [1...6]</param>
	<returns>pixd quantized to octcube or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFewColorsOctcubeQuant2(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Numa,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Generates a colormapped image, where the colormap table values
 are the averages of all pixels that are found in the octcube.
 (2) This fails if there are more than 256 colors (i.e., more
 than 256 occupied octcubes).
 (3) Often level 3 (512 octcubes) will succeed because not more
 than half of them are occupied with 1 or more pixels.
 (4) For an image with not more than 256 colors, it is unlikely
 that two pixels of different color will fall in the same
 octcube at level = 4.   However it is possible, and this
 function optionally returns %nerrors, the number of pixels
 where, because more than one color is in the same octcube,
 the pixel color is not exactly reproduced in the colormap.
 The colormap for an occupied leaf of the octree contains
 the color of the first pixel encountered in that octcube.
 (5) This differs from pixFewColorsOctcubeQuant1(), which also
 requires not more than 256 occupied leaves, but represents
 the color of each leaf by an average over the pixels in
 that leaf.  This also requires precomputing the histogram
 of occupied octree leaves, which is generated using
 pixOctcubeHistogram().
 (6) This is used in pixConvertRGBToColormap() for images that
 are determined, by their histogram, to have relatively few
 colors.  This typically happens with orthographically
 produced images (as oppopsed to natural images), where
 it is expected that most of the pixels within a leaf
 octcube have exactly the same color, and quantization to
 that color is lossless.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="level">of octcube indexing, for histogram 3, 4, 5, 6</param>
	<param name="na">histogram of pixel occupation in octree leaves at given level</param>
	<param name="ncolors">number of occupied octree leaves at given level</param>
	<param name="pnerrors">num of pixels not exactly represented in the colormap</param>
	<returns>pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFewColorsOctcubeQuantMixed(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) First runs pixFewColorsOctcubeQuant1().  If this succeeds,
 it separates the color from gray(ish) entries in the cmap,
 and re-quantizes the gray pixels.  The result has some pixels
 in color and others in gray.
 (2) This fails if there are more than 256 colors (i.e., more
 than 256 occupied octcubes in the color quantization).
 (3) Level 3 (512 octcubes) will usually succeed because not more
 than half of them are occupied with 1 or more pixels.
 (4) This uses the criterion from pixColorFraction() for deciding
 if a colormap entry is color; namely, if the color components
 are not too close to either black or white, and the maximum
 difference between component values equals or exceeds a threshold.
 (5) For quantizing the gray pixels, it uses a histogram-based
 method where input parameters determining the buckets are
 the minimum population fraction and the maximum allowed size.
 (6) Recommended input parameters are
 %level  3 or 4  (3 is default)
 %darkthresh  20
 %lightthresh 244
 %diffthresh 20
 %minfract 0.05
 %maxspan 15
 These numbers are intended to be conservative (somewhat over-
 sensitive) in color detection,  It's usually better to pay
 extra with octcube quantization of a grayscale image than
 to use grayscale quantization on an image that has some
 actual color.  Input 0 on any of these to get the default.
 (7) This can be useful for quantizing orthographically generated
 images such as color maps, where there may be more than 256 colors
 because of aliasing or jpeg artifacts on text or lines, but
 there are a relatively small number of solid colors.  It usually
 gives results that are better than pixOctcubeQuantMixedWithGray(),
 both in size and appearance.  But it is a bit slower.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="level">significant octcube bits for each of RGB; valid in [1...6]; use 0 for default</param>
	<param name="darkthresh">threshold near black; if the lightest component is below this, the pixel is not considered to be gray or color; uses 0 for default</param>
	<param name="lightthresh">threshold near white; if the darkest component is above this, the pixel is not considered to be gray or color; use 0 for default</param>
	<param name="diffthresh">thresh for the max difference between component values; for differences below this, the pixel is considered to be gray; use 0 for default</param>
	<param name="minfract">min fraction of pixels for gray histo bin; use 0.0 for default</param>
	<param name="maxspan">max size of gray histo bin; use 0 for default</param>
	<returns>pixd 8 bpp, quantized to octcube for pixels that are not gray; gray pixels are quantized separately over the full gray range, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFixedOctcubeQuantGenRGB(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Unlike the other color quantization functions, this one
 generates an rgb image.
 (2) The pixel values are quantized to the center of each octcube
 (at the specified level) containing the pixel.  They are
 not quantized to the average of the pixels in that octcube.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="level">significant bits for each of r,g,b</param>
	<returns>pixd rgb; quantized to octcube centers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixQuantFromCmap(LeptonicaSharp.Pix,LeptonicaSharp.PixColormap,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_AN_DISTANCE)">
	<summary>
 Notes
 (1) This is a top-level wrapper for quantizing either grayscale
 or rgb images to a specified colormap.
 (2) The actual output depth is constrained by %mindepth and
 by the number of colors in %cmap.
 (3) For grayscale, %level and %metric are ignored.
 (4) If the cmap has color and pixs is grayscale, the color is
 removed from the cmap before quantizing pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale without cmap, or 32 bpp rgb</param>
	<param name="cmap">to quantize to; insert copy into dest pix</param>
	<param name="mindepth">minimum depth of pixd can be 2, 4 or 8 bpp</param>
	<param name="level">of octcube used for finding nearest color in cmap</param>
	<param name="metric">L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
	<returns>pixd  2, 4 or 8 bpp, colormapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOctcubeQuantFromCmap(LeptonicaSharp.Pix,LeptonicaSharp.PixColormap,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_AN_DISTANCE)">
	<summary>
 Notes
 (1) In typical use, we are doing an operation, such as
 interpolative scaling, on a colormapped pix, where it is
 necessary to remove the colormap before the operation.
 We then want to re-quantize the RGB result using the same
 colormap.
 (2) The level is used to divide the color space into octcubes.
 Each input pixel is, in effect, placed at the center of an
 octcube at the given level, and it is mapped into the
 exact color (given in the colormap) that is the closest
 to that location.  We need to know that distance, for each color
 in the colormap.  The higher the level of the octtree, the smaller
 the octcubes in the color space, and hence the more accurately
 we can determine the closest color in the colormap; however,
 the size of the LUT, which is the total number of octcubes,
 increases by a factor of 8 for each increase of 1 level.
 The time required to acquire a level 4 mapping table, which has
 about 4K entries, is less than 1 msec, so that is the
 recommended minimum size to be used.  At that size, the
 octcubes have their centers 16 units apart in each (r,g,b)
 direction.  If two colors are in the same octcube, the one
 closest to the center will always be chosen.  The maximum
 error for any component occurs when the correct color is
 at a cube corner and there is an incorrect color just inside
 the cube next to the opposite corner, giving an error of
 14 units (out of 256) for each component.   Using a level 5
 mapping table reduces the maximum error to 6 units.
 (3) Typically you should use the Euclidean metric, because the
 resulting voronoi cells (which are generated using the actual
 colormap values as seeds) are convex for Euclidean distance
 but not for Manhattan distance.  In terms of the octcubes,
 convexity of the voronoi cells means that if the 8 corners
 of any cube (of which the octcubes are special cases)
 are all within a cell, then every point in the cube will
 lie within the cell.
 (4) The depth of the output pixd is equal to the maximum of
 (a) %mindepth and (b) the minimum (2, 4 or 8 bpp) necessary
 to hold the indices in the colormap.
 (5) We build a mapping table from octcube to colormap index so
 that this function can run in a time (otherwise) independent
 of the number of colors in the colormap.  This avoids a
 brute-force search for the closest colormap color to each
 pixel in the image.
 (6) This is similar to the function pixAssignToNearestColor()
 used for color segmentation.
 (7) Except for very small images or when using level GT 4,
 it takes very little time to generate the tables,
 compared to the generation of the colormapped dest pix,
 so one would not typically use the low-level version.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="cmap">to quantize to; insert copy into dest pix</param>
	<param name="mindepth">minimum depth of pixd can be 2, 4 or 8 bpp</param>
	<param name="level">of octcube used for finding nearest color in cmap</param>
	<param name="metric">L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
	<returns>pixd  2, 4 or 8 bpp, colormapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOctcubeHistogram(LeptonicaSharp.Pix,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Input NULL for ncolors to prevent computation and return value.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="level">significant bits for each of RGB; valid in [1...6]</param>
	<param name="pncolors">number of occupied cubes</param>
	<returns>numa histogram of color pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapToOctcubeLUT(LeptonicaSharp.PixColormap,System.Int32,LeptonicaSharp.Enumerations.L_AN_DISTANCE)">
	<summary>
 Notes
 (1) This function is used to quickly find the colormap color
 that is closest to any rgb color.  It is used to assign
 rgb colors to an existing colormap.  It can be very expensive
 to search through the entire colormap for the closest color
 to each pixel.  Instead, we first set up this table, which is
 populated by the colormap index nearest to each octcube
 color.  Then we go through the image; for each pixel,
 do two table lookups first to generate the octcube index
 from rgb and second to use this table to read out the
 colormap index.
 (2) Do a slight modification for white and black.  For level = 4,
 each octcube size is 16.  The center of the whitest octcube
 is at (248, 248, 248), which is closer to 242 than 255.
 Consequently, any gray color between 242 and 254 will
 be selected, even if white (255, 255, 255) exists.  This is
 typically not optimal, because the original color was
 likely white.  Therefore, if white exists in the colormap,
 use it for any rgb color that falls into the most white octcube.
 Do the similar thing for black.
 (3) Here are the actual function calls for quantizing to a
 specified colormap
 ~ first make the tables that map from rgb --GT octcube index
 makeRGBToIndexTables()
 ~ then for each pixel
 use the tables to get the octcube index
 getOctcubeIndexFromRGB()
 use this table to get the nearest color in the colormap
 cmap_index = tab[index]
 (4) Distance can be either manhattan or euclidean.
 (5) In typical use, level = 4 gives reasonable results, and
 level = 5 is slightly better.  When this function is used
 for color segmentation, there are typically a small number
 of colors and the number of levels can be small (e.g., level = 3).
 </summary>
	<remarks>
	</remarks>
	<param name="cmap"></param>
	<param name="level">significant bits for each of RGB; valid in [1...6]</param>
	<param name="metric">L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
	<returns>tab[23  level]</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRemoveUnusedColors(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) If the image doesn't have a colormap, returns without error.
 (3) Unusued colors are removed from the colormap, and the
 image pixels are re-numbered.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixNumberOccupiedOctcubes(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single,System.Int32@)">
	<summary>
 Notes
 (1) Exactly one of (%mincount, %minfract) must be -1, so, e.g.,
 if %mincount == -1, then we use %minfract.
 (2) If all occupied octcubes are to count, set %mincount == 1.
 Setting %minfract == 0.0 is taken to mean the same thing.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp</param>
	<param name="level">of octcube</param>
	<param name="mincount">minimum num pixels in an octcube to be counted; -1 to not use</param>
	<param name="minfract">minimum fract of pixels in an octcube to be counted; -1 to not use</param>
	<param name="pncolors">number of occupied octcubes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMedianCutQuant(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Simple interface.  See pixMedianCutQuantGeneral() for
 use of defaulted parameters.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; rgb color</param>
	<param name="ditherflag">1 for dither; 0 for no dither</param>
	<returns>pixd 8 bit with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMedianCutQuantGeneral(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) %maxcolors must be in the range [2 ... 256].
 (2) Use %outdepth = 0 to have the output depth computed as the
 minimum required to hold the actual colors found, given
 the %maxcolors constraint.
 (3) Use %outdepth = 1, 2, 4 or 8 to specify the output depth.
 In that case, %maxcolors must not exceed 2^(outdepth).
 (4) If there are fewer quantized colors in the image than %maxcolors,
 the colormap is simply generated from those colors.
 (5) %maxsub is the maximum allowed subsampling to be used in the
 computation of the color histogram and region of occupied
 color space.  The subsampling is chosen internally for
 efficiency, based on the image size, but this parameter
 limits it.  Use %maxsub = 0 for the internal default, which is the
 maximum allowed subsampling.  Use %maxsub = 1 to prevent
 subsampling.  In general use %maxsub GT= 1 to specify the
 maximum subsampling to be allowed, where the actual subsampling
 will be the minimum of this value and the internally
 determined default value.
 (6) If the image appears gray because either most of the pixels
 are gray or most of the pixels are essentially black or white,
 the image is trivially quantized with a grayscale colormap.  The
 reason is that median cut divides the color space into rectangular
 regions, and it does a very poor job if all the pixels are
 near the diagonal of the color space cube.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; rgb color</param>
	<param name="ditherflag">1 for dither; 0 for no dither</param>
	<param name="outdepth">output depth; valid 0, 1, 2, 4, 8</param>
	<param name="maxcolors">between 2 and 256</param>
	<param name="sigbits">valid 5 or 6; use 0 for default</param>
	<param name="maxsub">max subsampling, integer; use 0 for default; 1 for no subsampling</param>
	<param name="checkbw">1 to check if color content is very small, 0 to assume there is sufficient color</param>
	<returns>pixd 8 bit with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMedianCutQuantMixed(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) ncolor + ngray must not exceed 255.
 (2) The method makes use of pixMedianCutQuantGeneral() with
 minimal addition.
 (a) Preprocess the image, setting all pixels with little color
 to black, and populating an auxiliary 8 bpp image with the
 expected colormap values corresponding to the set of
 quantized gray values.
 (b) Color quantize the altered input image to n + 1 colors.
 (c) Augment the colormap with the gray indices, and
 substitute the gray quantized values from the auxiliary
 image for those in the color quantized output that had
 been quantized as black.
 (3) Median cut color quantization is relatively poor for grayscale
 images with many colors, when compared to octcube quantization.
 Thus, for images with both gray and color, it is important
 to quantize the gray pixels by another method.  Here, we
 are conservative in detecting color, preferring to use
 a few extra bits to encode colorful pixels that push them
 to gray.  This is particularly reasonable with this function,
 because it handles the gray and color pixels separately,
 using median cut color quantization for the color pixels
 and equal-bin grayscale quantization for the non-color pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; rgb color</param>
	<param name="ncolor">maximum number of colors assigned to pixels with significant color</param>
	<param name="ngray">number of gray colors to be used; must be GT= 2</param>
	<param name="darkthresh">threshold near black; if the lightest component is below this, the pixel is not considered to be gray or color; uses 0 for default</param>
	<param name="lightthresh">threshold near white; if the darkest component is above this, the pixel is not considered to be gray or color; use 0 for default</param>
	<param name="diffthresh">thresh for the max difference between component values; for differences below this, the pixel is considered to be gray; use 0 for default</param>
	<returns>pixd 8 bpp cmapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFewColorsMedianCutQuantMixed(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is the "few colors" version of pixMedianCutQuantMixed().
 It fails (returns NULL) if it finds more than maxncolors, but
 otherwise it gives the same result.
 (2) Recommended input parameters are
 %maxncolors  20
 %darkthresh  20
 %lightthresh 244
 %diffthresh  15  (any higher can miss colors differing
 slightly from gray)
 (3) Both ncolor and ngray should be at least equal to maxncolors.
 If they're not, they are automatically increased, and a
 warning is given.
 (4) If very little color content is found, the input is
 converted to gray and quantized in equal intervals.
 (5) This can be useful for quantizing orthographically generated
 images such as color maps, where there may be more than 256 colors
 because of aliasing or jpeg artifacts on text or lines, but
 there are a relatively small number of solid colors.
 (6) Example of usage
 // Try to quantize, using default values for mixed med cut
 Pix pixq = pixFewColorsMedianCutQuantMixed(pixs, 100, 20,
 0, 0, 0, 0);
 if (!pixq)  // too many colors; don't quantize
 pixq = pixClone(pixs);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="ncolor">number of colors to be assigned to pixels with significant color</param>
	<param name="ngray">number of gray colors to be used; must be GT= 2</param>
	<param name="maxncolors">maximum number of colors to be returned from pixColorsForQuantization(); use 0 for default</param>
	<param name="darkthresh">threshold near black; if the lightest component is below this, the pixel is not considered to be gray or color; use 0 for default</param>
	<param name="lightthresh">threshold near white; if the darkest component is above this, the pixel is not considered to be gray or color; use 0 for default</param>
	<param name="diffthresh">thresh for the max difference between component values; for differences below this, the pixel is considered to be gray; use 0 for default</param>
	<returns>pixd 8 bpp, median cut quantized for pixels that are not gray; gray pixels are quantized separately over the full gray range; null if too many colors or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMedianCutHisto(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Array is indexed by (3  sigbits) bits.  The array size
 is 2^(3  sigbits).
 (2) Indexing into the array from rgb uses red sigbits as
 most significant and blue as least.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; rgb color</param>
	<param name="sigbits">valid 5 or 6</param>
	<param name="subsample">integer GT 0</param>
	<returns>histo 1-d array, giving the number of pixels in each quantized region of color space, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorSegment(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Color segmentation proceeds in four phases
 Phase 1  pixColorSegmentCluster()
 The image is traversed in raster order.  Each pixel either
 becomes the representative for a new cluster or is assigned to an
 existing cluster.  Assignment is greedy.  The data is stored in
 a colormapped image.  Three auxiliary arrays are used to hold
 the colors of the representative pixels, for fast lookup.
 The average color in each cluster is computed.
 Phase 2.  pixAssignToNearestColor()
 A second non-greedy clustering pass is performed, where each pixel
 is assigned to the nearest cluster average.  We also keep track
 of how many pixels are assigned to each cluster.
 Phase 3.  pixColorSegmentClean()
 For each cluster, starting with the largest, do a morphological
 closing to eliminate small components within larger ones.
 Phase 4.  pixColorSegmentRemoveColors()
 Eliminate all colors except the most populated 'finalcolors'.
 Then remove unused colors from the colormap, and reassign those
 pixels to the nearest remaining cluster, using the original pixel values.
 Notes
 (1) The goal is to generate a small number of colors.
 Typically this would be specified by 'finalcolors',
 a number that would be somewhere between 3 and 6.
 The parameter 'maxcolors' specifies the maximum number of
 colors generated in the first phase.  This should be
 larger than finalcolors, perhaps twice as large.
 If more than 'maxcolors' are generated in the first phase
 using the input 'maxdist', the distance is repeatedly
 increased by a multiplicative factor until the condition
 is satisfied.  The implicit relation between 'maxdist'
 and 'maxcolors' is thus adjusted programmatically.
 (2) As a very rough guideline, given a target value of 'finalcolors',
 here are approximate values of 'maxdist' and 'maxcolors'
 to start with
 finalcolors maxcolors maxdist
 ----------- --------- -------
 3 6 100
 4 8  90
 5   10  75
 6   12  60
 For a given number of finalcolors, if you use too many
 maxcolors, the result will be noisy.  If you use too few,
 the result will be a relatively poor assignment of colors.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; 24-bit color</param>
	<param name="maxdist">max euclidean dist to existing cluster</param>
	<param name="maxcolors">max number of colors allowed in first pass</param>
	<param name="selsize">linear size of sel for closing to remove noise</param>
	<param name="finalcolors">max number of final colors allowed after 4th pass</param>
	<param name="debugflag">1 for debug output; 0 otherwise</param>
	<returns>pixd 8 bit with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorSegmentCluster(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is phase 1.  See description in pixColorSegment().
 (2) Greedy unsupervised classification.  If the limit 'maxcolors'
 is exceeded, the computation is repeated with a larger
 allowed cluster size.
 (3) On each successive iteration, 'maxdist' is increased by a
 constant factor.  See comments in pixColorSegment() for
 a guideline on parameter selection.
 Note that the diagonal of the 8-bit rgb color cube is about
 440, so for 'maxdist' = 440, you are guaranteed to get 1 color!
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; 24-bit color</param>
	<param name="maxdist">max euclidean dist to existing cluster</param>
	<param name="maxcolors">max number of colors allowed in first pass</param>
	<param name="debugflag">1 for debug output; 0 otherwise</param>
	<returns>pixd 8 bit with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAssignToNearestColor(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Pix,System.Int32[])">
	<summary>
 Notes
 (1) This is used in phase 2 of color segmentation, where pixs
 is the original input image to pixColorSegment(), and
 pixd is the colormapped image returned from
 pixColorSegmentCluster().  It is also used, with a mask,
 in phase 4.
 (2) This is an in-place operation.
 (3) The colormap in pixd is unchanged.
 (4) pixs and pixd must be the same size (w, h).
 (5) The selection mask pixm can be null.  If it exists, it must
 be the same size as pixs and pixd, and only pixels
 corresponding to fg in pixm are assigned.  Set to
 NULL if all pixels in pixd are to be assigned.
 (6) The countarray can be null.  If it exists, it is pre-allocated
 and of a size at least equal to the size of the colormap in pixd.
 (7) This does a best-fit (non-greedy) assignment of pixels to
 existing clusters.  Specifically, it assigns each pixel
 in pixd to the color index in the pixd colormap that has a
 color closest to the corresponding rgb pixel in pixs.
 (8) 'level' is the octcube level used to quickly find the nearest
 color in the colormap for each pixel.  For color segmentation,
 this parameter is set to LEVEL_IN_OCTCUBE.
 (9) We build a mapping table from octcube to colormap index so
 that this function can run in a time (otherwise) independent
 of the number of colors in the colormap.  This avoids a
 brute-force search for the closest colormap color to each
 pixel in the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8 bpp, colormapped</param>
	<param name="pixs">32 bpp; 24-bit color</param>
	<param name="pixm">1 bpp</param>
	<param name="level">of octcube used for finding nearest color in cmap</param>
	<param name="countarray">ptr to array, in which we can store the number of pixels found in each color in the colormap in pixd</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorSegmentClean(LeptonicaSharp.Pix,System.Int32,System.Int32[])">
	<summary>
 Notes
 (1) This operation is in-place.
 (2) This is phase 3 of color segmentation.  It is the first
 part of a two-step noise removal process.  Colors with a
 large population are closed first; this operation absorbs
 small sets of intercolated pixels of a different color.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, colormapped</param>
	<param name="selsize">for closing</param>
	<param name="countarray">ptr to array containing the number of pixels found in each color in the colormap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorSegmentRemoveColors(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This operation is in-place.
 (2) This is phase 4 of color segmentation, and the second part
 of the 2-step noise removal.  Only 'finalcolors' different
 colors are retained, with colors with smaller populations
 being replaced by the nearest color of the remaining colors.
 For highest accuracy, for pixels that are being replaced,
 we find the nearest colormap color  to the original rgb color.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8 bpp, colormapped</param>
	<param name="pixs">32 bpp rgb, with initial pixel values</param>
	<param name="finalcolors">max number of colors to retain</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToHSV(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
 (2) The definition of our HSV space is given in convertRGBToHSV().
 (3) The h, s and v values are stored in the same places as
 the r, g and b values, respectively.  Here, they are explicitly
 placed in the 3 MS bytes in the pixel.
 (4) Normalizing to 1 and considering the r,g,b components,
 a simple way to understand the HSV space is
 ~ v = max(r,g,b)
 ~ s = (max - min) / max
 ~ h ~ (mid - min) / (max - min)  [apart from signs and constants]
 (5) Normalizing to 1, some properties of the HSV space are
 ~ For gray values (r = g = b) along the continuum between
 black and white
 s = 0  (becoming undefined as you approach black)
 h is undefined everywhere
 ~ Where one component is saturated and the others are zero
 v = 1
 s = 1
 h = 0 (r = max), 1/3 (g = max), 2/3 (b = max)
 ~ Where two components are saturated and the other is zero
 v = 1
 s = 1
 h = 1/2 (if r = 0), 5/6 (if g = 0), 1/6 (if b = 0)
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; if not NULL, must == pixs</param>
	<param name="pixs"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertHSVToRGB(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
 (2) The user takes responsibility for making sure that pixs is
 in our HSV space.  The definition of our HSV space is given
 in convertRGBToHSV().
 (3) The h, s and v values are stored in the same places as
 the r, g and b values, respectively.  Here, they are explicitly
 placed in the 3 MS bytes in the pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; if not NULL, must == pixs</param>
	<param name="pixs"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertRGBToHSV(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The range of returned values is
 h [0 ... 239]
 s [0 ... 255]
 v [0 ... 255]
 (2) If r = g = b, the pixel is gray (s = 0), and we define h = 0.
 (3) h wraps around, so that h = 0 and h = 240 are equivalent
 in hue space.
 (4) h has the following correspondence to color
 h = 0   magenta
 h = 40  red
 h = 80  yellow
 h = 120 green
 h = 160 cyan
 h = 200 blue
 </summary>
	<remarks>
	</remarks>
	<param name="rval">RGB input</param>
	<param name="gval">RGB input</param>
	<param name="bval">RGB input</param>
	<param name="phval">HSV values</param>
	<param name="psval">HSV values</param>
	<param name="pvval">HSV values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertHSVToRGB(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) See convertRGBToHSV() for valid input range of HSV values
 and their interpretation in color space.
 </summary>
	<remarks>
	</remarks>
	<param name="hval"></param>
	<param name="sval"></param>
	<param name="vval"></param>
	<param name="prval">RGB values</param>
	<param name="pgval">RGB values</param>
	<param name="pbval">RGB values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapConvertRGBToHSV(LeptonicaSharp.PixColormap)">
	<summary>
 Notes
 ~ in-place transform
 ~ See convertRGBToHSV() for def'n of HSV space.
 ~ replaces r --GT h, g --GT s, b --GT v
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapConvertHSVToRGB(LeptonicaSharp.PixColormap)">
	<summary>
 Notes
 ~ in-place transform
 ~ See convertRGBToHSV() for def'n of HSV space.
 ~ replaces h --GT r, s --GT g, v --GT b
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToHue(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The conversion to HSV hue is in-lined here.
 (2) If there is a colormap, it is removed.
 (3) If you just want the hue component, this does it
 at about 10 Mpixels/sec/GHz, which is about
 2x faster than using pixConvertRGBToHSV()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB or 8 bpp with colormap</param>
	<returns>pixd 8 bpp hue of HSV, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToSaturation(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The conversion to HSV sat is in-lined here.
 (2) If there is a colormap, it is removed.
 (3) If you just want the saturation component, this does it
 at about 12 Mpixels/sec/GHz.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB or 8 bpp with colormap</param>
	<returns>pixd 8 bpp sat of HSV, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToValue(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The conversion to HSV sat is in-lined here.
 (2) If there is a colormap, it is removed.
 (3) If you just want the value component, this does it
 at about 35 Mpixels/sec/GHz.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB or 8 bpp with colormap</param>
	<returns>pixd 8 bpp max component intensity of HSV, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMakeRangeMaskHS(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_CLUDE_REGION)">
	<summary>
 Notes
 (1) The pixels are selected based on the specified ranges of
 hue and saturation.  For selection or exclusion, the pixel
 HS component values must be within both ranges.  Care must
 be taken in finding the hue range because of wrap-around.
 (2) Use %regionflag == L_INCLUDE_REGION to take only those
 pixels within the rectangular region specified in HS space.
 Use %regionflag == L_EXCLUDE_REGION to take all pixels except
 those within the rectangular region specified in HS space.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="huecenter">center value of hue range</param>
	<param name="huehw">half-width of hue range</param>
	<param name="satcenter">center value of saturation range</param>
	<param name="sathw">half-width of saturation range</param>
	<param name="regionflag">L_INCLUDE_REGION, L_EXCLUDE_REGION</param>
	<returns>pixd 1 bpp mask over selected pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMakeRangeMaskHV(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_CLUDE_REGION)">
	<summary>
 Notes
 (1) The pixels are selected based on the specified ranges of
 hue and max intensity values.  For selection or exclusion,
 the pixel HV component values must be within both ranges.
 Care must be taken in finding the hue range because of wrap-around.
 (2) Use %regionflag == L_INCLUDE_REGION to take only those
 pixels within the rectangular region specified in HV space.
 Use %regionflag == L_EXCLUDE_REGION to take all pixels except
 those within the rectangular region specified in HV space.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="huecenter">center value of hue range</param>
	<param name="huehw">half-width of hue range</param>
	<param name="valcenter">center value of max intensity range</param>
	<param name="valhw">half-width of max intensity range</param>
	<param name="regionflag">L_INCLUDE_REGION, L_EXCLUDE_REGION</param>
	<returns>pixd 1 bpp mask over selected pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMakeRangeMaskSV(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_CLUDE_REGION)">
	<summary>
 Notes
 (1) The pixels are selected based on the specified ranges of
 saturation and max intensity (val).  For selection or
 exclusion, the pixel SV component values must be within both ranges.
 (2) Use %regionflag == L_INCLUDE_REGION to take only those
 pixels within the rectangular region specified in SV space.
 Use %regionflag == L_EXCLUDE_REGION to take all pixels except
 those within the rectangular region specified in SV space.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="satcenter">center value of saturation range</param>
	<param name="sathw">half-width of saturation range</param>
	<param name="valcenter">center value of max intensity range</param>
	<param name="valhw">half-width of max intensity range</param>
	<param name="regionflag">L_INCLUDE_REGION, L_EXCLUDE_REGION</param>
	<returns>pixd 1 bpp mask over selected pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMakeHistoHS(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) pixs is a 32 bpp image in HSV colorspace; hue is in the "red"
 byte, saturation is in the "green" byte.
 (2) In pixd, hue is displayed vertically; saturation horizontally.
 The dimensions of pixd are w = 256, h = 240, and the depth
 is 32 bpp.  The value at each point is simply the number
 of pixels found at that value of hue and saturation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">HSV colorspace</param>
	<param name="factor">subsampling factor; integer</param>
	<param name="pnahue">hue histogram</param>
	<param name="pnasat">saturation histogram</param>
	<returns>pixd 32 bpp histogram in hue and saturation, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMakeHistoHV(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) pixs is a 32 bpp image in HSV colorspace; hue is in the "red"
 byte, max intensity ("value") is in the "blue" byte.
 (2) In pixd, hue is displayed vertically; intensity horizontally.
 The dimensions of pixd are w = 256, h = 240, and the depth
 is 32 bpp.  The value at each point is simply the number
 of pixels found at that value of hue and intensity.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">HSV colorspace</param>
	<param name="factor">subsampling factor; integer</param>
	<param name="pnahue">hue histogram</param>
	<param name="pnaval">max intensity (value) histogram</param>
	<returns>pixd 32 bpp histogram in hue and value, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMakeHistoSV(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) pixs is a 32 bpp image in HSV colorspace; sat is in the "green"
 byte, max intensity ("value") is in the "blue" byte.
 (2) In pixd, sat is displayed vertically; intensity horizontally.
 The dimensions of pixd are w = 256, h = 256, and the depth
 is 32 bpp.  The value at each point is simply the number
 of pixels found at that value of saturation and intensity.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">HSV colorspace</param>
	<param name="factor">subsampling factor; integer</param>
	<param name="pnasat">sat histogram</param>
	<param name="pnaval">max intensity (value) histogram</param>
	<returns>pixd 32 bpp histogram in sat and value, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindHistoPeaksHSV(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_HISTO,System.Int32,System.Int32,System.Int32,System.Single,LeptonicaSharp.Pta@,LeptonicaSharp.Numa@,LeptonicaSharp.Pixa@)">
	<summary>
 Notes
 (1) pixs is a 32 bpp histogram in a pair of HSV colorspace.  It
 should be thought of as a single sample with 32 bps (bits/sample).
 (2) After each peak is found, the peak is erased with a window
 that is centered on the peak and scaled from the sliding
 window by %erasefactor.  Typically, %erasefactor is chosen
 to be GT 1.0.
 (3) Data for a maximum of %npeaks is returned in %pta and %natot.
 (4) For debugging, after the pixa is returned, display with
 pixd = pixaDisplayTiledInRows(pixa, 32, 1000, 1.0, 0, 30, 2);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp; HS, HV or SV histogram; not changed</param>
	<param name="type">L_HS_HISTO, L_HV_HISTO or L_SV_HISTO</param>
	<param name="width">half width of sliding window</param>
	<param name="height">half height of sliding window</param>
	<param name="npeaks">number of peaks to look for</param>
	<param name="erasefactor">ratio of erase window size to sliding window size</param>
	<param name="ppta">locations of max for each integrated peak area</param>
	<param name="pnatot">integrated peak areas</param>
	<param name="ppixa">pixa for debugging; NULL to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.displayHSVColorRange(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The total number of color samplings in each of the hue
 and saturation directions is 2  nsamp + 1.
 </summary>
	<remarks>
	</remarks>
	<param name="hval">hue center value; in range [0 ... 240]</param>
	<param name="sval">saturation center value; in range [0 ... 255]</param>
	<param name="vval">max intensity value; in range [0 ... 255]</param>
	<param name="huehw">half-width of hue range; GT 0</param>
	<param name="sathw">half-width of saturation range; GT 0</param>
	<param name="nsamp">number of samplings in each half-width in hue and sat</param>
	<param name="factor">linear size of each color square, in pixels; GT 3</param>
	<returns>pixd 32 bpp set of color squares over input range, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToYUV(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
 (2) The Y, U and V values are stored in the same places as
 the r, g and b values, respectively.  Here, they are explicitly
 placed in the 3 MS bytes in the pixel.
 (3) Normalizing to 1 and considering the r,g,b components,
 a simple way to understand the YUV space is
 ~ Y = weighted sum of (r,g,b)
 ~ U = weighted difference between Y and B
 ~ V = weighted difference between Y and R
 (4) Following video conventions, Y, U and V are in the range
 Y [16, 235]
 U [16, 240]
 V [16, 240]
 (5) For the coefficients in the transform matrices, see eq. 4 in
 "Frequently Asked Questions about Color" by Charles Poynton,
 //http//user.engineering.uiowa.edu/~aip/Misc/ColorFAQ.html
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; if not NULL, must == pixs</param>
	<param name="pixs"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertYUVToRGB(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
 (2) The user takes responsibility for making sure that pixs is
 in YUV space.
 (3) The Y, U and V values are stored in the same places as
 the r, g and b values, respectively.  Here, they are explicitly
 placed in the 3 MS bytes in the pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; if not NULL, must == pixs</param>
	<param name="pixs"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertRGBToYUV(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The range of returned values is
 Y [16 ... 235]
 U [16 ... 240]
 V [16 ... 240]
 </summary>
	<remarks>
	</remarks>
	<param name="rval">RGB input</param>
	<param name="gval">RGB input</param>
	<param name="bval">RGB input</param>
	<param name="pyval">YUV values</param>
	<param name="puval">YUV values</param>
	<param name="pvval">YUV values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertYUVToRGB(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The range of valid input values is
 Y [16 ... 235]
 U [16 ... 240]
 V [16 ... 240]
 (2) Conversion of RGB --GT YUV --GT RGB leaves the image unchanged.
 (3) The YUV gamut is larger than the RBG gamut; many YUV values
 will result in an invalid RGB value.  We clip individual
 r,g,b components to the range [0, 255], and do not test input.
 </summary>
	<remarks>
	</remarks>
	<param name="yval"></param>
	<param name="uval"></param>
	<param name="vval"></param>
	<param name="prval">RGB values</param>
	<param name="pgval">RGB values</param>
	<param name="pbval">RGB values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapConvertRGBToYUV(LeptonicaSharp.PixColormap)">
	<summary>
 Notes
 ~ in-place transform
 ~ See convertRGBToYUV() for def'n of YUV space.
 ~ replaces r --GT y, g --GT u, b --GT v
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcmapConvertYUVToRGB(LeptonicaSharp.PixColormap)">
	<summary>
 Notes
 ~ in-place transform
 ~ See convertRGBToYUV() for def'n of YUV space.
 ~ replaces y --GT r, u --GT g, v --GT b
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">colormap</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToXYZ(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The [x,y,z] values are stored as float values in three fpix
 that are returned in a fpixa.
 (2) The XYZ color space was defined in 1931 as a reference model that
 simulates human color perception.  When Y is taken as luminance,
 the values of X and Z constitute a color plane representing
 all the hues that can be perceived.  This gamut of colors
 is larger than the gamuts that can be displayed or printed.
 For example, although all rgb values map to XYZ, the converse
 is not true.
 (3) The value of the coefficients depends on the illuminant.  We use
 coefficients for converting sRGB under D65 (the spectrum from
 a 6500 degree K black body; an approximation to daylight color).
 See, e.g.,
 http//www.cs.rit.edu/~ncs/color/t_convert.html
 For more general information on color transforms, see
 http//www.brucelindbloom.com/
 http//user.engineering.uiowa.edu/~aip/Misc/ColorFAQ.html
 http//en.wikipedia.org/wiki/CIE_1931_color_space
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">rgb</param>
	<returns>fpixa xyz</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaConvertXYZToRGB(LeptonicaSharp.FPixa)">
	<summary>
 Notes
 (1) The xyz image is stored in three fpix.
 (2) For values of xyz that are out of gamut for rgb, the rgb
 components are set to the closest valid color.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixa">three fpix x,y,z</param>
	<returns>pixd rgb</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertRGBToXYZ(System.Int32,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) These conversions are for illuminant D65 acting on linear sRGB
 values.
 </summary>
	<remarks>
	</remarks>
	<param name="rval">rgb input</param>
	<param name="gval">rgb input</param>
	<param name="bval">rgb input</param>
	<param name="pfxval">xyz values</param>
	<param name="pfyval">xyz values</param>
	<param name="pfzval">xyz values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertXYZToRGB(System.Single,System.Single,System.Single,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) For values of xyz that are out of gamut for rgb, at least
 one of the r, g or b components will be either less than 0
 or greater than 255.  For that situation
 if blackout == 0, the individual component(s) that are out
 of gamut will be set to 0 or 255, respectively.
 if blackout == 1, the output color will be set to black
 </summary>
	<remarks>
	</remarks>
	<param name="fxval"></param>
	<param name="fyval"></param>
	<param name="fzval"></param>
	<param name="blackout">0 to output nearest color if out of gamut; 1 to output black</param>
	<param name="prval">rgb values</param>
	<param name="pgval">rgb values</param>
	<param name="pbval">rgb values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaConvertXYZToLAB(LeptonicaSharp.FPixa)">
	<summary>
 Notes
 (1) The input [x,y,z] and output [l,a,b] values are stored as
 float values, each set in three fpix.
 (2) The CIE LAB color space was invented in 1976, as an
 absolute reference for specifying colors that we can
 perceive, independently of the rendering device.  It was
 invented to align color display and print images.
 For information, see
 http//www.brucelindbloom.com/
 http//en.wikipedia.org/wiki/Lab_color_space
 </summary>
	<remarks>
	</remarks>
	<param name="fpixas">xyz</param>
	<returns>fpixa lab</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaConvertLABToXYZ(LeptonicaSharp.FPixa)">
	<summary>
 Notes
 (1) The input [l,a,b] and output [x,y,z] values are stored as
 float values, each set in three fpix.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixas">lab</param>
	<returns>fpixa xyz</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertXYZToLAB(System.Single,System.Single,System.Single,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="xval">xyz input</param>
	<param name="yval">xyz input</param>
	<param name="zval">xyz input</param>
	<param name="plval">lab values</param>
	<param name="paval">lab values</param>
	<param name="pbval">lab values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertLABToXYZ(System.Single,System.Single,System.Single,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lval"></param>
	<param name="aval"></param>
	<param name="bval"></param>
	<param name="pxval">xyz values</param>
	<param name="pyval">xyz values</param>
	<param name="pzval">xyz values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToLAB(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The [l,a,b] values are stored as float values in three fpix
 that are returned in a fpixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">rgb</param>
	<returns>fpixa lab</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaConvertLABToRGB(LeptonicaSharp.FPixa)">
	<summary>
 Notes
 (1) The lab image is stored in three fpix.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixa">three fpix l,a,b</param>
	<returns>pixd rgb</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertRGBToLAB(System.Int32,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) These conversions are for illuminant D65 acting on linear sRGB
 values.
 </summary>
	<remarks>
	</remarks>
	<param name="rval">rgb input</param>
	<param name="gval">rgb input</param>
	<param name="bval">rgb input</param>
	<param name="pflval">lab values</param>
	<param name="pfaval">lab values</param>
	<param name="pfbval">lab values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertLABToRGB(System.Single,System.Single,System.Single,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) For values of lab that are out of gamut for rgb, the rgb
 components are set to the closest valid color.
 </summary>
	<remarks>
	</remarks>
	<param name="flval"></param>
	<param name="faval"></param>
	<param name="fbval"></param>
	<param name="prval">rgb values</param>
	<param name="pgval">rgb values</param>
	<param name="pbval">rgb values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixEqual(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32@)">
	<summary>
 Notes
 (1) Equality is defined as having the same pixel values for
 each respective image pixel.
 (2) This works on two pix of any depth.  If one or both pix
 have a colormap, the depths can be different and the
 two pix can still be equal.
 (3) This ignores the alpha component for 32 bpp images.
 (4) If both pix have colormaps and the depths are equal,
 use the pixEqualWithCmap() function, which does a fast
 comparison if the colormaps are identical and a relatively
 slow comparison otherwise.
 (5) In all other cases, any existing colormaps must first be
 removed before doing pixel comparison.  After the colormaps
 are removed, the resulting two images must have the same depth.
 The "lowest common denominator" is RGB, but this is only
 chosen when necessary, or when both have colormaps but
 different depths.
 (6) For images without colormaps that are not 32 bpp, all bits
 in the image part of the data array must be identical.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1"></param>
	<param name="pix2"></param>
	<param name="psame">1 if same; 0 if different</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixEqualWithAlpha(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) See notes in pixEqual().
 (2) This is more general than pixEqual(), in that for 32 bpp
 RGBA images, where spp = 4, you can optionally include
 the alpha component in the comparison.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1"></param>
	<param name="pix2"></param>
	<param name="use_alpha">1 to compare alpha in RGBA; 0 to ignore</param>
	<param name="psame">1 if same; 0 if different</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixEqualWithCmap(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32@)">
	<summary>
 Notes
 (1) This returns same = TRUE if the images have identical content.
 (2) Both pix must have a colormap, and be of equal size and depth.
 If these conditions are not satisfied, it is not an error;
 the returned result is same = FALSE.
 (3) We then check whether the colormaps are the same; if so,
 the comparison proceeds 32 bits at a time.
 (4) If the colormaps are different, the comparison is done by
 slow brute force.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1"></param>
	<param name="pix2"></param>
	<param name="psame"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.cmapEqual(LeptonicaSharp.PixColormap,LeptonicaSharp.PixColormap,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This returns %same = TRUE if the colormaps have identical entries.
 (2) If %ncomps == 4, the alpha components of the colormaps are also
 compared.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap1"></param>
	<param name="cmap2"></param>
	<param name="ncomps">3 for RGB, 4 for RGBA</param>
	<param name="psame"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixUsesCmapColor(LeptonicaSharp.Pix,System.Int32@)">
	<summary>
 Notes
 (1) This returns color = TRUE if three things are obtained
 (a) the pix has a colormap
 (b) the colormap has at least one color entry
 (c) a color entry is actually used
 (2) It is used in pixEqual() for comparing two images, in a
 situation where it is required to know if the colormap
 has color entries that are actually used in the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, colormap</param>
	<param name="pcolor">TRUE if color found</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCorrelationBinary(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Single[]@)">
	<summary>
 Notes
 (1) The correlation is a number between 0.0 and 1.0,
 based on foreground similarity
 (|1 AND 2|)2
 correlation =  --------------
 |1|  |2|
 where |x| is the count of foreground pixels in image x.
 If the images are identical, this is 1.0.
 If they have no fg pixels in common, this is 0.0.
 If one or both images have no fg pixels, the correlation is 0.0.
 (2) Typically the two images are of equal size, but this
 is not enforced.  Instead, the UL corners are aligned.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">1 bpp</param>
	<param name="pix2">1 bpp</param>
	<param name="pval">correlation</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDisplayDiffBinary(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This gives a color representation of the difference between
 pix1 and pix2.  The color difference depends on the order.
 The pixels in pixd have 4 colors
 unchanged  black (on), white (off)
 on in pix1, off in pix2 red
 on in pix2, off in pix1 green
 (2) This aligns the UL corners of pix1 and pix2, and crops
 to the overlapping pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">1 bpp</param>
	<param name="pix2">1 bpp</param>
	<returns>pixd 4 bpp cmapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCompareBinary(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_COMPARE,System.Single[]@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) The two images are aligned at the UL corner, and do not
 need to be the same size.
 (2) If using L_COMPARE_SUBTRACT, pix2 is subtracted from pix1.
 (3) The total number of pixels is determined by pix1.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">1 bpp</param>
	<param name="pix2">1 bpp</param>
	<param name="comptype">L_COMPARE_XOR, L_COMPARE_SUBTRACT</param>
	<param name="pfract">fraction of pixels that are different</param>
	<param name="ppixdiff">pix of difference</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCompareGrayOrRGB(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_COMPARE,System.Int32,System.Int32@,System.Single[]@,System.Single[]@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) The two images are aligned at the UL corner, and do not
 need to be the same size.  If they are not the same size,
 the comparison will be made over overlapping pixels.
 (2) If there is a colormap, it is removed and the result
 is either gray or RGB depending on the colormap.
 (3) If RGB, each component is compared separately.
 (4) If type is L_COMPARE_ABS_DIFF, pix2 is subtracted from pix1
 and the absolute value is taken.
 (5) If type is L_COMPARE_SUBTRACT, pix2 is subtracted from pix1
 and the result is clipped to 0.
 (6) The plot output types are specified in gplot.h.
 Use 0 if no difference plot is to be made.
 (7) If the images are pixelwise identical, no difference
 plot is made, even if requested.  The result (TRUE or FALSE)
 is optionally returned in the parameter 'same'.
 (8) The average difference (either subtracting or absolute value)
 is optionally returned in the parameter 'diff'.
 (9) The RMS difference is optionally returned in the
 parameter 'rmsdiff'.  For RGB, we return the average of
 the RMS differences for each of the components.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 or 16 bpp gray, 32 bpp rgb, or colormapped</param>
	<param name="pix2">8 or 16 bpp gray, 32 bpp rgb, or colormapped</param>
	<param name="comptype">L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF</param>
	<param name="plottype">gplot plot output type, or 0 for no plot</param>
	<param name="psame">1 if pixel values are identical</param>
	<param name="pdiff">average difference</param>
	<param name="prmsdiff">rms of difference</param>
	<param name="ppixdiff">pix of difference</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCompareGray(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_COMPARE,System.Int32,System.Int32@,System.Single[]@,System.Single[]@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) See pixCompareGrayOrRGB() for details.
 (2) Use pixCompareGrayOrRGB() if the input pix are colormapped.
 (3) Note setting %plottype GT 0 can result in writing named
 output files.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 or 16 bpp, not cmapped</param>
	<param name="pix2">8 or 16 bpp, not cmapped</param>
	<param name="comptype">L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF</param>
	<param name="plottype">gplot plot output type, or 0 for no plot</param>
	<param name="psame">1 if pixel values are identical</param>
	<param name="pdiff">average difference</param>
	<param name="prmsdiff">rms of difference</param>
	<param name="ppixdiff">pix of difference</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCompareRGB(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_COMPARE,System.Int32,System.Int32@,System.Single[]@,System.Single[]@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) See pixCompareGrayOrRGB() for details.
 (2) Note setting %plottype GT 0 can result in writing named
 output files.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">32 bpp rgb</param>
	<param name="pix2">32 bpp rgb</param>
	<param name="comptype">L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF</param>
	<param name="plottype">gplot plot output type, or 0 for no plot</param>
	<param name="psame">1 if pixel values are identical</param>
	<param name="pdiff">average difference</param>
	<param name="prmsdiff">rms of difference</param>
	<param name="ppixdiff">pix of difference</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCompareTiled(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_statistical_measures,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) With L_MEAN_ABSVAL, we compute for each tile the
 average abs value of the pixel component difference between
 the two (aligned) images.  With L_ROOT_MEAN_SQUARE, we
 compute instead the rms difference over all components.
 (2) The two input pix must be the same depth.  Comparison is made
 using UL corner alignment.
 (3) For 32 bpp, the distance between corresponding tiles
 is found by averaging the measured difference over all three
 components of each pixel in the tile.
 (4) The result, pixdiff, contains one pixel for each source tile.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 bpp or 32 bpp rgb</param>
	<param name="pix2">8 bpp 32 bpp rgb</param>
	<param name="sx">tile size; must be GT 1 in each dimension</param>
	<param name="sy">tile size; must be GT 1 in each dimension</param>
	<param name="type">L_MEAN_ABSVAL or L_ROOT_MEAN_SQUARE</param>
	<param name="ppixdiff">pix of difference</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCompareRankDifference(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This answers the question if the pixel values in each
 component are compared by absolute difference, for
 any value of difference, what is the fraction of
 pixel pairs that have a difference of this magnitude
 or greater.  For a difference of 0, the fraction is 1.0.
 In this sense, it is a mapping from pixel difference to
 rank order of difference.
 (2) The two images are aligned at the UL corner, and do not
 need to be the same size.  If they are not the same size,
 the comparison will be made over overlapping pixels.
 (3) If there is a colormap, it is removed and the result
 is either gray or RGB depending on the colormap.
 (4) If RGB, pixel differences for each component are aggregated
 into a single histogram.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="pix2">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="factor">subsampling factor; use 0 or 1 for no subsampling</param>
	<returns>narank      numa of rank difference, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTestForSimilarity(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single,System.Single,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) This takes 2 pix that are the same size and determines using
 3 input parameters if they are "similar".  The first parameter
 %mindiff establishes a criterion of pixel-to-pixel similarity
 two pixels are not similar if their difference in value is
 at least mindiff.  Then %maxfract and %maxave are thresholds
 on the number and distribution of dissimilar pixels
 allowed for the two pix to be similar.   If the pix are
 to be similar, neither threshold can be exceeded.
 (2) In setting the %maxfract and %maxave thresholds, you have
 these options
 (a) Base the comparison only on %maxfract.  Then set
 %maxave = 0.0 or 256.0.  (If 0, we always ignore it.)
 (b) Base the comparison only on %maxave.  Then set
 %maxfract = 1.0.
 (c) Base the comparison on both thresholds.
 (3) Example of values that can be expected at mindiff = 15 when
 comparing lossless png encoding with jpeg encoding, q=75
 (smoothish bg) fractdiff = 0.01, avediff = 2.5
 (natural scene)   fractdiff = 0.13, avediff = 3.5
 To identify these images as 'similar', select maxfract
 and maxave to be upper bounds of what you expect.
 (4) See pixGetDifferenceStats() for a discussion of why we subtract
 mindiff from the computed average diff of the nonsimilar pixels
 to get the 'avediff' returned by that function.
 (5) If there is a colormap, it is removed and the result
 is either gray or RGB depending on the colormap.
 (6) If RGB, the maximum difference between pixel components is
 saved in the histogram.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="pix2">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="factor">subsampling factor; use 0 or 1 for no subsampling</param>
	<param name="mindiff">minimum pixel difference to be counted; GT 0</param>
	<param name="maxfract">maximum fraction of pixels allowed to have diff greater than or equal to mindiff</param>
	<param name="maxave">maximum average difference of pixels allowed for pixels with diff greater than or equal to mindiff, after subtracting mindiff</param>
	<param name="psimilar">1 if similar, 0 otherwise</param>
	<param name="details">use 1 to give normalized histogram and other data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetDifferenceStats(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Int32)">
	<summary>
 Notes
 (1) This takes a threshold %mindiff and describes the difference
 between two images in terms of two numbers
 (a) the fraction of pixels, %fractdiff, whose difference
 equals or exceeds the threshold %mindiff, and
 (b) the average value %avediff of the difference in pixel value
 for the pixels in the set given by (a), after you subtract
 %mindiff.  The reason for subtracting %mindiff is that
 you then get a useful measure for the rate of falloff
 of the distribution for larger differences.  For example,
 if %mindiff = 10 and you find that %avediff = 2.5, it
 says that of the pixels with diff GT 10, the average of
 their diffs is just mindiff + 2.5 = 12.5.  This is a
 fast falloff in the histogram with increasing difference.
 (2) The two images are aligned at the UL corner, and do not
 need to be the same size.  If they are not the same size,
 the comparison will be made over overlapping pixels.
 (3) If there is a colormap, it is removed and the result
 is either gray or RGB depending on the colormap.
 (4) If RGB, the maximum difference between pixel components is
 saved in the histogram.
 (5) Set %details == 1 to see the difference histogram and get
 an output that shows for each value of %mindiff, what are the
 minimum values required for fractdiff and avediff in order
 that the two pix will be considered similar.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="pix2">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="factor">subsampling factor; use 0 or 1 for no subsampling</param>
	<param name="mindiff">minimum pixel difference to be counted; GT 0</param>
	<param name="pfractdiff">fraction of pixels with diff greater than or equal to mindiff</param>
	<param name="pavediff">average difference of pixels with diff greater than or equal to mindiff, less mindiff</param>
	<param name="details">use 1 to give normalized histogram and other data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetDifferenceHistogram(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) The two images are aligned at the UL corner, and do not
 need to be the same size.  If they are not the same size,
 the comparison will be made over overlapping pixels.
 (2) If there is a colormap, it is removed and the result
 is either gray or RGB depending on the colormap.
 (3) If RGB, the maximum difference between pixel components is
 saved in the histogram.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="pix2">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="factor">subsampling factor; use 0 or 1 for no subsampling</param>
	<returns>na     Numa of histogram of differences, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetPerceptualDiff(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Single[]@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This takes 2 pix and determines, using 2 input parameters
 %dilation specifies the amount of grayscale or color
 dilation to apply to the images, to compensate for
 a small amount of misregistration.  A typical number might
 be 5, which uses a 5x5 Sel.  Grayscale dilation expands
 lighter pixels into darker pixel regions.
 %mindiff determines the threshold on the difference in
 pixel values to be counted -- two pixels are not similar
 if their difference in value is at least %mindiff.  For
 color pixels, we use the maximum component difference.
 (2) The pixelwise comparison is always done with the UL corners
 aligned.  The sizes of pix1 and pix2 need not be the same,
 although in practice it can be useful to scale to the same size.
 (3) If there is a colormap, it is removed and the result
 is either gray or RGB depending on the colormap.
 (4) Two optional diff images can be retrieved (typ. for debugging)
 pixdiff1 the gray or color difference
 pixdiff2 thresholded to 1 bpp for pixels exceeding %mindiff
 (5) The returned value of fract can be compared to some threshold,
 which is application dependent.
 (6) This method is in analogy to the two-sided hausdorff transform,
 except here it is for d GT 1.  For d == 1 (see pixRankHaustest()),
 we verify that when one pix1 is dilated, it covers at least a
 given fraction of the pixels in pix2, and v.v.; in that
 case, the two pix are sufficiently similar.  Here, we
 do an analogous thing subtract the dilated pix1 from pix2 to
 get a 1-sided hausdorff-like transform.  Then do it the
 other way.  Take the component-wise max of the two results,
 and threshold to get the fraction of pixels with a difference
 below the threshold.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="pixs2">8 bpp gray or 32 bpp rgb, or colormapped</param>
	<param name="sampling">subsampling factor; use 0 or 1 for no subsampling</param>
	<param name="dilation">size of grayscale or color Sel; odd</param>
	<param name="mindiff">minimum pixel difference to be counted; GT 0</param>
	<param name="pfract">fraction of pixels with diff greater than mindiff</param>
	<param name="ppixdiff1">showing difference (gray or color)</param>
	<param name="ppixdiff2">showing pixels of sufficient diff</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetPSNR(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) This computes the power S/N ratio, in dB, for the difference
 between two images.  By convention, the power S/N
 for a grayscale image is ('log' == log base 10,
 and 'ln == log base e)
 PSNR = 10  log((255/MSE)^2)
 = 4.3429  ln((255/MSE)^2)
 = -4.3429  ln((MSE/255)^2)
 where MSE is the mean squared error.
 Here are some examples
 MSE PSNR
 --- ----
 10  28.1
 3   38.6
 1   48.1
 0.1 68.1
 (2) If pix1 and pix2 have the same pixel values, the MSE = 0.0
 and the PSNR is infinity.  For that case, this returns
 PSNR = 1000, which corresponds to the very small MSE of
 about 10^(-48).
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">8 or 32 bpp; no colormap</param>
	<param name="pix2">8 or 32 bpp; no colormap</param>
	<param name="factor">sampling factor; GT= 1</param>
	<param name="ppsnr">power signal/noise ratio difference</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaComparePhotoRegionsByHisto(LeptonicaSharp.Pixa,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Single,LeptonicaSharp.Numa@,System.Collections.Generic.List{System.Single[]}@,LeptonicaSharp.Pix@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This function takes a pixa of cropped photo images and
 compares each one to the others for similarity.
 Each image is first tested to see if it is a photo that can
 be compared by tiled histograms.  If so, it is padded to put
 the centroid in the center of the image, and the histograms
 are generated.  The final step of comparing each histogram
 with all the others is very fast.
 (2) An initial filter gives %score = 0 if the ratio of widths
 and heights (smallest / largest) does not exceed a
 threshold %minratio.  If set at 1.0, both images must be
 exactly the same size.  A typical value for %minratio is 0.9.
 (3) The comparison score between two images is a value in [0.0 .. 1.0].
 If the comparison score GT= %simthresh, the images are placed in
 the same similarity class.  Default value for %simthresh is 0.25.
 (4) An array %nai of similarity class indices for pix in the
 input pixa is returned.
 (5) There are two debugging options
 An optional 2D matrix of scores is returned as a 1D array.
 A visualization of this is written to a temp file.
 An optional pix showing the similarity classes can be
 returned.  Text in each input pix is reproduced.
 (6) See the notes in pixComparePhotoRegionsByHisto() for details
 on the implementation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">any depth; colormap OK</param>
	<param name="minratio">requiring sizes be compatible; LT 1.0</param>
	<param name="textthresh">threshold for text/photo; use 0 for default</param>
	<param name="factor">subsampling; GT= 1</param>
	<param name="nx">num subregions to use for histograms; e.g. 3x3</param>
	<param name="ny">num subregions to use for histograms; e.g. 3x3</param>
	<param name="simthresh">threshold for similarity; use 0 for default</param>
	<param name="pnai">array  giving similarity class indices</param>
	<param name="pscores">score matrix as 1-D array of size N^2</param>
	<param name="ppixd">pix of similarity classes</param>
	<param name="debug">1 to output histograms; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixComparePhotoRegionsByHisto(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Single,System.Int32,System.Int32,System.Int32,System.Single[]@,System.Int32,LeptonicaSharp.Box,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This function compares two grayscale photo regions.  If a
 box is given, the region is clipped; otherwise assume
 the entire images are photo regions.  This is done with a
 set of (nx  ny) spatially aligned histograms, which are
 aligned using the centroid of the inverse image.
 (2) An initial filter gives %score = 0 if the ratio of widths
 and heights (smallest / largest) does not exceed a
 threshold %minratio.  This must be between 0.5 and 1.0.
 If set at 1.0, both images must be exactly the same size.
 A typical value for %minratio is 0.9.
 (3) Because this function should not be used on text or
 line graphics, which can give false positive results
 (i.e., high scores for different images), filter the images
 using pixGenPhotoHistos(), which returns tiled histograms
 only if an image is not text and comparison is expected
 to work with histograms.  If either image fails the test,
 the comparison returns a score of 0.0.
 (4) The white value counts in the histograms are removed; they
 are typically pixels that were padded to achieve alignment.
 (5) For an efficient representation of the histogram, normalize
 using a multiplicative factor so that the number in the
 maximum bucket is 255.  It then takes 256 bytes to store.
 (6) When comparing the histograms of two regions, use the
 Earth Mover distance (EMD), with the histograms normalized
 so that the sum over bins is the same.  Further normalize
 by dividing by 255, so that the result is in [0.0 ... 1.0].
 (7) Get a similarity score S = 1.0 - k  D, where
 k is a constant, say in the range 5-10
 D = normalized EMD
 and for multiple tiles, take the Min(S) to be the final score.
 Using aligned tiles gives protection against accidental
 similarity of the overall grayscale histograms.
 A small number of aligned tiles works well.
 (8) With debug on, you get a pdf that shows, for each tile,
 the images, histograms and score.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">any depth; colormap OK</param>
	<param name="pix2">any depth; colormap OK</param>
	<param name="box1">photo regions from each; can be null</param>
	<param name="box2">photo regions from each; can be null</param>
	<param name="minratio">requiring sizes be compatible; LT 1.0</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="nx">num subregions to use for histograms; e.g. 3x3</param>
	<param name="ny">num subregions to use for histograms; e.g. 3x3</param>
	<param name="pscore">similarity score of histograms</param>
	<param name="debugflag">1 for debug output; 0 for no debugging</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenPhotoHistos(LeptonicaSharp.Pix,System.Int32,System.Single,System.Int32,System.Int32,LeptonicaSharp.Numaa@,System.Int32@,System.Int32@,System.Int32,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This crops and converts to 8 bpp if necessary.  It adds a
 minimal white boundary such that the centroid of the
 photo-inverted image is in the center. This allows
 automatic alignment with histograms of other image regions.
 (2) The white value in the histogram is removed, because of
 the padding.
 (3) Use 0 for conservative default (1.3) for thresh.
 (4) For an efficient representation of the histogram, normalize
 using a multiplicative factor so that the number in the
 maximum bucket is 255.  It then takes 256 bytes to store.
 (5) With %debugindex GT 0, this makes a pdf that shows, for each tile,
 the images and histograms.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">depth GT 1 bpp; colormap OK</param>
	<param name="box">region to be selected; can be null</param>
	<param name="factor">subsampling; GT= 1</param>
	<param name="thresh">threshold for photo/text; use 0 for default</param>
	<param name="nx">number of subregions to use for histograms; e.g. 3x3</param>
	<param name="ny">number of subregions to use for histograms; e.g. 3x3</param>
	<param name="pnaa">nx  ny 256-entry gray histograms</param>
	<param name="pw">width of image used to make histograms</param>
	<param name="ph">height of image used to make histograms</param>
	<param name="debugindex">0 for no debugging; positive integer otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixPadToCenterCentroid(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This add minimum white padding to an 8 bpp pix, such that
 the centroid of the photometric inverse is in the center of
 the resulting image.  Thus in computing the centroid,
 black pixels have weight 255, and white pixels have weight 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, colormap OK</param>
	<param name="factor">subsampling for centroid; GT= 1</param>
	<returns>pixd padded with white pixels, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCentroid8(LeptonicaSharp.Pix,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This first does a photometric inversion (black = 255, white = 0).
 It then finds the centroid of the result.  The inversion is
 done because white is usually background, so the centroid
 is computed based on the "foreground" gray pixels, and the
 darker the pixel, the more weight it is given.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="pcx">x value of centroid</param>
	<param name="pcy">y value of centroid</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDecideIfPhotoImage(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Single,LeptonicaSharp.Numaa@,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) The input image must be 8 bpp (no colormap), and padded with
 white pixels so the centroid of photo-inverted pixels is at
 the center of the image.
 (2) If the pix is not almost certainly a photoimage, the returned
 histograms (%naa) are null.
 (3) If histograms are generated, the white (255) count is set
 to 0.  This removes all pixels values above 230, including
 white padding from the centroid matching operation, from
 consideration.  The resulting histograms are then normalized
 so the maximum count is 255.
 (4) Default for %thresh is 1.3; this seems sufficiently conservative.
 (5) Use %pixadebug == NULL unless debug output is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp, centroid in center</param>
	<param name="factor">subsampling for histograms; GT= 1</param>
	<param name="nx">number of subregions to use for histograms</param>
	<param name="ny">number of subregions to use for histograms</param>
	<param name="thresh">threshold for photo/text; use 0 for default</param>
	<param name="pnaa">array of normalized histograms</param>
	<param name="pixadebug">use only for debug output</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.compareTilesByHisto(LeptonicaSharp.Numaa,LeptonicaSharp.Numaa,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Single[]@,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) naa1 and naa2 must be generated using pixGenPhotoHistos(),
 using the same tile sizes.
 (2) The image dimensions must be similar.  The score is 0.0
 if the ratio of widths and heights (smallest / largest)
 exceeds a threshold %minratio, which must be between
 0.5 and 1.0.  If set at 1.0, both images must be exactly
 the same size.  A typical value for %minratio is 0.9.
 (2) The input pixadebug is null unless debug output is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="naa1">each is a set of 256 entry histograms</param>
	<param name="naa2">each is a set of 256 entry histograms</param>
	<param name="minratio">requiring image sizes be compatible; LT 1.0</param>
	<param name="w1">image sizes from which histograms were made</param>
	<param name="h1">image sizes from which histograms were made</param>
	<param name="w2">image sizes from which histograms were made</param>
	<param name="h2">image sizes from which histograms were made</param>
	<param name="pscore">similarity score of histograms</param>
	<param name="pixadebug">use only for debug output</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCompareGrayByHisto(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Single[]@,System.Int32,LeptonicaSharp.Box,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This function compares two grayscale photo regions.  It can
 do it with a single histogram from each region, or with a
 set of (nx  ny) spatially aligned histograms.  For both
 cases, align the regions using the centroid of the inverse
 image, and crop to the smallest of the two.
 (2) An initial filter gives %score = 0 if the ratio of widths
 and heights (smallest / largest) does not exceed a
 threshold %minratio.  This must be between 0.5 and 1.0.
 If set at 1.0, both images must be exactly the same size.
 A typical value for %minratio is 0.9.
 (3) The lightest values in the histogram can be disregarded.
 Set %maxgray to the lightest value to be kept.  For example,
 to eliminate white (255), set %maxgray = 254.  %maxgray must
 be GT= 200.
 (4) For an efficient representation of the histogram, normalize
 using a multiplicative factor so that the number in the
 maximum bucket is 255.  It then takes 256 bytes to store.
 (5) When comparing the histograms of two regions
 ~ Use %maxgray = 254 to ignore the white pixels, the number
 of which may be sensitive to the crop region if the pixels
 outside that region are white.
 ~ Use the Earth Mover distance (EMD), with the histograms
 normalized so that the sum over bins is the same.
 Further normalize by dividing by 255, so that the result
 is in [0.0 ... 1.0].
 (6) Get a similarity score S = 1.0 - k  D, where
 k is a constant, say in the range 5-10
 D = normalized EMD
 and for multiple tiles, take the Min(S) to be the final score.
 Using aligned tiles gives protection against accidental
 similarity of the overall grayscale histograms.
 A small number of aligned tiles works well.
 (7) With debug on, you get a pdf that shows, for each tile,
 the images, histograms and score.
 (8) When to use
 (a) Because this function should not be used on text or
 line graphics, which can give false positive results
 (i.e., high scores for different images), the input
 images should be filtered.
 (b) To filter, first use pixDecideIfText().  If that function
 says the image is text, do not use it.  If the function
 says it is not text, it still may be line graphics, and
 in that case, use
 pixGetGrayHistogramTiled()
 grayInterHistogramStats()
 to determine whether it is photo or line graphics.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">any depth; colormap OK</param>
	<param name="pix2">any depth; colormap OK</param>
	<param name="box1">region selected from each; can be null</param>
	<param name="box2">region selected from each; can be null</param>
	<param name="minratio">requiring sizes be compatible; LT 1.0</param>
	<param name="maxgray">max value to keep in histo; GT= 200, 255 to keep all</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="nx">num subregions to use for histograms; e.g. 3x3</param>
	<param name="ny">num subregions to use for histograms; e.g. 3x3</param>
	<param name="pscore">similarity score of histograms</param>
	<param name="debugflag">1 for debug output; 0 for no debugging</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCropAlignedToCentroid(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Box@,LeptonicaSharp.Box@)">
	<summary>
 Notes
 (1) This finds the maximum crop boxes for two 8 bpp images when
 their centroids of their photometric inverses are aligned.
 Black pixels have weight 255; white pixels have weight 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">any depth; colormap OK</param>
	<param name="pix2">any depth; colormap OK</param>
	<param name="factor">subsampling; GT= 1</param>
	<param name="pbox1">crop box for pix1</param>
	<param name="pbox2">crop box for pix2</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_compressGrayHistograms(LeptonicaSharp.Numaa,System.Int32,System.Int32,System.UInt32@)">
	<summary>
 Notes
 (1) This first writes w and h to the byte array as 4 byte ints.
 (2) Then it normalizes each histogram to a max value of 255,
 and saves each value as a byte.  If there are
 N histograms, the output bytearray has 8 + 256  N bytes.
 (3) Further compression of the array with zlib yields only about
 a 25% decrease in size, so we don't bother.  If size reduction
 were important, a lossy transform using a 1-dimensional DCT
 would be effective, because we don't care about the fine
 details of these histograms.
 </summary>
	<remarks>
	</remarks>
	<param name="naa">set of 256-entry histograms</param>
	<param name="w">size of image</param>
	<param name="h">size of image</param>
	<param name="psize">size of byte array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_uncompressGrayHistograms(System.Byte[],System.UInt32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The first 8 bytes are read as two 32-bit ints.
 (2) Then this constructs a numaa representing some number of
 gray histograms that are normalized such that the max value
 in each histogram is 255.  The data is stored as a byte
 array, with 256 bytes holding the data for each histogram.
 Each gray histogram was computed from a tile of a grayscale image.
 </summary>
	<remarks>
	</remarks>
	<param name="bytea">byte array of size 8 + 256  N, N an integer</param>
	<param name="size">size of byte array</param>
	<param name="pw">width of the image that generated the histograms</param>
	<param name="ph">height of the image</param>
	<returns>numaa     representing N histograms, each with 256 bins, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCompareWithTranslation(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Int32@,System.Single[]@,System.Int32)">
	<summary>
 Notes
 (1) This does a coarse-to-fine search for best translational
 alignment of two images, measured by a scoring function
 that is the correlation between the fg pixels.
 (2) The threshold is used if the images aren't 1 bpp.
 (3) With debug on, you get a pdf that shows, as a grayscale
 image, the score as a function of shift from the initial
 estimate, for each of the four levels.  The shift is 0 at
 the center of the image.
 (4) With debug on, you also get a pdf that shows the
 difference at the best alignment between the two images,
 at each of the four levels.  The red and green pixels
 show locations where one image has a fg pixel and the
 other doesn't.  The black pixels are where both images
 have fg pixels, and white pixels are where neither image
 has fg pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">any depth; colormap OK</param>
	<param name="pix2">any depth; colormap OK</param>
	<param name="thresh">threshold for converting to 1 bpp</param>
	<param name="pdelx">x translation on pix2 to align with pix1</param>
	<param name="pdely">y translation on pix2 to align with pix1</param>
	<param name="pscore">correlation score at best alignment</param>
	<param name="debugflag">1 for debug output; 0 for no debugging</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBestCorrelation(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32@,System.Int32@,System.Single[]@)">
	<summary>
 Notes
 (1) This maximizes the correlation score between two 1 bpp images,
 by starting with an estimate of the alignment
 (%etransx, %etransy) and computing the correlation around this.
 It optionally returns the shift (%delx, %dely) that maximizes
 the correlation score when pix2 is shifted by this amount
 relative to pix1.
 (2) Get the centroids of pix1 and pix2, using pixCentroid(),
 to compute (%etransx, %etransy).  Get the areas using
 pixCountPixels().
 (3) The centroid of pix2 is shifted with respect to the centroid
 of pix1 by all values between -maxshiftx and maxshiftx,
 and likewise for the y shifts.  Therefore, the number of
 correlations computed is
 (2  maxshiftx + 1)  (2  maxshifty + 1)
 Consequently, if pix1 and pix2 are large, you should do this
 in a coarse-to-fine sequence.  See the use of this function
 in pixCompareWithTranslation().
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">1 bpp</param>
	<param name="pix2">1 bpp</param>
	<param name="area1">number of on pixels in pix1</param>
	<param name="area2">number of on pixels in pix2</param>
	<param name="etransx">estimated x translation of pix2 to align with pix1</param>
	<param name="etransy">estimated y translation of pix2 to align with pix1</param>
	<param name="maxshift">max x and y shift of pix2, around the estimated alignment location, relative to pix1</param>
	<param name="tab8">sum tab for ON pixels in byte; can be NULL</param>
	<param name="pdelx">best x shift of pix2 relative to pix1</param>
	<param name="pdely">best y shift of pix2 relative to pix1</param>
	<param name="pscore">maximum score found; can be NULL</param>
	<param name="debugflag">LT= 0 to skip; positive to generate output. The integer is used to label the debug image.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConnComp(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Pixa@)">
	<summary>
 Notes
 (1) This is the top-level call for getting bounding boxes or
 a pixa of the components, and it can be used instead
 of either pixConnCompBB() or pixConnCompPixa(), rsp.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="ppixa">pixa of each c.c.</param>
	<param name="connectivity">4 or 8</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConnCompPixa(LeptonicaSharp.Pix,LeptonicaSharp.Pixa@,System.Int32)">
	<summary>
 Notes
 (1) This finds bounding boxes of 4- or 8-connected components
 in a binary image, and saves images of each c.c
 in a pixa array.
 (2) It sets up 2 temporary pix, and for each c.c. that is
 located in raster order, it erases the c.c. from one pix,
 then uses the b.b. to extract the c.c. from the two pix using
 an XOR, and finally erases the c.c. from the second pix.
 (3) A clone of the returned boxa (where all boxes in the array
 are clones) is inserted into the pixa.
 (4) If the input is valid, this always returns a boxa and a pixa.
 If pixs is empty, the boxa and pixa will be empty.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="ppixa">pixa of each c.c.</param>
	<param name="connectivity">4 or 8</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConnCompBB(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Finds bounding boxes of 4- or 8-connected components
 in a binary image.
 (2) This works on a copy of the input pix.  The c.c. are located
 in raster order and erased one at a time.  In the process,
 the b.b. is computed and saved.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">4 or 8</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCountConnComp(LeptonicaSharp.Pix,System.Int32,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">4 or 8</param>
	<param name="pcount"></param>
	<returns>0 if OK, 1 on error Notes (1 This is the top-level call for getting the number of 4- or 8-connected components in a 1 bpp image. 2 It works on a copy of the input pix.  The c.c. are located in raster order and erased one at a time.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.nextOnPixelInRaster(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="xstart">starting point for search</param>
	<param name="ystart">starting point for search</param>
	<param name="px">coord value of next ON pixel</param>
	<param name="py">coord value of next ON pixel</param>
	<returns>1 if a pixel is found; 0 otherwise or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.nextOnPixelInRasterLow(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">pix data</param>
	<param name="w">width and height</param>
	<param name="h">width and height</param>
	<param name="wpl">words per line</param>
	<param name="xstart">starting point for search</param>
	<param name="ystart">starting point for search</param>
	<param name="px">coord value of next ON pixel</param>
	<param name="py">coord value of next ON pixel</param>
	<returns>1 if a pixel is found; 0 otherwise or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfillBB(LeptonicaSharp.Pix,LeptonicaSharp.L_Stack,System.Int32,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) This is the high-level interface to Paul Heckbert's
 stack-based seedfill algorithm.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="stack">for holding fillsegs</param>
	<param name="x">,y   location of seed pixel</param>
	<param name="connectivity">4 or 8</param>
	<returns>box or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfill4BB(LeptonicaSharp.Pix,LeptonicaSharp.L_Stack,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.
 (2) This operates on the input 1 bpp pix to remove the fg seed
 pixel, at (x,y), and all pixels that are 4-connected to it.
 The seed pixel at (x,y) must initially be ON.
 (3) Returns the bounding box of the erased 4-cc component.
 (4) Reference see Paul Heckbert's stack-based seed fill algorithm
 in "Graphic Gems", ed. Andrew Glassner, Academic
 Press, 1990.  The algorithm description is given
 on pp. 275-277; working C code is on pp. 721-722.)
 The code here follows Heckbert's exactly, except
 we use function calls instead of macros for
 pushing data on and popping data off the stack.
 This makes sense to do because Heckbert's fixed-size
 stack with macros is dangerous images exist that
 will overrun the stack and crash.   The stack utility
 here grows dynamically as needed, and the fillseg
 structures that are not in use are stored in another
 stack for reuse.  It should be noted that the
 overhead in the function calls (vs. macros) is negligible.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="stack">for holding fillsegs</param>
	<param name="x">,y   location of seed pixel</param>
	<returns>box or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfill8BB(LeptonicaSharp.Pix,LeptonicaSharp.L_Stack,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.
 (2) This operates on the input 1 bpp pix to remove the fg seed
 pixel, at (x,y), and all pixels that are 8-connected to it.
 The seed pixel at (x,y) must initially be ON.
 (3) Returns the bounding box of the erased 8-cc component.
 (4) Reference see Paul Heckbert's stack-based seed fill algorithm
 in "Graphic Gems", ed. Andrew Glassner, Academic
 Press, 1990.  The algorithm description is given
 on pp. 275-277; working C code is on pp. 721-722.)
 The code here follows Heckbert's closely, except
 the leak checks are changed for 8 connectivity.
 See comments on pixSeedfill4BB() for more details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="stack">for holding fillsegs</param>
	<param name="x">,y   location of seed pixel</param>
	<returns>box or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfill(LeptonicaSharp.Pix,LeptonicaSharp.L_Stack,System.Int32,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) This removes the component from pixs with a fg pixel at (x,y).
 (2) See pixSeedfill4() and pixSeedfill8() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="stack">for holding fillsegs</param>
	<param name="x">,y   location of seed pixel</param>
	<param name="connectivity">4 or 8</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfill4(LeptonicaSharp.Pix,LeptonicaSharp.L_Stack,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.
 (2) This operates on the input 1 bpp pix to remove the fg seed
 pixel, at (x,y), and all pixels that are 4-connected to it.
 The seed pixel at (x,y) must initially be ON.
 (3) Reference see pixSeedFill4BB()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="stack">for holding fillsegs</param>
	<param name="x">,y   location of seed pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfill8(LeptonicaSharp.Pix,LeptonicaSharp.L_Stack,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.
 (2) This operates on the input 1 bpp pix to remove the fg seed
 pixel, at (x,y), and all pixels that are 8-connected to it.
 The seed pixel at (x,y) must initially be ON.
 (3) Reference see pixSeedFill8BB()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="stack">for holding fillsegs</param>
	<param name="x">,y   location of seed pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertFilesTo1bpp(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String,LeptonicaSharp.Enumerations.IFF,System.String)">
	<summary>
 Notes
 (1) Images are sorted lexicographically, and the names in the
 output directory are retained except for the extension.
 </summary>
	<remarks>
	</remarks>
	<param name="dirin"></param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="upscaling">1, 2 or 4; only for input color or grayscale</param>
	<param name="thresh">global threshold for binarization; use 0 for default</param>
	<param name="firstpage"></param>
	<param name="npages">use 0 to do all from %firstpage to the end</param>
	<param name="dirout"></param>
	<param name="outformat">IFF_PNG, IFF_TIFF_G4</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlockconv(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1)
 (2) Returns a copy if both wc and hc are 0
 (3) Require that w GT= 2  wc + 1 and h GT= 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlockconvGray(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If accum pix is null, make one and destroy it before
 returning; otherwise, just use the input accum pix.
 (2) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1).
 (3) Returns a copy if both wc and hc are 0.
 (4) Require that w GT= 2  wc + 1 and h GT= 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="pixacc">pix 32 bpp; can be null</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<returns>pix 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlockconvAccum(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The general recursion relation is
 a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)
 For the first line, this reduces to the special case
 a(i,j) = v(i,j) + a(i, j-1)
 For the first column, the special case is
 a(i,j) = v(i,j) + a(i-1, j)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 or 32 bpp</param>
	<returns>accum pix 32 bpp, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlockconvGrayUnnormalized(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1).
 (2) Require that w GT= 2  wc + 1 and h GT= 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 (3) Returns a copy if both wc and hc are 0.
 (3) Adds mirrored border to avoid treating the boundary pixels
 specially.  Note that we add wc + 1 pixels to the left
 and wc to the right.  The added width is 2  wc + 1 pixels,
 and the particular choice simplifies the indexing in the loop.
 Likewise, add hc + 1 pixels to the top and hc to the bottom.
 (4) To get the normalized result, divide by the area of the
 convolution kernel (2  wc + 1)  (2  hc + 1)
 Specifically, do this
 pixc = pixBlockconvGrayUnnormalized(pixs, wc, hc);
 fract = 1. / ((2  wc + 1)  (2  hc + 1));
 pixMultConstantGray(pixc, fract);
 pixd = pixGetRGBComponent(pixc, L_ALPHA_CHANNEL);
 (5) Unlike pixBlockconvGray(), this always computes the accumulation
 pix because its size is tied to wc and hc.
 (6) Compare this implementation with pixBlockconvGray(), where
 most of the code in blockconvLow() is special casing for
 efficiently handling the boundary.  Here, the use of
 mirrored borders and destination indexing makes the
 implementation very simple.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<returns>pix 32 bpp; containing the convolution without normalizing for the window size, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlockconvTiled(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1)
 (2) Returns a copy if both wc and hc are 0
 (3) Require that w GT= 2  wc + 1 and h GT= 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 (4) For nx == ny == 1, this defaults to pixBlockconv(), which
 is typically about twice as fast, and gives nearly
 identical results as pixBlockconvGrayTile().
 (5) If the tiles are too small, nx and/or ny are reduced
 a minimum amount so that the tiles are expanded to the
 smallest workable size in the problematic direction(s).
 (6) Why a tiled version?  Three reasons
 (a) Because the accumulator is a uint32, overflow can occur
 for an image with more than 16M pixels.
 (b) The accumulator array for 16M pixels is 64 MB; using
 tiles reduces the size of this array.
 (c) Each tile can be processed independently, in parallel,
 on a multicore processor.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<param name="nx">subdivision into tiles</param>
	<param name="ny">subdivision into tiles</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlockconvGrayTile(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1)
 (2) Assumes that the input pixs is padded with (wc + 1) pixels on
 left and right, and with (hc + 1) pixels on top and bottom.
 The returned pix has these stripped off; they are only used
 for computation.
 (3) Returns a copy if both wc and hc are 0
 (4) Require that w GT 2  wc + 1 and h GT 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray</param>
	<param name="pixacc">32 bpp accum pix</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWindowedStats(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.FPix@,LeptonicaSharp.FPix@)">
	<summary>
 Notes
 (1) This is a high-level convenience function for calculating
 any or all of these derived images.
 (2) If %hasborder = 0, a border is added and the result is
 computed over all pixels in pixs.  Otherwise, no border is
 added and the border pixels are removed from the output images.
 (3) These statistical measures over the pixels in the
 rectangular window are
 ~ average value LTpGT  (pixm)
 ~ average squared value LTppGT (pixms)
 ~ variance LT(p - LTpGT)(p - LTpGT)GT = LTppGT - LTpGTLTpGT  (pixv)
 ~ square-root of variance (pixrv)
 where the brackets LT .. GT indicate that the average value is
 to be taken over the window.
 (4) Note that the variance is just the mean square difference from
 the mean value; and the square root of the variance is the
 root mean square difference from the mean, sometimes also
 called the 'standard deviation'.
 (5) The added border, along with the use of an accumulator array,
 allows computation without special treatment of pixels near
 the image boundary, and runs in a time that is independent
 of the size of the convolution kernel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<param name="hasborder">use 1 if it already has (wc + 1 border pixels on left and right, and hc + 1 on top and bottom; use 0 to add kernel-dependent border)</param>
	<param name="ppixm">8 bpp mean value in window</param>
	<param name="ppixms">32 bpp mean square value in window</param>
	<param name="pfpixv">float variance in window</param>
	<param name="pfpixrv">float rms deviation from the mean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWindowedMean(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The input and output depths are the same.
 (2) A set of border pixels of width (wc + 1) on left and right,
 and of height (hc + 1) on top and bottom, must be on the
 pix before the accumulator is found.  The output pixd
 (after convolution) has this border removed.
 If %hasborder = 0, the required border is added.
 (3) Typically, %normflag == 1.  However, if you want the sum
 within the window, rather than a normalized convolution,
 use %normflag == 0.
 (4) This builds a block accumulator pix, uses it here, and
 destroys it.
 (5) The added border, along with the use of an accumulator array,
 allows computation without special treatment of pixels near
 the image boundary, and runs in a time that is independent
 of the size of the convolution kernel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp grayscale</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<param name="hasborder">use 1 if it already has (wc + 1 border pixels on left and right, and hc + 1 on top and bottom; use 0 to add kernel-dependent border)</param>
	<param name="normflag">1 for normalization to get average in window; 0 for the sum in the window (un-normalized)</param>
	<returns>pixd 8 or 32 bpp, average over kernel window</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWindowedMeanSquare(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) A set of border pixels of width (wc + 1) on left and right,
 and of height (hc + 1) on top and bottom, must be on the
 pix before the accumulator is found.  The output pixd
 (after convolution) has this border removed.
 If %hasborder = 0, the required border is added.
 (2) The advantage is that we are unaffected by the boundary, and
 it is not necessary to treat pixels within %wc and %hc of the
 border differently.  This is because processing for pixd
 only takes place for pixels in pixs for which the
 kernel is entirely contained in pixs.
 (3) Why do we have an added border of width (%wc + 1) and
 height (%hc + 1), when we only need %wc and %hc pixels
 to satisfy this condition?  Answer the accumulators
 are asymmetric, requiring an extra row and column of
 pixels at top and left to work accurately.
 (4) The added border, along with the use of an accumulator array,
 allows computation without special treatment of pixels near
 the image boundary, and runs in a time that is independent
 of the size of the convolution kernel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="wc">half width/height of convolution kernel</param>
	<param name="hc">half width/height of convolution kernel</param>
	<param name="hasborder">use 1 if it already has (wc + 1 border pixels on left and right, and hc + 1 on top and bottom; use 0 to add kernel-dependent border)</param>
	<returns>pixd 32 bpp, average over rectangular window of width = 2  wc + 1 and height = 2  hc + 1</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWindowedVariance(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.FPix@,LeptonicaSharp.FPix@)">
	<summary>
 Notes
 (1) The mean and mean square values are precomputed, using
 pixWindowedMean() and pixWindowedMeanSquare().
 (2) Either or both of the variance and square-root of variance
 are returned as an fpix, where the variance is the
 average over the window of the mean square difference of
 the pixel value from the mean
 LT(p - LTpGT)(p - LTpGT)GT = LTppGT - LTpGTLTpGT
 (3) To visualize the results
 ~ for both, use fpixDisplayMaxDynamicRange().
 ~ for rms deviation, simply convert the output fpix to pix,
 </summary>
	<remarks>
	</remarks>
	<param name="pixm">mean over window; 8 or 32 bpp grayscale</param>
	<param name="pixms">mean square over window; 32 bpp</param>
	<param name="pfpixv">float variance -- the ms deviation from the mean</param>
	<param name="pfpixrv">float rms deviation from the mean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMeanSquareAccum(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Similar to pixBlockconvAccum(), this computes the
 sum of the squares of the pixel values in such a way
 that the value at (i,j) is the sum of all squares in
 the rectangle from the origin to (i,j).
 (2) The general recursion relation (v are squared pixel values) is
 a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)
 For the first line, this reduces to the special case
 a(i,j) = v(i,j) + a(i, j-1)
 For the first column, the special case is
 a(i,j) = v(i,j) + a(i-1, j)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<returns>dpix 64 bit array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlockrank(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1)
 (2) This returns a pixd where each pixel is a 1 if the
 neighborhood (2  wc + 1) x (2  hc + 1)) pixels
 contains the rank fraction of 1 pixels.  Otherwise,
 the returned pixel is 0.  Note that the special case
 of rank = 0.0 is always satisfied, so the returned
 pixd has all pixels with value 1.
 (3) If accum pix is null, make one, use it, and destroy it
 before returning; otherwise, just use the input accum pix
 (4) If both wc and hc are 0, returns a copy unless rank == 0.0,
 in which case this returns an all-ones image.
 (5) Require that w GT= 2  wc + 1 and h GT= 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pixacc">pix [optional] 32 bpp</param>
	<param name="wc">half width/height of block sum/rank kernel</param>
	<param name="hc">half width/height of block sum/rank kernel</param>
	<param name="rank">between 0.0 and 1.0; 0.5 is median filter</param>
	<returns>pixd 1 bpp</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlocksum(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If accum pix is null, make one and destroy it before
 returning; otherwise, just use the input accum pix
 (2) The full width and height of the convolution kernel
 are (2  wc + 1) and (2  hc + 1)
 (3) Use of wc = hc = 1, followed by pixInvert() on the
 8 bpp result, gives a nice anti-aliased, and somewhat
 darkened, result on text.
 (4) Require that w GT= 2  wc + 1 and h GT= 2  hc + 1,
 where (w,h) are the dimensions of pixs.
 (5) Returns in each dest pixel the sum of all src pixels
 that are within a block of size of the kernel, centered
 on the dest pixel.  This sum is the number of src ON
 pixels in the block at each location, normalized to 255
 for a block containing all ON pixels.  For pixels near
 the boundary, where the block is not entirely contained
 within the image, we then multiply by a second normalization
 factor that is greater than one, so that all results
 are normalized by the number of participating pixels
 within the block.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pixacc">pix [optional] 32 bpp</param>
	<param name="wc">half width/height of block sum/rank kernel</param>
	<param name="hc">half width/height of block sum/rank kernel</param>
	<returns>pixd 8 bpp</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCensusTransform(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The Census transform was invented by Ramin Zabih and John Woodfill
 ("Non-parametric local transforms for computing visual
 correspondence", Third European Conference on Computer Vision,
 Stockholm, Sweden, May 1994); see publications at
 http//www.cs.cornell.edu/~rdz/index.htm
 This compares each pixel against the average of its neighbors,
 in a square of odd dimension centered on the pixel.
 If the pixel is greater than the average of its neighbors,
 the output pixel value is 1; otherwise it is 0.
 (2) This can be used as an encoding for an image that is
 fairly robust against slow illumination changes, with
 applications in image comparison and mosaicing.
 (3) The size of the convolution kernel is (2  halfsize + 1)
 on a side.  The halfsize parameter must be GT= 1.
 (4) If accum pix is null, make one, use it, and destroy it
 before returning; otherwise, just use the input accum pix
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="halfsize">of square over which neighbors are averaged</param>
	<param name="pixacc">pix [optional] 32 bpp</param>
	<returns>pixd 1 bpp</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvolve(LeptonicaSharp.Pix,LeptonicaSharp.L_Kernel,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This gives a convolution with an arbitrary kernel.
 (2) The input pixs must have only one sample/pixel.
 To do a convolution on an RGB image, use pixConvolveRGB().
 (3) The parameter %outdepth determines the depth of the result.
 If the kernel is normalized to unit sum, the output values
 can never exceed 255, so an output depth of 8 bpp is sufficient.
 If the kernel is not normalized, it may be necessary to use
 16 or 32 bpp output to avoid overflow.
 (4) If normflag == 1, the result is normalized by scaling all
 kernel values for a unit sum.  If the sum of kernel values
 is very close to zero, the kernel can not be normalized and
 the convolution will not be performed.  A warning is issued.
 (5) The kernel values can be positive or negative, but the
 result for the convolution can only be stored as a positive
 number.  Consequently, if it goes negative, the choices are
 to clip to 0 or take the absolute value.  We're choosing
 to take the absolute value.  (Another possibility would be
 to output a second unsigned image for the negative values.)
 If you want to get a clipped result, or to keep the negative
 values in the result, use fpixConvolve(), with the
 converters in fpix2.c between pix and fpix.
 (6) This uses a mirrored border to avoid special casing on
 the boundaries.
 (7) To get a subsampled output, call l_setConvolveSampling().
 The time to make a subsampled output is reduced by the
 product of the sampling factors.
 (8) The function is slow, running at about 12 machine cycles for
 each pixel-op in the convolution.  For example, with a 3 GHz
 cpu, a 1 Mpixel grayscale image, and a kernel with
 (sx  sy) = 25 elements, the convolution takes about 100 msec.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16, 32 bpp; no colormap</param>
	<param name="kel">kernel</param>
	<param name="outdepth">of pixd 8, 16 or 32</param>
	<param name="normflag">1 to normalize kernel to unit sum; 0 otherwise</param>
	<returns>pixd 8, 16 or 32 bpp</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvolveSep(LeptonicaSharp.Pix,LeptonicaSharp.L_Kernel,LeptonicaSharp.L_Kernel,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does a convolution with a separable kernel that is
 is a sequence of convolutions in x and y.  The two
 one-dimensional kernel components must be input separately;
 the full kernel is the product of these components.
 The support for the full kernel is thus a rectangular region.
 (2) The input pixs must have only one sample/pixel.
 To do a convolution on an RGB image, use pixConvolveSepRGB().
 (3) The parameter %outdepth determines the depth of the result.
 If the kernel is normalized to unit sum, the output values
 can never exceed 255, so an output depth of 8 bpp is sufficient.
 If the kernel is not normalized, it may be necessary to use
 16 or 32 bpp output to avoid overflow.
 (2) The %normflag parameter is used as in pixConvolve().
 (4) The kernel values can be positive or negative, but the
 result for the convolution can only be stored as a positive
 number.  Consequently, if it goes negative, the choices are
 to clip to 0 or take the absolute value.  We're choosing
 the former for now.  Another possibility would be to output
 a second unsigned image for the negative values.
 (5) Warning if you use l_setConvolveSampling() to get a
 subsampled output, and the sampling factor is larger than
 the kernel half-width, it is faster to use the non-separable
 version pixConvolve().  This is because the first convolution
 here must be done on every raster line, regardless of the
 vertical sampling factor.  If the sampling factor is smaller
 than kernel half-width, it's faster to use the separable
 convolution.
 (6) This uses mirrored borders to avoid special casing on
 the boundaries.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16, 32 bpp; no colormap</param>
	<param name="kelx">x-dependent kernel</param>
	<param name="kely">y-dependent kernel</param>
	<param name="outdepth">of pixd 8, 16 or 32</param>
	<param name="normflag">1 to normalize kernel to unit sum; 0 otherwise</param>
	<returns>pixd 8, 16 or 32 bpp</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvolveRGB(LeptonicaSharp.Pix,LeptonicaSharp.L_Kernel)">
	<summary>
 Notes
 (1) This gives a convolution on an RGB image using an
 arbitrary kernel (which we normalize to keep each
 component within the range [0 ... 255].
 (2) The input pixs must be RGB.
 (3) The kernel values can be positive or negative, but the
 result for the convolution can only be stored as a positive
 number.  Consequently, if it goes negative, we clip the
 result to 0.
 (4) To get a subsampled output, call l_setConvolveSampling().
 The time to make a subsampled output is reduced by the
 product of the sampling factors.
 (5) This uses a mirrored border to avoid special casing on
 the boundaries.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="kel">kernel</param>
	<returns>pixd 32 bpp rgb</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvolveRGBSep(LeptonicaSharp.Pix,LeptonicaSharp.L_Kernel,LeptonicaSharp.L_Kernel)">
	<summary>
 Notes
 (1) This does a convolution on an RGB image using a separable
 kernel that is a sequence of convolutions in x and y.  The two
 one-dimensional kernel components must be input separately;
 the full kernel is the product of these components.
 The support for the full kernel is thus a rectangular region.
 (2) The kernel values can be positive or negative, but the
 result for the convolution can only be stored as a positive
 number.  Consequently, if it goes negative, we clip the
 result to 0.
 (3) To get a subsampled output, call l_setConvolveSampling().
 The time to make a subsampled output is reduced by the
 product of the sampling factors.
 (4) This uses a mirrored border to avoid special casing on
 the boundaries.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="kelx">x-dependent kernel</param>
	<param name="kely">y-dependent kernel</param>
	<returns>pixd 32 bpp rgb</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixConvolve(LeptonicaSharp.FPix,LeptonicaSharp.L_Kernel,System.Int32)">
	<summary>
 Notes
 (1) This gives a float convolution with an arbitrary kernel.
 (2) If normflag == 1, the result is normalized by scaling all
 kernel values for a unit sum.  If the sum of kernel values
 is very close to zero, the kernel can not be normalized and
 the convolution will not be performed.  A warning is issued.
 (3) With the FPix, there are no issues about negative
 array or kernel values.  The convolution is performed
 with single precision arithmetic.
 (4) To get a subsampled output, call l_setConvolveSampling().
 The time to make a subsampled output is reduced by the
 product of the sampling factors.
 (5) This uses a mirrored border to avoid special casing on
 the boundaries.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs">32 bit float array</param>
	<param name="kel">kernel</param>
	<param name="normflag">1 to normalize kernel to unit sum; 0 otherwise</param>
	<returns>fpixd 32 bit float array</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixConvolveSep(LeptonicaSharp.FPix,LeptonicaSharp.L_Kernel,LeptonicaSharp.L_Kernel,System.Int32)">
	<summary>
 Notes
 (1) This does a convolution with a separable kernel that is
 is a sequence of convolutions in x and y.  The two
 one-dimensional kernel components must be input separately;
 the full kernel is the product of these components.
 The support for the full kernel is thus a rectangular region.
 (2) The normflag parameter is used as in fpixConvolve().
 (3) Warning if you use l_setConvolveSampling() to get a
 subsampled output, and the sampling factor is larger than
 the kernel half-width, it is faster to use the non-separable
 version pixConvolve().  This is because the first convolution
 here must be done on every raster line, regardless of the
 vertical sampling factor.  If the sampling factor is smaller
 than kernel half-width, it's faster to use the separable
 convolution.
 (4) This uses mirrored borders to avoid special casing on
 the boundaries.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs">32 bit float array</param>
	<param name="kelx">x-dependent kernel</param>
	<param name="kely">y-dependent kernel</param>
	<param name="normflag">1 to normalize kernel to unit sum; 0 otherwise</param>
	<returns>fpixd 32 bit float array</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvolveWithBias(LeptonicaSharp.Pix,LeptonicaSharp.L_Kernel,System.Int32,System.Int32@,LeptonicaSharp.L_Kernel)">
	<summary>
 Notes
 (1) This does a convolution with either a single kernel or
 a pair of separable kernels, and automatically applies whatever
 bias (shift) is required so that the resulting pixel values
 are non-negative.
 (2) The kernel is always normalized.  If there are no negative
 values in the kernel, a standard normalized convolution is
 performed, with 8 bpp output.  If the sum of kernel values is
 very close to zero, the kernel can not be normalized and
 the convolution will not be performed.  An error message results.
 (3) If there are negative values in the kernel, the pix is
 converted to an fpix, the convolution is done on the fpix, and
 a bias (shift) may need to be applied.
 (4) If force8 == TRUE and the range of values after the convolution
 is GT 255, the output values will be scaled to fit in [0 ... 255].
 If force8 == FALSE, the output will be either 8 or 16 bpp,
 to accommodate the dynamic range of output values without scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="kel1"></param>
	<param name="kel2">; use if separable</param>
	<param name="force8">if 1, force output to 8 bpp; otherwise, determine output depth by the dynamic range of pixel values</param>
	<param name="pbias">applied bias</param>
	<returns>pixd 8 or 16 bpp</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_setConvolveSampling(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This sets the x and y output subsampling factors for generic pix
 and fpix convolution.  The default values are 1 (no subsampling).
 </summary>
	<remarks>
	</remarks>
	<param name="xfact">integer GT= 1</param>
	<param name="yfact">integer GT= 1</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddGaussianNoise(LeptonicaSharp.Pix,System.Single)">
	<summary>
 Notes
 (1) This adds noise to each pixel, taken from a normal
 distribution with zero mean and specified standard deviation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb; no colormap</param>
	<param name="stdev">of noise</param>
	<returns>pixd 8 or 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gaussDistribSampling">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCorrelationScore(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32[],System.Single[]@)">
	<summary>
 Notes
 We check first that the two pix are roughly the same size.
 For jbclass (jbig2) applications at roughly 300 ppi, maxdiffw and
 maxdiffh should be at least 2.
 Only if they meet that criterion do we compare the bitmaps.
 The centroid difference is used to align the two images to the
 nearest integer for the correlation.
 The correlation score is the ratio of the square of the number of
 pixels in the AND of the two bitmaps to the product of the number
 of ON pixels in each.  Denote the number of ON pixels in pix1
 by |1|, the number in pix2 by |2|, and the number in the AND
 of pix1 and pix2 by |1  2|.  The correlation score is then
 (|1  2|)2 / (|1||2|).
 This score is compared with an input threshold, which can
 be modified depending on the weight of the template.
 The modified threshold is
 thresh + (1.0 - thresh)  weight  R
 where
 weight is a fixed input factor between 0.0 and 1.0
 R = |2| / area(2)
 and area(2) is the total number of pixels in 2 (i.e., width x height).
 To understand why a weight factor is useful, consider what happens
 with thick, sans-serif characters that look similar and have a value
 of R near 1.  Different characters can have a high correlation value,
 and the classifier will make incorrect substitutions.  The weight
 factor raises the threshold for these characters.
 Yet another approach to reduce such substitutions is to run the classifier
 in a non-greedy way, matching to the template with the highest
 score, not the first template with a score satisfying the matching
 constraint.  However, this is not particularly effective.
 The implementation here gives the same result as in
 pixCorrelationScoreSimple(), where a temporary Pix is made to hold
 the AND and implementation uses rasterop
 pixt = pixCreateTemplate(pix1);
 pixRasterop(pixt, idelx, idely, wt, ht, PIX_SRC, pix2, 0, 0);
 pixRasterop(pixt, 0, 0, wi, hi, PIX_SRC  PIX_DST, pix1, 0, 0);
 pixCountPixels(pixt, count, tab);
 pixDestroy(pixt);
 However, here it is done in a streaming fashion, counting as it goes,
 and touching memory exactly once, giving a 3-4x speedup over the
 simple implementation.  This very fast correlation matcher was
 contributed by William Rucklidge.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">test pix, 1 bpp</param>
	<param name="pix2">exemplar pix, 1 bpp</param>
	<param name="area1">number of on pixels in pix1</param>
	<param name="area2">number of on pixels in pix2</param>
	<param name="delx">x comp of centroid difference</param>
	<param name="dely">y comp of centroid difference</param>
	<param name="maxdiffw">max width difference of pix1 and pix2</param>
	<param name="maxdiffh">max height difference of pix1 and pix2</param>
	<param name="tab">sum tab for byte</param>
	<param name="pscore">correlation score</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCorrelationScoreThresholded(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Single)">
	<summary>
 Notes
 We check first that the two pix are roughly the same size.
 Only if they meet that criterion do we compare the bitmaps.
 The centroid difference is used to align the two images to the
 nearest integer for the correlation.
 The correlation score is the ratio of the square of the number of
 pixels in the AND of the two bitmaps to the product of the number
 of ON pixels in each.  Denote the number of ON pixels in pix1
 by |1|, the number in pix2 by |2|, and the number in the AND
 of pix1 and pix2 by |1  2|.  The correlation score is then
 (|1  2|)2 / (|1||2|).
 This score is compared with an input threshold, which can
 be modified depending on the weight of the template.
 The modified threshold is
 thresh + (1.0 - thresh)  weight  R
 where
 weight is a fixed input factor between 0.0 and 1.0
 R = |2| / area(2)
 and area(2) is the total number of pixels in 2 (i.e., width x height).
 To understand why a weight factor is useful, consider what happens
 with thick, sans-serif characters that look similar and have a value
 of R near 1.  Different characters can have a high correlation value,
 and the classifier will make incorrect substitutions.  The weight
 factor raises the threshold for these characters.
 Yet another approach to reduce such substitutions is to run the classifier
 in a non-greedy way, matching to the template with the highest
 score, not the first template with a score satisfying the matching
 constraint.  However, this is not particularly effective.
 This very fast correlation matcher was contributed by William Rucklidge.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">test pix, 1 bpp</param>
	<param name="pix2">exemplar pix, 1 bpp</param>
	<param name="area1">number of on pixels in pix1</param>
	<param name="area2">number of on pixels in pix2</param>
	<param name="delx">x comp of centroid difference</param>
	<param name="dely">y comp of centroid difference</param>
	<param name="maxdiffw">max width difference of pix1 and pix2</param>
	<param name="maxdiffh">max height difference of pix1 and pix2</param>
	<param name="tab">sum tab for byte</param>
	<param name="downcount">count of 1 pixels below each row of pix1</param>
	<param name="score_threshold"></param>
	<returns>whether the correlation score is GT= score_threshold</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCorrelationScoreSimple(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32[],System.Single[]@)">
	<summary>
 Notes
 (1) This calculates exactly the same value as pixCorrelationScore().
 It is 2-3x slower, but much simpler to understand.
 (2) The returned correlation score is 0.0 if the width or height
 exceed %maxdiffw or %maxdiffh.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">test pix, 1 bpp</param>
	<param name="pix2">exemplar pix, 1 bpp</param>
	<param name="area1">number of on pixels in pix1</param>
	<param name="area2">number of on pixels in pix2</param>
	<param name="delx">x comp of centroid difference</param>
	<param name="dely">y comp of centroid difference</param>
	<param name="maxdiffw">max width difference of pix1 and pix2</param>
	<param name="maxdiffh">max height difference of pix1 and pix2</param>
	<param name="tab">sum tab for byte</param>
	<param name="pscore">correlation score, in range [0.0 ... 1.0]</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCorrelationScoreShifted(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[],System.Single[]@)">
	<summary>
 Notes
 (1) This finds the correlation between two 1 bpp images,
 when pix2 is shifted by (delx, dely) with respect
 to each other.
 (2) This is implemented by starting with a copy of pix1 and
 ANDing its pixels with those of a shifted pix2.
 (3) Get the pixel counts for area1 and area2 using piCountPixels().
 (4) A good estimate for a shift that would maximize the correlation
 is to align the centroids (cx1, cy1; cx2, cy2), giving the
 relative translations etransx and etransy
 etransx = cx1 - cx2
 etransy = cy1 - cy2
 Typically delx is chosen to be near etransx; ditto for dely.
 This function is used in pixBestCorrelation(), where the
 translations delx and dely are varied to find the best alignment.
 (5) We do not check the sizes of pix1 and pix2, because they should
 be comparable.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">1 bpp</param>
	<param name="pix2">1 bpp</param>
	<param name="area1">number of on pixels in pix1</param>
	<param name="area2">number of on pixels in pix2</param>
	<param name="delx">x translation of pix2 relative to pix1</param>
	<param name="dely">y translation of pix2 relative to pix1</param>
	<param name="tab">sum tab for byte</param>
	<param name="pscore">correlation score</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpCreate(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) The input pixs is either full resolution or 2x reduced.
 (2) The page number is typically 0-based.  If scanned from a book,
 the even pages are usually on the left.  Disparity arrays
 built for even pages should only be applied to even pages.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pageno">page number</param>
	<returns>dew or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpCreateRef(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This specifies which dewarp struct should be used for
 the given page.  It is placed in dewarpa for pages
 for which no model can be built.
 (2) This page and the reference page have the same parity and
 the reference page is the closest page with a disparity model
 to this page.
 </summary>
	<remarks>
	</remarks>
	<param name="pageno">this page number</param>
	<param name="refpage">page number of dewarp disparity arrays to be used</param>
	<returns>dew or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpDestroy(LeptonicaSharp.L_Dewarp@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdew">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaCreate(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The sampling, minlines and maxdist parameters will be
 applied to all images.
 (2) The sampling factor is used for generating the disparity arrays
 from the input image.  For 2x reduced input, use a sampling
 factor that is half the sampling you want on the full resolution
 images.
 (3) Use %redfactor = 1 for full resolution; 2 for 2x reduction.
 All input images must be at one of these two resolutions.
 (4) %minlines is the minimum number of nearly full-length lines
 required to generate a vertical disparity array.  The default
 number is 15.  Use a smaller number to accept a questionable
 array, but not smaller than 4.
 (5) When a model can't be built for a page, it looks up to %maxdist
 in either direction for a valid model with the same page parity.
 Use -1 for the default value of %maxdist; use 0 to avoid using
 a ref model.
 (6) The ptr array is expanded as necessary to accommodate page images.
 </summary>
	<remarks>
	</remarks>
	<param name="nptrs">number of dewarp page ptrs; typically the number of pages</param>
	<param name="sampling">use 0 for default value; the minimum allowed is 8</param>
	<param name="redfactor">of input images 1 is full resolution; 2 is 2x reduced</param>
	<param name="minlines">minimum number of lines to accept; use 0 for default</param>
	<param name="maxdist">for locating reference disparity; use -1 for default</param>
	<returns>dewa or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaCreateFromPixacomp(LeptonicaSharp.PixaComp,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The returned dewa has disparity arrays calculated and
 is ready for serialization or for use in dewarping.
 (2) The sampling, minlines and maxdist parameters are
 applied to all images.  See notes in dewarpaCreate() for details.
 (3) The pixac is full.  Placeholders, if any, are w=h=d=1 images,
 and the real input images are 1 bpp at full resolution.
 They are assumed to be cropped to the actual page regions,
 and may be arbitrarily sparse in the array.
 (4) The output dewarpa is indexed by the page number.
 The offset in the pixac gives the mapping between the
 array index in the pixac and the page number.
 (5) This adds the ref page models.
 (6) This can be used to make models for any desired set of pages.
 The direct models are only made for pages with images in
 the pixacomp; the ref models are made for pages of the
 same parity within %maxdist of the nearest direct model.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac">pixacomp of G4, 1 bpp images; with 1x1x1 placeholders</param>
	<param name="useboth">0 for only vert disparity; 1 for both vert and horiz</param>
	<param name="sampling">use -1 or 0 for default value; otherwise minimum of 5</param>
	<param name="minlines">minimum number of lines to accept; e.g., 10</param>
	<param name="maxdist">for locating reference disparity; use -1 for default</param>
	<returns>dewa or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaDestroy(LeptonicaSharp.L_Dewarpa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdewa">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaDestroyDewarp(LeptonicaSharp.L_Dewarpa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="pageno">of dew to be destroyed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaInsertDewarp(LeptonicaSharp.L_Dewarpa,LeptonicaSharp.L_Dewarp)">
	<summary>
 Notes
 (1) This inserts the dewarp into the array, which now owns it.
 It also keeps track of the largest page number stored.
 It must be done before the disparity model is built.
 (2) Note that this differs from the usual method of filling out
 arrays in leptonica, where the arrays are compact and
 new elements are typically added to the end.  Here,
 the dewarp can be added anywhere, even beyond the initial
 allocation.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="dew">to be added</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaGetDewarp(LeptonicaSharp.L_Dewarpa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dewa">populated with dewarp structs for pages</param>
	<param name="index">into dewa this is the pageno</param>
	<returns>dew handle; still owned by dewa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaSetCurvatures(LeptonicaSharp.L_Dewarpa,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Approximating the line by a quadratic, the coefficient
 of the quadratic term is the curvature, and distance
 units are in pixels (of course).  The curvature is very
 small, so we multiply by 10^6 and express the constraints
 on the model curvatures in micro-units.
 (2) This sets five curvature thresholds and a slope threshold
 the maximum absolute value of the vertical disparity
 line curvatures
 the minimum absolute value of the largest difference in
 vertical disparity line curvatures (Use a value of 0
 to accept all models.)
 the maximum absolute value of the largest difference in
 vertical disparity line curvatures
 the maximum absolute value of the left and right edge
 curvature for the horizontal disparity
 the maximum absolute value of the difference between
 left and right edge curvature for the horizontal disparity
 all in micro-units, for dewarping to take place.
 Use -1 for default values.
 (3) An image with a line curvature less than about 0.00001
 has fairly straight textlines.  This is 10 micro-units.
 (4) For example, if %max_linecurv == 100, this would prevent dewarping
 if any of the lines has a curvature exceeding 100 micro-units.
 A model having maximum line curvature larger than about 150
 micro-units should probably not be used.
 (5) A model having a left or right edge curvature larger than
 about 100 micro-units should probably not be used.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="max_linecurv">-1 for default</param>
	<param name="min_diff_linecurv">-1 for default; 0 to accept all models</param>
	<param name="max_diff_linecurv">-1 for default</param>
	<param name="max_edgecurv">-1 for default</param>
	<param name="max_diff_edgecurv">-1 for default</param>
	<param name="max_edgeslope">-1 for default</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaUseBothArrays(LeptonicaSharp.L_Dewarpa,System.Int32)">
	<summary>
 Notes
 (1) This sets the useboth field.  If set, this will attempt
 to apply both vertical and horizontal disparity arrays.
 Note that a model with only a vertical disparity array will
 always be valid.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="useboth">0 for false, 1 for true</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaSetCheckColumns(LeptonicaSharp.L_Dewarpa,System.Int32)">
	<summary>
 Notes
 (1) This sets the 'check_columns" field.  If set, and if
 'useboth' is set, this will count the number of text
 columns.  If the number is larger than 1, this will
 prevent the application of horizontal disparity arrays
 if they exist.  Note that the default value of check_columns
 if 0 (FALSE).
 (2) This field is set to 0 by default.  For horizontal disparity
 correction to take place on a single column of text, you must have
 - a valid horizontal disparity array
 - useboth = 1 (TRUE)
 If there are multiple columns, additionally
 - check_columns = 0 (FALSE)
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="check_columns">0 for false, 1 for true</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaSetMaxDistance(LeptonicaSharp.L_Dewarpa,System.Int32)">
	<summary>
 Notes
 (1) This sets the maxdist field.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="maxdist">for using ref models</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>dew, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpReadStream(LeptonicaSharp.FILE)">
	<summary>
 Notes
 (1) The dewarp struct is stored in minimized format, with only
 subsampled disparity arrays.
 (2) The sampling and extra horizontal disparity parameters are
 stored here.  During generation of the dewarp struct, they
 are passed in from the dewarpa.  In readback, it is assumed
 that they are (a) the same for each page and (b) the same
 as the values used to create the dewarpa.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>dew, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization of dewarp</param>
	<param name="size">of data in bytes</param>
	<returns>dew  dewarp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpWrite(System.String,LeptonicaSharp.L_Dewarp)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="dew"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.L_Dewarp)">
	<summary>
 Notes
 (1) This should not be written if there is no sampled
 vertical disparity array, which means that no model has
 been built for this page.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="dew"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.L_Dewarp)">
	<summary>
 Notes
 (1) Serializes a dewarp in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized dewarp (not ascii)</param>
	<param name="psize">size of returned data</param>
	<param name="dew"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>dewa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaReadStream(LeptonicaSharp.FILE)">
	<summary>
 Notes
 (1) The serialized dewarp contains a Numa that gives the
 (increasing) page number of the dewarp structs that are
 contained.
 (2) Reference pages are added in after readback.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>dewa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization of dewarpa</param>
	<param name="size">of data in bytes</param>
	<returns>dewa  dewarpa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaWrite(System.String,LeptonicaSharp.L_Dewarpa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="dewa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.L_Dewarpa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="dewa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.L_Dewarpa)">
	<summary>
 Notes
 (1) Serializes a dewarpa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized dewarpa (not ascii)</param>
	<param name="psize">size of returned data</param>
	<param name="dewa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpBuildPageModel(LeptonicaSharp.L_Dewarp,System.String)">
	<summary>
 Notes
 (1) This is the basic function that builds the horizontal and
 vertical disparity arrays, which allow determination of the
 src pixel in the input image corresponding to each
 dest pixel in the dewarped image.
 (2) Sets vsuccess = 1 if the vertical disparity array builds.
 Always attempts to build the horizontal disparity array,
 even if it will not be requested (useboth == 0).
 Sets hsuccess = 1 if horizontal disparity builds.
 (3) The method is as follows
 (a) Estimate the points along the centers of all the
 long textlines.  If there are too few lines, no
 disparity models are built.
 (b) From the vertical deviation of the lines, estimate
 the vertical disparity.
 (c) From the ends of the lines, estimate the horizontal
 disparity, assuming that the text is made of lines
 that are close to left and right justified.
 (d) One can also compute an additional contribution to the
 horizontal disparity, inferred from slopes of the top
 and bottom lines.  We do not do this.
 (4) In more detail for the vertical disparity
 (a) Fit a LS quadratic to center locations along each line.
 This smooths the curves.
 (b) Sample each curve at a regular interval, find the y-value
 of the mid-point on each curve, and subtract the sampled
 curve value from this value.  This is the vertical
 disparity at sampled points along each curve.
 (c) Fit a LS quadratic to each set of vertically aligned
 disparity samples.  This smooths the disparity values
 in the vertical direction.  Then resample at the same
 regular interval.  We now have a regular grid of smoothed
 vertical disparity valuels.
 (5) Once the sampled vertical disparity array is found, it can be
 interpolated to get a full resolution vertical disparity map.
 This can be applied directly to the src image pixels
 to dewarp the image in the vertical direction, making
 all textlines horizontal.  Likewise, the horizontal
 disparity array is used to left- and right-align the
 longest textlines.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="debugfile">writing this</param>
	<returns>0 if OK, 1 if unable to build the model or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpFindVertDisparity(LeptonicaSharp.L_Dewarp,LeptonicaSharp.Ptaa,System.Int32)">
	<summary>
 Notes
 (1) This starts with points along the centers of textlines.
 It does quadratic fitting (and smoothing), first along the
 lines and then in the vertical direction, to generate
 the sampled vertical disparity map.  This can then be
 interpolated to full resolution and used to remove
 the vertical line warping.
 (2) Use %rotflag == 1 if you are dewarping vertical lines, as
 is done in dewarpBuildLineModel().  The usual case is for
 %rotflag == 0.
 (3) Note that this builds a vertical disparity model (VDM), but
 does not check it against constraints for validity.
 Constraint checking is done after building the models,
 and before inserting reference models.
 (4) This sets the vsuccess flag to 1 on success.
 (5) Pix debug output goes to /tmp/dewvert/ for collection into
 a pdf.  Non-pix debug output goes to /tmp.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="ptaa">unsmoothed lines, not vertically ordered</param>
	<param name="rotflag">0 if using dew-GTpixs; 1 if rotated by 90 degrees cw</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpFindHorizDisparity(LeptonicaSharp.L_Dewarp,LeptonicaSharp.Ptaa)">
	<summary>
 Notes
 (1) This builds a horizontal disparity model (HDM), but
 does not check it against constraints for validity.
 Constraint checking is done at rendering time.
 (2) Horizontal disparity is not required for a successful model;
 only the vertical disparity is required.  This will not be
 called if the function to build the vertical disparity fails.
 (3) This sets the hsuccess flag to 1 on success.
 (4) Internally in ptal1, ptar1, ptal2, ptar2 x and y are reversed,
 so the 'y' value is horizontal distance across the image width.
 (5) Debug output goes to /tmp/lept/dewmod/ for collection into a pdf.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="ptaa">unsmoothed lines, not vertically ordered</param>
	<returns>0 if OK, 1 if horizontal disparity array is not built, or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpGetTextlineCenters(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This in general does not have a point for each value
 of x, because there will be gaps between words.
 It doesn't matter because we will fit a quadratic to the
 points that we do have.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="debugflag">1 for debug output</param>
	<returns>ptaa of center values of textlines</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpRemoveShortLines(LeptonicaSharp.Pix,LeptonicaSharp.Ptaa,System.Single,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="ptaas">input lines</param>
	<param name="fract">minimum fraction of longest line to keep</param>
	<param name="debugflag"></param>
	<returns>ptaad containing only lines of sufficient length, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpFindHorizSlopeDisparity(LeptonicaSharp.L_Dewarp,LeptonicaSharp.Pix,System.Single,System.Int32)">
	<summary>
 Notes
 (1) %fractthresh is a threshold on the fractional difference in stroke
 density between between left and right sides.  Process this
 disparity only if the absolute value of the fractional
 difference equals or exceeds this threshold.
 (2) %parity indicates where the binding is on the left for
 %parity == 0 and on the right for %parity == 1.
 (3) This takes a 1 bpp %pixb where both vertical and horizontal
 disparity have been applied, so the text lines are straight and,
 more importantly, the line end points are vertically aligned.
 It estimates the foreshortening of the characters on the
 binding side, and if significant, computes a one-dimensional
 horizontal disparity function to compensate.
 (4) The first attempt was to use the average width of the
 connected components (c.c.) in vertical slices.  This does not work
 reliably, because the horizontal compression of the text is
 often accompanied by horizontal joining of c.c.
 (5) We use the density of vertical strokes, measured by first using
 a vertical opening, which improves the signal.  The result
 is relatively insensitive to the size of the opening; we use
 a 10-pixel opening.  The relative density is measured by
 finding the number of c.c. in a full height sliding window
 of width 50 pixels, and compute every 25 pixels.  Similar results
 are obtained counting c.c. that either intersect the window
 or are fully contained within it.
 (6) Debug output goes to /tmp/lept/dewmod/ for collection into a pdf.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="pixb">(1 bpp, with vertical and horizontal disparity removed)</param>
	<param name="fractthresh">(threshold fractional difference in density)</param>
	<param name="parity">(0 if even page, 1 if odd page)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpBuildLineModel(LeptonicaSharp.L_Dewarp,System.Int32,System.String)">
	<summary>
 Notes
 (1) This builds the horizontal and vertical disparity arrays
 for an input of ruled lines, typically for calibration.
 In book scanning, you could lay the ruled paper over a page.
 Then for that page and several below it, you can use the
 disparity correction of the line model to dewarp the pages.
 (2) The dew has been initialized with the image of ruled lines.
 These lines must be continuous, but we do a small amount
 of pre-processing here to insure that.
 (3) %opensize is typically about 8.  It must be larger than
 the thickness of the lines to be extracted.  This is the
 default value, which is applied if %opensize LT 3.
 (4) Sets vsuccess = 1 and hsuccess = 1 if the vertical and/or
 horizontal disparity arrays build.
 (5) Similar to dewarpBuildPageModel(), except here the vertical
 and horizontal disparity arrays are both built from ruled lines.
 See notes there.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="opensize">size of opening to remove perpendicular lines</param>
	<param name="debugfile">writing this</param>
	<returns>0 if OK, 1 if unable to build the model or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaModelStatus(LeptonicaSharp.L_Dewarpa,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This tests if a model has been built, not if it is valid.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="pageno"></param>
	<param name="pvsuccess">1 on success</param>
	<param name="phsuccess">1 on success</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaApplyDisparity(LeptonicaSharp.L_Dewarpa,System.Int32,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@,System.String)">
	<summary>
 Notes
 (1) This applies the disparity arrays to the specified image.
 (2) Specify gray color for pixels brought in from the outside
 0 is black, 255 is white.  Use -1 to select pixels from the
 boundary of the source image.
 (3) If the models and ref models have not been validated, this
 will do so by calling dewarpaInsertRefModels().
 (4) This works with both stripped and full resolution page models.
 If the full res disparity array(s) are missing, they are remade.
 (5) The caller must handle errors that are returned because there
 are no valid models or ref models for the page -- typically
 by using the input pixs.
 (6) If there is no model for %pageno, this will use the model for
 'refpage' and put the result in the dew for %pageno.
 (7) This populates the full resolution disparity arrays if
 necessary.  If x and/or y are positive, they are used,
 in conjunction with pixs, to determine the required
 slope-based extension of the full resolution disparity
 arrays in each direction.  When (x,y) == (0,0), all
 extension is to the right and down.  Nonzero values of (x,y)
 are useful for dewarping when pixs is deliberately undercropped.
 (8) Important when applying disparity to a number of images,
 after calling this function and saving the resulting pixd,
 you should call dewarpMinimize(dew) on the dew for %pageno.
 This will remove pixs and pixd (or their clones) stored in dew,
 as well as the full resolution disparity arrays.  Together,
 these hold approximately 16 bytes for each pixel in pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="pageno">of page model to be used; may be a ref model</param>
	<param name="pixs">image to be modified; can be 1, 8 or 32 bpp</param>
	<param name="grayin">gray value, from 0 to 255, for pixels brought in; use -1 to use pixels on the boundary of pixs</param>
	<param name="x">origin for generation of disparity arrays</param>
	<param name="y">origin for generation of disparity arrays</param>
	<param name="ppixd">disparity corrected image</param>
	<param name="debugfile">writing this</param>
	<returns>0 if OK, 1 on error no models or ref models available</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaApplyDisparityBoxa(LeptonicaSharp.L_Dewarpa,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.Boxa,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Boxa@,System.String)">
	<summary>
 Notes
 (1) This applies the disparity arrays in one of two mapping directions
 to the specified boxa.  It can be used in the backward direction
 to locate a box in the original coordinates that would have
 been dewarped to to the specified image.
 (2) If there is no model for %pageno, this will use the model for
 'refpage' and put the result in the dew for %pageno.
 (3) This works with both stripped and full resolution page models.
 If the full res disparity array(s) are missing, they are remade.
 (4) If an error occurs, a copy of the input boxa is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="pageno">of page model to be used; may be a ref model</param>
	<param name="pixs">initial pix reference; for alignment and debugging</param>
	<param name="boxas">boxa to be mapped</param>
	<param name="mapdir">1 if mapping forward from original to dewarped; 0 if backward</param>
	<param name="x">origin for generation of disparity arrays with respect to the source region</param>
	<param name="y">origin for generation of disparity arrays with respect to the source region</param>
	<param name="pboxad">disparity corrected boxa</param>
	<param name="debugfile">writing this</param>
	<returns>0 if OK, 1 on error no models or ref models available</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpMinimize(LeptonicaSharp.L_Dewarp)">
	<summary>
 Notes
 (1) This removes all data that is not needed for serialization.
 It keeps the subsampled disparity array(s), so the full
 resolution arrays can be reconstructed.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpPopulateFullRes(LeptonicaSharp.L_Dewarp,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If the full resolution vertical and horizontal disparity
 arrays do not exist, they are built from the subsampled ones.
 (2) If pixs is not given, the size of the arrays is determined
 by the original image from which the sampled version was
 generated.  Any values of (x,y) are ignored.
 (3) If pixs is given, the full resolution disparity arrays must
 be large enough to accommodate it.
 (a) If the arrays do not exist, the value of (x,y) determines
 the origin of the full resolution arrays without extension,
 relative to pixs.  Thus, (x,y) gives the amount of
 slope extension in (left, top).  The (right, bottom)
 extension is then determined by the size of pixs and
 (x,y); the values should never be LT 0.
 (b) If the arrays exist and pixs is too large, the existing
 full res arrays are destroyed and new ones are made,
 again using (x,y) to determine the extension in the
 four directions.
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="pix">, to give size of actual image</param>
	<param name="x">origin for generation of disparity arrays</param>
	<param name="y">origin for generation of disparity arrays</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpSinglePage(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.L_Dewarpa@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) Dewarps pixs and returns the result in pixd.
 (2) This uses default values for all model parameters.
 (3) If pixs is 1 bpp, the parameters %adaptive and %thresh are ignored.
 (4) If it can't build a model, returns a copy of pixs in pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">with text, any depth</param>
	<param name="thresh">for global thresholding to 1 bpp; ignored otherwise</param>
	<param name="adaptive">1 for adaptive thresholding; 0 for global threshold</param>
	<param name="useboth">1 for horizontal and vertical; 0 for vertical only</param>
	<param name="check_columns">1 to skip horizontal if multiple columns; 0 otherwise; default is to skip</param>
	<param name="ppixd">dewarped result</param>
	<param name="pdewa">dewa with single page; NULL to skip</param>
	<param name="debug">1 for debugging output, 0 otherwise</param>
	<returns>0 if OK, 1 on error list of page numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpSinglePageInit(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.L_Dewarpa@)">
	<summary>
 Notes
 (1) This binarizes the input pixs if necessary, returning the
 binarized image.  It also initializes the dewa to default values
 for the model parameters.
 (2) If pixs is 1 bpp, the parameters %adaptive and %thresh are ignored.
 (3) To change the model parameters, call dewarpaSetCurvatures()
 before running dewarpSinglePageRun().  For example
 dewarpSinglePageInit(pixs, 0, 1, 1, 1, pixb, dewa);
 dewarpaSetCurvatures(dewa, 250, -1, -1, 80, 70, 150);
 dewarpSinglePageRun(pixs, pixb, dewa, pixd, 0);
 dewarpaDestroy(dewa);
 pixDestroy(pixb);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">with text, any depth</param>
	<param name="thresh">for global thresholding to 1 bpp; ignored otherwise</param>
	<param name="adaptive">1 for adaptive thresholding; 0 for global threshold</param>
	<param name="useboth">1 for horizontal and vertical; 0 for vertical only</param>
	<param name="check_columns">1 to skip horizontal if multiple columns; 0 otherwise; default is to skip</param>
	<param name="ppixb">1 bpp image</param>
	<param name="pdewa">initialized dewa</param>
	<returns>0 if OK, 1 on error list of page numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpSinglePageRun(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.L_Dewarpa,LeptonicaSharp.Pix@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) Dewarps pixs and returns the result in pixd.
 (2) The 1 bpp version %pixb and %dewa are conveniently generated by
 dewarpSinglePageInit().
 (3) Non-default model parameters must be set before calling this.
 (4) If a model cannot be built, this returns a copy of pixs in pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="pixb">1 bpp</param>
	<param name="dewa">initialized</param>
	<param name="ppixd">dewarped result</param>
	<param name="debug">1 for debugging output, 0 otherwise</param>
	<returns>0 if OK, 1 on error list of page numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaListPages(LeptonicaSharp.L_Dewarpa)">
	<summary>
 Notes
 (1) This generates two numas, stored in the dewarpa, that give
 (a) the page number for each dew that has a page model.
 (b) the page number for each dew that has either a page
 model or a reference model.
 It can be called at any time.
 (2) It is called by the dewarpa serializer before writing.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa">populated with dewarp structs for pages</param>
	<returns>0 if OK, 1 on error list of page numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaSetValidModels(LeptonicaSharp.L_Dewarpa,System.Int32,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) A valid model must meet the rendering requirements, which
 include whether or not a vertical disparity model exists
 and conditions on curvatures for vertical and horizontal
 disparity models.
 (2) If %notests == 1, this ignores the curvature constraints
 and assumes that all successfully built models are valid.
 (3) This function does not need to be called by the application.
 It is called by dewarpaInsertRefModels(), which
 will destroy all invalid dewarps.  Consequently, to inspect
 an invalid dewarp model, it must be done before calling
 dewarpaInsertRefModels().
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="notests"></param>
	<param name="debug">1 to output information on invalid page models</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaInsertRefModels(LeptonicaSharp.L_Dewarpa,System.Int32,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This destroys all dewarp models that are invalid, and then
 inserts reference models where possible.
 (2) If %notests == 1, this ignores the curvature constraints
 and assumes that all successfully built models are valid.
 (3) If useboth == 0, it uses the closest valid model within the
 distance and parity constraints.  If useboth == 1, it tries
 to use the closest allowed hvalid model; if it doesn't find
 an hvalid model, it uses the closest valid model.
 (4) For all pages without a model, this clears out any existing
 invalid and reference dewarps, finds the nearest valid model
 with the same parity, and inserts an empty dewarp with the
 reference page.
 (5) Then if it is requested to use both vertical and horizontal
 disparity arrays (useboth == 1), it tries to replace any
 hvalid == 0 model or reference with an hvalid == 1 reference.
 (6) The distance constraint is that any reference model must
 be within maxdist.  Note that with the parity constraint,
 no reference models will be used if maxdist LT 2.
 (7) This function must be called, even if reference models will
 not be used.  It should be called after building models on all
 available pages, and after setting the rendering parameters.
 (8) If the dewa has been serialized, this function is called by
 dewarpaRead() when it is read back.  It is also called
 any time the rendering parameters are changed.
 (9) Note if this has been called with useboth == 1, and useboth
 is reset to 0, you should first call dewarpaRestoreModels()
 to bring real models from the cache back to the primary array.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="notests">if 1, ignore curvature constraints on model</param>
	<param name="debug">1 to output information on invalid page models</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaStripRefModels(LeptonicaSharp.L_Dewarpa)">
	<summary>
 Notes
 (1) This examines each dew in a dewarpa, and removes
 all that don't have their own page model (i.e., all
 that have "references" to nearby pages with valid models).
 These references were generated by dewarpaInsertRefModels(dewa).
 </summary>
	<remarks>
	</remarks>
	<param name="dewa">populated with dewarp structs for pages</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaRestoreModels(LeptonicaSharp.L_Dewarpa)">
	<summary>
 Notes
 (1) This puts all real models (and only real models) in the
 primary dewarpa array.  First remove all dewarps that are
 only references to other page models.  Then move all models
 that had been cached back into the primary dewarp array.
 (2) After this is done, we still need to recompute and insert
 the reference models before dewa-GTmodelsready is true.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa">populated with dewarp structs for pages</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaInfo(LeptonicaSharp.FILE,LeptonicaSharp.L_Dewarpa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp"></param>
	<param name="dewa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaModelStats(LeptonicaSharp.L_Dewarpa,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) A page without a model has no dew.  It most likely failed to
 generate a vertical model, and has not been assigned a ref
 model from a neighboring page with a valid vertical model.
 (2) A page has vsuccess == 1 if there is at least a model of the
 vertical disparity.  The model may be invalid, in which case
 dewarpaInsertRefModels() will stash it in the cache and
 attempt to replace it by a valid ref model.
 (3) A vvvalid model is a vertical disparity model whose parameters
 satisfy the constraints given in dewarpaSetValidModels().
 (4) A page has hsuccess == 1 if both the vertical and horizontal
 disparity arrays have been constructed.
 (5) An  hvalid model has vertical and horizontal disparity
 models whose parameters satisfy the constraints given
 in dewarpaSetValidModels().
 (6) A page has a ref model if it failed to generate a valid
 model but was assigned a vvalid or hvalid model on another
 page (within maxdist) by dewarpaInsertRefModel().
 (7) This calls dewarpaTestForValidModel(); it ignores the vvalid
 and hvalid fields.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="pnnone">number without any model</param>
	<param name="pnvsuccess">number with a vert model</param>
	<param name="pnvvalid">number with a valid vert model</param>
	<param name="pnhsuccess">number with both models</param>
	<param name="pnhvalid">number with both models valid</param>
	<param name="pnref">number with a reference model</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpaShowArrays(LeptonicaSharp.L_Dewarpa,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Generates a pdf of contour plots of the disparity arrays.
 (2) This only shows actual models; not ref models
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="scalefact">on contour images; typ. 0.5</param>
	<param name="first">first page model to render</param>
	<param name="last">last page model to render; use 0 to go to end</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpDebug(LeptonicaSharp.L_Dewarp,System.String,System.Int32)">
	<summary>
 Notes
 (1) Prints dewarp fields and generates disparity array contour images.
 The contour images are written to file
 /tmp/[subdirs]/pixv_[index].png
 </summary>
	<remarks>
	</remarks>
	<param name="dew"></param>
	<param name="subdirs">one or more subdirectories of /tmp; e.g., "dew1"</param>
	<param name="index">to help label output images; e.g., the page number</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dewarpShowResults(LeptonicaSharp.L_Dewarpa,LeptonicaSharp.Sarray,LeptonicaSharp.Boxa,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) This generates a pdf of image pairs (before, after) for
 the designated set of input pages.
 (2) If the boxa exists, its elements are aligned with numbers
 in the filenames in %sa.  It is used to crop the input images.
 It is assumed that the dewa was generated from the cropped
 images.  No undercropping is applied before rendering.
 </summary>
	<remarks>
	</remarks>
	<param name="dewa"></param>
	<param name="sa">of indexed input images</param>
	<param name="boxa">crop boxes for input images; can be null</param>
	<param name="firstpage"></param>
	<param name="lastpage"></param>
	<param name="pdfout">filename</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of number array to be alloc'd; 0 for default</param>
	<returns>da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaCreateFromIArray(System.Int32[],System.Int32)">
	<summary>
 Notes
 (1) We can't insert this int array into the l_dna, because a l_dna
 takes a double array.  So this just copies the data from the
 input array into the l_dna.  The input array continues to be
 owned by the caller.
 </summary>
	<remarks>
	</remarks>
	<param name="iarray">integer</param>
	<param name="size">of the array</param>
	<returns>da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaCreateFromDArray(System.Double[],System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) With L_INSERT, ownership of the input array is transferred
 to the returned l_dna, and all %size elements are considered
 to be valid.
 </summary>
	<remarks>
	</remarks>
	<param name="darray">float</param>
	<param name="size">of the array</param>
	<param name="copyflag">L_INSERT or L_COPY</param>
	<returns>da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaMakeSequence(System.Double,System.Double,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="startval"></param>
	<param name="increment"></param>
	<param name="size">of sequence</param>
	<returns>l_dna of sequence of evenly spaced values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaDestroy(LeptonicaSharp.L_Dna@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the l_dna.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pda">to be nulled if it exists</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaCopy(LeptonicaSharp.L_Dna)">
	<summary>
 Notes
 (1) This removes unused ptrs above da-GTn.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>copy of da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaClone(LeptonicaSharp.L_Dna)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>ptr to same da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaEmpty(LeptonicaSharp.L_Dna)">
	<summary>
 Notes
 (1) This does not change the allocation of the array.
 It just clears the number of stored numbers, so that
 the array appears to be empty.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaAddNumber(LeptonicaSharp.L_Dna,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="val">float or int to be added; stored as a float</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaInsertNumber(LeptonicaSharp.L_Dna,System.Int32,System.Double)">
	<summary>
 Notes
 (1) This shifts da[i] --GT da[i + 1] for all i GT= index,
 and then inserts val as da[index].
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">location in da to insert new value</param>
	<param name="val">float64 or integer to be added</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaRemoveNumber(LeptonicaSharp.L_Dna,System.Int32)">
	<summary>
 Notes
 (1) This shifts da[i] --GT da[i - 1] for all i GT index.
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">element to be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaReplaceNumber(LeptonicaSharp.L_Dna,System.Int32,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">element to be replaced</param>
	<param name="val">new value to replace old one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaGetCount(LeptonicaSharp.L_Dna)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>count, or 0 if no numbers or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaSetCount(LeptonicaSharp.L_Dna,System.Int32)">
	<summary>
 Notes
 (1) If newcount LT= da-GTnalloc, this resets da-GTn.
 Using newcount = 0 is equivalent to l_dnaEmpty().
 (2) If newcount GT da-GTnalloc, this causes a realloc
 to a size da-GTnalloc = newcount.
 (3) All the previously unused values in da are set to 0.0.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="newcount"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaGetDValue(LeptonicaSharp.L_Dna,System.Int32,System.Double[]@)">
	<summary>
 Notes
 (1) Caller may need to check the function return value to
 decide if a 0.0 in the returned ival is valid.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">into l_dna</param>
	<param name="pval">double value; 0.0 on error</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaGetIValue(LeptonicaSharp.L_Dna,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Caller may need to check the function return value to
 decide if a 0 in the returned ival is valid.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">into l_dna</param>
	<param name="pival">integer value; 0 on error</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaSetValue(LeptonicaSharp.L_Dna,System.Int32,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">to element to be set</param>
	<param name="val">to set element</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaShiftValue(LeptonicaSharp.L_Dna,System.Int32,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="index">to element to change relative to the current value</param>
	<param name="diff">increment if diff GT 0 or decrement if diff LT 0</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaGetIArray(LeptonicaSharp.L_Dna)">
	<summary>
 Notes
 (1) A copy of the array is made, because we need to
 generate an integer array from the bare double array.
 The caller is responsible for freeing the array.
 (2) The array size is determined by the number of stored numbers,
 not by the size of the allocated array in the l_dna.
 (3) This function is provided to simplify calculations
 using the bare internal array, rather than continually
 calling accessors on the l_dna.  It is typically used
 on an array of size 256.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>a copy of the bare internal array, integerized by rounding, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaGetDArray(LeptonicaSharp.L_Dna,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) If copyflag == L_COPY, it makes a copy which the caller
 is responsible for freeing.  Otherwise, it operates
 directly on the bare array of the l_dna.
 (2) Very important for L_NOCOPY, any writes to the array
 will be in the l_dna.  Do not write beyond the size of
 the count field, because it will not be accessible
 from the l_dna!  If necessary, be sure to set the count
 field to a larger number (such as the alloc size)
 BEFORE calling this function.  Creating with l_dnaMakeConstant()
 is another way to insure full initialization.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="copyflag">L_NOCOPY or L_COPY</param>
	<returns>either the bare internal array or a copy of it, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaGetRefcount(LeptonicaSharp.L_Dna)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>refcount, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaChangeRefcount(LeptonicaSharp.L_Dna,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="delta">change to be applied</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaGetParameters(LeptonicaSharp.L_Dna,System.Double[]@,System.Double[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="pstartx">startx</param>
	<param name="pdelx">delx</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaSetParameters(LeptonicaSharp.L_Dna,System.Double,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="startx">x value corresponding to da[0]</param>
	<param name="delx">difference in x values for the situation where the elements of da correspond to the evaulation of a function at equal intervals of size %delx</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaCopyParameters(LeptonicaSharp.L_Dna,LeptonicaSharp.L_Dna)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dad">destination DNuma</param>
	<param name="das">source DNuma</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaReadStream(LeptonicaSharp.FILE)">
	<summary>
 Notes
 (1) fscanf takes %lf to read a double; fprintf takes %f to write it.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaWrite(System.String,LeptonicaSharp.L_Dna)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="da"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.L_Dna)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="da"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of l_dna ptr array to be alloc'd 0 for default</param>
	<returns>daa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaCreateFull(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This allocates a dnaa and fills the array with allocated dnas.
 In use, after calling this function, use
 l_dnaaAddNumber(dnaa, index, val);
 to add val to the index-th dna in dnaa.
 </summary>
	<remarks>
	</remarks>
	<param name="nptr">size of dna ptr array to be alloc'd</param>
	<param name="n">size of individual dna arrays to be alloc'd 0 for default</param>
	<returns>daa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaTruncate(LeptonicaSharp.L_Dnaa)">
	<summary>
 Notes
 (1) This identifies the largest index containing a dna that
 has any numbers within it, destroys all dna beyond that
 index, and resets the count.
 </summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaDestroy(LeptonicaSharp.L_Dnaa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdaa">to be nulled if it exists</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaAddDna(LeptonicaSharp.L_Dnaa,LeptonicaSharp.L_Dna,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<param name="da">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaGetCount(LeptonicaSharp.L_Dnaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<returns>count number of l_dna, or 0 if no l_dna or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaGetDnaCount(LeptonicaSharp.L_Dnaa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<param name="index">of l_dna in daa</param>
	<returns>count of numbers in the referenced l_dna, or 0 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaGetNumberCount(LeptonicaSharp.L_Dnaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<returns>count total number of numbers in the l_dnaa, or 0 if no numbers or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaGetDna(LeptonicaSharp.L_Dnaa,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<param name="index">to the index-th l_dna</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>l_dna, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaReplaceDna(LeptonicaSharp.L_Dnaa,System.Int32,LeptonicaSharp.L_Dna)">
	<summary>
 Notes
 (1) Any existing l_dna is destroyed, and the input one
 is inserted in its place.
 (2) If the index is invalid, return 1 (error)
 </summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<param name="index">to the index-th l_dna</param>
	<param name="da">insert and replace any existing one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaGetValue(LeptonicaSharp.L_Dnaa,System.Int32,System.Int32,System.Double[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<param name="i">index of l_dna within l_dnaa</param>
	<param name="j">index into l_dna</param>
	<param name="pval">double value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaAddNumber(LeptonicaSharp.L_Dnaa,System.Int32,System.Double)">
	<summary>
 Notes
 (1) Adds to an existing l_dna only.
 </summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<param name="index">of l_dna within l_dnaa</param>
	<param name="val">number to be added; stored as a double</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>daa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>daa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaWrite(System.String,LeptonicaSharp.L_Dnaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="daa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.L_Dnaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="daa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaJoin(LeptonicaSharp.L_Dna,System.Int32,System.Int32,LeptonicaSharp.L_Dna)">
	<summary>
 Notes
 (1) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (2) iend LT 0 means 'read to the end'
 (3) if das == NULL, this is a no-op
 </summary>
	<remarks>
	</remarks>
	<param name="dad">dest dna; add to this one</param>
	<param name="das">source dna; add from this one</param>
	<param name="istart">starting index in das</param>
	<param name="iend">ending index in das; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaaFlattenToDna(LeptonicaSharp.L_Dnaa)">
	<summary>
 Notes
 (1) This 'flattens' the dnaa to a dna, by joining successively
 each dna in the dnaa.
 (2) It leaves the input dnaa unchanged.
 </summary>
	<remarks>
	</remarks>
	<param name="daa"></param>
	<returns>dad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaConvertToNuma(LeptonicaSharp.L_Dna)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaConvertToDna(LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>da, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaUnionByAset(LeptonicaSharp.L_Dna,LeptonicaSharp.L_Dna)">
	<summary>
 Notes
 (1) See sarrayUnionByAset() for the approach.
 (2) Here, the key in building the sorted tree is the number itself.
 (3) Operations using an underlying tree are O(nlogn), which is
 typically less efficient than hashing, which is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="da1"></param>
	<param name="da2"></param>
	<returns>dad with the union of the set of numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaRemoveDupsByAset(LeptonicaSharp.L_Dna)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="das"></param>
	<returns>dad with duplicates removed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaIntersectionByAset(LeptonicaSharp.L_Dna,LeptonicaSharp.L_Dna)">
	<summary>
 Notes
 (1) See sarrayIntersection() for the approach.
 (2) Here, the key in building the sorted tree is the number itself.
 (3) Operations using an underlying tree are O(nlogn), which is
 typically less efficient than hashing, which is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="da1"></param>
	<param name="da2"></param>
	<returns>dad with the intersection of the two arrays, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_asetCreateFromDna(LeptonicaSharp.L_Dna)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="da">source dna</param>
	<returns>set using the doubles in %da as keys</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaDiffAdjValues(LeptonicaSharp.L_Dna)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="das">input l_dna</param>
	<returns>dad of difference values val[i+1] - val[i], or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaHashCreate(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Actual dna are created only as required by l_dnaHashAdd()
 </summary>
	<remarks>
	</remarks>
	<param name="nbuckets">the number of buckets in the hash table, which should be prime.</param>
	<param name="initsize">initial size of each allocated dna; 0 for default</param>
	<returns>ptr to new dnahash, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaHashDestroy(LeptonicaSharp.L_DnaHash@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdahash">to be nulled, if it exists</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaHashGetCount(LeptonicaSharp.L_DnaHash)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dahash"></param>
	<returns>nbuckets allocated, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaHashGetTotalCount(LeptonicaSharp.L_DnaHash)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dahash"></param>
	<returns>n number of numbers in all dna, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaHashGetDna(LeptonicaSharp.L_DnaHash,System.UInt64,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dahash"></param>
	<param name="key">key to be hashed into a bucket number</param>
	<param name="copyflag">L_NOCOPY, L_COPY, L_CLONE</param>
	<returns>ptr to dna</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaHashAdd(LeptonicaSharp.L_DnaHash,System.UInt64,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dahash"></param>
	<param name="key">key to be hashed into a bucket number</param>
	<param name="value">float value to be appended to the specific dna</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaHashCreateFromDna(LeptonicaSharp.L_Dna)">
	<summary>
 Notes
 (1) The values stored in the %dahash are indices into %da;
 %dahash has no use without %da.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<returns>dahash if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaRemoveDupsByHash(LeptonicaSharp.L_Dna,LeptonicaSharp.L_Dna@,LeptonicaSharp.L_DnaHash@)">
	<summary>
 Notes
 (1) Generates a dna with unique values.
 (2) The dnahash is built up with dad to assure uniqueness.
 It can be used to find if an element is in the set
 l_dnaFindValByHash(dad, dahash, val, index)
 </summary>
	<remarks>
	</remarks>
	<param name="das"></param>
	<param name="pdad">hash set</param>
	<param name="pdahash">dnahash used for lookup</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaMakeHistoByHash(LeptonicaSharp.L_Dna,LeptonicaSharp.L_DnaHash@,LeptonicaSharp.L_Dna@,LeptonicaSharp.L_Dna@)">
	<summary>
 Notes
 (1) Generates and returns a dna of occurrences (histogram),
 an aligned dna of values, and an associated hashmap.
 The hashmap takes %dav and a value, and points into the
 histogram in %dac.
 (2) The dna of values, %dav, is aligned with the histogram %dac,
 and is needed for fast lookup.  It is a hash set, because
 the values are unique.
 (3) Lookup is simple
 l_dnaFindValByHash(dav, dahash, val, index);
 if (index GT= 0)
 l_dnaGetIValue(dac, index, icount);
 else
 icount = 0;
 </summary>
	<remarks>
	</remarks>
	<param name="das"></param>
	<param name="pdahash">hash map val --GT index</param>
	<param name="pdav">array of values index --GT val</param>
	<param name="pdac">histo array of counts index --GT count</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaIntersectionByHash(LeptonicaSharp.L_Dna,LeptonicaSharp.L_Dna)">
	<summary>
 Notes
 (1) This uses the same method for building the intersection set
 as ptaIntersectionByHash() and sarrayIntersectionByHash().
 </summary>
	<remarks>
	</remarks>
	<param name="da1"></param>
	<param name="da2"></param>
	<returns>dad intersection of the number arrays, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaFindValByHash(LeptonicaSharp.L_Dna,LeptonicaSharp.L_DnaHash,System.Double,System.Int32@)">
	<summary>
 Notes
 (1) Algo hash %val into a key; hash the key to get the dna
 in %dahash (that holds indices into %da); traverse
 the dna of indices looking for %val in %da.
 </summary>
	<remarks>
	</remarks>
	<param name="da"></param>
	<param name="dahash">containing indices into %da</param>
	<param name="val">searching for this number in %da</param>
	<param name="pindex">index into da if found; -1 otherwise</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMorphDwa_2(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_MORPH,System.String@)">
	<summary>
 Notes
 (1) This simply adds a border, calls the appropriate
 pixFMorphopGen_(), and removes the border.
 See the notes for that function.
 (2) The size of the border depends on the operation
 and the boundary conditions.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">usual 3 choices null, == pixs, != pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="operation">L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, L_MORPH_CLOSE</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFMorphopGen_2(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_MORPH,System.String@)">
	<summary>
 Notes
 (1) This is a dwa operation, and the Sels must be limited in
 size to not more than 31 pixels about the origin.
 (2) A border of appropriate size (32 pixels, or 64 pixels
 for safe closing with asymmetric b.c.) must be added before
 this function is called.
 (3) This handles all required setting of the border pixels
 before erosion and dilation.
 (4) The closing operation is safe; no pixels can be removed
 near the boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">usual 3 choices null, == pixs, != pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="operation">L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, L_MORPH_CLOSE</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fmorphopgen_low_2(System.Object@,System.Int32@,System.Int32@,System.Int32@,System.Object@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSobelEdgeFilter(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_L_EDGES)">
	<summary>
 Notes
 (1) Invert pixd to see larger gradients as darker (grayscale).
 (2) To generate a binary image of the edges, threshold
 the result using pixThresholdToBinary().  If the high
 edge values are to be fg (1), invert after running
 pixThresholdToBinary().
 (3) Label the pixels as follows
 1 4 7
 2 5 8
 3 6 9
 Read the data incrementally across the image and unroll
 the loop.
 (4) This runs at about 45 Mpix/sec on a 3 GHz processor.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="orientflag">L_HORIZONTAL_EDGES, L_VERTICAL_EDGES, L_ALL_EDGES</param>
	<returns>pixd 8 bpp, edges are brighter, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTwoSidedEdgeFilter(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_L_EDGES)">
	<summary>
 Notes
 (1) For detecting vertical edges, this considers the
 difference of the central pixel from those on the left
 and right.  For situations where the gradient is the same
 sign on both sides, this computes and stores the minimum
 (absolute value of the) difference.  The reason for
 checking the sign is that we are looking for pixels within
 a transition.  By contrast, for single pixel noise, the pixel
 value is either larger than or smaller than its neighbors,
 so the gradient would change direction on each side.  Horizontal
 edges are handled similarly, looking for vertical gradients.
 (2) To generate a binary image of the edges, threshold
 the result using pixThresholdToBinary().  If the high
 edge values are to be fg (1), invert after running
 pixThresholdToBinary().
 (3) This runs at about 60 Mpix/sec on a 3 GHz processor.
 It is about 30% faster than Sobel, and the results are
 similar.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="orientflag">L_HORIZONTAL_EDGES, L_VERTICAL_EDGES</param>
	<returns>pixd 8 bpp, edges are brighter, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMeasureEdgeSmoothness(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_scan_direction,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@,System.String)">
	<summary>
 Notes
 (1) This computes three measures of smoothness of the edge of a
 connected component
 jumps/length (jpl) the number of jumps of size GT= %minjump,
 normalized to the length of the side
 jump sum/length (jspl) the sum of all jump lengths of
 size GT= %minjump, normalized to the length of the side
 reversals/length (rpl) the number of peak LT--GT valley
 reversals, using %minreverse as a minimum deviation of
 the peak or valley from its preceding extremum,
 normalized to the length of the side
 (2) The input pix should be a single connected component, but
 this is not required.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="side">L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
	<param name="minjump">minimum jump to be counted; GT= 1</param>
	<param name="minreversal">minimum reversal size for new peak or valley</param>
	<param name="pjpl">jumps/length number of jumps, normalized to length of component side</param>
	<param name="pjspl">jumpsum/length sum of all sufficiently large jumps, normalized to length of component side</param>
	<param name="prpl">reversals/length number of peak-to-valley or valley-to-peak reversals, normalized to length of component side</param>
	<param name="debugfile">displays constructed edge; use NULL for no output</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetEdgeProfile(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_scan_direction,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="side">L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT</param>
	<param name="debugfile">displays constructed edge; use NULL for no output</param>
	<returns>na of fg edge pixel locations, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetLastOffPixelInRun(LeptonicaSharp.Pix@,System.Int32@,System.Int32@,System.Int32@,System.Object@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetLastOnPixelInRun(LeptonicaSharp.Pix@,System.Int32@,System.Int32@,System.Int32@,System.Object@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.encodeBase64(System.Byte[],System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The input character data is unrestricted binary.
 The output encoded data consists of the 64 characters
 in the base64 set, plus newlines and the pad character '='.
 </summary>
	<remarks>
	</remarks>
	<param name="inarray">input binary data</param>
	<param name="insize">number of bytes in input array</param>
	<param name="poutsize">number of bytes in output char array</param>
	<returns>chara with MAX_BASE64_LINE characters + \n in each line</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.decodeBase64(System.String,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The input character data should have only 66 different characters
 The 64 character set for base64 encoding, plus the pad
 character '=' and newlines for formatting with fixed line
 lengths.  If there are any other characters, the decoder
 will declare the input data to be invalid and return NULL.
 (2) The decoder ignores newlines and, for a valid input string,
 stops reading input when a pad byte is found.
 </summary>
	<remarks>
	</remarks>
	<param name="inarray">input encoded char data, with 72 chars/line)</param>
	<param name="insize">number of bytes in input array</param>
	<param name="poutsize">number of bytes in output byte array</param>
	<returns>bytea decoded byte data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.encodeAscii85(System.Byte[],System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Ghostscript has a stack break if the last line of
 data only has a 'GT', so we avoid the problem by
 always putting '~GT' on the last line.
 </summary>
	<remarks>
	</remarks>
	<param name="inarray">input data</param>
	<param name="insize">number of bytes in input array</param>
	<param name="poutsize">number of bytes in output char array</param>
	<returns>chara with 64 characters + \n in each line</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.decodeAscii85(System.String,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) We assume the data is properly encoded, so we do not check
 for invalid characters or the final 'GT' character.
 (2) We permit whitespace to be added to the encoding in an
 arbitrary way.
 </summary>
	<remarks>
	</remarks>
	<param name="inarray">ascii85 input data</param>
	<param name="insize">number of bytes in input array</param>
	<param name="poutsize">number of bytes in output l_uint8 array</param>
	<returns>outarray binary</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.reformatPacked64(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Each line in the output array has %leadspace space characters,
 followed optionally by a double-quote, followed by %linechars
 bytes of base64 data, followed optionally by a double-quote,
 followed by a newline.
 (2) This can be used to convert a base64 encoded string to a
 string formatted for inclusion in a C source file.
 </summary>
	<remarks>
	</remarks>
	<param name="inarray">base64 encoded string with newlines</param>
	<param name="insize">number of bytes in input array</param>
	<param name="leadspace">number of spaces in each line before the data</param>
	<param name="linechars">number of bytes of data in each line; multiple of 4</param>
	<param name="addquotes">1 to add quotes to each line of data; 0 to skip</param>
	<param name="poutsize">number of bytes in output char array</param>
	<returns>outarray ascii</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGammaTRC(LeptonicaSharp.Pix,System.Single,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) pixd must either be null or equal to pixs.
 For in-place operation, set pixd == pixs
 pixGammaTRC(pixs, pixs, ...);
 To get a new image, set pixd == null
 pixd = pixGammaTRC(NULL, pixs, ...);
 (2) If pixs is colormapped, the colormap is transformed,
 either in-place or in a copy of pixs.
 (3) We use a gamma mapping between minval and maxval.
 (4) If gamma LT 1.0, the image will appear darker;
 if gamma GT 1.0, the image will appear lighter;
 (5) If gamma = 1.0 and minval = 0 and maxval = 255, no
 enhancement is performed; return a copy unless in-place,
 in which case this is a no-op.
 (6) For color images that are not colormapped, the mapping
 is applied to each component.
 (7) minval and maxval are not restricted to the interval [0, 255].
 If minval LT 0, an input value of 0 is mapped to a
 nonzero output.  This will turn black to gray.
 If maxval GT 255, an input value of 255 is mapped to
 an output value less than 255.  This will turn
 white (e.g., in the background) to gray.
 (8) Increasing minval darkens the image.
 (9) Decreasing maxval bleaches the image.
 (10) Simultaneously increasing minval and decreasing maxval
 will darken the image and make the colors more intense;
 e.g., minval = 50, maxval = 200.
 (11) See numaGammaTRC() for further examples of use.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null or equal to pixs</param>
	<param name="pixs">8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
	<param name="gamma">gamma correction; must be GT 0.0</param>
	<param name="minval">input value that gives 0 for output; can be LT 0</param>
	<param name="maxval">input value that gives 255 for output; can be GT 255</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGammaTRCMasked(LeptonicaSharp.Pix,System.Single,System.Int32,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Same as pixGammaTRC() except mapping is optionally over
 a subset of pixels described by pixm.
 (2) Masking does not work for colormapped images.
 (3) See pixGammaTRC() for details on how to use the parameters.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null or equal to pixs</param>
	<param name="pixs">8 or 32 bpp; not colormapped</param>
	<param name="pixm">null or 1 bpp</param>
	<param name="gamma">gamma correction; must be GT 0.0</param>
	<param name="minval">input value that gives 0 for output; can be LT 0</param>
	<param name="maxval">input value that gives 255 for output; can be GT 255</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGammaTRCWithAlpha(LeptonicaSharp.Pix,System.Single,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See usage notes in pixGammaTRC().
 (2) This version saves the alpha channel.  It is only valid
 for 32 bpp (no colormap), and is a bit slower.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null or equal to pixs</param>
	<param name="pixs">32 bpp</param>
	<param name="gamma">gamma correction; must be GT 0.0</param>
	<param name="minval">input value that gives 0 for output; can be LT 0</param>
	<param name="maxval">input value that gives 255 for output; can be GT 255</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGammaTRC(System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The map is returned as a numa; values are clipped to [0, 255].
 (2) To force all intensities into a range within fraction delta
 of white, use minval = -256  (1 - delta) / delta
 maxval = 255
 (3) To force all intensities into a range within fraction delta
 of black, use minval = 0
 maxval = 256  (1 - delta) / delta
 </summary>
	<remarks>
	</remarks>
	<param name="gamma">gamma factor; must be GT 0.0</param>
	<param name="minval">input value that gives 0 for output</param>
	<param name="maxval">input value that gives 255 for output</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixContrastTRC(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) pixd must either be null or equal to pixs.
 For in-place operation, set pixd == pixs
 pixContrastTRC(pixs, pixs, ...);
 To get a new image, set pixd == null
 pixd = pixContrastTRC(NULL, pixs, ...);
 (2) If pixs is colormapped, the colormap is transformed,
 either in-place or in a copy of pixs.
 (3) Contrast is enhanced by mapping each color component
 using an atan function with maximum slope at 127.
 Pixels below 127 are lowered in intensity and pixels
 above 127 are increased.
 (4) The useful range for the contrast factor is scaled to
 be in (0.0 to 1.0), but larger values can also be used.
 (5) If factor == 0.0, no enhancement is performed; return a copy
 unless in-place, in which case this is a no-op.
 (6) For color images that are not colormapped, the mapping
 is applied to each component.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null or equal to pixs</param>
	<param name="pixs">8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
	<param name="factor">0.0 is no enhancement</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixContrastTRCMasked(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Same as pixContrastTRC() except mapping is optionally over
 a subset of pixels described by pixm.
 (2) Masking does not work for colormapped images.
 (3) See pixContrastTRC() for details on how to use the parameters.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null or equal to pixs</param>
	<param name="pixs">8 or 32 bpp; or 2, 4 or 8 bpp with colormap</param>
	<param name="pixm">null or 1 bpp</param>
	<param name="factor">0.0 is no enhancement</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaContrastTRC(System.Single)">
	<summary>
 Notes
 (1) The mapping is monotonic increasing, where 0 is mapped
 to 0 and 255 is mapped to 255.
 (2) As 'factor' is increased from 0.0 (where the mapping is linear),
 the map gets closer to its limit as a step function that
 jumps from 0 to 255 at the center (input value = 127).
 </summary>
	<remarks>
	</remarks>
	<param name="factor">generally between 0.0 [no enhancement] and 1.0, but can be larger than 1.0</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixEqualizeTRC(LeptonicaSharp.Pix,System.Single,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) pixd must either be null or equal to pixs.
 For in-place operation, set pixd == pixs
 pixEqualizeTRC(pixs, pixs, ...);
 To get a new image, set pixd == null
 pixd = pixEqualizeTRC(NULL, pixs, ...);
 (2) In histogram equalization, a tone reproduction curve
 mapping is used to make the number of pixels at each
 intensity equal.
 (3) If fract == 0.0, no equalization is performed; return a copy
 unless in-place, in which case this is a no-op.
 If fract == 1.0, equalization is complete.
 (4) Set the subsampling factor GT 1 to reduce the amount of computation.
 (5) If pixs is colormapped, the colormap is removed and
 converted to rgb or grayscale.
 (6) If pixs has color, equalization is done in each channel
 separately.
 (7) Note that even if there is a colormap, we can get an
 in-place operation because the intermediate image pixt
 is copied back to pixs (which for in-place is the same
 as pixd).
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">null or equal to pixs</param>
	<param name="pixs">8 bpp gray, 32 bpp rgb, or colormapped</param>
	<param name="fract">fraction of equalization movement of pixel values</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaEqualizeTRC(LeptonicaSharp.Pix,System.Single,System.Int32)">
	<summary>
 Notes
 (1) If fract == 0.0, no equalization will be performed.
 If fract == 1.0, equalization is complete.
 (2) Set the subsampling factor GT 1 to reduce the amount of computation.
 (3) The map is returned as a numa with 256 values, specifying
 the equalized value (array value) for every input value
 (the array index).
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp, no colormap</param>
	<param name="fract">fraction of equalization movement of pixel values</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>nad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTRCMap(LeptonicaSharp.Pix,LeptonicaSharp.Numa,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This operation is in-place on pixs.
 (2) For 32 bpp, this applies the same map to each of the r,g,b
 components.
 (3) The mapping array is of size 256, and it maps the input
 index into values in the range [0, 255].
 (4) If defined, the optional 1 bpp mask pixm has its origin
 aligned with pixs, and the map function is applied only
 to pixels in pixs under the fg of pixm.
 (5) For 32 bpp, this does not save the alpha channel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 grayscale or 32 bpp rgb; not colormapped</param>
	<param name="pixm">1 bpp mask</param>
	<param name="na">mapping array</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixUnsharpMasking(LeptonicaSharp.Pix,System.Int32,System.Single)">
	<summary>
 Notes
 (1) We use symmetric smoothing filters of odd dimension,
 typically use sizes of 3, 5, 7, etc.  The %halfwidth parameter
 for these is (size - 1)/2; i.e., 1, 2, 3, etc.
 (2) The fract parameter is typically taken in the
 range  0.2 LT fract LT 0.7
 (3) Returns a clone if no sharpening is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths except 1 bpp; with or without colormaps</param>
	<param name="halfwidth">"half-width" of smoothing filter</param>
	<param name="fract">fraction of edge added back into image</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixUnsharpMaskingGray(LeptonicaSharp.Pix,System.Int32,System.Single)">
	<summary>
 Notes
 (1) We use symmetric smoothing filters of odd dimension,
 typically use sizes of 3, 5, 7, etc.  The %halfwidth parameter
 for these is (size - 1)/2; i.e., 1, 2, 3, etc.
 (2) The fract parameter is typically taken in the range
 0.2 LT fract LT 0.7
 (3) Returns a clone if no sharpening is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="halfwidth">"half-width" of smoothing filter</param>
	<param name="fract">fraction of edge added back into image</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixUnsharpMaskingFast(LeptonicaSharp.Pix,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_direction)">
	<summary>
 Notes
 (1) The fast version uses separable 1-D filters directly on
 the input image.  The halfwidth is either 1 (full width = 3)
 or 2 (full width = 5).
 (2) The fract parameter is typically taken in the
 range  0.2 LT fract LT 0.7
 (3) To skip horizontal sharpening, use %fracth = 0.0; ditto for %fractv
 (4) For one dimensional filtering (as an example)
 For %halfwidth = 1, the low-pass filter is
 L 1/3 1/3   1/3
 and the high-pass filter is
 H = I - L   -1/3   2/3   -1/3
 For %halfwidth = 2, the low-pass filter is
 L 1/5 1/5   1/5 1/5 1/5
 and the high-pass filter is
 H = I - L   -1/5  -1/5   4/5  -1/5   -1/5
 The new sharpened pixel value is found by adding some fraction
 of the high-pass filter value (which sums to 0) to the
 initial pixel value
 N = I + fract  H
 (5) For 2D, the sharpening filter is not separable, because the
 vertical filter depends on the horizontal location relative
 to the filter origin, and v.v.   So we either do the full
 2D filter (for %halfwidth == 1) or do the low-pass
 convolution separably and then compose with the original pix.
 (6) Returns a clone if no sharpening is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths except 1 bpp; with or without colormaps</param>
	<param name="halfwidth">"half-width" of smoothing filter; 1 and 2 only</param>
	<param name="fract">fraction of high frequency added to image</param>
	<param name="direction">L_HORIZ, L_VERT, L_BOTH_DIRECTIONS</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixUnsharpMaskingGrayFast(LeptonicaSharp.Pix,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_direction)">
	<summary>
 Notes
 (1) For usage and explanation of the algorithm, see notes
 in pixUnsharpMaskingFast().
 (2) Returns a clone if no sharpening is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="halfwidth">"half-width" of smoothing filter 1 or 2</param>
	<param name="fract">fraction of high frequency added to image</param>
	<param name="direction">L_HORIZ, L_VERT, L_BOTH_DIRECTIONS</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixUnsharpMaskingGray1D(LeptonicaSharp.Pix,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_direction)">
	<summary>
 Notes
 (1) For usage and explanation of the algorithm, see notes
 in pixUnsharpMaskingFast().
 (2) Returns a clone if no sharpening is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="halfwidth">"half-width" of smoothing filter 1 or 2</param>
	<param name="fract">fraction of high frequency added to image</param>
	<param name="direction">filtering direction; use L_HORIZ or L_VERT</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixUnsharpMaskingGray2D(LeptonicaSharp.Pix,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This is for %halfwidth == 1, 2.
 (2) The lowpass filter is implemented separably.
 (3) Returns a clone if no sharpening is requested.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="halfwidth">"half-width" of smoothing filter 1 or 2</param>
	<param name="fract">fraction of high frequency added to image</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixModifyHue(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) pixd must either be null or equal to pixs.
 For in-place operation, set pixd == pixs
 pixEqualizeTRC(pixs, pixs, ...);
 To get a new image, set pixd == null
 pixd = pixEqualizeTRC(NULL, pixs, ...);
 (1) Use fract GT 0.0 to increase hue value; LT 0.0 to decrease it.
 1.0 (or -1.0) represents a 360 degree rotation; i.e., no change.
 (2) If no modification is requested (fract = -1.0 or 0 or 1.0),
 return a copy unless in-place, in which case this is a no-op.
 (3) See discussion of color-modification methods, in coloring.c.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be null or equal to pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="fract">between -1.0 and 1.0</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixModifySaturation(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If fract GT 0.0, it gives the fraction that the pixel
 saturation is moved from its initial value toward 255.
 If fract LT 0.0, it gives the fraction that the pixel
 saturation is moved from its initial value toward 0.
 The limiting values for fract = -1.0 (1.0) thus set the
 saturation to 0 (255).
 (2) If fract = 0, no modification is requested; return a copy
 unless in-place, in which case this is a no-op.
 (3) See discussion of color-modification methods, in coloring.c.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be null, existing or equal to pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="fract">between -1.0 and 1.0</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMeasureSaturation(LeptonicaSharp.Pix,System.Int32,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="psat">average saturation</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixModifyBrightness(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If fract GT 0.0, it gives the fraction that the v-parameter,
 which is max(r,g,b), is moved from its initial value toward 255.
 If fract LT 0.0, it gives the fraction that the v-parameter
 is moved from its initial value toward 0.
 The limiting values for fract = -1.0 (1.0) thus set the
 v-parameter to 0 (255).
 (2) If fract = 0, no modification is requested; return a copy
 unless in-place, in which case this is a no-op.
 (3) See discussion of color-modification methods, in coloring.c.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be null, existing or equal to pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="fract">between -1.0 and 1.0</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMosaicColorShiftRGB(LeptonicaSharp.Pix,System.Single,System.Single,System.Single,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This generates a mosaic view of the effect of shifting the RGB
 components.  See pixColorShiftRGB() for details on the shifting.
 (2) The offsets (%roff, %goff, %boff) set the color center point,
 and the deviations from this are shown separately for deltas
 in r, g and b.  For each component, we show 2  %nincr + 1
 images.
 (3) Usage color prints differ from the original due to three factors
 illumination, calibration of the camera in acquisition,
 and calibration of the printer.  This function can be used
 to iteratively match a color print to the original.  On each
 iteration, the center offsets are set to the best match so
 far, and the %delta increments are typically reduced.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="roff">center offset of red component</param>
	<param name="goff">center offset of green component</param>
	<param name="boff">center offset of blue component</param>
	<param name="delta">increments from center offsets [0.0 - 0.1]; use 0.0 to get the default (0.04)</param>
	<param name="nincr">number of increments in each (positive and negative) direction; use 0 to get the default (2).</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorShiftRGB(LeptonicaSharp.Pix,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This allows independent fractional shifts of the r,g and b
 components.  A positive shift pushes to saturation (255);
 a negative shift pushes toward 0 (black).
 (2) The effect can be imagined using a color wheel that consists
 (for our purposes) of these 6 colors, separated by 60 degrees
 red, magenta, blue, cyan, green, yellow
 (3) So, for example, a negative shift of the blue component
 (bfract LT 0) could be accompanied by positive shifts
 of red and green to make an image more yellow.
 (4) Examples of limiting cases
 rfract = 1 ==GT r = 255
 rfract = -1 ==GT r = 0
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="rfract">fractional shift in red component</param>
	<param name="gfract">fractional shift in green component</param>
	<param name="bfract">fractional shift in blue component</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDarkenGray(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This darkens gray pixels, by a fraction (sat/%satlimit), where
 the sat, the saturation, is the component difference (max - min).
 The pixel value is unchanged if sat GT= %satlimit.  A typical
 value of %satlimit might be 50; the larger the value, the
 more that pixels with a smaller saturation will be darkened.
 (2) Pixels with max component GT= %thresh are unchanged. This can be
 used to prevent bright pixels with low saturation from being
 darkened.  Setting thresh == 0 is a no-op; setting %thresh == 255
 causes the darkening to be applied to all pixels.
 (3) This function is useful to enhance pixels relative to a
 gray background.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be null or equal to pixs</param>
	<param name="pixs">32 bpp rgb</param>
	<param name="thresh">pixels with max component GT= %thresh are unchanged</param>
	<param name="satlimit">pixels with saturation GT= %satlimit are unchanged</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMultConstantColor(LeptonicaSharp.Pix,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) rfact, gfact and bfact can only have non-negative values.
 They can be greater than 1.0.  All transformed component
 values are clipped to the interval [0, 255].
 (2) For multiplication with a general 3x3 matrix of constants,
 use pixMultMatrixColor().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped or rgb</param>
	<param name="rfact">red multiplicative factor</param>
	<param name="gfact">green multiplicative factor</param>
	<param name="bfact">blue multiplicative factor</param>
	<returns>pixd colormapped or rgb, with colors scaled, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMultMatrixColor(LeptonicaSharp.Pix,LeptonicaSharp.L_Kernel)">
	<summary>
 Notes
 (1) The kernel is a data structure used mostly for floating point
 convolution.  Here it is a 3x3 matrix of floats that are used
 to transform the pixel values by matrix multiplication
 nrval = a[0,0]  rval + a[0,1]  gval + a[0,2]  bval
 ngval = a[1,0]  rval + a[1,1]  gval + a[1,2]  bval
 nbval = a[2,0]  rval + a[2,1]  gval + a[2,2]  bval
 (2) The matrix can be generated in several ways.
 See kernel.c for details.  Here are two of them
 (a) kel = kernelCreate(3, 3);
 kernelSetElement(kel, 0, 0, val00);
 kernelSetElement(kel, 0, 1, val01);
 ...
 (b) from a static string; e.g.,
 const char kdata = " 0.6  0.3 -0.2 "
 " 0.1  1.2  0.4 "
 " -0.4 0.2  0.9 ";
 kel = kernelCreateFromString(3, 3, 0, 0, kdata);
 (3) For the special case where the matrix is diagonal, it is easier
 to use pixMultConstantColor().
 (4) Matrix entries can have positive and negative values, and can
 be larger than 1.0.  All transformed component values
 are clipped to [0, 255].
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped or rgb</param>
	<param name="kel">kernel 3x3 matrix of floats</param>
	<returns>pixd colormapped or rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixHalfEdgeByBandpass(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) We use symmetric smoothing filters of odd dimension,
 typically use 3, 5, 7, etc.  The smoothing parameters
 for these are 1, 2, 3, etc.  The filter size is related
 to the smoothing parameter by
 size = 2  smoothing + 1
 (2) Because we take the difference of two lowpass filters,
 this is actually a bandpass filter.
 (3) We allow both filters to be anisotropic.
 (4) Consider either the h or v component of the 2 filters.
 Depending on whether sm1 GT sm2 or sm2 GT sm1, we get
 different halves of the smoothed gradients (or "edges").
 This difference of smoothed signals looks more like
 a second derivative of a transition, which we rectify
 by not allowing the signal to go below zero.  If sm1 LT sm2,
 the sm2 transition is broader, so the difference between
 sm1 and sm2 signals is positive on the upper half of
 the transition.  Likewise, if sm1 GT sm2, the sm1 - sm2
 signal difference is positive on the lower half of
 the transition.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb</param>
	<param name="sm1h">"half-widths" of smoothing filter sm1</param>
	<param name="sm1v">"half-widths" of smoothing filter sm1</param>
	<param name="sm2h">"half-widths" of smoothing filter sm2; require sm2 != sm1</param>
	<param name="sm2v">"half-widths" of smoothing filter sm2; require sm2 != sm1</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fhmtautogen(LeptonicaSharp.Sela,System.Int32,System.String)">
	<summary>
 Notes
 (1) This function generates all the code for implementing
 dwa morphological operations using all the sels in the sela.
 (2) See fhmtautogen1() and fhmtautogen2() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="fileindex"></param>
	<param name="filename">; can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fhmtautogen1(LeptonicaSharp.Sela,System.Int32,System.String)">
	<summary>
 Notes
 (1) This function uses hmttemplate1.txt to create a
 top-level file that contains two functions that carry
 out the hit-miss transform for any of the sels in
 the input sela.
 (2) The fileindex parameter is inserted into the output
 filename, as described below.
 (3) If filename == NULL, the output file is fhmtgen.[n].c,
 where [n] is equal to the 'fileindex' parameter.
 (4) If filename != NULL, the output file is [filename].[n].c.
 (5) Each sel must have at least one hit.  A sel with only misses
 generates code that will abort the operation if it is called.
 </summary>
	<remarks>
	</remarks>
	<param name="sela">array</param>
	<param name="fileindex"></param>
	<param name="filename">; can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fhmtautogen2(LeptonicaSharp.Sela,System.Int32,System.String)">
	<summary>
 Notes
 (1) This function uses hmttemplate2.txt to create a
 low-level file that contains the low-level functions for
 implementing the hit-miss transform for every sel
 in the input sela.
 (2) The fileindex parameter is inserted into the output
 filename, as described below.
 (3) If filename == NULL, the output file is fhmtgenlow.[n].c,
 where [n] is equal to the %fileindex parameter.
 (4) If filename != NULL, the output file is [filename]low.[n].c.
 </summary>
	<remarks>
	</remarks>
	<param name="sela">array</param>
	<param name="fileindex"></param>
	<param name="filename">; can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixHMTDwa_1(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.String@)">
	<summary>
 Notes
 (1) This simply adds a 32 pixel border, calls the appropriate
 pixFHMTGen_(), and removes the border.
 See notes below for that function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">usual 3 choices null, == pixs, != pixs</param>
	<param name="pixs">1 bpp</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFHMTGen_1(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.String@)">
	<summary>
 Notes
 (1) This is a dwa implementation of the hit-miss transform
 on pixs by the sel.
 (2) The sel must be limited in size to not more than 31 pixels
 about the origin.  It must have at least one hit, and it
 can have any number of misses.
 (3) This handles all required setting of the border pixels
 before erosion and dilation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">usual 3 choices null, == pixs, != pixs</param>
	<param name="pixs">1 bpp</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fhmtgen_low_1(System.Object@,System.Int32@,System.Int32@,System.Int32@,System.Object@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixItalicWords(LeptonicaSharp.Pix,LeptonicaSharp.Boxa@,System.Int32,LeptonicaSharp.Boxa,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) You can input the bounding boxes for the words in one of
 two forms as bounding boxes (%boxaw) or as a word mask with
 the word bounding boxes filled (%pixw).  For example,
 to compute %pixw, you can use pixWordMaskByDilation().
 (2) Alternatively, you can set both of these inputs to NULL,
 in which case the word mask is generated here.  This is
 done by dilating and closing the input image to connect
 letters within a word, while leaving the words separated.
 The parameters are chosen under the assumption that the
 input is 10 to 12 pt text, scanned at about 300 ppi.
 (3) sel_ital1 and sel_ital2 detect the right edges that are
 nearly vertical, at approximately the angle of italic
 strokes.  We use the right edge to avoid getting seeds
 from lower-case 'y'.  The typical italic slant has a smaller
 angle with the vertical than the 'W', so in most cases we
 will not trigger on the slanted lines in the 'W'.
 (4) Note that sel_ital2 is shorter than sel_ital1.  It is
 more appropriate for a typical font scanned at 200 ppi.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="boxaw">word bounding boxes; can be NULL</param>
	<param name="pixw">word box mask; can be NULL</param>
	<param name="pboxa">boxa of italic words</param>
	<param name="debugflag">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOrientCorrect(LeptonicaSharp.Pix,System.Single,System.Single,System.Single[]@,System.Single[]@,System.Int32@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) Simple top-level function to detect if Roman text is in
 reading orientation, and to rotate the image accordingly if not.
 (2) Returns a copy if no rotation is needed.
 (3) See notes for pixOrientDetect() and pixOrientDecision().
 Use 0.0 for default values for %minupconf and %minratio
 (4) Optional output of intermediate confidence results and
 the rotation performed on pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text, 150 - 300 ppi</param>
	<param name="minupconf">minimum value for which a decision can be made</param>
	<param name="minratio">minimum conf ratio required for a decision</param>
	<param name="pupconf">; use NULL to skip</param>
	<param name="pleftconf">; use NULL to skip</param>
	<param name="protation">; use NULL to skip</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>pixd  may be rotated by 90, 180 or 270; null on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOrientDetect(LeptonicaSharp.Pix,System.Int32,System.Single[]@,System.Single[]@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) See "Measuring document image skew and orientation"
 Dan S. Bloomberg, Gary E. Kopec and Lakshmi Dasari
 IST/SPIE EI'95, Conference 2422 Document Recognition II
 pp 302-316, Feb 6-7, 1995, San Jose, CA
 (2) upconf is the normalized difference between up ascenders
 and down ascenders.  The image is analyzed without rotation
 for being rightside-up or upside-down.  Set upconf to null
 to skip this operation.
 (3) leftconf is the normalized difference between up ascenders
 and down ascenders in the image after it has been
 rotated 90 degrees clockwise.  With that rotation, ascenders
 projecting to the left in the source image will project up
 in the rotated image.  We compute this by rotating 90 degrees
 clockwise and testing for up and down ascenders.  Set
 leftconf to null to skip this operation.
 (4) Note that upconf and leftconf are not linear measures of
 confidence, e.g., in a range between 0 and 100.  They
 measure how far you are out on the tail of a (presumably)
 normal distribution.  For example, a confidence of 10 means
 that it is nearly certain that the difference did not
 happen at random.  However, these values must be interpreted
 cautiously, taking into consideration the estimated prior
 for a particular orientation or mirror flip.   The up-down
 signal is very strong if applied to text with ascenders
 up and down, and relatively weak for text at 90 degrees,
 but even at 90 degrees, the difference can look significant.
 For example, suppose the ascenders are oriented horizontally,
 but the test is done vertically.  Then upconf can
 be LT -MIN_CONF_FOR_UP_DOWN, suggesting the text may be
 upside-down.  However, if instead the test were done
 horizontally, leftconf will be very much larger
 (in absolute value), giving the correct orientation.
 (5) If you compute both upconf and leftconf, and there is
 sufficient signal, the following table determines the
 cw angle necessary to rotate pixs so that the text is
 rightside-up
 0 deg   upconf GTGT 1, abs(upconf) GTGT abs(leftconf)
 90 deg  leftconf GTGT 1,  abs(leftconf) GTGT abs(upconf)
 180 deg upconf LTLT -1,   abs(upconf) GTGT abs(leftconf)
 270 deg leftconf LTLT -1, abs(leftconf) GTGT abs(upconf)
 (6) One should probably not interpret the direction unless
 there are a sufficient number of counts for both orientations,
 in which case neither upconf nor leftconf will be 0.0.
 (7) Uses rasterop implementation of HMT.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text, 150 - 300 ppi</param>
	<param name="pupconf">; may be NULL</param>
	<param name="pleftconf">; may be NULL</param>
	<param name="mincount">min number of up + down; use 0 for default</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeOrientDecision(System.Single,System.Single,System.Single,System.Single,System.Int32@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This can be run after pixOrientDetect()
 (2) Both upconf and leftconf must be nonzero; otherwise the
 orientation cannot be determined.
 (3) The abs values of the input confidences are compared to
 minupconf.
 (4) The abs value of the largest of (upconf/leftconf) and
 (leftconf/upconf) is compared with minratio.
 (5) Input 0.0 for the default values for minupconf and minratio.
 (6) The return value of orient is interpreted thus
 L_TEXT_ORIENT_UNKNOWN  not enough evidence to determine
 L_TEXT_ORIENT_UP text rightside-up
 L_TEXT_ORIENT_LEFT  landscape, text up facing left
 L_TEXT_ORIENT_DOWN  text upside-down
 L_TEXT_ORIENT_RIGHT landscape, text up facing right
 </summary>
	<remarks>
	</remarks>
	<param name="upconf">nonzero</param>
	<param name="leftconf">nonzero</param>
	<param name="minupconf">minimum value for which a decision can be made</param>
	<param name="minratio">minimum conf ratio required for a decision</param>
	<param name="porient">text orientation enum {0,1,2,3,4}</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixUpDownDetect(LeptonicaSharp.Pix,System.Single[]@,System.Int32,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) Special (typical, slightly faster) case, where the pixels
 identified through the HMT (hit-miss transform) are not
 clipped by a truncated word mask pixm.  See pixOrientDetect()
 and pixUpDownDetectGeneral() for details.
 (2) The returned confidence is the normalized difference
 between the number of detected up and down ascenders,
 assuming that the text is either rightside-up or upside-down
 and not rotated at a 90 degree angle.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text, 150 - 300 ppi</param>
	<param name="pconf">confidence that text is rightside-up</param>
	<param name="mincount">min number of up + down; use 0 for default</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixUpDownDetectGeneral(LeptonicaSharp.Pix,System.Single[]@,System.Int32,System.Int32,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) See pixOrientDetect() for other details.
 (2) %conf is the normalized difference between the number of
 detected up and down ascenders, assuming that the text
 is either rightside-up or upside-down and not rotated
 at a 90 degree angle.
 (3) The typical mode of operation is %npixels == 0.
 If %npixels GT 0, this removes HMT matches at the
 beginning and ending of "words."  This is useful for
 pages that may have mostly digits, because if npixels == 0,
 leading "1" and "3" digits can register as having
 ascenders or descenders, and "7" digits can match descenders.
 Consequently, a page image of only digits may register
 as being upside-down.
 (4) We want to count the number of instances found using the HMT.
 An expensive way to do this would be to count the
 number of connected components.  A cheap way is to do a rank
 reduction cascade that reduces each component to a single
 pixel, and results (after two or three 2x reductions)
 in one pixel for each of the original components.
 After the reduction, you have a much smaller pix over
 which to count pixels.  We do only 2 reductions, because
 this function is designed to work for input pix between
 150 and 300 ppi, and an 8x reduction on a 150 ppi image
 is going too far -- components will get merged.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text, 150 - 300 ppi</param>
	<param name="pconf">confidence that text is rightside-up</param>
	<param name="mincount">min number of up + down; use 0 for default</param>
	<param name="npixels">number of pixels removed from each side of word box</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOrientDetectDwa(LeptonicaSharp.Pix,System.Int32,System.Single[]@,System.Single[]@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) Same interface as for pixOrientDetect().  See notes
 there for usage.
 (2) Uses auto-gen'd code for the Sels defined at the
 top of this file, with some renaming of functions.
 The auto-gen'd code is in fliphmtgen.c, and can
 be generated by a simple executable; see prog/flipselgen.c.
 (3) This runs about 2.5 times faster than the pixOrientDetect().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text</param>
	<param name="pupconf">; may be NULL</param>
	<param name="pleftconf">; may be NULL</param>
	<param name="mincount">min number of up + down; use 0 for default</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixUpDownDetectDwa(LeptonicaSharp.Pix,System.Single[]@,System.Int32,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) Faster (DWA) version of pixUpDownDetect().
 (2) This is a special case (but typical and slightly faster) of
 pixUpDownDetectGeneralDwa(), where the pixels identified
 through the HMT (hit-miss transform) are not clipped by
 a truncated word mask pixm.  See pixUpDownDetectGeneral()
 for usage and other details.
 (3) The returned confidence is the normalized difference
 between the number of detected up and down ascenders,
 assuming that the text is either rightside-up or upside-down
 and not rotated at a 90 degree angle.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text, 150 - 300 ppi</param>
	<param name="pconf">confidence that text is rightside-up</param>
	<param name="mincount">min number of up + down; use 0 for default</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixUpDownDetectGeneralDwa(LeptonicaSharp.Pix,System.Single[]@,System.Int32,System.Int32,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) See the notes in pixUpDownDetectGeneral() for usage.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text</param>
	<param name="pconf">confidence that text is rightside-up</param>
	<param name="mincount">min number of up + down; use 0 for default</param>
	<param name="npixels">number of pixels removed from each side of word box</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMirrorDetect(LeptonicaSharp.Pix,System.Single[]@,System.Int32,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) For this test, it is necessary that the text is horizontally
 oriented, with ascenders going up.
 (2) conf is the normalized difference between the number of
 right and left facing characters with ascenders.
 Left-facing are {d}; right-facing are {b, h, k}.
 At least that was the expectation.  In practice, we can
 really just say that it is the normalized difference in
 hits using two specific hit-miss filters, textsel1 and textsel2,
 after the image has been suitably pre-filtered so that
 these filters are effective.  See (4) for what's really happening.
 (3) A large positive conf value indicates normal text, whereas
 a large negative conf value means the page is mirror reversed.
 (4) The implementation is a bit tricky.  The general idea is
 to fill the x-height part of characters, but not the space
 between them, before doing the HMT.  This is done by
 finding pixels added using two different operations -- a
 horizontal close and a vertical dilation -- and adding
 the intersection of these sets to the original.  It turns
 out that the original intuition about the signal was largely
 in error much of the signal for right-facing characters
 comes from the lower part of common x-height characters, like
 the e and c, that remain open after these operations.
 So it's important that the operations to close the x-height
 parts of the characters are purposely weakened sufficiently
 to allow these characters to remain open.  The wonders
 of morphology!
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text</param>
	<param name="pconf">confidence that text is not LR mirror reversed</param>
	<param name="mincount">min number of left + right; use 0 for default</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMirrorDetectDwa(LeptonicaSharp.Pix,System.Single[]@,System.Int32,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) We assume the text is horizontally oriented, with
 ascenders going up.
 (2) See notes in pixMirrorDetect().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, deskewed, English text</param>
	<param name="pconf">confidence that text is not LR mirror reversed</param>
	<param name="mincount">min number of left + right; use 0 for default</param>
	<param name="debug">1 for debug output; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFlipFHMTGen(LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fmorphautogen(LeptonicaSharp.Sela,System.Int32,System.String)">
	<summary>
 Notes
 (1) This function generates all the code for implementing
 dwa morphological operations using all the sels in the sela.
 (2) See fmorphautogen1() and fmorphautogen2() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="fileindex"></param>
	<param name="filename">; can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fmorphautogen1(LeptonicaSharp.Sela,System.Int32,System.String)">
	<summary>
 Notes
 (1) This function uses morphtemplate1.txt to create a
 top-level file that contains two functions.  These
 functions will carry out dilation, erosion,
 opening or closing for any of the sels in the input sela.
 (2) The fileindex parameter is inserted into the output
 filename, as described below.
 (3) If filename == NULL, the output file is fmorphgen.[n].c,
 where [n] is equal to the %fileindex parameter.
 (4) If filename != NULL, the output file is [%filename].[n].c.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="fileindex"></param>
	<param name="filename">; can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fmorphautogen2(LeptonicaSharp.Sela@,System.Int32@,System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMorphDwa_1(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_MORPH,System.String@)">
	<summary>
 Notes
 (1) This simply adds a border, calls the appropriate
 pixFMorphopGen_(), and removes the border.
 See the notes for that function.
 (2) The size of the border depends on the operation
 and the boundary conditions.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">usual 3 choices null, == pixs, != pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="operation">L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, L_MORPH_CLOSE</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFMorphopGen_1(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_MORPH,System.String@)">
	<summary>
 Notes
 (1) This is a dwa operation, and the Sels must be limited in
 size to not more than 31 pixels about the origin.
 (2) A border of appropriate size (32 pixels, or 64 pixels
 for safe closing with asymmetric b.c.) must be added before
 this function is called.
 (3) This handles all required setting of the border pixels
 before erosion and dilation.
 (4) The closing operation is safe; no pixels can be removed
 near the boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">usual 3 choices null, == pixs, != pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="operation">L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN, L_MORPH_CLOSE</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fmorphopgen_low_1(System.Object@,System.Int32@,System.Int32@,System.Int32@,System.Object@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixCreate(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Makes a FPix of specified size, with the data array
 allocated and initialized to 0.
 (2) The number of pixels must be less than 2^29.
 </summary>
	<remarks>
	</remarks>
	<param name="width"></param>
	<param name="height"></param>
	<returns>fpixd   with data allocated and initialized to 0, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixCreateTemplate(LeptonicaSharp.FPix)">
	<summary>
 Notes
 (1) Makes a FPix of the same size as the input FPix, with the
 data array allocated and initialized to 0.
 (2) Copies the resolution.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixClone(LeptonicaSharp.FPix)">
	<summary>
 Notes
 (1) See pixClone() for definition and usage.
 </summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<returns>same fpix ptr, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixCopy(LeptonicaSharp.FPix,LeptonicaSharp.FPix)">
	<summary>
 Notes
 (1) There are three cases
 (a) fpixd == null  (makes a new fpix; refcount = 1)
 (b) fpixd == fpixs  (no-op)
 (c) fpixd != fpixs  (data copy; no change in refcount)
 If the refcount of fpixd GT 1, case (c) will side-effect
 these handles.
 (2) The general pattern of use is
 fpixd = fpixCopy(fpixd, fpixs);
 This will work for all three cases.
 For clarity when the case is known, you can use
 (a) fpixd = fpixCopy(NULL, fpixs);
 (c) fpixCopy(fpixd, fpixs);
 (3) For case (c), we check if fpixs and fpixd are the same size.
 If so, the data is copied directly.
 Otherwise, the data is reallocated to the correct size
 and the copy proceeds.  The refcount of fpixd is unchanged.
 (4) This operation, like all others that may involve a pre-existing
 fpixd, will side-effect any existing clones of fpixd.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">; can be null, or equal to fpixs, or different from fpixs</param>
	<param name="fpixs"></param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixResizeImageData(LeptonicaSharp.FPix,LeptonicaSharp.FPix)">
	<summary>
 Notes
 (1) If the data sizes differ, this destroys the existing
 data in fpixd and allocates a new, uninitialized, data array
 of the same size as the data in fpixs.  Otherwise, this
 doesn't do anything.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd"></param>
	<param name="fpixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixDestroy(LeptonicaSharp.FPix@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the fpix.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pfpix">will be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixGetDimensions(LeptonicaSharp.FPix,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixSetDimensions(LeptonicaSharp.FPix,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="w"></param>
	<param name="h"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixGetWpl(LeptonicaSharp.FPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<returns>wpl, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixSetWpl(LeptonicaSharp.FPix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="wpl"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixGetRefcount(LeptonicaSharp.FPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<returns>refcount, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixChangeRefcount(LeptonicaSharp.FPix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="delta"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixGetResolution(LeptonicaSharp.FPix,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="pxres">x and y resolution</param>
	<param name="pyres">x and y resolution</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixSetResolution(LeptonicaSharp.FPix,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="xres">x and y resolution</param>
	<param name="yres">x and y resolution</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixCopyResolution(LeptonicaSharp.FPix,LeptonicaSharp.FPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixd"></param>
	<param name="fpixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixGetData(LeptonicaSharp.FPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<returns>ptr FPixdata, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixSetData(LeptonicaSharp.FPix,System.Single[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="data"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixGetPixel(LeptonicaSharp.FPix,System.Int32,System.Int32@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="x">,y pixel coords</param>
	<param name="pval">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixSetPixel(LeptonicaSharp.FPix,System.Int32,System.Int32@,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="x">,y pixel coords</param>
	<param name="val">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">initial number of ptrs</param>
	<returns>fpixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaCopy(LeptonicaSharp.FPixa,System.Int32)">
	<summary>
 Notes
 copyflag may be one of
 ~ L_COPY makes a new fpixa and copies each fpix
 ~ L_CLONE gives a new ref-counted handle to the input fpixa
 ~ L_COPY_CLONE makes a new fpixa with clones of all fpix
 </summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="copyflag">L_COPY, L_CLODE or L_COPY_CLONE</param>
	<returns>new fpixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaDestroy(LeptonicaSharp.FPixa@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the fpixa.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pfpixa">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaAddFPix(LeptonicaSharp.FPixa,LeptonicaSharp.FPix,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="fpix">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaGetCount(LeptonicaSharp.FPixa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<returns>count, or 0 if no pixa</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaChangeRefcount(LeptonicaSharp.FPixa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="delta"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaGetFPix(LeptonicaSharp.FPixa,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="index">to the index-th fpix</param>
	<param name="accesstype">L_COPY or L_CLONE</param>
	<returns>fpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaGetFPixDimensions(LeptonicaSharp.FPixa,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="index">to the index-th box</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaGetData(LeptonicaSharp.FPixa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="index">into fpixa array</param>
	<returns>data not a copy, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaGetPixel(LeptonicaSharp.FPixa,System.Int32,System.Int32,System.Int32@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="index">into fpixa array</param>
	<param name="x">,y pixel coords</param>
	<param name="pval">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaSetPixel(LeptonicaSharp.FPixa,System.Int32,System.Int32,System.Int32@,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixa"></param>
	<param name="index">into fpixa array</param>
	<param name="x">,y pixel coords</param>
	<param name="val">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixCreate(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Makes a DPix of specified size, with the data array
 allocated and initialized to 0.
 (2) The number of pixels must be less than 2^28.
 </summary>
	<remarks>
	</remarks>
	<param name="width"></param>
	<param name="height"></param>
	<returns>dpix  with data allocated and initialized to 0, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixCreateTemplate(LeptonicaSharp.DPix)">
	<summary>
 Notes
 (1) Makes a DPix of the same size as the input DPix, with the
 data array allocated and initialized to 0.
 (2) Copies the resolution.
 </summary>
	<remarks>
	</remarks>
	<param name="dpixs"></param>
	<returns>dpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixClone(LeptonicaSharp.DPix)">
	<summary>
 Notes
 (1) See pixClone() for definition and usage.
 </summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<returns>same dpix ptr, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixCopy(LeptonicaSharp.DPix,LeptonicaSharp.DPix)">
	<summary>
 Notes
 (1) There are three cases
 (a) dpixd == null  (makes a new dpix; refcount = 1)
 (b) dpixd == dpixs  (no-op)
 (c) dpixd != dpixs  (data copy; no change in refcount)
 If the refcount of dpixd GT 1, case (c) will side-effect
 these handles.
 (2) The general pattern of use is
 dpixd = dpixCopy(dpixd, dpixs);
 This will work for all three cases.
 For clarity when the case is known, you can use
 (a) dpixd = dpixCopy(NULL, dpixs);
 (c) dpixCopy(dpixd, dpixs);
 (3) For case (c), we check if dpixs and dpixd are the same size.
 If so, the data is copied directly.
 Otherwise, the data is reallocated to the correct size
 and the copy proceeds.  The refcount of dpixd is unchanged.
 (4) This operation, like all others that may involve a pre-existing
 dpixd, will side-effect any existing clones of dpixd.
 </summary>
	<remarks>
	</remarks>
	<param name="dpixd">; can be null, or equal to dpixs, or different from dpixs</param>
	<param name="dpixs"></param>
	<returns>dpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixResizeImageData(LeptonicaSharp.DPix,LeptonicaSharp.DPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpixd"></param>
	<param name="dpixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixDestroy(LeptonicaSharp.DPix@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the dpix.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pdpix">will be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixGetDimensions(LeptonicaSharp.DPix,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixSetDimensions(LeptonicaSharp.DPix,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="w"></param>
	<param name="h"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixGetWpl(LeptonicaSharp.DPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<returns>wpl, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixSetWpl(LeptonicaSharp.DPix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="wpl"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixGetRefcount(LeptonicaSharp.DPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<returns>refcount, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixChangeRefcount(LeptonicaSharp.DPix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="delta"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixGetResolution(LeptonicaSharp.DPix,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="pxres">x and y resolution</param>
	<param name="pyres">x and y resolution</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixSetResolution(LeptonicaSharp.DPix,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="xres">x and y resolution</param>
	<param name="yres">x and y resolution</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixCopyResolution(LeptonicaSharp.DPix,LeptonicaSharp.DPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpixd"></param>
	<param name="dpixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixGetData(LeptonicaSharp.DPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<returns>ptr DPixdata, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixSetData(LeptonicaSharp.DPix,System.Double[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="data"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixGetPixel(LeptonicaSharp.DPix,System.Int32,System.Int32@,System.Double[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="x">,y pixel coords</param>
	<param name="pval">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixSetPixel(LeptonicaSharp.DPix,System.Int32,System.Int32@,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="x">,y pixel coords</param>
	<param name="val">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>fpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>fpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">of serialized fpix</param>
	<param name="size">of data in bytes</param>
	<returns>fpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixWrite(System.String,LeptonicaSharp.FPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="fpix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.FPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="fpix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.FPix)">
	<summary>
 Notes
 (1) Serializes a fpix in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized fpix</param>
	<param name="psize">size of returned data</param>
	<param name="fpix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixEndianByteSwap(LeptonicaSharp.FPix,LeptonicaSharp.FPix)">
	<summary>
 Notes
 (1) On big-endian hardware, this does byte-swapping on each of
 the 4-byte floats in the fpix data.  On little-endians,
 the data is unchanged.  This is used for serialization
 of fpix; the data is serialized in little-endian byte
 order because most hardware is little-endian.
 (2) The operation can be either in-place or, if fpixd == NULL,
 a new fpix is made.  If not in-place, caller must catch
 the returned pointer.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">can be equal to fpixs or NULL</param>
	<param name="fpixs"></param>
	<returns>fpixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>dpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>dpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">of serialized dpix</param>
	<param name="size">of data in bytes</param>
	<returns>dpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixWrite(System.String,LeptonicaSharp.DPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="dpix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.DPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="dpix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.DPix)">
	<summary>
 Notes
 (1) Serializes a dpix in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized dpix</param>
	<param name="psize">size of returned data</param>
	<param name="dpix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixEndianByteSwap(LeptonicaSharp.DPix,LeptonicaSharp.DPix)">
	<summary>
 Notes
 (1) On big-endian hardware, this does byte-swapping on each of
 the 4-byte words in the dpix data.  On little-endians,
 the data is unchanged.  This is used for serialization
 of dpix; the data is serialized in little-endian byte
 order because most hardware is little-endian.
 (2) The operation can be either in-place or, if dpixd == NULL,
 a new dpix is made.  If not in-place, caller must catch
 the returned pointer.
 </summary>
	<remarks>
	</remarks>
	<param name="dpixd">can be equal to dpixs or NULL</param>
	<param name="dpixs"></param>
	<returns>dpixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixPrintStream(LeptonicaSharp.FILE,LeptonicaSharp.FPix,System.Int32)">
	<summary>
 Notes
 (1) Subsampled printout of fpix for debugging.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="fpix"></param>
	<param name="factor">subsampled</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertToFPix(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) If colormapped, remove to grayscale.
 (2) If 32 bpp and %ncomps == 3, this is RGB; convert to luminance.
 In all other cases the src image is treated as having a single
 component of pixel values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="ncomps">number of components 3 for RGB, 1 otherwise</param>
	<returns>fpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertToDPix(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) If colormapped, remove to grayscale.
 (2) If 32 bpp and %ncomps == 3, this is RGB; convert to luminance.
 In all other cases the src image is treated as having a single
 component of pixel values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="ncomps">number of components 3 for RGB, 1 otherwise</param>
	<returns>dpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixConvertToPix(LeptonicaSharp.FPix,System.Int32,LeptonicaSharp.Enumerations.L_hling_negative_values_in_conversion_to_unsigned_int,System.Int32)">
	<summary>
 Notes
 (1) Use %outdepth = 0 to programmatically determine the
 output depth.  If no values are greater than 255,
 it will set outdepth = 8; otherwise to 16 or 32.
 (2) Because we are converting a float to an unsigned int
 with a specified dynamic range (8, 16 or 32 bits), errors
 can occur.  If errorflag == TRUE, output the number
 of values out of range, both negative and positive.
 (3) If a pixel value is positive and out of range, clip to
 the maximum value represented at the outdepth of 8, 16
 or 32 bits.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="outdepth">0, 8, 16 or 32 bpp</param>
	<param name="negvals">L_CLIP_TO_ZERO, L_TAKE_ABSVAL</param>
	<param name="errorflag">1 to output error stats; 0 otherwise</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixDisplayMaxDynamicRange(LeptonicaSharp.FPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixConvertToDPix(LeptonicaSharp.FPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<returns>dpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixConvertToPix(LeptonicaSharp.DPix,System.Int32,LeptonicaSharp.Enumerations.L_hling_negative_values_in_conversion_to_unsigned_int,System.Int32)">
	<summary>
 Notes
 (1) Use %outdepth = 0 to programmatically determine the
 output depth.  If no values are greater than 255,
 it will set outdepth = 8; otherwise to 16 or 32.
 (2) Because we are converting a float to an unsigned int
 with a specified dynamic range (8, 16 or 32 bits), errors
 can occur.  If errorflag == TRUE, output the number
 of values out of range, both negative and positive.
 (3) If a pixel value is positive and out of range, clip to
 the maximum value represented at the outdepth of 8, 16
 or 32 bits.
 </summary>
	<remarks>
	</remarks>
	<param name="dpixs"></param>
	<param name="outdepth">0, 8, 16 or 32 bpp</param>
	<param name="negvals">L_CLIP_TO_ZERO, L_TAKE_ABSVAL</param>
	<param name="errorflag">1 to output error stats; 0 otherwise</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixConvertToFPix(LeptonicaSharp.DPix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<returns>fpix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixGetMin(LeptonicaSharp.FPix,System.Single[]@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="pminval">min value</param>
	<param name="pxminloc">x location of min</param>
	<param name="pyminloc">y location of min</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixGetMax(LeptonicaSharp.FPix,System.Single[]@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="pmaxval">max value</param>
	<param name="pxmaxloc">x location of max</param>
	<param name="pymaxloc">y location of max</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixGetMin(LeptonicaSharp.DPix,System.Double[]@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="pminval">min value</param>
	<param name="pxminloc">x location of min</param>
	<param name="pyminloc">y location of min</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixGetMax(LeptonicaSharp.DPix,System.Double[]@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="pmaxval">max value</param>
	<param name="pxmaxloc">x location of max</param>
	<param name="pymaxloc">y location of max</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixScaleByInteger(LeptonicaSharp.FPix,System.Int32)">
	<summary>
 Notes
 (1) The width wd of fpixd is related to ws of fpixs by
 wd = factor  (ws - 1) + 1   (and ditto for the height)
 We avoid special-casing boundary pixels in the interpolation
 by constructing fpixd by inserting (factor - 1) interpolated
 pixels between each pixel in fpixs.  Then
 wd = ws + (ws - 1)  (factor - 1) (same as above)
 This also has the advantage that if we subsample by %factor,
 throwing out all the interpolated pixels, we regain the
 original low resolution fpix.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs">low resolution, subsampled</param>
	<param name="factor">scaling factor</param>
	<returns>fpixd interpolated result, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixScaleByInteger(LeptonicaSharp.DPix,System.Int32)">
	<summary>
 Notes
 (1) The width wd of dpixd is related to ws of dpixs by
 wd = factor  (ws - 1) + 1   (and ditto for the height)
 We avoid special-casing boundary pixels in the interpolation
 by constructing fpixd by inserting (factor - 1) interpolated
 pixels between each pixel in fpixs.  Then
 wd = ws + (ws - 1)  (factor - 1) (same as above)
 This also has the advantage that if we subsample by %factor,
 throwing out all the interpolated pixels, we regain the
 original low resolution dpix.
 </summary>
	<remarks>
	</remarks>
	<param name="dpixs">low resolution, subsampled</param>
	<param name="factor">scaling factor</param>
	<returns>dpixd interpolated result, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixLinearCombination(LeptonicaSharp.FPix,LeptonicaSharp.FPix,System.Single,System.Single,LeptonicaSharp.FPix)">
	<summary>
 Notes
 (1) Computes pixelwise linear combination a  src1 + b  src2
 (2) Alignment is to UL corner.
 (3) There are 3 cases.  The result can go to a new dest,
 in-place to fpixs1, or to an existing input dest
 fpixd == null   (src1 + src2) --GT new fpixd
 fpixd == fpixs1  (src1 + src2) --GT src1  (in-place)
 fpixd != fpixs1 (src1 + src2) --GT input fpixd
 (4) fpixs2 must be different from both fpixd and fpixs1.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">; this can be null, equal to fpixs1, or different from fpixs1</param>
	<param name="fpixs1">can be == to fpixd</param>
	<param name="fpixs2"></param>
	<param name="a">multiplication factors on fpixs1 and fpixs2, rsp.</param>
	<param name="b">multiplication factors on fpixs1 and fpixs2, rsp.</param>
	<returns>fpixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixAddMultConstant(LeptonicaSharp.FPix,System.Single,System.Single)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) It can be used to multiply each pixel by a constant,
 and also to add a constant to each pixel.  Multiplication
 is done first.
 </summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="addc">use 0.0 to skip the operation</param>
	<param name="multc">use 1.0 to skip the operation</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixLinearCombination(LeptonicaSharp.DPix,LeptonicaSharp.DPix,System.Single,System.Single,LeptonicaSharp.DPix)">
	<summary>
 Notes
 (1) Computes pixelwise linear combination a  src1 + b  src2
 (2) Alignment is to UL corner.
 (3) There are 3 cases.  The result can go to a new dest,
 in-place to dpixs1, or to an existing input dest
 dpixd == null   (src1 + src2) --GT new dpixd
 dpixd == dpixs1  (src1 + src2) --GT src1  (in-place)
 dpixd != dpixs1 (src1 + src2) --GT input dpixd
 (4) dpixs2 must be different from both dpixd and dpixs1.
 </summary>
	<remarks>
	</remarks>
	<param name="dpixd">; this can be null, equal to dpixs1, or different from dpixs1</param>
	<param name="dpixs1">can be == to dpixd</param>
	<param name="dpixs2"></param>
	<param name="a">multiplication factors on dpixs1 and dpixs2, rsp.</param>
	<param name="b">multiplication factors on dpixs1 and dpixs2, rsp.</param>
	<returns>dpixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixAddMultConstant(LeptonicaSharp.DPix,System.Double,System.Double)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) It can be used to multiply each pixel by a constant,
 and also to add a constant to each pixel.  Multiplication
 is done first.
 </summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="addc">use 0.0 to skip the operation</param>
	<param name="multc">use 1.0 to skip the operation</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixSetAllArbitrary(LeptonicaSharp.FPix,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="inval">to set at each pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.dpixSetAllArbitrary(LeptonicaSharp.DPix,System.Double)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="dpix"></param>
	<param name="inval">to set at each pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixAddBorder(LeptonicaSharp.FPix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Adds border of '0' 32-bit pixels
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="left">pixels on each side to be added</param>
	<param name="right">pixels on each side to be added</param>
	<param name="top">pixels on each side to be added</param>
	<param name="bot">pixels on each side to be added</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixRemoveBorder(LeptonicaSharp.FPix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="left">pixels on each side to be removed</param>
	<param name="right">pixels on each side to be removed</param>
	<param name="top">pixels on each side to be removed</param>
	<param name="bot">pixels on each side to be removed</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixAddMirroredBorder(LeptonicaSharp.FPix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixAddMirroredBorder() for situations of usage.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="left">pixels on each side to be added</param>
	<param name="right">pixels on each side to be added</param>
	<param name="top">pixels on each side to be added</param>
	<param name="bot">pixels on each side to be added</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixAddContinuedBorder(LeptonicaSharp.FPix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This adds pixels on each side whose values are equal to
 the value on the closest boundary pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="left">pixels on each side to be added</param>
	<param name="right">pixels on each side to be added</param>
	<param name="top">pixels on each side to be added</param>
	<param name="bot">pixels on each side to be added</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixAddSlopeBorder(LeptonicaSharp.FPix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This adds pixels on each side whose values have a normal
 derivative equal to the normal derivative at the boundary
 of fpixs.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="left">pixels on each side to be added</param>
	<param name="right">pixels on each side to be added</param>
	<param name="top">pixels on each side to be added</param>
	<param name="bot">pixels on each side to be added</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixRasterop(LeptonicaSharp.FPix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.FPix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is similar in structure to pixRasterop(), except
 it only allows copying from the source into the destination.
 For that reason, no op code is necessary.  Additionally,
 all pixels are 32 bit words (float values), which makes
 the copy very simple.
 (2) Clipping of both src and dest fpix are done automatically.
 (3) This allows in-place copying, without checking to see if
 the result is valid  use for in-place with caution!
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">dest fpix</param>
	<param name="dx">x val of UL corner of dest rectangle</param>
	<param name="dy">y val of UL corner of dest rectangle</param>
	<param name="dw">width of dest rectangle</param>
	<param name="dh">height of dest rectangle</param>
	<param name="fpixs">src fpix</param>
	<param name="sx">x val of UL corner of src rectangle</param>
	<param name="sy">y val of UL corner of src rectangle</param>
	<returns>0 if OK; 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixRotateOrth(LeptonicaSharp.FPix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="quads">0-3; number of 90 degree cw rotations</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixRotate180(LeptonicaSharp.FPix,LeptonicaSharp.FPix)">
	<summary>
 Notes
 (1) This does a 180 rotation of the image about the center,
 which is equivalent to a left-right flip about a vertical
 line through the image center, followed by a top-bottom
 flip about a horizontal line through the image center.
 (2) There are 3 cases for input
 (a) fpixd == null (creates a new fpixd)
 (b) fpixd == fpixs (in-place operation)
 (c) fpixd != fpixs (existing fpixd)
 (3) For clarity, use these three patterns, respectively
 (a) fpixd = fpixRotate180(NULL, fpixs);
 (b) fpixRotate180(fpixs, fpixs);
 (c) fpixRotate180(fpixd, fpixs);
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">; can be null, equal to fpixs, or different from fpixs</param>
	<param name="fpixs"></param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixRotate90(LeptonicaSharp.FPix,System.Int32)">
	<summary>
 Notes
 (1) This does a 90 degree rotation of the image about the center,
 either cw or ccw, returning a new pix.
 (2) The direction must be either 1 (cw) or -1 (ccw).
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="direction">1 = clockwise,  -1 = counter-clockwise</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixFlipLR(LeptonicaSharp.FPix,LeptonicaSharp.FPix)">
	<summary>
 Notes
 (1) This does a left-right flip of the image, which is
 equivalent to a rotation out of the plane about a
 vertical line through the image center.
 (2) There are 3 cases for input
 (a) fpixd == null (creates a new fpixd)
 (b) fpixd == fpixs (in-place operation)
 (c) fpixd != fpixs (existing fpixd)
 (3) For clarity, use these three patterns, respectively
 (a) fpixd = fpixFlipLR(NULL, fpixs);
 (b) fpixFlipLR(fpixs, fpixs);
 (c) fpixFlipLR(fpixd, fpixs);
 (4) If an existing fpixd is not the same size as fpixs, the
 image data will be reallocated.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">; can be null, equal to fpixs, or different from fpixs</param>
	<param name="fpixs"></param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixFlipTB(LeptonicaSharp.FPix,LeptonicaSharp.FPix)">
	<summary>
 Notes
 (1) This does a top-bottom flip of the image, which is
 equivalent to a rotation out of the plane about a
 horizontal line through the image center.
 (2) There are 3 cases for input
 (a) fpixd == null (creates a new fpixd)
 (b) fpixd == fpixs (in-place operation)
 (c) fpixd != fpixs (existing fpixd)
 (3) For clarity, use these three patterns, respectively
 (a) fpixd = fpixFlipTB(NULL, fpixs);
 (b) fpixFlipTB(fpixs, fpixs);
 (c) fpixFlipTB(fpixd, fpixs);
 (4) If an existing fpixd is not the same size as fpixs, the
 image data will be reallocated.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixd">; can be null, equal to fpixs, or different from fpixs</param>
	<param name="fpixs"></param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixAffinePta(LeptonicaSharp.FPix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.Int32,System.Single)">
	<summary>
 Notes
 (1) If %border GT 0, all four sides are extended by that distance,
 and removed after the transformation is finished.  Pixels
 that would be brought in to the trimmed result from outside
 the extended region are assigned %inval.  The purpose of
 extending the image is to avoid such assignments.
 (2) On the other hand, you may want to give all pixels that
 are brought in from outside fpixs a specific value.  In that
 case, set %border == 0.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs">8 bpp</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="border">size of extension with constant normal derivative</param>
	<param name="inval">value brought in; typ. 0</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixAffine(LeptonicaSharp.FPix,System.Single[],System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixs">8 bpp</param>
	<param name="vc">vector of 8 coefficients for projective transformation</param>
	<param name="inval">value brought in; typ. 0</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixProjectivePta(LeptonicaSharp.FPix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.Int32,System.Single)">
	<summary>
 Notes
 (1) If %border GT 0, all four sides are extended by that distance,
 and removed after the transformation is finished.  Pixels
 that would be brought in to the trimmed result from outside
 the extended region are assigned %inval.  The purpose of
 extending the image is to avoid such assignments.
 (2) On the other hand, you may want to give all pixels that
 are brought in from outside fpixs a specific value.  In that
 case, set %border == 0.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs">8 bpp</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="border">size of extension with constant normal derivative</param>
	<param name="inval">value brought in; typ. 0</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixProjective(LeptonicaSharp.FPix,System.Single[],System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpixs">8 bpp</param>
	<param name="vc">vector of 8 coefficients for projective transformation</param>
	<param name="inval">value brought in; typ. 0</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.linearInterpolatePixelFloat(System.Single[],System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single[]@)">
	<summary>
 Notes
 (1) This is a standard linear interpolation function.  It is
 equivalent to area weighting on each component, and
 avoids "jaggies" when rendering sharp edges.
 </summary>
	<remarks>
	</remarks>
	<param name="datas">ptr to beginning of float image data</param>
	<param name="w">of image</param>
	<param name="h">of image</param>
	<param name="x">floating pt location for evaluation</param>
	<param name="y">floating pt location for evaluation</param>
	<param name="inval">float value brought in from the outside when the input x,y location is outside the image</param>
	<param name="pval">interpolated float value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixThresholdToPix(LeptonicaSharp.FPix,System.Single)">
	<summary>
 Notes
 (1) For all values of fpix that are LT= thresh, sets the pixel
 in pixd to 1.
 </summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="thresh"></param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixComponentFunction(LeptonicaSharp.Pix,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This stores a function of the component values of each
 input pixel in %fpixd.
 (2) The function is a ratio of linear combinations of component values.
 There are two special cases for denominator coefficients
 (a) The denominator is 1.0 input 0 for all denominator coefficients
 (b) Only one component is used in the denominator input 1.0
 for that denominator component and 0.0 for the other two.
 (3) If the denominator is 0, multiply by an arbitrary number that
 is much larger than 1.  Choose 256 "arbitrarily".
 </summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="rnum">coefficients for numerator</param>
	<param name="gnum">coefficients for numerator</param>
	<param name="bnum">coefficients for numerator</param>
	<param name="rdenom">coefficients for denominator</param>
	<param name="gdenom">coefficients for denominator</param>
	<param name="bdenom">coefficients for denominator</param>
	<returns>fpixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadStreamGif(LeptonicaSharp.FILE@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadMemGif(System.Byte[]@,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamGif(LeptonicaSharp.FILE@,LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMemGif(System.Object@,System.Object@,LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotCreate(System.String,LeptonicaSharp.Enumerations.GPLOT_OUTPUT,System.String,System.String,System.String)">
	<summary>
 Notes
 (1) This initializes the plot.
 (2) The 'title', 'xlabel' and 'ylabel' strings can have spaces,
 double quotes and backquotes, but not single quotes.
 </summary>
	<remarks>
	</remarks>
	<param name="rootname">root for all output files</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="title">overall title</param>
	<param name="xlabel">x axis label</param>
	<param name="ylabel">y axis label</param>
	<returns>gplot, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotDestroy(LeptonicaSharp.GPlot@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pgplot">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotAddPlot(LeptonicaSharp.GPlot,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.GPLOT_STYLE,LeptonicaSharp.Numa,System.String)">
	<summary>
 Notes
 (1) There are 2 options for (x,y) values
 o  To plot an array vs a linear function of the
 index, set nax = NULL.
 o  To plot one array vs another, use both nax and nay.
 (2) If nax is NULL, the x value corresponding to the i-th
 value of nay is found from the startx and delx fields
 in nay
 x = startx + i  delx
 These are set with numaSetParameters().  Their default
 values are startx = 0.0, delx = 1.0.
 (3) If nax is defined, it must be the same size as nay, and
 must have at least one number.
 (4) The 'plottitle' string can have spaces, double
 quotes and backquotes, but not single quotes.
 </summary>
	<remarks>
	</remarks>
	<param name="gplot"></param>
	<param name="nax">numa set to null for Y_VS_I; required for Y_VS_X</param>
	<param name="nay">numa required for both Y_VS_I and Y_VS_X</param>
	<param name="plotstyle">GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES, GPLOT_LINESPOINTS, GPLOT_DOTS</param>
	<param name="plottitle">title for individual plot</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotSetScaling(LeptonicaSharp.GPlot,LeptonicaSharp.Enumerations.GPLOT_SCALING)">
	<summary>
 Notes
 (1) By default, the x and y axis scaling is linear.
 (2) Call this function to set semi-log or log-log scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="gplot"></param>
	<param name="scaling">GPLOT_LINEAR_SCALE, GPLOT_LOG_SCALE_X, GPLOT_LOG_SCALE_Y, GPLOT_LOG_SCALE_X_Y</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotMakeOutput(LeptonicaSharp.GPlot)">
	<summary>
 Notes
 (1) This uses gplot and the new arrays to add a plot
 to the output, by writing a new data file and appending
 the appropriate plot commands to the command file.
 (2) This is the only function in this file that requires the
 gnuplot executable, to actually generate the plot.
 (3) The command file name for unix is canonical (i.e., directory /tmp)
 but the temp filename paths in the command file must be correct.
 (4) The gnuplot program for windows is wgnuplot.exe.
 </summary>
	<remarks>
	</remarks>
	<param name="gplot"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotGenCommandFile(LeptonicaSharp.GPlot)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="gplot"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotGenDataFiles(LeptonicaSharp.GPlot)">
	<summary>
 Notes
 (1) The pathnames in the gplot command file are actual pathnames,
 which can be in temp directories.  Consequently, they must not be
 rewritten by calling fopenWriteStream(), and we use fopen().
 </summary>
	<remarks>
	</remarks>
	<param name="gplot"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotSimple1(LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.GPLOT_OUTPUT,System.String,System.String)">
	<summary>
 Notes
 (1) This gives a line plot of a numa, where the array value
 is plotted vs the array index.  The plot is generated
 in the specified output format; the title  is optional.
 (2) When calling these simple plot functions more than once, use
 different %outroot to avoid overwriting the output files.
 </summary>
	<remarks>
	</remarks>
	<param name="na">numa; plot Y_VS_I</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="outroot">root of output files</param>
	<param name="title">, can be NULL</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotSimple2(LeptonicaSharp.Numa,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.GPLOT_OUTPUT,System.String,System.String)">
	<summary>
 Notes
 (1) This gives a line plot of two numa, where the array values
 are each plotted vs the array index.  The plot is generated
 in the specified output format; the title  is optional.
 (2) When calling these simple plot functions more than once, use
 different %outroot to avoid overwriting the output files.
 </summary>
	<remarks>
	</remarks>
	<param name="na1">numa; plotted with Y_VS_I</param>
	<param name="na2">ditto</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="outroot">root of output files</param>
	<param name="title"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotSimpleN(LeptonicaSharp.Numaa,LeptonicaSharp.Enumerations.GPLOT_OUTPUT,System.String,System.String)">
	<summary>
 Notes
 (1) This gives a line plot of all numas in a numaa (array of numa),
 where the array values are each plotted vs the array index.
 The plot is generated in the specified output format;
 the title  is optional.
 (2) When calling these simple plot functions more than once, use
 different %outroot to avoid overwriting the output files.
 </summary>
	<remarks>
	</remarks>
	<param name="naa">numaa; we plotted with Y_VS_I for each numa</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="outroot">root of output files</param>
	<param name="title"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotSimpleXY1(LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.GPLOT_STYLE,LeptonicaSharp.Enumerations.GPLOT_OUTPUT,System.String,LeptonicaSharp.Numa,System.String)">
	<summary>
 Notes
 (1) This gives a plot of a %nay vs %nax, generated in
 the specified output format.  The title is optional.
 (2) Use 0 for default plotstyle (lines).
 (3) %nax is optional.  If NULL, %nay is plotted against
 the array index.
 (4) When calling these simple plot functions more than once, use
 different %outroot to avoid overwriting the output files.
 </summary>
	<remarks>
	</remarks>
	<param name="nax"></param>
	<param name="nay"></param>
	<param name="plotstyle">GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES, GPLOT_LINESPOINTS, GPLOT_DOTS</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="outroot">root of output files</param>
	<param name="title">, can be NULL</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotSimpleXY2(LeptonicaSharp.Numa,LeptonicaSharp.Numa,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.GPLOT_STYLE,LeptonicaSharp.Enumerations.GPLOT_OUTPUT,System.String,System.String)">
	<summary>
 Notes
 (1) This gives plots of %nay1 and %nay2 against nax, generated
 in the specified output format.  The title is optional.
 (2) Use 0 for default plotstyle (lines).
 (3) %nax is optional.  If NULL, %nay1 and %nay2 are plotted
 against the array index.
 (4) When calling these simple plot functions more than once, use
 different %outroot to avoid overwriting the output files.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">LToptional; can be NULL</param>
	<param name="nay1"></param>
	<param name="nay2"></param>
	<param name="plotstyle">GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES, GPLOT_LINESPOINTS, GPLOT_DOTS</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="outroot">root of output files</param>
	<param name="title"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotSimpleXYN(LeptonicaSharp.Numaa,LeptonicaSharp.Enumerations.GPLOT_STYLE,LeptonicaSharp.Enumerations.GPLOT_OUTPUT,System.String,LeptonicaSharp.Numa,System.String)">
	<summary>
 Notes
 (1) This gives plots of each Numa in %naa against nax,
 generated in the specified output format.  The title is optional.
 (2) Use 0 for default plotstyle (lines).
 (3) %nax is optional.  If NULL, each Numa array is plotted against
 the array index.
 (4) When calling these simple plot functions more than once, use
 different %outroot to avoid overwriting the output files.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">; can be NULL</param>
	<param name="naay">numaa of arrays to plot against %nax</param>
	<param name="plotstyle">GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES, GPLOT_LINESPOINTS, GPLOT_DOTS</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="outroot">root of output files</param>
	<param name="title"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>gplot, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.gplotWrite(System.String,LeptonicaSharp.GPlot)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="gplot"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generatePtaLine(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Uses Bresenham line drawing, which results in an 8-connected line.
 </summary>
	<remarks>
	</remarks>
	<param name="x1">end point 1</param>
	<param name="y1">end point 1</param>
	<param name="x2">end point 2</param>
	<param name="y2">end point 2</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generatePtaWideLine(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="x1">end point 1</param>
	<param name="y1">end point 1</param>
	<param name="x2">end point 2</param>
	<param name="y2">end point 2</param>
	<param name="width"></param>
	<returns>ptaj, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generatePtaBox(LeptonicaSharp.Box,System.Int32)">
	<summary>
 Notes
 (1) Because the box is constructed so that we don't have any
 overlapping lines, there is no need to remove duplicates.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="width">of line</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generatePtaBoxa(LeptonicaSharp.Boxa,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If the boxa has overlapping boxes, and if blending will
 be used to give a transparent effect, transparency
 artifacts at line intersections can be removed using
 removedups = 1.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="width"></param>
	<param name="removedups">1 to remove, 0 to leave</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generatePtaHashBox(LeptonicaSharp.Box,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_LINE,System.Int32)">
	<summary>
 Notes
 (1) The orientation takes on one of 4 orientations (horiz, vertical,
 slope +1, slope -1).
 (2) The full outline is also drawn if %outline = 1.
 </summary>
	<remarks>
	</remarks>
	<param name="box"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">of line</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generatePtaHashBoxa(LeptonicaSharp.Boxa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_LINE,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The orientation takes on one of 4 orientations (horiz, vertical,
 slope +1, slope -1).
 (2) The full outline is also drawn if %outline = 1.
 (3) If the boxa has overlapping boxes, and if blending will
 be used to give a transparent effect, transparency
 artifacts at line intersections can be removed using
 removedups = 1.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">of line</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="removedups">1 to remove, 0 to leave</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generatePtaaBoxa(LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) This generates a pta of the four corners for each box in
 the boxa.
 (2) Each of these pta can be rendered onto a pix with random colors,
 by using pixRenderRandomCmapPtaa() with closeflag = 1.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generatePtaaHashBoxa(LeptonicaSharp.Boxa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_LINE,System.Int32)">
	<summary>
 Notes
 (1) The orientation takes on one of 4 orientations (horiz, vertical,
 slope +1, slope -1).
 (2) The full outline is also drawn if %outline = 1.
 (3) Each of these pta can be rendered onto a pix with random colors,
 by using pixRenderRandomCmapPtaa() with closeflag = 1.
 </summary>
	<remarks>
	</remarks>
	<param name="boxa"></param>
	<param name="spacing">spacing between hash lines; must be GT 1</param>
	<param name="width">hash line width</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generatePtaPolyline(LeptonicaSharp.Pta,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas">vertices of polyline</param>
	<param name="width"></param>
	<param name="closeflag">1 to close the contour; 0 otherwise</param>
	<param name="removedups">1 to remove, 0 to leave</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generatePtaGrid(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="w">of region where grid will be displayed</param>
	<param name="h">of region where grid will be displayed</param>
	<param name="nx">number of rectangles in each direction in grid</param>
	<param name="ny">number of rectangles in each direction in grid</param>
	<param name="width">of rendered lines</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertPtaLineTo4cc(LeptonicaSharp.Pta)">
	<summary>
 Notes
 (1) When a polyline is generated with width = 1, the resulting
 line is not 4-connected in general.  This function adds
 points as necessary to convert the line to 4-cconnected.
 It is useful when rendering 1 bpp on a pix.
 (2) Do not use this for lines generated with width GT 1.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">8-connected line of points</param>
	<returns>ptad 4-connected line, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generatePtaFilledCircle(System.Int32)">
	<summary>
 Notes
 (1) The circle is has diameter = 2  radius + 1.
 (2) It is located with the center of the circle at the
 point (radius, radius).
 (3) Consequently, it typically must be translated if
 it is to represent a set of pixels in an image.
 </summary>
	<remarks>
	</remarks>
	<param name="radius"></param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generatePtaFilledSquare(System.Int32)">
	<summary>
 Notes
 (1) The center of the square can be chosen to be at
 (side / 2, side / 2).  It must be translated by this amount
 when used for replication.
 </summary>
	<remarks>
	</remarks>
	<param name="side"></param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generatePtaLineFromPt(System.Int32,System.Int32,System.Double,System.Double)">
	<summary>
 Notes
 (1) The %length of the line is 1 greater than the distance
 used in locatePtRadially().  Example a distance of 1
 gives rise to a length of 2.
 </summary>
	<remarks>
	</remarks>
	<param name="x">point of origination</param>
	<param name="y">point of origination</param>
	<param name="length">of line, including starting point</param>
	<param name="radang">angle in radians, CW from horizontal</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.locatePtRadially(System.Int32,System.Int32,System.Double,System.Double,System.Double[]@,System.Double[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="xr">reference point</param>
	<param name="yr">reference point</param>
	<param name="dist">distance of point from reference point along line given by the specified angle</param>
	<param name="radang">angle in radians, CW from horizontal</param>
	<param name="px">location of point</param>
	<param name="py">location of point</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderPlotFromNuma(LeptonicaSharp.Pix@,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_PLOT_AT,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) Simplified interface for plotting row or column aligned data
 on a pix.
 (2) This replaces %pix with a 32 bpp rgb version if it is not
 already 32 bpp.  It then draws the plot on the pix.
 (3) See makePlotPtaFromNumaGen() for more details.
 </summary>
	<remarks>
	</remarks>
	<param name="ppix">any type; replaced if not 32 bpp rgb</param>
	<param name="na">to be plotted</param>
	<param name="plotloc">location of plot L_PLOT_AT_TOP, etc</param>
	<param name="linewidth">width of "line" that is drawn; between 1 and 7</param>
	<param name="max">maximum excursion in pixels from baseline</param>
	<param name="color">plot color 0xrrggbb00</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makePlotPtaFromNuma(LeptonicaSharp.Numa,System.Int32,LeptonicaSharp.Enumerations.L_PLOT_AT,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates points from %numa representing y(x) or x(y)
 with respect to a pix.  A horizontal plot y(x) is drawn for
 a function of column position, and a vertical plot is drawn
 for a function x(y) of row position.  The baseline is located
 so that all plot points will fit in the pix.
 (2) See makePlotPtaFromNumaGen() for more details.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="size">pix height for horizontal plot; width for vertical plot</param>
	<param name="plotloc">location of plot L_PLOT_AT_TOP, etc</param>
	<param name="linewidth">width of "line" that is drawn; between 1 and 7</param>
	<param name="max">maximum excursion in pixels from baseline</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderPlotFromNumaGen(LeptonicaSharp.Pix@,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_LINE,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) General interface for plotting row or column aligned data
 on a pix.
 (2) This replaces %pix with a 32 bpp rgb version if it is not
 already 32 bpp.  It then draws the plot on the pix.
 (3) See makePlotPtaFromNumaGen() for other input parameters.
 </summary>
	<remarks>
	</remarks>
	<param name="ppix">any type; replaced if not 32 bpp rgb</param>
	<param name="na">to be plotted</param>
	<param name="orient">L_HORIZONTAL_LINE, L_VERTICAL_LINE</param>
	<param name="linewidth">width of "line" that is drawn; between 1 and 7</param>
	<param name="refpos">reference position y for horizontal and x for vertical</param>
	<param name="max">maximum excursion in pixels from baseline</param>
	<param name="drawref">1 to draw the reference line and the normal to it</param>
	<param name="color">plot color 0xrrggbb00</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makePlotPtaFromNumaGen(LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_LINE,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates points from %numa representing y(x) or x(y)
 with respect to a pix.  For y(x), we draw a horizontal line
 at the reference position and a vertical line at the edge; then
 we draw the values of %numa, scaled so that the maximum
 excursion from the reference position is %max pixels.
 (2) The start and delx parameters of %numa are used to refer
 its values to the raster lines (L_VERTICAL_LINE) or columns
 (L_HORIZONTAL_LINE).
 (3) The linewidth is chosen in the interval [1 ... 7].
 (4) %refpos should be chosen so the plot is entirely within the pix
 that it will be painted onto.
 (5) This would typically be used to plot, in place, a function
 computed along pixel rows or columns.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="orient">L_HORIZONTAL_LINE, L_VERTICAL_LINE</param>
	<param name="linewidth">width of "line" that is drawn; between 1 and 7</param>
	<param name="refpos">reference position y for horizontal and x for vertical</param>
	<param name="max">maximum excursion in pixels from baseline</param>
	<param name="drawref">1 to draw the reference line and the normal to it</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderPta(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Enumerations.L_PIXELS)">
	<summary>
 Notes
 (1) L_SET_PIXELS puts all image bits in each pixel to 1
 (black for 1 bpp; white for depth GT 1)
 (2) L_CLEAR_PIXELS puts all image bits in each pixel to 0
 (white for 1 bpp; black for depth GT 1)
 (3) L_FLIP_PIXELS reverses all image bits in each pixel
 (4) This function clips the rendering to the pix.  It performs
 clipping for functions such as pixRenderLine(),
 pixRenderBox() and pixRenderBoxa(), that call pixRenderPta().
 </summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="pta">arbitrary set of points</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderPtaArb(LeptonicaSharp.Pix,LeptonicaSharp.Pta,System.Byte,System.Byte,System.Byte)">
	<summary>
 Notes
 (1) If pix is colormapped, render this color (or the nearest
 color if the cmap is full) on each pixel.
 (2) The rgb components have the standard dynamic range [0 ... 255]
 (3) If pix is not colormapped, do the best job you can using
 the input colors
 ~ d = 1 set the pixels
 ~ d = 2, 4, 8 average the input rgb value
 ~ d = 32 use the input rgb value
 (4) This function clips the rendering to the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, cmapped ok</param>
	<param name="pta">arbitrary set of points</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderPtaBlend(LeptonicaSharp.Pix,LeptonicaSharp.Pta,System.Byte,System.Byte,System.Byte,System.Single)">
	<summary>
 Notes
 (1) This function clips the rendering to the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="pta">arbitrary set of points</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderLine(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_PIXELS)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="x1"></param>
	<param name="y1"></param>
	<param name="x2"></param>
	<param name="y2"></param>
	<param name="width">thickness of line</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderLineArb(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte,System.Byte,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, cmapped ok</param>
	<param name="x1"></param>
	<param name="y1"></param>
	<param name="x2"></param>
	<param name="y2"></param>
	<param name="width">thickness of line</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderLineBlend(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte,System.Byte,System.Byte,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="x1"></param>
	<param name="y1"></param>
	<param name="x2"></param>
	<param name="y2"></param>
	<param name="width">thickness of line</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderBox(LeptonicaSharp.Pix,LeptonicaSharp.Box,System.Int32,LeptonicaSharp.Enumerations.L_PIXELS)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="box"></param>
	<param name="width">thickness of box lines</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderBoxArb(LeptonicaSharp.Pix,LeptonicaSharp.Box,System.Int32,System.Byte,System.Byte,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, cmapped ok</param>
	<param name="box"></param>
	<param name="width">thickness of box lines</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderBoxBlend(LeptonicaSharp.Pix,LeptonicaSharp.Box,System.Int32,System.Byte,System.Byte,System.Byte,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="box"></param>
	<param name="width">thickness of box lines</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract">in [0.0 - 1.0]; complete transparency (no effect if 0.0; no transparency if 1.0)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderBoxa(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,System.Int32,LeptonicaSharp.Enumerations.L_PIXELS)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="boxa"></param>
	<param name="width">thickness of line</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderBoxaArb(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,System.Int32,System.Byte,System.Byte,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; colormapped is ok</param>
	<param name="boxa"></param>
	<param name="width">thickness of line</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderBoxaBlend(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,System.Int32,System.Byte,System.Byte,System.Byte,System.Single,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="boxa"></param>
	<param name="width">thickness of line</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract">in [0.0 - 1.0]; complete transparency (no effect if 0.0; no transparency if 1.0)</param>
	<param name="removedups">1 to remove; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderHashBox(LeptonicaSharp.Pix,LeptonicaSharp.Box,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_LINE,System.Int32,LeptonicaSharp.Enumerations.L_PIXELS)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="box"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderHashBoxArb(LeptonicaSharp.Pix,LeptonicaSharp.Box,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_LINE,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; cmapped ok</param>
	<param name="box"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderHashBoxBlend(LeptonicaSharp.Pix,LeptonicaSharp.Box,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_LINE,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp</param>
	<param name="box"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract">in [0.0 - 1.0]; complete transparency (no effect if 0.0; no transparency if 1.0)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderHashMaskArb(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_LINE,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place operation that renders hash lines
 through a mask %pixm onto %pix.  The mask origin is
 translated by (%x,%y) relative to the origin of %pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; cmapped ok</param>
	<param name="pixm">1 bpp clipping mask for hash marks</param>
	<param name="x">,y   UL corner of %pixm with respect to %pix</param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderHashBoxa(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_LINE,System.Int32,LeptonicaSharp.Enumerations.L_PIXELS)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="boxa"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderHashBoxaArb(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_LINE,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; cmapped ok</param>
	<param name="boxa"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderHashBoxaBlend(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_LINE,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="boxa"></param>
	<param name="spacing">spacing between lines; must be GT 1</param>
	<param name="width">thickness of box and hash lines</param>
	<param name="orient">orientation of lines L_HORIZONTAL_LINE, ...</param>
	<param name="outline">0 to skip drawing box outline</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract">in [0.0 - 1.0]; complete transparency (no effect if 0.0; no transparency if 1.0)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderPolyline(LeptonicaSharp.Pix,LeptonicaSharp.Pta,System.Int32,LeptonicaSharp.Enumerations.L_PIXELS,System.Int32)">
	<summary>
 Notes
 This renders a closed contour.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, not cmapped</param>
	<param name="ptas"></param>
	<param name="width">thickness of line</param>
	<param name="op">one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS</param>
	<param name="closeflag">1 to close the contour; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderPolylineArb(LeptonicaSharp.Pix,LeptonicaSharp.Pta,System.Int32,System.Byte,System.Byte,System.Byte,System.Int32)">
	<summary>
 Notes
 This renders a closed contour.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; cmapped ok</param>
	<param name="ptas"></param>
	<param name="width">thickness of line</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="closeflag">1 to close the contour; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderPolylineBlend(LeptonicaSharp.Pix,LeptonicaSharp.Pta,System.Int32,System.Byte,System.Byte,System.Byte,System.Single,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="ptas"></param>
	<param name="width">thickness of line</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="fract">in [0.0 - 1.0]; complete transparency (no effect if 0.0; no transparency if 1.0)</param>
	<param name="closeflag">1 to close the contour; 0 otherwise</param>
	<param name="removedups">1 to remove; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderGridArb(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Byte,System.Byte,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, cmapped ok</param>
	<param name="nx">number of rectangles in each direction</param>
	<param name="ny">number of rectangles in each direction</param>
	<param name="width">thickness of grid lines</param>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderRandomCmapPtaa(LeptonicaSharp.Pix,LeptonicaSharp.Ptaa,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a debugging routine, that displays a set of
 pixels, selected by the set of Ptas in a Ptaa,
 in a random color in a pix.
 (2) If %polyflag == 1, each Pta is considered to be a polyline,
 and is rendered using %width and %closeflag.  Each polyline
 is rendered in a random color.
 (3) If %polyflag == 0, all points in each Pta are rendered in a
 random color.  The %width and %closeflag parameters are ignored.
 (4) The output pix is 8 bpp and colormapped.  Up to 254
 different, randomly selected colors, can be used.
 (5) The rendered pixels replace the input pixels.  They will
 be clipped silently to the input pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1, 2, 4, 8, 16, 32 bpp</param>
	<param name="ptaa"></param>
	<param name="polyflag">1 to interpret each Pta as a polyline; 0 to simply render the Pta as a set of pixels</param>
	<param name="width">thickness of line; use only for polyline</param>
	<param name="closeflag">1 to close the contour; 0 otherwise; use only for polyline mode</param>
	<returns>pixd cmapped, 8 bpp or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderPolygon(LeptonicaSharp.Pta,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The pix is the minimum size required to contain the origin
 and the polygon.  For example, the max x value of the input
 points is w - 1, where w is the pix width.
 (2) The rendered line is 4-connected, so that an interior or
 exterior 8-c.c. flood fill operation works properly.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">of vertices, none repeated</param>
	<param name="width">of polygon outline</param>
	<param name="pxmin">min x value of input pts</param>
	<param name="pymin">min y value of input pts</param>
	<returns>pix 1 bpp, with outline generated, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFillPolygon(LeptonicaSharp.Pix,LeptonicaSharp.Pta,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This fills the interior of the polygon, returning a
 new pix.  It works for both convex and non-convex polygons.
 (2) To generate a filled polygon from a pta
 PIX pixt = pixRenderPolygon(pta, 1, xmin, ymin);
 PIX pixd = pixFillPolygon(pixt, pta, xmin, ymin);
 pixDestroy(pixt);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, with 4-connected polygon outline</param>
	<param name="pta">vertices of the polygon</param>
	<param name="xmin">min values of vertices of polygon</param>
	<param name="ymin">min values of vertices of polygon</param>
	<returns>pixd with outline filled, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRenderContours(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The output can be either 1 bpp, showing just the contour
 lines, or a copy of the input pixs with the contour lines
 superposed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 16 bpp; no colormap</param>
	<param name="startval">value of lowest contour; must be in [0 ... maxval]</param>
	<param name="incr">increment to next contour; must be GT 0</param>
	<param name="outdepth">either 1 or depth of pixs</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixAutoRenderContours(LeptonicaSharp.FPix,System.Int32)">
	<summary>
 Notes
 (1) The increment is set to get approximately %ncontours.
 (2) The proximity to the target value for contour display
 is set to 0.15.
 (3) Negative values are rendered in red; positive values as black.
 </summary>
	<remarks>
	</remarks>
	<param name="fpix"></param>
	<param name="ncontours">GT 1, LT 500, typ. about 50</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixRenderContours(LeptonicaSharp.FPix,System.Single,System.Single)">
	<summary>
 Notes
 (1) Values are displayed when val/incr is within +-proxim
 to an integer.  The default value is 0.15; smaller values
 result in thinner contour lines.
 (2) Negative values are rendered in red; positive values as black.
 </summary>
	<remarks>
	</remarks>
	<param name="fpixs"></param>
	<param name="incr">increment between contours; must be GT 0.0</param>
	<param name="proxim">required proximity to target value; default 0.15</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGeneratePtaBoundary(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Similar to ptaGetBoundaryPixels(), except here
 we only get pixels in the foreground
 we can have a "line" width greater than 1 pixel.
 (2) Once generated, this can be applied to a random 1 bpp image
 to add a color boundary as follows
 Pta pta = pixGeneratePtaBoundary(pixs, width);
 Pix pix1 = pixConvert1To8Cmap(pixs);
 pixRenderPtaArb(pix1, pta, rval, gval, bval);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="width">of boundary line</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixErodeGray(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDilateGray(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOpenGray(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCloseGray(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixErodeGray3(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
 (2) If hsize = vsize = 1, just returns a copy.
 (3) It would be nice not to add a border, but it is required
 if we want the same results as from the general case.
 We add 4 bytes on the left to speed up the copying, and
 8 bytes at the right and bottom to allow unrolling of
 the computation of 8 pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="hsize">1 or 3</param>
	<param name="vsize">1 or 3</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDilateGray3(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
 (2) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="hsize">1 or 3</param>
	<param name="vsize">1 or 3</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOpenGray3(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
 (2) If hsize = vsize = 1, just returns a copy.
 (3) It would be nice not to add a border, but it is required
 to get the same results as for the general case.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="hsize">1 or 3</param>
	<param name="vsize">1 or 3</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCloseGray3(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
 (2) If hsize = vsize = 1, just returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="hsize">1 or 3</param>
	<param name="vsize">1 or 3</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDitherToBinary(LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>pixd dithered binary, or NULL on error The Floyd-Steinberg error diffusion dithering algorithm binarizes an 8 bpp grayscale image to a threshold of 128. If a pixel has a value above 127, it is binarized to white and the excess below 255 is subtracted from three neighboring pixels in the fractions 3/8 to i, j+1, 3/8 to i+1, j) and 1/4 to (i+1,j+1, truncating to 0 if necessary.  Likewise, if it the pixel has a value below 128, it is binarized to black and the excess above 0 is added to the neighboring pixels, truncating to 255 if necessary. This function differs from straight dithering in that it allows clipping of grayscale to 0 or 255 if the values are sufficiently close, without distribution of the excess. This uses default values to specify the range of lower and upper values near 0 and 255, rsp that are clipped to black and white without propagating the excess. Not propagating the excess has the effect of reducing the snake patterns in parts of the image that are nearly black or white; however, it also prevents the attempt to reproduce gray for those values. The implementation is straightforward.  It uses a pair of line buffers to avoid changing pixs.  It is about the same speed as pixDitherToBinaryLUT(), which uses three LUTs.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDitherToBinarySpec(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See comments above in pixDitherToBinary() for details.
 (2) The input parameters lowerclip and upperclip specify the range
 of lower and upper values (near 0 and 255, rsp) that are
 clipped to black and white without propagating the excess.
 For that reason, lowerclip and upperclip should be small numbers.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="lowerclip">lower clip distance to black; use 0 for default</param>
	<param name="upperclip">upper clip distance to white; use 0 for default</param>
	<returns>pixd dithered binary, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ditherToBinaryLineLow(System.Byte[],System.Int32,System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lined">ptr to beginning of dest line</param>
	<param name="w">width of image in pixels</param>
	<param name="bufs1">buffer of current source line</param>
	<param name="bufs2">buffer of next source line</param>
	<param name="lowerclip">lower clip distance to black</param>
	<param name="upperclip">upper clip distance to white</param>
	<param name="lastlineflag">0 if not last dest line, 1 if last dest line</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixThresholdToBinary(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) If the source pixel is less than the threshold value,
 the dest will be 1; otherwise, it will be 0.
 (2) For example, for 8 bpp src pix, if %thresh == 256, the dest
 1 bpp pix is all ones (fg), and if %thresh == 0, the dest
 pix is all zeros (bg).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">4 or 8 bpp</param>
	<param name="thresh">threshold value</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.thresholdToBinaryLineLow(System.Object@,System.Int32@,System.Object@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.pixVarThresholdToBinary(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If the pixel in pixs is less than the corresponding pixel
 in pixg, the dest will be 1; otherwise it will be 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="pixg">8 bpp; contains threshold values for each pixel</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAdaptThresholdToBinary(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a simple convenience function for doing adaptive
 thresholding on a grayscale image with variable background.
 It uses default parameters appropriate for typical text images.
 (2) %pixm is a 1 bpp mask over "image" regions, which are not
 expected to have a white background.  The mask inhibits
 background finding under the fg pixels of the mask.  For
 images with both text and image, the image regions would
 be binarized (or quantized) by a different set of operations.
 (3) As %gamma is increased, the foreground pixels are reduced.
 (4) Under the covers  The default background value for normalization
 is 200, so we choose 170 for 'maxval' in pixGammaTRC.  Likewise,
 the default foreground threshold for normalization is 60,
 so we choose 50 for 'minval' in pixGammaTRC.  Because
 170 was mapped to 255, choosing 200 for the threshold is
 quite safe for avoiding speckle noise from the background.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="pixm">1 bpp image mask; can be null</param>
	<param name="gamma">gamma correction; must be GT 0.0; typically ~1.0</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAdaptThresholdToBinaryGen(LeptonicaSharp.Pix,System.Single,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a convenience function for doing adaptive thresholding
 on a grayscale image with variable background.  Also see notes
 in pixAdaptThresholdToBinary().
 (2) Reducing %gamma increases the foreground (text) pixels.
 Use a low value (e.g., 0.5) for images with light text.
 (3) For normal images, see default args in pixAdaptThresholdToBinary().
 For images with very light text, these values are appropriate
 gamma  ~0.5
 blackval  ~70
 whiteval  ~190
 thresh ~200
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="pixm">1 bpp image mask; can be null</param>
	<param name="gamma">gamma correction; must be GT 0.0; typically ~1.0</param>
	<param name="blackval">dark value to set to black (0)</param>
	<param name="whiteval">light value to set to white (255)</param>
	<param name="thresh">final threshold for binarization</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenerateMaskByValue(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) %val is the pixel value that we are selecting.  It can be
 either a gray value or a colormap index.
 (2) If pixs is colormapped, %usecmap determines if the colormap
 index values are used, or if the colormap is removed to gray and
 the gray values are used.  For the latter, it generates
 an approximate grayscale value for each pixel, and then looks
 for gray pixels with the value %val.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp, or colormapped</param>
	<param name="val">of pixels for which we set 1 in dest</param>
	<param name="usecmap">1 to retain cmap values; 0 to convert to gray</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenerateMaskByBand(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Generates a 1 bpp mask pixd, the same size as pixs, where
 the fg pixels in the mask are those either within the specified
 band (for inband == 1) or outside the specified band
 (for inband == 0).
 (2) If pixs is colormapped, %usecmap determines if the colormap
 values are used, or if the colormap is removed to gray and
 the gray values are used.  For the latter, it generates
 an approximate grayscale value for each pixel, and then looks
 for gray pixels with the value %val.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp, or colormapped</param>
	<param name="lower">two pixel values from which a range, either between (inband) or outside of (!inband), determines which pixels in pixs cause us to set a 1 in the dest mask</param>
	<param name="upper">two pixel values from which a range, either between (inband) or outside of (!inband), determines which pixels in pixs cause us to set a 1 in the dest mask</param>
	<param name="inband">1 for finding pixels in [lower, upper]; 0 for finding pixels in [0, lower) union (upper, 255]</param>
	<param name="usecmap">1 to retain cmap values; 0 to convert to gray</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDitherTo2bpp(LeptonicaSharp.Pix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="cmapflag">1 to generate a colormap</param>
	<returns>pixd dithered 2 bpp, or NULL on error An analog of the Floyd-Steinberg error diffusion dithering algorithm is used to "dibitize" an 8 bpp grayscale image to 2 bpp, using equally spaced gray values of 0, 85, 170, and 255, which are served by thresholds of 43, 128 and 213. If cmapflag == 1, the colormap values are set to 0, 85, 170 and 255. If a pixel has a value between 0 and 42, it is dibitized to 0, and the excess above 0 is added to the three neighboring pixels, in the fractions 3/8 to i, j+1, 3/8 to i+1, j) and 1/4 to (i+1, j+1, truncating to 255 if necessary.  If a pixel has a value between 43 and 127, it is dibitized to 1, and the excess above 85 is added to the three neighboring pixels as before.  If the value is below 85, the excess is subtracted.  With a value between 128 and 212, it is dibitized to 2, with the excess on either side of 170 distributed as before.  Finally, with a value between 213 and 255, it is dibitized to 3, with the excess below 255 subtracted from the neighbors.  We always truncate to 0 or 255. The details can be seen in the lookup table generation. This function differs from straight dithering in that it allows clipping of grayscale to 0 or 255 if the values are sufficiently close, without distribution of the excess. This uses default values from pix.h to specify the range of lower and upper values near 0 and 255, rsp that are clipped to black and white without propagating the excess. Not propagating the excess has the effect of reducing the snake patterns in parts of the image that are nearly black or white; however, it also prevents any attempt to reproduce gray for those values. The implementation uses 3 lookup tables for simplicity, and a pair of line buffers to avoid modifying pixs.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDitherTo2bppSpec(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See comments above in pixDitherTo2bpp() for details.
 (2) The input parameters lowerclip and upperclip specify the range
 of lower and upper values (near 0 and 255, rsp) that are
 clipped to black and white without propagating the excess.
 For that reason, lowerclip and upperclip should be small numbers.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="lowerclip">lower clip distance to black; use 0 for default</param>
	<param name="upperclip">upper clip distance to white; use 0 for default</param>
	<param name="cmapflag">1 to generate a colormap</param>
	<returns>pixd dithered 2 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixThresholdTo2bpp(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Valid values for nlevels is the set {2, 3, 4}.
 (2) Any colormap on the input pixs is removed to 8 bpp grayscale.
 (3) This function is typically invoked with cmapflag == 1.
 In the situation where no colormap is desired, nlevels is
 ignored and pixs is thresholded to 4 levels.
 (4) The target output colors are equally spaced, with the
 darkest at 0 and the lightest at 255.  The thresholds are
 chosen halfway between adjacent output values.  A table
 is built that specifies the mapping from src to dest.
 (5) If cmapflag == 1, a colormap of size 'nlevels' is made,
 and the pixel values in pixs are replaced by their
 appropriate color indices.  The number of holdouts,
 4 - nlevels, will be between 0 and 2.
 (6) If you don't want the thresholding to be equally spaced,
 either first transform the 8 bpp src using pixGammaTRC().
 or, if cmapflag == 1, after calling this function you can use
 pixcmapResetColor() to change any individual colors.
 (7) If a colormap is generated, it will specify (to display
 programs) exactly how each level is to be represented in RGB
 space.  When representing text, 3 levels is far better than
 2 because of the antialiasing of the single gray level,
 and 4 levels (black, white and 2 gray levels) is getting
 close to the perceptual quality of a (nearly continuous)
 grayscale image.  With 2 bpp, you can set up a colormap
 and allocate from 2 to 4 levels to represent antialiased text.
 Any left over colormap entries can be used for coloring regions.
 For the same number of levels, the file size of a 2 bpp image
 is about 10% smaller than that of a 4 bpp result for the same
 number of levels.  For both 2 bpp and 4 bpp, using 4 levels you
 get compression far better than that of jpeg, because the
 quantization to 4 levels will remove the jpeg ringing in the
 background near character edges.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="nlevels">equally spaced; must be between 2 and 4</param>
	<param name="cmapflag">1 to build colormap; 0 otherwise</param>
	<returns>pixd 2 bpp, optionally with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixThresholdTo4bpp(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Valid values for nlevels is the set {2, ... 16}.
 (2) Any colormap on the input pixs is removed to 8 bpp grayscale.
 (3) This function is typically invoked with cmapflag == 1.
 In the situation where no colormap is desired, nlevels is
 ignored and pixs is thresholded to 16 levels.
 (4) The target output colors are equally spaced, with the
 darkest at 0 and the lightest at 255.  The thresholds are
 chosen halfway between adjacent output values.  A table
 is built that specifies the mapping from src to dest.
 (5) If cmapflag == 1, a colormap of size 'nlevels' is made,
 and the pixel values in pixs are replaced by their
 appropriate color indices.  The number of holdouts,
 16 - nlevels, will be between 0 and 14.
 (6) If you don't want the thresholding to be equally spaced,
 either first transform the 8 bpp src using pixGammaTRC().
 or, if cmapflag == 1, after calling this function you can use
 pixcmapResetColor() to change any individual colors.
 (7) If a colormap is generated, it will specify, to display
 programs, exactly how each level is to be represented in RGB
 space.  When representing text, 3 levels is far better than
 2 because of the antialiasing of the single gray level,
 and 4 levels (black, white and 2 gray levels) is getting
 close to the perceptual quality of a (nearly continuous)
 grayscale image.  Therefore, with 4 bpp, you can set up a
 colormap, allocate a relatively small fraction of the 16
 possible values to represent antialiased text, and use the
 other colormap entries for other things, such as coloring
 text or background.  Two other reasons for using a small number
 of gray values for antialiased text are (1) PNG compression
 gets worse as the number of levels that are used is increased,
 and (2) using a small number of levels will filter out most of
 the jpeg ringing that is typically introduced near sharp edges
 of text.  This filtering is partly responsible for the improved
 compression.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, can have colormap</param>
	<param name="nlevels">equally spaced; must be between 2 and 16</param>
	<param name="cmapflag">1 to build colormap; 0 otherwise</param>
	<returns>pixd 4 bpp, optionally with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixThresholdOn8bpp(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Valid values for nlevels is the set {2,...,256}.
 (2) Any colormap on the input pixs is removed to 8 bpp grayscale.
 (3) If cmapflag == 1, a colormap of size 'nlevels' is made,
 and the pixel values in pixs are replaced by their
 appropriate color indices.  Otherwise, the pixel values
 are the actual thresholded (i.e., quantized) grayscale values.
 (4) If you don't want the thresholding to be equally spaced,
 first transform the input 8 bpp src using pixGammaTRC().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, can have colormap</param>
	<param name="nlevels">equally spaced; must be between 2 and 256</param>
	<param name="cmapflag">1 to build colormap; 0 otherwise</param>
	<returns>pixd 8 bpp, optionally with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixThresholdGrayArb(LeptonicaSharp.Pix,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This function allows exact specification of the quantization bins.
 The string %edgevals is a space-separated set of values
 specifying the dividing points between output quantization bins.
 These threshold values are assigned to the bin with higher
 values, so that each of them is the smallest value in their bin.
 (2) The output image (pixd) depth is specified by %outdepth.  The
 number of bins is the number of edgevals + 1.  The
 relation between outdepth and the number of bins is
 outdepth = 2 nbins LT= 4
 outdepth = 4 nbins LT= 16
 outdepth = 8 nbins LT= 256
 With %outdepth == 0, the minimum required depth for the
 given number of bins is used.
 The output pixd has a colormap.
 (3) The last 3 args determine the specific values that go into
 the colormap.
 (4) For %use_average
 ~ if TRUE, the average value of pixels falling in the bin is
 chosen as the representative gray value.  Otherwise,
 ~ if FALSE, the central value of each bin is chosen as
 the representative value.
 The colormap holds the representative value.
 (5) For %setblack, if TRUE the darkest color is set to (0,0,0).
 (6) For %setwhite, if TRUE the lightest color is set to (255,255,255).
 (7) An alternative to using this function to quantize to
 unequally-spaced bins is to first transform the 8 bpp pixs
 using pixGammaTRC(), and follow this with pixThresholdTo4bpp().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale; can have colormap</param>
	<param name="edgevals">string giving edge value of each bin</param>
	<param name="outdepth">0, 2, 4 or 8 bpp; 0 is default for min depth</param>
	<param name="use_average">1 if use the average pixel value in colormap</param>
	<param name="setblack">1 if darkest color is set to black</param>
	<param name="setwhite">1 if lightest color is set to white</param>
	<returns>pixd 2, 4 or 8 bpp quantized image with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeGrayQuantIndexTable(System.Int32)">
	<summary>
 Notes
 (1) 'nlevels' is some number between 2 and 256 (typically 8 or less).
 (2) The table is typically used for quantizing 2, 4 and 8 bpp
 grayscale src pix, and generating a colormapped dest pix.
 </summary>
	<remarks>
	</remarks>
	<param name="nlevels">number of output levels</param>
	<returns>table maps input gray level to colormap index, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeGrayQuantTableArb(LeptonicaSharp.Numa,System.Int32,System.Collections.Generic.List{System.Int32[]}@,LeptonicaSharp.PixColormap@)">
	<summary>
 Notes
 (1) The number of bins is the count of %na + 1.
 (2) The bin boundaries in na must be sorted in increasing order.
 (3) The table is an inverse colormap it maps input gray level
 to colormap index (the bin number).
 (4) The colormap generated here has quantized values at the
 center of each bin.  If you want to use the average gray
 value of pixels within the bin, discard the colormap and
 compute it using makeGrayQuantColormapArb().
 (5) Returns an error if there are not enough levels in the
 output colormap for the number of bins.  The number
 of bins must not exceed 2^outdepth.
 </summary>
	<remarks>
	</remarks>
	<param name="na">numa of bin boundaries</param>
	<param name="outdepth">of colormap 1, 2, 4 or 8</param>
	<param name="ptab">table mapping input gray level to cmap index</param>
	<param name="pcmap">colormap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenerateMaskByBand32(LeptonicaSharp.Pix,System.UInt32,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) Generates a 1 bpp mask pixd, the same size as pixs, where
 the fg pixels in the mask within a band of rgb values
 surrounding %refval.  The band can be chosen in two ways
 for each component
 (a) Use (%delm, %delp) to specify how many levels down and up
 (b) Use (%fractm, %fractp) to specify the fractional
 distance toward 0 and 255, respectively.
 Note that %delm and %delp must be in [0 ... 255], whereas
 %fractm and %fractp must be in [0.0 - 1.0].
 (2) Either (%delm, %delp) or (%fractm, %fractp) can be used.
 Set each value in the other pair to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="refval">reference rgb value</param>
	<param name="delm">max amount below the ref value for any component</param>
	<param name="delp">max amount above the ref value for any component</param>
	<param name="fractm">fractional amount below ref value for all components</param>
	<param name="fractp">fractional amount above ref value for all components</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenerateMaskByDiscr32(LeptonicaSharp.Pix,System.UInt32,System.UInt32,LeptonicaSharp.Enumerations.L_AN_DISTANCE)">
	<summary>
 Notes
 (1) Generates a 1 bpp mask pixd, the same size as pixs, where
 the fg pixels in the mask are those where the pixel in pixs
 is "closer" to refval1 than to refval2.
 (2) "Closer" can be defined in several ways, such as
 ~ manhattan distance (L1)
 ~ euclidean distance (L2)
 ~ majority vote of the individual components
 Here, we have a choice of L1 or L2.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="refval1">reference rgb value</param>
	<param name="refval2">reference rgb value</param>
	<param name="distflag">L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGrayQuantFromHisto(LeptonicaSharp.Pix,System.Single,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is useful for quantizing images with relatively few
 colors, but which may have both color and gray pixels.
 If there are color pixels, it is assumed that an input
 rgb image has been color quantized first so that
 ~ pixd has a colormap describing the color pixels
 ~ pixm is a mask over the non-color pixels in pixd
 ~ the colormap in pixd, and the color pixels in pixd,
 have been repacked to go from 0 to n-1 (n colors)
 If there are no color pixels, pixd and pixm are both null,
 and all pixels in pixs are quantized to gray.
 (2) A 256-entry histogram is built of the gray values in pixs.
 If pixm exists, the pixels contributing to the histogram are
 restricted to the fg of pixm.  A colormap and LUT are generated
 from this histogram.  We break up the array into a set
 of intervals, each one constituting a color in the colormap
 An interval is identified by summing histogram bins until
 either the sum equals or exceeds the %minfract of the total
 number of pixels, or the span itself equals or exceeds %maxsize.
 The color of each bin is always an average of the pixels
 that constitute it.
 (3) Note that we do not specify the number of gray colors in
 the colormap.  Instead, we specify two parameters that
 describe the accuracy of the color assignments; this and
 the actual image determine the number of resulting colors.
 (4) If a mask exists and it is not the same size as pixs, make
 a new mask the same size as pixs, with the original mask
 aligned at the UL corners.  Set all additional pixels
 in the (larger) new mask set to 1, causing those pixels
 in pixd to be set as gray.
 (5) We estimate the total number of colors (color plus gray);
 if it exceeds 255, return null.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">quantized pix with cmap; can be null</param>
	<param name="pixs">8 bpp gray input pix; not cmapped</param>
	<param name="pixm">mask over pixels in pixs to quantize</param>
	<param name="minfract">minimum fraction of pixels in a set of adjacent histo bins that causes the set to be automatically set aside as a color in the colormap; must be at least 0.01</param>
	<param name="maxsize">maximum number of adjacent bins allowed to represent a color, regardless of the population of pixels in the bins; must be at least 2</param>
	<returns>pixd 8 bpp, cmapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGrayQuantFromCmap(LeptonicaSharp.Pix,LeptonicaSharp.PixColormap,System.Int32)">
	<summary>
 Notes
 (1) In use, pixs is an 8 bpp grayscale image without a colormap.
 If there is an existing colormap, a warning is issued and
 a copy of the input pixs is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale without cmap</param>
	<param name="cmap">to quantize to; of dest pix</param>
	<param name="mindepth">minimum depth of pixd can be 2, 4 or 8 bpp</param>
	<returns>pixd 2, 4 or 8 bpp, colormapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lheapCreate(System.Int32,LeptonicaSharp.Enumerations.L_SORT_CREASING)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nalloc">size of ptr array to be alloc'd 0 for default</param>
	<param name="direction">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<returns>lheap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lheapDestroy(LeptonicaSharp.L_Heap@,System.Int32)">
	<summary>
 Notes
 (1) Use freeflag == TRUE when the items in the array can be
 simply destroyed using free.  If those items require their
 own destroy function, they must be destroyed before
 calling this function, and then this function is called
 with freeflag == FALSE.
 (2) To destroy the lheap, we destroy the ptr array, then
 the lheap, and then null the contents of the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="plh">to be nulled</param>
	<param name="freeflag">TRUE to free each remaining struct in the array</param>
</member><member name="M:LeptonicaSharp._AllFunctions.lheapAdd(LeptonicaSharp.L_Heap,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lh">heap</param>
	<param name="item">to be added to the tail of the heap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lheapRemove(LeptonicaSharp.L_Heap)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lh">heap</param>
	<returns>ptr to item popped from the root of the heap, or NULL if the heap is empty or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lheapGetCount(LeptonicaSharp.L_Heap)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lh">heap</param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lheapSwapUp(LeptonicaSharp.L_Heap,System.Int32)">
	<summary>
 Notes
 (1) This is called after a new item is put on the heap, at the
 bottom of a complete tree.
 (2) To regain the heap order, we let it bubble up,
 iteratively swapping with its parent, until it either
 reaches the root of the heap or it finds a parent that
 is in the correct position already vis-a-vis the child.
 </summary>
	<remarks>
	</remarks>
	<param name="lh">heap</param>
	<param name="index">of array corresponding to node to be swapped up</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lheapSwapDown(LeptonicaSharp.L_Heap)">
	<summary>
 Notes
 (1) This is called after an item has been popped off the
 root of the heap, and the last item in the heap has
 been placed at the root.
 (2) To regain the heap order, we let it bubble down,
 iteratively swapping with one of its children.  For a
 decreasing sort, it swaps with the largest child; for
 an increasing sort, the smallest.  This continues until
 it either reaches the lowest level in the heap, or the
 parent finds that neither child should swap with it
 (e.g., for a decreasing heap, the parent is larger
 than or equal to both children).
 </summary>
	<remarks>
	</remarks>
	<param name="lh">heap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lheapSort(LeptonicaSharp.L_Heap)">
	<summary>
 Notes
 (1) This sorts an array into heap order.  If the heap is already
 in heap order for the direction given, this has no effect.
 </summary>
	<remarks>
	</remarks>
	<param name="lh">heap, with internal array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lheapSortStrictOrder(LeptonicaSharp.L_Heap)">
	<summary>
 Notes
 (1) This sorts a heap into strict order.
 (2) For each element, starting at the end of the array and
 working forward, the element is swapped with the head
 element and then allowed to swap down onto a heap of
 size reduced by one.  The result is that the heap is
 reversed but in strict order.  The array elements are
 then reversed to put it in the original order.
 </summary>
	<remarks>
	</remarks>
	<param name="lh">heap, with internal array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lheapPrint(LeptonicaSharp.FILE,LeptonicaSharp.L_Heap)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="lh">heap</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbRankHausInit(LeptonicaSharp.Enumerations.JB_S,System.Int32,System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<param name="maxwidth">of component; use 0 for default</param>
	<param name="maxheight">of component; use 0 for default</param>
	<param name="size">of square structuring element; 2, representing 2x2 sel, is necessary for reasonable accuracy of small components; combine this with rank ~ 0.97 to avoid undue class expansion</param>
	<param name="rank">rank val of match, each way; in [0.5 - 1.0]; when using size = 2, 0.97 is a reasonable value</param>
	<returns>jbclasser if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbCorrelationInit(LeptonicaSharp.Enumerations.JB_S,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) For scanned text, suggested input values are
 thresh ~ [0.8 - 0.85]
 weightfactor ~ [0.5 - 0.6]
 (2) For electronically generated fonts (e.g., rasterized pdf),
 a very high thresh (e.g., 0.95) will not cause a significant
 increase in the number of classes.
 </summary>
	<remarks>
	</remarks>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<param name="maxwidth">of component; use 0 for default</param>
	<param name="maxheight">of component; use 0 for default</param>
	<param name="thresh">value for correlation score in [0.4 - 0.98]</param>
	<param name="weightfactor">corrects thresh for thick characters [0.0 - 1.0]</param>
	<returns>jbclasser if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbCorrelationInitWithoutComponents(LeptonicaSharp.Enumerations.JB_S,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 Acts the same as jbCorrelationInit(), but the resulting
 object doesn't keep a list of all the components.
 </summary>
	<remarks>
	</remarks>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<param name="maxwidth">of component; use 0 for default</param>
	<param name="maxheight">of component; use 0 for default</param>
	<param name="thresh">value  for correlation score in [0.4 - 0.98]</param>
	<param name="weightfactor">corrects thresh for thick characters [0.0 - 1.0]</param>
	<returns>jbclasser if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbAddPages(LeptonicaSharp.JbClasser@,LeptonicaSharp.Sarray)">
	<summary>
 Notes
 (1) jbclasser makes a copy of the array of file names.
 (2) The caller is still responsible for destroying the input array.
 </summary>
	<remarks>
	</remarks>
	<param name="safiles">of page image file names</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbAddPage(LeptonicaSharp.JbClasser@,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">input page</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbAddPageComponents(LeptonicaSharp.JbClasser@,LeptonicaSharp.Pix,LeptonicaSharp.Boxa,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) If there are no components on the page, we don't require input
 of empty boxas or pixas, although that's the typical situation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input page</param>
	<param name="boxas">b.b. of components for this page</param>
	<param name="pixas">components for this page</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbClassifyRankHaus(LeptonicaSharp.JbClasser@,LeptonicaSharp.Boxa,LeptonicaSharp.Pixa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa">new components for classification</param>
	<param name="pixas">new components for classification</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixHaustest(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 We check first that the two pix are roughly
 the same size.  Only if they meet that criterion do
 we compare the bitmaps.  The Hausdorff is a 2-way
 check.  The centroid difference is used to align the two
 images to the nearest integer for each of the checks.
 These check that the dilated image of one contains
 ALL the pixels of the undilated image of the other.
 Checks are done in both direction.  A single pixel not
 contained in either direction results in failure of the test.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">new pix, not dilated</param>
	<param name="pix2">new pix, dilated</param>
	<param name="pix3">exemplar pix, not dilated</param>
	<param name="pix4">exemplar pix, dilated</param>
	<param name="delx">x comp of centroid difference</param>
	<param name="dely">y comp of centroid difference</param>
	<param name="maxdiffw">max width difference of pix1 and pix2</param>
	<param name="maxdiffh">max height difference of pix1 and pix2</param>
	<returns>0 FALSE) if no match, 1 (TRUE if the new pix is in the same class as the exemplar.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRankHaustest(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Int32[])">
	<summary>
 Notes
 We check first that the two pix are roughly
 the same size.  Only if they meet that criterion do
 we compare the bitmaps.  We convert the rank value to
 a number of pixels by multiplying the rank fraction by the number
 of pixels in the undilated image.  The Hausdorff is a 2-way
 check.  The centroid difference is used to align the two
 images to the nearest integer for each of the checks.
 The rank hausdorff checks that the dilated image of one
 contains the rank fraction of the pixels of the undilated
 image of the other.   Checks are done in both direction.
 Failure of the test in either direction results in failure
 of the test.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">new pix, not dilated</param>
	<param name="pix2">new pix, dilated</param>
	<param name="pix3">exemplar pix, not dilated</param>
	<param name="pix4">exemplar pix, dilated</param>
	<param name="delx">x comp of centroid difference</param>
	<param name="dely">y comp of centroid difference</param>
	<param name="maxdiffw">max width difference of pix1 and pix2</param>
	<param name="maxdiffh">max height difference of pix1 and pix2</param>
	<param name="area1">fg pixels in pix1</param>
	<param name="area3">fg pixels in pix3</param>
	<param name="rank">rank value of test, each way</param>
	<param name="tab8">table of pixel sums for byte</param>
	<returns>0 FALSE) if no match, 1 (TRUE if the new pix is in the same class as the exemplar.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbClassifyCorrelation(LeptonicaSharp.JbClasser@,LeptonicaSharp.Boxa,LeptonicaSharp.Pixa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="boxa">new components for classification</param>
	<param name="pixas">new components for classification</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbGetComponents(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.JB_S,System.Int32,System.Int32,LeptonicaSharp.Boxa@,LeptonicaSharp.Pixa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<param name="maxwidth">of saved components; larger are discarded</param>
	<param name="maxheight">of saved components; larger are discarded</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWordMaskByDilation(LeptonicaSharp.Pix,LeptonicaSharp.Pix@,System.Int32@,LeptonicaSharp.Pixa@)">
	<summary>
 Notes
 (1) This gives an estimate of the word masks.  See
 pixWordBoxesByDilation() for further filtering of the word boxes.
 (2) The resolution should be between 75 and 150 ppi, and the optimal
 dilation will be between 3 and 10.
 (3) A good size for dilating to get word masks is optionally returned.
 (4) Typically, the number of c.c. reduced with each successive
 dilation (stored in nadiff) decreases quickly to a minimum
 (where the characters in a word are joined), and then
 increases again as the smaller number of words are joined.
 For the typical case, you can then look for this minimum
 and dilate to get the word mask.  However, there are many
 cases where the function is not so simple. For example, if the
 pix has been upscaled 2x, the nadiff function oscillates, with
 every other value being zero!  And for some images it tails
 off without a clear minimum to indicate where to break.
 So a more simple and robust method is to find the dilation
 where the initial number of c.c. has been reduced by some
 fraction (we use a 70% reduction).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp; typ. at 75 to 150 ppi</param>
	<param name="psize">size of good horizontal dilation</param>
	<param name="pixadb">debug pixa of intermediate steps</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWordBoxesByDilation(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Boxa@,System.Int32@,LeptonicaSharp.Pixa@)">
	<summary>
 Notes
 (1) Returns a pruned set of word boxes.
 (2) See pixWordMaskByDilation().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp; typ. 75 - 200 ppi</param>
	<param name="minwidth">saved components; smaller are discarded</param>
	<param name="minheight">saved components; smaller are discarded</param>
	<param name="maxwidth">saved components; larger are discarded</param>
	<param name="maxheight">saved components; larger are discarded</param>
	<param name="pboxa">of dilated word mask</param>
	<param name="psize">size of good horizontal dilation</param>
	<param name="pixadb">debug pixa of intermediate steps</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbAccumulateComposites(LeptonicaSharp.Pixaa,LeptonicaSharp.Numa@,LeptonicaSharp.Pta@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixaa">one pixa for each class</param>
	<param name="pptat">centroids of bordered composites</param>
	<returns>pixad accumulated sum of samples in each class, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbTemplatesFromComposites(LeptonicaSharp.Pixa,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixac">one pix of composites for each class</param>
	<param name="na">number of samples used for each class composite</param>
	<returns>pixad 8 bpp templates for each class, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbClasserCreate(LeptonicaSharp.Enumerations.JB,LeptonicaSharp.Enumerations.JB_S)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="method">JB_RANKHAUS, JB_CORRELATION</param>
	<param name="components">JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS</param>
	<returns>jbclasser, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbClasserDestroy(LeptonicaSharp.JbClasser@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.jbDataSave(LeptonicaSharp.JbClasser@)">
	<summary>
 Notes
 (1) This routine stores the jbig2-type data required for
 generating a lossy jbig2 version of the image.
 It can be losslessly written to (and read from) two files.
 (2) It generates and stores the mosaic of templates.
 (3) It clones the Numa and Pta arrays, so these must all
 be destroyed by the caller.
 (4) Input 0 to use the default values for latticew and/or latticeh,
 </summary>
	<remarks>
	</remarks>
	<returns>jbdata, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbDataDestroy(LeptonicaSharp.JbData@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.jbDataWrite(System.String@,LeptonicaSharp.JbData)">
	<summary>
 Notes
 (1) Serialization function that writes data in jbdata to file.
 </summary>
	<remarks>
	</remarks>
	<param name="jbdata"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbDataRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="rootname">for template and data files</param>
	<returns>jbdata, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbDataRender(LeptonicaSharp.JbData@,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="debugflag">if TRUE, writes into 2 bpp pix and adds component outlines in color</param>
	<returns>pixa reconstruction of original images, using templates or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbGetULCorners(LeptonicaSharp.JbClasser@,LeptonicaSharp.Pix,LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) This computes the ptaul field, which has the global UL corners,
 adjusted for each specific component, so that each component
 can be replaced by the template for its class and have the
 centroid in the template in the same position as the
 centroid of the original connected component.  It is important
 that this be done properly to avoid a wavy baseline in the
 result.
 (2) The array fields ptac and ptact give the centroids of
 those components relative to the UL corner of each component.
 Here, we compute the difference in each component, round to
 nearest integer, and correct the box-GTx and box-GTy by
 the appropriate integral difference.
 (3) The templates and stored instances are all bordered.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">full res image</param>
	<param name="boxa">of c.c. bounding rectangles for this page</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.jbGetLLCorners(LeptonicaSharp.JbClasser@)">
	<summary>
 Notes
 (1) This computes the ptall field, which has the global LL corners,
 adjusted for each specific component, so that each component
 can be replaced by the template for its class and have the
 centroid in the template in the same position as the
 centroid of the original connected component. It is important
 that this be done properly to avoid a wavy baseline in the result.
 (2) It is computed here from the corresponding UL corners, where
 the input templates and stored instances are all bordered.
 This should be done after all pages have been processed.
 (3) For proper substitution, the templates whose LL corners are
 placed in these locations must be UN-bordered.
 This is available for a realistic jbig2 encoder, which would
 (1) encode each template without a border, and (2) encode
 the position using the LL corner (rather than the UL
 corner) because the difference between y-values
 of successive instances is typically close to zero.
 </summary>
	<remarks>
	</remarks>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readHeaderJp2k(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.freadHeaderJp2k(LeptonicaSharp.FILE,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for read</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readHeaderMemJp2k(System.Byte[],System.UInt32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The ISO/IEC reference for jpeg2000 is
 http//www.jpeg.org/public/15444-1annexi.pdf
 and the file format syntax begins at page 127.
 (2) The Image Header Box begins with 'ihdr' = 0x69686472 in
 big-endian order.  This typically, but not always, starts
 byte 44, with the big-endian data fields beginning at byte 48
 h 4 bytes
 w 4 bytes
 spp  2 bytes
 bps  1 byte   (contains bps - 1)
 </summary>
	<remarks>
	</remarks>
	<param name="data"></param>
	<param name="size">at least 80</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fgetJp2kResolution(LeptonicaSharp.FILE@,System.Object@,System.Object@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadJp2k(System.String@,System.UInt32@,LeptonicaSharp.Box@,System.Int32@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadStreamJp2k(LeptonicaSharp.FILE@,System.UInt32@,LeptonicaSharp.Box@,System.Int32@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteJp2k(System.String@,LeptonicaSharp.Pix@,System.Int32@,System.Int32@,System.Int32@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamJp2k(LeptonicaSharp.FILE@,LeptonicaSharp.Pix@,System.Int32@,System.Int32@,System.Int32@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadMemJp2k(System.Byte[]@,System.UInt32@,System.UInt32@,LeptonicaSharp.Box@,System.Int32@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMemJp2k(System.Object@,System.Object@,LeptonicaSharp.Pix@,System.Int32@,System.Int32@,System.Int32@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadJpeg(System.String,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This is a special function for reading jpeg files.
 (2) Use this if you want the jpeg library to create
 an 8 bpp colormapped image.
 (3) Images reduced by factors of 2, 4 or 8 can be returned
 significantly faster than full resolution images.
 (4) If the jpeg data is bad, the jpeg library will continue
 silently, or return warnings, or attempt to exit.  Depending
 on the severity of the data corruption, there are two possible
 outcomes
 (a) a possibly damaged pix can be generated, along with zero
 or more warnings, or
 (b) the library will attempt to exit (caught by our error
 handler) and no pix will be returned.
 If a pix is generated with at least one warning of data
 corruption, and if L_JPEG_FAIL_ON_BAD_DATA is included in %hint,
 no pix will be returned.
 (5) The possible hint values are given in the enum in imageio.h
 L_JPEG_READ_LUMINANCE
 L_JPEG_FAIL_ON_BAD_DATA
 Default (0) is to do neither.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="cmapflag">0 for no colormap in returned pix; 1 to return an 8 bpp cmapped pix if spp = 3 or 4</param>
	<param name="reduction">scaling factor 1, 2, 4 or 8</param>
	<param name="pnwarn">number of warnings about corrupted data</param>
	<param name="hint">a bitwise OR of L_JPEG_ values; 0 for default</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadStreamJpeg(LeptonicaSharp.FILE,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The jpeg comment, if it exists, is not stored in the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="cmapflag">0 for no colormap in returned pix; 1 to return an 8 bpp cmapped pix if spp = 3 or 4</param>
	<param name="reduction">scaling factor 1, 2, 4 or 8</param>
	<param name="pnwarn">number of warnings</param>
	<param name="hint">a bitwise OR of L_JPEG_ values; 0 for default</param>
	<returns>pix, or NULL on error Usage see pixReadJpeg</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readHeaderJpeg(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pspp">samples/pixel</param>
	<param name="pycck">1 if ycck color space; 0 otherwise</param>
	<param name="pcmyk">1 if cmyk color space; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.freadHeaderJpeg(LeptonicaSharp.FILE,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pspp">samples/pixel</param>
	<param name="pycck">1 if ycck color space; 0 otherwise</param>
	<param name="pcmyk">1 if cmyk color space; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fgetJpegResolution(LeptonicaSharp.FILE@,System.Object@,System.Object@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fgetJpegComment(LeptonicaSharp.FILE@,System.Object@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteJpeg(System.String,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pix">any depth; cmap is OK</param>
	<param name="quality">1 - 100; 75 is default</param>
	<param name="progressive">0 for baseline sequential; 1 for progressive</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamJpeg(LeptonicaSharp.FILE,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Progressive encoding gives better compression, at the
 expense of slower encoding and decoding.
 (2) Standard chroma subsampling is 2x2 on both the U and V
 channels.  For highest quality, use no subsampling; this
 option is set by pixSetChromaSampling(pix, 0).
 (3) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16
 and 32 bpp.  However, it is possible, and in some cases desirable,
 to write out a jpeg file using an rgb pix that has 24 bpp.
 This can be created by appending the raster data for a 24 bpp
 image (with proper scanline padding) directly to a 24 bpp
 pix that was created without a data array.
 (4) There are two compression paths in this function
 Grayscale image, no colormap compress as 8 bpp image.
 rgb full color image copy each line into the color
 line buffer, and compress as three 8 bpp images.
 (5) Under the covers, the jpeg library transforms rgb to a
 luminance-chromaticity triple, each component of which is
 also 8 bits, and compresses that.  It uses 2 Huffman tables,
 a higher resolution one (with more quantization levels)
 for luminosity and a lower resolution one for the chromas.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pixs">any depth; cmap is OK</param>
	<param name="quality">1 - 100; 75 is default value; 0 is also default</param>
	<param name="progressive">0 for baseline sequential; 1 for progressive</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadMemJpeg(System.Byte[],System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) The %size byte of %data must be a null character.
 (2) The only hint flag so far is L_JPEG_READ_LUMINANCE,
 given in the enum in imageio.h.
 (3) See pixReadJpeg() for usage.
 </summary>
	<remarks>
	</remarks>
	<param name="data">const; jpeg-encoded</param>
	<param name="size">of data</param>
	<param name="cmflag">colormap flag 0 means return RGB image if color; 1 means create a colormap and return an 8 bpp colormapped image if color</param>
	<param name="reduction">scaling factor 1, 2, 4 or 8</param>
	<param name="pnwarn">number of warnings</param>
	<param name="hint">a bitwise OR of L_JPEG_ values; 0 for default</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readHeaderMemJpeg(System.Byte[],System.UInt32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">const; jpeg-encoded</param>
	<param name="size">of data</param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<param name="pspp">samples/pixel</param>
	<param name="pycck">1 if ycck color space; 0 otherwise</param>
	<param name="pcmyk">1 if cmyk color space; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readResolutionMemJpeg(System.Byte[],System.UInt32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">const; jpeg-encoded</param>
	<param name="size">of data</param>
	<param name="pxres"></param>
	<param name="pyres"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMemJpeg(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixWriteStreamJpeg() for usage.  This version writes to
 memory instead of to a file stream.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of jpeg compressed image</param>
	<param name="psize">size of returned data</param>
	<param name="pix">any depth; cmap is OK</param>
	<param name="quality">1 - 100; 75 is default value; 0 is also default</param>
	<param name="progressive">0 for baseline sequential; 1 for progressive</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetChromaSampling(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) The default is for 2x2 chroma subsampling because the files are
 considerably smaller and the appearance is typically satisfactory.
 To get full resolution output in the chroma channels for
 jpeg writing, call this with %sampling == 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="sampling">1 for subsampling; 0 for no subsampling</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelCreate(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) kernelCreate() initializes all values to 0.
 (2) After this call, (cy,cx) and nonzero data values must be
 assigned.
 (2) The number of kernel elements must be less than 2^29.
 </summary>
	<remarks>
	</remarks>
	<param name="height"></param>
	<param name="width"></param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelDestroy(LeptonicaSharp.L_Kernel@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pkel">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelCopy(LeptonicaSharp.L_Kernel)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kels">source kernel</param>
	<returns>keld copy of kels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelGetElement(LeptonicaSharp.L_Kernel,System.Int32,System.Int32,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kel"></param>
	<param name="row"></param>
	<param name="col"></param>
	<param name="pval"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelSetElement(LeptonicaSharp.L_Kernel,System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kel">kernel</param>
	<param name="row"></param>
	<param name="col"></param>
	<param name="val"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelGetParameters(LeptonicaSharp.L_Kernel,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kel">kernel</param>
	<param name="psy">each can be null</param>
	<param name="psx">each can be null</param>
	<param name="pcy">each can be null</param>
	<param name="pcx">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelSetOrigin(LeptonicaSharp.L_Kernel,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kel">kernel</param>
	<param name="cy"></param>
	<param name="cx"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelGetSum(LeptonicaSharp.L_Kernel,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kel">kernel</param>
	<param name="psum">sum of all kernel values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelGetMinMax(LeptonicaSharp.L_Kernel,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="kel">kernel</param>
	<param name="pmin">minimum value</param>
	<param name="pmax">maximum value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelNormalize(LeptonicaSharp.L_Kernel,System.Single)">
	<summary>
 Notes
 (1) If the sum of kernel elements is close to 0, do not
 try to calculate the normalized kernel.  Instead,
 return a copy of the input kernel, with a warning.
 </summary>
	<remarks>
	</remarks>
	<param name="kels">source kel, to be normalized</param>
	<param name="normsum">desired sum of elements in keld</param>
	<returns>keld normalized version of kels, or NULL on error or if sum of elements is very close to 0)</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelInvert(LeptonicaSharp.L_Kernel)">
	<summary>
 Notes
 (1) For convolution, the kernel is spatially inverted before
 a "correlation" operation is done between the kernel and the image.
 </summary>
	<remarks>
	</remarks>
	<param name="kels">source kel, to be inverted</param>
	<returns>keld spatially inverted, about the origin, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.create2dFloatArray(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The array[sy][sx] is indexed in standard "matrix notation",
 with the row index first.
 (2) The caller kernelCreate() limits the size to LT 2^29 pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="sy">rows == height</param>
	<param name="sx">columns == width</param>
	<returns>doubly indexed array i.e., an array of sy row pointers, each of which points to an array of sx floats</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">filename</param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelWrite(System.String,LeptonicaSharp.L_Kernel)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">output file</param>
	<param name="kel">kernel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.L_Kernel)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="kel"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelCreateFromString(System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) The data is an array of chars, in row-major order, giving
 space separated integers in the range [-255 ... 255].
 (2) The only other formatting limitation is that you must
 leave space between the last number in each row and
 the double-quote.  If possible, it's also nice to have each
 line in the string represent a line in the kernel; e.g.,
 static const char kdata =
 " 20   50   20 "
 " 70  140   70 "
 " 20   50   20 ";
 </summary>
	<remarks>
	</remarks>
	<param name="h">height, width</param>
	<param name="w">height, width</param>
	<param name="cy">origin</param>
	<param name="cx">origin</param>
	<param name="kdata"></param>
	<returns>kernel of the given size, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelCreateFromFile(System.String)">
	<summary>
 Notes
 (1) The file contains, in the following order
 ~ Any number of comment lines starting with '#' are ignored
 ~ The height and width of the kernel
 ~ The y and x values of the kernel origin
 ~ The kernel data, formatted as lines of numbers (integers
 or floats) for the kernel values in row-major order,
 and with no other punctuation.
 (Note this differs from kernelCreateFromString(),
 where each line must begin and end with a double-quote
 to tell the compiler it's part of a string.)
 ~ The kernel specification ends when a blank line,
 a comment line, or the end of file is reached.
 (2) All lines must be left-justified.
 (3) See kernelCreateFromString() for a description of the string
 format for the kernel data.  As an example, here are the lines
 of a valid kernel description file  In the file, all lines
 are left-justified
 \code
 # small 3x3 kernel
 3 3
 1 1
 25.5   51 24.3
 70.2  146.3  73.4
 20  50.9  18.4
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelCreateFromPix(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The origin must be positive and within the dimensions of the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="cy">origin of kernel</param>
	<param name="cx">origin of kernel</param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.kernelDisplayInPix(LeptonicaSharp.L_Kernel,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This gives a visual representation of a kernel.
 (2) There are two modes of display
 (a) Grid lines of minimum width 2, surrounding regions
 representing kernel elements of minimum size 17,
 with a "plus" mark at the kernel origin, or
 (b) A pix without grid lines and using 1 pixel per kernel element.
 (3) For both cases, the kernel absolute value is displayed,
 normalized such that the maximum absolute value is 255.
 (4) Large 2D separable kernels should be used for convolution
 with two 1D kernels.  However, for the bilateral filter,
 the computation time is independent of the size of the
 2D content kernel.
 </summary>
	<remarks>
	</remarks>
	<param name="kel">kernel</param>
	<param name="size">of grid interiors; odd; either 1 or a minimum size of 17 is enforced</param>
	<param name="gthick">grid thickness; either 0 or a minimum size of 2 is enforced</param>
	<returns>pix display of kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.parseStringForNumbers(System.String,System.String)">
	<summary>
 Notes
 (1) The numbers can be ints or floats.
 </summary>
	<remarks>
	</remarks>
	<param name="str">string containing numbers; not changed</param>
	<param name="seps">string of characters that can be used between ints</param>
	<returns>numa of numbers found, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeFlatKernel(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is the same low-pass filtering kernel that is used
 in the block convolution functions.
 (2) The kernel origin (%cy, %cx) is typically placed as near
 the center of the kernel as possible.  If height and
 width are odd, then using cy = height / 2 and
 cx = width / 2 places the origin at the exact center.
 (3) This returns a normalized kernel.
 </summary>
	<remarks>
	</remarks>
	<param name="height"></param>
	<param name="width"></param>
	<param name="cy">origin of kernel</param>
	<param name="cx">origin of kernel</param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeGaussianKernel(System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) The kernel size (sx, sy) = (2  halfwidth + 1, 2  halfheight + 1).
 (2) The kernel center (cx, cy) = (halfwidth, halfheight).
 (3) The halfwidth and halfheight are typically equal, and
 are typically several times larger than the standard deviation.
 (4) If pixConvolve() is invoked with normalization (the sum of
 kernel elements = 1.0), use 1.0 for max (or any number that's
 not too small or too large).
 </summary>
	<remarks>
	</remarks>
	<param name="halfheight">sx = 2  halfwidth + 1, etc</param>
	<param name="halfwidth">sx = 2  halfwidth + 1, etc</param>
	<param name="stdev">standard deviation</param>
	<param name="max">value at (cx,cy)</param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeGaussianKernelSep(System.Int32,System.Int32,System.Single,System.Single,LeptonicaSharp.L_Kernel@,LeptonicaSharp.L_Kernel@)">
	<summary>
 Notes
 (1) See makeGaussianKernel() for description of input parameters.
 (2) These kernels are constructed so that the result of both
 normalized and un-normalized convolution will be the same
 as when convolving with pixConvolve() using the full kernel.
 (3) The trick for the un-normalized convolution is to have the
 product of the two kernel elemets at (cx,cy) be equal to max,
 not max2.  That's why the max for kely is 1.0.  If instead
 we use sqrt(max) for both, the results are slightly less
 accurate, when compared to using the full kernel in
 makeGaussianKernel().
 </summary>
	<remarks>
	</remarks>
	<param name="halfheight">sx = 2  halfwidth + 1, etc</param>
	<param name="halfwidth">sx = 2  halfwidth + 1, etc</param>
	<param name="stdev">standard deviation</param>
	<param name="max">value at (cx,cy)</param>
	<param name="pkelx">x part of kernel</param>
	<param name="pkely">y part of kernel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeDoGKernel(System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) The DoG (difference of gaussians) is a wavelet mother
 function with null total sum.  By subtracting two blurred
 versions of the image, it acts as a bandpass filter for
 frequencies passed by the narrow gaussian but stopped
 by the wide one.See
 http//en.wikipedia.org/wiki/Difference_of_Gaussians
 (2) The kernel size (sx, sy) = (2  halfwidth + 1, 2  halfheight + 1).
 (3) The kernel center (cx, cy) = (halfwidth, halfheight).
 (4) The halfwidth and halfheight are typically equal, and
 are typically several times larger than the standard deviation.
 (5) The ratio is the ratio of standard deviations of the wide
 to narrow gaussian.  It must be GT= 1.0; 1.0 is a no-op.
 (6) Because the kernel is a null sum, it must be invoked without
 normalization in pixConvolve().
 </summary>
	<remarks>
	</remarks>
	<param name="halfheight">sx = 2  halfwidth + 1, etc</param>
	<param name="halfwidth">sx = 2  halfwidth + 1, etc</param>
	<param name="stdev">standard deviation of narrower gaussian</param>
	<param name="ratio">of stdev for wide filter to stdev for narrow one</param>
	<returns>kernel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetWindowsHBITMAP(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) It's the responsibility of the caller to destroy the
 returned hBitmap with a call to DeleteObject (or with
 something that eventually calls DeleteObject).
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>Windows hBitmap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getImagelibVersions">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.listDestroy(LeptonicaSharp.DoubleLinkedList@)">
	<summary>
 Notes
 (1) This only destroys the cons cells.  Before destroying
 the list, it is necessary to remove all data and set the
 data pointers in each cons cell to NULL.
 (2) listDestroy() will give a warning message for each data
 ptr that is not NULL.
 </summary>
	<remarks>
	</remarks>
	<param name="phead">to be nulled; head of list</param>
</member><member name="M:LeptonicaSharp._AllFunctions.listAddToHead(System.Object,LeptonicaSharp.DoubleLinkedList@)">
	<summary>
 Notes
 (1) This makes a new cell, attaches the data, and adds the
 cell to the head of the list.
 (2) When consing from NULL, be sure to initialize head to NULL
 before calling this function.
 </summary>
	<remarks>
	</remarks>
	<param name="phead">input head</param>
	<param name="data">void ptr, to be added</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.listAddToTail(LeptonicaSharp.DoubleLinkedList@,LeptonicaSharp.DoubleLinkedList@,System.Object)">
	<summary>
 Notes
 (1) This makes a new cell, attaches the data, and adds the
 cell to the tail of the list.
 (2) head is input to allow the list to be "cons'd" up from NULL.
 (3) tail is input to allow the tail to be updated
 for efficient sequential operation with this function.
 (4) We assume that if phead and/or ptail are not NULL,
 then they are valid addresses.  Therefore
 (a) when consing from NULL, be sure to initialize both
 head and tail to NULL.
 (b) when tail == NULL for an existing list, the tail
 will be found and updated.
 </summary>
	<remarks>
	</remarks>
	<param name="phead">[may be updated], can be NULL</param>
	<param name="ptail">[updated], can be NULL</param>
	<param name="data">void ptr, to be hung on tail cons cell</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.listInsertBefore(LeptonicaSharp.DoubleLinkedList,System.Object,LeptonicaSharp.DoubleLinkedList@)">
	<summary>
 Notes
 (1) This can be called on a null list, in which case both
 head and elem must be null.
 (2) If you are searching through a list, looking for a condition
 to add an element, you can do something like this
 \code
 L_BEGIN_LIST_FORWARD(head, elem)
 LTidentify an elem to insert beforeGT
 listInsertBefore(head, elem, data);
 L_END_LIST
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="phead">input head</param>
	<param name="elem">list element to be inserted in front of; must be NULL if head is NULL</param>
	<param name="data">void  address, to be added</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.listInsertAfter(LeptonicaSharp.DoubleLinkedList,System.Object,LeptonicaSharp.DoubleLinkedList@)">
	<summary>
 Notes
 (1) This can be called on a null list, in which case both
 head and elem must be null.  The head is included
 in the call to allow "consing" up from NULL.
 (2) If you are searching through a list, looking for a condition
 to add an element, you can do something like this
 \code
 L_BEGIN_LIST_FORWARD(head, elem)
 LTidentify an elem to insert afterGT
 listInsertAfter(head, elem, data);
 L_END_LIST
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="phead">input head</param>
	<param name="elem">list element to be inserted after; must be NULL if head is NULL</param>
	<param name="data">void  ptr, to be added</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.listRemoveElement(LeptonicaSharp.DoubleLinkedList@,LeptonicaSharp.DoubleLinkedList)">
	<summary>
 Notes
 (1) in ANSI C, it is not necessary to cast return to actual type; e.g.,
 pix = listRemoveElement(head, elem);
 but in ANSI C++, it is necessary to do the cast
 pix = (Pix )listRemoveElement(head, elem);
 </summary>
	<remarks>
	</remarks>
	<param name="phead">[can be changed] input head</param>
	<param name="elem">list element to be removed</param>
	<returns>data  void struct on cell</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.listRemoveFromHead(LeptonicaSharp.DoubleLinkedList@)">
	<summary>
 Notes
 (1) in ANSI C, it is not necessary to cast return to actual type; e.g.,
 pix = listRemoveFromHead(head);
 but in ANSI C++, it is necessary to do the cast; e.g.,
 pix = (Pix )listRemoveFromHead(head);
 </summary>
	<remarks>
	</remarks>
	<param name="phead">head of list [to be updated]</param>
	<returns>data  void struct on cell, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.listRemoveFromTail(LeptonicaSharp.DoubleLinkedList@,LeptonicaSharp.DoubleLinkedList@)">
	<summary>
 Notes
 (1) We include head so that it can be set to NULL if
 if the only element in the list is removed.
 (2) The function is relying on the fact that if tail is
 not NULL, then is is a valid address.  You can use
 this function with tail == NULL for an existing list, in
 which case  the tail is found and updated, and the
 removed element is returned.
 (3) In ANSI C, it is not necessary to cast return to actual type; e.g.,
 pix = listRemoveFromTail(head, tail);
 but in ANSI C++, it is necessary to do the cast; e.g.,
 pix = (Pix )listRemoveFromTail(head, tail);
 </summary>
	<remarks>
	</remarks>
	<param name="phead">[may be changed], head must NOT be NULL</param>
	<param name="ptail">[always updated], tail may be NULL</param>
	<returns>data  void struct on cell or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.listFindElement(LeptonicaSharp.DoubleLinkedList,System.Object)">
	<summary>
 Notes
 (1) This returns a ptr to the cell, which is still embedded in
 the list.
 (2) This handle and the attached data have not been copied or
 reference counted, so they must not be destroyed.  This
 violates our basic rule that every handle returned from a
 function is owned by that function and must be destroyed,
 but if rules aren't there to be broken, why have them?
 </summary>
	<remarks>
	</remarks>
	<param name="head">list head</param>
	<param name="data">void  address, to be searched for</param>
	<returns>cell  the containing cell, or NULL if not found or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.listFindTail(LeptonicaSharp.DoubleLinkedList)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="head"></param>
	<returns>tail, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.listGetCount(LeptonicaSharp.DoubleLinkedList)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="head">of list</param>
	<returns>number of elements; 0 if no list or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.listReverse(LeptonicaSharp.DoubleLinkedList@)">
	<summary>
 Notes
 (1) This reverses the list in-place.
 </summary>
	<remarks>
	</remarks>
	<param name="phead">[may be changed] list head</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.listJoin(LeptonicaSharp.DoubleLinkedList@,LeptonicaSharp.DoubleLinkedList@)">
	<summary>
 Notes
 (1) The concatenated list is returned with head1 as the new head.
 (2) Both input ptrs must exist, though either can have the value NULL.
 </summary>
	<remarks>
	</remarks>
	<param name="phead1">[may be changed] head of first list</param>
	<param name="phead2">to be nulled; head of second list</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_amapCreate(System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_amapFind(LeptonicaSharp.L_Rbtree@,LeptonicaSharp.Rb_Type@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_amapInsert(LeptonicaSharp.L_Rbtree@,LeptonicaSharp.Rb_Type@,LeptonicaSharp.Rb_Type@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.l_amapDelete(LeptonicaSharp.L_Rbtree@,LeptonicaSharp.Rb_Type@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.l_amapDestroy(LeptonicaSharp.L_Rbtree@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.l_amapGetFirst(LeptonicaSharp.L_Rbtree@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_amapGetNext(LeptonicaSharp.L_Rbtree_Node@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_amapGetLast(LeptonicaSharp.L_Rbtree@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_amapGetPrev(LeptonicaSharp.L_Rbtree_Node@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_amapSize(LeptonicaSharp.L_Rbtree@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_asetCreate(System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_asetFind(LeptonicaSharp.L_Rbtree@,LeptonicaSharp.Rb_Type@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_asetInsert(LeptonicaSharp.L_Rbtree@,LeptonicaSharp.Rb_Type@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.l_asetDelete(LeptonicaSharp.L_Rbtree@,LeptonicaSharp.Rb_Type@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.l_asetDestroy(LeptonicaSharp.L_Rbtree@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.l_asetGetFirst(LeptonicaSharp.L_Rbtree@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_asetGetNext(LeptonicaSharp.L_Rbtree_Node@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_asetGetLast(LeptonicaSharp.L_Rbtree@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_asetGetPrev(LeptonicaSharp.L_Rbtree_Node@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_asetSize(LeptonicaSharp.L_Rbtree@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generateBinaryMaze(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) We have two input probability factors that determine the
 density of walls and average length of straight passages.
 When ranis LT 1.0, you are more likely to generate a wall
 to the side than going forward.  Enter 0.0 for either if
 you want to use the default values.
 (2) This is a type of percolation problem, and exhibits
 different phases for different parameters wallps and ranis.
 For larger values of these parameters, regions in the maze
 are not explored because the maze generator walls them
 off and cannot get through.  The boundary between the
 two phases in this two-dimensional parameter space goes
 near these values
 wallps ranis
 0.35   1.00
 0.40   0.85
 0.45   0.70
 0.50   0.50
 0.55   0.40
 0.60   0.30
 0.65   0.25
 0.70   0.19
 0.75   0.15
 0.80   0.11
 (3) Because there is a considerable amount of overhead in calling
 pixGetPixel() and pixSetPixel(), this function can be sped
 up with little effort using raster line pointers and the
 GET_DATA and SET_DATA macros.
 </summary>
	<remarks>
	</remarks>
	<param name="w">size of maze</param>
	<param name="h">size of maze</param>
	<param name="xi">initial location</param>
	<param name="yi">initial location</param>
	<param name="wallps">probability that a pixel to the side is ON</param>
	<param name="ranis">ratio of prob that pixel in forward direction is a wall to the probability that pixel in side directions is a wall</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSearchBinaryMaze(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) Because of the overhead in calling pixGetPixel() and
 pixSetPixel(), we have used raster line pointers and the
 GET_DATA and SET_DATA macros for many of the pix accesses.
 (2) Commentary
 The goal is to find the shortest path between beginning and
 end points, without going through walls, and there are many
 ways to solve this problem.
 We use a queue to implement a breadth-first search.  Two auxiliary
 "image" data structures can be used one to mark the visited
 pixels and one to give the direction to the parent for each
 visited pixel.  The first structure is used to avoid putting
 pixels on the queue more than once, and the second is used
 for retracing back to the origin, like the breadcrumbs in
 Hansel and Gretel.  Each pixel taken off the queue is destroyed
 after it is used to locate the allowed neighbors.  In fact,
 only one distance image is required, if you initialize it
 to some value that signifies "not yet visited."  (We use
 a binary image for marking visited pixels because it is clearer.)
 This method for a simple search of a binary maze is implemented in
 pixSearchBinaryMaze().
 An alternative method would store the (manhattan) distance
 from the start point with each pixel on the queue.  The children
 of each pixel get a distance one larger than the parent.  These
 values can be stored in an auxiliary distance map image
 that is constructed simultaneously with the search.  Once the
 end point is reached, the distance map is used to backtrack
 along a minimum path.  There may be several equal length
 minimum paths, any one of which can be chosen this way.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, maze</param>
	<param name="xi">beginning point; use same initial point that was used to generate the maze</param>
	<param name="yi">beginning point; use same initial point that was used to generate the maze</param>
	<param name="xf">end point, or close to it</param>
	<param name="yf">end point, or close to it</param>
	<param name="ppixd">maze with path illustrated, or if no path possible, the part of the maze that was searched</param>
	<returns>pta shortest path, or NULL if either no path exists or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSearchGrayMaze(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, maze</param>
	<param name="xi">beginning point; use same initial point that was used to generate the maze</param>
	<param name="yi">beginning point; use same initial point that was used to generate the maze</param>
	<param name="xf">end point, or close to it</param>
	<param name="yf">end point, or close to it</param>
	<param name="ppixd">maze with path illustrated, or if no path possible, the part of the maze that was searched</param>
	<returns>pta shortest path, or NULL if either no path exists or on error Commentary Consider first a slight generalization of the binary maze search problem.  Suppose that you can go through walls, but the cost is higher say, an increment of 3 to go into a wall pixel rather than 1?  You're still trying to find the shortest path.  One way to do this is with an ordered queue, and a simple way to visualize an ordered queue is as a set of stacks, each stack being marked with the distance of each pixel in the stack from the start.  We place the start pixel in stack 0, pop it, and process its 4 children. Each pixel is given a distance that is incremented from that of its parent 0 in this case, depending on if it is a wall pixel or not.  That value may be recorded on a distance map, according to the algorithm below.  For children of the first pixel, those not on a wall go in stack 1, and wall children go in stack 3.  Stack 0 being emptied, the process then continues with pixels being popped from stack 1. Here is the algorithm for each child pixel.  The pixel's distance value, were it to be placed on a stack, is compared with the value for it that is on the distance map.  There are three possible cases 1 If the pixel has not yet been registered, it is pushed on its stack and the distance is written to the map. 2 If it has previously been registered with a higher distance, the distance on the map is relaxed to that of the current pixel, which is then placed on its stack. 3 If it has previously been registered with an equal or lower value, the pixel is discarded. The pixels are popped and processed successively from stack 1, and when stack 1 is empty, popping starts on stack 2. This continues until the destination pixel is popped off a stack.   The minimum path is then derived from the distance map, going back from the end point as before.  This is just Dijkstra's algorithm for a directed graph; here, the underlying graph consisting of the pixels and four edges connecting each pixel to its 4-neighbor is a special case of a directed graph, where each edge is bi-directional.  The implementation of this generalized maze search is left as an exercise to the reader. Let's generalize a bit further.  Suppose the "maze" is just a grayscale image -- think of it as an elevation map.  The cost of moving on this surface depends on the height, or the gradient, or whatever you want.  All that is required is that the cost is specified and non-negative on each link between adjacent pixels.  Now the problem becomes find the least cost path moving on this surface between two specified end points. For example, if the cost across an edge between two pixels depends on the "gradient", you can use cost = 1 + L_ABSdeltaV where deltaV is the difference in value between two adjacent pixels.  If the costs are all integers, we can still use an array of stacks to avoid ordering the queue e.g., by using a heap sort. This is a neat problem, because you don't even have to build a maze -- you can can use it on any grayscale image! Rather than using an array of stacks, a more practical approach is to implement with a priority queue, which is a queue that is sorted so that the elements with the largest or smallest key values always come off first.  The priority queue is efficiently implemented as a heap, and this is how we do it.  Suppose you run the algorithm using a priority queue, doing the bookkeeping with an auxiliary image data structure that saves the distance of each pixel put on the queue as before, according to the method described above.  We implement it as a 2-way choice by initializing the distance array to a large value and putting a pixel on the queue if its distance is less than the value found on the array.  When you finally pop the end pixel from the queue, you're done, and you can trace the path backward, either always going downhill or using an auxiliary image to give you the direction to go at each step.  This is implemented here in searchGrayMaze. Do we really have to use a sorted queue?  Can we solve this generalized maze with an unsorted queue of pixels?  Or even an unsorted stack, doing a depth-first search (DFS)? Consider a different algorithm for this generalized maze, where we travel again breadth first, but this time use a single, unsorted queue.  An auxiliary image is used as before to store the distances and to determine if pixels get pushed on the stack or dropped.  As before, we must allow pixels to be revisited, with relaxation of the distance if a shorter path arrives later.  As a result, we will in general have multiple instances of the same pixel on the stack with different distances.  However, because the queue is not ordered, some of these pixels will be popped when another instance with a lower distance is still on the stack.  Here, we're just popping them in the order they go on, rather than setting up a priority based on minimum distance.  Thus, unlike the priority queue, when a pixel is popped we have to check the distance map to see if a pixel with a lower distance has been put on the queue, and, if so, we discard the pixel we just popped.  So the "while" loop looks like this ~ pop a pixel from the queue ~ check its distance against the distance stored in the distance map; if larger, discard ~ otherwise, for each of its neighbors ~ compute its distance from the start pixel ~ compare this distance with that on the distance map ~ if the distance map value higher, relax the distance and push the pixel on the queue ~ if the distance map value is lower, discard the pixel How does this loop terminate?  Before, with an ordered queue, it terminates when you pop the end pixel.  But with an unordered queue or stack, the first time you hit the end pixel, the distance is not guaranteed to be correct, because the pixels along the shortest path may not have yet been visited and relaxed. Because the shortest path can theoretically go anywhere, we must keep going.  How do we know when to stop?   Dijkstra uses an ordered queue to systematically remove nodes from further consideration.  Each time a pixel is popped, we're done with it; it's "finalized" in the Dijkstra sense because we know the shortest path to it.  However, with an unordered queue, the brute force answer is stop when the queue or stack is empty, because then every pixel in the image has been assigned its minimum "distance" from the start pixel. This is similar to the situation when you use a stack for the simpler uniform-step problem with breadth-first search BFS the pixels on the queue are automatically ordered, so you are done when you locate the end pixel as a neighbor of a popped pixel; whereas depth-first search DFS, using a stack, requires, in general, a search of every accessible pixel.  Further, if a pixel is revisited with a smaller distance, that distance is recorded and the pixel is put on the stack again. But surely, you ask, can't we stop sooner?  What if the start and end pixels are very close to each other? OK, suppose they are, and you have very high walls and a long snaking level path that is actually the minimum cost. That long path can wind back and forth across the entire maze many times before ending up at the end point, which could be just over a wall from the start.  With the unordered queue, you very quickly get a high distance for the end pixel, which will be relaxed to the minimum distance only after all the pixels of the path have been visited and placed on the queue, multiple times for many of them.  So that's the price for not ordering the queue!</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDilate(LeptonicaSharp.Pix,LeptonicaSharp.Sel,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This dilates src using hits in Sel.
 (2) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixDilate(NULL, pixs, ...);
 (b) pixDilate(pixs, pixs, ...);
 (c) pixDilate(pixd, pixs, ...);
 (4) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixErode(LeptonicaSharp.Pix,LeptonicaSharp.Sel,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This erodes src using hits in Sel.
 (2) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixErode(NULL, pixs, ...);
 (b) pixErode(pixs, pixs, ...);
 (c) pixErode(pixd, pixs, ...);
 (4) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixHMT(LeptonicaSharp.Pix,LeptonicaSharp.Sel,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The hit-miss transform erodes the src, using both hits
 and misses in the Sel.  It ANDs the shifted src for hits
 and ANDs the inverted shifted src for misses.
 (2) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixHMT(NULL, pixs, ...);
 (b) pixHMT(pixs, pixs, ...);
 (c) pixHMT(pixd, pixs, ...);
 (4) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOpen(LeptonicaSharp.Pix,LeptonicaSharp.Sel,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Generic morphological opening, using hits in the Sel.
 (2) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixOpen(NULL, pixs, ...);
 (b) pixOpen(pixs, pixs, ...);
 (c) pixOpen(pixd, pixs, ...);
 (4) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixClose(LeptonicaSharp.Pix,LeptonicaSharp.Sel,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Generic morphological closing, using hits in the Sel.
 (2) This implementation is a strict dual of the opening if
 symmetric boundary conditions are used (see notes at top
 of this file).
 (3) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (4) For clarity, if the case is known, use these patterns
 (a) pixd = pixClose(NULL, pixs, ...);
 (b) pixClose(pixs, pixs, ...);
 (c) pixClose(pixd, pixs, ...);
 (5) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCloseSafe(LeptonicaSharp.Pix,LeptonicaSharp.Sel,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Generic morphological closing, using hits in the Sel.
 (2) If non-symmetric boundary conditions are used, this
 function adds a border of OFF pixels that is of
 sufficient size to avoid losing pixels from the dilation,
 and it removes the border after the operation is finished.
 It thus enforces a correct extensive result for closing.
 (3) If symmetric b.c. are used, it is not necessary to add
 and remove this border.
 (4) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (5) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseSafe(NULL, pixs, ...);
 (b) pixCloseSafe(pixs, pixs, ...);
 (c) pixCloseSafe(pixd, pixs, ...);
 (6) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOpenGeneralized(LeptonicaSharp.Pix,LeptonicaSharp.Sel,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Generalized morphological opening, using both hits and
 misses in the Sel.
 (2) This does a hit-miss transform, followed by a dilation
 using the hits.
 (3) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (4) For clarity, if the case is known, use these patterns
 (a) pixd = pixOpenGeneralized(NULL, pixs, ...);
 (b) pixOpenGeneralized(pixs, pixs, ...);
 (c) pixOpenGeneralized(pixd, pixs, ...);
 (5) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCloseGeneralized(LeptonicaSharp.Pix,LeptonicaSharp.Sel,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Generalized morphological closing, using both hits and
 misses in the Sel.
 (2) This does a dilation using the hits, followed by a
 hit-miss transform.
 (3) This operation is a dual of the generalized opening.
 (4) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (5) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseGeneralized(NULL, pixs, ...);
 (b) pixCloseGeneralized(pixs, pixs, ...);
 (c) pixCloseGeneralized(pixd, pixs, ...);
 (6) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="sel"></param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDilateBrick(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do separably if both hsize and vsize are GT 1.
 (4) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (5) For clarity, if the case is known, use these patterns
 (a) pixd = pixDilateBrick(NULL, pixs, ...);
 (b) pixDilateBrick(pixs, pixs, ...);
 (c) pixDilateBrick(pixd, pixs, ...);
 (6) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixErodeBrick(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do separably if both hsize and vsize are GT 1.
 (4) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (5) For clarity, if the case is known, use these patterns
 (a) pixd = pixErodeBrick(NULL, pixs, ...);
 (b) pixErodeBrick(pixs, pixs, ...);
 (c) pixErodeBrick(pixd, pixs, ...);
 (6) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOpenBrick(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do separably if both hsize and vsize are GT 1.
 (4) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (5) For clarity, if the case is known, use these patterns
 (a) pixd = pixOpenBrick(NULL, pixs, ...);
 (b) pixOpenBrick(pixs, pixs, ...);
 (c) pixOpenBrick(pixd, pixs, ...);
 (6) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCloseBrick(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do separably if both hsize and vsize are GT 1.
 (4) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (5) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseBrick(NULL, pixs, ...);
 (b) pixCloseBrick(pixs, pixs, ...);
 (c) pixCloseBrick(pixd, pixs, ...);
 (6) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCloseSafeBrick(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do separably if both hsize and vsize are GT 1.
 (4) Safe closing adds a border of 0 pixels, of sufficient size so
 that all pixels in input image are processed within
 32-bit words in the expanded image.  As a result, there is
 no special processing for pixels near the boundary, and there
 are no boundary effects.  The border is removed at the end.
 (5) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (6) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseBrick(NULL, pixs, ...);
 (b) pixCloseBrick(pixs, pixs, ...);
 (c) pixCloseBrick(pixd, pixs, ...);
 (7) The size of the result is determined by pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selectComposableSels(System.Int32@,System.Int32@,LeptonicaSharp.Sel@,LeptonicaSharp.Sel@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selectComposableSizes(System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This works for Sel sizes up to 62500, which seems sufficient.
 (2) The composable sel size is typically within +- 1 of
 the requested size.  Up to size = 300, the maximum difference
 is +- 2.
 (3) We choose an overall cost function where the penalty for
 the size difference between input and actual is 4 times
 the penalty for additional rasterops.
 (4) Returned values factor1 GT= factor2
 If size GT 1, then factor1 GT 1.
 </summary>
	<remarks>
	</remarks>
	<param name="size">of sel to be decomposed</param>
	<param name="pfactor1">larger factor</param>
	<param name="pfactor2">smaller factor</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDilateCompBrick(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do compositely for each dimension GT 1.
 (4) Do separably if both hsize and vsize are GT 1.
 (5) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (6) For clarity, if the case is known, use these patterns
 (a) pixd = pixDilateCompBrick(NULL, pixs, ...);
 (b) pixDilateCompBrick(pixs, pixs, ...);
 (c) pixDilateCompBrick(pixd, pixs, ...);
 (7) The dimensions of the resulting image are determined by pixs.
 (8) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixErodeCompBrick(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do compositely for each dimension GT 1.
 (4) Do separably if both hsize and vsize are GT 1.
 (5) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (6) For clarity, if the case is known, use these patterns
 (a) pixd = pixErodeCompBrick(NULL, pixs, ...);
 (b) pixErodeCompBrick(pixs, pixs, ...);
 (c) pixErodeCompBrick(pixd, pixs, ...);
 (7) The dimensions of the resulting image are determined by pixs.
 (8) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOpenCompBrick(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do compositely for each dimension GT 1.
 (4) Do separably if both hsize and vsize are GT 1.
 (5) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (6) For clarity, if the case is known, use these patterns
 (a) pixd = pixOpenCompBrick(NULL, pixs, ...);
 (b) pixOpenCompBrick(pixs, pixs, ...);
 (c) pixOpenCompBrick(pixd, pixs, ...);
 (7) The dimensions of the resulting image are determined by pixs.
 (8) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCloseCompBrick(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do compositely for each dimension GT 1.
 (4) Do separably if both hsize and vsize are GT 1.
 (5) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (6) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseCompBrick(NULL, pixs, ...);
 (b) pixCloseCompBrick(pixs, pixs, ...);
 (c) pixCloseCompBrick(pixd, pixs, ...);
 (7) The dimensions of the resulting image are determined by pixs.
 (8) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCloseSafeCompBrick(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) The origin is at (x, y) = (hsize/2, vsize/2)
 (3) Do compositely for each dimension GT 1.
 (4) Do separably if both hsize and vsize are GT 1.
 (5) Safe closing adds a border of 0 pixels, of sufficient size so
 that all pixels in input image are processed within
 32-bit words in the expanded image.  As a result, there is
 no special processing for pixels near the boundary, and there
 are no boundary effects.  The border is removed at the end.
 (6) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (7) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseSafeCompBrick(NULL, pixs, ...);
 (b) pixCloseSafeCompBrick(pixs, pixs, ...);
 (c) pixCloseSafeCompBrick(pixd, pixs, ...);
 (8) The dimensions of the resulting image are determined by pixs.
 (9) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.resetMorphBoundaryCondition(LeptonicaSharp.Enumerations.MMETRIC_MORPH_BC)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bc">SYMMETRIC_MORPH_BC, ASYMMETRIC_MORPH_BC</param>
</member><member name="M:LeptonicaSharp._AllFunctions.getMorphBorderPixelColor(LeptonicaSharp.Enumerations.L_MORPH,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="type">L_MORPH_DILATE, L_MORPH_ERODE</param>
	<param name="depth">of pix</param>
	<returns>color of border pixels for this operation</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExtractBoundary(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Extracts the fg or bg boundary pixels for each component.
 Components are assumed to end at the boundary of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="type">0 for background pixels; 1 for foreground pixels</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMorphSequenceMasked(LeptonicaSharp.Pix,System.String,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This applies the morph sequence to the image, but only allows
 changes in pixs for pixels under the background of pixm.
 (5) If pixm is NULL, this is just pixMorphSequence().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pixm">1 bpp mask</param>
	<param name="sequence">string specifying sequence of operations</param>
	<param name="dispsep">horizontal separation in pixels between successive displays; use zero to suppress display</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMorphSequenceByComponent(LeptonicaSharp.Pix,System.String,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Boxa@)">
	<summary>
 Notes
 (1) See pixMorphSequence() for composing operation sequences.
 (2) This operates separately on each c.c. in the input pix.
 (3) The dilation does NOT increase the c.c. size; it is clipped
 to the size of the original c.c.   This is necessary to
 keep the c.c. independent after the operation.
 (4) You can specify that the width and/or height must equal
 or exceed a minimum size for the operation to take place.
 (5) Use NULL for boxa to avoid returning the boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="sequence">string specifying sequence</param>
	<param name="connectivity">4 or 8</param>
	<param name="minw">minimum width to consider; use 0 or 1 for any width</param>
	<param name="minh">minimum height to consider; use 0 or 1 for any height</param>
	<param name="pboxa">return boxa of c.c. in pixs</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaMorphSequenceByComponent(LeptonicaSharp.Pixa,System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixMorphSequence() for composing operation sequences.
 (2) This operates separately on each c.c. in the input pixa.
 (3) You can specify that the width and/or height must equal
 or exceed a minimum size for the operation to take place.
 (4) The input pixa should have a boxa giving the locations
 of the pix components.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">of 1 bpp pix</param>
	<param name="sequence">string specifying sequence</param>
	<param name="minw">minimum width to consider; use 0 or 1 for any width</param>
	<param name="minh">minimum height to consider; use 0 or 1 for any height</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMorphSequenceByRegion(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.String,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Boxa@)">
	<summary>
 Notes
 (1) See pixMorphCompSequence() for composing operation sequences.
 (2) This operates separately on the region in pixs corresponding
 to each c.c. in the mask pixm.  It differs from
 pixMorphSequenceByComponent() in that the latter does not have
 a pixm (mask), but instead operates independently on each
 component in pixs.
 (3) Dilation will NOT increase the region size; the result
 is clipped to the size of the mask region.  This is necessary
 to make regions independent after the operation.
 (4) You can specify that the width and/or height of a region must
 equal or exceed a minimum size for the operation to take place.
 (5) Use NULL for %pboxa to avoid returning the boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pixm">mask specifying regions</param>
	<param name="sequence">string specifying sequence</param>
	<param name="connectivity">4 or 8, used on mask</param>
	<param name="minw">minimum width to consider; use 0 or 1 for any width</param>
	<param name="minh">minimum height to consider; use 0 or 1 for any height</param>
	<param name="pboxa">return boxa of c.c. in pixm</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaMorphSequenceByRegion(LeptonicaSharp.Pix,LeptonicaSharp.Pixa,System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixMorphSequence() for composing operation sequences.
 (2) This operates separately on each region in the input pixs
 defined by the components in pixam.
 (3) You can specify that the width and/or height of a mask
 component must equal or exceed a minimum size for the
 operation to take place.
 (4) The input pixam should have a boxa giving the locations
 of the regions in pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pixam">of 1 bpp mask elements</param>
	<param name="sequence">string specifying sequence</param>
	<param name="minw">minimum width to consider; use 0 or 1 for any width</param>
	<param name="minh">minimum height to consider; use 0 or 1 for any height</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixUnionOfMorphOps(LeptonicaSharp.Pix,LeptonicaSharp.Sela,LeptonicaSharp.Enumerations.L_MORPH)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">binary</param>
	<param name="sela"></param>
	<param name="type">L_MORPH_DILATE, etc.</param>
	<returns>pixd union of the specified morphological operation on pixs for each Sel in the Sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixIntersectionOfMorphOps(LeptonicaSharp.Pix,LeptonicaSharp.Sela,LeptonicaSharp.Enumerations.L_MORPH)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">binary</param>
	<param name="sela"></param>
	<param name="type">L_MORPH_DILATE, etc.</param>
	<returns>pixd intersection of the specified morphological operation on pixs for each Sel in the Sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSelectiveConnCompFill(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">binary</param>
	<param name="connectivity">4 or 8</param>
	<param name="minw">minimum width to consider; use 0 or 1 for any width</param>
	<param name="minh">minimum height to consider; use 0 or 1 for any height</param>
	<returns>pix with holes filled in selected c.c., or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRemoveMatchedPattern(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is in-place.
 (2) You can use various functions in selgen to create a Sel
 that is used to generate pixe from pixs.
 (3) This function is applied after pixe has been computed.
 It finds the centroid of each c.c., and subtracts
 (the appropriately dilated version of) pixp, with the center
 of the Sel used to align pixp with pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image, 1 bpp</param>
	<param name="pixp">pattern to be removed from image, 1 bpp</param>
	<param name="pixe">image after erosion by Sel that approximates pixp, 1 bpp</param>
	<param name="x0">center of Sel</param>
	<param name="y0">center of Sel</param>
	<param name="dsize">number of pixels on each side by which pixp is dilated before being subtracted from pixs; valid values are {0, 1, 2, 3, 4}</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDisplayMatchedPattern(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.UInt32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) A 4 bpp colormapped image is generated.
 (2) If scale LT= 1.0, do scale to gray for the output, and threshold
 to nlevels of gray.
 (3) You can use various functions in selgen to create a Sel
 that will generate pixe from pixs.
 (4) This function is applied after pixe has been computed.
 It finds the centroid of each c.c., and colors the output
 pixels using pixp (appropriately aligned) as a stencil.
 Alignment is done using the origin of the Sel and the
 centroid of the eroded image to place the stencil pixp.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image, 1 bpp</param>
	<param name="pixp">pattern to be removed from image, 1 bpp</param>
	<param name="pixe">image after erosion by Sel that approximates pixp, 1 bpp</param>
	<param name="x0">center of Sel</param>
	<param name="y0">center of Sel</param>
	<param name="color">to paint the matched patterns; 0xrrggbb00</param>
	<param name="scale">reduction factor for output pixd</param>
	<param name="nlevels">if scale LT 1.0, threshold to this number of levels</param>
	<returns>pixd 8 bpp, colormapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaExtendByMorph(LeptonicaSharp.Pixa,LeptonicaSharp.Enumerations.L_MORPH,System.Int32,LeptonicaSharp.Sel,System.Int32)">
	<summary>
 Notes
 (1) This dilates or erodes every pix in %pixas, iteratively,
 using the input Sel (or, if null, a 2x2 Sel by default),
 and puts the results in %pixad.
 (2) If %niters LT= 0, this is a no-op; it returns a clone of pixas.
 (3) If %include == 1, the output %pixad contains all the pix
 in %pixas.  Otherwise, it doesn't, but pixaJoin() can be
 used later to join pixas with pixad.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="type">L_MORPH_DILATE, L_MORPH_ERODE</param>
	<param name="niters"></param>
	<param name="sel">used for dilation, erosion; uses 2x2 if null</param>
	<param name="include">1 to include a copy of the input pixas in pixad; 0 to omit</param>
	<returns>pixad   with derived pix, using all iterations, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaExtendByScaling(LeptonicaSharp.Pixa,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_direction,System.Int32)">
	<summary>
 Notes
 (1) This scales every pix in %pixas by each factor in %nasc.
 and puts the results in %pixad.
 (2) If %include == 1, the output %pixad contains all the pix
 in %pixas.  Otherwise, it doesn't, but pixaJoin() can be
 used later to join pixas with pixad.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="nasc">numa of scaling factors</param>
	<param name="type">L_HORIZ, L_VERT, L_BOTH_DIRECTIONS</param>
	<param name="include">1 to include a copy of the input pixas in pixad; 0 to omit</param>
	<returns>pixad   with derived pix, using all scalings, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfillMorph(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is in general a very inefficient method for filling
 from a seed into a mask.  Use it for a small number of iterations,
 but if you expect more than a few iterations, use
 pixSeedfillBinary().
 (2) We use a 3x3 brick SEL for 8-cc filling and a 3x3 plus SEL for 4-cc.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">seed</param>
	<param name="pixm">mask</param>
	<param name="maxiters">use 0 to go to completion</param>
	<param name="connectivity">4 or 8</param>
	<returns>pixd after filling into the mask or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRunHistogramMorph(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_RUN_O,LeptonicaSharp.Enumerations.L_direction,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="runtype">L_RUN_OFF, L_RUN_ON</param>
	<param name="direction">L_HORIZ, L_VERT</param>
	<param name="maxsize">size of largest runlength counted</param>
	<returns>numa of run-lengths</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTophat(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_TOPHAT)">
	<summary>
 Notes
 (1) Sel is a brick with all elements being hits
 (2) If hsize = vsize = 1, returns an image with all 0 data.
 (3) The L_TOPHAT_WHITE flag emphasizes small bright regions,
 whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.
 The L_TOPHAT_WHITE tophat can be accomplished by doing a
 L_TOPHAT_BLACK tophat on the inverse, or v.v.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<param name="type">L_TOPHAT_WHITE image - opening L_TOPHAT_BLACK closing - image</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixHDome(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) It is more efficient to use a connectivity of 4 for the fill.
 (2) This fills bumps to some level, and extracts the unfilled
 part of the bump.  To extract the troughs of basins, first
 invert pixs and then apply pixHDome().
 (3) It is useful to compare the HDome operation with the TopHat.
 The latter extracts peaks or valleys that have a width
 not exceeding the size of the structuring element used
 in the opening or closing, rsp.  The height of the peak is
 irrelevant.  By contrast, for the HDome, the gray seedfill
 is used to extract all peaks that have a height not exceeding
 a given value, regardless of their width!
 (4) Slightly more precisely, suppose you set 'height' = 40.
 Then all bumps in pixs with a height greater than or equal
 to 40 become, in pixd, bumps with a max value of exactly 40.
 All shorter bumps have a max value in pixd equal to the height
 of the bump.
 (5) The method the filling mask, pixs, is the image whose peaks
 are to be extracted.  The height of a peak is the distance
 between the top of the peak and the highest "leak" to the
 outside -- think of a sombrero, where the leak occurs
 at the highest point on the rim.
 (a) Generate a seed, pixd, by subtracting some value, p, from
 each pixel in the filling mask, pixs.  The value p is
 the 'height' input to this function.
 (b) Fill in pixd starting with this seed, clipping by pixs,
 in the way described in seedfillGrayLow().  The filling
 stops before the peaks in pixs are filled.
 For peaks that have a height GT p, pixd is filled to
 the level equal to the (top-of-the-peak - p).
 For peaks of height LT p, the peak is left unfilled
 from its highest saddle point (the leak to the outside).
 (c) Subtract the filled seed (pixd) from the filling mask (pixs).
 Note that in this procedure, everything is done starting
 with the filling mask, pixs.
 (6) For segmentation, the resulting image, pixd, can be thresholded
 and used as a seed for another filling operation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, filling mask</param>
	<param name="height">of seed below the filling maskhdome; must be GT= 0</param>
	<param name="connectivity">4 or 8</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFastTophat(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_TOPHAT)">
	<summary>
 Notes
 (1) Don't be fooled. This is NOT a tophat.  It is a tophat-like
 operation, where the result is similar to what you'd get
 if you used an erosion instead of an opening, or a dilation
 instead of a closing.
 (2) Instead of opening or closing at full resolution, it does
 a fast downscale/minmax operation, then a quick small smoothing
 at low res, a replicative expansion of the "background"
 to full res, and finally a removal of the background level
 from the input image.  The smoothing step may not be important.
 (3) It does not remove noise as well as a tophat, but it is
 5 to 10 times faster.
 If you need the preciseness of the tophat, don't use this.
 (4) The L_TOPHAT_WHITE flag emphasizes small bright regions,
 whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="xsize">width of max/min op, smoothing; any integer GT= 1</param>
	<param name="ysize">height of max/min op, smoothing; any integer GT= 1</param>
	<param name="type">L_TOPHAT_WHITE image - min L_TOPHAT_BLACK max - image</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMorphGradient(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="hsize">of Sel; must be odd; origin implicitly in center</param>
	<param name="vsize">ditto</param>
	<param name="smoothing">half-width of convolution smoothing filter. The width is (2  smoothing + 1, so 0 is no-op.</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaCentroids(LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) An error message is returned if any pix has something other
 than 1 bpp or 8 bpp depth, and the centroid from that pix
 is saved as (0, 0).
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of components 1 or 8 bpp</param>
	<returns>pta of centroids relative to the UL corner of each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCentroid(LeptonicaSharp.Pix,System.Single[]@,System.Single[]@,System.Int32[],System.Int32[])">
	<summary>
 Notes
 (1) Any table not passed in will be made internally and destroyed
 after use.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 or 8 bpp</param>
	<param name="centtab">table for finding centroids; can be null</param>
	<param name="sumtab">table for finding pixel sums; can be null</param>
	<param name="pxave">coordinates of centroid, relative to the UL corner of the pix</param>
	<param name="pyave">coordinates of centroid, relative to the UL corner of the pix</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDilateBrickDwa(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) These implement 2D brick Sels, using linear Sels generated
 with selaAddBasic().
 (2) A brick Sel has hits for all elements.
 (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (4) Do separably if both hsize and vsize are GT 1.
 (5) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (6) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (7) For clarity, if the case is known, use these patterns
 (a) pixd = pixDilateBrickDwa(NULL, pixs, ...);
 (b) pixDilateBrickDwa(pixs, pixs, ...);
 (c) pixDilateBrickDwa(pixd, pixs, ...);
 (8) The size of pixd is determined by pixs.
 (9) If either linear Sel is not found, this calls
 the appropriate decomposible function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixErodeBrickDwa(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) These implement 2D brick Sels, using linear Sels generated
 with selaAddBasic().
 (2) A brick Sel has hits for all elements.
 (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (4) Do separably if both hsize and vsize are GT 1.
 (5) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (6) Note that we must always set or clear the border pixels
 before each operation, depending on the the b.c.
 (symmetric or asymmetric).
 (7) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (8) For clarity, if the case is known, use these patterns
 (a) pixd = pixErodeBrickDwa(NULL, pixs, ...);
 (b) pixErodeBrickDwa(pixs, pixs, ...);
 (c) pixErodeBrickDwa(pixd, pixs, ...);
 (9) The size of the result is determined by pixs.
 (10) If either linear Sel is not found, this calls
 the appropriate decomposible function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOpenBrickDwa(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) These implement 2D brick Sels, using linear Sels generated
 with selaAddBasic().
 (2) A brick Sel has hits for all elements.
 (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (4) Do separably if both hsize and vsize are GT 1.
 (5) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (6) Note that we must always set or clear the border pixels
 before each operation, depending on the the b.c.
 (symmetric or asymmetric).
 (7) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (8) For clarity, if the case is known, use these patterns
 (a) pixd = pixOpenBrickDwa(NULL, pixs, ...);
 (b) pixOpenBrickDwa(pixs, pixs, ...);
 (c) pixOpenBrickDwa(pixd, pixs, ...);
 (9) The size of the result is determined by pixs.
 (10) If either linear Sel is not found, this calls
 the appropriate decomposible function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCloseBrickDwa(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a 'safe' closing; we add an extra border of 32 OFF
 pixels for the standard asymmetric b.c.
 (2) These implement 2D brick Sels, using linear Sels generated
 with selaAddBasic().
 (3) A brick Sel has hits for all elements.
 (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (5) Do separably if both hsize and vsize are GT 1.
 (6) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (7) Note that we must always set or clear the border pixels
 before each operation, depending on the the b.c.
 (symmetric or asymmetric).
 (8) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (9) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseBrickDwa(NULL, pixs, ...);
 (b) pixCloseBrickDwa(pixs, pixs, ...);
 (c) pixCloseBrickDwa(pixd, pixs, ...);
 (10) The size of the result is determined by pixs.
 (11) If either linear Sel is not found, this calls
 the appropriate decomposible function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDilateCompBrickDwa(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) These implement a separable composite dilation with 2D brick Sels.
 (2) For efficiency, it may decompose each linear morphological
 operation into two (brick + comb).
 (3) A brick Sel has hits for all elements.
 (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (5) Do separably if both hsize and vsize are GT 1.
 (6) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (7) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (8) For clarity, if the case is known, use these patterns
 (a) pixd = pixDilateCompBrickDwa(NULL, pixs, ...);
 (b) pixDilateCompBrickDwa(pixs, pixs, ...);
 (c) pixDilateCompBrickDwa(pixd, pixs, ...);
 (9) The size of pixd is determined by pixs.
 (10) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixErodeCompBrickDwa(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) These implement a separable composite erosion with 2D brick Sels.
 (2) For efficiency, it may decompose each linear morphological
 operation into two (brick + comb).
 (3) A brick Sel has hits for all elements.
 (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (5) Do separably if both hsize and vsize are GT 1.
 (6) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (7) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (8) For clarity, if the case is known, use these patterns
 (a) pixd = pixErodeCompBrickDwa(NULL, pixs, ...);
 (b) pixErodeCompBrickDwa(pixs, pixs, ...);
 (c) pixErodeCompBrickDwa(pixd, pixs, ...);
 (9) The size of pixd is determined by pixs.
 (10) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOpenCompBrickDwa(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) These implement a separable composite opening with 2D brick Sels.
 (2) For efficiency, it may decompose each linear morphological
 operation into two (brick + comb).
 (3) A brick Sel has hits for all elements.
 (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (5) Do separably if both hsize and vsize are GT 1.
 (6) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (7) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (8) For clarity, if the case is known, use these patterns
 (a) pixd = pixOpenCompBrickDwa(NULL, pixs, ...);
 (b) pixOpenCompBrickDwa(pixs, pixs, ...);
 (c) pixOpenCompBrickDwa(pixd, pixs, ...);
 (9) The size of pixd is determined by pixs.
 (10) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCloseCompBrickDwa(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This implements a separable composite safe closing with 2D
 brick Sels.
 (2) For efficiency, it may decompose each linear morphological
 operation into two (brick + comb).
 (3) A brick Sel has hits for all elements.
 (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
 (5) Do separably if both hsize and vsize are GT 1.
 (6) It is necessary that both horizontal and vertical Sels
 of the input size are defined in the basic sela.
 (7) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (8) For clarity, if the case is known, use these patterns
 (a) pixd = pixCloseCompBrickDwa(NULL, pixs, ...);
 (b) pixCloseCompBrickDwa(pixs, pixs, ...);
 (c) pixCloseCompBrickDwa(pixd, pixs, ...);
 (9) The size of pixd is determined by pixs.
 (10) CAUTION both hsize and vsize are being decomposed.
 The decomposer chooses a product of sizes (call them
 'terms') for each that is close to the input size,
 but not necessarily equal to it.  It attempts to optimize
 (a) for consistency with the input values the product
 of terms is close to the input size
 (b) for efficiency of the operation the sum of the
 terms is small; ideally about twice the square
 root of the input size.
 So, for example, if the input hsize = 37, which is
 a prime number, the decomposer will break this into two
 terms, 6 and 6, so that the net result is a dilation
 with hsize = 36.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDilateCompBrickExtendDwa(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Ankur Jain suggested and implemented extending the composite
 DWA operations beyond the 63 pixel limit.  This is a
 simplified and approximate implementation of the extension.
 This allows arbitrary Dwa morph operations using brick Sels,
 by decomposing the horizontal and vertical dilations into
 a sequence of 63-element dilations plus a dilation of size
 between 3 and 62.
 (2) The 63-element dilations are exact, whereas the extra dilation
 is approximate, because the underlying decomposition is
 in pixDilateCompBrickDwa().  See there for further details.
 (3) There are three cases
 (a) pixd == null   (result into new pixd)
 (b) pixd == pixs   (in-place; writes result back to pixs)
 (c) pixd != pixs   (puts result into existing pixd)
 (4) There is no need to call this directly  pixDilateCompBrickDwa()
 calls this function if either brick dimension exceeds 63.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixErodeCompBrickExtendDwa(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See pixDilateCompBrickExtendDwa() for usage.
 (2) There is no need to call this directly  pixErodeCompBrickDwa()
 calls this function if either brick dimension exceeds 63.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOpenCompBrickExtendDwa(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd 1 There are three cases a) pixd == null   (result into new pixd b) pixd == pixs   (in-place; writes result back to pixs c) pixd != pixs   (puts result into existing pixd 2) There is no need to call this directly  pixOpenCompBrickDwa( calls this function if either brick dimension exceeds 63.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCloseCompBrickExtendDwa(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">1 bpp</param>
	<param name="hsize">width of brick Sel</param>
	<param name="vsize">height of brick Sel</param>
	<returns>pixd 1 There are three cases a) pixd == null   (result into new pixd b) pixd == pixs   (in-place; writes result back to pixs c) pixd != pixs   (puts result into existing pixd 2) There is no need to call this directly  pixCloseCompBrickDwa( calls this function if either brick dimension exceeds 63.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getExtendedCompositeParameters(System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The DWA implementation allows Sels to be used with hits
 up to 31 pixels from the origin, either horizontally or
 vertically.  Larger Sels can be used if decomposed into
 a set of operations with Sels not exceeding 63 pixels
 in either width or height (and with the origin as close
 to the center of the Sel as possible).
 (2) This returns the decomposition of a linear Sel of length
 %size into a set of %n Sels of length 63 plus an extra
 Sel of length %extra.
 (3) For notation, let w == %size, n == %n, and e == %extra.
 We have 1 LT e LT 63.
 Then if w LT 64, we have n = 0 and e = w.
 The general formula for w GT 63 is
 w = 63 + (n - 1)  62 + (e - 1)
 Where did this come from?  Each successive convolution with
 a Sel of length L adds a total length (L - 1) to w.
 This accounts for using 62 for each additional Sel of size 63,
 and using (e - 1) for the additional Sel of size e.
 Solving for n and e for w GT 63
 n = 1 + Int((w - 63) / 62)
 e = w - 63 - (n - 1)  62 + 1
 The extra part is decomposed into two factors f1 and f2,
 and the actual size of the extra part is
 e' = f1  f2
 Then the actual width is
 w' = 63 + (n - 1)  62 + f1  f2 - 1
 </summary>
	<remarks>
	</remarks>
	<param name="size">of linear Sel</param>
	<param name="pn">number of 63 wide convolutions</param>
	<param name="pextra">size of extra Sel</param>
	<param name="pactualsize">actual size used in operation</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMorphSequence(LeptonicaSharp.Pix,System.String,System.Int32)">
	<summary>
 Notes
 (1) This does rasterop morphology on binary images.
 (2) This runs a pipeline of operations; no branching is allowed.
 (3) This only uses brick Sels, which are created on the fly.
 In the future this will be generalized to extract Sels from
 a Sela by name.
 (4) A new image is always produced; the input image is not changed.
 (5) This contains an interpreter, allowing sequences to be
 generated and run.
 (6) The format of the sequence string is defined below.
 (7) In addition to morphological operations, rank order reduction
 and replicated expansion allow operations to take place
 downscaled by a power of 2.
 (8) Intermediate results can optionally be displayed.
 (9) Thanks to Dar-Shyang Lee, who had the idea for this and
 built the first implementation.
 (10) The sequence string is formatted as follows
 ~ An arbitrary number of operations,  each separated
 by a '+' character.  White space is ignored.
 ~ Each operation begins with a case-independent character
 specifying the operation
 d or D  (dilation)
 e or E  (erosion)
 o or O  (opening)
 c or C  (closing)
 r or R  (rank binary reduction)
 x or X  (replicative binary expansion)
 b or B  (add a border of 0 pixels of this size)
 ~ The args to the morphological operations are bricks of hits,
 and are formatted as a.b, where a and b are horizontal and
 vertical dimensions, rsp.
 ~ The args to the reduction are a sequence of up to 4 integers,
 each from 1 to 4.
 ~ The arg to the expansion is a power of two, in the set
 {2, 4, 8, 16}.
 (11) An example valid sequence is
 "b32 + o1.3 + C3.1 + r23 + e2.2 + D3.2 + X4"
 In this example, the following operation sequence is carried out
 b32 Add a 32 pixel border around the input image
 o1.3 Opening with vert sel of length 3 (e.g., 1 x 3)
 C3.1 Closing with horiz sel of length 3  (e.g., 3 x 1)
 r23 Two successive 2x2 reductions with rank 2 in the first
 and rank 3 in the second.  The result is a 4x reduced pix.
 e2.2 Erosion with a 2x2 sel (origin will be at x,y 0,0)
 d3.2 Dilation with a 3x2 sel (origin will be at x,y 1,0)
 X4 4x replicative expansion, back to original resolution
 (12) The safe closing is used.  However, if you implement a
 closing as separable dilations followed by separable erosions,
 it will not be safe.  For that situation, you need to add
 a sufficiently large border as the first operation in
 the sequence.  This will be removed automatically at the
 end.  There are two cautions
 ~ When computing what is sufficient, remember that if
 reductions are carried out, the border is also reduced.
 ~ The border is removed at the end, so if a border is
 added at the beginning, the result must be at the
 same resolution as the input!
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="sequence">string specifying sequence</param>
	<param name="dispsep">controls debug display of each result in the sequence 0 no output GT 0 gives horizontal separation in pixels between successive displays LT 0 pdf output; abs(dispsep) is used for naming</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMorphCompSequence(LeptonicaSharp.Pix,System.String,System.Int32)">
	<summary>
 Notes
 (1) This does rasterop morphology on binary images, using composite
 operations for extra speed on large Sels.
 (2) Safe closing is used atomically.  However, if you implement a
 closing as a sequence with a dilation followed by an
 erosion, it will not be safe, and to ensure that you have
 no boundary effects you must add a border in advance and
 remove it at the end.
 (3) For other usage details, see the notes for pixMorphSequence().
 (4) The sequence string is formatted as follows
 ~ An arbitrary number of operations,  each separated
 by a '+' character.  White space is ignored.
 ~ Each operation begins with a case-independent character
 specifying the operation
 d or D  (dilation)
 e or E  (erosion)
 o or O  (opening)
 c or C  (closing)
 r or R  (rank binary reduction)
 x or X  (replicative binary expansion)
 b or B  (add a border of 0 pixels of this size)
 ~ The args to the morphological operations are bricks of hits,
 and are formatted as a.b, where a and b are horizontal and
 vertical dimensions, rsp.
 ~ The args to the reduction are a sequence of up to 4 integers,
 each from 1 to 4.
 ~ The arg to the expansion is a power of two, in the set
 {2, 4, 8, 16}.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="sequence">string specifying sequence</param>
	<param name="dispsep">controls debug display of each result in the sequence 0 no output GT 0 gives horizontal separation in pixels between successive displays LT 0 pdf output; abs(dispsep) is used for naming</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMorphSequenceDwa(LeptonicaSharp.Pix,System.String,System.Int32)">
	<summary>
 Notes
 (1) This does dwa morphology on binary images.
 (2) This runs a pipeline of operations; no branching is allowed.
 (3) This only uses brick Sels that have been pre-compiled with
 dwa code.
 (4) A new image is always produced; the input image is not changed.
 (5) This contains an interpreter, allowing sequences to be
 generated and run.
 (6) See pixMorphSequence() for further information about usage.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="sequence">string specifying sequence</param>
	<param name="dispsep">controls debug display of each result in the sequence 0 no output GT 0 gives horizontal separation in pixels between successive displays LT 0 pdf output; abs(dispsep) is used for naming</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMorphCompSequenceDwa(LeptonicaSharp.Pix,System.String,System.Int32)">
	<summary>
 Notes
 (1) This does dwa morphology on binary images, using brick Sels.
 (2) This runs a pipeline of operations; no branching is allowed.
 (3) It implements all brick Sels that have dimensions up to 63
 on each side, using a composite (linear + comb) when useful.
 (4) A new image is always produced; the input image is not changed.
 (5) This contains an interpreter, allowing sequences to be
 generated and run.
 (6) See pixMorphSequence() for further information about usage.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="sequence">string specifying sequence</param>
	<param name="dispsep">controls debug display of each result in the sequence 0 no output GT 0 gives horizontal separation in pixels between successive displays LT 0 pdf output; abs(dispsep) is used for naming</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.morphSequenceVerify(LeptonicaSharp.Sarray)">
	<summary>
 Notes
 (1) This does verification of valid binary morphological
 operation sequences.
 (2) See pixMorphSequence() for notes on valid operations
 in the sequence.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of operation sequence</param>
	<returns>TRUE if valid; FALSE otherwise or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGrayMorphSequence(LeptonicaSharp.Pix,System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This works on 8 bpp grayscale images.
 (2) This runs a pipeline of operations; no branching is allowed.
 (3) This only uses brick SELs.
 (4) A new image is always produced; the input image is not changed.
 (5) This contains an interpreter, allowing sequences to be
 generated and run.
 (6) The format of the sequence string is defined below.
 (7) In addition to morphological operations, the composite
 morph/subtract tophat can be performed.
 (8) Sel sizes (width, height) must each be odd numbers.
 (9) Intermediate results can optionally be displayed
 (10) The sequence string is formatted as follows
 ~ An arbitrary number of operations,  each separated
 by a '+' character.  White space is ignored.
 ~ Each operation begins with a case-independent character
 specifying the operation
 d or D  (dilation)
 e or E  (erosion)
 o or O  (opening)
 c or C  (closing)
 t or T  (tophat)
 ~ The args to the morphological operations are bricks of hits,
 and are formatted as a.b, where a and b are horizontal and
 vertical dimensions, rsp. (each must be an odd number)
 ~ The args to the tophat are w or W (for white tophat)
 or b or B (for black tophat), followed by a.b as for
 the dilation, erosion, opening and closing.
 Example valid sequences are
 "c5.3 + o7.5"
 "c9.9 + tw9.9"
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="sequence">string specifying sequence</param>
	<param name="dispsep">controls debug display of each result in the sequence 0 no output GT 0 gives horizontal separation in pixels between successive displays LT 0 pdf output; abs(dispsep) is used for naming</param>
	<param name="dispy">if dispsep GT 0, this gives the y-value of the UL corner for display; otherwise it is ignored</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorMorphSequence(LeptonicaSharp.Pix,System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This works on 32 bpp rgb images.
 (2) Each component is processed separately.
 (3) This runs a pipeline of operations; no branching is allowed.
 (4) This only uses brick SELs.
 (5) A new image is always produced; the input image is not changed.
 (6) This contains an interpreter, allowing sequences to be
 generated and run.
 (7) Sel sizes (width, height) must each be odd numbers.
 (8) The format of the sequence string is defined below.
 (9) Intermediate results can optionally be displayed.
 (10) The sequence string is formatted as follows
 ~ An arbitrary number of operations,  each separated
 by a '+' character.  White space is ignored.
 ~ Each operation begins with a case-independent character
 specifying the operation
 d or D  (dilation)
 e or E  (erosion)
 o or O  (opening)
 c or C  (closing)
 ~ The args to the morphological operations are bricks of hits,
 and are formatted as a.b, where a and b are horizontal and
 vertical dimensions, rsp. (each must be an odd number)
 Example valid sequences are
 "c5.3 + o7.5"
 "D9.1"
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="sequence">string specifying sequence</param>
	<param name="dispsep">controls debug display of each result in the sequence 0 no output GT 0 gives horizontal separation in pixels between successive displays LT 0 pdf output; abs(dispsep) is used for naming</param>
	<param name="dispy">if dispsep GT 0, this gives the y-value of the UL corner for display; otherwise it is ignored</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of number array to be alloc'd 0 for default</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaCreateFromIArray(System.Int32[],System.Int32)">
	<summary>
 Notes
 (1) We can't insert this int array into the numa, because a numa
 takes a float array.  So this just copies the data from the
 input array into the numa.  The input array continues to be
 owned by the caller.
 </summary>
	<remarks>
	</remarks>
	<param name="iarray">integer</param>
	<param name="size">of the array</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaCreateFromFArray(System.Single[],System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) With L_INSERT, ownership of the input array is transferred
 to the returned numa, and all %size elements are considered
 to be valid.
 </summary>
	<remarks>
	</remarks>
	<param name="farray">float</param>
	<param name="size">of the array</param>
	<param name="copyflag">L_INSERT or L_COPY</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaCreateFromString(System.String)">
	<summary>
 Notes
 (1) The numbers can be ints or floats; they will be interpreted
 and stored as floats.  To use them as integers (e.g., for
 indexing into arrays), use numaGetIValue(...).
 </summary>
	<remarks>
	</remarks>
	<param name="str">string of comma-separated numbers</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaDestroy(LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the numa.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pna">to be nulled if it exists</param>
</member><member name="M:LeptonicaSharp._AllFunctions.numaCopy(LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>copy of numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaClone(LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>ptr to same numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaEmpty(LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) This does not change the allocation of the array.
 It just clears the number of stored numbers, so that
 the array appears to be empty.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaAddNumber(LeptonicaSharp.Numa,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="val">float or int to be added; stored as a float</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaInsertNumber(LeptonicaSharp.Numa,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This shifts na[i] --GT na[i + 1] for all i GT= index,
 and then inserts val as na[index].
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">location in na to insert new value</param>
	<param name="val">float32 or integer to be added</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaRemoveNumber(LeptonicaSharp.Numa,System.Int32)">
	<summary>
 Notes
 (1) This shifts na[i] --GT na[i - 1] for all i GT index.
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">element to be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaReplaceNumber(LeptonicaSharp.Numa,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">element to be replaced</param>
	<param name="val">new value to replace old one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetCount(LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>count, or 0 if no numbers or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSetCount(LeptonicaSharp.Numa,System.Int32)">
	<summary>
 Notes
 (1) If newcount LT= na-GTnalloc, this resets na-GTn.
 Using newcount = 0 is equivalent to numaEmpty().
 (2) If newcount GT na-GTnalloc, this causes a realloc
 to a size na-GTnalloc = newcount.
 (3) All the previously unused values in na are set to 0.0.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="newcount"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetFValue(LeptonicaSharp.Numa,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) Caller may need to check the function return value to
 decide if a 0.0 in the returned ival is valid.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">into numa</param>
	<param name="pval">float value; 0.0 on error</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetIValue(LeptonicaSharp.Numa,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Caller may need to check the function return value to
 decide if a 0 in the returned ival is valid.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">into numa</param>
	<param name="pival">integer value; 0 on error</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSetValue(LeptonicaSharp.Numa,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">to element to be set</param>
	<param name="val">to set element</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaShiftValue(LeptonicaSharp.Numa,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="index">to element to change relative to the current value</param>
	<param name="diff">increment if diff GT 0 or decrement if diff LT 0</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetIArray(LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) A copy of the array is always made, because we need to
 generate an integer array from the bare float array.
 The caller is responsible for freeing the array.
 (2) The array size is determined by the number of stored numbers,
 not by the size of the allocated array in the Numa.
 (3) This function is provided to simplify calculations
 using the bare internal array, rather than continually
 calling accessors on the numa.  It is typically used
 on an array of size 256.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>a copy of the bare internal array, integerized by rounding, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetFArray(LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) If copyflag == L_COPY, it makes a copy which the caller
 is responsible for freeing.  Otherwise, it operates
 directly on the bare array of the numa.
 (2) Very important for L_NOCOPY, any writes to the array
 will be in the numa.  Do not write beyond the size of
 the count field, because it will not be accessible
 from the numa!  If necessary, be sure to set the count
 field to a larger number (such as the alloc size)
 BEFORE calling this function.  Creating with numaMakeConstant()
 is another way to insure full initialization.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="copyflag">L_NOCOPY or L_COPY</param>
	<returns>either the bare internal array or a copy of it, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetRefcount(LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<returns>refcount, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaChangeRefcount(LeptonicaSharp.Numa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="delta">change to be applied</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetParameters(LeptonicaSharp.Numa,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="pstartx">startx</param>
	<param name="pdelx">delx</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSetParameters(LeptonicaSharp.Numa,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="startx">x value corresponding to na[0]</param>
	<param name="delx">difference in x values for the situation where the elements of na correspond to the evaulation of a function at equal intervals of size %delx</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaCopyParameters(LeptonicaSharp.Numa,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nad">destination Numa</param>
	<param name="nas">source Numa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaConvertToSarray(LeptonicaSharp.Numa,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_VALUE)">
	<summary>
 Notes
 (1) For integer conversion, size2 is ignored.
 For float conversion, addzeroes is ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="size1">size of conversion field</param>
	<param name="size2">for float conversion size of field to the right of the decimal point</param>
	<param name="addzeros">for integer conversion to add lead zeros</param>
	<param name="type">L_INTEGER_VALUE, L_FLOAT_VALUE</param>
	<returns>a sarray of the float values converted to strings representing either integer or float values; or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">numa serialization; in ascii</param>
	<param name="size">of data; can use strlen to get it</param>
	<returns>na, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaWriteDebug(System.String,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) Debug version, intended for use in the library when writing
 to files in a temp directory with names that are compiled in.
 This is used instead of numaWrite() for all such library calls.
 (2) The global variable LeptDebugOK defaults to 0, and can be set
 or cleared by the function setLeptDebugOK().
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="na"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaWrite(System.String,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="na"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="na"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) Serializes a numa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized numa; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="na"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of numa ptr array to be alloc'd 0 for default</param>
	<returns>naa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaCreateFull(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This allocates numaa and fills the array with allocated numas.
 In use, after calling this function, use
 numaaAddNumber(naa, index, val);
 to add val to the index-th numa in naa.
 </summary>
	<remarks>
	</remarks>
	<param name="nptr">size of numa ptr array to be alloc'd</param>
	<param name="n">size of individual numa arrays to be alloc'd 0 for default</param>
	<returns>naa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaTruncate(LeptonicaSharp.Numaa)">
	<summary>
 Notes
 (1) This identifies the largest index containing a numa that
 has any numbers within it, destroys all numa beyond that
 index, and resets the count.
 </summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaDestroy(LeptonicaSharp.Numaa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pnaa">to be nulled if it exists</param>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaAddNuma(LeptonicaSharp.Numaa,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<param name="na">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaGetCount(LeptonicaSharp.Numaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<returns>count number of numa, or 0 if no numa or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaGetNumaCount(LeptonicaSharp.Numaa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<param name="index">of numa in naa</param>
	<returns>count of numbers in the referenced numa, or 0 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaGetNumberCount(LeptonicaSharp.Numaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<returns>count total number of numbers in the numaa, or 0 if no numbers or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaGetPtrArray(LeptonicaSharp.Numaa)">
	<summary>
 Notes
 (1) This function is convenient for doing direct manipulation on
 a fixed size array of Numas.  To do this, it sets the count
 to the full size of the allocated array of Numa ptrs.
 The originating Numaa owns this array DO NOT free it!
 (2) Intended usage
 Numaa naa = numaaCreate(n);
 Numa array = numaaGetPtrArray(naa);
 ...  [manipulate Numas directly on the array]
 numaaDestroy(naa);
 (3) Cautions
 ~ Do not free this array; it is owned by tne Numaa.
 ~ Do not call any functions on the Numaa, other than
 numaaDestroy() when you're finished with the array.
 Adding a Numa will force a resize, destroying the ptr array.
 ~ Do not address the array outside its allocated size.
 With the bare array, there are no protections.  If the
 allocated size is n, array[n] is an error.
 </summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<returns>the internal array of ptrs to Numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaGetNuma(LeptonicaSharp.Numaa,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<param name="index">to the index-th numa</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaReplaceNuma(LeptonicaSharp.Numaa,System.Int32,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) Any existing numa is destroyed, and the input one
 is inserted in its place.
 (2) If the index is invalid, return 1 (error)
 </summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<param name="index">to the index-th numa</param>
	<param name="na">insert and replace any existing one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaGetValue(LeptonicaSharp.Numaa,System.Int32,System.Int32,System.Single[]@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<param name="i">index of numa within numaa</param>
	<param name="j">index into numa</param>
	<param name="pfval">float value</param>
	<param name="pival">int value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaAddNumber(LeptonicaSharp.Numaa,System.Int32,System.Single)">
	<summary>
 Notes
 (1) Adds to an existing numa only.
 </summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<param name="index">of numa within numaa</param>
	<param name="val">float or int to be added; stored as a float</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>naa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>naa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">numaa serialization; in ascii</param>
	<param name="size">of data; can use strlen to get it</param>
	<returns>naa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaWrite(System.String,LeptonicaSharp.Numaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="naa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.Numaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="naa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.Numaa)">
	<summary>
 Notes
 (1) Serializes a numaa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized numaa; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="naa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaArithOp(LeptonicaSharp.Numa,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_arithmetic_logical_operator,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) The sizes of na1 and na2 must be equal.
 (2) nad can only null or equal to na1.
 (3) To add a constant to a numa, or to multipy a numa by
 a constant, use numaTransform().
 </summary>
	<remarks>
	</remarks>
	<param name="nad">can be null or equal to na1 (in-place</param>
	<param name="na1"></param>
	<param name="na2"></param>
	<param name="op">L_ARITH_ADD, L_ARITH_SUBTRACT, L_ARITH_MULTIPLY, L_ARITH_DIVIDE</param>
	<returns>nad always operation applied to na1 and na2</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaLogicalOp(LeptonicaSharp.Numa,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_arithmetic_logical_operator,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) The sizes of na1 and na2 must be equal.
 (2) nad can only be null or equal to na1.
 (3) This is intended for use with indicator arrays (0s and 1s).
 Input data is extracted as integers (0 == false, anything
 else == true); output results are 0 and 1.
 (4) L_SUBTRACTION is subtraction of val2 from val1.  For bit logical
 arithmetic this is (val1  ~val2), but because these values
 are integers, we use (val1  !val2).
 </summary>
	<remarks>
	</remarks>
	<param name="nad">can be null or equal to na1 (in-place</param>
	<param name="na1"></param>
	<param name="na2"></param>
	<param name="op">L_UNION, L_INTERSECTION, L_SUBTRACTION, L_EXCLUSIVE_OR</param>
	<returns>nad always operation applied to na1 and na2</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaInvert(LeptonicaSharp.Numa,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) This is intended for use with indicator arrays (0s and 1s).
 It gives a boolean-type output, taking the input as
 an integer and inverting it
 0  --GT  1
 anything else  --GT   0
 </summary>
	<remarks>
	</remarks>
	<param name="nad">can be null or equal to nas (in-place</param>
	<param name="nas"></param>
	<returns>nad always 'inverts' nas</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSimilar(LeptonicaSharp.Numa,LeptonicaSharp.Numa,System.Single,System.Int32@)">
	<summary>
 Notes
 (1) Float values can differ slightly due to roundoff and
 accumulated errors.  Using %maxdiff GT 0.0 allows similar
 arrays to be identified.
 </summary>
	<remarks>
	</remarks>
	<param name="na1"></param>
	<param name="na2"></param>
	<param name="maxdiff">use 0.0 for exact equality</param>
	<param name="psimilar">1 if similar; 0 if different</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaAddToNumber(LeptonicaSharp.Numa,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This is useful for accumulating sums, regardless of the index
 order in which the values are made available.
 (2) Before use, the numa has to be filled up to %index.  This would
 typically be used by creating the numa with the full sized
 array, initialized to 0.0, using numaMakeConstant().
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="index">element to be changed</param>
	<param name="val">new value to be added</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetMin(LeptonicaSharp.Numa,System.Single[]@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pminval">min value</param>
	<param name="piminloc">index of min location</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetMax(LeptonicaSharp.Numa,System.Single[]@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pmaxval">max value</param>
	<param name="pimaxloc">index of max location</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetSum(LeptonicaSharp.Numa,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="psum">sum of values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetPartialSums(LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) nasum[i] is the sum for all j LT= i of na[j].
 So nasum[0] = na[0].
 (2) If you want to generate a rank function, where rank[0] - 0.0,
 insert a 0.0 at the beginning of the nasum array.
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<returns>nasum, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetSumOnInterval(LeptonicaSharp.Numa,System.Int32,System.Int32,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="first">beginning index</param>
	<param name="last">final index</param>
	<param name="psum">sum of values in the index interval range</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaHasOnlyIntegers(LeptonicaSharp.Numa,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Set %maxsamples == 0 to check every integer in na.  Otherwise,
 this samples no more than %maxsamples.
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="maxsamples">maximum number of samples to check</param>
	<param name="pallints">1 if all sampled values are ints; else 0</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSubsample(LeptonicaSharp.Numa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="subfactor">subsample factor, GT= 1</param>
	<returns>nad evenly sampled values from nas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaMakeDelta(LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<returns>numa of difference values val[i+1] - val[i], or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaMakeSequence(System.Single,System.Single,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="startval"></param>
	<param name="increment"></param>
	<param name="size">of sequence</param>
	<returns>numa of sequence of evenly spaced values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaMakeConstant(System.Single,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="val"></param>
	<param name="size">of numa</param>
	<returns>numa of given size with all entries equal to 'val', or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaMakeAbsValue(LeptonicaSharp.Numa,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nad">for new array, or the same as nas for inplace</param>
	<param name="nas">input numa</param>
	<returns>nad with all numbers being the absval of the input, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaAddBorder(LeptonicaSharp.Numa,System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="left">number of elements to add on each side</param>
	<param name="right">number of elements to add on each side</param>
	<param name="val">initialize border elements</param>
	<returns>nad with added elements at left and right, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaAddSpecifiedBorder(LeptonicaSharp.Numa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_BORDER)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="left">number of elements to add on each side</param>
	<param name="right">number of elements to add on each side</param>
	<param name="type">L_CONTINUED_BORDER, L_MIRRORED_BORDER</param>
	<returns>nad with added elements at left and right, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaRemoveBorder(LeptonicaSharp.Numa,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="left">number of elements to remove from each side</param>
	<param name="right">number of elements to remove from each side</param>
	<returns>nad with removed elements at left and right, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaCountNonzeroRuns(LeptonicaSharp.Numa,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">e.g., of pixel counts in rows or columns</param>
	<param name="pcount">number of nonzero runs</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetNonzeroRange(LeptonicaSharp.Numa,System.Single,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="eps">largest value considered to be zero</param>
	<param name="pfirst">interval of array indices where values are nonzero</param>
	<param name="plast">interval of array indices where values are nonzero</param>
	<returns>0 if OK, 1 on error or if no nonzero range is found.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetCountRelativeToZero(LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_ZERO,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="type">L_LESS_THAN_ZERO, L_EQUAL_TO_ZERO, L_GREATER_THAN_ZERO</param>
	<param name="pcount">count of values of given type</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaClipToInterval(LeptonicaSharp.Numa,System.Int32,System.Int32)">
	<summary>
 Notes
 If you want the indices of the array values to be unchanged,
 use first = 0.
 Usage
 This is useful to clip a histogram that has a few nonzero
 values to its nonzero range.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="first">clipping interval</param>
	<param name="last">clipping interval</param>
	<returns>numa with the same values as the input, but clipped to the specified interval</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaMakeThresholdIndicator(LeptonicaSharp.Numa,System.Single,LeptonicaSharp.Enumerations.L_SELECT_IF)">
	<summary>
 Notes
 (1) For each element in nas, if the constraint given by 'type'
 correctly specifies its relation to thresh, a value of 1
 is recorded in nad.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<param name="thresh">threshold value</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaUniformSampling(LeptonicaSharp.Numa,System.Int32)">
	<summary>
 Notes
 (1) This resamples the values in the array, using %nsamp
 equal divisions.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<param name="nsamp">number of samples</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaReverse(LeptonicaSharp.Numa,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) Usage
 numaReverse(nas, nas);   // in-place
 nad = numaReverse(NULL, nas);  // makes a new one
 </summary>
	<remarks>
	</remarks>
	<param name="nad">can be null or equal to nas</param>
	<param name="nas">input numa</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaLowPassIntervals(LeptonicaSharp.Numa,System.Single,System.Single)">
	<summary>
 Notes
 (1) For each interval where the value is less than a specified
 fraction of the maximum, this records the left and right "x"
 value.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<param name="thresh">threshold fraction of max; in [0.0 ... 1.0]</param>
	<param name="maxn">for normalizing; set maxn = 0.0 to use the max in nas</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaThresholdEdges(LeptonicaSharp.Numa,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) For each edge interval, where where the value is less
 than %thresh1 on one side, greater than %thresh2 on
 the other, and between these thresholds throughout the
 interval, this records a triplet of values the
 'left' and 'right' edges, and either +1 or -1, depending
 on whether the edge is rising or falling.
 (2) No assumption is made about the value outside the array,
 so if the value at the array edge is between the threshold
 values, it is not considered part of an edge.  We start
 looking for edge intervals only after leaving the thresholded
 band.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<param name="thresh1">low threshold as fraction of max; in [0.0 ... 1.0]</param>
	<param name="thresh2">high threshold as fraction of max; in [0.0 ... 1.0]</param>
	<param name="maxn">for normalizing; set maxn = 0.0 to use the max in nas</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetSpanValues(LeptonicaSharp.Numa,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">numa that is output of numaLowPassIntervals()</param>
	<param name="span">span number, zero-based</param>
	<param name="pstart">location of start of transition</param>
	<param name="pend">location of end of transition</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetEdgeValues(LeptonicaSharp.Numa,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">numa that is output of numaThresholdEdges()</param>
	<param name="edge">edge number, zero-based</param>
	<param name="pstart">location of start of transition</param>
	<param name="pend">location of end of transition</param>
	<param name="psign">transition sign +1 is rising, -1 is falling</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaInterpolateEqxVal(System.Single,System.Single,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_INTERP,System.Single,System.Single[]@)">
	<summary>
 Notes
 (1) Considering nay as a function of x, the x values
 are equally spaced
 (2) Caller should check for valid return.
 For linear Lagrangian interpolation (through 2 data pts)
 y(x) = y1(x-x2)/(x1-x2) + y2(x-x1)/(x2-x1)
 For quadratic Lagrangian interpolation (through 3 data pts)
 y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +
 y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +
 y3(x-x1)(x-x2)/((x3-x1)(x3-x2))
 </summary>
	<remarks>
	</remarks>
	<param name="startx">xval corresponding to first element in array</param>
	<param name="deltax">x increment between array elements</param>
	<param name="nay">numa of ordinate values, assumed equally spaced</param>
	<param name="type">L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
	<param name="xval"></param>
	<param name="pyval">interpolated value</param>
	<returns>0 if OK, 1 on error e.g., if xval is outside range</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaInterpolateArbxVal(LeptonicaSharp.Numa,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_INTERP,System.Single,System.Single[]@)">
	<summary>
 Notes
 (1) The values in nax must be sorted in increasing order.
 If, additionally, they are equally spaced, you can use
 numaInterpolateEqxVal().
 (2) Caller should check for valid return.
 (3) Uses lagrangian interpolation.  See numaInterpolateEqxVal()
 for formulas.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values</param>
	<param name="nay">numa of ordinate values, corresponding to nax</param>
	<param name="type">L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
	<param name="xval"></param>
	<param name="pyval">interpolated value</param>
	<returns>0 if OK, 1 on error e.g., if xval is outside range</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaInterpolateEqxInterval(System.Single,System.Single,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_INTERP,System.Single,System.Single,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) Considering nasy as a function of x, the x values
 are equally spaced.
 (2) This creates nay (and optionally nax) of interpolated
 values over the specified interval (x0, x1).
 (3) If the interval (x0, x1) lies partially outside the array
 nasy (as interpreted by startx and deltax), it is an
 error and returns 1.
 (4) Note that deltax is the intrinsic x-increment for the input
 array nasy, whereas delx is the intrinsic x-increment for the
 output interpolated array nay.
 </summary>
	<remarks>
	</remarks>
	<param name="startx">xval corresponding to first element in nas</param>
	<param name="deltax">x increment between array elements in nas</param>
	<param name="nasy">numa of ordinate values, assumed equally spaced</param>
	<param name="type">L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
	<param name="x0">start value of interval</param>
	<param name="x1">end value of interval</param>
	<param name="npts">number of points to evaluate function in interval</param>
	<param name="pnax">array of x values in interval</param>
	<param name="pnay">array of y values in interval</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaInterpolateArbxInterval(LeptonicaSharp.Numa,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_INTERP,System.Single,System.Single,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The values in nax must be sorted in increasing order.
 If they are not sorted, we do it here, and complain.
 (2) If the values in nax are equally spaced, you can use
 numaInterpolateEqxInterval().
 (3) Caller should check for valid return.
 (4) We don't call numaInterpolateArbxVal() for each output
 point, because that requires an O(n) search for
 each point.  Instead, we do a single O(n) pass through
 nax, saving the indices to be used for each output yval.
 (5) Uses lagrangian interpolation.  See numaInterpolateEqxVal()
 for formulas.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values</param>
	<param name="nay">numa of ordinate values, corresponding to nax</param>
	<param name="type">L_LINEAR_INTERP, L_QUADRATIC_INTERP</param>
	<param name="x0">start value of interval</param>
	<param name="x1">end value of interval</param>
	<param name="npts">number of points to evaluate function in interval</param>
	<param name="pnadx">array of x values in interval</param>
	<param name="pnady">array of y values in interval</param>
	<returns>0 if OK, 1 on error e.g., if x0 or x1 is outside range</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaFitMax(LeptonicaSharp.Numa,System.Single[]@,System.Single[]@,LeptonicaSharp.Numa)">
	<summary>
 Notes
 If %naloc is given, there is no requirement that the
 data points are evenly spaced.  Lagrangian interpolation
 handles that.  The only requirement is that the
 data points are ordered so that the values in naloc
 are either increasing or decreasing.  We test to make
 sure that the sizes of na and naloc are equal, and it
 is assumed that the correspondences %na[i] as a function
 of %naloc[i] are properly arranged for all i.
 The formula for Lagrangian interpolation through 3 data pts is
 y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +
 y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +
 y3(x-x1)(x-x2)/((x3-x1)(x3-x2))
 Then the derivative, using the constants (c1,c2,c3) defined below,
 is set to 0
 y'(x) = 2x(c1+c2+c3) - c1(x2+x3) - c2(x1+x3) - c3(x1+x2) = 0
 </summary>
	<remarks>
	</remarks>
	<param name="na">numa of ordinate values, to fit a max to</param>
	<param name="pmaxval">max value</param>
	<param name="naloc">associated numa of abscissa values</param>
	<param name="pmaxloc">abscissa value that gives max value in na; if naloc == null, this is given as an interpolated index value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaDifferentiateInterval(LeptonicaSharp.Numa,LeptonicaSharp.Numa,System.Single,System.Single,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The values in nax must be sorted in increasing order.
 If they are not sorted, it is done in the interpolation
 step, and a warning is issued.
 (2) Caller should check for valid return.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values</param>
	<param name="nay">numa of ordinate values, corresponding to nax</param>
	<param name="x0">start value of interval</param>
	<param name="x1">end value of interval</param>
	<param name="npts">number of points to evaluate function in interval</param>
	<param name="pnadx">array of x values in interval</param>
	<param name="pnady">array of derivatives in interval</param>
	<returns>0 if OK, 1 on error e.g., if x0 or x1 is outside range</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaIntegrateInterval(LeptonicaSharp.Numa,LeptonicaSharp.Numa,System.Single,System.Single,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) The values in nax must be sorted in increasing order.
 If they are not sorted, it is done in the interpolation
 step, and a warning is issued.
 (2) Caller should check for valid return.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values</param>
	<param name="nay">numa of ordinate values, corresponding to nax</param>
	<param name="x0">start value of interval</param>
	<param name="x1">end value of interval</param>
	<param name="npts">number of points to evaluate function in interval</param>
	<param name="psum">integral of function over interval</param>
	<returns>0 if OK, 1 on error e.g., if x0 or x1 is outside range</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSortGeneral(LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_SORT_CREASING,LeptonicaSharp.Enumerations.L_SORT,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) Sorting can be confusing.  Here's an array of five values with
 the results shown for the 3 output arrays.
 na   nasort   naindex   nainvert
 -----------------------------------
 3   9   2   3
 4   6   3   2
 9   4   1   0
 6   3   0   1
 1   1   4   4
 Note that naindex is a LUT into na for the sorted array values,
 and nainvert directly gives the sorted index values for the
 input array.  It is useful to view naindex is as a map
 0  --GT  2
 1  --GT  3
 2  --GT  1
 3  --GT  0
 4  --GT  4
 and nainvert, the inverse of this map
 0  --GT  3
 1  --GT  2
 2  --GT  0
 3  --GT  1
 4  --GT  4
 We can write these relations symbolically as
 nasort[i] = na[naindex[i]]
 na[i] = nasort[nainvert[i]]
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pnasort">sorted numa</param>
	<param name="pnaindex">index of elements in na associated with each element of nasort</param>
	<param name="pnainvert">index of elements in nasort associated with each element of na</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<param name="sorttype">L_SHELL_SORT or L_BIN_SORT</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSortAutoSelect(LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_SORT_CREASING)">
	<summary>
 Notes
 (1) This does either a shell sort or a bin sort, depending on
 the number of elements in nas and the dynamic range.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>naout output sorted numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSortIndexAutoSelect(LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_SORT_CREASING)">
	<summary>
 Notes
 (1) This does either a shell sort or a bin sort, depending on
 the number of elements in nas and the dynamic range.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>nad indices of nas, sorted by value in nas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaChooseSortType(LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) This selects either a shell sort or a bin sort, depending on
 the number of elements in nas and the dynamic range.
 (2) If there are negative values in nas, it selects shell sort.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">to be sorted</param>
	<returns>sorttype L_SHELL_SORT or L_BIN_SORT, or UNDEF on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSort(LeptonicaSharp.Numa,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_SORT_CREASING)">
	<summary>
 Notes
 (1) Set naout = nain for in-place; otherwise, set naout = NULL.
 (2) Source Shell sort, modified from KR, 2nd edition, p.62.
 Slow but simple O(n logn) sort.
 </summary>
	<remarks>
	</remarks>
	<param name="naout">output numa; can be NULL or equal to nain</param>
	<param name="nain">input numa</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>naout output sorted numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaBinSort(LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_SORT_CREASING)">
	<summary>
 Notes
 (1) Because this uses a bin sort with buckets of size 1, it
 is not appropriate for sorting either small arrays or
 arrays containing very large integer values.  For such
 arrays, use a standard general sort function like
 numaSort().
 </summary>
	<remarks>
	</remarks>
	<param name="nas">of non-negative integers with a max that is typically less than 50,000</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>na sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetSortIndex(LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_SORT_CREASING)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>na giving an array of indices that would sort the input array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetBinSortIndex(LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_SORT_CREASING)">
	<summary>
 Notes
 (1) This creates an array (or lookup table) that contains
 the sorted position of the elements in the input Numa.
 (2) Because it uses a bin sort with buckets of size 1, it
 is not appropriate for sorting either small arrays or
 arrays containing very large integer values.  For such
 arrays, use a standard general sort function like
 numaGetSortIndex().
 </summary>
	<remarks>
	</remarks>
	<param name="nas">of non-negative integers with a max that is typically less than 1,000,000</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>na sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSortByIndex(LeptonicaSharp.Numa,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="naindex">na that maps from the new numa to the input numa</param>
	<returns>nad sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaIsSorted(LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_SORT_CREASING,System.Int32@)">
	<summary>
 Notes
 (1) This is a quick O(n) test if nas is sorted.  It is useful
 in situations where the array is likely to be already
 sorted, and a sort operation can be avoided.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<param name="psorted">1 if sorted; 0 if not</param>
	<returns>1 if OK; 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSortPair(LeptonicaSharp.Numa,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_SORT_CREASING,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This function sorts the two input arrays, nax and nay,
 together, using nax as the key for sorting.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">input arrays</param>
	<param name="nay">input arrays</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<param name="pnasx">sorted</param>
	<param name="pnasy">sorted exactly in order of nasx</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaInvertMap(LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) This requires that nas contain each integer from 0 to n-1.
 The array is typically an index array into a sort or permutation
 of another array.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<returns>nad the inverted map, or NULL on error or if not invertible</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaPseudorandomSequence(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This uses the Durstenfeld shuffle.
 See http//en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle.
 Result is a pseudorandom permutation of the sequence of integers
 from 0 to size - 1.
 </summary>
	<remarks>
	</remarks>
	<param name="size">of sequence</param>
	<param name="seed">for random number generation</param>
	<returns>na pseudorandom on {0,...,size - 1}, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaRandomPermutation(LeptonicaSharp.Numa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas">input array</param>
	<param name="seed">for random number generation</param>
	<returns>nas randomly shuffled array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetRankValue(LeptonicaSharp.Numa,System.Single,System.Int32,System.Single[]@,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) Computes the rank value of a number in the %na, which is
 the number that is a fraction %fract from the small
 end of the sorted version of %na.
 (2) If you do this multiple times for different rank values,
 sort the array in advance and use that for %nasort;
 if you're only calling this once, input %nasort == NULL.
 (3) If %usebins == 1, this uses a bin sorting method.
 Use this only where
 the numbers are non-negative integers
 there are over 100 numbers
 the maximum value is less than about 50,000
 (4) The advantage of using a bin sort is that it is O(n),
 instead of O(nlogn) for general sort routines.
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="fract">use 0.0 for smallest, 1.0 for largest</param>
	<param name="nasort">increasing sorted version of na</param>
	<param name="usebins">0 for general sort; 1 for bin sort</param>
	<param name="pval">rank val</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetMedian(LeptonicaSharp.Numa,System.Single[]@)">
	<summary>
 Notes
 (1) Computes the median value of the numbers in the numa, by
 sorting and finding the middle value in the sorted array.
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pval">median value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetBinnedMedian(LeptonicaSharp.Numa,System.Int32@)">
	<summary>
 Notes
 (1) Computes the median value of the numbers in the numa,
 using bin sort and finding the middle value in the sorted array.
 (2) See numaGetRankValue() for conditions on na for which
 this should be used.  Otherwise, use numaGetMedian().
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pval">integer median value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetMode(LeptonicaSharp.Numa,System.Single[]@,System.Int32@)">
	<summary>
 Notes
 (1) Computes the mode value of the numbers in the numa, by
 sorting and finding the value of the number with the
 largest count.
 (2) Optionally, also returns that count.
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pval">mode val</param>
	<param name="pcount">mode count</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetMedianVariation(LeptonicaSharp.Numa,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) Finds the median of the absolute value of the variation from
 the median value in the array.  Why take the absolute value?
 Consider the case where you have values equally distributed
 about both sides of a median value.  Without taking the absolute
 value of the differences, you will get 0 for the variation,
 and this is not useful.
 </summary>
	<remarks>
	</remarks>
	<param name="na">source numa</param>
	<param name="pmedval">median value</param>
	<param name="pmedvar">median variation from median val</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaJoin(LeptonicaSharp.Numa,System.Int32,System.Int32,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (2) iend LT 0 means 'read to the end'
 (3) if nas == NULL, this is a no-op
 </summary>
	<remarks>
	</remarks>
	<param name="nad">dest numa; add to this one</param>
	<param name="nas">source numa; add from this one</param>
	<param name="istart">starting index in nas</param>
	<param name="iend">ending index in nas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaJoin(LeptonicaSharp.Numaa,System.Int32,System.Int32,LeptonicaSharp.Numaa)">
	<summary>
 Notes
 (1) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (2) iend LT 0 means 'read to the end'
 (3) if naas == NULL, this is a no-op
 </summary>
	<remarks>
	</remarks>
	<param name="naad">dest naa; add to this one</param>
	<param name="naas">source naa; add from this one</param>
	<param name="istart">starting index in nas</param>
	<param name="iend">ending index in naas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaaFlattenToNuma(LeptonicaSharp.Numaa)">
	<summary>
 Notes
 (1) This 'flattens' the Numaa to a Numa, by joining successively
 each Numa in the Numaa.
 (2) It doesn't make any assumptions about the location of the
 Numas in the Numaa array, unlike most Numaa functions.
 (3) It leaves the input Numaa unchanged.
 </summary>
	<remarks>
	</remarks>
	<param name="naa"></param>
	<returns>numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaErode(LeptonicaSharp.Numa,System.Int32)">
	<summary>
 Notes
 (1) The structuring element (sel) is linear, all "hits"
 (2) If size == 1, this returns a copy
 (3) General comment.  The morphological operations are equivalent
 to those that would be performed on a 1-dimensional fpix.
 However, because we have not implemented morphological
 operations on fpix, we do this here.  Because it is only
 1 dimensional, there is no reason to use the more
 complicated van Herk/Gil-Werman algorithm, and we do it
 by brute force.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="size">of sel; greater than 0, odd; origin implicitly in center</param>
	<returns>nad eroded, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaDilate(LeptonicaSharp.Numa,System.Int32)">
	<summary>
 Notes
 (1) The structuring element (sel) is linear, all "hits"
 (2) If size == 1, this returns a copy
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="size">of sel; greater than 0, odd; origin implicitly in center</param>
	<returns>nad dilated, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaOpen(LeptonicaSharp.Numa,System.Int32)">
	<summary>
 Notes
 (1) The structuring element (sel) is linear, all "hits"
 (2) If size == 1, this returns a copy
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="size">of sel; greater than 0, odd; origin implicitly in center</param>
	<returns>nad opened, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaClose(LeptonicaSharp.Numa,System.Int32)">
	<summary>
 Notes
 (1) The structuring element (sel) is linear, all "hits"
 (2) If size == 1, this returns a copy
 (3) We add a border before doing this operation, for the same
 reason that we add a border to a pix before doing a safe closing.
 Without the border, a small component near the border gets
 clipped at the border on dilation, and can be entirely removed
 by the following erosion, violating the basic extensivity
 property of closing.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="size">of sel; greater than 0, odd; origin implicitly in center</param>
	<returns>nad opened, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaTransform(LeptonicaSharp.Numa,System.Single,System.Single)">
	<summary>
 Notes
 (1) Each number is shifted before scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="shift">add this to each number</param>
	<param name="scale">multiply each number by this</param>
	<returns>nad with all values shifted and scaled, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSimpleStats(LeptonicaSharp.Numa,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">input numa</param>
	<param name="first">first element to use</param>
	<param name="last">last element to use; 0 to go to the end</param>
	<param name="pmean">mean value</param>
	<param name="pvar">variance</param>
	<param name="prvar">rms deviation from the mean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaWindowedStats(LeptonicaSharp.Numa,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This is a high-level convenience function for calculating
 any or all of these derived arrays.
 (2) These statistical measures over the values in the
 rectangular window are
 ~ average value [x]  (nam)
 ~ average squared value [xx] (nams)
 ~ variance [(x - [x])(x - [x])] = [xx] - [x][x]  (nav)
 ~ square-root of variance (narv)
 where the brackets [ .. ] indicate that the average value is
 to be taken over the window.
 (3) Note that the variance is just the mean square difference from
 the mean value; and the square root of the variance is the
 root mean square difference from the mean, sometimes also
 called the 'standard deviation'.
 (4) Internally, use mirrored borders to handle values near the
 end of each array.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input numa</param>
	<param name="wc">half width of the window</param>
	<param name="pnam">mean value in window</param>
	<param name="pnams">mean square value in window</param>
	<param name="pnav">variance in window</param>
	<param name="pnarv">rms deviation from the mean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaWindowedMean(LeptonicaSharp.Numa,System.Int32)">
	<summary>
 Notes
 (1) This is a convolution.  The window has width = 2  %wc + 1.
 (2) We add a mirrored border of size %wc to each end of the array.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="wc">half width of the convolution window</param>
	<returns>nad after low-pass filtering, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaWindowedMeanSquare(LeptonicaSharp.Numa,System.Int32)">
	<summary>
 Notes
 (1) The window has width = 2  %wc + 1.
 (2) We add a mirrored border of size %wc to each end of the array.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="wc">half width of the window</param>
	<returns>nad containing windowed mean square values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaWindowedVariance(LeptonicaSharp.Numa,LeptonicaSharp.Numa,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The numas of windowed mean and mean square are precomputed,
 using numaWindowedMean() and numaWindowedMeanSquare().
 (2) Either or both of the variance and square-root of variance
 are returned, where the variance is the average over the
 window of the mean square difference of the pixel value
 from the mean
 [(x - [x])(x - [x])] = [xx] - [x][x]
 </summary>
	<remarks>
	</remarks>
	<param name="nam">windowed mean values</param>
	<param name="nams">windowed mean square values</param>
	<param name="pnav">numa of variance -- the ms deviation from the mean</param>
	<param name="pnarv">numa of rms deviation from the mean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaWindowedMedian(LeptonicaSharp.Numa,System.Int32)">
	<summary>
 Notes
 (1) The requested window has width = 2  %halfwin + 1.
 (2) If the input nas has less then 3 elements, return a copy.
 (3) If the filter is too small (%halfwin LT= 0), return a copy.
 (4) If the filter is too large, it is reduced in size.
 (5) We add a mirrored border of size %halfwin to each end of
 the array to simplify the calculation by avoiding end-effects.
 </summary>
	<remarks>
	</remarks>
	<param name="nas"></param>
	<param name="halfwin">half width of window over which the median is found</param>
	<returns>nad after windowed median filtering, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaConvertToInt(LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas">source numa</param>
	<returns>na with all values rounded to nearest integer, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaMakeHistogram(LeptonicaSharp.Numa,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This simple interface is designed for integer data.
 The bins are of integer width and start on integer boundaries,
 so the results on float data will not have high precision.
 (2) Specify the max number of input bins.   Then %binsize,
 the size of bins necessary to accommodate the input data,
 is returned.  It is one of the sequence
 {1, 2, 5, 10, 20, 50, ...}.
 (3) If binstart is given, all values are accommodated,
 and the min value of the starting bin is returned.
 Otherwise, all negative values are discarded and
 the histogram bins start at 0.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="maxbins">max number of histogram bins</param>
	<param name="pbinsize">size of histogram bins</param>
	<param name="pbinstart">start val of minimum bin; input NULL to force start at 0</param>
	<returns>na consisiting of histogram of integerized values, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaMakeHistogramAuto(LeptonicaSharp.Numa,System.Int32)">
	<summary>
 Notes
 (1) This simple interface is designed for accurate binning
 of both integer and float data.
 (2) If the array data is integers, and the range of integers
 is smaller than %maxbins, they are binned as they fall,
 with binsize = 1.
 (3) If the range of data, (maxval - minval), is larger than
 %maxbins, or if the data is floats, they are binned into
 exactly %maxbins bins.
 (4) Unlike numaMakeHistogram(), these bins in general have
 non-integer location and width, even for integer data.
 </summary>
	<remarks>
	</remarks>
	<param name="na">numa of floats; these may be integers</param>
	<param name="maxbins">max number of histogram bins; GT= 1</param>
	<returns>na consisiting of histogram of quantized float values, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaMakeHistogramClipped(LeptonicaSharp.Numa,System.Single,System.Single)">
	<summary>
 Notes
 (1) This simple function generates a histogram of values
 from na, discarding all values LT 0.0 or greater than
 min(%maxsize, maxval), where maxval is the maximum value in na.
 The histogram data is put in bins of size delx = %binsize,
 starting at x = 0.0.  We use as many bins as are
 needed to hold the data.
 </summary>
	<remarks>
	</remarks>
	<param name="na"></param>
	<param name="binsize">typically 1.0</param>
	<param name="maxsize">of histogram ordinate</param>
	<returns>na histogram of bins of size %binsize, starting with the na[0] (x = 0.0 and going up to a maximum of x = %maxsize, by increments of %binsize), or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaRebinHistogram(LeptonicaSharp.Numa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas">input histogram</param>
	<param name="newsize">number of old bins contained in each new bin</param>
	<returns>nad more coarsely re-binned histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaNormalizeHistogram(LeptonicaSharp.Numa,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nas">input histogram</param>
	<param name="tsum">target sum of all numbers in dest histogram; e.g., use %tsum= 1.0 if this represents a probability distribution</param>
	<returns>nad normalized histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetStatsUsingHistogram(LeptonicaSharp.Numa,System.Int32,System.Single,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This is a simple interface for gathering statistics
 from a numa, where a histogram is used 'under the covers'
 to avoid sorting if a rank value is requested.  In that case,
 by using a histogram we are trading speed for accuracy, because
 the values in %na are quantized to the center of a set of bins.
 (2) If the median, other rank value, or histogram are not requested,
 the calculation is all performed on the input Numa.
 (3) The variance is the average of the square of the
 difference from the mean.  The median is the value in na
 with rank 0.5.
 (4) There are two situations where this gives rank results with
 accuracy comparable to computing stastics directly on the input
 data, without binning into a histogram
 (a) the data is integers and the range of data is less than
 %maxbins, and
 (b) the data is floats and the range is small compared to
 %maxbins, so that the binsize is much less than 1.
 (5) If a histogram is used and the numbers in the Numa extend
 over a large range, you can limit the required storage by
 specifying the maximum number of bins in the histogram.
 Use %maxbins == 0 to force the bin size to be 1.
 (6) This optionally returns the median and one arbitrary rank value.
 If you need several rank values, return the histogram and use
 numaHistogramGetValFromRank(nah, rank, rval)
 multiple times.
 </summary>
	<remarks>
	</remarks>
	<param name="na">an arbitrary set of numbers; not ordered and not a histogram</param>
	<param name="maxbins">the maximum number of bins to be allowed in the histogram; use an integer larger than the largest number in %na for consecutive integer bins</param>
	<param name="pmin">min value of set</param>
	<param name="pmax">max value of set</param>
	<param name="pmean">mean value of set</param>
	<param name="pvariance">variance</param>
	<param name="pmedian">median value of set</param>
	<param name="rank">in [0.0 ... 1.0]; median has a rank 0.5; ignored if rval == NULL</param>
	<param name="prval">value in na corresponding to %rank</param>
	<param name="phisto">Numa histogram; use NULL to prevent</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetHistogramStats(LeptonicaSharp.Numa,System.Single,System.Single,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) If the histogram represents the relation y(x), the
 computed values that are returned are the x values.
 These are NOT the bucket indices i; they are related to the
 bucket indices by
 x(i) = startx + i  deltax
 </summary>
	<remarks>
	</remarks>
	<param name="nahisto">histogram y(x(i)), i = 0 ... nbins - 1</param>
	<param name="startx">x value of first bin x(0)</param>
	<param name="deltax">x increment between bins; the bin size; x(1) - x(0)</param>
	<param name="pxmean">mean value of histogram</param>
	<param name="pxmedian">median value of histogram</param>
	<param name="pxmode">mode value of histogram xmode = x(imode), where y(xmode) GT= y(x(i)) for all i != imode</param>
	<param name="pxvariance">variance of x</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetHistogramStatsOnInterval(LeptonicaSharp.Numa,System.Single,System.Single,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) If the histogram represents the relation y(x), the
 computed values that are returned are the x values.
 These are NOT the bucket indices i; they are related to the
 bucket indices by
 x(i) = startx + i  deltax
 </summary>
	<remarks>
	</remarks>
	<param name="nahisto">histogram y(x(i)), i = 0 ... nbins - 1</param>
	<param name="startx">x value of first bin x(0)</param>
	<param name="deltax">x increment between bins; the bin size; x(1) - x(0)</param>
	<param name="ifirst">first bin to use for collecting stats</param>
	<param name="ilast">last bin for collecting stats; use 0 to go to the end</param>
	<param name="pxmean">mean value of histogram</param>
	<param name="pxmedian">median value of histogram</param>
	<param name="pxmode">mode value of histogram xmode = x(imode), where y(xmode) GT= y(x(i)) for all i != imode</param>
	<param name="pxvariance">variance of x</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaMakeRankFromHistogram(System.Single,System.Single,LeptonicaSharp.Numa,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="startx">xval corresponding to first element in nay</param>
	<param name="deltax">x increment between array elements in nay</param>
	<param name="nasy">input histogram, assumed equally spaced</param>
	<param name="npts">number of points to evaluate rank function</param>
	<param name="pnax">array of x values in range</param>
	<param name="pnay">rank array of specified npts</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaHistogramGetRankFromVal(LeptonicaSharp.Numa,System.Single,System.Single[]@)">
	<summary>
 Notes
 (1) If we think of the histogram as a function y(x), normalized
 to 1, for a given input value of x, this computes the
 rank of x, which is the integral of y(x) from the start
 value of x to the input value.
 (2) This function only makes sense when applied to a Numa that
 is a histogram.  The values in the histogram can be ints and
 floats, and are computed as floats.  The rank is returned
 as a float between 0.0 and 1.0.
 (3) The numa parameters startx and binsize are used to
 compute x from the Numa index i.
 </summary>
	<remarks>
	</remarks>
	<param name="na">histogram</param>
	<param name="rval">value of input sample for which we want the rank</param>
	<param name="prank">fraction of total samples below rval</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaHistogramGetValFromRank(LeptonicaSharp.Numa,System.Single,System.Single[]@)">
	<summary>
 Notes
 (1) If we think of the histogram as a function y(x), this returns
 the value x such that the integral of y(x) from the start
 value to x gives the fraction 'rank' of the integral
 of y(x) over all bins.
 (2) This function only makes sense when applied to a Numa that
 is a histogram.  The values in the histogram can be ints and
 floats, and are computed as floats.  The val is returned
 as a float, even though the buckets are of integer width.
 (3) The numa parameters startx and binsize are used to
 compute x from the Numa index i.
 </summary>
	<remarks>
	</remarks>
	<param name="na">histogram</param>
	<param name="rank">fraction of total samples</param>
	<param name="prval">approx. to the bin value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaDiscretizeRankAndIntensity(LeptonicaSharp.Numa,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) We are inverting the rank(intensity) function to get
 the intensity(rank) function at %nbins equally spaced
 values of rank between 0.0 and 1.0.  We save integer values
 for the intensity.
 (2) We are using the word "intensity" to describe the type of
 array values, but any array of non-negative numbers will work.
 (3) The output arrays give the following mappings, where the
 input is a normalized histogram of array values
 array values  --GT  rank bin number  (narbin)
 rank bin number  --GT  median array value in bin (nam)
 array values  --GT  cumulative norm = rank  (nar)
 rank bin number  --GT  array value at right bin edge (nabb)
 </summary>
	<remarks>
	</remarks>
	<param name="na">normalized histogram of probability density vs intensity</param>
	<param name="nbins">number of bins at which the rank is divided</param>
	<param name="pnarbin">rank bin value vs intensity</param>
	<param name="pnam">median intensity in a bin vs rank bin value, with %nbins of discretized rank values</param>
	<param name="pnar">rank vs intensity; this is a cumulative norm histogram</param>
	<param name="pnabb">intensity at the right bin boundary vs rank bin</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaGetRankBinValues(LeptonicaSharp.Numa,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) Simple interface for getting a binned rank representation
 of an input array of values.  This returns two mappings
 array value  --GT  rank bin number  (narbin)
 rank bin number --GT  median array value in each rank bin (nam)
 </summary>
	<remarks>
	</remarks>
	<param name="na">just an array of values</param>
	<param name="nbins">number of bins at which the rank is divided</param>
	<param name="pnarbin">rank bin value vs array value</param>
	<param name="pnam">median intensity in a bin vs rank bin value, with %nbins of discretized rank values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSplitDistribution(LeptonicaSharp.Numa,System.Single,System.Int32@,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This function is intended to be used on a distribution of
 values that represent two sets, such as a histogram of
 pixel values for an image with a fg and bg, and the goal
 is to determine the averages of the two sets and the
 best splitting point.
 (2) The Otsu method finds a split point that divides the distribution
 into two parts by maximizing a score function that is the
 product of two terms
 (a) the square of the difference of centroids, (ave1 - ave2)^2
 (b) fract1  (1 - fract1)
 where fract1 is the fraction in the lower distribution.
 (3) This works well for images where the fg and bg are
 each relatively homogeneous and well-separated in color.
 However, if the actual fg and bg sets are very different
 in size, and the bg is highly varied, as can occur in some
 scanned document images, this will bias the split point
 into the larger "bump" (i.e., toward the point where the
 (b) term reaches its maximum of 0.25 at fract1 = 0.5.
 To avoid this, we define a range of values near the
 maximum of the score function, and choose the value within
 this range such that the histogram itself has a minimum value.
 The range is determined by scorefract we include all abscissa
 values to the left and right of the value that maximizes the
 score, such that the score stays above (1 - scorefract)  maxscore.
 The intuition behind this modification is to try to find
 a split point that both has a high variance score and is
 at or near a minimum in the histogram, so that the histogram
 slope is small at the split point.
 (4) We normalize the score so that if the two distributions
 were of equal size and at opposite ends of the numa, the
 score would be 1.0.
 </summary>
	<remarks>
	</remarks>
	<param name="na">histogram</param>
	<param name="scorefract">fraction of the max score, used to determine the range over which the histogram min is searched</param>
	<param name="psplitindex">index for splitting</param>
	<param name="pave1">average of lower distribution</param>
	<param name="pave2">average of upper distribution</param>
	<param name="pnum1">population of lower distribution</param>
	<param name="pnum2">population of upper distribution</param>
	<param name="pnascore">for debugging; otherwise use NULL</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.grayHistogramsToEMD(LeptonicaSharp.Numaa,LeptonicaSharp.Numaa,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The two numaas must be the same size and have corresponding
 256-element histograms.  Pairs do not need to be normalized
 to the same sum.
 (2) This is typically used on two sets of histograms from
 corresponding tiles of two images.  The similarity of two
 images can be found with the scoring function used in
 pixCompareGrayByHisto()
 score S = 1.0 - k  D, where
 k is a constant, say in the range 5-10
 D = EMD
 for each tile; for multiple tiles, take the Min(S) over
 the set of tiles to be the final score.
 </summary>
	<remarks>
	</remarks>
	<param name="naa1">two numaa, each with one or more 256-element histograms</param>
	<param name="naa2">two numaa, each with one or more 256-element histograms</param>
	<param name="pnad">nad of EM distances for each histogram</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaEarthMoverDistance(LeptonicaSharp.Numa,LeptonicaSharp.Numa,System.Single[]@)">
	<summary>
 Notes
 (1) The two numas must have the same size.  They do not need to be
 normalized to the same sum before applying the function.
 (2) For a 1D discrete function, the implementation of the EMD
 is trivial.  Just keep filling or emptying buckets in one numa
 to match the amount in the other, moving sequentially along
 both arrays.
 (3) We divide the sum of the absolute value of everything moved
 (by 1 unit at a time) by the sum of the numa (amount of "earth")
 to get the average distance that the "earth" was moved.
 This is the value returned here.
 (4) The caller can do a further normalization, by the number of
 buckets (minus 1), to get the EM distance as a fraction of
 the maximum possible distance, which is n-1.  This fraction
 is 1.0 for the situation where all the 'earth' in the first
 array is at one end, and all in the second array is at the
 other end.
 </summary>
	<remarks>
	</remarks>
	<param name="na1">two numas of the same size, typically histograms</param>
	<param name="na2">two numas of the same size, typically histograms</param>
	<param name="pdist">EM distance</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.grayInterHistogramStats(LeptonicaSharp.Numaa,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The %naa has two or more 256-element numa histograms, which
 are to be compared value-wise at each of the 256 gray levels.
 The result are stats (mean, mean square, variance, root variance)
 aggregated across the set of histograms, and each is output
 as a 256 entry numa.  Think of these histograms as a matrix,
 where each histogram is one row of the array.  The stats are
 then aggregated column-wise, between the histograms.
 (2) These stats are
 ~ average value LTvGT  (nam)
 ~ average squared value LTvvGT (nams)
 ~ variance LT(v - LTvGT)(v - LTvGT)GT = LTvvGT - LTvGTLTvGT  (nav)
 ~ square-root of variance (narv)
 where the brackets LT .. GT indicate that the average value is
 to be taken over each column of the array.
 (3) The input histograms are optionally smoothed before these
 statistical operations.
 (4) The input histograms are normalized to a sum of 10000.  By
 doing this, the resulting numbers are independent of the
 number of samples used in building the individual histograms.
 (5) A typical application is on a set of histograms from tiles
 of an image, to distinguish between text/tables and photo
 regions.  If the tiles are much larger than the text line
 spacing, text/table regions typically have smaller variance
 across tiles than photo regions.  For this application, it
 may be useful to ignore values near white, which are large for
 text and would magnify the variance due to variations in
 illumination.  However, because the variance of a drawing or
 a light photo can be similar to that of grayscale text, this
 function is only a discriminator between darker photos/drawings
 and light photos/text/line-graphics.
 </summary>
	<remarks>
	</remarks>
	<param name="naa">numaa with two or more 256-element histograms</param>
	<param name="wc">half-width of the smoothing window</param>
	<param name="pnam">mean values</param>
	<param name="pnams">mean square values</param>
	<param name="pnav">variances</param>
	<param name="pnarv">rms deviations from the mean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaFindPeaks(LeptonicaSharp.Numa,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) The returned na consists of sets of four numbers representing
 the peak, in the following order
 left edge; peak center; right edge; normalized peak area
 </summary>
	<remarks>
	</remarks>
	<param name="nas">source numa</param>
	<param name="nmax">max number of peaks to be found</param>
	<param name="fract1">min fraction of peak value</param>
	<param name="fract2">min slope</param>
	<returns>peak na, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaFindExtrema(LeptonicaSharp.Numa,System.Single,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This returns a sequence of extrema (peaks and valleys).
 (2) The algorithm is analogous to that for determining
 mountain peaks.  Suppose we have a local peak, with
 bumps on the side.  Under what conditions can we consider
 those 'bumps' to be actual peaks?  The answer if the
 bump is separated from the peak by a saddle that is at
 least 500 feet below the bump.
 (3) Operationally, suppose we are looking for a peak.
 We are keeping the largest value we've seen since the
 last valley, and are looking for a value that is delta
 BELOW our current peak.  When we find such a value,
 we label the peak, use the current value to label the
 valley, and then do the same operation in reverse (looking
 for a valley).
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input values</param>
	<param name="delta">relative amount to resolve peaks and valleys</param>
	<param name="pnav">values of extrema</param>
	<returns>nad (locations of extrema, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaCountReversals(LeptonicaSharp.Numa,System.Single,System.Single[]@,System.Int32@)">
	<summary>
 Notes
 (1) The input numa is can be generated from pixExtractAlongLine().
 If so, the x parameters can be used to find the reversal
 frequency along a line.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">input values</param>
	<param name="minreversal">relative amount to resolve peaks and valleys</param>
	<param name="pnr">number of reversals</param>
	<param name="pnrpl">([optional] reversal density reversals/length</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaSelectCrossingThreshold(LeptonicaSharp.Numa,System.Single,System.Single[]@,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) When a valid threshold is used, the number of crossings is
 a maximum, because none are missed.  If no threshold intersects
 all the crossings, the crossings must be determined with
 numaCrossingsByPeaks().
 (2) %estthresh is an input estimate of the threshold that should
 be used.  We compute the crossings with 41 thresholds
 (20 below and 20 above).  There is a range in which the
 number of crossings is a maximum.  Return a threshold
 in the center of this stable plateau of crossings.
 This can then be used with numaCrossingsByThreshold()
 to get a good estimate of crossing locations.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values; can be NULL</param>
	<param name="nay">signal</param>
	<param name="estthresh">estimated pixel threshold for crossing e.g., for images, white LT--GT black; typ. ~120</param>
	<param name="pbestthresh">robust estimate of threshold to use</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaCrossingsByThreshold(LeptonicaSharp.Numa,System.Single,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) If nax == NULL, we use startx and delx from nay to compute
 the crossing values in nad.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values; can be NULL</param>
	<param name="nay">numa of ordinate values, corresponding to nax</param>
	<param name="thresh">threshold value for nay</param>
	<returns>nad abscissa pts at threshold, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaCrossingsByPeaks(LeptonicaSharp.Numa,System.Single,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) If nax == NULL, we use startx and delx from nay to compute
 the crossing values in nad.
 </summary>
	<remarks>
	</remarks>
	<param name="nax">numa of abscissa values</param>
	<param name="nay">numa of ordinate values, corresponding to nax</param>
	<param name="delta">parameter used to identify when a new peak can be found</param>
	<returns>nad abscissa pts at threshold, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaEvalBestHaarParameters(LeptonicaSharp.Numa,System.Single,System.Int32,System.Int32,System.Single,System.Single,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This does a linear sweep of widths, evaluating at %nshift
 shifts for each width, computing the score from a convolution
 with a long comb, and finding the (width, shift) pair that
 gives the maximum score.  The best width is the "half-wavelength"
 of the signal.
 (2) The convolving function is a comb of alternating values
 +1 and -1  relweight, separated by the width and phased by
 the shift.  This is similar to a Haar transform, except
 there the convolution is performed with a square wave.
 (3) The function is useful for finding the line spacing
 and strength of line signal from pixel sum projections.
 (4) The score is normalized to the size of nas divided by
 the number of half-widths.  For image applications, the input is
 typically an array of pixel projections, so one should
 normalize by dividing the score by the image width in the
 pixel projection direction.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">numa of non-negative signal values</param>
	<param name="relweight">relative weight of (-1 comb) / (+1 comb) contributions to the 'convolution'.  In effect, the convolution kernel is a comb consisting of alternating +1 and -weight.</param>
	<param name="nwidth">number of widths to consider</param>
	<param name="nshift">number of shifts to consider for each width</param>
	<param name="minwidth">smallest width to consider</param>
	<param name="maxwidth">largest width to consider</param>
	<param name="pbestwidth">width giving largest score</param>
	<param name="pbestshift">shift giving largest score</param>
	<param name="pbestscore">convolution with "Haar"-like comb</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaEvalHaarSum(LeptonicaSharp.Numa,System.Single,System.Single,System.Single,System.Single[]@)">
	<summary>
 Notes
 (1) This does a convolution with a comb of alternating values
 +1 and -relweight, separated by the width and phased by the shift.
 This is similar to a Haar transform, except that for Haar,
 (1) the convolution kernel is symmetric about 0, so the
 relweight is 1.0, and
 (2) the convolution is performed with a square wave.
 (2) The score is normalized to the size of nas divided by
 twice the "width".  For image applications, the input is
 typically an array of pixel projections, so one should
 normalize by dividing the score by the image width in the
 pixel projection direction.
 (3) To get a Haar-like result, use relweight = 1.0.  For detecting
 signals where you expect every other sample to be close to
 zero, as with barcodes or filtered text lines, you can
 use relweight GT 1.0.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">numa of non-negative signal values</param>
	<param name="width">distance between +1 and -1 in convolution comb</param>
	<param name="shift">phase of the comb location of first +1</param>
	<param name="relweight">relative weight of (-1 comb) / (+1 comb) contributions to the 'convolution'.  In effect, the convolution kernel is a comb consisting of alternating +1 and -weight.</param>
	<param name="pscore">convolution with "Haar"-like comb</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.genConstrainedNumaInRange(System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Selection is made uniformly in the range.  This can be used
 to select pages distributed as uniformly as possible
 through a book, where you are constrained to
 ~ choose between [first, ... biggest],
 ~ choose no more than nmax numbers, and
 and you have the option of requiring pairs of adjacent numbers.
 </summary>
	<remarks>
	</remarks>
	<param name="first">first number to choose; GT= 0</param>
	<param name="last">biggest possible number to reach; GT= first</param>
	<param name="nmax">maximum number of numbers to select; GT 0</param>
	<param name="use_pairs">1 = select pairs of adjacent numbers; 0 = select individual numbers</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRegionsBinary(LeptonicaSharp.Pix,LeptonicaSharp.Pixa,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) It is best to deskew the image before segmenting.
 (2) Passing in %pixadb enables debug output.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, assumed to be 300 to 400 ppi</param>
	<param name="ppixhm">halftone mask</param>
	<param name="ppixtm">textline mask</param>
	<param name="ppixtb">textblock mask</param>
	<param name="pixadb">input for collecting debug pix; use NULL to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenHalftoneMask(LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,System.Object@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Deprecated
 This wrapper avoids an ABI change with tesseract 3.0.4.
 It should be removed when we no longer need to support 3.0.4.
 The debug parameter is ignored (assumed 0).
 </summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenerateHalftoneMask(LeptonicaSharp.Pix,LeptonicaSharp.Pixa,LeptonicaSharp.Pix@,System.Int32@)">
	<summary>
 Notes
 (1) This is not intended to work on small thumbnails.  The
 dimensions of pixs must be at least MinWidth x MinHeight.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, assumed to be 150 to 200 ppi</param>
	<param name="ppixtext">text part of pixs</param>
	<param name="phtfound">1 if the mask is not empty</param>
	<param name="pixadb">input for collecting debug pix; use NULL to skip</param>
	<returns>pixd halftone mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenTextlineMask(LeptonicaSharp.Pix,LeptonicaSharp.Pix@,LeptonicaSharp.Pixa,System.Int32@)">
	<summary>
 Notes
 (1) The input pixs should be deskewed.
 (2) pixs should have no halftone pixels.
 (3) This is not intended to work on small thumbnails.  The
 dimensions of pixs must be at least MinWidth x MinHeight.
 (4) Both the input image and the returned textline mask
 are at the same resolution.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, assumed to be 150 to 200 ppi</param>
	<param name="ppixvws">vertical whitespace mask</param>
	<param name="ptlfound">1 if the mask is not empty</param>
	<param name="pixadb">input for collecting debug pix; use NULL to skip</param>
	<returns>pixd textline mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenTextblockMask(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) Both the input masks (textline and vertical white space) and
 the returned textblock mask are at the same resolution.
 (2) This is not intended to work on small thumbnails.  The
 dimensions of pixs must be at least MinWidth x MinHeight.
 (3) The result is somewhat noisy, in that small "blocks" of
 text may be included.  These can be removed by post-processing,
 using, e.g.,
 pixSelectBySize(pix, 60, 60, 4, L_SELECT_IF_EITHER,
 L_SELECT_IF_GTE, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, textline mask, assumed to be 150 to 200 ppi</param>
	<param name="pixvws">vertical white space mask</param>
	<param name="pixadb">input for collecting debug pix; use NULL to skip</param>
	<returns>pixd textblock mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindPageForeground(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.PixaComp)">
	<summary>
 Notes
 (1) This doesn't simply crop to the fg.  It attempts to remove
 pixel noise and junk at the edge of the image before cropping.
 The input %threshold is used if pixs is not 1 bpp.
 (2) This is not intended to work on small thumbnails.  The
 dimensions of pixs must be at least MinWidth x MinHeight.
 (3) Debug set showmorph to display the intermediate image in
 the morphological operations on this page.
 (4) Debug to get pdf output of results when called repeatedly,
 call with an existing pixac, which will add an image of this page,
 with the fg outlined.  If no foreground is found, there is
 no output for this page image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">full resolution (any type or depth</param>
	<param name="threshold">for binarization; typically about 128</param>
	<param name="mindist">min distance of text from border to allow cleaning near border; at 2x reduction, this should be larger than 50; typically about 70</param>
	<param name="erasedist">when conditions are satisfied, erase anything within this distance of the edge; typically 20-30 at 2x reduction</param>
	<param name="showmorph">debug set to a negative integer to show steps in generating masks; this is typically used for debugging region extraction</param>
	<param name="pixac">debug allocate outside and pass this in to accumulate results of each call to this function, which can be displayed in a mosaic or a pdf.</param>
	<returns>box region including foreground, with some pixel noise removed, or NULL if not found</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSplitIntoCharacters(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Boxa@,LeptonicaSharp.Pixa@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This is a simple function that attempts to find split points
 based on vertical pixel profiles.
 (2) It should be given an image that has an arbitrary number
 of text characters.
 (3) The returned pixa includes the boxes from which the
 (possibly split) components are extracted.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, contains only deskewed text</param>
	<param name="minw">min component width for initial filtering; typ. 4</param>
	<param name="minh">min component height for initial filtering; typ. 4</param>
	<param name="pboxa">character bounding boxes</param>
	<param name="ppixa">character images</param>
	<param name="ppixdebug">showing splittings</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSplitComponentWithProfile(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This will split the most obvious cases of touching characters.
 The split points it is searching for are narrow and deep
 minimima in the vertical pixel projection profile, after a
 large vertical closing has been applied to the component.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, exactly one connected component</param>
	<param name="delta">distance used in extrema finding in a numa; typ. 10</param>
	<param name="mindel">minimum required difference between profile minimum and profile values +2 and -2 away; typ. 7</param>
	<param name="ppixdebug">debug image of splitting</param>
	<returns>boxa of c.c. after splitting, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExtractTextlines(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) This function assumes that textline fragments have sufficient
 vertical separation and small enough skew so that a
 horizontal dilation sufficient to join words will not join
 textlines.  It does not guarantee that horizontally adjacent
 textline fragments on the same line will be joined.
 (2) For images with multiple columns, it attempts to avoid joining
 textlines across the space between columns.  If that is not
 a concern, you can also use pixExtractRawTextlines(),
 which will join them with alacrity.
 (3) This first removes components from pixs that are either
 wide (GT %maxw) or tall (GT %maxh).
 (4) A final filtering operation removes small components, such
 that width LT %minw or height LT %minh.
 (5) For reasonable accuracy, the resolution of pixs should be
 at least 100 ppi.  For reasonable efficiency, the resolution
 should not exceed 600 ppi.
 (6) This can be used to determine if some region of a scanned
 image is horizontal text.
 (7) As an example, for a pix with resolution 300 ppi, a reasonable
 set of parameters is
 pixExtractTextlines(pix, 150, 150, 36, 20, 5, 5, NULL);
 The defaults minw and minh for 300 ppi are about 36 and 20,
 so the same result is obtained with
 pixExtractTextlines(pix, 150, 150, 0, 0, 5, 5, NULL);
 (8) The output pixa is composed of subimages, one for each textline,
 and the boxa in the pixa tells where in %pixs each textline goes.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, assumed to have nearly horizontal text</param>
	<param name="maxw">initial filtering remove any components in pixs with components larger than maxw or maxh</param>
	<param name="maxh">initial filtering remove any components in pixs with components larger than maxw or maxh</param>
	<param name="minw">final filtering remove extracted 'lines' with sizes smaller than minw or minh; use 0 for default.</param>
	<param name="minh">final filtering remove extracted 'lines' with sizes smaller than minw or minh; use 0 for default.</param>
	<param name="adjw">final adjustment of boxes representing each text line.  If GT 0, these increase the box size at each edge by this amount.</param>
	<param name="adjh">final adjustment of boxes representing each text line.  If GT 0, these increase the box size at each edge by this amount.</param>
	<param name="pixadb">pixa for saving intermediate steps; NULL to omit</param>
	<returns>pixa of textline images, including bounding boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExtractRawTextlines(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) This function assumes that textlines have sufficient
 vertical separation and small enough skew so that a
 horizontal dilation sufficient to join words will not join
 textlines.  It aggressively joins textlines across multiple
 columns, so if that is not desired, you must either (a) make
 sure that %pixs is a single column of text or (b) use instead
 pixExtractTextlines(), which is more conservative
 about joining text fragments that have vertical overlap.
 (2) This first removes components from pixs that are either
 very wide (GT %maxw) or very tall (GT %maxh).
 (3) For reasonable accuracy, the resolution of pixs should be
 at least 100 ppi.  For reasonable efficiency, the resolution
 should not exceed 600 ppi.
 (4) This can be used to determine if some region of a scanned
 image is horizontal text.
 (5) As an example, for a pix with resolution 300 ppi, a reasonable
 set of parameters is
 pixExtractRawTextlines(pix, 150, 150, 0, 0, NULL);
 (6) The output pixa is composed of subimages, one for each textline,
 and the boxa in the pixa tells where in %pixs each textline goes.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, assumed to have nearly horizontal text</param>
	<param name="maxw">initial filtering remove any components in pixs with components larger than maxw or maxh; use 0 for default values.</param>
	<param name="maxh">initial filtering remove any components in pixs with components larger than maxw or maxh; use 0 for default values.</param>
	<param name="adjw">final adjustment of boxes representing each text line.  If GT 0, these increase the box size at each edge by this amount.</param>
	<param name="adjh">final adjustment of boxes representing each text line.  If GT 0, these increase the box size at each edge by this amount.</param>
	<param name="pixadb">pixa for saving intermediate steps; NULL to omit</param>
	<returns>pixa of textline images, including bounding boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCountTextColumns(LeptonicaSharp.Pix,System.Single,System.Single,System.Single,System.Int32@,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) It is assumed that pixs has the correct resolution set.
 If the resolution is 0, we set to 300 and issue a warning.
 (2) If necessary, the image is scaled to between 37 and 75 ppi;
 most of the processing is done at this resolution.
 (3) If no text is found (essentially a blank page),
 this returns ncols = 0.
 (4) For debug output, input a pre-allocated pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="deltafract">fraction of (max - min) to be used in the delta for extrema finding; typ 0.3</param>
	<param name="peakfract">fraction of (max - min) to be used to threshold the peak value; typ. 0.5</param>
	<param name="clipfract">fraction of image dimension removed on each side; typ. 0.1, which leaves w and h reduced by 0.8</param>
	<param name="pncols">number of columns; -1 if not determined</param>
	<param name="pixadb">pre-allocated, for showing intermediate computation; use null to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDecideIfText(LeptonicaSharp.Pix,System.Int32@,LeptonicaSharp.Box,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) It is assumed that pixs has the correct resolution set.
 If the resolution is 0, we set to 300 and issue a warning.
 (2) If necessary, the image is scaled to 300 ppi; most of the
 processing is done at this resolution.
 (3) Text is assumed to be in horizontal lines.
 (4) Because thin vertical lines are removed before filtering for
 text lines, this should identify tables as text.
 (5) If %box is null and pixs contains both text lines and line art,
 this function might return %istext == true.
 (6) If the input pixs is empty, or for some other reason the
 result can not be determined, return -1.
 (7) For debug output, input a pre-allocated pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="box">if null, use entire pixs</param>
	<param name="pistext">1 if text; 0 if photo; -1 if not determined or empty</param>
	<param name="pixadb">pre-allocated, for showing intermediate computation; use NULL to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindThreshFgExtent(LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="thresh">threshold number of pixels in row</param>
	<param name="ptop">location of top of region</param>
	<param name="pbot">location of bottom of region</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDecideIfTable(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_MODE,System.Int32@,LeptonicaSharp.Box,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) It is assumed that pixs has the correct resolution set.
 If the resolution is 0, we assume it is 300 ppi and issue a warning.
 (2) If %orient == L_LANDSCAPE_MODE, the image is rotated 90 degrees
 clockwise before being analyzed.
 (3) The interpretation of the returned score
 -1  undetermined
 0  no table
 1  unlikely to have a table
 2  likely to have a table
 3  even more likely to have a table
 4  extremely likely to have a table
 Setting the condition for finding a table at score GT= 2 works
 well, except for false positives on kanji and landscape text.
 These false positives can be removed by setting the condition
 at score GT= 3, but recall is lowered because it will not find
 tables without either horizontal or vertical lines.
 (4) Most of the processing takes place at 75 ppi.
 (5) Internally, three numbers are determined, for horizontal and
 vertical fg lines, and for vertical bg lines.  From these,
 four tests are made to decide if there is a table occupying
 a significant part of the image.
 (6) Images have arbitrary content and would be likely to trigger
 this detector, so they are checked for first, and if found,
 return with a 0 (no table) score.
 (7) Musical scores (tablature) are likely to trigger the detector.
 (8) Tables of content with more than 2 columns are likely to
 trigger the detector.
 (9) For debug output, input a pre-allocated pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, any resolution GT= 75 ppi</param>
	<param name="box">if null, use entire pixs</param>
	<param name="orient">L_PORTRAIT_MODE, L_LANDSCAPE_MODE</param>
	<param name="pscore">0 - 4; -1 if not determined</param>
	<param name="pixadb">pre-allocated, for showing intermediate computation; use NULL to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixPrepare1bpp(LeptonicaSharp.Pix,System.Single,System.Int32,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This handles some common pre-processing operations,
 where the page segmentation algorithm takes a 1 bpp image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="box">if null, use entire pixs</param>
	<param name="cropfract">fraction to be removed from the boundary; use 0.0 to retain the entire image</param>
	<param name="outres">desired resolution of output image; if the input image resolution is not set, assume 300 ppi; use 0 to skip scaling.</param>
	<returns>pixd if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixEstimateBackground(LeptonicaSharp.Pix,System.Int32,System.Single,System.Int32@)">
	<summary>
 Notes
 (1) Caller should check that return bg value is GT 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, with or without colormap</param>
	<param name="darkthresh">pixels below this value are never considered part of the background; typ. 70; use 0 to skip</param>
	<param name="edgecrop">fraction of half-width on each side, and of half-height at top and bottom, that are cropped</param>
	<param name="pbg">estimated background, or 0 on error</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindLargeRectangles(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Boxa@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This does a greedy search to find the largest rectangles,
 either black or white and without overlaps, in %pix.
 (2) See pixFindLargestRectangle(), which is called multiple
 times, for details.  On each call, the largest rectangle
 found is painted, so that none of its pixels can be
 used later, before calling it again.
 (3) This function is surprisingly fast.  Although
 pixFindLargestRectangle() runs at about 50 MPix/sec, when it
 is run multiple times by pixFindLargeRectangles(), it processes
 at 150 - 250 MPix/sec, and the time is approximately linear
 in %nrect.  For example, for a 1 MPix image, searching for
 the largest 50 boxes takes about 0.2 seconds.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="polarity">0 within background, 1 within foreground</param>
	<param name="nrect">number of rectangles to be found</param>
	<param name="pboxa">largest rectangles, sorted by decreasing area</param>
	<param name="ppixdb">optional return output with rectangles drawn on it</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindLargestRectangle(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Box@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This is a simple and elegant solution to a problem in
 computational geometry that at first appears to be quite
 difficult what is the largest rectangle that can be
 placed in the image, covering only pixels of one polarity
 (bg or fg)?  The solution is O(n), where n is the number
 of pixels in the image, and it requires nothing more than
 using a simple recursion relation in a single sweep of the image.
 (2) In a sweep from UL to LR with left-to-right being the fast
 direction, calculate the largest white rectangle at (x, y),
 using previously calculated values at pixels #1 and #2
 #1 (x, y - 1)
 #2 (x - 1, y)
 We also need the most recent "black" pixels that were seen
 in the current row and column.
 Consider the largest area.  There are only two possibilities
 (a)  Min(w(1), horizdist)  (h(1) + 1)
 (b)  Min(h(2), vertdist)  (w(2) + 1)
 where
 horizdist the distance from the rightmost "black" pixel seen
 in the current row across to the current pixel
 vertdist the distance from the lowest "black" pixel seen
 in the current column down to the current pixel
 and we choose the Max of (a) and (b).
 (3) To convince yourself that these recursion relations are correct,
 it helps to draw the maximum rectangles at #1 and #2.
 Then for #1, you try to extend the rectangle down one line,
 so that the height is h(1) + 1.  Do you get the full
 width of #1, w(1)?  It depends on where the black pixels are
 in the current row.  You know the final width is bounded by w(1)
 and w(2) + 1, but the actual value depends on the distribution
 of black pixels in the current row that are at a distance
 from the current pixel that is between these limits.
 We call that value "horizdist", and the area is then given
 by the expression (a) above.  Using similar reasoning for #2,
 where you attempt to extend the rectangle to the right
 by 1 pixel, you arrive at (b).  The largest rectangle is
 then found by taking the Max.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="polarity">0 within background, 1 within foreground</param>
	<param name="pbox">largest area rectangle</param>
	<param name="ppixdb">optional return output with rectangle drawn on it</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetSelectCmap(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) It sets all pixels in region that have the color specified
 by the colormap index 'sindex' to the new color.
 (3) sindex must be in the existing colormap; otherwise an
 error is returned.
 (4) If the new color exists in the colormap, it is used;
 otherwise, it is added to the colormap.  If it cannot be
 added because the colormap is full, an error is returned.
 (5) If box is NULL, applies function to the entire image; otherwise,
 clips the operation to the intersection of the box and pix.
 (6) An example of use would be to set to a specific color all
 the light (background) pixels within a certain region of
 a 3-level 2 bpp image, while leaving light pixels outside
 this region unchanged.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4 or 8 bpp, with colormap</param>
	<param name="box">region to set color; can be NULL</param>
	<param name="sindex">colormap index of pixels to be changed</param>
	<param name="rval">new color to paint</param>
	<param name="gval">new color to paint</param>
	<param name="bval">new color to paint</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorGrayRegionsCmap(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_PAINT,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
 preserving antialiasing.
 If type == L_PAINT_DARK, it colorizes non-white pixels,
 preserving antialiasing.  See pixColorGrayCmap() for details.
 (3) This can also be called through pixColorGrayRegions().
 (4) This increases the colormap size by the number of
 different gray (non-black or non-white) colors in the
 selected regions of pixs.  If there is not enough room in
 the colormap for this expansion, it returns 1 (error),
 and the caller should check the return value.
 (5) Because two boxes in the boxa can overlap, pixels that
 are colorized in the first box must be excluded in the
 second because their value exceeds the size of the map.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, with colormap</param>
	<param name="boxa">of regions in which to apply color</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="rval">target color</param>
	<param name="gval">target color</param>
	<param name="bval">target color</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorGrayCmap(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_PAINT,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
 preserving antialiasing.
 If type == L_PAINT_DARK, it colorizes non-white pixels,
 preserving antialiasing.
 (3) box gives the region to apply color; if NULL, this
 colorizes the entire image.
 (4) If the cmap is only 2 or 4 bpp, pixs is converted in-place
 to an 8 bpp cmap.  A 1 bpp cmap is not a valid input pix.
 (5) This can also be called through pixColorGray().
 (6) This operation increases the colormap size by the number of
 different gray (non-black or non-white) colors in the
 input colormap.  If there is not enough room in the colormap
 for this expansion, it returns 1 (error), and the caller
 should check the return value.
 (7) Using the darkness of each original pixel in the rect,
 it generates a new color (based on the input rgb values).
 If type == L_PAINT_LIGHT, the new color is a (generally)
 darken-to-black version of the  input rgb color, where the
 amount of darkening increases with the darkness of the
 original pixel color.
 If type == L_PAINT_DARK, the new color is a (generally)
 faded-to-white version of the  input rgb color, where the
 amount of fading increases with the brightness of the
 original pixel color.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp, with colormap</param>
	<param name="box">region to set color; can be NULL</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="rval">target color</param>
	<param name="gval">target color</param>
	<param name="bval">target color</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorGrayMaskedCmap(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_PAINT,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
 preserving antialiasing.
 If type == L_PAINT_DARK, it colorizes non-white pixels,
 preserving antialiasing.  See pixColorGrayCmap() for details.
 (3) This increases the colormap size by the number of
 different gray (non-black or non-white) colors in the
 input colormap.  If there is not enough room in the colormap
 for this expansion, it returns 1 (error).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, with colormap</param>
	<param name="pixm">1 bpp mask, through which to apply color</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="rval">target color</param>
	<param name="gval">target color</param>
	<param name="bval">target color</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.addColorizedGrayToCmap(LeptonicaSharp.PixColormap,LeptonicaSharp.Enumerations.L_PAINT,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
 preserving antialiasing.
 If type == L_PAINT_DARK, it colorizes non-white pixels,
 preserving antialiasing.
 (2) This increases the colormap size by the number of
 different gray (non-black or non-white) colors in the
 input colormap.  If there is not enough room in the colormap
 for this expansion, it returns 1 (treated as a warning);
 the caller should check the return value.
 (3) This can be used to determine if the new colors will fit in
 the cmap, using null for na.  Returns 0 if they fit; 2 if
 they don't fit.
 (4) The mapping table contains, for each gray color found, the
 index of the corresponding colorized pixel.  Non-gray
 pixels are assigned the invalid index 256.
 (5) See pixColorGrayCmap() for usage.
 </summary>
	<remarks>
	</remarks>
	<param name="cmap">from 2 or 4 bpp pix</param>
	<param name="type">L_PAINT_LIGHT, L_PAINT_DARK</param>
	<param name="rval">target color</param>
	<param name="gval">target color</param>
	<param name="bval">target color</param>
	<param name="pna">table for mapping new cmap entries</param>
	<returns>0 if OK; 1 on error; 2 if new colors will not fit in cmap.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetSelectMaskedCmap(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) This paints through the fg of pixm and replaces all pixels
 in pixs that have a particular value (sindex) with the new color.
 (3) If pixm == NULL, a warning is given.
 (4) sindex must be in the existing colormap; otherwise an
 error is returned.
 (5) If the new color exists in the colormap, it is used;
 otherwise, it is added to the colormap.  If the colormap
 is full, an error is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp, with colormap</param>
	<param name="pixm">1 bpp mask; no-op if NULL</param>
	<param name="x">UL corner of mask relative to pixs</param>
	<param name="y">UL corner of mask relative to pixs</param>
	<param name="sindex">colormap index of pixels in pixs to be changed</param>
	<param name="rval">new color to substitute</param>
	<param name="gval">new color to substitute</param>
	<param name="bval">new color to substitute</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetMaskedCmap(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) It paints a single color through the mask (as a stencil).
 (3) The mask origin is placed at (x,y) on pixs, and the
 operation is clipped to the intersection of the mask and pixs.
 (4) If pixm == NULL, a warning is given.
 (5) Typically, pixm is a small binary mask located somewhere
 on the larger pixs.
 (6) If the color is in the colormap, it is used.  Otherwise,
 it is added if possible; an error is returned if the
 colormap is already full.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp, colormapped</param>
	<param name="pixm">1 bpp mask; no-op if NULL</param>
	<param name="x">origin of pixm relative to pixs; can be negative</param>
	<param name="y">origin of pixm relative to pixs; can be negative</param>
	<param name="rval">new color to set at each masked pixel</param>
	<param name="gval">new color to set at each masked pixel</param>
	<param name="bval">new color to set at each masked pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.parseForProtos(System.String@,System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaGetWhiteblocks(LeptonicaSharp.Boxa,LeptonicaSharp.Box,LeptonicaSharp.Enumerations.L_SORT_BY,System.Int32,System.Single,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This uses the elegant Breuel algorithm, found in "Two
 Geometric Algorithms for Layout Analysis", 2002,
 url "citeseer.ist.psu.edu/breuel02two.html".
 It starts with the bounding boxes (b.b.) of the connected
 components (c.c.) in a region, along with the rectangle
 representing that region.  It repeatedly divides the
 rectangle into four maximal rectangles that exclude a
 pivot rectangle, sorting them in a priority queue
 according to one of the six sort flags.  It returns a boxa
 of the "largest" set that have no intersection with boxes
 from the input boxas.
 (2) If box == NULL, the initial region is the minimal region
 that includes the origin and every box in boxas.
 (3) maxboxes is the maximum number of whitespace boxes that will
 be returned.  The actual number will depend on the image
 and the values chosen for maxoverlap and maxpops.  In many
 cases, the actual number will be 'maxboxes'.
 (4) maxoverlap allows pruning of whitespace boxes depending on
 the overlap.  To avoid all pruning, use maxoverlap = 1.0.
 To select only boxes that have no overlap with each other
 (maximal pruning), choose maxoverlap = 0.0.
 Otherwise, no box can have more than the 'maxoverlap' fraction
 of its area overlapped by any larger (in the sense of the
 sortflag) box.
 (5) Choose maxperim (actually, maximum half-perimeter) to
 represent a c.c. that is small enough so that you don't care
 about the white space that could be inside of it.  For all such
 c.c., the pivot for 'quadfurcation' of a rectangle is selected
 as having a reasonable proximity to the rectangle centroid.
 (6) Use fract in the range [0.0 ... 1.0].  Set fract = 0.0
 to choose the small box nearest the centroid as the pivot.
 If you choose fract GT 0.0, it is suggested that you call
 boxaPermuteRandom() first, to permute the boxes (see usage below).
 This should reduce the search time for each of the pivot boxes.
 (7) Choose maxpops to be the maximum number of rectangles that
 are popped from the heap.  This is an indirect way to limit the
 execution time.  Use 0 for default (a fairly large number).
 At any time, you can expect the heap to contain about
 2.5 times as many boxes as have been popped off.
 (8) The output result is a sorted set of overlapping
 boxes, constrained by 'maxboxes', 'maxoverlap' and 'maxpops'.
 (9) The main defect of the method is that it abstracts out the
 actual components, retaining only the b.b. for analysis.
 Consider a component with a large b.b.  If this is chosen
 as a pivot, all white space inside is immediately taken
 out of consideration.  Furthermore, even if it is never chosen
 as a pivot, as the partitioning continues, at no time will
 any of the whitespace inside this component be part of a
 rectangle with zero overlapping boxes.  Thus, the interiors
 of all boxes are necessarily excluded from the union of
 the returned whitespace boxes.
 (10) It should be noted that the algorithm puts a large number
 of partels on the queue.  Setting a limit of X partels to
 remove from the queue, one typically finds that there will be
 several times that number (say, 2X - 3X) left on the queue.
 For an efficient algorithm to find the largest white or
 or black rectangles, without permitting them to overlap,
 see pixFindLargeRectangles().
 (11) USAGE One way to accommodate to this weakness is to remove such
 large b.b. before starting the computation.  For example,
 if 'box' is an input image region containing 'boxa' b.b. of c.c.
 // Faster pivot choosing
 boxaPermuteRandom(boxa, boxa);
 // Remove anything either large width or height
 boxat = boxaSelectBySize(boxa, maxwidth, maxheight,
 L_SELECT_IF_BOTH, L_SELECT_IF_LT,
 NULL);
 boxad = boxaGetWhiteblocks(boxat, box, type, maxboxes,
 maxoverlap, maxperim, fract,
 maxpops);
 The result will be rectangular regions of "white space" that
 extend into (and often through) the excluded components.
 (11) As a simple example, suppose you wish to find the columns on a page.
 First exclude large c.c. that may block the columns, and then call
 boxad = boxaGetWhiteblocks(boxa, box, L_SORT_BY_HEIGHT,
 20, 0.15, 200, 0.2, 2000);
 to get the 20 tallest boxes with no more than 0.15 overlap
 between a box and any of the taller ones, and avoiding the
 use of any c.c. with a b.b. half perimeter greater than 200
 as a pivot.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">typically, a set of bounding boxes of fg components</param>
	<param name="box">initial region; typically including all boxes in boxas; if null, it computes the region to include all boxes in boxas</param>
	<param name="sortflag">L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER, L_SORT_BY_AREA</param>
	<param name="maxboxes">maximum number of output whitespace boxes; e.g., 100</param>
	<param name="maxoverlap">maximum fractional overlap of a box by any of the larger boxes; e.g., 0.2</param>
	<param name="maxperim">maximum half-perimeter, in pixels, for which pivot is selected by proximity to box centroid; e.g., 200</param>
	<param name="fract">fraction of box diagonal that is an acceptable distance from the box centroid to select the pivot; e.g., 0.2</param>
	<param name="maxpops">maximum number of pops from the heap; use 0 as default</param>
	<returns>boxa of sorted whitespace boxes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaPruneSortedOnOverlap(LeptonicaSharp.Boxa,System.Single)">
	<summary>
 Notes
 (1) This selectively removes smaller boxes when they are overlapped
 by any larger box by more than the input 'maxoverlap' fraction.
 (2) To avoid all pruning, use maxoverlap = 1.0.  To select only
 boxes that have no overlap with each other (maximal pruning),
 set maxoverlap = 0.0.
 (3) If there are no boxes in boxas, returns an empty boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="boxas">sorted by size in decreasing order</param>
	<param name="maxoverlap">maximum fractional overlap of a box by any of the larger boxes</param>
	<returns>boxad pruned, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertFilesToPdf(System.String,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.String,System.String,System.String)">
	<summary>
 Notes
 (1) If %substr is not NULL, only image filenames that contain
 the substring can be used.  If %substr == NULL, all files
 in the directory are used.
 (2) The files in the directory, after optional filtering by
 the substring, are lexically sorted in increasing order
 before concatenation.
 (3) The scalefactor is applied to each image before encoding.
 If you enter a value LT= 0.0, it will be set to 1.0.
 (4) Specifying one of the three encoding types for %type forces
 all images to be compressed with that type.  Use 0 to have
 the type determined for each image based on depth and whether
 or not it has a colormap.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name containing images</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="res">input resolution of all images</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.saConvertFilesToPdf(LeptonicaSharp.Sarray,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) See convertFilesToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of pathnames for images</param>
	<param name="res">input resolution of all images</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.saConvertFilesToPdfData(LeptonicaSharp.Sarray,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.Byte[]@,System.UInt32@,System.String)">
	<summary>
 Notes
 (1) See convertFilesToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of pathnames for images</param>
	<param name="res">input resolution of all images</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="pdata">output pdf data (of all images</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selectDefaultPdfEncoding(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_ENCODE@)">
	<summary>
 Notes
 (1) This attempts to choose an encoding for the pix that results
 in the smallest file, assuming that if jpeg encoded, it will
 use quality = 75.  The decision is approximate, in that
 (a) all colormapped images will be losslessly encoded with
 gzip (flate), and (b) an image with less than about 20 colors
 is likely to be smaller if flate encoded than if encoded
 as a jpeg (dct).  For example, an image made by pixScaleToGray3()
 will have 10 colors, and flate encoding will give about
 twice the compression as jpeg with quality = 75.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="ptype">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertUnscaledFilesToPdf(System.String,System.String,System.String,System.String)">
	<summary>
 Notes
 (1) If %substr is not NULL, only image filenames that contain
 the substring can be used.  If %substr == NULL, all files
 in the directory are used.
 (2) The files in the directory, after optional filtering by
 the substring, are lexically sorted in increasing order
 before concatenation.
 (3) For jpeg and jp2k, this is very fast because the compressed
 data is wrapped up and concatenated.  For png and tiffg4,
 the images must be read and recompressed.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name containing images</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.saConvertUnscaledFilesToPdf(LeptonicaSharp.Sarray,System.String,System.String)">
	<summary>
 Notes
 (1) See convertUnscaledFilesToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of pathnames for images</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.saConvertUnscaledFilesToPdfData(LeptonicaSharp.Sarray,System.Byte[]@,System.UInt32@,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array of pathnames for images</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="pdata">output pdf data (of all images)</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertUnscaledToPdfData(System.String,System.Byte[]@,System.UInt32@,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">of image file</param>
	<param name="title">pdf title; can be NULL</param>
	<param name="pdata">output pdf data for image</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaConvertToPdf(LeptonicaSharp.Pixa,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without
 colormap and many colors, or 32 bpp; FLATE for anything else.
 (2) The scalefactor must be GT 0.0; otherwise it is set to 1.0.
 (3) Specifying one of the three encoding types for %type forces
 all images to be compressed with that type.  Use 0 to have
 the type determined for each image based on depth and whether
 or not it has a colormap.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">containing images all at the same resolution</param>
	<param name="res">override the resolution of each input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaConvertToPdfData(LeptonicaSharp.Pixa,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.Byte[]@,System.UInt32@,System.String)">
	<summary>
 Notes
 (1) See pixaConvertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">containing images all at the same resolution</param>
	<param name="res">input resolution of all images</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title</param>
	<param name="pdata">output pdf data (of all images</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertToPdf(System.String,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.String,System.Int32,System.Int32,System.Int32,LeptonicaSharp.L_Pdf_Data@,LeptonicaSharp.Enumerations.L_T_IMAGE,System.String)">
	<summary>
 Notes
 (1) To wrap only one image in pdf, input %plpd = NULL, and
 the value of %position will be ignored
 convertToPdf(...  type, quality, x, y, res, NULL, 0);
 (2) To wrap multiple images on a single pdf page, this is called
 once for each successive image.  Do it this way
 L_PDF_DATA   lpd;
 convertToPdf(...  type, quality, x, y, res, lpd, L_FIRST_IMAGE);
 convertToPdf(...  type, quality, x, y, res, lpd, L_NEXT_IMAGE);
 ...
 convertToPdf(...  type, quality, x, y, res, lpd, L_LAST_IMAGE);
 This will write the result to the value of %fileout specified
 in the first call; succeeding values of %fileout are ignored.
 On the last call the pdf data bytes are computed and written
 to %fileout, lpd is destroyed internally, and the returned
 value of lpd is null.  So the client has nothing to clean up.
 (3) (a) Set %res == 0 to respect the resolution embedded in the
 image file.  If no resolution is embedded, it will be set
 to the default value.
 (b) Set %res to some other value to override the file resolution.
 (4) (a) If the input %res and the resolution of the output device
 are equal, the image will be "displayed" at the same size
 as the original.
 (b) If the input %res is 72, the output device will render
 the image at 1 pt/pixel.
 (c) Some possible choices for the default input pix resolution are
 72 ppi  Render pix on any output device at one pt/pixel
 96 ppi  Windows default for generated display images
 300 ppi  Typical default for scanned images.
 We choose 300, which is sensible for rendering page images.
 However,  images come from a variety of sources, and
 some are explicitly created for viewing on a display.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input image file -- any format</param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="fileout">output pdf file; only required on last image on page</param>
	<param name="x">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="y">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title; if null, taken from filein</param>
	<param name="plpd">ptr to lpd, which is created on the first invocation and returned until last image is processed, at which time it is destroyed</param>
	<param name="position">in image sequence L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertImageDataToPdf(System.Byte[],System.UInt32,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.String,System.Int32,System.Int32,System.Int32,LeptonicaSharp.L_Pdf_Data@,LeptonicaSharp.Enumerations.L_T_IMAGE,System.String)">
	<summary>
 Notes
 (1) If %res == 0 and the input resolution field is 0,
 this will use DEFAULT_INPUT_RES.
 (2) See comments in convertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="imdata">array of formatted image data; e.g., png, jpeg</param>
	<param name="size">size of image data</param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="fileout">output pdf file; only required on last image on page</param>
	<param name="x">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="y">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title</param>
	<param name="plpd">ptr to lpd, which is created on the first invocation and returned until last image is processed, at which time it is destroyed</param>
	<param name="position">in image sequence L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertToPdfData(System.String,LeptonicaSharp.Enumerations.L_ENCODE,System.Byte[]@,System.UInt32@,LeptonicaSharp.L_Pdf_Data@,LeptonicaSharp.Enumerations.L_T_IMAGE,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) If %res == 0 and the input resolution field is 0,
 this will use DEFAULT_INPUT_RES.
 (2) See comments in convertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input image file -- any format</param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="pdata">pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<param name="x">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="y">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title; if null, use filein</param>
	<param name="plpd">ptr to lpd, which is created on the first invocation and returned until last image is processed, at which time it is destroyed</param>
	<param name="position">in image sequence L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertImageDataToPdfData(System.Byte[],System.UInt32,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.Byte[]@,System.UInt32@,System.Int32,System.Int32,System.Int32,LeptonicaSharp.L_Pdf_Data@,LeptonicaSharp.Enumerations.L_T_IMAGE,System.String)">
	<summary>
 Notes
 (1) If %res == 0 and the input resolution field is 0,
 this will use DEFAULT_INPUT_RES.
 (2) See comments in convertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="imdata">array of formatted image data; e.g., png, jpeg</param>
	<param name="size">size of image data</param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="pdata">pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<param name="x">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="y">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title</param>
	<param name="plpd">ptr to lpd, which is created on the first invocation and returned until last image is processed, at which time it is destroyed</param>
	<param name="position">in image sequence L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertToPdf(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_ENCODE,System.String,LeptonicaSharp.L_Pdf_Data@,LeptonicaSharp.Enumerations.L_T_IMAGE,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) If %res == 0 and the input resolution field is 0,
 this will use DEFAULT_INPUT_RES.
 (2) This only writes data to fileout if it is the last
 image to be written on the page.
 (3) See comments in convertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="fileout">output pdf file; only required on last image on page</param>
	<param name="x">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0 at the lower-left corner of the page)</param>
	<param name="y">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0 at the lower-left corner of the page)</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title</param>
	<param name="plpd">ptr to lpd, which is created on the first invocation and returned until last image is processed</param>
	<param name="position">in image sequence L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamPdf(LeptonicaSharp.FILE,LeptonicaSharp.Pix,System.Int32,System.String)">
	<summary>
 Notes
 (1) This is the simplest interface for writing a single image
 with pdf encoding to a stream.  It uses G4 encoding for 1 bpp,
 JPEG encoding for 8 bpp (no cmap) and 32 bpp, and FLATE
 encoding for everything else.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for writing</param>
	<param name="pix">all depths, cmap OK</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title; taken from the first image placed on a page; e.g., an input image filename</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMemPdf(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pix,System.Int32,System.String)">
	<summary>
 Notes
 (1) This is the simplest interface for writing a single image
 with pdf encoding to memory.  It uses G4 encoding for 1 bpp,
 JPEG encoding for 8 bpp (no cmap) and 32 bpp, and FLATE
 encoding for everything else.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">pdf as byte array</param>
	<param name="pnbytes">number of bytes in pdf array</param>
	<param name="pix">all depths, cmap OK</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title; taken from the first image placed on a page; e.g., an input image filename</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertSegmentedFilesToPdf(System.String,System.Int32,LeptonicaSharp.Enumerations.L_ENCODE,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.Single,System.String,System.String,LeptonicaSharp.Boxaa,System.String)">
	<summary>
 Notes
 (1) If %substr is not NULL, only image filenames that contain
 the substring can be used.  If %substr == NULL, all files
 in the directory are used.
 (2) The files in the directory, after optional filtering by
 the substring, are lexically sorted in increasing order
 before concatenation.
 (3) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without
 colormap and many colors, or 32 bpp; FLATE for anything else.
 (4) The boxaa, if it exists, contains one boxa of "image regions"
 for each image file.  The boxa must be aligned with the
 sorted set of images.
 (5) The scalefactor is applied to each image region.  It is
 typically LT 1.0, to save bytes in the final pdf, because
 the resolution is often not critical in non-text regions.
 (6) If the non-image regions have pixel depth GT 1 and the encoding
 type is G4, they are automatically scaled up by 2x and
 thresholded.  Otherwise, no scaling is performed on them.
 (7) Note that this function can be used to generate multipage
 G4 compressed pdf from any input, by using %boxaa == NULL
 and %type == L_G4_ENCODE.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name containing images</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="res">input resolution of all images</param>
	<param name="type">compression type for non-image regions; the image regions are always compressed with L_JPEG_ENCODE</param>
	<param name="thresh">used for converting gray --GT 1 bpp with L_G4_ENCODE</param>
	<param name="baa">boxaa of image regions</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="scalefactor">scaling factor applied to each image region</param>
	<param name="title">pdf title; if null, taken from the first image filename</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertNumberedMasksToBoxaa(System.String,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) This is conveniently used to generate the input boxaa
 for convertSegmentedFilesToPdf().  It guarantees that the
 boxa will be aligned with the page images, even if some
 of the boxa are empty.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name containing mask images</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="numpre">number of characters in name before number</param>
	<param name="numpost">number of characters in name after number, up to a dot before an extension including an extension and the dot separator</param>
	<returns>boxaa of mask regions, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertToPdfSegmented(System.String,System.Int32,LeptonicaSharp.Enumerations.L_ENCODE,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.Single,System.String,LeptonicaSharp.Boxa,System.String)">
	<summary>
 Notes
 (1) If there are no image regions, set %boxa == NULL;
 %quality and %scalefactor are ignored.
 (2) Typically, %scalefactor is LT 1.0, because the image regions
 can be rendered at a lower resolution (for better compression)
 than the text regions.  If %scalefactor == 0, we use 1.0.
 If the input image is 1 bpp and scalefactor LT 1.0, we
 use scaleToGray() to downsample the image regions to gray
 before compressing them.
 (3) If the compression type for non-image regions is L_G4_ENCODE
 and bpp GT 1, the image is upscaled 2x and thresholded
 to 1 bpp.  That is the only situation where %thresh is used.
 (4) The parameter %quality is only used for image regions.
 If %type == L_JPEG_ENCODE, default jpeg quality (75) is
 used for the non-image regions.
 (5) Processing matrix for non-image regions.
 Input  G4  JPEG FLATE
 ----------|---------------------------------------------------
 1 bpp  |  1x, 1 bpp 1x flate, 1 bpp  1x, 1 bpp
 |
 cmap   |  2x, 1 bpp 1x flate, cmap   1x, cmap
 |
 2,4 bpp   |  2x, 1 bpp 1x flate   1x, 2,4 bpp
 no cmap   |   2,4 bpp
 |
 8,32 bpp  |  2x, 1 bpp 1x (jpeg)  1x, 8,32 bpp
 no cmap   |   8,32 bpp
 Summary
 (a) if G4 is requested, G4 is used, with 2x upscaling
 for all cases except 1 bpp.
 (b) if JPEG is requested, use flate encoding for all cases
 except 8 bpp without cmap and 32 bpp (rgb).
 (c) if FLATE is requested, use flate with no transformation
 of the raster data.
 (6) Calling options/sequence for these functions
 file  --GT  file   (convertToPdfSegmented)
 pix  --GT  file   (pixConvertToPdfSegmented)
 pix  --GT  data   (pixConvertToPdfDataSegmented)
 file  --GT  data   (convertToPdfDataSegmented)
 pix  --GT  data   (pixConvertToPdfDataSegmented)
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input image file -- any format</param>
	<param name="res">input image resolution; typ. 300 ppi; use 0 for default</param>
	<param name="type">compression type for non-image regions; the image regions are always compressed with L_JPEG_ENCODE</param>
	<param name="thresh">used for converting gray --GT 1 bpp with L_G4_ENCODE</param>
	<param name="boxa">of image regions; can be null</param>
	<param name="quality">used for jpeg image regions; 0 for default</param>
	<param name="scalefactor">used for jpeg regions; must be LT= 1.0</param>
	<param name="title">pdf title; typically taken from the input file for the pix</param>
	<param name="fileout">output pdf file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertToPdfSegmented(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Enumerations.L_ENCODE,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.Single,System.String,LeptonicaSharp.Boxa,System.String)">
	<summary>
 Notes
 (1) See convertToPdfSegmented() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, cmap OK</param>
	<param name="res">input image resolution; typ. 300 ppi; use 0 for default</param>
	<param name="type">compression type for non-image regions; the image regions are always compressed with L_JPEG_ENCODE</param>
	<param name="thresh">used for converting gray --GT 1 bpp with L_G4_ENCODE</param>
	<param name="boxa">of image regions; can be null</param>
	<param name="quality">used for jpeg image regions; 0 for default</param>
	<param name="scalefactor">used for jpeg regions; must be LT= 1.0</param>
	<param name="title">pdf title; typically taken from the input file for the pix</param>
	<param name="fileout">output pdf file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertToPdfDataSegmented(System.String,System.Int32,LeptonicaSharp.Enumerations.L_ENCODE,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.Single,System.Byte[]@,System.UInt32@,LeptonicaSharp.Boxa,System.String)">
	<summary>
 Notes
 (1) If there are no image regions, set %boxa == NULL;
 %quality and %scalefactor are ignored.
 (2) Typically, %scalefactor is LT 1.0.  The image regions are
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input image file -- any format</param>
	<param name="res">input image resolution; typ. 300 ppi; use 0 for default</param>
	<param name="type">compression type for non-image regions; the image regions are always compressed with L_JPEG_ENCODE</param>
	<param name="thresh">used for converting gray --GT 1 bpp with L_G4_ENCODE</param>
	<param name="boxa">image regions; can be null</param>
	<param name="quality">used for jpeg image regions; 0 for default</param>
	<param name="scalefactor">used for jpeg regions; must be LT= 1.0</param>
	<param name="title">pdf title; if null, uses filein</param>
	<param name="pdata">pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertToPdfDataSegmented(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Enumerations.L_ENCODE,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.Single,System.Byte[]@,System.UInt32@,LeptonicaSharp.Boxa,System.String)">
	<summary>
 Notes
 (1) See convertToPdfSegmented() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, cmap OK</param>
	<param name="res">input image resolution; typ. 300 ppi; use 0 for default</param>
	<param name="type">compression type for non-image regions; the image regions are always compressed with L_JPEG_ENCODE</param>
	<param name="thresh">used for converting gray --GT 1 bpp with L_G4_ENCODE</param>
	<param name="boxa">of image regions; can be null</param>
	<param name="quality">used for jpeg image regions; 0 for default</param>
	<param name="scalefactor">used for jpeg regions; must be LT= 1.0</param>
	<param name="title">pdf title; typically taken from the input file for the pix</param>
	<param name="pdata">pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.concatenatePdf(System.String,System.String,System.String)">
	<summary>
 Notes
 (1) This only works with leptonica-formatted single-page pdf files.
 (2) If %substr is not NULL, only filenames that contain
 the substring can be returned.  If %substr == NULL,
 none of the filenames are filtered out.
 (3) The files in the directory, after optional filtering by
 the substring, are lexically sorted in increasing order
 before concatenation.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name containing single-page pdf files</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="fileout">concatenated pdf file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.saConcatenatePdf(LeptonicaSharp.Sarray,System.String)">
	<summary>
 Notes
 (1) This only works with leptonica-formatted single-page pdf files.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of pathnames for single-page pdf files</param>
	<param name="fileout">concatenated pdf file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraConcatenatePdf(LeptonicaSharp.L_Ptra,System.String)">
	<summary>
 Notes
 (1) This only works with leptonica-formatted single-page pdf files.
 </summary>
	<remarks>
	</remarks>
	<param name="pa">array of pdf strings, each for a single-page pdf file</param>
	<param name="fileout">concatenated pdf file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.concatenatePdfToData(System.String,System.Byte[]@,System.UInt32@,System.String)">
	<summary>
 Notes
 (1) This only works with leptonica-formatted single-page pdf files.
 (2) If %substr is not NULL, only filenames that contain
 the substring can be returned.  If %substr == NULL,
 none of the filenames are filtered out.
 (3) The files in the directory, after optional filtering by
 the substring, are lexically sorted in increasing order
 before concatenation.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name containing single-page pdf files</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="pdata">concatenated pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.saConcatenatePdfToData(LeptonicaSharp.Sarray,System.Byte[]@,System.UInt32@)">
	<summary>
 Notes
 (1) This only works with leptonica-formatted single-page pdf files.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of pathnames for single-page pdf files</param>
	<param name="pdata">concatenated pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertToPdfData(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_ENCODE,System.Byte[]@,System.UInt32@,LeptonicaSharp.L_Pdf_Data@,LeptonicaSharp.Enumerations.L_T_IMAGE,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) If %res == 0 and the input resolution field is 0,
 this will use DEFAULT_INPUT_RES.
 (2) This only writes %data if it is the last image to be
 written on the page.
 (3) See comments in convertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; cmap OK</param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="pdata">pdf array</param>
	<param name="pnbytes">number of bytes in pdf array</param>
	<param name="x">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page)</param>
	<param name="y">location of lower-left corner of image, in pixels, relative to the PostScript origin (0,0) at the lower-left corner of the page)</param>
	<param name="res">override the resolution of the input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="title">pdf title</param>
	<param name="plpd">ptr to lpd, which is created on the first invocation and returned until last image is processed</param>
	<param name="position">in image sequence L_FIRST_IMAGE, L_NEXT_IMAGE, L_LAST_IMAGE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraConcatenatePdfToData(LeptonicaSharp.L_Ptra,LeptonicaSharp.Sarray,System.Byte[]@,System.UInt32@)">
	<summary>
 Notes
 (1) This only works with leptonica-formatted single-page pdf files.
 pdf files generated by other programs will have unpredictable
 (and usually bad) results.  The requirements for each pdf file
 (a) The Catalog and Info objects are the first two.
 (b) Object 3 is Pages
 (c) Object 4 is Page
 (d) The remaining objects are Contents, XObjects, and ColorSpace
 (2) We remove trailers from each page, and append the full trailer
 for all pages at the end.
 (3) For all but the first file, remove the ID and the first 3
 objects (catalog, info, pages), so that each subsequent
 file has only objects of these classes
 Page, Contents, XObject, ColorSpace (Indexed RGB).
 For those objects, we substitute these refs to objects
 in the local file
 Page  Parent(object 3), Contents, XObject(typically multiple)
 XObject  [ColorSpace if indexed]
 The Pages object on the first page (object 3) has a Kids array
 of references to all the Page objects, with a Count equal
 to the number of pages.  Each Page object refers back to
 this parent.
 </summary>
	<remarks>
	</remarks>
	<param name="pa_data">ptra array of pdf strings, each for a single-page pdf file</param>
	<param name="sa">string array [optional] of pathnames for input pdf files</param>
	<param name="pdata">concatenated pdf data in memory</param>
	<param name="pnbytes">number of bytes in pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertTiffMultipageToPdf(System.String,System.String)">
	<summary>
 Notes
 (1) A multipage tiff file can also be converted to PS, using
 convertTiffMultipageToPS()
 </summary>
	<remarks>
	</remarks>
	<param name="filein">(tiff)</param>
	<param name="fileout">(pdf)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_generateCIDataForPdf(System.Int32,LeptonicaSharp.L_Compressed_Data@,System.String,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) You must set either filename or pix.
 (2) Given an image file and optionally a pix raster of that data,
 this provides a CID that is compatible with PDF, preferably
 without transcoding.
 (3) The pix is included for efficiency, in case transcoding
 is required and the pix is available to the caller.
 (4) We don't try to open files named "stdin" or "-" for Tesseract
 compatibility reasons. We may remove this restriction
 in the future.
 </summary>
	<remarks>
	</remarks>
	<param name="fname">; can be null</param>
	<param name="pix">; can be null</param>
	<param name="quality">for jpeg if transcoded; 75 is standard</param>
	<param name="pcid">compressed data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_generateFlateDataPdf(System.String,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If you hand this a png file, you are going to get
 png predictors embedded in the flate data. So it has
 come to this. http//xkcd.com/1022/
 (2) Exception if the png is interlaced or if it is RGBA,
 it will be transcoded.
 (3) If transcoding is required, this will not have to read from
 file if you also input a pix.
 </summary>
	<remarks>
	</remarks>
	<param name="fname">preferably png</param>
	<param name="pixs">; can be null</param>
	<returns>cid containing png data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_generateJpegData(System.String,System.Int32)">
	<summary>
 Notes
 (1) Set ascii85flag
 ~ 0 for binary data (not permitted in PostScript)
 ~ 1 for ascii85 (5 for 4) encoded binary data
 (not permitted in pdf)
 (2) Do not free the data.  l_generateJpegDataMem() will free
 the data if it does not use ascii encoding.
 </summary>
	<remarks>
	</remarks>
	<param name="fname">of jpeg file</param>
	<param name="ascii85flag">0 for jpeg; 1 for ascii85-encoded jpeg</param>
	<returns>cid containing jpeg data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_generateJpegDataMem(System.Byte[],System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) See l_generateJpegData().
 </summary>
	<remarks>
	</remarks>
	<param name="data">of jpeg file</param>
	<param name="nbytes"></param>
	<param name="ascii85flag">0 for jpeg; 1 for ascii85-encoded jpeg</param>
	<returns>cid containing jpeg data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_generateCIData(System.String,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.Int32,LeptonicaSharp.L_Compressed_Data@)">
	<summary>
 Notes
 (1) This can be used for both PostScript and pdf.
 (1) Set ascii85
 ~ 0 for binary data (not permitted in PostScript)
 ~ 1 for ascii85 (5 for 4) encoded binary data
 (2) This attempts to compress according to the requested type.
 If this can't be done, it falls back to ordinary flate encoding.
 (3) This differs from l_generateCIDataPdf(), which determines
 the format and attempts to generate the CID without transcoding.
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE, L_JP2K_ENCODE</param>
	<param name="quality">used for jpeg only; 0 for default (75)</param>
	<param name="ascii85">0 for binary; 1 for ascii85-encoded</param>
	<param name="pcid">compressed data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenerateCIData(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.Int32,LeptonicaSharp.L_Compressed_Data@)">
	<summary>
 Notes
 (1) Set ascii85
 ~ 0 for binary data (not permitted in PostScript)
 ~ 1 for ascii85 (5 for 4) encoded binary data
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp, no colormap</param>
	<param name="type">L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE</param>
	<param name="quality">used for jpeg only; 0 for default (75)</param>
	<param name="ascii85">0 for binary; 1 for ascii85-encoded</param>
	<param name="pcid">compressed data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_generateFlateData(System.String,System.Int32)">
	<summary>
 Notes
 (1) The input image is converted to one of these 4 types
 ~ 1 bpp
 ~ 8 bpp, no colormap
 ~ 8 bpp, colormap
 ~ 32 bpp rgb
 (2) Set ascii85flag
 ~ 0 for binary data (not permitted in PostScript)
 ~ 1 for ascii85 (5 for 4) encoded binary data
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="ascii85flag">0 for gzipped; 1 for ascii85-encoded gzipped</param>
	<returns>cid flate compressed image data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_generateG4Data(System.String,System.Int32)">
	<summary>
 Notes
 (1) Set ascii85flag
 ~ 0 for binary data (not permitted in PostScript)
 ~ 1 for ascii85 (5 for 4) encoded binary data
 (not permitted in pdf)
 </summary>
	<remarks>
	</remarks>
	<param name="fname">of g4 compressed file</param>
	<param name="ascii85flag">0 for g4 compressed; 1 for ascii85-encoded g4</param>
	<returns>cid g4 compressed image data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.cidConvertToPdfData(LeptonicaSharp.L_Compressed_Data,System.Byte[]@,System.UInt32@,System.String)">
	<summary>
 Notes
 (1) Caller must not destroy the cid.  It is absorbed in the
 lpd and destroyed by this function.
 </summary>
	<remarks>
	</remarks>
	<param name="cid">compressed image data -- of jp2k image</param>
	<param name="title">pdf title; can be NULL</param>
	<param name="pdata">output pdf data for image</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_CIDataDestroy(LeptonicaSharp.L_Compressed_Data@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pcid">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_pdfSetG4ImageMask(System.Int32)">
	<summary>
 Notes
 (1) The default is for writing only the fg (through the mask).
 That way when you write a 1 bpp image, the bg is transparent,
 so any previously written image remains visible behind it.
 </summary>
	<remarks>
	</remarks>
	<param name="flag">1 for writing g4 data as fg only through a mask; 0 for writing fg and bg</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_pdfSetDateAndVersion(System.Int32)">
	<summary>
 Notes
 (1) The default is for writing this data.  For regression tests
 that compare output against golden files, it is useful to omit.
 </summary>
	<remarks>
	</remarks>
	<param name="flag">1 for writing date/time and leptonica version; 0 for omitting this from the metadata</param>
</member><member name="M:LeptonicaSharp._AllFunctions.setPixMemoryManager(System.IntPtr,System.IntPtr)">
	<summary>
 Notes
 (1) Use this to change the alloc and/or dealloc functions;
 e.g., setPixMemoryManager(my_malloc, my_free).
 (2) The C99 standard (section 6.7.5.3, par. 8) says
 A declaration of a parameter as "function returning type"
 shall be adjusted to "pointer to function returning type"
 so that it can be in either of these two forms
 (a) type (function-ptr(type, ...))
 (b) type ((function-ptr)(type, ...))
 because form (a) is implictly converted to form (b), as in the
 definition of struct PixMemoryManager above.  So, for example,
 we should be able to declare either of these
 (a) void (allocator(size_t))
 (b) void ((allocator)(size_t))
 However, MSVC++ only accepts the second version.
 </summary>
	<remarks>
	</remarks>
	<param name="allocator">use NULL to skip</param>
	<param name="deallocator">use NULL to skip</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCreate(System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="width"></param>
	<param name="height"></param>
	<param name="depth"></param>
	<returns>pixd with data allocated and initialized to 0, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCreateNoInit(System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Must set pad bits to avoid reading uninitialized data, because
 some optimized routines (e.g., pixConnComp()) read from pad bits.
 </summary>
	<remarks>
	</remarks>
	<param name="width"></param>
	<param name="height"></param>
	<param name="depth"></param>
	<returns>pixd with data allocated but not initialized, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCreateTemplate(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Makes a Pix of the same size as the input Pix, with the
 data array allocated and initialized to 0.
 (2) Copies the other fields, including colormap if it exists.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCreateTemplateNoInit(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Makes a Pix of the same size as the input Pix, with
 the data array allocated but not initialized to 0.
 (2) Copies the other fields, including colormap if it exists.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCreateHeader(System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) It is assumed that all 32 bit pix have 3 spp.  If there is
 a valid alpha channel, this will be set to 4 spp later.
 (2) If the number of bytes to be allocated is larger than the
 maximum value in an int32, we can get overflow, resulting
 in a smaller amount of memory actually being allocated.
 Later, an attempt to access memory that wasn't allocated will
 cause a crash.  So to avoid crashing a program (or worse)
 with bad (or malicious) input, this is where we limit the
 requested allocation of image data in a typesafe way.
 </summary>
	<remarks>
	</remarks>
	<param name="width"></param>
	<param name="height"></param>
	<param name="depth"></param>
	<returns>pixd with no data allocated, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixClone(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) A "clone" is simply a handle (ptr) to an existing pix.
 It is implemented because (a) images can be large and
 hence expensive to copy, and (b) extra handles to a data
 structure need to be made with a simple policy to avoid
 both double frees and memory leaks.  Pix are reference
 counted.  The side effect of pixClone() is an increase
 by 1 in the ref count.
 (2) The protocol to be used is
 (a) Whenever you want a new handle to an existing image,
 call pixClone(), which just bumps a ref count.
 (b) Always call pixDestroy() on all handles.  This
 decrements the ref count, nulls the handle, and
 only destroys the pix when pixDestroy() has been
 called on all handles.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>same pix ptr, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDestroy(LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the pix.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppix">will be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCopy(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) There are three cases
 (a) pixd == null  (makes a new pix; refcount = 1)
 (b) pixd == pixs  (no-op)
 (c) pixd != pixs  (data copy; no change in refcount)
 If the refcount of pixd GT 1, case (c) will side-effect
 these handles.
 (2) The general pattern of use is
 pixd = pixCopy(pixd, pixs);
 This will work for all three cases.
 For clarity when the case is known, you can use
 (a) pixd = pixCopy(NULL, pixs);
 (c) pixCopy(pixd, pixs);
 (3) For case (c), we check if pixs and pixd are the same
 size (w,h,d).  If so, the data is copied directly.
 Otherwise, the data is reallocated to the correct size
 and the copy proceeds.  The refcount of pixd is unchanged.
 (4) This operation, like all others that may involve a pre-existing
 pixd, will side-effect any existing clones of pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be null, equal to pixs, different from pixs</param>
	<param name="pixs"></param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixResizeImageData(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If the sizes of data in pixs and pixd are unequal, this
 frees the existing image data in pixd and allocates
 an uninitialized buffer that will hold the required amount
 of image data in pixs.  The image data from pixs is not
 copied into the new buffer.
 (2) On failure to allocate, pixd is unchanged.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">gets new uninitialized buffer for image data</param>
	<param name="pixs">determines the size of the buffer; not changed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCopyColormap(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This always destroys any colormap in pixd (except if
 the operation is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd"></param>
	<param name="pixs">copies the colormap to %pixd</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSizesEqual(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix1"></param>
	<param name="pix2"></param>
	<returns>1 if the two pix have same {h, w, d}; 0 otherwise.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTransferAllData(LeptonicaSharp.Pix,LeptonicaSharp.Pix@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does a complete data transfer from pixs to pixd,
 followed by the destruction of pixs (refcount permitting).
 (2) If the refcount of pixs is 1, pixs is destroyed.  Otherwise,
 the data in pixs is copied (rather than transferred) to pixd.
 (3) This operation, like all others with a pre-existing pixd,
 will side-effect any existing clones of pixd.  The pixd
 refcount does not change.
 (4) When might you use this?  Suppose you have an in-place Pix
 function (returning void) with the typical signature
 void function-inplace(PIX pix, ...)
 where "..." are non-pointer input parameters, and suppose
 further that you sometimes want to return an arbitrary Pix
 in place of the input Pix.  There are two ways you can do this
 (a) The straightforward way is to change the function
 signature to take the address of the Pix ptr
 \code
 void function-inplace(PIX ppix, ...) {
 PIX pixt = function-makenew(ppix);
 pixDestroy(ppix);
 ppix = pixt;
 return;
 }
 \endcode
 Here, the input and returned pix are different, as viewed
 by the calling function, and the inplace function is
 expected to destroy the input pix to avoid a memory leak.
 (b) Keep the signature the same and use pixTransferAllData()
 to return the new Pix in the input Pix struct
 \code
 void function-inplace(PIX pix, ...) {
 PIX pixt = function-makenew(pix);
 pixTransferAllData(pix, pixt, 0, 0);
 // pixDestroy() is called on pixt
 return;
 }
 \endcode
 Here, the input and returned pix are the same, as viewed
 by the calling function, and the inplace function must
 never destroy the input pix, because the calling function
 maintains an unchanged handle to it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">must be different from pixs</param>
	<param name="ppixs">will be nulled if refcount goes to 0</param>
	<param name="copytext">1 to copy the text field; 0 to skip</param>
	<param name="copyformat">1 to copy the informat field; 0 to skip</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSwapAndDestroy(LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) Simple operation to change the handle name safely.
 After this operation, the original image in pixd has
 been destroyed, pixd points to what was pixs, and
 the input pixs ptr has been nulled.
 (2) This works safely whether or not pixs and pixd are cloned.
 If pixs is cloned, the other handles still point to
 the original image, with the ref count reduced by 1.
 (3) Usage example
 \code
 Pix pix1 = pixRead("...");
 Pix pix2 = function(pix1, ...);
 pixSwapAndDestroy(pix1, pix2);
 pixDestroy(pix1);  // holds what was in pix2
 \endcode
 Example with clones ([] shows ref count of image generated
 by the function)
 \code
 Pix pixs = pixRead("...");
 Pix pix1 = pixClone(pixs);
 Pix pix2 = function(pix1, ...);   [1]
 Pix pix3 = pixClone(pix2);   [1] --GT [2]
 pixSwapAndDestroy(pix1, pix2);
 pixDestroy(pixs);  // still holds read image
 pixDestroy(pix1);  // holds what was in pix2  [2] --GT [1]
 pixDestroy(pix3);  // holds what was in pix2  [1] --GT [0]
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="ppixd">input pixd can be null, and it must be different from pixs</param>
	<param name="ppixs">will be nulled after the swap</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetWidth(LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetWidth(LeptonicaSharp.Pix@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetHeight(LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetHeight(LeptonicaSharp.Pix@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetDepth(LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetDepth(LeptonicaSharp.Pix@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetDimensions(LeptonicaSharp.Pix,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<param name="pd">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetDimensions(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="w">use 0 to skip the setting for any of these</param>
	<param name="h">use 0 to skip the setting for any of these</param>
	<param name="d">use 0 to skip the setting for any of these</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCopyDimensions(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd"></param>
	<param name="pixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetSpp(LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetSpp(LeptonicaSharp.Pix@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCopySpp(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd"></param>
	<param name="pixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetWpl(LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetWpl(LeptonicaSharp.Pix@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRefcount(LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixChangeRefcount(LeptonicaSharp.Pix@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetXRes(LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetXRes(LeptonicaSharp.Pix@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetYRes(LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetYRes(LeptonicaSharp.Pix@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetResolution(LeptonicaSharp.Pix,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="pxres">each can be null</param>
	<param name="pyres">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetResolution(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="xres">use 0 to skip setting a value for either of these</param>
	<param name="yres">use 0 to skip setting a value for either of these</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCopyResolution(LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleResolution(LeptonicaSharp.Pix@,System.Single@,System.Single@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetInputFormat(LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetInputFormat(LeptonicaSharp.Pix@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCopyInputFormat(LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetSpecial(LeptonicaSharp.Pix@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetText(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The text string belongs to the pix.  The caller must
 NOT free it!
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>ptr to existing text string</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetText(LeptonicaSharp.Pix,System.String)">
	<summary>
 Notes
 (1) This removes any existing textstring and puts a copy of
 the input textstring there.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="textstring"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddText(LeptonicaSharp.Pix,System.String)">
	<summary>
 Notes
 (1) This adds the new textstring to any existing text.
 (2) Either or both the existing text and the new text
 string can be null.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="textstring"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCopyText(LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetColormap(LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetColormap(LeptonicaSharp.Pix,LeptonicaSharp.PixColormap)">
	<summary>
 Notes
 (1) Unlike with the pix data field, pixSetColormap() destroys
 any existing colormap before assigning the new one.
 Because colormaps are not ref counted, it is important that
 the new colormap does not belong to any other pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="colormap">to be assigned</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDestroyColormap(LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetData(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This gives a new handle for the data.  The data is still
 owned by the pix, so do not call LEPT_FREE() on it.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>ptr to image data</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetData(LeptonicaSharp.Pix,System.Byte[])">
	<summary>
 Notes
 (1) This does not free any existing data.  To free existing
 data, use pixFreeData() before pixSetData().
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="data"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExtractData(LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This extracts the pix image data for use in another context.
 The caller still needs to use pixDestroy() on the input pix.
 (2) If refcount == 1, the data is extracted and the
 pix-GTdata ptr is set to NULL.
 (3) If refcount GT 1, this simply returns a copy of the data,
 using the pix allocator, and leaving the input pix unchanged.
 </summary>
	<remarks>
	</remarks>
	<returns>ptr to data, or null on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFreeData(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This frees the data and sets the pix data ptr to null.
 It should be used before pixSetData() in the situation where
 you want to free any existing data before doing
 a subsequent assignment with pixSetData().
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetLinePtrs(LeptonicaSharp.Pix,System.Int32@)">
	<summary>
 Notes
 (1) This is intended to be used for fast random pixel access.
 For example, for an 8 bpp image,
 val = GET_DATA_BYTE(lines8[i], j);
 is equivalent to, but much faster than,
 pixGetPixel(pix, j, i, val);
 (2) How much faster?  For 1 bpp, it's from 6 to 10x faster.
 For 8 bpp, it's an amazing 30x faster.  So if you are
 doing random access over a substantial part of the image,
 use this line ptr array.
 (3) When random access is used in conjunction with a stack,
 queue or heap, the overall computation time depends on
 the operations performed on each struct that is popped
 or pushed, and whether we are using a priority queue (O(logn))
 or a queue or stack (O(1)).  For example, for maze search,
 the overall ratio of time for line ptrs vs. pixGet/Set is
 Maze type  Type    Time ratio
 binary   queue   0.4
 gray  heap (priority queue)  0.6
 (4) Because this returns a void and the accessors take void,
 the compiler cannot check the pointer types.  It is
 strongly recommended that you adopt a naming scheme for
 the returned ptr arrays that indicates the pixel depth.
 (This follows the original intent of Simonyi's "Hungarian"
 application notation, where naming is used proactively
 to make errors visibly obvious.)  By doing this, you can
 tell by inspection if the correct accessor is used.
 For example, for an 8 bpp pixg
 void lineg8 = pixGetLinePtrs(pixg, NULL);
 val = GET_DATA_BYTE(lineg8[i], j);  // fast access; BYTE, 8
 ...
 LEPT_FREE(lineg8);  // don't forget this
 (5) These are convenient for accessing bytes sequentially in an
 8 bpp grayscale image.  People who write image processing code
 on 8 bpp images are accustomed to grabbing pixels directly out
 of the raster array.  Note that for little endians, you first
 need to reverse the byte order in each 32-bit word.
 Here's a typical usage pattern
 pixEndianByteSwap(pix);   // always safe; no-op on big-endians
 l_uint8 lineptrs = (l_uint8 )pixGetLinePtrs(pix, NULL);
 pixGetDimensions(pix, w, h, NULL);
 for (i = 0; i LT h; i++) {
 l_uint8 line = lineptrs[i];
 for (j = 0; j LT w; j++) {
 val = line[j];
 ...
 }
 }
 pixEndianByteSwap(pix);  // restore big-endian order
 LEPT_FREE(lineptrs);
 This can be done even more simply as follows
 l_uint8 lineptrs = pixSetupByteProcessing(pix, w, h);
 for (i = 0; i LT h; i++) {
 l_uint8 line = lineptrs[i];
 for (j = 0; j LT w; j++) {
 val = line[j];
 ...
 }
 }
 pixCleanupByteProcessing(pix, lineptrs);
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="psize">array size, which is the pix height</param>
	<returns>array of line ptrs, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixPrintStreamInfo(LeptonicaSharp.FILE,LeptonicaSharp.Pix,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix"></param>
	<param name="text">identifying string; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetPixel(LeptonicaSharp.Pix,System.Int32,System.Int32@,System.UInt32@)">
	<summary>
 Notes
 (1) This returns the value in the data array.  If the pix is
 colormapped, it returns the colormap index, not the rgb value.
 (2) Because of the function overhead and the parameter checking,
 this is much slower than using the GET_DATA_() macros directly.
 Speed on a 1 Mpixel RGB image, using a 3 GHz machine
 pixGet/pixSet ~25 Mpix/sec
 GET_DATA/SET_DATA ~350 MPix/sec
 If speed is important and you're doing random access into
 the pix, use pixGetLinePtrs() and the array access macros.
 (3) If the point is outside the image, this returns an error (1),
 with 0 in %pval.  To avoid spamming output, it fails silently.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="x">,y    pixel coords</param>
	<param name="pval">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetPixel(LeptonicaSharp.Pix,System.Int32,System.Int32@,System.UInt32)">
	<summary>
 Notes
 (1) Warning the input value is not checked for overflow with respect
 the the depth of %pix, and the sign bit (if any) is ignored.
 For d == 1, %val GT 0 sets the bit on.
 For d == 2, 4, 8 and 16, %val is masked to the maximum allowable
 pixel value, and any (invalid) higher order bits are discarded.
 (2) See pixGetPixel() for information on performance.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="x">,y   pixel coords</param>
	<param name="val">value to be inserted</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRGBPixel(LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb, not colormapped</param>
	<param name="x">,y    pixel coords</param>
	<param name="prval">red component</param>
	<param name="pgval">green component</param>
	<param name="pbval">blue component</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetRGBPixel(LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp rgb</param>
	<param name="x">,y    pixel coords</param>
	<param name="rval">red component</param>
	<param name="gval">green component</param>
	<param name="bval">blue component</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRandomPixel(LeptonicaSharp.Pix,System.UInt32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If the pix is colormapped, it returns the rgb value.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; can be colormapped</param>
	<param name="pval">pixel value</param>
	<param name="px">x coordinate chosen; can be null</param>
	<param name="py">y coordinate chosen; can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixClearPixel(LeptonicaSharp.Pix,System.Int32,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth; warning if colormapped</param>
	<param name="x">,y   pixel coords</param>
	<returns>0 if OK; 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFlipPixel(LeptonicaSharp.Pix,System.Int32,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">any depth, warning if colormapped</param>
	<param name="x">,y   pixel coords</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.setPixelLow(System.Byte[],System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) Caution input variables are not checked!
 </summary>
	<remarks>
	</remarks>
	<param name="line">ptr to beginning of line,</param>
	<param name="x">pixel location in line</param>
	<param name="depth">bpp</param>
	<param name="val">to be inserted</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetBlackOrWhiteVal(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_GET_VAL,System.UInt32@)">
	<summary>
 Notes
 (1) Side effect.  For a colormapped image, if the requested
 color is not present and there is room to add it in the cmap,
 it is added and the new index is returned.  If there is no room,
 the index of the closest color in intensity is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; cmap ok</param>
	<param name="op">L_GET_BLACK_VAL, L_GET_WHITE_VAL</param>
	<param name="pval">pixel value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixClearAll(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Clears all data to 0.  For 1 bpp, this is white; for grayscale
 or color, this is black.
 (2) Caution for colormapped pix, this sets the color to the first
 one in the colormap.  Be sure that this is the intended color!
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; use cmapped with caution</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetAll(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Sets all data to 1.  For 1 bpp, this is black; for grayscale
 or color, this is white.
 (2) Caution for colormapped pix, this sets the pixel value to the
 maximum value supported by the colormap 2^d - 1.  However, this
 color may not be defined, because the colormap may not be full.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; use cmapped with caution</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetAllGray(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) N.B.  For all images, %grayval == 0 represents black and
 %grayval == 255 represents white.
 (2) For depth LT 8, we do our best to approximate the gray level.
 For 1 bpp images, any %grayval LT 128 is black; GT= 128 is white.
 For 32 bpp images, each r,g,b component is set to %grayval,
 and the alpha component is preserved.
 (3) If pix is colormapped, it adds the gray value, replicated in
 all components, to the colormap if it's not there and there
 is room.  If the colormap is full, it finds the closest color in
 L2 distance of components.  This index is written to all pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths, cmap ok</param>
	<param name="grayval">in range 0 ... 255</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetAllArbitrary(LeptonicaSharp.Pix,System.UInt32)">
	<summary>
 Notes
 (1) Caution 1!  For colormapped pix, %val is used as an index
 into a colormap.  Be sure that index refers to the intended color.
 If the color is not in the colormap, you should first add it
 and then call this function.
 (2) Caution 2!  For 32 bpp pix, the interpretation of the LSB
 of %val depends on whether spp == 3 (RGB) or spp == 4 (RGBA).
 For RGB, the LSB is ignored in image transformations.
 For RGBA, the LSB is interpreted as the alpha (transparency)
 component; full transparency has alpha == 0x0, whereas
 full opacity has alpha = 0xff.  An RGBA image with full
 opacity behaves like an RGB image.
 (3) As an example of (2), suppose you want to initialize a 32 bpp
 pix with partial opacity, say 0xee337788.  If the pix is 3 spp,
 the 0x88 alpha component will be ignored and may be changed
 in subsequent processing.  However, if the pix is 4 spp, the
 alpha component will be retained and used. The function
 pixCreate(w, h, 32) makes an RGB image by default, and
 pixSetSpp(pix, 4) can be used to promote an RGB image to RGBA.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; use cmapped with caution</param>
	<param name="val">value to set all pixels</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetBlackOrWhite(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_SET)">
	<summary>
 Notes
 (1) Function for setting all pixels in an image to either black
 or white.
 (2) If pixs is colormapped, it adds black or white to the
 colormap if it's not there and there is room.  If the colormap
 is full, it finds the closest color in intensity.
 This index is written to all pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; cmap ok</param>
	<param name="op">L_SET_BLACK, L_SET_WHITE</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetComponentArbitrary(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.colors_32_bpp,System.Int32)">
	<summary>
 Notes
 (1) For example, this can be used to set the alpha component to opaque
 pixSetComponentArbitrary(pix, L_ALPHA_CHANNEL, 255)
 </summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp</param>
	<param name="comp">COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL</param>
	<param name="val">value to set this component</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixClearInRect(LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) Clears all data in rect to 0.  For 1 bpp, this is white;
 for grayscale or color, this is black.
 (2) Caution for colormapped pix, this sets the color to the first
 one in the colormap.  Be sure that this is the intended color!
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; can be cmapped</param>
	<param name="box">in which all pixels will be cleared</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetInRect(LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) Sets all data in rect to 1.  For 1 bpp, this is black;
 for grayscale or color, this is white.
 (2) Caution for colormapped pix, this sets the pixel value to the
 maximum value supported by the colormap 2^d - 1.  However, this
 color may not be defined, because the colormap may not be full.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths, can be cmapped</param>
	<param name="box">in which all pixels will be set</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetInRectArbitrary(LeptonicaSharp.Pix,LeptonicaSharp.Box,System.UInt32)">
	<summary>
 Notes
 (1) For colormapped pix, be sure the value is the intended
 one in the colormap.
 (2) Caution for colormapped pix, this sets each pixel in the
 rect to the color at the index equal to val.  Be sure that
 this index exists in the colormap and that it is the intended one!
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; can be cmapped</param>
	<param name="box">in which all pixels will be set to val</param>
	<param name="val">value to set all pixels</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixBlendInRect(LeptonicaSharp.Pix,System.UInt32,System.Single,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This is an in-place function.  It blends the input color %val
 with the pixels in pixs in the specified rectangle.
 If no rectangle is specified, it blends over the entire image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="box">in which all pixels will be blended</param>
	<param name="val">blend value; 0xrrggbb00</param>
	<param name="fract">fraction of color to be blended with each pixel in pixs</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetPadBits(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) The pad bits are the bits that expand each scanline to a
 multiple of 32 bits.  They are usually not used in
 image processing operations.  When boundary conditions
 are important, as in seedfill, they must be set properly.
 (2) This sets the value of the pad bits (if any) in the last
 32-bit word in each scanline.
 (3) For 32 bpp pix, there are no pad bits, so this is a no-op.
 (4) When writing formatted output, such as tiff, png or jpeg,
 the pad bits have no effect on the raster image that is
 generated by reading back from the file.  However, in some
 cases, the compressed file itself will depend on the pad
 bits.  This is seen, for example, in Windows with 2 and 4 bpp
 tiff-compressed images that have pad bits on each scanline.
 It is sometimes convenient to use a golden file with a
 byte-by-byte check to verify invariance.  Consequently,
 and because setting the pad bits is cheap, the pad bits are
 set to 0 before writing these compressed files.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1, 2, 4, 8, 16, 32 bpp</param>
	<param name="val">0 or 1</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetPadBitsBand(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The pad bits are the bits that expand each scanline to a
 multiple of 32 bits.  They are usually not used in
 image processing operations.  When boundary conditions
 are important, as in seedfill, they must be set properly.
 (2) This sets the value of the pad bits (if any) in the last
 32-bit word in each scanline, within the specified
 band of raster lines.
 (3) For 32 bpp pix, there are no pad bits, so this is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1, 2, 4, 8, 16, 32 bpp</param>
	<param name="by">starting y value of band</param>
	<param name="bh">height of band</param>
	<param name="val">0 or 1</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetOrClearBorder(LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32)">
	<summary>
 Notes
 (1) The border region is defined to be the region in the
 image within a specific distance of each edge.  Here, we
 allow the pixels within a specified distance of each
 edge to be set independently.  This either sets or
 clears all pixels in the border region.
 (2) For binary images, use PIX_SET for black and PIX_CLR for white.
 (3) For grayscale or color images, use PIX_SET for white
 and PIX_CLR for black.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="left">right, top, bot amount to set or clear</param>
	<param name="op">operation PIX_SET or PIX_CLR</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetBorderVal(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) The border region is defined to be the region in the
 image within a specific distance of each edge.  Here, we
 allow the pixels within a specified distance of each
 edge to be set independently.  This sets the pixels
 in the border region to the given input value.
 (2) For efficiency, use pixSetOrClearBorder() if
 you're setting the border to either black or white.
 (3) If d != 32, the input value should be masked off
 to the appropriate number of least significant bits.
 (4) The code is easily generalized for 2 or 4 bpp.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16 or 32 bpp</param>
	<param name="left">amount to set</param>
	<param name="right">amount to set</param>
	<param name="top">amount to set</param>
	<param name="bot">amount to set</param>
	<param name="val">value to set at each border pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetBorderRingVal(LeptonicaSharp.Pix,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) The rings are single-pixel-wide rectangular sets of
 pixels at a given distance from the edge of the pix.
 This sets all pixels in a given ring to a value.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; cmap OK</param>
	<param name="dist">distance from outside; must be GT 0; first ring is 1</param>
	<param name="val">value to set at each border pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetMirroredBorder(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This applies what is effectively mirror boundary conditions
 to a border region in the image.  It is in-place.
 (2) This is useful for setting pixels near the border to a
 value representative of the near pixels to the interior.
 (3) The general pixRasterop() is used for an in-place operation here
 because there is no overlap between the src and dest rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels to set</param>
	<param name="right">number of pixels to set</param>
	<param name="top">number of pixels to set</param>
	<param name="bot">number of pixels to set</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCopyBorder(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) pixd can be null, but otherwise it must be the same size
 and depth as pixs.  Always returns pixd.
 (2) This is useful in situations where by setting a few border
 pixels we can avoid having to copy all pixels in pixs into
 pixd as an initialization step for some operation.
 Nevertheless, for safety, if making a new pixd, all the
 non-border pixels are initialized to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">all depths; colormap ok; can be NULL</param>
	<param name="pixs">same depth and size as pixd</param>
	<param name="left">number of pixels to copy</param>
	<param name="right">number of pixels to copy</param>
	<param name="top">number of pixels to copy</param>
	<param name="bot">number of pixels to copy</param>
	<returns>pixd, or NULL on error if pixd is not defined</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddBorder(LeptonicaSharp.Pix,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) See pixGetBlackOrWhiteVal() for values of black and white pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="npix">number of pixels to be added to each side</param>
	<param name="val">value of added border pixels</param>
	<returns>pixd with the added exterior pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddBlackOrWhiteBorder(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_GET_VAL)">
	<summary>
 Notes
 (1) See pixGetBlackOrWhiteVal() for possible side effect (adding
 a color to a colormap).
 (2) The only complication is that pixs may have a colormap.
 There are two ways to add the black or white border
 (a) As done here (simplest, most efficient)
 (b) l_int32 ws, hs, d;
 pixGetDimensions(pixs, ws, hs, d);
 Pix pixd = pixCreate(ws + left + right, hs + top + bot, d);
 PixColormap cmap = pixGetColormap(pixs);
 if (cmap != NULL)
 pixSetColormap(pixd, pixcmapCopy(cmap));
 pixSetBlackOrWhite(pixd, L_SET_WHITE);  // uses cmap
 pixRasterop(pixd, left, top, ws, hs, PIX_SET, pixs, 0, 0);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels added</param>
	<param name="right">number of pixels added</param>
	<param name="top">number of pixels added</param>
	<param name="bot">number of pixels added</param>
	<param name="op">L_GET_BLACK_VAL, L_GET_WHITE_VAL</param>
	<returns>pixd with the added exterior pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddBorderGeneral(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) For binary images
 white  val = 0
 black  val = 1
 For grayscale images
 white  val = 2  d - 1
 black  val = 0
 For rgb color images
 white  val = 0xffffff00
 black  val = 0
 For colormapped images, set val to the appropriate colormap index.
 (2) If the added border is either black or white, you can use
 pixAddBlackOrWhiteBorder()
 The black and white values for all images can be found with
 pixGetBlackOrWhiteVal()
 which, if pixs is cmapped, may add an entry to the colormap.
 Alternatively, if pixs has a colormap, you can find the index
 of the pixel whose intensity is closest to white or black
 white pixcmapGetRankIntensity(cmap, 1.0, index);
 black pixcmapGetRankIntensity(cmap, 0.0, index);
 and use that for val.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels added</param>
	<param name="right">number of pixels added</param>
	<param name="top">number of pixels added</param>
	<param name="bot">number of pixels added</param>
	<param name="val">value of added border pixels</param>
	<returns>pixd with the added exterior pixels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRemoveBorder(LeptonicaSharp.Pix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="npix">number to be removed from each of the 4 sides</param>
	<returns>pixd with pixels removed around border, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRemoveBorderGeneral(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels removed</param>
	<param name="right">number of pixels removed</param>
	<param name="top">number of pixels removed</param>
	<param name="bot">number of pixels removed</param>
	<returns>pixd with pixels removed around border, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRemoveBorderToSize(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Removes pixels as evenly as possible from the sides of the
 image, leaving the central part.
 (2) Returns clone if no pixels requested removed, or the target
 sizes are larger than the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="wd">target width; use 0 if only removing from height</param>
	<param name="hd">target height; use 0 if only removing from width</param>
	<returns>pixd with pixels removed around border, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddMirroredBorder(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This applies what is effectively mirror boundary conditions.
 For the added border pixels in pixd, the pixels in pixs
 near the border are mirror-copied into the border region.
 (2) This is useful for avoiding special operations near
 boundaries when doing image processing operations
 such as rank filters and convolution.  In use, one first
 adds mirrored pixels to each side of the image.  The number
 of pixels added on each side is half the filter dimension.
 Then the image processing operations proceed over a
 region equal to the size of the original image, and
 write directly into a dest pix of the same size as pixs.
 (3) The general pixRasterop() is used for an in-place operation here
 because there is no overlap between the src and dest rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels added</param>
	<param name="right">number of pixels added</param>
	<param name="top">number of pixels added</param>
	<param name="bot">number of pixels added</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddRepeatedBorder(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This applies a repeated border, as if the central part of
 the image is tiled over the plane.  So, for example, the
 pixels in the left border come from the right side of the image.
 (2) The general pixRasterop() is used for an in-place operation here
 because there is no overlap between the src and dest rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels added</param>
	<param name="right">number of pixels added</param>
	<param name="top">number of pixels added</param>
	<param name="bot">number of pixels added</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddMixedBorder(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This applies mirrored boundary conditions horizontally
 and repeated b.c. vertically.
 (2) It is specifically used for avoiding special operations
 near boundaries when convolving a hue-saturation histogram
 with a given window size.  The repeated b.c. are used
 vertically for hue, and the mirrored b.c. are used
 horizontally for saturation.  The number of pixels added
 on each side is approximately (but not quite) half the
 filter dimension.  The image processing operations can
 then proceed over a region equal to the size of the original
 image, and write directly into a dest pix of the same
 size as pixs.
 (3) The general pixRasterop() can be used for an in-place
 operation here because there is no overlap between the
 src and dest rectangles.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">number of pixels added</param>
	<param name="right">number of pixels added</param>
	<param name="top">number of pixels added</param>
	<param name="bot">number of pixels added</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddContinuedBorder(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This adds pixels on each side whose values are equal to
 the value on the closest boundary pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="left">pixels on each side to be added</param>
	<param name="right">pixels on each side to be added</param>
	<param name="top">pixels on each side to be added</param>
	<param name="bot">pixels on each side to be added</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixShiftAndTransferAlpha(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp</param>
	<param name="pixs">32 bpp</param>
	<param name="shiftx"></param>
	<param name="shifty"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDisplayLayersRGBA(LeptonicaSharp.Pix,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) Use %val == 0xffffff00 for white background.
 (2) Three views are given
 ~ the image with a fully opaque alpha
 ~ the alpha layer
 ~ the image as it would appear with a white background.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">cmap or 32 bpp rgba</param>
	<param name="val">32 bit unsigned color to use as background</param>
	<param name="maxw">max output image width; 0 for no scaling</param>
	<returns>pixd showing various image views, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCreateRGBImage(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) the 4th byte, sometimes called the "alpha channel",
 and which is often used for blending between different
 images, is left with 0 value.
 (2) see Note (4) in pix.h for details on storage of
 8-bit samples within each 32-bit word.
 (3) This implementation, setting the r, g and b components
 sequentially, is much faster than setting them in parallel
 by constructing an RGB dest pixel and writing it to dest.
 The reason is there are many more cache misses when reading
 from 3 input images simultaneously.
 </summary>
	<remarks>
	</remarks>
	<param name="pixr">8 bpp red pix</param>
	<param name="pixg">8 bpp green pix</param>
	<param name="pixb">8 bpp blue pix</param>
	<returns>32 bpp pix, interleaved with 4 samples/pixel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRGBComponent(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Three calls to this function generate the r, g and b 8 bpp
 component images.  This is much faster than generating the
 three images in parallel, by extracting a src pixel and setting
 the pixels of each component image from it.  The reason is
 there are many more cache misses when writing to three
 output images simultaneously.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, or colormapped</param>
	<param name="comp">one of {COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL}</param>
	<returns>pixd the selected 8 bpp component image of the input 32 bpp image or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetRGBComponent(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This places the 8 bpp pixel in pixs into the
 specified component (properly interleaved) in pixd,
 (2) The two images are registered to the UL corner; the sizes
 need not be the same, but a warning is issued if they differ.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp</param>
	<param name="pixs">8 bpp</param>
	<param name="comp">one of the set {COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL}</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRGBComponentCmap(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) In leptonica, we do not support alpha in colormaps.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped</param>
	<param name="comp">one of the set {COLOR_RED, COLOR_GREEN, COLOR_BLUE}</param>
	<returns>pixd  the selected 8 bpp component image of the input cmapped image, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCopyRGBComponent(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) The two images are registered to the UL corner.  The sizes
 are usually the same, and a warning is issued if they differ.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp</param>
	<param name="pixs">32 bpp</param>
	<param name="comp">one of the set {COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL}</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.composeRGBPixel(System.Int32,System.Int32,System.Int32,System.UInt32@)">
	<summary>
 Notes
 (1) All channels are 8 bits the input values must be between
 0 and 255.  For speed, this is not enforced by masking
 with 0xff before shifting.
 (2) A slower implementation uses macros
 SET_DATA_BYTE(ppixel, COLOR_RED, rval);
 SET_DATA_BYTE(ppixel, COLOR_GREEN, gval);
 SET_DATA_BYTE(ppixel, COLOR_BLUE, bval);
 </summary>
	<remarks>
	</remarks>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="ppixel">32-bit pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.composeRGBAPixel(System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32@)">
	<summary>
 Notes
 (1) All channels are 8 bits the input values must be between
 0 and 255.  For speed, this is not enforced by masking
 with 0xff before shifting.
 </summary>
	<remarks>
	</remarks>
	<param name="rval"></param>
	<param name="gval"></param>
	<param name="bval"></param>
	<param name="aval"></param>
	<param name="ppixel">32-bit pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.extractRGBValues(System.UInt32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) A slower implementation uses macros
 prval = GET_DATA_BYTE(pixel, COLOR_RED);
 pgval = GET_DATA_BYTE(pixel, COLOR_GREEN);
 pbval = GET_DATA_BYTE(pixel, COLOR_BLUE);
 </summary>
	<remarks>
	</remarks>
	<param name="pixel">32 bit</param>
	<param name="prval">red component</param>
	<param name="pgval">green component</param>
	<param name="pbval">blue component</param>
</member><member name="M:LeptonicaSharp._AllFunctions.extractRGBAValues(System.UInt32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixel">32 bit</param>
	<param name="prval">red component</param>
	<param name="pgval">green component</param>
	<param name="pbval">blue component</param>
	<param name="paval">alpha component</param>
</member><member name="M:LeptonicaSharp._AllFunctions.extractMinMaxComponent(System.UInt32,LeptonicaSharp.Enumerations.L_CHOOSE_M)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixel">32 bpp RGB</param>
	<param name="type">L_CHOOSE_MIN or L_CHOOSE_MAX</param>
	<returns>component in range [0 ... 255], or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRGBLine(LeptonicaSharp.Pix,System.Int32,System.Byte[],System.Byte[],System.Byte[])">
	<summary>
 Notes
 (1) This puts rgb components from the input line in pixs
 into the given buffers.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="row"></param>
	<param name="bufr">array of red samples; size w bytes</param>
	<param name="bufg">array of green samples; size w bytes</param>
	<param name="bufb">array of blue samples; size w bytes</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixEndianByteSwapNew(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is used to convert the data in a pix to a
 serialized byte buffer in raster order, and, for RGB,
 in order RGBA.  This requires flipping bytes within
 each 32-bit word for little-endian platforms, because the
 words have a MSB-to-the-left rule, whereas byte raster-order
 requires the left-most byte in each word to be byte 0.
 For big-endians, no swap is necessary, so this returns a clone.
 (2) Unlike pixEndianByteSwap(), which swaps the bytes in-place,
 this returns a new pix (or a clone).  We provide this
 because often when serialization is done, the source
 pix needs to be restored to canonical little-endian order,
 and this requires a second byte swap.  In such a situation,
 it is twice as fast to make a new pix in big-endian order,
 use it, and destroy it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixEndianByteSwap(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is used on little-endian platforms to swap
 the bytes within a word; bytes 0 and 3 are swapped,
 and bytes 1 and 2 are swapped.
 (2) This is required for little-endians in situations
 where we convert from a serialized byte order that is
 in raster order, as one typically has in file formats,
 to one with MSB-to-the-left in each 32-bit word, or v.v.
 See pix.h for a description of the canonical format
 (MSB-to-the left) that is used for both little-endian
 and big-endian platforms.   For big-endians, the
 MSB-to-the-left word order has the bytes in raster
 order when serialized, so no byte flipping is required.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lineEndianByteSwap(System.Byte[],System.Byte[],System.Int32)">
	<summary>
 Notes
 (1) This is used on little-endian platforms to swap
 the bytes within each word in the line of image data.
 Bytes 0 LT==GT 3 and 1 LT==GT 2 are swapped in the dest
 byte array data8d, relative to the pix data in datas.
 (2) The bytes represent 8 bit pixel values.  They are swapped
 for little endians so that when the dest array datad
 is addressed by bytes, the pixels are chosen sequentially
 from left to right in the image.
 </summary>
	<remarks>
	</remarks>
	<param name="datad">dest byte array data, reordered on little-endians</param>
	<param name="datas">a src line of pix data)</param>
	<param name="wpl">number of 32 bit words in the line</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixEndianTwoByteSwapNew(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is used on little-endian platforms to swap the
 2-byte entities within a 32-bit word.
 (2) This is equivalent to a full byte swap, as performed
 by pixEndianByteSwap(), followed by byte swaps in
 each of the 16-bit entities separately.
 (3) Unlike pixEndianTwoByteSwap(), which swaps the shorts in-place,
 this returns a new pix (or a clone).  We provide this
 to avoid having to swap twice in situations where the input
 pix must be restored to canonical little-endian order.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixEndianTwoByteSwap(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is used on little-endian platforms to swap the
 2-byte entities within a 32-bit word.
 (2) This is equivalent to a full byte swap, as performed
 by pixEndianByteSwap(), followed by byte swaps in
 each of the 16-bit entities separately.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRasterData(LeptonicaSharp.Pix,System.Byte[]@,System.UInt32@)">
	<summary>
 Notes
 (1) This returns the raster data as a byte string, padded to the
 byte.  For 1 bpp, the first pixel is the MSbit in the first byte.
 For rgb, the bytes are in (rgb) order.  This is the format
 required for flate encoding of pixels in a PostScript file.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8, 32 bpp</param>
	<param name="pdata">raster data in memory</param>
	<param name="pnbytes">number of bytes in data string</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAlphaIsOpaque(LeptonicaSharp.Pix,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">32 bpp, spp == 4</param>
	<param name="popaque">1 if spp == 4 and all alpha component values are 255 (opaque); 0 otherwise</param>
	<returns>0 if OK, 1 on error Notes 1) On error, opaque is returned as 0 (FALSE).</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetupByteProcessing(LeptonicaSharp.Pix,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This is a simple helper for processing 8 bpp images with
 direct byte access.  It can swap byte order within each word.
 (2) After processing, you must call pixCleanupByteProcessing(),
 which frees the lineptr array and restores byte order.
 (3) Usage
 l_uint8 lineptrs = pixSetupByteProcessing(pix, w, h);
 for (i = 0; i LT h; i++) {
 l_uint8 line = lineptrs[i];
 for (j = 0; j LT w; j++) {
 val = line[j];
 ...
 }
 }
 pixCleanupByteProcessing(pix, lineptrs);
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp, no colormap</param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<returns>line ptr array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCleanupByteProcessing(LeptonicaSharp.Pix,System.Collections.Generic.List{System.Byte[]})">
	<summary>
 Notes
 (1) This must be called after processing that was initiated
 by pixSetupByteProcessing() has finished.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp, no colormap</param>
	<param name="lineptrs">ptrs to the beginning of each raster line of data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_setAlphaMaskBorder(System.Single,System.Single)">
	<summary>
 Notes
 (1) This sets the opacity values used to generate the two outer
 boundary rings in the alpha mask associated with geometric
 transforms such as pixRotateWithAlpha().
 (2) The default values are val1 = 0.0 (completely transparent
 in the outermost ring) and val2 = 0.5 (half transparent
 in the second ring).  When the image is blended, this
 completely removes the outer ring (shrinking the image by
 2 in each direction), and alpha-blends with 0.5 the second ring.
 Using val1 = 0.25 and val2 = 0.75 gives a slightly more
 blurred border, with no perceptual difference at screen resolution.
 (3) The actual mask values are found by multiplying these
 normalized opacity values by 255.
 </summary>
	<remarks>
	</remarks>
	<param name="val1">in [0.0 ... 1.0]</param>
	<param name="val2">in [0.0 ... 1.0]</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetMasked(LeptonicaSharp.Pix,System.UInt32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) In-place operation.
 (2) NOTE For cmapped images, this calls pixSetMaskedCmap().
 %val must be the 32-bit color representation of the RGB pixel.
 It is not the index into the colormap!
 (2) If pixm == NULL, a warning is given.
 (3) This is an implicitly aligned operation, where the UL
 corners of pixd and pixm coincide.  A warning is
 issued if the two image sizes differ significantly,
 but the operation proceeds.
 (4) Each pixel in pixd that co-locates with an ON pixel
 in pixm is set to the specified input value.
 Other pixels in pixd are not changed.
 (5) You can visualize this as painting the color through
 the mask, as a stencil.
 (6) If you do not want to have the UL corners aligned,
 use the function pixSetMaskedGeneral(), which requires
 you to input the UL corner of pixm relative to pixd.
 (7) Implementation details see comments in pixPaintThroughMask()
 for when we use rasterop to do the painting.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">1, 2, 4, 8, 16 or 32 bpp; or colormapped</param>
	<param name="pixm">1 bpp mask; no operation if NULL</param>
	<param name="val">value to set at each masked pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetMaskedGeneral(LeptonicaSharp.Pix,System.UInt32,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is an in-place operation.
 (2) Alignment is explicit.  If you want the UL corners of
 the two images to be aligned, use pixSetMasked().
 (3) A typical use would be painting through the foreground
 of a small binary mask pixm, located somewhere on a
 larger pixd.  Other pixels in pixd are not changed.
 (4) You can visualize this as painting the color through
 the mask, as a stencil.
 (5) This uses rasterop to handle clipping and different depths of pixd.
 (6) If pixd has a colormap, you should call pixPaintThroughMask().
 (7) Why is this function here, if pixPaintThroughMask() does the
 same thing, and does it more generally?  I've retained it here
 to show how one can paint through a mask using only full
 image rasterops, rather than pixel peeking in pixm and poking
 in pixd.  It's somewhat baroque, but I found it amusing.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8, 16 or 32 bpp</param>
	<param name="pixm">1 bpp mask; no operation if null</param>
	<param name="val">value to set at each masked pixel</param>
	<param name="x">location of UL corner of pixm relative to pixd; can be negative</param>
	<param name="y">location of UL corner of pixm relative to pixd; can be negative</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCombineMasked(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) In-place operation; pixd is changed.
 (2) This sets each pixel in pixd that co-locates with an ON
 pixel in pixm to the corresponding value of pixs.
 (3) pixs and pixd must be the same depth and not colormapped.
 (4) All three input pix are aligned at the UL corner, and the
 operation is clipped to the intersection of all three images.
 (5) If pixm == NULL, it's a no-op.
 (6) Implementation see notes in pixCombineMaskedGeneral().
 For 8 bpp selective masking, you might guess that it
 would be faster to generate an 8 bpp version of pixm,
 using pixConvert1To8(pixm, 0, 255), and then use a
 general combine operation
 d = (d  ~m) | (s  m)
 on a word-by-word basis.  Not always.  The word-by-word
 combine takes a time that is independent of the mask data.
 If the mask is relatively sparse, the byte-check method
 is actually faster!
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">1 bpp, 8 bpp gray or 32 bpp rgb; no cmap</param>
	<param name="pixs">1 bpp, 8 bpp gray or 32 bpp rgb; no cmap</param>
	<param name="pixm">1 bpp mask; no operation if NULL</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCombineMaskedGeneral(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) In-place operation; pixd is changed.
 (2) This is a generalized version of pixCombinedMasked(), where
 the source and mask can be placed at the same (arbitrary)
 location relative to pixd.
 (3) pixs and pixd must be the same depth and not colormapped.
 (4) The UL corners of both pixs and pixm are aligned with
 the point (x, y) of pixd, and the operation is clipped to
 the intersection of all three images.
 (5) If pixm == NULL, it's a no-op.
 (6) Implementation.  There are two ways to do these.  In the first,
 we use rasterop, ORing the part of pixs under the mask
 with pixd (which has been appropriately cleared there first).
 In the second, the mask is used one pixel at a time to
 selectively replace pixels of pixd with those of pixs.
 Here, we use rasterop for 1 bpp and pixel-wise replacement
 for 8 and 32 bpp.  To use rasterop for 8 bpp, for example,
 we must first generate an 8 bpp version of the mask.
 The code is simple
 Pix pixm8 = pixConvert1To8(NULL, pixm, 0, 255);
 Pix pixt = pixAnd(NULL, pixs, pixm8);
 pixRasterop(pixd, x, y, wmin, hmin, PIX_DST  PIX_NOT(PIX_SRC),
 pixm8, 0, 0);
 pixRasterop(pixd, x, y, wmin, hmin, PIX_SRC | PIX_DST,
 pixt, 0, 0);
 pixDestroy(pixt);
 pixDestroy(pixm8);
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">1 bpp, 8 bpp gray or 32 bpp rgb</param>
	<param name="pixs">1 bpp, 8 bpp gray or 32 bpp rgb</param>
	<param name="pixm">1 bpp mask</param>
	<param name="x">origin of pixs and pixm relative to pixd; can be negative</param>
	<param name="y">origin of pixs and pixm relative to pixd; can be negative</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixPaintThroughMask(LeptonicaSharp.Pix,System.Int32,System.Int32,System.UInt32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) In-place operation.  Calls pixSetMaskedCmap() for colormapped
 images.
 (2) For 1, 2, 4, 8 and 16 bpp gray, we take the appropriate
 number of least significant bits of val.
 (3) If pixm == NULL, it's a no-op.
 (4) The mask origin is placed at (x,y) on pixd, and the
 operation is clipped to the intersection of rectangles.
 (5) For rgb, the components in val are in the canonical locations,
 with red in location COLOR_RED, etc.
 (6) Implementation detail 1
 For painting with val == 0 or val == maxval, you can use rasterop.
 If val == 0, invert the mask so that it's 0 over the region
 into which you want to write, and use PIX_SRC  PIX_DST to
 clear those pixels.  To write with val = maxval (all 1's),
 use PIX_SRC | PIX_DST to set all bits under the mask.
 (7) Implementation detail 2
 The rasterop trick can be used for depth GT 1 as well.
 For val == 0, generate the mask for depth d from the binary
 mask using
 pixmd = pixUnpackBinary(pixm, d, 1);
 and use pixRasterop() with PIX_MASK.  For val == maxval,
 pixmd = pixUnpackBinary(pixm, d, 0);
 and use pixRasterop() with PIX_PAINT.
 But note that if d == 32 bpp, it is about 3x faster to use
 the general implementation (not pixRasterop()).
 (8) Implementation detail 3
 It might be expected that the switch in the inner loop will
 cause large branching delays and should be avoided.
 This is not the case, because the entrance is always the
 same and the compiler can correctly predict the jump.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">1, 2, 4, 8, 16 or 32 bpp; or colormapped</param>
	<param name="pixm">1 bpp mask</param>
	<param name="x">origin of pixm relative to pixd; can be negative</param>
	<param name="y">origin of pixm relative to pixd; can be negative</param>
	<param name="val">pixel value to set at each masked pixel</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixPaintSelfThroughMask(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_direction,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) In-place operation; pixd is changed.
 (2) If pixm == NULL, it's a no-op.
 (3) The mask origin is placed at (x,y) on pixd, and the
 operation is clipped to the intersection of pixd and the
 fg of the mask.
 (4) %tsize is the the requested size for tiling.  The actual
 actual size for each c.c. will be bounded by the minimum
 dimension of the c.c.
 (5) For %mindist, %searchdir and %ntiles, see pixFindRepCloseTile().
 They determine the set of possible tiles that can be used
 to build a larger mirrored tile to paint onto pixd through
 the c.c. of pixm.
 (6) %distblend is used for alpha blending.  It is only applied
 if there is exactly one c.c. in the mask.  Use distblend == 0
 to skip blending and just paint through the 1 bpp mask.
 (7) To apply blending to more than 1 component, call this function
 repeatedly with %pixm, %x and %y representing one component of
 the mask each time.  This would be done as follows, for an
 underlying image pixs and mask pixm of components to fill
 Boxa boxa = pixConnComp(pixm, pixa, 8);
 n = boxaGetCount(boxa);
 for (i = 0; i LT n; i++) {
 Pix pix = pixaGetPix(pixa, i, L_CLONE);
 Box box = pixaGetBox(pixa, i, L_CLONE);
 boxGetGeometry(box, bx, by, bw, bh);
 pixPaintSelfThroughMask(pixs, pix, bx, by, searchdir,
 mindist, tilesize, ntiles, distblend);
 pixDestroy(pix);
 boxDestroy(box);
 }
 pixaDestroy(pixa);
 boxaDestroy(boxa);
 (8) If no tiles can be found, this falls back to estimating the
 color near the boundary of the region to be textured.
 (9) This can be used to replace the pixels in some regions of
 an image by selected neighboring pixels.  The mask represents
 the pixels to be replaced.  For each connected component in
 the mask, this function selects up to two tiles of neighboring
 pixels to be used for replacement of pixels represented by
 the component (i.e., under the FG of that component in the mask).
 After selection, mirror replication is used to generate an
 image that is large enough to cover the component.  Alpha
 blending can also be used outside of the component, but near the
 edge, to blur the transition between painted and original pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8 bpp gray or 32 bpp rgb; not colormapped</param>
	<param name="pixm">1 bpp mask</param>
	<param name="x">origin of pixm relative to pixd; must not be negative</param>
	<param name="y">origin of pixm relative to pixd; must not be negative</param>
	<param name="searchdir">L_HORIZ, L_VERT or L_BOTH_DIRECTIONS</param>
	<param name="mindist">min distance of nearest tile edge to box; GT= 0</param>
	<param name="tilesize">requested size for tiling; may be reduced</param>
	<param name="ntiles">number of tiles tested in each row/column</param>
	<param name="distblend">distance outside the fg used for blending with pixs</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMakeMaskFromVal(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This generates a 1 bpp mask image, where a 1 is written in
 the mask for each pixel in pixs that has a value %val.
 (2) If no pixels have the value, an empty mask is generated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp; can be colormapped</param>
	<param name="val">pixel value</param>
	<returns>pixd 1 bpp mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMakeMaskFromLUT(LeptonicaSharp.Pix,System.Int32[])">
	<summary>
 Notes
 (1) This generates a 1 bpp mask image, where a 1 is written in
 the mask for each pixel in pixs that has a value corresponding
 to a 1 in the LUT.
 (2) The LUT should be of size 256.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp; can be colormapped</param>
	<param name="tab">256-entry LUT; 1 means to write to mask</param>
	<returns>pixd 1 bpp mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMakeArbMaskFromRGB(LeptonicaSharp.Pix,System.Single,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This generates a 1 bpp mask image, where a 1 is written in
 the mask for each pixel in pixs that satisfies
 rc  rval + gc  gval + bc  bval GT thresh
 where rval is the red component, etc.
 (2) Unlike with pixConvertToGray(), there are no constraints
 on the color coefficients, which can be negative.  For
 example, a mask that discriminates against red and in favor
 of blue will have rc LT 0.0 and bc GT 0.0.
 (3) To make the result independent of intensity (the 'V' in HSV),
 select coefficients so that %thresh = 0.  Then the result
 is not changed when all components are multiplied by the
 same constant (as long as nothing saturates).  This can be
 useful if, for example, the illumination is not uniform.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<param name="rc">arithmetic factors; can be negative</param>
	<param name="gc">arithmetic factors; can be negative</param>
	<param name="bc">arithmetic factors; can be negative</param>
	<param name="thresh">lower threshold on weighted sum of components</param>
	<returns>pixd 1 bpp mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetUnderTransparency(LeptonicaSharp.Pix,System.UInt32,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This sets the r, g and b components under every fully
 transparent alpha component to %val.  The alpha components
 are unchanged.
 (2) Full transparency is denoted by alpha == 0.  Setting
 all pixels to a constant %val where alpha is transparent
 can improve compressibility by reducing the entropy.
 (3) The visual result depends on how the image is displayed.
 (a) For display devices that respect the use of the alpha
 layer, this will not affect the appearance.
 (b) For typical leptonica operations, alpha is ignored,
 so there will be a change in appearance because this
 resets the rgb values in the fully transparent region.
 (4) pixRead() and pixWrite() will, by default, read and write
 4-component (rgba) pix in png format.  To ignore the alpha
 component after reading, or omit it on writing, pixSetSpp(..., 3).
 (5) Here are some examples
 To convert all fully transparent pixels in a 4 component
 (rgba) png file to white
 pixs = pixRead(LTinfileGT);
 pixd = pixSetUnderTransparency(pixs, 0xffffff00, 0);
 To write pixd with the alpha component
 pixWrite(LToutfileGT, pixd, IFF_PNG);
 To write and rgba image without the alpha component, first do
 pixSetSpp(pixd, 3);
 If you later want to use the alpha, spp must be reset to 4.
 (fancier) To remove the alpha by blending the image over
 a white background
 pixRemoveAlpha()
 This changes all pixel values where the alpha component is
 not opaque (255).
 (6) Caution.  rgb images in leptonica typically have value 0 in
 the alpha channel, which is fully transparent.  If spp for
 such an image were changed from 3 to 4, the image becomes
 fully transparent, and this function will set each pixel to %val.
 If you really want to set every pixel to the same value,
 use pixSetAllArbitrary().
 (7) This is useful for compressing an RGBA image where the part
 of the image that is fully transparent is random junk; compression
 is typically improved by setting that region to a constant.
 For rendering as a 3 component RGB image over a uniform
 background of arbitrary color, use pixAlphaBlendUniform().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgba</param>
	<param name="val">32 bit unsigned color to use where alpha == 0</param>
	<param name="debug">displays layers of pixs</param>
	<returns>pixd 32 bpp rgba, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMakeAlphaFromMask(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Box@)">
	<summary>
 Notes
 (1) This generates a 8 bpp alpha layer that is opaque (256)
 over the FG of pixs, and goes transparent linearly away
 from the FG pixels, decaying to 0 (transparent) is an
 8-connected distance given by %dist.  If %dist == 0,
 this does a simple conversion from 1 to 8 bpp.
 (2) If box == NULL, this returns an alpha mask that is the
 full size of pixs.  Otherwise, the returned mask pixd covers
 just the FG pixels of pixs, expanded by %dist in each
 direction (if possible), and the returned box gives the
 location of the returned mask relative to pixs.
 (3) This is useful for painting through a mask and allowing
 blending of the painted image with an underlying image
 in the mask background for pixels near foreground mask pixels.
 For example, with an underlying rgb image pix1, an overlaying
 image rgb pix2, binary mask pixm, and dist GT 0, this
 blending is achieved with
 pix3 = pixMakeAlphaFromMask(pixm, dist, box);
 boxGetGeometry(box, x, y, NULL, NULL);
 pix4 = pixBlendWithGrayMask(pix1, pix2, pix3, x, y);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="dist">blending distance; typically 10 - 30</param>
	<param name="pbox">use NULL to get the full size</param>
	<returns>pixd (8 bpp gray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetColorNearMaskBoundary(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Box,System.Int32,System.UInt32@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This finds the average color in a set of pixels that are
 roughly a distance %dist from the c.c. boundary and in the
 background of the mask image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="pixm">1 bpp mask, full image</param>
	<param name="box">region of mask; typically b.b. of a component</param>
	<param name="dist">distance into BG from mask boundary to use</param>
	<param name="pval">average pixel value</param>
	<param name="debug">1 to output mask images</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixInvert(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This inverts pixs, for all pixel depths.
 (2) There are 3 cases
 (a) pixd == null,   ~src --GT new pixd
 (b) pixd == pixs,   ~src --GT src  (in-place)
 (c) pixd != pixs,   ~src --GT input pixd
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixInvert(NULL, pixs);
 (b) pixInvert(pixs, pixs);
 (c) pixInvert(pixd, pixs);
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs"></param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixOr(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This gives the union of two images with equal depth,
 aligning them to the the UL corner.  pixs1 and pixs2
 need not have the same width and height.
 (2) There are 3 cases
 (a) pixd == null,   (src1 | src2) --GT new pixd
 (b) pixd == pixs1,  (src1 | src2) --GT src1  (in-place)
 (c) pixd != pixs1,  (src1 | src2) --GT input pixd
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixOr(NULL, pixs1, pixs2);
 (b) pixOr(pixs1, pixs1, pixs2);
 (c) pixOr(pixd, pixs1, pixs2);
 (4) The size of the result is determined by pixs1.
 (5) The depths of pixs1 and pixs2 must be equal.
 (6) Note carefully that the order of pixs1 and pixs2 only matters
 for the in-place case.  For in-place, you must have
 pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
 result the copy puts pixs1 image data in pixs2, and
 the rasterop is then between pixs2 and pixs2 (a no-op).
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs1, different from pixs1</param>
	<param name="pixs1">can be == pixd</param>
	<param name="pixs2">must be != pixd</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAnd(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This gives the intersection of two images with equal depth,
 aligning them to the the UL corner.  pixs1 and pixs2
 need not have the same width and height.
 (2) There are 3 cases
 (a) pixd == null,   (src1  src2) --GT new pixd
 (b) pixd == pixs1,  (src1  src2) --GT src1  (in-place)
 (c) pixd != pixs1,  (src1  src2) --GT input pixd
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixAnd(NULL, pixs1, pixs2);
 (b) pixAnd(pixs1, pixs1, pixs2);
 (c) pixAnd(pixd, pixs1, pixs2);
 (4) The size of the result is determined by pixs1.
 (5) The depths of pixs1 and pixs2 must be equal.
 (6) Note carefully that the order of pixs1 and pixs2 only matters
 for the in-place case.  For in-place, you must have
 pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
 result the copy puts pixs1 image data in pixs2, and
 the rasterop is then between pixs2 and pixs2 (a no-op).
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs1, different from pixs1</param>
	<param name="pixs1">can be == pixd</param>
	<param name="pixs2">must be != pixd</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixXor(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This gives the XOR of two images with equal depth,
 aligning them to the the UL corner.  pixs1 and pixs2
 need not have the same width and height.
 (2) There are 3 cases
 (a) pixd == null,   (src1 ^ src2) --GT new pixd
 (b) pixd == pixs1,  (src1 ^ src2) --GT src1  (in-place)
 (c) pixd != pixs1,  (src1 ^ src2) --GT input pixd
 (3) For clarity, if the case is known, use these patterns
 (a) pixd = pixXor(NULL, pixs1, pixs2);
 (b) pixXor(pixs1, pixs1, pixs2);
 (c) pixXor(pixd, pixs1, pixs2);
 (4) The size of the result is determined by pixs1.
 (5) The depths of pixs1 and pixs2 must be equal.
 (6) Note carefully that the order of pixs1 and pixs2 only matters
 for the in-place case.  For in-place, you must have
 pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
 result the copy puts pixs1 image data in pixs2, and
 the rasterop is then between pixs2 and pixs2 (a no-op).
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs1, different from pixs1</param>
	<param name="pixs1">can be == pixd</param>
	<param name="pixs2">must be != pixd</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSubtract(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This gives the set subtraction of two images with equal depth,
 aligning them to the the UL corner.  pixs1 and pixs2
 need not have the same width and height.
 (2) Source pixs2 is always subtracted from source pixs1.
 The result is
 pixs1 \ pixs2 = pixs1  (~pixs2)
 (3) There are 4 cases
 (a) pixd == null,   (src1 - src2) --GT new pixd
 (b) pixd == pixs1,  (src1 - src2) --GT src1  (in-place)
 (c) pixd == pixs2,  (src1 - src2) --GT src2  (in-place)
 (d) pixd != pixs1  pixd != pixs2),
 (src1 - src2) --GT input pixd
 (4) For clarity, if the case is known, use these patterns
 (a) pixd = pixSubtract(NULL, pixs1, pixs2);
 (b) pixSubtract(pixs1, pixs1, pixs2);
 (c) pixSubtract(pixs2, pixs1, pixs2);
 (d) pixSubtract(pixd, pixs1, pixs2);
 (5) The size of the result is determined by pixs1.
 (6) The depths of pixs1 and pixs2 must be equal.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs1, equal to pixs2, or different from both pixs1 and pixs2</param>
	<param name="pixs1">can be == pixd</param>
	<param name="pixs2">can be == pixd</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixZero(LeptonicaSharp.Pix,System.Int32@)">
	<summary>
 Notes
 (1) For a binary image, if there are no fg (black) pixels, empty = 1.
 (2) For a grayscale image, if all pixels are black (0), empty = 1.
 (3) For an RGB image, if all 4 components in every pixel is 0,
 empty = 1.
 (4) For a colormapped image, pixel values are 0.  The colormap
 is ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">all depths; colormap OK</param>
	<param name="pempty">1 if all bits in image data field are 0; 0 otherwise</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixForegroundFraction(LeptonicaSharp.Pix,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="pfract">fraction of ON pixels</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaCountPixels(LeptonicaSharp.Pixa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa">array of 1 bpp pix</param>
	<returns>na of ON pixels in each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCountPixels(LeptonicaSharp.Pix,System.Int32@,System.Int32[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pcount">count of ON pixels</param>
	<param name="tab8">8-bit pixel lookup table</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCountPixelsInRect(LeptonicaSharp.Pix,LeptonicaSharp.Box,System.Int32@,System.Int32[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="box">(can be null)</param>
	<param name="pcount">count of ON pixels</param>
	<param name="tab8">8-bit pixel lookup table</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCountByRow(LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="box">clipping box for count; can be null</param>
	<returns>na of number of ON pixels by row, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCountByColumn(LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="box">clipping box for count; can be null</param>
	<returns>na of number of ON pixels by column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCountPixelsByRow(LeptonicaSharp.Pix,System.Int32[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="tab8">8-bit pixel lookup table</param>
	<returns>na of counts, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCountPixelsByColumn(LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<returns>na of counts in each column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCountPixelsInRow(LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Int32[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="row">number</param>
	<param name="pcount">sum of ON pixels in raster line</param>
	<param name="tab8">8-bit pixel lookup table</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetMomentByColumn(LeptonicaSharp.Pix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="order">of moment, either 1 or 2</param>
	<returns>na of first moment of fg pixels, by column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixThresholdPixelSum(LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Int32[])">
	<summary>
 Notes
 (1) This sums the ON pixels and returns immediately if the count
 goes above threshold.  It is therefore more efficient
 for matching images (by running this function on the xor of
 the 2 images) than using pixCountPixels(), which counts all
 pixels before returning.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="thresh">threshold</param>
	<param name="pabove">1 if above threshold; 0 if equal to or less than threshold</param>
	<param name="tab8">8-bit pixel lookup table</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makePixelSumTab8">
	<summary>
 Notes
 (1) This table of integers gives the number of 1 bits
 in the 8 bit index.
 </summary>
	<remarks>
	</remarks>
	<returns>table of 256 l_int32, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makePixelCentroidTab8">
	<summary>
 Notes
 (1) This table of integers gives the centroid weight of the 1 bits
 in the 8 bit index.  In other words, if sumtab is obtained by
 makePixelSumTab8, and centroidtab is obtained by
 makePixelCentroidTab8, then, for 1 LT= i LT= 255,
 centroidtab[i] / (float)sumtab[i]
 is the centroid of the 1 bits in the 8-bit index i, where the
 MSB is considered to have position 0 and the LSB is considered
 to have position 7.
 </summary>
	<remarks>
	</remarks>
	<returns>table of 256 l_int32, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAverageByRow(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_IS_MAX,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 (2) If type == L_BLACK_IS_MAX, black pixels get the maximum
 value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 or 16 bpp; no colormap</param>
	<param name="box">clipping box for sum; can be null</param>
	<param name="type">L_WHITE_IS_MAX, L_BLACK_IS_MAX</param>
	<returns>na of pixel averages by row, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAverageByColumn(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_IS_MAX,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 (2) If type == L_BLACK_IS_MAX, black pixels get the maximum
 value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 or 16 bpp; no colormap</param>
	<param name="box">clipping box for sum; can be null</param>
	<param name="type">L_WHITE_IS_MAX, L_BLACK_IS_MAX</param>
	<returns>na of pixel averages by column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAverageInRect(LeptonicaSharp.Pix,System.Single[]@,LeptonicaSharp.Box)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1, 2, 4, 8 bpp; not cmapped</param>
	<param name="box">if null, use entire image</param>
	<param name="pave">average of pixel values in region</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixVarianceByRow(LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 (2) We are actually computing the RMS deviation in each row.
 This is the square root of the variance.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 or 16 bpp; no colormap</param>
	<param name="box">clipping box for variance; can be null</param>
	<returns>na of rmsdev by row, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixVarianceByColumn(LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 (2) We are actually computing the RMS deviation in each row.
 This is the square root of the variance.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 or 16 bpp; no colormap</param>
	<param name="box">clipping box for variance; can be null</param>
	<returns>na of rmsdev by column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixVarianceInRect(LeptonicaSharp.Pix,System.Single[]@,LeptonicaSharp.Box)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">1, 2, 4, 8 bpp; not cmapped</param>
	<param name="box">if null, use entire image</param>
	<param name="prootvar">sqrt variance of pixel values in region</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAbsDiffByRow(LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This is an average over differences of adjacent pixels along
 each row.
 (2) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; no colormap</param>
	<param name="box">clipping box for region; can be null</param>
	<returns>na of abs val pixel difference averages by row, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAbsDiffByColumn(LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This is an average over differences of adjacent pixels along
 each column.
 (2) To resample for a bin size different from 1, use
 numaUniformSampling() on the result of this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; no colormap</param>
	<param name="box">clipping box for region; can be null</param>
	<returns>na of abs val pixel difference averages by column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAbsDiffInRect(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_LINE,System.Single[]@,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This gives the average over the abs val of differences of
 adjacent pixels values, along either each
 row  dir == L_HORIZONTAL_LINE
 column  dir == L_VERTICAL_LINE
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; not cmapped</param>
	<param name="box">if null, use entire image</param>
	<param name="dir">differences along L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
	<param name="pabsdiff">average of abs diff pixel values in region</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAbsDiffOnLine(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Single[]@)">
	<summary>
 Notes
 (1) This gives the average over the abs val of differences of
 adjacent pixels values, along a line that is either horizontal
 or vertical.
 (2) If horizontal, require x1 LT x2; if vertical, require y1 LT y2.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; not cmapped</param>
	<param name="x1">first point; x1 LT= x2, y1 LT= y2</param>
	<param name="y1">first point; x1 LT= x2, y1 LT= y2</param>
	<param name="x2">first point</param>
	<param name="y2">first point</param>
	<param name="pabsdiff">average of abs diff pixel values on line</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCountArbInRect(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32@,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) If pixs is cmapped, %val is compared to the colormap index;
 otherwise, %val is compared to the grayscale value.
 (2) Set the subsampling %factor GT 1 to reduce the amount of computation.
 If %factor GT 1, multiply the count by %factor  %factor.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, or colormapped</param>
	<param name="box">over which count is made; use entire image if NULL</param>
	<param name="val">pixel value to count</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="pcount">count; estimate it if factor GT 1</param>
	<returns>na histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMirroredTiling(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This uses mirrored tiling, where each row alternates
 with LR flips and every column alternates with TB
 flips, such that the result is a tiling with identical
 2 x 2 tiles, each of which is composed of these transforms
 -----------------
 | 1 |  LR |
 -----------------
 | TB   |  LR/TB |
 -----------------
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp, small tile; to be replicated</param>
	<param name="w">dimensions of output pix</param>
	<param name="h">dimensions of output pix</param>
	<returns>pixd usually larger pix, mirror-tiled with pixs, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindRepCloseTile(LeptonicaSharp.Pix,LeptonicaSharp.Box,LeptonicaSharp.Enumerations.L_direction,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Box@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This looks for one or two square tiles with conforming median
 intensity and low variance, that is outside but near the input box.
 (2) %mindist specifies the gap between the box and the
 potential tiles.  The tiles are given an overlap of 50%.
 %ntiles specifies the number of tiles that are tested
 beyond %mindist for each row or column.
 (3) For example, if %mindist = 20, %tilesize = 50 and %ntiles = 3,
 a horizontal search to the right will have 3 tiles in each row,
 with left edges at 20, 45 and 70 from the right edge of the
 input %box.  The number of rows of tiles is determined by
 the height of %box and %tsize, with the 50% overlap..
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="box">region of pixs to search around</param>
	<param name="searchdir">L_HORIZ or L_VERT; direction to search</param>
	<param name="mindist">min distance of selected tile edge from box; GT= 0</param>
	<param name="tsize">tile size; GT 1; even; typically ~50</param>
	<param name="ntiles">number of tiles tested in each row/column</param>
	<param name="pboxtile">region of best tile</param>
	<param name="debug">1    for debug output</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetGrayHistogram(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) If pixs has a colormap, it is converted to 8 bpp gray.
 If you want a histogram of the colormap indices, use
 pixGetCmapHistogram().
 (2) If pixs does not have a colormap, the output histogram is
 of size 2^d, where d is the depth of pixs.
 (3) Set the subsampling factor GT 1 to reduce the amount of computation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 bpp; can be colormapped</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>na histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetGrayHistogramMasked(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If pixs is cmapped, it is converted to 8 bpp gray.
 If you want a histogram of the colormap indices, use
 pixGetCmapHistogramMasked().
 (2) This always returns a 256-value histogram of pixel values.
 (3) Set the subsampling factor GT 1 to reduce the amount of computation.
 (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
 (5) Input x,y are ignored unless pixm exists.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, or colormapped</param>
	<param name="pixm">1 bpp mask over which histogram is to be computed; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>na histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetGrayHistogramInRect(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) If pixs is cmapped, it is converted to 8 bpp gray.
 If you want a histogram of the colormap indices, use
 pixGetCmapHistogramInRect().
 (2) This always returns a 256-value histogram of pixel values.
 (3) Set the subsampling %factor GT 1 to reduce the amount of computation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, or colormapped</param>
	<param name="box">over which histogram is to be computed; use full image if NULL</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>na histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetGrayHistogramTiled(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If pixs is cmapped, it is converted to 8 bpp gray.
 (2) This returns a set of 256-value histograms of pixel values.
 (3) Set the subsampling factor GT 1 to reduce the amount of computation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, colormap OK</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="nx">tiling; GT= 1; typically small</param>
	<param name="ny">tiling; GT= 1; typically small</param>
	<returns>naa set of histograms, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetColorHistogram(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This generates a set of three 256 entry histograms,
 one for each color component (r,g,b).
 (2) Set the subsampling %factor GT 1 to reduce the amount of computation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">rgb or colormapped</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="pnar">red histogram</param>
	<param name="pnag">green histogram</param>
	<param name="pnab">blue histogram</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetColorHistogramMasked(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This generates a set of three 256 entry histograms,
 (2) Set the subsampling %factor GT 1 to reduce the amount of computation.
 (3) Clipping of pixm (if it exists) to pixs is done in the inner loop.
 (4) Input x,y are ignored unless pixm exists.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb, or colormapped</param>
	<param name="pixm">1 bpp mask over which histogram is to be computed; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="pnar">red histogram</param>
	<param name="pnag">green histogram</param>
	<param name="pnab">blue histogram</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetCmapHistogram(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This generates a histogram of colormap pixel indices,
 and is of size 2^d.
 (2) Set the subsampling %factor GT 1 to reduce the amount of computation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped d = 2, 4 or 8</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>na histogram of cmap indices, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetCmapHistogramMasked(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This generates a histogram of colormap pixel indices,
 and is of size 2^d.
 (2) Set the subsampling %factor GT 1 to reduce the amount of computation.
 (3) Clipping of pixm to pixs is done in the inner loop.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped d = 2, 4 or 8</param>
	<param name="pixm">1 bpp mask over which histogram is to be computed; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>na histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetCmapHistogramInRect(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This generates a histogram of colormap pixel indices,
 and is of size 2^d.
 (2) Set the subsampling %factor GT 1 to reduce the amount of computation.
 (3) Clipping to the box is done in the inner loop.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">colormapped d = 2, 4 or 8</param>
	<param name="box">over which histogram is to be computed; use full image if NULL</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>na histogram, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCountRGBColors(LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">rgb or rgba</param>
	<returns>ncolors, or -1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetColorAmapHistogram(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This generates an ordered map from pixel value to histogram count.
 (2) Use amapGetCountForColor() to use the map to look up a count.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">rgb or rgba</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<returns>amap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.amapGetCountForColor(LeptonicaSharp.L_Rbtree,System.UInt32)">
	<summary>
 Notes
 (1) The ordered map is made by pixGetColorAmapHistogram().
 </summary>
	<remarks>
	</remarks>
	<param name="amap">map from pixel value to count</param>
	<param name="val">rgb or rgba pixel value</param>
	<returns>count, or -1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRankValue(LeptonicaSharp.Pix,System.Int32,System.Single,System.UInt32@)">
	<summary>
 Notes
 (1) Simple function to get rank values of an image.
 For a color image, the median value (rank = 0.5) can be
 used to linearly remap the colors based on the median
 of a target image, using pixLinearMapToTargetColor().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, 32 bpp or colormapped</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="rank">between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest</param>
	<param name="pvalue">pixel value corresponding to input rank</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRankValueMaskedRGB(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Single,LeptonicaSharp.Pix,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) Computes the rank component values of pixels in pixs that
 are under the fg of the optional mask.  If the mask is null, it
 computes the average of the pixels in pixs.
 (2) Set the subsampling %factor GT 1 to reduce the amount of
 computation.
 (4) Input x,y are ignored unless pixm exists.
 (5) The rank must be in [0.0 ... 1.0], where the brightest pixel
 has rank 1.0.  For the median pixel value, use 0.5.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="pixm">1 bpp mask over which rank val is to be taken; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="rank">between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest</param>
	<param name="prval">red component val for input rank</param>
	<param name="pgval">green component val for input rank</param>
	<param name="pbval">blue component val for input rank</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRankValueMasked(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Single,System.Single[]@,LeptonicaSharp.Pix,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) Computes the rank value of pixels in pixs that are under
 the fg of the optional mask.  If the mask is null, it
 computes the average of the pixels in pixs.
 (2) Set the subsampling %factor GT 1 to reduce the amount of
 computation.
 (3) Clipping of pixm (if it exists) to pixs is done in the inner loop.
 (4) Input x,y are ignored unless pixm exists.
 (5) The rank must be in [0.0 ... 1.0], where the brightest pixel
 has rank 1.0.  For the median pixel value, use 0.5.
 (6) The histogram can optionally be returned, so that other rank
 values can be extracted without recomputing the histogram.
 In that case, just use
 numaHistogramGetValFromRank(na, rank, val);
 on the returned Numa for additional rank values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, or colormapped</param>
	<param name="pixm">1 bpp mask, over which the rank val is to be taken; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0; these values are ignored if pixm is null</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="rank">between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest</param>
	<param name="pval">pixel value corresponding to input rank</param>
	<param name="pna">of histogram</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetPixelAverage(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.UInt32@,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For rgb pix, this is a more direct computation of the
 average value of the pixels in %pixs that are under the
 mask %pixm. It is faster than pixGetPixelStats(), which
 calls pixGetAverageMaskedRGB() and has the overhead of
 generating a temporary pix of each of the three components;
 this can take most of the time if %factor GT 1.
 (2) If %pixm is null, this gives the average value of all
 pixels in %pixs.  The returned value is an integer.
 (3) For color %pixs, the returned pixel value is in the standard
 uint32 RGBA packing.
 (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
 (5) Input x,y are ignored if %pixm does not exist.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp, or colormapped</param>
	<param name="pixm">1 bpp mask over which average is to be taken; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="pval">average pixel value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetPixelStats(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Enumerations.L_statistical_measures,System.UInt32@)">
	<summary>
 Notes
 (1) Simple function to get one of four statistical values of an image.
 (2) It does not take a mask it uses the entire image.
 (3) To get the average pixel value of an RGB image, suggest using
 pixGetPixelAverage(), which is considerably faster.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, 32 bpp or colormapped</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="type">L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION, L_VARIANCE</param>
	<param name="pvalue">pixel value corresponding to input type</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetAverageMaskedRGB(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_statistical_measures,LeptonicaSharp.Pix,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) For usage, see pixGetAverageMasked().
 (2) If there is a colormap, it is removed before the 8 bpp
 component images are extracted.
 (3) A better name for this would be pixGetPixelStatsRGB()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, or colormapped</param>
	<param name="pixm">1 bpp mask over which average is to be taken; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="type">L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION, L_VARIANCE</param>
	<param name="prval">measured red value of given 'type'</param>
	<param name="pgval">measured green value of given 'type'</param>
	<param name="pbval">measured blue value of given 'type'</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetAverageMasked(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_statistical_measures,System.Single[]@,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Use L_MEAN_ABSVAL to get the average value of pixels in pixs
 that are under the fg of the optional mask.  If the mask
 is null, it finds the average of the pixels in pixs.
 (2) Likewise, use L_ROOT_MEAN_SQUARE to get the rms value of
 pixels in pixs, either masked or not; L_STANDARD_DEVIATION
 to get the standard deviation from the mean of the pixels;
 L_VARIANCE to get the average squared difference from the
 expected value.  The variance is the square of the stdev.
 For the standard deviation, we use
 sqrt([([x] - x)]^2) = sqrt([x^2] - [x]^2)
 (3) Set the subsampling %factor GT 1 to reduce the amount of
 computation.
 (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
 (5) Input x,y are ignored unless pixm exists.
 (6) A better name for this would be pixGetPixelStatsGray()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 16 bpp, or colormapped</param>
	<param name="pixm">1 bpp mask over which average is to be taken; use all pixels if null</param>
	<param name="x">UL corner of pixm relative to the UL corner of pixs; can be LT 0</param>
	<param name="y">UL corner of pixm relative to the UL corner of pixs; can be LT 0</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="type">L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION, L_VARIANCE</param>
	<param name="pval">measured value of given 'type'</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetAverageTiledRGB(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_statistical_measures,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) For usage, see pixGetAverageTiled().
 (2) If there is a colormap, it is removed before the 8 bpp
 component images are extracted.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, or colormapped</param>
	<param name="sx">tile size; must be at least 2 x 2</param>
	<param name="sy">tile size; must be at least 2 x 2</param>
	<param name="type">L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION</param>
	<param name="ppixr">tiled 'average' of red component</param>
	<param name="ppixg">tiled 'average' of green component</param>
	<param name="ppixb">tiled 'average' of blue component</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetAverageTiled(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_statistical_measures)">
	<summary>
 Notes
 (1) Only computes for tiles that are entirely contained in pixs.
 (2) Use L_MEAN_ABSVAL to get the average abs value within the tile;
 L_ROOT_MEAN_SQUARE to get the rms value within each tile;
 L_STANDARD_DEVIATION to get the standard dev. from the average
 within each tile.
 (3) If colormapped, converts to 8 bpp gray.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, or colormapped</param>
	<param name="sx">tile size; must be at least 2 x 2</param>
	<param name="sy">tile size; must be at least 2 x 2</param>
	<param name="type">L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION</param>
	<returns>pixd average values in each tile, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRowStats(LeptonicaSharp.Pix,LeptonicaSharp.Box,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This computes numas that represent column vectors of statistics,
 with each of its values derived from the corresponding row of a Pix.
 (2) Use NULL on input to prevent computation of any of the 5 numas.
 (3) Other functions that compute pixel row statistics are
 pixCountPixelsByRow()
 pixAverageByRow()
 pixVarianceByRow()
 pixGetRowStats()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; not cmapped</param>
	<param name="box">clipping box; can be null</param>
	<param name="pnamean">numa of mean values</param>
	<param name="pnamedian">numa of median values</param>
	<param name="pnamode">numa of mode intensity values</param>
	<param name="pnamodecount">numa of mode counts</param>
	<param name="pnavar">numa of variance</param>
	<param name="pnarootvar">numa of square root of variance</param>
	<returns>na numa of requested statistic for each row, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColumnStats(LeptonicaSharp.Pix,LeptonicaSharp.Box,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This computes numas that represent row vectors of statistics,
 with each of its values derived from the corresponding col of a Pix.
 (2) Use NULL on input to prevent computation of any of the 5 numas.
 (3) Other functions that compute pixel column statistics are
 pixCountPixelsByColumn()
 pixAverageByColumn()
 pixVarianceByColumn()
 pixGetColumnStats()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; not cmapped</param>
	<param name="box">clipping box; can be null</param>
	<param name="pnamean">numa of mean values</param>
	<param name="pnamedian">numa of median values</param>
	<param name="pnamode">numa of mode intensity values</param>
	<param name="pnamodecount">numa of mode counts</param>
	<param name="pnavar">numa of variance</param>
	<param name="pnarootvar">numa of square root of variance</param>
	<returns>na numa of requested statistic for each column, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRangeValues(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Enumerations.L_SELECT_,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If pixs is 8 bpp grayscale, the color selection type is ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, 32 bpp rgb, or colormapped</param>
	<param name="factor">subsampling factor; GT= 1; ignored if colormapped</param>
	<param name="color">L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE</param>
	<param name="pminval">minimum value of component</param>
	<param name="pmaxval">maximum value of component</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetExtremeValue(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Enumerations.L_SELECT_,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If pixs is grayscale, the result is returned in grayval.
 Otherwise, if there is a colormap or d == 32,
 each requested color component is returned.  At least
 one color component (address) must be input.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, 32 bpp rgb, or colormapped</param>
	<param name="factor">subsampling factor; GT= 1; ignored if colormapped</param>
	<param name="type">L_SELECT_MIN or L_SELECT_MAX</param>
	<param name="prval">red component</param>
	<param name="pgval">green component</param>
	<param name="pbval">blue component</param>
	<param name="pgrayval">min or max gray value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetMaxValueInRect(LeptonicaSharp.Pix,LeptonicaSharp.Box,System.UInt32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This can be used to find the maximum and its location
 in a 2-dimensional histogram, where the x and y directions
 represent two color components (e.g., saturation and hue).
 (2) Note that here a 32 bpp pixs has pixel values that are simply
 numbers.  They are not 8 bpp components in a colorspace.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16 or 32 bpp grayscale; no color space components</param>
	<param name="box">region; set box = NULL to use entire pixs</param>
	<param name="pmaxval">max value in region</param>
	<param name="pxmax">x location of max value</param>
	<param name="pymax">y location of max value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetBinnedComponentRange(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_SELECT_,System.Int32@,System.Int32@,System.Byte[]@,System.Int32)">
	<summary>
 Notes
 (1) This returns the min and max average values of the
 selected color component in the set of rank bins,
 where the ranking is done using the specified component.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="nbins">number of equal population bins; must be GT 1</param>
	<param name="factor">subsampling factor; GT= 1</param>
	<param name="color">L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE</param>
	<param name="pminval">minimum value of component</param>
	<param name="pmaxval">maximum value of component</param>
	<param name="pcarray">color array of bins</param>
	<param name="fontsize">0 for no debug; for debug, valid set is {4,6,8,10,12,14,16,18,20}.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRankColorArray(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Byte[]@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The color selection flag is one of L_SELECT_RED, L_SELECT_GREEN,
 L_SELECT_BLUE, L_SELECT_MIN, L_SELECT_MAX, L_SELECT_AVERAGE,
 L_SELECT_HUE, L_SELECT_SATURATION.
 (2) Then it finds the histogram of the selected color type in each
 RGB pixel.  For each of the %nbins sets of pixels,
 ordered by this color type value, find the average RGB color,
 and return this as a "rank color" array.  The output array
 has %nbins colors.
 (3) Set the subsampling factor GT 1 to reduce the amount of
 computation.  Typically you want at least 10,000 pixels
 for reasonable statistics.
 (4) The rank color as a function of rank can then be found from
 rankint = (l_int32)(rank  (nbins - 1) + 0.5);
 extractRGBValues(array[rankint], rval, gval, bval);
 where the rank is in [0.0 ... 1.0].
 This function is meant to be simple and approximate.
 (5) Compare this with pixGetBinnedColor(), which generates equal
 width intensity bins and finds the average color in each bin.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp or cmapped</param>
	<param name="nbins">number of equal population bins; must be GT 1</param>
	<param name="type">color selection flag</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="pcarray">array of colors, ranked by intensity</param>
	<param name="debugflag">1 to display color squares and plots of color components; 2 to write them as png to file</param>
	<param name="fontsize">0 for no debug; for debug, valid set is {4,6,8,10,12,14,16,18,20}.  Ignored if debugflag == 0.  fontsize == 6 is typical.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetBinnedColor(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Numa,System.Byte[]@,System.Int32)">
	<summary>
 Notes
 (1) This takes a color image, a grayscale (intensity) version,
 a LUT from intensity to bin number, and the number of bins.
 It computes the average color for pixels whose intensity
 is in each bin.  This is returned as an array of l_uint32
 colors in our standard RGBA ordering.
 (2) This function generates equal width intensity bins and
 finds the average color in each bin.  Compare this with
 pixGetRankColorArray(), which rank orders the pixels
 by the value of the selected component in each pixel,
 sets up bins with equal population (not intensity width!),
 and gets the average color in each bin.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="pixg">8 bpp grayscale version of pixs</param>
	<param name="factor">sampling factor along pixel counting direction</param>
	<param name="nbins">number of intensity bins</param>
	<param name="nalut">LUT for mapping from intensity to bin number</param>
	<param name="pcarray">array of average color values in each bin</param>
	<param name="debugflag">1 to display output debug plots of color components; 2 to write them as png to file</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDisplayColorArray(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="carray">array of colors 0xrrggbb00</param>
	<param name="ncolors">size of array</param>
	<param name="side">size of each color square; suggest 200</param>
	<param name="ncols">number of columns in output color matrix</param>
	<param name="fontsize">to label each square with text.  Valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	<returns>pixd color array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRankBinByStrip(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_scan_direction,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This generates a pix where each column represents a strip of
 the input image.  If %direction == L_SCAN_HORIZONTAL, the
 input impage is tiled into vertical strips of width %size,
 where %size is a compromise between getting better spatial
 columnwise resolution (small %size) and getting better
 columnwise statistical information (larger %size).  Likewise
 with rows of the image if %direction == L_SCAN_VERTICAL.
 (2) For L_HORIZONTAL_SCAN, the output pix contains rank binned
 median colors in each column that correspond to a vertical
 strip of width %size in the input image.
 (3) The color selection flag is one of L_SELECT_RED, L_SELECT_GREEN,
 L_SELECT_BLUE, L_SELECT_MIN, L_SELECT_MAX, L_SELECT_AVERAGE.
 It determines how the rank ordering is done.
 (4) Typical input values might be %size = 5, %nbins = 10.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp or cmapped</param>
	<param name="direction">L_SCAN_HORIZONTAL or L_SCAN_VERTICAL</param>
	<param name="size">of strips in scan direction</param>
	<param name="nbins">number of equal population bins; must be GT 1</param>
	<param name="type">color selection flag</param>
	<returns>pixd result, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaGetAlignedStats(LeptonicaSharp.Pixa,LeptonicaSharp.Enumerations.L_statistical_measures,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Each pixel in the returned pix represents an average
 (or median, or mode) over the corresponding pixels in each
 pix in the pixa.
 (2) The %thresh parameter works with L_MODE_VAL only, and
 sets a minimum occupancy of the mode bin.
 If the occupancy of the mode bin is less than %thresh, the
 mode value is returned as 0.  To always return the actual
 mode value, set %thresh = 0.  See pixGetRowStats().
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of identically sized, 8 bpp pix; not cmapped</param>
	<param name="type">L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT</param>
	<param name="nbins">of histogram for median and mode; ignored for mean</param>
	<param name="thresh">on histogram for mode val; ignored for all other types</param>
	<returns>pix with pixelwise aligned stats, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaExtractColumnFromEachPix(LeptonicaSharp.Pixa,System.Int32,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa">of identically sized, 8 bpp; not cmapped</param>
	<param name="col">column index</param>
	<param name="pixd">pix into which each column is inserted</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRowStats(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_statistical_measures,System.Int32,System.Int32,System.Single[])">
	<summary>
 Notes
 (1) This computes a column vector of statistics using each
 row of a Pix.  The result is put in %colvect.
 (2) The %thresh parameter works with L_MODE_VAL only, and
 sets a minimum occupancy of the mode bin.
 If the occupancy of the mode bin is less than %thresh, the
 mode value is returned as 0.  To always return the actual
 mode value, set %thresh = 0.
 (3) What is the meaning of this %thresh parameter?
 For each row, the total count in the histogram is w, the
 image width.  So %thresh, relative to w, gives a measure
 of the ratio of the bin width to the width of the distribution.
 The larger %thresh, the narrower the distribution must be
 for the mode value to be returned (instead of returning 0).
 (4) If the Pix consists of a set of corresponding columns,
 one for each Pix in a Pixa, the width of the Pix is the
 number of Pix in the Pixa and the column vector can
 be stored as a column in a Pix of the same size as
 each Pix in the Pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; not cmapped</param>
	<param name="type">L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT</param>
	<param name="nbins">of histogram for median and mode; ignored for mean</param>
	<param name="thresh">on histogram for mode; ignored for mean and median</param>
	<param name="colvect">vector of results gathered across the rows of pixs</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetColumnStats(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_statistical_measures,System.Int32,System.Int32,System.Single[])">
	<summary>
 Notes
 (1) This computes a row vector of statistics using each
 column of a Pix.  The result is put in %rowvect.
 (2) The %thresh parameter works with L_MODE_VAL only, and
 sets a minimum occupancy of the mode bin.
 If the occupancy of the mode bin is less than %thresh, the
 mode value is returned as 0.  To always return the actual
 mode value, set %thresh = 0.
 (3) What is the meaning of this %thresh parameter?
 For each column, the total count in the histogram is h, the
 image height.  So %thresh, relative to h, gives a measure
 of the ratio of the bin width to the width of the distribution.
 The larger %thresh, the narrower the distribution must be
 for the mode value to be returned (instead of returning 0).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; not cmapped</param>
	<param name="type">L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT</param>
	<param name="nbins">of histogram for median and mode; ignored for mean</param>
	<param name="thresh">on histogram for mode val; ignored for all other types</param>
	<param name="rowvect">vector of results gathered down the columns of pixs</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetPixelColumn(LeptonicaSharp.Pix,System.Int32,System.Single[])">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; not cmapped</param>
	<param name="col">column index</param>
	<param name="colvect">vector of floats</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixThresholdForFgBg(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; cmapped ok</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="thresh">threshold for generating foreground mask</param>
	<param name="pfgval">average foreground value</param>
	<param name="pbgval">average background value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSplitDistributionFgBg(LeptonicaSharp.Pix,System.Single,System.Int32,System.Int32@,System.Int32@,System.Int32@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) See numaSplitDistribution() for details on the underlying
 method of choosing a threshold.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; cmapped ok</param>
	<param name="scorefract">fraction of the max score, used to determine the range over which the histogram min is searched</param>
	<param name="factor">subsampling factor; integer GT= 1</param>
	<param name="pthresh">best threshold for separating</param>
	<param name="pfgval">average foreground value</param>
	<param name="pbgval">average background value</param>
	<param name="ppixdb">plot of distribution and split point</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaFindDimensions(LeptonicaSharp.Pixa,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pnaw">numa of pix widths</param>
	<param name="pnah">numa of pix heights</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindAreaPerimRatio(LeptonicaSharp.Pix,System.Single[]@,System.Int32[])">
	<summary>
 Notes
 (1) The area is the number of fg pixels that are not on the
 boundary (i.e., are not 8-connected to a bg pixel), and the
 perimeter is the number of fg boundary pixels.  Returns
 0.0 if there are no fg pixels.
 (2) This function is retained because clients are using it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="tab">pixel sum table, can be NULL</param>
	<param name="pfract">area/perimeter ratio</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaFindPerimToAreaRatio(LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) This is typically used for a pixa consisting of
 1 bpp connected components.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp pix</param>
	<returns>na   of perimeter/arear ratio for each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindPerimToAreaRatio(LeptonicaSharp.Pix,System.Single[]@,System.Int32[])">
	<summary>
 Notes
 (1) The perimeter is the number of fg boundary pixels, and the
 area is the number of fg pixels.  This returns 0.0 if
 there are no fg pixels.
 (2) Unlike pixFindAreaPerimRatio(), this uses the full set of
 fg pixels for the area, and the ratio is taken in the opposite
 order.
 (3) This is typically used for a single connected component.
 This always has a value LT= 1.0, and if the average distance
 of a fg pixel from the nearest bg pixel is d, this has
 a value ~1/d.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="tab">pixel sum table, can be NULL</param>
	<param name="pfract">perimeter/area ratio</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaFindPerimSizeRatio(LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) This is typically used for a pixa consisting of
 1 bpp connected components.
 (2) This has a minimum value for a circle of pi/4; a value for
 a rectangle component of approx. 1.0; and a value much larger
 than 1.0 for a component with a highly irregular boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp pix</param>
	<returns>na   of fg perimeter/(2(w+h)) ratio for each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindPerimSizeRatio(LeptonicaSharp.Pix,System.Single[]@,System.Int32[])">
	<summary>
 Notes
 (1) We take the 'size' as twice the sum of the width and
 height of pixs, and the perimeter is the number of fg
 boundary pixels.  We use the fg pixels of the boundary
 because the pix may be clipped to the boundary, so an
 erosion is required to count all boundary pixels.
 (2) This has a large value for dendritic, fractal-like components
 with highly irregular boundaries.
 (3) This is typically used for a single connected component.
 It has a value of about 1.0 for rectangular components with
 relatively smooth boundaries.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="tab">pixel sum table, can be NULL</param>
	<param name="pratio">perimeter/size ratio</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaFindAreaFraction(LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) This is typically used for a pixa consisting of
 1 bpp connected components.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp pix</param>
	<returns>na  of area fractions for each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindAreaFraction(LeptonicaSharp.Pix,System.Single[]@,System.Int32[])">
	<summary>
 Notes
 (1) This finds the ratio of the number of fg pixels to the
 size of the pix (w  h).  It is typically used for a
 single connected component.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="tab">pixel sum table, can be NULL</param>
	<param name="pfract">fg area/size ratio</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaFindAreaFractionMasked(LeptonicaSharp.Pixa,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This is typically used for a pixa consisting of
 1 bpp connected components, which has an associated
 boxa giving the location of the components relative
 to the mask origin.
 (2) The debug flag displays in green and red the masked and
 unmasked parts of the image from which pixa was derived.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp pix</param>
	<param name="pixm">mask image</param>
	<param name="debug">1 for output, 0 to suppress</param>
	<returns>na of ratio masked/total fractions for each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindAreaFractionMasked(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Single[]@,LeptonicaSharp.Box,System.Int32[])">
	<summary>
 Notes
 (1) This finds the ratio of the number of masked fg pixels
 in pixs to the total number of fg pixels in pixs.
 It is typically used for a single connected component.
 If there are no fg pixels, this returns a ratio of 0.0.
 (2) The box gives the location of the pix relative to that
 of the UL corner of the mask.  Therefore, the rasterop
 is performed with the pix translated to its location
 (x, y) in the mask before ANDing.
 If box == NULL, the UL corners of pixs and pixm are aligned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, typically a single component</param>
	<param name="box">for pixs relative to pixm</param>
	<param name="pixm">1 bpp mask, typically over the entire image from which the component pixs was extracted</param>
	<param name="tab">pixel sum table, can be NULL</param>
	<param name="pfract">fg area/size ratio</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaFindWidthHeightRatio(LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) This is typically used for a pixa consisting of
 1 bpp connected components.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp pix</param>
	<returns>na of width/height ratios for each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaFindWidthHeightProduct(LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) This is typically used for a pixa consisting of
 1 bpp connected components.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp pix</param>
	<returns>na of widthheight products for each pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindOverlapFraction(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single[]@,System.Int32[],System.Int32@)">
	<summary>
 Notes
 (1) The UL corner of pixs2 is placed at (x2, y2) in pixs1.
 (2) This measure is similar to the correlation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">1 bpp</param>
	<param name="pixs2">1 bpp</param>
	<param name="x2">location in pixs1 of UL corner of pixs2</param>
	<param name="y2">location in pixs1 of UL corner of pixs2</param>
	<param name="tab">pixel sum table, can be null</param>
	<param name="pratio">ratio fg intersection to fg union</param>
	<param name="pnoverlap">number of overlapping pixels</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindRectangleComps(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This applies the function pixConformsToRectangle() to
 each 8-c.c. in pixs, and returns a boxa containing the
 regions of all components that are conforming.
 (2) Conforming components must satisfy both the size constraint
 given by %minsize and the slop in conforming to a rectangle
 determined by %dist.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="dist">max distance allowed between bounding box and nearest foreground pixel within it</param>
	<param name="minw">minimum size in each direction as a requirement for a conforming rectangle</param>
	<param name="minh">minimum size in each direction as a requirement for a conforming rectangle</param>
	<returns>boxa of components that conform, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConformsToRectangle(LeptonicaSharp.Pix,System.Int32,System.Int32@,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) There are several ways to test if a connected component has
 an essentially rectangular boundary, such as
 a. Fraction of fill into the bounding box
 b. Max-min distance of fg pixel from periphery of bounding box
 c. Max depth of bg intrusions into component within bounding box
 The weakness of (a) is that it is highly sensitive to holes
 within the c.c.  The weakness of (b) is that it can have
 arbitrarily large intrusions into the c.c.  Method (c) tests
 the integrity of the outer boundary of the c.c., with respect
 to the enclosing bounding box, so we use it.
 (2) This tests if the connected component within the box conforms
 to the box at all points on the periphery within %dist.
 Inside, at a distance from the box boundary that is greater
 than %dist, we don't care about the pixels in the c.c.
 (3) We can think of the conforming condition as follows
 No pixel inside a distance %dist from the boundary
 can connect to the boundary through a path through the bg.
 To implement this, we need to do a flood fill.  We can go
 either from inside toward the boundary, or the other direction.
 It's easiest to fill from the boundary, and then verify that
 there are no filled pixels farther than %dist from the boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="box">if null, use the entire pixs</param>
	<param name="dist">max distance allowed between bounding box and nearest foreground pixel within it</param>
	<param name="pconforms">0 (false) if not conforming; 1 (true) if conforming</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixClipRectangles(LeptonicaSharp.Pix,LeptonicaSharp.Boxa)">
	<summary>
 Notes
 (1) The returned pixa includes the actual regions clipped out from
 the input pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="boxa">requested clipping regions</param>
	<returns>pixa consisting of requested regions, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixClipRectangle(LeptonicaSharp.Pix,LeptonicaSharp.Box,LeptonicaSharp.Box@)">
	<summary>
 Notes
 This should be simple, but there are choices to be made.
 The box is defined relative to the pix coordinates.  However,
 if the box is not contained within the pix, we have two choices
 (1) clip the box to the pix
 (2) make a new pix equal to the full box dimensions,
 but let rasterop do the clipping and positioning
 of the src with respect to the dest
 Choice (2) immediately brings up the problem of what pixel values
 to use that were not taken from the src.  For example, on a grayscale
 image, do you want the pixels not taken from the src to be black
 or white or something else?  To implement choice 2, one needs to
 specify the color of these extra pixels.
 So we adopt (1), and clip the box first, if necessary,
 before making the dest pix and doing the rasterop.  But there
 is another issue to consider.  If you want to paste the
 clipped pix back into pixs, it must be properly aligned, and
 it is necessary to use the clipped box for alignment.
 Accordingly, this function has a third (optional) argument, which is
 the input box clipped to the src pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="box">requested clipping region; const</param>
	<param name="pboxc">actual box of clipped region</param>
	<returns>clipped pix, or NULL on error or if rectangle doesn't intersect pixs</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixClipMasked(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) If pixs has a colormap, it is preserved in pixd.
 (2) The depth of pixd is the same as that of pixs.
 (3) If the depth of pixs is 1, use %outval = 0 for white background
 and 1 for black; otherwise, use the max value for white
 and 0 for black.  If pixs has a colormap, the max value for
 %outval is 0xffffffff; otherwise, it is 2^d - 1.
 (4) When using 1 bpp pixs, this is a simple clip and
 blend operation.  For example, if both pix1 and pix2 are
 black text on white background, and you want to OR the
 fg on the two images, let pixm be the inverse of pix2.
 Then the operation takes all of pix1 that's in the bg of
 pix2, and for the remainder (which are the pixels
 corresponding to the fg of the pix2), paint them black
 (1) in pix1.  The function call looks like
 pixClipMasked(pix2, pixInvert(pix1, pix1), x, y, 1);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp; colormap ok</param>
	<param name="pixm">clipping mask, 1 bpp</param>
	<param name="x">origin of clipping mask relative to pixs</param>
	<param name="y">origin of clipping mask relative to pixs</param>
	<param name="outval">val to use for pixels that are outside the mask</param>
	<returns>pixd, clipped pix or NULL on error or if pixm doesn't intersect pixs</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCropToMatch(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This resizes pixs1 and/or pixs2 by cropping at the right
 and bottom, so that they're the same size.
 (2) If a pix doesn't need to be cropped, a clone is returned.
 (3) Note the images are implicitly aligned to the UL corner.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">any depth, colormap OK</param>
	<param name="pixs2">any depth, colormap OK</param>
	<param name="ppixd1">may be a clone</param>
	<param name="ppixd2">may be a clone</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCropToSize(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If either w or h is smaller than the corresponding dimension
 of pixs, this returns a cropped image; otherwise it returns
 a clone of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, colormap OK</param>
	<param name="w">max dimensions of cropped image</param>
	<param name="h">max dimensions of cropped image</param>
	<returns>pixd cropped if necessary or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixResizeToMatch(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This resizes pixs to make pixd, without scaling, by either
 cropping or extending separately in both width and height.
 Extension is done by replicating the last row or column.
 This is useful in a situation where, due to scaling
 operations, two images that are expected to be the
 same size can differ slightly in each dimension.
 (2) You can use either an existing pixt or specify
 both %w and %h.  If pixt is defined, the values
 in %w and %h are ignored.
 (3) If pixt is larger than pixs (or if w and/or d is larger
 than the dimension of pixs, replicate the outer row and
 column of pixels in pixs into pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp; colormap ok</param>
	<param name="pixt">; we use only the size</param>
	<param name="w">ignored if pixt is defined</param>
	<param name="h">ignored if pixt is defined</param>
	<returns>pixd resized to match or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMakeFrameMask(System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This makes an arbitrary 1-component mask with a centered fg
 frame, which can have both an inner and an outer boundary.
 All input fractional distances are measured from the image
 border to the frame boundary, in units of the image half-width
 for hf1 and hf2 and the image half-height for vf1 and vf2.
 The distances to the outer frame boundary are given by hf1
 and vf1; to the inner frame boundary, by hf2 and vf2.
 Input fractions are thus in [0.0 ... 1.0], with hf1 LT= hf2
 and vf1 LT= vf2.  Horizontal and vertical frame widths are
 thus independently specified.
 (2) Special cases
 full fg mask hf1 = vf1 = 0.0, hf2 = vf2 = 1.0.
 empty fg (zero width) mask set  hf1 = hf2  and vf1 = vf2.
 fg rectangle with no hole set hf2 = vf2 = 1.0.
 frame touching outer boundary set hf1 = vf1 = 0.0.
 (3) The vertical thickness of the horizontal mask parts
 is 0.5  (vf2 - vf1)  h.  The horizontal thickness of the
 vertical mask parts is 0.5  (hf2 - hf1)  w.
 </summary>
	<remarks>
	</remarks>
	<param name="w">dimensions of output 1 bpp pix</param>
	<param name="h">dimensions of output 1 bpp pix</param>
	<param name="hf1">horizontal fraction of half-width at outer frame bdry</param>
	<param name="hf2">horizontal fraction of half-width at inner frame bdry</param>
	<param name="vf1">vertical fraction of half-width at outer frame bdry</param>
	<param name="vf2">vertical fraction of half-width at inner frame bdry</param>
	<returns>pixd 1 bpp, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMakeCoveringOfRectangles(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This iteratively finds the bounding boxes of the connected
 components and generates a mask from them.  Two iterations
 should suffice for most situations.
 (2) Returns an empty pix if %pixs is empty.
 (3) If there are many small components in proximity, it may
 be useful to merge them with a morphological closing before
 calling this one.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="maxiters">max iterations use 0 to iterate to completion</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFractionFgInMask(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Single[]@)">
	<summary>
 Notes
 (1) This gives the fraction of fg pixels in pix1 that are in
 the intersection (i.e., under the fg) of pix2
 |1  2|/|1|, where |...| means the number of fg pixels.
 Note that this is different from the situation where
 pix1 and pix2 are reversed.
 (2) Both pix1 and pix2 are registered to the UL corners.  A warning
 is issued if pix1 and pix2 have different sizes.
 (3) This can also be used to find the fraction of fg pixels in pix1
 that are NOT under the fg of pix2 1.0 - |1  2|/|1|
 (4) If pix1 or pix2 are empty, this returns %fract = 0.0.
 (5) For example, pix2 could be a frame around the outside of the
 image, made from pixMakeFrameMask().
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">1 bpp</param>
	<param name="pix2">1 bpp</param>
	<param name="pfract">fraction of fg pixels in 1 that are aligned with the fg of 2</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixClipToForeground(LeptonicaSharp.Pix,LeptonicaSharp.Pix@,LeptonicaSharp.Box@)">
	<summary>
 Notes
 (1) At least one of {pixd, box} must be specified.
 (2) If there are no fg pixels, the returned ptrs are null.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="ppixd">clipped pix returned</param>
	<param name="pbox">bounding box</param>
	<returns>0 if OK; 1 on error or if there are no fg pixels</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTestClipToForeground(LeptonicaSharp.Pix,System.Int32@)">
	<summary>
 Notes
 (1) This is a lightweight test to determine if a 1 bpp image
 can be further cropped without loss of fg pixels.
 If it cannot, canclip is set to 0.
 (2) It does not test for the existence of any fg pixels.
 If there are no fg pixels, it will return %canclip = 1.
 Check the output of the subsequent call to pixClipToForeground().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pcanclip">1 if fg does not extend to all four edges</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixClipBoxToForeground(LeptonicaSharp.Pix,LeptonicaSharp.Box,LeptonicaSharp.Pix@,LeptonicaSharp.Box@)">
	<summary>
 Notes
 (1) At least one of {pixd, boxd} must be specified.
 (2) If there are no fg pixels, the returned ptrs are null.
 (3) Do not use pixs for the 3rd arg or boxs for the 4th arg;
 this will leak memory.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="boxs">use full image if null</param>
	<param name="ppixd">clipped pix returned</param>
	<param name="pboxd">bounding box</param>
	<returns>0 if OK; 1 on error or if there are no fg pixels</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScanForForeground(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_scan_direction,System.Int32@,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) If there are no fg pixels, the position is set to 0.
 Caller must check the return value!
 (2) Use %box == NULL to scan from edge of pixs
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="box">within which the search is conducted</param>
	<param name="scanflag">direction of scan; e.g., L_FROM_LEFT</param>
	<param name="ploc">location in scan direction of first black pixel</param>
	<returns>0 if OK; 1 on error or if no fg pixels are found</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixClipBoxToEdges(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Box,LeptonicaSharp.Pix@,LeptonicaSharp.Box@)">
	<summary>
 Notes
 (1) At least one of {pixd, boxd} must be specified.
 (2) If there are no fg pixels, the returned ptrs are null.
 (3) This function attempts to locate rectangular "image" regions
 of high-density fg pixels, that have well-defined edges
 on the four sides.
 (4) Edges are searched for on each side, iterating in order
 from left, right, top and bottom.  As each new edge is
 found, the search box is resized to use that location.
 Once an edge is found, it is held.  If no more edges
 are found in one iteration, the search fails.
 (5) See pixScanForEdge() for usage of the thresholds and %maxwidth.
 (6) The thresholds must be at least 1, and the low threshold
 cannot be larger than the high threshold.
 (7) If the low and high thresholds are both 1, this is equivalent
 to pixClipBoxToForeground().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="boxs">; use full image if null</param>
	<param name="lowthresh">threshold to choose clipping location</param>
	<param name="highthresh">threshold required to find an edge</param>
	<param name="maxwidth">max allowed width between low and high thresh locs</param>
	<param name="factor">sampling factor along pixel counting direction</param>
	<param name="ppixd">clipped pix returned</param>
	<param name="pboxd">bounding box</param>
	<returns>0 if OK; 1 on error or if a fg edge is not found from all four sides.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScanForEdge(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_scan_direction,System.Int32@,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) If there are no fg pixels, the position is set to 0.
 Caller must check the return value!
 (2) Use %box == NULL to scan from edge of pixs
 (3) As the scan progresses, the location where the sum of
 pixels equals or excees %lowthresh is noted (loc).  The
 scan is stopped when the sum of pixels equals or exceeds
 %highthresh.  If the scan distance between loc and that
 point does not exceed %maxwidth, an edge is found and
 its position is taken to be loc.  %maxwidth implicitly
 sets a minimum on the required gradient of the edge.
 (4) The thresholds must be at least 1, and the low threshold
 cannot be larger than the high threshold.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="box">within which the search is conducted</param>
	<param name="lowthresh">threshold to choose clipping location</param>
	<param name="highthresh">threshold required to find an edge</param>
	<param name="maxwidth">max allowed width between low and high thresh locs</param>
	<param name="factor">sampling factor along pixel counting direction</param>
	<param name="scanflag">direction of scan; e.g., L_FROM_LEFT</param>
	<param name="ploc">location in scan direction of first black pixel</param>
	<returns>0 if OK; 1 on error or if the edge is not found</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExtractOnLine(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Input end points are clipped to the pix.
 (2) If the line is either horizontal, or closer to horizontal
 than to vertical, the points will be extracted from left
 to right in the pix.  Likewise, if the line is vertical,
 or closer to vertical than to horizontal, the points will
 be extracted from top to bottom.
 (3) Can be used with numaCountReverals(), for example, to
 characterize the intensity smoothness along a line.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp or 8 bpp; no colormap</param>
	<param name="x1">one end point for line</param>
	<param name="y1">one end point for line</param>
	<param name="x2">another end pt for line</param>
	<param name="y2">another end pt for line</param>
	<param name="factor">sampling; GT= 1</param>
	<returns>na of pixel values along line, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAverageOnLine(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The line must be either horizontal or vertical, so either
 y1 == y2 (horizontal) or x1 == x2 (vertical).
 (2) If horizontal, x1 must be LT= x2.
 If vertical, y1 must be LT= y2.
 characterize the intensity smoothness along a line.
 (3) Input end points are clipped to the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp or 8 bpp; no colormap</param>
	<param name="x1">starting pt for line</param>
	<param name="y1">starting pt for line</param>
	<param name="x2">end pt for line</param>
	<param name="y2">end pt for line</param>
	<param name="factor">sampling; GT= 1</param>
	<returns>average of pixel values along line, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAverageIntensityProfile(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_LINE,System.Int32,System.Int32@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If d != 1 bpp, colormaps are removed and the result
 is converted to 8 bpp.
 (2) If %dir == L_HORIZONTAL_LINE, the intensity is averaged
 along each horizontal raster line (sampled by %factor1),
 and the profile is the array of these averages in the
 vertical direction between %first and %last raster lines,
 and sampled by %factor2.
 (3) If %dir == L_VERTICAL_LINE, the intensity is averaged
 along each vertical line (sampled by %factor1),
 and the profile is the array of these averages in the
 horizontal direction between %first and %last columns,
 and sampled by %factor2.
 (4) The averages are measured over the central %fract of the image.
 Use %fract == 1.0 to average across the entire width or height.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; colormap OK</param>
	<param name="fract">fraction of image width or height to be used</param>
	<param name="dir">averaging direction L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
	<param name="first">last span of rows or columns to measure</param>
	<param name="factor1">sampling along fast scan direction; GT= 1</param>
	<param name="factor2">sampling along slow scan direction; GT= 1</param>
	<returns>na of reversal profile, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReversalProfile(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_LINE,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If d != 1 bpp, colormaps are removed and the result
 is converted to 8 bpp.
 (2) If %dir == L_HORIZONTAL_LINE, the the reversals are counted
 along each horizontal raster line (sampled by %factor1),
 and the profile is the array of these sums in the
 vertical direction between %first and %last raster lines,
 and sampled by %factor2.
 (3) If %dir == L_VERTICAL_LINE, the the reversals are counted
 along each vertical column (sampled by %factor1),
 and the profile is the array of these sums in the
 horizontal direction between %first and %last columns,
 and sampled by %factor2.
 (4) For each row or column, the reversals are summed over the
 central %fract of the image.  Use %fract == 1.0 to sum
 across the entire width (of row) or height (of column).
 (5) %minreversal is the relative change in intensity that is
 required to resolve peaks and valleys.  A typical number for
 locating text in 8 bpp might be 50.  For 1 bpp, minreversal
 must be 1.
 (6) The reversal profile is simply the number of reversals
 in a row or column, vs the row or column index.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; colormap OK</param>
	<param name="fract">fraction of image width or height to be used</param>
	<param name="dir">profile direction L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
	<param name="first">span of rows or columns to measure</param>
	<param name="last">span of rows or columns to measure</param>
	<param name="minreversal">minimum change in intensity to trigger a reversal</param>
	<param name="factor1">sampling along raster line (fast scan); GT= 1</param>
	<param name="factor2">sampling of raster lines (slow scan); GT= 1</param>
	<returns>na of reversal profile, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWindowedVarianceOnLine(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_LINE,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The returned variance array traverses the line starting
 from the smallest coordinate, min(c1,c2).
 (2) Line end points are clipped to pixs.
 (3) The reference point for the variance calculation is the center of
 the window.  Therefore, the numa start parameter from
 pixExtractOnLine() is incremented by %size/2,
 to align the variance values with the pixel coordinate.
 (4) The square root of the variance is the RMS deviation from the mean.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="dir">L_HORIZONTAL_LINE or L_VERTICAL_LINE</param>
	<param name="loc">location of the constant coordinate for the line</param>
	<param name="c1">end point coordinates for the line</param>
	<param name="c2">end point coordinates for the line</param>
	<param name="size">window size; must be GT 1</param>
	<param name="pnad">windowed square root of variance</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMinMaxNearLine(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_scan_direction,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) If the line is more horizontal than vertical, the values
 are computed for [x1, x2], and the pixels are taken
 below and/or above the local y-value.  Otherwise, the
 values are computed for [y1, y2] and the pixels are taken
 to the left and/or right of the local x value.
 (2) %direction specifies which side (or both sides) of the
 line are scanned for min and max values.
 (3) There are two ways to tell if the returned values of min
 and max averages are valid the returned values cannot be
 negative and the function must return 0.
 (4) All accessed pixels are clipped to the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="x1">starting pt for line</param>
	<param name="y1">starting pt for line</param>
	<param name="x2">end pt for line</param>
	<param name="y2">end pt for line</param>
	<param name="dist">distance to search from line in each direction</param>
	<param name="direction">L_SCAN_NEGATIVE, L_SCAN_POSITIVE, L_SCAN_BOTH</param>
	<param name="pnamin">minimum values</param>
	<param name="pnamax">maximum values</param>
	<param name="pminave">average of minimum values</param>
	<param name="pmaxave">average of maximum values</param>
	<returns>0 if OK; 1 on error or if there are no sampled points within the image.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRankRowTransform(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The time is O(n) in the number of pixels and runs about
 100 Mpixels/sec on a 3 GHz machine.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<returns>pixd with pixels sorted in each row, from min to max value</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRankColumnTransform(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The time is O(n) in the number of pixels and runs about
 50 Mpixels/sec on a 3 GHz machine.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<returns>pixd with pixels sorted in each column, from min to max value</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaCreate(System.Int32)">
	<summary>
 Notes
 (1) This creates an empty boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="n">initial number of ptrs</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaCreateFromPix(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For bpp = 1, we truncate each retrieved pix to the ON
 pixels, which we assume for now start at (0,0)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">with individual components on a lattice</param>
	<param name="n">number of components</param>
	<param name="cellw">width of each cell</param>
	<param name="cellh">height of each cell</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaCreateFromBoxa(LeptonicaSharp.Pix,LeptonicaSharp.Boxa,System.Int32@)">
	<summary>
 Notes
 (1) This simply extracts from pixs the region corresponding to each
 box in the boxa.
 (2) The 3rd arg is optional.  If the extent of the boxa exceeds the
 size of the pixa, so that some boxes are either clipped
 or entirely outside the pix, a warning is returned as TRUE.
 (3) pixad will have only the properly clipped elements, and
 the internal boxa will be correct.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="boxa"></param>
	<param name="pcropwarn">TRUE if the boxa extent is larger than pixs.</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSplitPix(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) This is a variant on pixaCreateFromPix(), where we
 simply divide the image up into (approximately) equal
 subunits.  If you want the subimages to have essentially
 the same aspect ratio as the input pix, use nx = ny.
 (2) If borderwidth is 0, we ignore the input bordercolor and
 redefine it to white.
 (3) The bordercolor is always used to initialize each tiled pix,
 so that if the src is clipped, the unblitted part will
 be this color.  This avoids 1 pixel wide black stripes at the
 left and lower edges.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">with individual components on a lattice</param>
	<param name="nx">number of mosaic cells horizontally</param>
	<param name="ny">number of mosaic cells vertically</param>
	<param name="borderwidth">of added border on all sides</param>
	<param name="bordercolor">in our RGBA format 0xrrggbbaa</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDestroy(LeptonicaSharp.Pixa@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the pixa.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppixa">ed</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaCopy(LeptonicaSharp.Pixa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="copyflag">see pix.h for details L_COPY makes a new pixa and copies each pix and each box; L_CLONE gives a new ref-counted handle to the input pixa; L_COPY_CLONE makes a new pixa and inserts clones of all pix and boxes</param>
	<returns>new pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaAddPix(LeptonicaSharp.Pixa,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pix">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaAddBox(LeptonicaSharp.Pixa,LeptonicaSharp.Box,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="box"></param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaExtendArrayToSize(LeptonicaSharp.Pixa,System.Int32)">
	<summary>
 Notes
 (1) If necessary, reallocs new pixa and boxa ptrs arrays to %size.
 The pixa and boxa ptr arrays must always be equal in size.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="size"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaGetCount(LeptonicaSharp.Pixa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<returns>count, or 0 if no pixa</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaChangeRefcount(LeptonicaSharp.Pixa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="delta"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaGetPix(LeptonicaSharp.Pixa,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">to the index-th pix</param>
	<param name="accesstype">L_COPY or L_CLONE</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaGetPixDimensions(LeptonicaSharp.Pixa,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">to the index-th box</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<param name="pd">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaGetBoxa(LeptonicaSharp.Pixa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="accesstype">L_COPY, L_CLONE, L_COPY_CLONE</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaGetBoxaCount(LeptonicaSharp.Pixa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaGetBox(LeptonicaSharp.Pixa,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) There is always a boxa with a pixa, and it is initialized so
 that each box ptr is NULL.
 (2) In general, we expect that there is either a box associated
 with each pix, or no boxes at all in the boxa.
 (3) Having no boxes is thus not an automatic error.  Whether it
 is an actual error is determined by the calling program.
 If the caller expects to get a box, it is an error; see, e.g.,
 pixaGetBoxGeometry().
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">to the index-th pix</param>
	<param name="accesstype">L_COPY or L_CLONE</param>
	<returns>box if null, not automatically an error, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaGetBoxGeometry(LeptonicaSharp.Pixa,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">to the index-th box</param>
	<param name="px">each can be null</param>
	<param name="py">each can be null</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSetBoxa(LeptonicaSharp.Pixa,LeptonicaSharp.Boxa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) This destroys the existing boxa in the pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="boxa"></param>
	<param name="accesstype">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaGetPixArray(LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) This returns a ptr to the actual array.  The array is
 owned by the pixa, so it must not be destroyed.
 (2) The caller should always check if the return value is NULL
 before accessing any of the pix ptrs in this array!
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<returns>pix array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaVerifyDepth(LeptonicaSharp.Pixa,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) It is considered to be an error if there are no pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="psame">1 if depth is the same for all pix; 0 otherwise</param>
	<param name="pmaxd">max depth of all pix</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaVerifyDimensions(LeptonicaSharp.Pixa,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) It is considered to be an error if there are no pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="psame">1 if dimensions are the same for all pix; 0 otherwise</param>
	<param name="pmaxw">max width of all pix</param>
	<param name="pmaxh">max height of all pix</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaIsFull(LeptonicaSharp.Pixa,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) A pixa is "full" if the array of pix is fully
 occupied from index 0 to index (pixa-GTn - 1).
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pfullpa">1 if pixa is full</param>
	<param name="pfullba">1 if boxa is full</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaCountText(LeptonicaSharp.Pixa,System.Int32@)">
	<summary>
 Notes
 (1) All pix have non-empty text strings if the returned value %ntext
 equals the pixa count.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pntext">number of pix with non-empty text strings</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSetText(LeptonicaSharp.Pixa,LeptonicaSharp.Sarray)">
	<summary>
 Notes
 (1) To clear all the text fields, use sa == NULL;
 (2) If sa is defined, it must be the same size as %pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="sa">array of text strings, to insert in each pix</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaGetLinePtrs(LeptonicaSharp.Pixa,System.Int32@)">
	<summary>
 Notes
 (1) See pixGetLinePtrs() for details.
 (2) It is best if all pix in the pixa are the same size.
 The size of each line ptr array is equal to the height
 of the pix that it refers to.
 (3) This is an array of arrays.  To destroy it
 for (i = 0; i LT size; i++)
 LEPT_FREE(lineset[i]);
 LEPT_FREE(lineset);
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of pix that all have the same depth</param>
	<param name="psize">number of pix in the pixa</param>
	<returns>array of array of line ptrs, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaWriteStreamInfo(LeptonicaSharp.FILE,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) For each pix in the pixa, write out the pix dimensions, spp,
 text string (if it exists), and cmap info.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pixa"></param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaReplacePix(LeptonicaSharp.Pixa,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) In-place replacement of one pix.
 (2) The previous pix at that location is destroyed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">to the index-th pix</param>
	<param name="pix">insert to replace existing one</param>
	<param name="box">insert to replace existing</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaInsertPix(LeptonicaSharp.Pixa,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This shifts pixa[i] --GT pixa[i + 1] for all i GT= index,
 and then inserts at pixa[index].
 (2) To insert at the beginning of the array, set index = 0.
 (3) It should not be used repeatedly on large arrays,
 because the function is O(n).
 (4) To append a pix to a pixa, it's easier to use pixaAddPix().
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">at which pix is to be inserted</param>
	<param name="pixs">new pix to be inserted</param>
	<param name="box">new box to be inserted</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaRemovePix(LeptonicaSharp.Pixa,System.Int32)">
	<summary>
 Notes
 (1) This shifts pixa[i] --GT pixa[i - 1] for all i GT index.
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 (3) The corresponding box is removed as well, if it exists.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">of pix to be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaRemovePixAndSave(LeptonicaSharp.Pixa,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Box@)">
	<summary>
 Notes
 (1) This shifts pixa[i] --GT pixa[i - 1] for all i GT index.
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 (3) The corresponding box is removed as well, if it exists.
 (4) The removed pix and box can either be retained or destroyed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="index">of pix to be removed</param>
	<param name="ppix">removed pix</param>
	<param name="pbox">removed box</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaInitFull(LeptonicaSharp.Pixa,LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This initializes a pixa by filling up the entire pix ptr array
 with copies of %pix.  If %pix == NULL, we use a tiny placeholder
 pix (w = h = d = 1).  Any existing pix are destroyed.
 It also optionally fills the boxa with copies of %box.
 After this operation, the numbers of pix and (optionally)
 boxes are equal to the number of allocated ptrs.
 (2) Note that we use pixaReplacePix() instead of pixaInsertPix().
 They both have the same effect when inserting into a NULL ptr
 in the pixa ptr array
 (3) If the boxa is not initialized (i.e., filled with boxes),
 later insertion of boxes will cause an error, because the
 'n' field is 0.
 (4) Example usage.  This function is useful to prepare for a
 random insertion (or replacement) of pix into a pixa.
 To randomly insert pix into a pixa, without boxes, up to
 some index "max"
 Pixa pixa = pixaCreate(max);
 pixaInitFull(pixa, NULL, NULL);
 An existing pixa with a smaller ptr array can also be reused
 pixaExtendArrayToSize(pixa, max);
 pixaInitFull(pixa, NULL, NULL);
 The initialization allows the pixa to always be properly
 filled, even if all pix (and boxes) are not later replaced.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">typically empty</param>
	<param name="pix">to be replicated into the entire pixa ptr array</param>
	<param name="box">to be replicated into the entire boxa ptr array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaClear(LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) This destroys all pix in the pixa, as well as
 all boxes in the boxa.  The ptrs in the pix ptr array
 are all null'd.  The number of allocated pix, n, is set to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaJoin(LeptonicaSharp.Pixa,System.Int32,System.Int32,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) This appends a clone of each indicated pix in pixas to pixad
 (2) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (3) iend LT 0 means 'read to the end'
 (4) If pixas is NULL or contains no pix, this is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="pixad">dest pixa; add to this one</param>
	<param name="pixas">source pixa; add from this one</param>
	<param name="istart">starting index in pixas</param>
	<param name="iend">ending index in pixas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaInterleave(LeptonicaSharp.Pixa,LeptonicaSharp.Pixa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) %copyflag determines if the pix are copied or cloned.
 The boxes, if they exist, are copied.
 (2) If the two pixa have different sizes, a warning is issued,
 and the number of pairs returned is the minimum size.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa1">first src pixa</param>
	<param name="pixa2">second src pixa</param>
	<param name="copyflag">L_CLONE, L_COPY</param>
	<returns>pixa  interleaved from sources, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaJoin(LeptonicaSharp.Pixaa,System.Int32,System.Int32,LeptonicaSharp.Pixaa)">
	<summary>
 Notes
 (1) This appends a clone of each indicated pixa in paas to pixaad
 (2) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (3) iend LT 0 means 'read to the end'
 </summary>
	<remarks>
	</remarks>
	<param name="paad">dest pixaa; add to this one</param>
	<param name="paas">source pixaa; add from this one</param>
	<param name="istart">starting index in pixaas</param>
	<param name="iend">ending index in pixaas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaCreate(System.Int32)">
	<summary>
 Notes
 (1) A pixaa provides a 2-level hierarchy of images.
 A common use is for segmentation masks, which are
 inexpensive to store in png format.
 (2) For example, suppose you want a mask for each textline
 in a two-column page.  The textline masks for each column
 can be represented by a pixa, of which there are 2 in the pixaa.
 The boxes for the textline mask components within a column
 can have their origin referred to the column rather than the page.
 Then the boxa field can be used to represent the two box (regions)
 for the columns, and the (x,y) components of each box can
 be used to get the absolute position of the textlines on
 the page.
 </summary>
	<remarks>
	</remarks>
	<param name="n">initial number of pixa ptrs</param>
	<returns>paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaCreateFromPixa(LeptonicaSharp.Pixa,System.Int32,LeptonicaSharp.Enumerations.L_CHOOSE,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) This subdivides a pixa into a set of smaller pixa that
 are accumulated into a pixaa.
 (2) If type == L_CHOOSE_CONSECUTIVE, the first 'n' pix are
 put in a pixa and added to pixaa, then the next 'n', etc.
 If type == L_CHOOSE_SKIP_BY, the first pixa is made by
 aggregating pix[0], pix[n], pix[2n], etc.
 (3) The copyflag specifies if each new pix is a copy or a clone.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="n">number specifying subdivision of pixa</param>
	<param name="type">L_CHOOSE_CONSECUTIVE, L_CHOOSE_SKIP_BY</param>
	<param name="copyflag">L_CLONE, L_COPY</param>
	<returns>paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaDestroy(LeptonicaSharp.Pixaa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ppaa">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaAddPixa(LeptonicaSharp.Pixaa,LeptonicaSharp.Pixa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="pixa">to be added</param>
	<param name="copyflag">L_INSERT inserts the pixa directly; L_COPY makes a new pixa and copies each pix and each box; L_CLONE gives a new handle to the input pixa; L_COPY_CLONE makes a new pixa and inserts clones of all pix and boxes</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaExtendArray(LeptonicaSharp.Pixaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaAddPix(LeptonicaSharp.Pixaa,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_access_storage,LeptonicaSharp.Box)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="paa">input paa</param>
	<param name="index">index of pixa in paa</param>
	<param name="pix">to be added</param>
	<param name="box">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaAddBox(LeptonicaSharp.Pixaa,LeptonicaSharp.Box,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) The box can be used, for example, to hold the support region
 of a pixa that is being added to the pixaa.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="box"></param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaGetCount(LeptonicaSharp.Pixaa,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) If paa is empty, a returned na will also be empty.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="pna">number of pix in each pixa</param>
	<returns>count, or 0 if no pixaa</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaGetPixa(LeptonicaSharp.Pixaa,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) L_COPY makes a new pixa with a copy of every pix
 (2) L_CLONE just makes a new reference to the pixa,
 and bumps the counter.  You would use this, for example,
 when you need to extract some data from a pix within a
 pixa within a pixaa.
 (3) L_COPY_CLONE makes a new pixa with a clone of every pix
 and box
 (4) In all cases, you must invoke pixaDestroy() on the returned pixa
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="index">to the index-th pixa</param>
	<param name="accesstype">L_COPY, L_CLONE, L_COPY_CLONE</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaGetBoxa(LeptonicaSharp.Pixaa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) L_COPY returns a copy; L_CLONE returns a new reference to the boxa.
 (2) In both cases, invoke boxaDestroy() on the returned boxa.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="accesstype">L_COPY, L_CLONE</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaGetPix(LeptonicaSharp.Pixaa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="index">index into the pixa array in the pixaa</param>
	<param name="ipix">index into the pix array in the pixa</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaVerifyDepth(LeptonicaSharp.Pixaa,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) It is considered to be an error if any pixa have no pix.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="psame">1 if all pix have the same depth; 0 otherwise</param>
	<param name="pmaxd">max depth of all pix in pixaa</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaVerifyDimensions(LeptonicaSharp.Pixaa,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) It is considered to be an error if any pixa have no pix.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="psame">1 if all pix have the same depth; 0 otherwise</param>
	<param name="pmaxw">max width of all pix in pixaa</param>
	<param name="pmaxh">max height of all pix in pixaa</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaIsFull(LeptonicaSharp.Pixaa,System.Int32@)">
	<summary>
 Notes
 (1) Does not require boxa associated with each pixa to be full.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="pfull">1 if all pixa in the paa have full pix arrays</param>
	<returns>return 0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaInitFull(LeptonicaSharp.Pixaa,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) This initializes a pixaa by filling up the entire pixa ptr array
 with copies of %pixa.  Any existing pixa are destroyed.
 (2) Example usage.  This function is useful to prepare for a
 random insertion (or replacement) of pixa into a pixaa.
 To randomly insert pixa into a pixaa, up to some index "max"
 Pixaa paa = pixaaCreate(max);
 Pixa pixa = pixaCreate(1);  // if you want little memory
 pixaaInitFull(paa, pixa);  // copy it to entire array
 pixaDestroy(pixa);  // no longer needed
 The initialization allows the pixaa to always be properly filled.
 </summary>
	<remarks>
	</remarks>
	<param name="paa">typically empty</param>
	<param name="pixa">to be replicated into the entire pixa ptr array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaReplacePixa(LeptonicaSharp.Pixaa,System.Int32,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) This allows random insertion of a pixa into a pixaa, with
 destruction of any existing pixa at that location.
 The input pixa is now owned by the pixaa.
 (2) No other pixa in the array are affected.
 (3) The index must be within the allowed set.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="index">to the index-th pixa</param>
	<param name="pixa">insert to replace existing one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaClear(LeptonicaSharp.Pixaa)">
	<summary>
 Notes
 (1) This destroys all pixa in the pixaa, and nulls the ptrs
 in the pixa ptr array.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaTruncate(LeptonicaSharp.Pixaa)">
	<summary>
 Notes
 (1) This identifies the largest index containing a pixa that
 has any pix within it, destroys all pixa above that index,
 and resets the count.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaRead(System.String)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaReadStream(LeptonicaSharp.FILE)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">of serialized pixa</param>
	<param name="size">of data in bytes</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaWriteDebug(System.String,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) Debug version, intended for use in the library when writing
 to files in a temp directory with names that are compiled in.
 This is used instead of pixaWrite() for all such library calls.
 (2) The global variable LeptDebugOK defaults to 0, and can be set
 or cleared by the function setLeptDebugOK().
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="pixa"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaWrite(System.String,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pixa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="pixa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) Serializes a pixa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized pixa</param>
	<param name="psize">size of returned data</param>
	<param name="pixa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaReadBoth(System.String)">
	<summary>
 Notes
 (1) This reads serialized files of either a pixa or a pixacomp,
 and returns a pixa in memory.  It requires png and jpeg libraries.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaReadFromFiles(System.String,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) The files must be serialized pixa files (e.g., .pa)
 If some files cannot be read, warnings are issued.
 (2) Use %substr to filter filenames in the directory.  If
 %substr == NULL, this takes all files.
 (3) After filtering, use %first and %nfiles to select
 a contiguous set of files, that have been lexically
 sorted in increasing order.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="first">0-based</param>
	<param name="nfiles">use 0 for everything from %first to the end</param>
	<returns>paa, or NULL on error or if no pixa files are found.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaRead(System.String)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaReadStream(LeptonicaSharp.FILE)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">of serialized pixaa</param>
	<param name="size">of data in bytes</param>
	<returns>paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaWrite(System.String,LeptonicaSharp.Pixaa)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="paa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.Pixaa)">
	<summary>
 Notes
 (1) The pix are stored in the file as png.
 If the png library is not linked, this will fail.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="paa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pixaa)">
	<summary>
 Notes
 (1) Serializes a pixaa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized pixaa</param>
	<param name="psize">size of returned data</param>
	<param name="paa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaccCreate(System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Use %negflag = 1 for safety if any negative numbers are going
 to be used in the chain of operations.  Negative numbers
 arise, e.g., by subtracting a pix, or by adding a pix
 that has been pre-multiplied by a negative number.
 (2) Initializes the internal 32 bpp pix, similarly to the
 initialization in pixInitAccumulate().
 </summary>
	<remarks>
	</remarks>
	<param name="w">of 32 bpp internal Pix</param>
	<param name="h">of 32 bpp internal Pix</param>
	<param name="negflag">0 if only positive numbers are involved; 1 if there will be negative numbers</param>
	<returns>pixacc, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaccCreateFromPix(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) See pixaccCreate()
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="negflag">0 if only positive numbers are involved; 1 if there will be negative numbers</param>
	<returns>pixacc, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaccDestroy(LeptonicaSharp.Pixacc@)">
	<summary>
 Notes
 (1) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppixacc">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaccFinal(LeptonicaSharp.Pixacc,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<param name="outdepth">8, 16 or 32 bpp</param>
	<returns>pixd 8 , 16 or 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaccGetPix(LeptonicaSharp.Pixacc)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaccGetOffset(LeptonicaSharp.Pixacc)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<returns>offset, or -1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaccAdd(LeptonicaSharp.Pixacc,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<param name="pix">to be added</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaccSubtract(LeptonicaSharp.Pixacc,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<param name="pix">to be subtracted</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaccMultConst(LeptonicaSharp.Pixacc,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<param name="factor"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaccMultConstAccumulate(LeptonicaSharp.Pixacc,LeptonicaSharp.Pix,System.Single)">
	<summary>
 Notes
 (1) This creates a temp pix that is %pix multiplied by the
 constant %factor.  It then adds that into %pixacc.
 </summary>
	<remarks>
	</remarks>
	<param name="pixacc"></param>
	<param name="pix"></param>
	<param name="factor"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSelectBySize(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_SELECT,LeptonicaSharp.Enumerations.L_SELECT_IF,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) If unchanged, returns a copy of pixs.  Otherwise,
 returns a new pix with the filtered components.
 (3) If the selection type is L_SELECT_WIDTH, the input
 height is ignored, and v.v.
 (4) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="width">threshold dimensions</param>
	<param name="height">threshold dimensions</param>
	<param name="connectivity">4 or 8</param>
	<param name="type">L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 otherwise</param>
	<returns>filtered pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSelectBySize(LeptonicaSharp.Pixa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_SELECT,LeptonicaSharp.Enumerations.L_SELECT_IF,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) Uses pix and box clones in the new pixa.
 (3) If the selection type is L_SELECT_WIDTH, the input
 height is ignored, and v.v.
 (4) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="width">threshold dimensions</param>
	<param name="height">threshold dimensions</param>
	<param name="type">L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 otherwise</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaMakeSizeIndicator(LeptonicaSharp.Pixa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_SELECT,LeptonicaSharp.Enumerations.L_SELECT_IF)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) If the selection type is L_SELECT_WIDTH, the input
 height is ignored, and v.v.
 (3) To keep small components, use relation = L_SELECT_IF_LT or
 L_SELECT_IF_LTE.
 To keep large components, use relation = L_SELECT_IF_GT or
 L_SELECT_IF_GTE.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="width">threshold dimensions</param>
	<param name="height">threshold dimensions</param>
	<param name="type">L_SELECT_WIDTH, L_SELECT_HEIGHT, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns>na indicator array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSelectByPerimToAreaRatio(LeptonicaSharp.Pix,System.Single,System.Int32,LeptonicaSharp.Enumerations.L_SELECT_IF,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) If unchanged, returns a copy of pixs.  Otherwise,
 returns a new pix with the filtered components.
 (3) This filters "thick" components, where a thick component
 is defined to have a ratio of boundary to interior pixels
 that is smaller than a given threshold value.
 (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the thicker
 components, and L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="thresh">threshold ratio of fg boundary to fg pixels</param>
	<param name="connectivity">4 or 8</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSelectByPerimToAreaRatio(LeptonicaSharp.Pixa,System.Single,LeptonicaSharp.Enumerations.L_SELECT_IF,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa clone if no components are removed.
 (2) Uses pix and box clones in the new pixa.
 (3) See pixSelectByPerimToAreaRatio().
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="thresh">threshold ratio of fg boundary to fg pixels</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSelectByPerimSizeRatio(LeptonicaSharp.Pix,System.Single,System.Int32,LeptonicaSharp.Enumerations.L_SELECT_IF,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the size of the
 components that are kept.
 (2) If unchanged, returns a copy of pixs.  Otherwise,
 returns a new pix with the filtered components.
 (3) This filters components with smooth vs. dendritic shape, using
 the ratio of the fg boundary pixels to the circumference of
 the bounding box, and comparing it to a threshold value.
 (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the smooth
 boundary components, and L_SELECT_IF_GT or L_SELECT_IF_GTE
 to remove them.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="thresh">threshold ratio of fg boundary to fg pixels</param>
	<param name="connectivity">4 or 8</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSelectByPerimSizeRatio(LeptonicaSharp.Pixa,System.Single,LeptonicaSharp.Enumerations.L_SELECT_IF,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa clone if no components are removed.
 (2) Uses pix and box clones in the new pixa.
 (3) See pixSelectByPerimSizeRatio().
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="thresh">threshold ratio of fg boundary to b.b. circumference</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSelectByAreaFraction(LeptonicaSharp.Pix,System.Single,System.Int32,LeptonicaSharp.Enumerations.L_SELECT_IF,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the amount of foreground
 coverage of the components that are kept.
 (2) If unchanged, returns a copy of pixs.  Otherwise,
 returns a new pix with the filtered components.
 (3) This filters components based on the fraction of fg pixels
 of the component in its bounding box.
 (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
 with less than the threshold fraction of foreground, and
 L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="thresh">threshold ratio of fg pixels to (w  h)</param>
	<param name="connectivity">4 or 8</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSelectByAreaFraction(LeptonicaSharp.Pixa,System.Single,LeptonicaSharp.Enumerations.L_SELECT_IF,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa clone if no components are removed.
 (2) Uses pix and box clones in the new pixa.
 (3) This filters components based on the fraction of fg pixels
 of the component in its bounding box.
 (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
 with less than the threshold fraction of foreground, and
 L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="thresh">threshold ratio of fg pixels to (w  h)</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSelectByWidthHeightRatio(LeptonicaSharp.Pix,System.Single,System.Int32,LeptonicaSharp.Enumerations.L_SELECT_IF,System.Int32@)">
	<summary>
 Notes
 (1) The args specify constraints on the width-to-height ratio
 for components that are kept.
 (2) If unchanged, returns a copy of pixs.  Otherwise,
 returns a new pix with the filtered components.
 (3) This filters components based on the width-to-height ratios.
 (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
 with less than the threshold ratio, and
 L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="thresh">threshold ratio of width/height</param>
	<param name="connectivity">4 or 8</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSelectByWidthHeightRatio(LeptonicaSharp.Pixa,System.Single,LeptonicaSharp.Enumerations.L_SELECT_IF,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa clone if no components are removed.
 (2) Uses pix and box clones in the new pixa.
 (3) This filters components based on the width-to-height ratio
 of each pix.
 (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
 with less than the threshold ratio, and
 L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="thresh">threshold ratio of width/height</param>
	<param name="type">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSelectByNumConnComp(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa clone if no components are removed.
 (2) Uses pix and box clones in the new pixa.
 (3) This filters by the number of connected components in
 a given range.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="nmin">minimum number of components</param>
	<param name="nmax">maximum number of components</param>
	<param name="connectivity">4 or 8</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSelectWithIndicator(LeptonicaSharp.Pixa,LeptonicaSharp.Numa,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa clone if no components are removed.
 (2) Uses pix and box clones in the new pixa.
 (3) The indicator numa has values 0 (ignore) and 1 (accept).
 (4) If the source boxa is not fully populated, it is left
 empty in the dest pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="na">indicator numa</param>
	<param name="pchanged">1 if changed; 0 if clone returned</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRemoveWithIndicator(LeptonicaSharp.Pix,LeptonicaSharp.Pixa,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) This complements pixAddWithIndicator().   Here, the selected
 components are set subtracted from pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp pix from which components are removed; in-place</param>
	<param name="pixa">of connected components in pixs</param>
	<param name="na">numa indicator remove components corresponding to 1s</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddWithIndicator(LeptonicaSharp.Pix,LeptonicaSharp.Pixa,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) This complements pixRemoveWithIndicator().   Here, the selected
 components are added to pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp pix from which components are added; in-place</param>
	<param name="pixa">of connected components, some of which will be put into pixs</param>
	<param name="na">numa indicator add components corresponding to 1s</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSelectWithString(LeptonicaSharp.Pixa,System.String,System.Int32@)">
	<summary>
 Notes
 (1) Returns a pixa with copies of selected pix.
 (2) Associated boxes are also copied, if fully populated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="str">string of indices into pixa, giving the pix to be selected</param>
	<param name="perror">1 if any indices are invalid; 0 if all indices are valid</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaRenderComponent(LeptonicaSharp.Pixa,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If pixs is null, this generates an empty pix of a size determined
 by union of the component bounding boxes, and including the origin.
 (2) The selected component is blitted into pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp pix</param>
	<param name="pixa">of 1 bpp connected components, one of which will be rendered in pixs, with its origin determined by the associated box.</param>
	<param name="index">of component to be rendered</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSort(LeptonicaSharp.Pixa,LeptonicaSharp.Enumerations.L_SORT_BY,LeptonicaSharp.Enumerations.L_SORT_CREASING,LeptonicaSharp.Enumerations.L_access_storage,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This sorts based on the data in the boxa.  If the boxa
 count is not the same as the pixa count, this returns an error.
 (2) If the boxa is empty, it makes one corresponding to the
 dimensions of each pix, which allows meaningful sorting on
 all types except x and y.
 (3) The copyflag refers to the pix and box copies that are
 inserted into the sorted pixa.  These are either L_COPY
 or L_CLONE.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER, L_SORT_BY_AREA, L_SORT_BY_ASPECT_RATIO</param>
	<param name="sortorder">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<param name="pnaindex">index of sorted order into original array</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>pixad sorted version of pixas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaBinSort(LeptonicaSharp.Pixa,LeptonicaSharp.Enumerations.L_SORT_BY,LeptonicaSharp.Enumerations.L_SORT_CREASING,LeptonicaSharp.Enumerations.L_access_storage,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This sorts based on the data in the boxa.  If the boxa
 count is not the same as the pixa count, this returns an error.
 (2) The copyflag refers to the pix and box copies that are
 inserted into the sorted pixa.  These are either L_COPY
 or L_CLONE.
 (3) For a large number of boxes (say, greater than 1000), this
 O(n) binsort is much faster than the O(nlogn) shellsort.
 For 5000 components, this is over 20x faster than boxaSort().
 (4) Consequently, pixaSort() calls this function if it will
 likely go much faster.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT, L_SORT_BY_PERIMETER</param>
	<param name="sortorder">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<param name="pnaindex">index of sorted order into original array</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>pixad sorted version of pixas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSortByIndex(LeptonicaSharp.Pixa,LeptonicaSharp.Numa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="naindex">na that maps from the new pixa to the input pixa</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>pixad sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSort2dByIndex(LeptonicaSharp.Pixa,LeptonicaSharp.Numaa,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="naa">numaa that maps from the new pixaa to the input pixas</param>
	<param name="copyflag">L_CLONE or L_COPY</param>
	<returns>paa sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSelectRange(LeptonicaSharp.Pixa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) The copyflag specifies what we do with each pix from pixas.
 Specifically, L_CLONE inserts a clone into pixad of each
 selected pix from pixas.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="first">use 0 to select from the beginning</param>
	<param name="last">use 0 to select to the end</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaSelectRange(LeptonicaSharp.Pixaa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) The copyflag specifies what we do with each pixa from paas.
 Specifically, L_CLONE inserts a clone into paad of each
 selected pixa from paas.
 </summary>
	<remarks>
	</remarks>
	<param name="paas"></param>
	<param name="first">use 0 to select from the beginning</param>
	<param name="last">use 0 to select to the end</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>paad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaScaleToSize(LeptonicaSharp.Pixaa,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This guarantees that each output scaled image has the
 dimension(s) you specify.
 ~ To specify the width with isotropic scaling, set %hd = 0.
 ~ To specify the height with isotropic scaling, set %wd = 0.
 ~ If both %wd and %hd are specified, the image is scaled
 (in general, anisotropically) to that size.
 ~ It is an error to set both %wd and %hd to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="paas"></param>
	<param name="wd">target width; use 0 if using height as target</param>
	<param name="hd">target height; use 0 if using width as target</param>
	<returns>paad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaScaleToSizeVar(LeptonicaSharp.Pixaa,LeptonicaSharp.Numa,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) This guarantees that the scaled images in each pixa have the
 dimension(s) you specify in the numas.
 ~ To specify the width with isotropic scaling, set %nahd = NULL.
 ~ To specify the height with isotropic scaling, set %nawd = NULL.
 ~ If both %nawd and %nahd are specified, the image is scaled
 (in general, anisotropically) to that size.
 ~ It is an error to set both %nawd and %nahd to NULL.
 (2) If either nawd and/or nahd is defined, it must have the same
 count as the number of pixa in paas.
 </summary>
	<remarks>
	</remarks>
	<param name="paas"></param>
	<param name="nawd">target widths; use NULL if using height</param>
	<param name="nahd">target height; use NULL if using width</param>
	<returns>paad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaScaleToSize(LeptonicaSharp.Pixa,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See pixaaScaleToSize()
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="wd">target width; use 0 if using height as target</param>
	<param name="hd">target height; use 0 if using width as target</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaScaleToSizeRel(LeptonicaSharp.Pixa,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If a requested change in a pix is not possible because
 either the requested width or height is LT= 0, issue a
 warning and return a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="delw">change in width, in pixels; 0 means no change</param>
	<param name="delh">change in height, in pixels; 0 means no change return  pixad, or NULL on error</param>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaScale(LeptonicaSharp.Pixa,System.Single,System.Single)">
	<summary>
 Notes
 (1) If pixas has a full boxes, it is scaled as well.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaScaleBySampling(LeptonicaSharp.Pixa,System.Single,System.Single)">
	<summary>
 Notes
 (1) If pixas has a full boxes, it is scaled as well.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaRotate(LeptonicaSharp.Pixa,System.Single,LeptonicaSharp.Enumerations.L_ROTATE,LeptonicaSharp.Enumerations.L_BRING_IN,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Each pix is rotated about its center.  See pixRotate() for details.
 (2) The boxa array is copied.  Why is it not rotated?
 If a boxa exists, the array of boxes is in 1-to-1
 correspondence with the array of pix, and each box typically
 represents the location of the pix relative to an image from
 which it has been extracted.  Like the pix, we could rotate
 each box around its center, and then generate a box that
 contains all four corners, as is done in boxaRotate(), but
 this seems unnecessary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">1, 2, 4, 8, 32 bpp rgb</param>
	<param name="angle">rotation angle in radians; clockwise is positive</param>
	<param name="type">L_ROTATE_AREA_MAP, L_ROTATE_SHEAR, L_ROTATE_SAMPLING</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<param name="width">original width; use 0 to avoid embedding</param>
	<param name="height">original height; use 0 to avoid embedding</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaRotateOrth(LeptonicaSharp.Pixa,System.Int32)">
	<summary>
 Notes
 (1) Rotates each pix in the pixa.  Rotates and saves the boxes in
 the boxa if the boxa is full.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="rotation">0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg; all rotations are clockwise</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaTranslate(LeptonicaSharp.Pixa,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="hshift">horizontal shift; hshift GT 0 is to right</param>
	<param name="vshift">vertical shift; vshift GT 0 is down</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixad, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaAddBorderGeneral(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) For binary images
 white  val = 0
 black  val = 1
 For grayscale images
 white  val = 2  d - 1
 black  val = 0
 For rgb color images
 white  val = 0xffffff00
 black  val = 0
 For colormapped images, use 'index' found this way
 white pixcmapGetRankIntensity(cmap, 1.0, index);
 black pixcmapGetRankIntensity(cmap, 0.0, index);
 (2) For in-place replacement of each pix with a bordered version,
 use %pixad = %pixas.  To make a new pixa, use %pixad = NULL.
 (3) In both cases, the boxa has sides adjusted as if it were
 expanded by the border.
 </summary>
	<remarks>
	</remarks>
	<param name="pixad">or equal to pixas</param>
	<param name="pixas">containing pix of all depths; colormap ok</param>
	<param name="left">number of pixels added</param>
	<param name="right">number of pixels added</param>
	<param name="top">number of pixels added</param>
	<param name="bot">number of pixels added</param>
	<param name="val">value of added border pixels</param>
	<returns>pixad with border added to each pix, including on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaFlattenToPixa(LeptonicaSharp.Pixaa,LeptonicaSharp.Enumerations.L_access_storage,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This 'flattens' the pixaa to a pixa, taking the pix in
 order in the first pixa, then the second, etc.
 (2) If naindex is defined, we generate a Numa that gives, for
 each pix in the pixaa, the index of the pixa to which it belongs.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="pnaindex">the pixa index in the pixaa</param>
	<param name="copyflag">L_COPY or L_CLONE</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaSizeRange(LeptonicaSharp.Pixaa,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="pminw">range of dimensions of all boxes</param>
	<param name="pminh">range of dimensions of all boxes</param>
	<param name="pmaxw">range of dimensions of all boxes</param>
	<param name="pmaxh">range of dimensions of all boxes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSizeRange(LeptonicaSharp.Pixa,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pminw">range of dimensions of pix in the array</param>
	<param name="pminh">range of dimensions of pix in the array</param>
	<param name="pmaxw">range of dimensions of pix in the array</param>
	<param name="pmaxh">range of dimensions of pix in the array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaClipToPix(LeptonicaSharp.Pixa,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is intended for use in situations where pixas
 was originally generated from the input pixs.
 (2) Returns a pixad where each pix in pixas is ANDed
 with its associated region of the input pixs.  This
 region is specified by the the box that is associated
 with the pix.
 (3) In a typical application of this function, pixas has
 a set of region masks, so this generates a pixa of
 the parts of pixs that correspond to each region
 mask component, along with the bounding box for
 the region.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="pixs"></param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaClipToForeground(LeptonicaSharp.Pixa,LeptonicaSharp.Pixa@,LeptonicaSharp.Boxa@)">
	<summary>
 Notes
 (1) At least one of [pixd, boxa] must be specified.
 (2) Any pix with no fg pixels is skipped.
 (3) See pixClipToForeground().
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="ppixad">pixa of clipped pix returned</param>
	<param name="pboxa">clipping boxes returned</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaGetRenderingDepth(LeptonicaSharp.Pixa,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pdepth">depth required to render if all colormaps are removed</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaHasColor(LeptonicaSharp.Pixa,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="phascolor">1 if any pix is rgb or has a colormap with color; 0 otherwise</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaAnyColormaps(LeptonicaSharp.Pixa,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="phascmap">1 if any pix has a colormap; 0 otherwise</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaGetDepthInfo(LeptonicaSharp.Pixa,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pmaxdepth">max pixel depth of pix in pixa</param>
	<param name="psame">true if all depths are equal</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaConvertToSameDepth(LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) If any pix has a colormap, they are all converted to rgb.
 Otherwise, they are all converted to the maximum depth of
 all the pix.
 (2) This can be used to allow lossless rendering onto a single pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaEqual(LeptonicaSharp.Pixa,LeptonicaSharp.Pixa,System.Int32,System.Int32@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The two pixa are the "same" if they contain the same
 boxa and the same ordered set of pix.  However, if they
 have boxa, the pix in each pixa can differ in ordering
 by an amount given by the parameter %maxdist.  If they
 don't have a boxa, the %maxdist parameter is ignored,
 and the ordering must be identical.
 (2) This applies only to boxa geometry, pixels and ordering;
 other fields in the pix are ignored.
 (3) naindex[i] gives the position of the box in pixa2 that
 corresponds to box i in pixa1.  It is only returned if the
 pixa have boxa and the boxa are equal.
 (4) In situations where the ordering is very different, so that
 a large %maxdist is required for "equality", this should be
 implemented with a hash function for efficiency.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa1"></param>
	<param name="pixa2"></param>
	<param name="maxdist"></param>
	<param name="pnaindex">index array of correspondences</param>
	<param name="psame">1 if equal; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSetFullSizeBoxa(LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) Replaces the existing boxa.  Each box gives the dimensions
 of the corresponding pix.  This is needed for functions
 like pixaSort() that sort based on the boxes.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplay(LeptonicaSharp.Pixa,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This uses the boxes to place each pix in the rendered composite.
 (2) Set w = h = 0 to use the b.b. of the components to determine
 the size of the returned pix.
 (3) Uses the first pix in pixa to determine the depth.
 (4) The background is written "white".  On 1 bpp, each successive
 pix is "painted" (adding foreground), whereas for grayscale
 or color each successive pix is blitted with just the src.
 (5) If the pixa is empty, returns an empty 1 bpp pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="w">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<param name="h">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplayOnColor(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) This uses the boxes to place each pix in the rendered composite.
 (2) Set w = h = 0 to use the b.b. of the components to determine
 the size of the returned pix.
 (3) If any pix in %pixa are colormapped, or if the pix have
 different depths, it returns a 32 bpp pix.  Otherwise,
 the depth of the returned pixa equals that of the pix in %pixa.
 (4) If the pixa is empty, return null.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="w">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<param name="h">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<param name="bgcolor">background color to use</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplayRandomCmap(LeptonicaSharp.Pixa,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This uses the boxes to place each pix in the rendered composite.
 The fg of each pix in %pixa, such as a single connected
 component or a line of text, is given a random color.
 (2) By default, the background color is black (cmap index 0).
 This can be changed by pixcmapResetColor()
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">1 bpp regions, with boxa delineating those regions</param>
	<param name="w">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<param name="h">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<returns>pix   8 bpp, cmapped, with random colors assigned to each region, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplayLinearly(LeptonicaSharp.Pixa,LeptonicaSharp.Enumerations.L_direction,System.Single,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Boxa@)">
	<summary>
 Notes
 (1) This puts each pix, sequentially, in a line, either horizontally
 or vertically.
 (2) If any pix has a colormap, all pix are rendered in rgb.
 (3) The boxa gives the location of each image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="direction">L_HORIZ or L_VERT</param>
	<param name="scalefactor">applied to every pix; use 1.0 for no scaling</param>
	<param name="background">0 for white, 1 for black; this is the color of the spacing between the images</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of black border added to each image; use 0 for no border</param>
	<param name="pboxa">location of images in output pix</param>
	<returns>pix of composite images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplayOnLattice(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32@,LeptonicaSharp.Boxa@)">
	<summary>
 Notes
 (1) This places each pix on sequentially on a regular lattice
 in the rendered composite.  If a pix is too large to fit in the
 allocated lattice space, it is not rendered.
 (2) If any pix has a colormap, all pix are rendered in rgb.
 (3) This is useful when putting bitmaps of components,
 such as characters, into a single image.
 (4) The boxa gives the location of each image.  The UL corner
 of each image is on a lattice cell corner.  Omitted images
 (due to size) are assigned an invalid width and height of 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="cellw">lattice cell width</param>
	<param name="cellh">lattice cell height</param>
	<param name="pncols">number of columns in output lattice</param>
	<param name="pboxa">location of images in lattice</param>
	<returns>pix of composite images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplayUnsplit(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) This is a logical inverse of pixaSplitPix().  It
 constructs a pix from a mosaic of tiles, all of equal size.
 (2) For added generality, a border of arbitrary color can
 be added to each of the tiles.
 (3) In use, pixa will typically have either been generated
 from pixaSplitPix() or will derived from a pixa that
 was so generated.
 (4) All pix in the pixa must be of equal depth, and, if
 colormapped, have the same colormap.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="nx">number of mosaic cells horizontally</param>
	<param name="ny">number of mosaic cells vertically</param>
	<param name="borderwidth">of added border on all sides</param>
	<param name="bordercolor">in our RGBA format 0xrrggbbaa</param>
	<returns>pix of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplayTiled(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This renders a pixa to a single image of width not to
 exceed maxwidth, with background color either white or black,
 and with each subimage spaced on a regular lattice.
 (2) The lattice size is determined from the largest width and height,
 separately, of all pix in the pixa.
 (3) All pix in the pixa must be of equal depth.
 (4) If any pix has a colormap, all pix are rendered in rgb.
 (5) Careful because no components are omitted, this is
 dangerous if there are thousands of small components and
 one or more very large one, because the size of the
 resulting pix can be huge!
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="maxwidth">of output image</param>
	<param name="background">0 for white, 1 for black</param>
	<param name="spacing"></param>
	<returns>pix of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplayTiledInRows(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This renders a pixa to a single image of width not to
 exceed maxwidth, with background color either white or black,
 and with each row tiled such that the top of each pix is
 aligned and separated by 'spacing' from the next one.
 A black border can be added to each pix.
 (2) All pix are converted to outdepth; existing colormaps are removed.
 (3) This does a reasonably spacewise-efficient job of laying
 out the individual pix images into a tiled composite.
 (4) A serialized boxa giving the location in pixd of each input
 pix (without added border) is stored in the text string of pixd.
 This allows, e.g., regeneration of a pixa from pixd, using
 pixaCreateFromBoxa().  If there is no scaling and the depth of
 each input pix in the pixa is the same, this tiling operation
 can be inverted using the boxa (except for loss of text in
 each of the input pix)
 pix1 = pixaDisplayTiledInRows(pixa1, 1, 1500, 1.0, 0, 30, 0);
 char boxatxt = pixGetText(pix1);
 boxa1 = boxaReadMem((l_uint8 )boxatxt, strlen(boxatxt));
 pixa2 = pixaCreateFromBoxa(pix1, boxa1, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="outdepth">output depth 1, 8 or 32 bpp</param>
	<param name="maxwidth">of output image</param>
	<param name="scalefactor">applied to every pix; use 1.0 for no scaling</param>
	<param name="background">0 for white, 1 for black; this is the color of the spacing between the images</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of black border added to each image; use 0 for no border</param>
	<returns>pixd of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplayTiledInColumns(LeptonicaSharp.Pixa,System.Int32,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This renders a pixa to a single image with nx columns of
 subimages.  The background color is white, and each row
 is tiled such that the top of each pix is aligned and
 each pix is separated by 'spacing' from the next one.
 A black border can be added to each pix.
 (2) The output depth is determined by the largest depth
 required by the pix in the pixa.  Colormaps are removed.
 (3) A serialized boxa giving the location in pixd of each input
 pix (without added border) is stored in the text string of pixd.
 This allows, e.g., regeneration of a pixa from pixd, using
 pixaCreateFromBoxa().  If there is no scaling and the depth of
 each input pix in the pixa is the same, this tiling operation
 can be inverted using the boxa (except for loss of text in
 each of the input pix)
 pix1 = pixaDisplayTiledInColumns(pixa1, 3, 1.0, 0, 30, 2);
 char boxatxt = pixGetText(pix1);
 boxa1 = boxaReadMem((l_uint8 )boxatxt, strlen(boxatxt));
 pixa2 = pixaCreateFromBoxa(pix1, boxa1, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="nx">number of columns in output image</param>
	<param name="scalefactor">applied to every pix; use 1.0 for no scaling</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of black border added to each image; use 0 for no border</param>
	<returns>pixd of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplayTiledAndScaled(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This can be used to tile a number of renderings of
 an image that are at different scales and depths.
 (2) Each image, after scaling and optionally adding the
 black border, has width 'tilewidth'.  Thus, the border does
 not affect the spacing between the image tiles.  The
 maximum allowed border width is tilewidth / 5.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="outdepth">output depth 1, 8 or 32 bpp</param>
	<param name="tilewidth">each pix is scaled to this width</param>
	<param name="ncols">number of tiles in each row</param>
	<param name="background">0 for white, 1 for black; this is the color of the spacing between the images</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<returns>pix of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplayTiledWithText(LeptonicaSharp.Pixa,System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) This is a version of pixaDisplayTiledInRows() that prints, below
 each pix, the text in the pix text field.  Up to 127 chars
 of text in the pix text field are rendered below each pix.
 (2) It renders a pixa to a single image of width not to
 exceed %maxwidth, with white background color, with each row
 tiled such that the top of each pix is aligned and separated
 by %spacing from the next one.
 (3) All pix are converted to 32 bpp.
 (4) This does a reasonably spacewise-efficient job of laying
 out the individual pix images into a tiled composite.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="maxwidth">of output image</param>
	<param name="scalefactor">applied to every pix; use 1.0 for no scaling</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of black border added to each image; use 0 for no border</param>
	<param name="fontsize">4, 6, ... 20</param>
	<param name="textcolor">0xrrggbb00</param>
	<returns>pixd of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplayTiledByIndex(LeptonicaSharp.Pixa,LeptonicaSharp.Numa,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) This renders a pixa to a single image with white
 background color, where the pix are placed in columns
 given by the index value in the numa.  Each pix
 is separated by %spacing from the adjacent ones, and
 an optional border is placed around them.
 (2) Up to 127 chars of text in the pix text field are rendered
 below each pix.  Use newlines in the text field to write
 the text in multiple lines that fit within the pix width.
 (3) To avoid having empty columns, if there are N different
 index values, they should be in [0 ... N-1].
 (4) All pix are converted to 32 bpp.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="na">numa with indices corresponding to the pix in pixa</param>
	<param name="width">each pix is scaled to this width</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of black border added to each image; use 0 for no border</param>
	<param name="fontsize">4, 6, ... 20</param>
	<param name="textcolor">0xrrggbb00</param>
	<returns>pixd of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaDisplay(LeptonicaSharp.Pixaa,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Each pix of the paa is displayed at the location given by
 its box, translated by the box of the containing pixa
 if it exists.
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="w">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<param name="h">if set to 0, the size is determined from the bounding box of the components in pixa</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaDisplayByPixa(LeptonicaSharp.Pixaa,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Displays each pixa on a line (or set of lines),
 in order from top to bottom.  Within each pixa,
 the pix are displayed in order from left to right.
 (2) The sizes and depths of each pix can differ.  The output pix
 has a depth equal to the max depth of all the pix.
 (3) This ignores the boxa of the paa.
 </summary>
	<remarks>
	</remarks>
	<param name="paa">with pix that may have different depths</param>
	<param name="xspace">between pix in pixa</param>
	<param name="yspace">between pixa</param>
	<param name="maxw">max width of output pix</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaaDisplayTiledAndScaled(LeptonicaSharp.Pixaa,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For each pixa, this generates from all the pix a
 tiled/scaled output pix, and puts it in the output pixa.
 (2) See comments in pixaDisplayTiledAndScaled().
 </summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="outdepth">output depth 1, 8 or 32 bpp</param>
	<param name="tilewidth">each pix is scaled to this width</param>
	<param name="ncols">number of tiles in each row</param>
	<param name="background">0 for white, 1 for black; this is the color of the spacing between the images</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<returns>pixa of tiled images, one image for each pixa in the paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaConvertTo1(LeptonicaSharp.Pixa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="thresh">threshold for final binarization from 8 bpp gray</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaConvertTo8(LeptonicaSharp.Pixa,System.Int32)">
	<summary>
 Notes
 (1) See notes for pixConvertTo8(), applied to each pix in pixas.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="cmapflag">1 to give pixd a colormap; 0 otherwise</param>
	<returns>pixad each pix is 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaConvertTo8Colormap(LeptonicaSharp.Pixa,System.Int32)">
	<summary>
 Notes
 (1) See notes for pixConvertTo8Colormap(), applied to each pix in pixas.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="dither">1 to dither if necessary; 0 otherwise</param>
	<returns>pixad each pix is 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaConvertTo32(LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) See notes for pixConvertTo32(), applied to each pix in pixas.
 (2) This can be used to allow 1 bpp pix in a pixa to be displayed
 with color.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<returns>pixad 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaConstrainedSelect(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) See notes in genConstrainedNumaInRange() for how selection
 is made.
 (2) This returns a selection of the pix in the input pixa.
 (3) Use copyflag == L_COPY if you don't want changes in the pix
 in the returned pixa to affect those in the input pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="first">first index to choose; GT= 0</param>
	<param name="last">biggest possible index to reach; use -1 to go to the end; otherwise, last GT= first</param>
	<param name="nmax">maximum number of pix to select; GT 0</param>
	<param name="use_pairs">1 = select pairs of adjacent pix; 0 = select individual pix</param>
	<param name="copyflag">L_COPY, L_CLONE</param>
	<returns>pixad if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSelectToPdf(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.UInt32,System.Int32,System.String)">
	<summary>
 Notes
 (1) This writes a pdf of the selected images from %pixas, one to
 a page.  They are optionally scaled and annotated with the
 index printed to the left of the image.
 (2) If the input images are 1 bpp and you want the numbers to be
 in color, first promote each pix to 8 bpp with a colormap
 pixa1 = pixaConvertTo8(pixas, 1);
 and then call this function with the specified color
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="first">first index to choose; GT= 0</param>
	<param name="last">biggest possible index to reach; use -1 to go to the end; otherwise, last GT= first</param>
	<param name="res">override the resolution of each input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or 0 for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="color">of numbers added to each image (e.g., 0xff000000)</param>
	<param name="fontsize">to print number below each image.  The valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaDisplayMultiTiled(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Each set of %nx  %ny images is optionally scaled and saved
 into a new pix, and then aggregated.
 (2) Set %maxw = %maxh = 0 if you want to include all pix from %pixs.
 (3) This is useful for generating a pdf from the output pixa, where
 each page is a tile of (%nx  %ny) images from the input pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="nx">in [1, ... 50], tiling factors in each direction</param>
	<param name="ny">in [1, ... 50], tiling factors in each direction</param>
	<param name="maxw">max sizes to keep</param>
	<param name="maxh">max sizes to keep</param>
	<param name="scalefactor">scale each image by this</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<returns>pixad if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSplitIntoFiles(LeptonicaSharp.Pixa,System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For each requested output, %nsplit files are written into
 directory /tmp/lept/split/.
 (2) This is useful when a pixa is so large that the images
 are not conveniently displayed as a single tiled image at
 full resolution.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="nsplit">split pixas into this number of pixa; GT= 2</param>
	<param name="scale">scalefactor applied to each pix</param>
	<param name="outwidth">the maxwidth parameter of tiled images for write_pix</param>
	<param name="write_pixa">1 to write the split pixa as separate files</param>
	<param name="write_pix">1 to write tiled images of the split pixa</param>
	<param name="write_pdf">1 to write pdfs of the split pixa</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertToNUpFiles(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) Each set of %nx  %ny images is scaled and tiled into a single
 image, that is written out to %outdir.
 (2) All images in each %nx  %ny set are scaled to the same
 width, %tw.  This is typically used when all images are
 roughly the same size.
 (3) This is useful for generating a pdf from the set of input
 files, where each page is a tile of (%nx  %ny) input images.
 Typical values for %nx and %ny are in the range [2 ... 5].
 (4) If %fontsize != 0, each image has the tail of its filename
 rendered below it.
 </summary>
	<remarks>
	</remarks>
	<param name="dir">full path to directory of images</param>
	<param name="substr">can be null</param>
	<param name="nx">in [1, ... 50], tiling factors in each direction</param>
	<param name="ny">in [1, ... 50], tiling factors in each direction</param>
	<param name="tw">target width, in pixels; must be GT= 20</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<param name="fontsize">to print tail of filename with image.  Valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	<param name="outdir">subdirectory of /tmp to put N-up tiled images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertToNUpPixa(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) See notes for convertToNUpFiles()
 </summary>
	<remarks>
	</remarks>
	<param name="dir">full path to directory of images</param>
	<param name="substr">can be null</param>
	<param name="nx">in [1, ... 50], tiling factors in each direction</param>
	<param name="ny">in [1, ... 50], tiling factors in each direction</param>
	<param name="tw">target width, in pixels; must be GT= 20</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<param name="fontsize">to print tail of filename with image.  Valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaConvertToNUpPixa(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Sarray)">
	<summary>
 Notes
 (1) This takes an input pixa and an optional array of strings, and
 generates a pixa of NUp tiles from the input, labeled with
 the strings if they exist and %fontsize != 0.
 (2) See notes for convertToNUpFiles()
 </summary>
	<remarks>
	</remarks>
	<param name="pixas"></param>
	<param name="sa">array of strings associated with each pix</param>
	<param name="nx">in [1, ... 50], tiling factors in each direction</param>
	<param name="ny">in [1, ... 50], tiling factors in each direction</param>
	<param name="tw">target width, in pixels; must be GT= 20</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<param name="fontsize">to print string with each image.  Valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	<returns>pixad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaCompareInPdf(LeptonicaSharp.Pixa,LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) This takes two pixa and renders them interleaved, side-by-side
 in a pdf.  A warning is issued if the input pixa arrays
 have different lengths.
 (2) %nx and %ny specify how many side-by-side pairs are displayed
 on each pdf page.  For example, if %nx = 1 and %ny = 2, then
 two pairs are shown, one above the other, on each page.
 (3) The input pix are scaled to a target width of %tw, and
 then paired with optional %spacing between and optional
 black border of width %border.
 (4) After a pixa is generated of these tiled images, it is
 written to %fileout as a pdf.
 (5) Typical numbers for the input parameters are
 %nx = small integer (1 - 4)
 %ny = 2  %nx
 %tw = 200 - 500 pixels
 %spacing = 10
 %border = 2
 %fontsize = 10
 (6) If %fontsize != 0, the index of the pix pair in their pixa
 is printed out below each pair.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa1"></param>
	<param name="pixa2"></param>
	<param name="nx">in [1, ... 20], tiling factors in each direction</param>
	<param name="ny">in [1, ... 20], tiling factors in each direction</param>
	<param name="tw">target width, in pixels; must be GT= 20</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image and on each pair; use 0 for no border</param>
	<param name="fontsize">to print index of each pair of images.  Valid set is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.</param>
	<param name="fileout">output pdf file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pmsCreate(System.UInt32,System.UInt32,LeptonicaSharp.Numa,System.String)">
	<summary>
 Notes
 (1) This computes the size of the block of memory required
 and allocates it.  Each chunk starts on a 32-bit word boundary.
 The chunk sizes are in powers of 2, starting at %smallest,
 and the number of levels and chunks at each level is
 specified by %numalloc.
 (2) This is intended to manage the image data for a small number
 of relatively large pix.  The system malloc is expected to
 handle very large numbers of small chunks efficiently.
 (3) Important set the allocators and call this function
 before any pix have been allocated.  Destroy all the pix
 in the normal way before calling pmsDestroy().
 (4) The pms struct is stored in a static global, so this function
 is not thread-safe.  When used, there must be only one thread
 per process.
 </summary>
	<remarks>
	</remarks>
	<param name="minsize">of data chunk that can be supplied by pms</param>
	<param name="smallest">bytes of the smallest pre-allocated data chunk.</param>
	<param name="numalloc">array with the number of data chunks for each size that are in the memory store</param>
	<param name="logfile">use for debugging; null otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pmsDestroy">
	<summary>
 Notes
 (1) Important call this function at the end of the program, after
 the last pix has been destroyed.
 </summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.pmsCustomAlloc(System.UInt32)">
	<summary>
 Notes
 (1) This attempts to find a suitable pre-allocated chunk.
 If not found, it dynamically allocates the chunk.
 (2) If logging is turned on, the allocations that are not taken
 from the memory store, and are at least as large as the
 minimum size the store can handle, are logged to file.
 </summary>
	<remarks>
	</remarks>
	<param name="nbytes">min number of bytes in the chunk to be retrieved</param>
	<returns>data ptr to chunk</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pmsCustomDealloc(System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">to be freed or returned to the storage</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pmsGetAlloc(System.UInt32)">
	<summary>
 Notes
 (1) This is called when a request for pix data cannot be
 obtained from the preallocated memory store.  After use it
 is freed like normal memory.
 (2) If logging is on, only write out allocs that are as large as
 the minimum size handled by the memory store.
 (3) size_t is %lu on 64 bit platforms and %u on 32 bit platforms.
 The C99 platform-independent format specifier for size_t is %zu,
 but windows hasn't conformed, so we are forced to go back to
 C89, use %lu, and cast to get platform-independence.  Ugh.
 </summary>
	<remarks>
	</remarks>
	<param name="nbytes"></param>
	<returns>data</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pmsGetLevelForAlloc(System.UInt32,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nbytes">min number of bytes in the chunk to be retrieved</param>
	<param name="plevel">-1 if either too small or too large</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pmsGetLevelForDealloc(System.Object,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">ptr to memory chunk</param>
	<param name="plevel">level in memory store; -1 if allocated outside the store</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pmsLogInfo">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddConstantGray(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) In-place operation.
 (2) No clipping for 32 bpp.
 (3) For 8 and 16 bpp, if val GT 0 the result is clipped
 to 0xff and 0xffff, rsp.
 (4) For 8 and 16 bpp, if val LT 0 the result is clipped to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16 or 32 bpp</param>
	<param name="val">amount to add to each pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMultConstantGray(LeptonicaSharp.Pix,System.Single)">
	<summary>
 Notes
 (1) In-place operation; val must be GT= 0.
 (2) No clipping for 32 bpp.
 (3) For 8 and 16 bpp, the result is clipped to 0xff and 0xffff, rsp.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16 or 32 bpp</param>
	<param name="val">GT= 0.0; amount to multiply by each pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddGray(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Arithmetic addition of two 8, 16 or 32 bpp images.
 (2) For 8 and 16 bpp, we do explicit clipping to 0xff and 0xffff,
 respectively.
 (3) Alignment is to UL corner.
 (4) There are 3 cases.  The result can go to a new dest,
 in-place to pixs1, or to an existing input dest
 pixd == null   (src1 + src2) --GT new pixd
 pixd == pixs1  (src1 + src2) --GT src1  (in-place)
 pixd != pixs1  (src1 + src2) --GT input pixd
 (5) pixs2 must be different from both pixd and pixs1.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs1, or different from pixs1</param>
	<param name="pixs1">can be == to pixd</param>
	<param name="pixs2"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSubtractGray(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Arithmetic subtraction of two 8, 16 or 32 bpp images.
 (2) Source pixs2 is always subtracted from source pixs1.
 (3) Do explicit clipping to 0.
 (4) Alignment is to UL corner.
 (5) There are 3 cases.  The result can go to a new dest,
 in-place to pixs1, or to an existing input dest
 (a) pixd == null   (src1 - src2) --GT new pixd
 (b) pixd == pixs1  (src1 - src2) --GT src1  (in-place)
 (d) pixd != pixs1  (src1 - src2) --GT input pixd
 (6) pixs2 must be different from both pixd and pixs1.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs1, or different from pixs1</param>
	<param name="pixs1">can be == to pixd</param>
	<param name="pixs2"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixThresholdToValue(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 ~ operation can be in-place (pixs == pixd) or to a new pixd
 ~ if setval GT threshval, sets pixels with a value GT= threshval to setval
 ~ if setval LT threshval, sets pixels with a value LT= threshval to setval
 ~ if setval == threshval, no-op
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; if not null, must be equal to pixs</param>
	<param name="pixs">8, 16, 32 bpp</param>
	<param name="threshval"></param>
	<param name="setval"></param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixInitAccumulate(System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) The offset must be GT= 0.
 (2) The offset is used so that we can do arithmetic
 with negative number results on l_uint32 data; it
 prevents the l_uint32 data from going negative.
 (3) Because we use l_int32 intermediate data results,
 these should never exceed the max of l_int32 (0x7fffffff).
 We do not permit the offset to be above 0x40000000,
 which is half way between 0 and the max of l_int32.
 (4) The same offset should be used for initialization,
 multiplication by a constant, and final extraction!
 (5) If you're only adding positive values, offset can be 0.
 </summary>
	<remarks>
	</remarks>
	<param name="w">of accumulate array</param>
	<param name="h">of accumulate array</param>
	<param name="offset">initialize the 32 bpp to have this value; not more than 0x40000000</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFinalAccumulate(LeptonicaSharp.Pix,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) The offset must be GT= 0 and should not exceed 0x40000000.
 (2) The offset is subtracted from the src 32 bpp image
 (3) For 8 bpp dest, the result is clipped to [0, 0xff]
 (4) For 16 bpp dest, the result is clipped to [0, 0xffff]
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="offset">same as used for initialization</param>
	<param name="depth">8, 16 or 32 bpp, of destination</param>
	<returns>pixd 8, 16 or 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFinalAccumulateThreshold(LeptonicaSharp.Pix,System.UInt32,System.UInt32)">
	<summary>
 Notes
 (1) The offset must be GT= 0 and should not exceed 0x40000000.
 (2) The offset is subtracted from the src 32 bpp image
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="offset">same as used for initialization</param>
	<param name="threshold">values less than this are set in the destination</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAccumulate(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_arithmetic_logical_operator)">
	<summary>
 Notes
 (1) This adds or subtracts each pixs value from pixd.
 (2) This clips to the minimum of pixs and pixd, so they
 do not need to be the same size.
 (3) The alignment is to the origin [UL corner] of pixs  pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp</param>
	<param name="pixs">1, 8, 16 or 32 bpp</param>
	<param name="op">L_ARITH_ADD or L_ARITH_SUBTRACT</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMultConstAccumulate(LeptonicaSharp.Pix,System.Single,System.UInt32)">
	<summary>
 Notes
 (1) The offset must be GT= 0 and should not exceed 0x40000000.
 (2) This multiplies each pixel, relative to offset, by the input factor
 (3) The result is returned with the offset back in place.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="factor"></param>
	<param name="offset">same as used for initialization</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAbsDifference(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The depth of pixs1 and pixs2 must be equal.
 (2) Clips computation to the min size, aligning the UL corners
 (3) For 8 and 16 bpp, assumes one gray component.
 (4) For 32 bpp, assumes 3 color components, and ignores the
 LSB of each word (the alpha channel)
 (5) Computes the absolute value of the difference between
 each component value.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">both either 8 or 16 bpp gray, or 32 bpp RGB</param>
	<param name="pixs2">both either 8 or 16 bpp gray, or 32 bpp RGB</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddRGB(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Clips computation to the minimum size, aligning the UL corners.
 (2) Removes any colormap to RGB, and ignores the LSB of each
 pixel word (the alpha channel).
 (3) Adds each component value, pixelwise, clipping to 255.
 (4) This is useful to combine two images where most of the
 pixels are essentially black, such as in pixPerceptualDiff().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">32 bpp RGB, or colormapped</param>
	<param name="pixs2">32 bpp RGB, or colormapped</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMinOrMax(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_CHOOSE_M,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This gives the min or max of two images, component-wise.
 (2) The depth can be 8 or 16 bpp for 1 component, and 32 bpp
 for a 3 component image.  For 32 bpp, ignore the LSB
 of each word (the alpha channel)
 (3) There are 3 cases
 ~  if pixd == null,   Min(src1, src2) --GT new pixd
 ~  if pixd == pixs1,  Min(src1, src2) --GT src1  (in-place)
 ~  if pixd != pixs1,  Min(src1, src2) --GT input pixd
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">destination this can be null, equal to pixs1, or different from pixs1</param>
	<param name="pixs1">can be == to pixd</param>
	<param name="pixs2"></param>
	<param name="type">L_CHOOSE_MIN, L_CHOOSE_MAX</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMaxDynamicRange(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_L_SCALE)">
	<summary>
 Notes
 (1) Scales pixel values to fit maximally within the dest 8 bpp pixd
 (2) Assumes the source 'pixels' are a 1-component scalar.  For
 a 32 bpp source, each pixel is treated as a single number --
 not as a 3-component rgb pixel value.
 (3) Uses a LUT for log scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">4, 8, 16 or 32 bpp source</param>
	<param name="type">L_LINEAR_SCALE or L_LOG_SCALE</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMaxDynamicRangeRGB(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_L_SCALE)">
	<summary>
 Notes
 (1) Scales pixel values to fit maximally within a 32 bpp dest pixd
 (2) All color components are scaled with the same factor, based
 on the maximum r,g or b component in the image.  This should
 not be used if the 32-bit value is a single number (e.g., a
 count in a histogram generated by pixMakeHistoHS()).
 (3) Uses a LUT for log scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb source</param>
	<param name="type">L_LINEAR_SCALE or L_LOG_SCALE</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.linearScaleRGBVal(System.UInt32,System.Single)">
	<summary>
 Notes
 (1) %factor must be chosen to be not greater than (255 / maxcomp),
 where maxcomp is the maximum value of the pixel components.
 Otherwise, the product will overflow a uint8.  In use, factor
 is the same for all pixels in a pix.
 (2) No scaling is performed on the transparency ("A") component.
 </summary>
	<remarks>
	</remarks>
	<param name="sval">32-bit rgb pixel value</param>
	<param name="factor">multiplication factor on each component</param>
	<returns>dval  linearly scaled version of %sval</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.logScaleRGBVal(System.UInt32,System.Single[],System.Single)">
	<summary>
 Notes
 (1) %tab is made with makeLogBase2Tab().
 (2) %factor must be chosen to be not greater than
 255.0 / log[base2](maxcomp), where maxcomp is the maximum
 value of the pixel components.  Otherwise, the product
 will overflow a uint8.  In use, factor is the same for
 all pixels in a pix.
 (3) No scaling is performed on the transparency ("A") component.
 </summary>
	<remarks>
	</remarks>
	<param name="sval">32-bit rgb pixel value</param>
	<param name="tab">256 entry log-base-2 table</param>
	<param name="factor">multiplication factor on each component</param>
	<returns>dval  log scaled version of %sval</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeLogBase2Tab">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getLogBase2(System.Int32@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcompCreateFromPix(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.IFF)">
	<summary>
 Notes
 (1) Use %comptype == IFF_DEFAULT to have the compression
 type automatically determined.
 (2) To compress jpeg with a quality other than the default (75), use
 l_jpegSetQuality()
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>pixc, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcompCreateFromString(System.Byte[],System.UInt32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) This works when the compressed string is png, jpeg or tiffg4.
 (2) The copyflag determines if the data in the new Pixcomp is
 a copy of the input data.
 </summary>
	<remarks>
	</remarks>
	<param name="data">compressed string</param>
	<param name="size">number of bytes</param>
	<param name="copyflag">L_INSERT or L_COPY</param>
	<returns>pixc, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcompCreateFromFile(System.String,LeptonicaSharp.Enumerations.IFF)">
	<summary>
 Notes
 (1) Use %comptype == IFF_DEFAULT to have the compression
 type automatically determined.
 (2) If the comptype is invalid for this file, the default will
 be substituted.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>pixc, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcompDestroy(LeptonicaSharp.PixComp@)">
	<summary>
 Notes
 (1) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppixc">will be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcompCopy(LeptonicaSharp.PixComp)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixcs"></param>
	<returns>pixcd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcompGetDimensions(LeptonicaSharp.PixComp,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixc"></param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pd"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcompGetParameters(LeptonicaSharp.PixComp,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixc"></param>
	<param name="pxres"></param>
	<param name="pyres"></param>
	<param name="pcomptype"></param>
	<param name="pcmapflag"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcompDetermineFormat(LeptonicaSharp.Enumerations.IFF,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This determines the best format for a pix, given both
 the request (%comptype) and the image characteristics.
 (2) If %comptype == IFF_DEFAULT, this does not necessarily result
 in png encoding.  Instead, it returns one of the three formats
 that is both valid and most likely to give best compression.
 (3) If the pix cannot be compressed by the input value of
 %comptype, this selects IFF_PNG, which can compress all pix.
 </summary>
	<remarks>
	</remarks>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<param name="d">pix depth</param>
	<param name="cmapflag">1 if pix to be compressed as a colormap; 0 otherwise</param>
	<param name="pformat">return IFF_TIFF, IFF_PNG or IFF_JFIF_JPEG</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixCreateFromPixcomp(LeptonicaSharp.PixComp)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixc"></param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">initial number of ptrs</param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompCreateWithInit(System.Int32,System.Int32,LeptonicaSharp.Enumerations.IFF,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Initializes a pixacomp to be fully populated with %pix,
 compressed using %comptype.  If %pix == NULL, %comptype
 is ignored.
 (2) Typically, the array is initialized with a tiny pix.
 This is most easily done by setting %pix == NULL, causing
 initialization of each array element with a tiny placeholder
 pix (w = h = d = 1), using comptype = IFF_TIFF_G4 .
 (3) Example usage
 // Generate pixacomp for pages 30 - 49.  This has an array
 // size of 20 and the page number offset is 30.
 PixaComp pixac = pixacompCreateWithInit(20, 30, NULL,
 IFF_TIFF_G4);
 // Now insert png-compressed images into the initialized array
 for (pageno = 30; pageno LT 50; pageno++) {
 Pix pixt = ...   // derived from image[pageno]
 if (pixt)
 pixacompReplacePix(pixac, pageno, pixt, IFF_PNG);
 pixDestroy(pixt);
 }
 The result is a pixac with 20 compressed strings, and with
 selected pixt replacing the placeholders.
 To extract the image for page 38, which is decompressed
 from element 8 in the array, use
 pixt = pixacompGetPix(pixac, 38);
 </summary>
	<remarks>
	</remarks>
	<param name="n">initial number of ptrs</param>
	<param name="offset">difference accessor index - pixacomp array index</param>
	<param name="pix">initialize each ptr in pixacomp to this pix; can be NULL</param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompCreateFromPixa(LeptonicaSharp.Pixa,LeptonicaSharp.Enumerations.IFF,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) If %format == IFF_DEFAULT, the conversion format for each
 image is chosen automatically.  Otherwise, we use the
 specified format unless it can't be done (e.g., jpeg
 for a 1, 2 or 4 bpp pix, or a pix with a colormap),
 in which case we use the default (assumed best) compression.
 (2) %accesstype is used to extract a boxa from %pixa.
 (3) To compress jpeg with a quality other than the default (75), use
 l_jpegSetQuality()
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<param name="accesstype">L_COPY, L_CLONE, L_COPY_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompCreateFromFiles(System.String,LeptonicaSharp.Enumerations.IFF,System.String)">
	<summary>
 Notes
 (1) %dirname is the full path for the directory.
 (2) %substr is the part of the file name (excluding
 the directory) that is to be matched.  All matching
 filenames are read into the Pixa.  If substr is NULL,
 all filenames are read into the Pixa.
 (3) Use %comptype == IFF_DEFAULT to have the compression
 type automatically determined for each file.
 (4) If the comptype is invalid for a file, the default will
 be substituted.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname"></param>
	<param name="substr">substring filter on filenames; can be null</param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompCreateFromSA(LeptonicaSharp.Sarray,LeptonicaSharp.Enumerations.IFF)">
	<summary>
 Notes
 (1) Use %comptype == IFF_DEFAULT to have the compression
 type automatically determined for each file.
 (2) If the comptype is invalid for a file, the default will
 be substituted.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">full pathnames for all files</param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompDestroy(LeptonicaSharp.PixaComp@)">
	<summary>
 Notes
 (1) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppixac">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompAddPix(LeptonicaSharp.PixaComp,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.IFF)">
	<summary>
 Notes
 (1) The array is filled up to the (n-1)-th element, and this
 converts the input pix to a pixc and adds it at
 the n-th position.
 (2) The pixc produced from the pix is owned by the pixac.
 The input pix is not affected.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="pix">to be added</param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompAddPixcomp(LeptonicaSharp.PixaComp,LeptonicaSharp.PixComp,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) Anything added to a pixac is owned by the pixac.
 So do not L_INSERT a pixc that is owned by another pixac,
 or destroy a pixc that has been L_INSERTed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="pixc">to be added by insertion</param>
	<param name="copyflag">L_INSERT, L_COPY</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompReplacePix(LeptonicaSharp.PixaComp,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.IFF)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 (2) The input %pix is converted to a pixc, which is then inserted
 into the pixac.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<param name="pix">owned by the caller</param>
	<param name="comptype">IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompReplacePixcomp(LeptonicaSharp.PixaComp,System.Int32,LeptonicaSharp.PixComp)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 (2) The inserted %pixc is now owned by the pixac.  The caller
 must not destroy it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<param name="pixc">to replace existing one, which is destroyed</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompAddBox(LeptonicaSharp.PixaComp,LeptonicaSharp.Box,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="box"></param>
	<param name="copyflag">L_INSERT, L_COPY</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompGetCount(LeptonicaSharp.PixaComp)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<returns>count, or 0 if no pixa</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompGetPixcomp(LeptonicaSharp.PixaComp,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 (2) If copyflag == L_NOCOPY, the pixc is owned by %pixac; do
 not destroy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<param name="copyflag">L_NOCOPY, L_COPY</param>
	<returns>pixc, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompGetPix(LeptonicaSharp.PixaComp,System.Int32)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompGetPixDimensions(LeptonicaSharp.PixaComp,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<param name="pd">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompGetBoxa(LeptonicaSharp.PixaComp,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="accesstype">L_COPY, L_CLONE, L_COPY_CLONE</param>
	<returns>boxa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompGetBoxaCount(LeptonicaSharp.PixaComp)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompGetBox(LeptonicaSharp.PixaComp,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 (2) There is always a boxa with a pixac, and it is initialized so
 that each box ptr is NULL.
 (3) In general, we expect that there is either a box associated
 with each pixc, or no boxes at all in the boxa.
 (4) Having no boxes is thus not an automatic error.  Whether it
 is an actual error is determined by the calling program.
 If the caller expects to get a box, it is an error; see, e.g.,
 pixacGetBoxGeometry().
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<param name="accesstype">L_COPY or L_CLONE</param>
	<returns>box if null, not automatically an error, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompGetBoxGeometry(LeptonicaSharp.PixaComp,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The %index includes the offset, which must be subtracted
 to get the actual index into the ptr array.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="index">caller's view of index within pixac; includes offset</param>
	<param name="px">each can be null</param>
	<param name="py">each can be null</param>
	<param name="pw">each can be null</param>
	<param name="ph">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompGetOffset(LeptonicaSharp.PixaComp)">
	<summary>
 Notes
 (1) The offset is the difference between the caller's view of
 the index into the array and the actual array index.
 By default it is 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<returns>offset, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompSetOffset(LeptonicaSharp.PixaComp,System.Int32)">
	<summary>
 Notes
 (1) The offset is the difference between the caller's view of
 the index into the array and the actual array index.
 By default it is 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="offset">non-negative</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaCreateFromPixacomp(LeptonicaSharp.PixaComp,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) Because the pixa has no notion of offset, the offset must
 be set to 0 before the conversion, so that pixacompGetPix()
 fetches all the pixcomps.  It is reset at the end.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="accesstype">L_COPY, L_CLONE, L_COPY_CLONE; for boxa</param>
	<returns>pixa if OK, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompJoin(LeptonicaSharp.PixaComp,System.Int32,System.Int32,LeptonicaSharp.PixaComp)">
	<summary>
 Notes
 (1) This appends a clone of each indicated pixc in pixcas to pixcad
 (2) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (3) iend LT 0 means 'read to the end'
 (4) If pixacs is NULL or contains no pixc, this is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="pixacd">dest pixac; add to this one</param>
	<param name="pixacs">source pixac; add from this one</param>
	<param name="istart">starting index in pixacs</param>
	<param name="iend">ending index in pixacs; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompInterleave(LeptonicaSharp.PixaComp,LeptonicaSharp.PixaComp)">
	<summary>
 Notes
 (1) If the two pixac have different sizes, a warning is issued,
 and the number of pairs returned is the minimum size.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac1">first src pixac</param>
	<param name="pixac2">second src pixac</param>
	<returns>pixacd  interleaved from sources, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompRead(System.String)">
	<summary>
 Notes
 (1) Unlike the situation with serialized Pixa, where the image
 data is stored in png format, the Pixacomp image data
 can be stored in tiffg4, png and jpg formats.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompReadMem(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) Deseralizes a buffer of pixacomp data into a pixac in memory.
 </summary>
	<remarks>
	</remarks>
	<param name="data">const; pixacomp format</param>
	<param name="size">of data</param>
	<returns>pixac, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompWrite(System.String,LeptonicaSharp.PixaComp)">
	<summary>
 Notes
 (1) Unlike the situation with serialized Pixa, where the image
 data is stored in png format, the Pixacomp image data
 can be stored in tiffg4, png and jpg formats.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pixac"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.PixaComp)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pixac"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.PixaComp)">
	<summary>
 Notes
 (1) Serializes a pixac in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">serialized data of pixac</param>
	<param name="psize">size of serialized data</param>
	<param name="pixac"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompConvertToPdf(LeptonicaSharp.PixaComp,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.String,System.String)">
	<summary>
 Notes
 (1) This follows closely the function pixaConvertToPdf() in pdfio.c.
 (2) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without
 colormap and many colors, or 32 bpp; FLATE for anything else.
 (3) The scalefactor must be GT 0.0; otherwise it is set to 1.0.
 (4) Specifying one of the three encoding types for %type forces
 all images to be compressed with that type.  Use 0 to have
 the type determined for each image based on depth and whether
 or not it has a colormap.
 (5) If all images are jpeg compressed, don't require scaling
 and have the same resolution, it is much faster to skip
 transcoding with pixacompFastConvertToPdfData(), and then
 write the data out to file.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac">containing images all at the same resolution</param>
	<param name="res">override the resolution of each input image, in ppi; use 0 to respect the resolution embedded in the input</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or L_DEFAULT_ENCODE for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title</param>
	<param name="fileout">pdf file of all images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompConvertToPdfData(LeptonicaSharp.PixaComp,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_ENCODE,System.Int32,System.Byte[]@,System.UInt32@,System.String)">
	<summary>
 Notes
 (1) See pixacompConvertToPdf().
 </summary>
	<remarks>
	</remarks>
	<param name="pixac">containing images all at the same resolution</param>
	<param name="res">input resolution of all images</param>
	<param name="scalefactor">scaling factor applied to each image; GT 0.0</param>
	<param name="type">encoding type (L_JPEG_ENCODE, L_G4_ENCODE, L_FLATE_ENCODE, or L_DEFAULT_ENCODE for default</param>
	<param name="quality">used for JPEG only; 0 for default (75)</param>
	<param name="title">pdf title</param>
	<param name="pdata">output pdf data (of all images</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompFastConvertToPdfData(LeptonicaSharp.PixaComp,System.Byte[]@,System.UInt32@,System.String)">
	<summary>
 Notes
 (1) This generates the pdf without transcoding if all the
 images in %pixac are compressed with jpeg.
 Images not jpeg compressed are skipped.
 (2) It assumes all images have the same resolution, and that
 the resolution embedded in each jpeg file is correct.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac">containing images all at the same resolution</param>
	<param name="title">pdf title</param>
	<param name="pdata">output pdf data (of all images</param>
	<param name="pnbytes">size of output pdf data</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompWriteStreamInfo(LeptonicaSharp.FILE,LeptonicaSharp.PixaComp,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pixac"></param>
	<param name="text">identifying string; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcompWriteStreamInfo(LeptonicaSharp.FILE,LeptonicaSharp.PixComp,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pixc"></param>
	<param name="text">identifying string; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompDisplayTiledAndScaled(LeptonicaSharp.PixaComp,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is the same function as pixaDisplayTiledAndScaled(),
 except it works on a Pixacomp instead of a Pix.  It is particularly
 useful for showing the images in a Pixacomp at reduced resolution.
 (2) See pixaDisplayTiledAndScaled() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="outdepth">output depth 1, 8 or 32 bpp</param>
	<param name="tilewidth">each pix is scaled to this width</param>
	<param name="ncols">number of tiles in each row</param>
	<param name="background">0 for white, 1 for black; this is the color of the spacing between the images</param>
	<param name="spacing">between images, and on outside</param>
	<param name="border">width of additional black border on each image; use 0 for no border</param>
	<returns>pix of tiled images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixacompWriteFiles(LeptonicaSharp.PixaComp,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixac"></param>
	<param name="subdir">(subdirectory of /tmp)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixcompWriteFile(System.String,LeptonicaSharp.PixComp)">
	<summary>
 Notes
 (1) The compressed data is written to file, and the filename is
 generated by appending the format extension to %rootname.
 </summary>
	<remarks>
	</remarks>
	<param name="rootname"></param>
	<param name="pixc"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixThreshold8(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This uses, by default, equally spaced "target" values
 that depend on the number of levels, with thresholds
 halfway between.  For N levels, with separation (N-1)/255,
 there are N-1 fixed thresholds.
 (2) For 1 bpp destination, the number of levels can only be 2
 and if a cmap is made, black is (0,0,0) and white
 is (255,255,255), which is opposite to the convention
 without a colormap.
 (3) For 1, 2 and 4 bpp, the nlevels arg is used if a colormap
 is made; otherwise, we take the most significant bits
 from the src that will fit in the dest.
 (4) For 8 bpp, the input pixs is quantized to nlevels.  The
 dest quantized with that mapping, either through a colormap
 table or directly with 8 bit values.
 (5) Typically you should not use make a colormap for 1 bpp dest.
 (6) This is not dithering.  Each pixel is treated independently.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="d">destination depth 1, 2, 4 or 8</param>
	<param name="nlevels">number of levels to be used for colormap</param>
	<param name="cmapflag">1 if makes colormap; 0 otherwise</param>
	<returns>pixd thresholded with standard dest thresholds, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRemoveColormapGeneral(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.REMOVE_CMAP,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) Convenience function that allows choice between returning
 a clone or a copy if pixs does not have a colormap.
 (2) See pixRemoveColormap().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, with or without colormap</param>
	<param name="type">REMOVE_CMAP_TO_BINARY, REMOVE_CMAP_TO_GRAYSCALE, REMOVE_CMAP_TO_FULL_COLOR, REMOVE_CMAP_WITH_ALPHA, REMOVE_CMAP_BASED_ON_SRC</param>
	<param name="ifnocmap">L_CLONE, L_COPY</param>
	<returns>pixd always a new pix; without colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRemoveColormap(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.REMOVE_CMAP)">
	<summary>
 Notes
 (1) If pixs does not have a colormap, a clone is returned.
 (2) Otherwise, the input pixs is restricted to 1, 2, 4 or 8 bpp.
 (3) Use REMOVE_CMAP_TO_BINARY only on 1 bpp pix.
 (4) For grayscale conversion from RGB, use a weighted average
 of RGB values, and always return an 8 bpp pix, regardless
 of whether the input pixs depth is 2, 4 or 8 bpp.
 (5) REMOVE_CMAP_TO_FULL_COLOR ignores the alpha component and
 returns a 32 bpp pix with spp == 3 and the alpha bytes are 0.
 (6) For REMOVE_CMAP_BASED_ON_SRC, if there is no color, this
 returns either a 1 bpp or 8 bpp grayscale pix.
 If there is color, this returns a 32 bpp pix, with either
 3 spp, if the alpha values are all 255 (opaque), or
 4 spp (preserving the alpha), if any alpha values are not 255.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">see restrictions below</param>
	<param name="type">REMOVE_CMAP_TO_BINARY, REMOVE_CMAP_TO_GRAYSCALE, REMOVE_CMAP_TO_FULL_COLOR, REMOVE_CMAP_WITH_ALPHA, REMOVE_CMAP_BASED_ON_SRC</param>
	<returns>pixd without colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddGrayColormap8(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If pixs has a colormap, this is a no-op.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddMinimalGrayColormap8(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This generates a colormapped version of the input image
 that has the same number of colormap entries as the
 input image has unique gray levels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToLuminance(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Use a standard luminance conversion.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<returns>8 bpp pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToGray(LeptonicaSharp.Pix,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) Use a weighted average of the RGB values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<param name="rwt">non-negative; these should add to 1.0, or use 0.0 for default</param>
	<param name="gwt">non-negative; these should add to 1.0, or use 0.0 for default</param>
	<param name="bwt">non-negative; these should add to 1.0, or use 0.0 for default</param>
	<returns>8 bpp pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToGrayFast(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This function should be used if speed of conversion
 is paramount, and the green channel can be used as
 a fair representative of the RGB intensity.  It is
 several times faster than pixConvertRGBToGray().
 (2) To combine RGB to gray conversion with subsampling,
 use pixScaleRGBToGrayFast() instead.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<returns>8 bpp pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToGrayMinMax(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_CHOOSE_M)">
	<summary>
 Notes
 (1) This chooses various components or combinations of them,
 from the three RGB sample values.  In addition to choosing
 the min, max, and maxdiff (difference between max and min),
 this also allows boosting the min and max about a reference
 value.
 (2) The default reference value for boosting the min and max
 is 200.  This can be changed with l_setNeutralBoostVal()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<param name="type">L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF, L_CHOOSE_MIN_BOOST, L_CHOOSE_MAX_BOOST</param>
	<returns>8 bpp pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToGraySatBoost(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This returns the max component value, boosted by
 the saturation. The maximum boost occurs where
 the maximum component value is equal to some reference value.
 This particular weighting is due to Dany Qumsiyeh.
 (2) For gray pixels (zero saturation), this returns
 the intensity of any component.
 (3) For fully saturated pixels ('fullsat'), this rises linearly
 with the max value and has a slope equal to 255 divided
 by the reference value; for a max value greater than
 the reference value, it is clipped to 255.
 (4) For saturation values in between, the output is a linear
 combination of (2) and (3), weighted by saturation.
 It falls between these two curves, and does not exceed 255.
 (5) This can be useful for distinguishing an object that has nonzero
 saturation from a gray background.  For this, the refval
 should be chosen near the expected value of the background,
 to achieve maximum saturation boost there.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="refval">between 1 and 255; typ. less than 128</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToGrayArb(LeptonicaSharp.Pix,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This converts to gray using an arbitrary linear combination
 of the rgb color components.  It differs from pixConvertToGray(),
 which uses only positive coefficients that sum to 1.
 (2) The gray output values are clipped to 0 and 255.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<param name="rc">arithmetic factors; can be negative</param>
	<param name="gc">arithmetic factors; can be negative</param>
	<param name="bc">arithmetic factors; can be negative</param>
	<returns>8 bpp pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToBinaryArb(LeptonicaSharp.Pix,System.Single,System.Single,System.Single,System.Int32,LeptonicaSharp.Enumerations.L_SELECT_IF)">
	<summary>
 Notes
 (1) This makes a 1 bpp mask from an RGB image, using an arbitrary
 linear combination of the rgb color components, along with
 a threshold and a selection choice of the gray value relative
 to %thresh.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<param name="rc">arithmetic factors; can be negative</param>
	<param name="gc">arithmetic factors; can be negative</param>
	<param name="bc">arithmetic factors; can be negative</param>
	<param name="thresh">binarization threshold</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns>1 bpp pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertGrayToColormap(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a simple interface for adding a colormap to a
 2, 4 or 8 bpp grayscale image without causing any
 quantization.  There is some similarity to operations
 in grayquant.c, such as pixThresholdOn8bpp(), where
 the emphasis is on quantization with an arbitrary number
 of levels, and a colormap is an option.
 (2) Returns a copy if pixs already has a colormap.
 (3) For 8 bpp src, this is a lossless transformation.
 (4) For 2 and 4 bpp src, this generates a colormap that
 assumes full coverage of the gray space, with equally spaced
 levels 4 levels for d = 2 and 16 levels for d = 4.
 (5) In all cases, the depth of the dest is the same as the src.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4 or 8 bpp grayscale</param>
	<returns>pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertGrayToColormap8(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Returns a copy if pixs already has a colormap.
 (2) This is a lossless transformation; there is no quantization.
 We compute the number of different gray values in pixs,
 and construct a colormap that has exactly these values.
 (3) 'mindepth' is the minimum depth of pixd.  If mindepth == 8,
 pixd will always be 8 bpp.  Let the number of different
 gray values in pixs be ngray.  If mindepth == 4, we attempt
 to save pixd as a 4 bpp image, but if ngray GT 16,
 pixd must be 8 bpp.  Likewise, if mindepth == 2,
 the depth of pixd will be 2 if ngray LT= 4 and 4 if ngray GT 4
 but LT= 16.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="mindepth">of pixd; valid values are 2, 4 and 8</param>
	<returns>pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixColorizeGray(LeptonicaSharp.Pix,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) This applies the specific color to the grayscale image.
 (2) If pixs already has a colormap, it is removed to gray
 before colorizing.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray; 2, 4 or 8 bpp colormapped</param>
	<param name="color">32 bit rgba pixel</param>
	<param name="cmapflag">1 for result to have colormap; 0 for RGB</param>
	<returns>pixd 8 bpp colormapped or 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertRGBToColormap(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This function has two relatively simple modes of color
 quantization
 (a) If the image is made orthographically and has not more
 than 256 'colors' at the level 4 octcube leaves,
 it is quantized nearly exactly.  The ditherflag
 is ignored.
 (b) Most natural images have more than 256 different colors;
 in that case we use adaptive octree quantization,
 with dithering if requested.
 (2) If there are not more than 256 occupied level 4 octcubes,
 the color in the colormap that represents all pixels in
 one of those octcubes is given by the first pixel that
 falls into that octcube.
 (3) If there are more than 256 colors, we use adaptive octree
 color quantization.
 (4) Dithering gives better visual results on images where
 there is a color wash (a slow variation of color), but it
 is about twice as slow and results in significantly larger
 files when losslessly compressed (e.g., into png).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="ditherflag">1 to dither, 0 otherwise</param>
	<returns>pixd 2, 4 or 8 bpp with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertCmapTo1(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is an extreme color quantizer.  It decides which
 colors map to FG (black) and which to BG (white).
 (2) This uses two heuristics to make the decision
 (a) colors similar to each other are likely to be in the same class
 (b) there is usually much less FG than BG.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">cmapped</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixQuantizeIfFewColors(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This is a wrapper that tests if the pix can be quantized
 with good quality using a small number of colors.  If so,
 it does the quantization, defining a colormap and using
 pixels whose value is an index into the colormap.
 (2) If the image has color, it is quantized with 8 bpp pixels.
 If the image is essentially grayscale, the pixels are
 either 4 or 8 bpp, depending on the size of the required
 colormap.
 (3) %octlevel = 4 generates a larger colormap and larger
 compressed image than %octlevel = 3.  If image quality is
 important, you should use %octlevel = 4.
 (4) If the image already has a colormap, it returns a clone.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp gray or 32 bpp rgb</param>
	<param name="maxcolors">max number of colors allowed to be returned from pixColorsForQuantization(); use 0 for default</param>
	<param name="mingraycolors">min number of gray levels that a grayscale image is quantized to; use 0 for default</param>
	<param name="octlevel">for octcube quantization 3 or 4</param>
	<param name="ppixd">2,4 or 8 bpp quantized; null if too many colors</param>
	<returns>0 if OK, 1 on error or if pixs can't be quantized into a small number of colors.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert16To8(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_16_bit_conversion)">
	<summary>
 Notes
 (1) With L_AUTO_BYTE, if the max pixel value is greater than 255,
 use the MSB; otherwise, use the LSB.
 (2) With L_CLIP_TO_FF, use min(pixel-value, 0xff) for each
 16-bit src pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">16 bpp</param>
	<param name="type">L_LS_BYTE, L_MS_BYTE, L_AUTO_BYTE, L_CLIP_TO_FF</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertGrayToFalseColor(LeptonicaSharp.Pix,System.Single)">
	<summary>
 Notes
 (1) For 8 bpp input, this simply adds a colormap to the input image.
 (2) For 16 bpp input, it first converts to 8 bpp, using the MSB,
 and then adds the colormap.
 (3) The colormap is modeled after the Matlab "jet" configuration.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 16 bpp grayscale</param>
	<param name="gamma">(factor) 0.0 or 1.0 for default; GT 1.0 for brighter; 2.0 is quite nice</param>
	<returns>pixd 8 bpp with colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixUnpackBinary(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This function calls special cases of pixConvert1To(),
 for 2, 4, 8, 16 and 32 bpp destinations.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="depth">of destination 2, 4, 8, 16 or 32 bpp</param>
	<param name="invert">0  binary 0 --GT grayscale 0 binary 1 --GT grayscale 0xff... 1  binary 0 --GT grayscale 0xff... binary 1 --GT grayscale 0</param>
	<returns>pixd 2, 4, 8, 16 or 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert1To16(LeptonicaSharp.Pix,System.UInt16,System.UInt16,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If pixd is null, a new pix is made.
 (2) If pixd is not null, it must be of equal width and height
 as pixs.  It is always returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">16 bpp, can be null</param>
	<param name="pixs">1 bpp</param>
	<param name="val0">16 bit value to be used for 0s in pixs</param>
	<param name="val1">16 bit value to be used for 1s in pixs</param>
	<returns>pixd 16 bpp</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert1To32(LeptonicaSharp.Pix,System.UInt32,System.UInt32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If pixd is null, a new pix is made.
 (2) If pixd is not null, it must be of equal width and height
 as pixs.  It is always returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp, can be null</param>
	<param name="pixs">1 bpp</param>
	<param name="val0">32 bit value to be used for 0s in pixs</param>
	<param name="val1">32 bit value to be used for 1s in pixs</param>
	<returns>pixd 32 bpp</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert1To2Cmap(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 2 bpp, cmapped</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert1To2(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If pixd is null, a new pix is made.
 (2) If pixd is not null, it must be of equal width and height
 as pixs.  It is always returned.
 (3) A simple unpacking might use val0 = 0 and val1 = 3.
 (4) If you want a colormapped pixd, use pixConvert1To2Cmap().
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">2 bpp, can be null</param>
	<param name="pixs">1 bpp</param>
	<param name="val0">2 bit value to be used for 0s in pixs</param>
	<param name="val1">2 bit value to be used for 1s in pixs</param>
	<returns>pixd 2 bpp</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert1To4Cmap(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 4 bpp, cmapped</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert1To4(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If pixd is null, a new pix is made.
 (2) If pixd is not null, it must be of equal width and height
 as pixs.  It is always returned.
 (3) A simple unpacking might use val0 = 0 and val1 = 15, or v.v.
 (4) If you want a colormapped pixd, use pixConvert1To4Cmap().
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">4 bpp, can be null</param>
	<param name="pixs">1 bpp</param>
	<param name="val0">4 bit value to be used for 0s in pixs</param>
	<param name="val1">4 bit value to be used for 1s in pixs</param>
	<returns>pixd 4 bpp</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert1To8Cmap(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, cmapped</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert1To8(LeptonicaSharp.Pix,System.Byte,System.Byte,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If pixd is null, a new pix is made.
 (2) If pixd is not null, it must be of equal width and height
 as pixs.  It is always returned.
 (3) A simple unpacking might use val0 = 0 and val1 = 255, or v.v.
 (4) To have a colormap associated with the 8 bpp pixd,
 use pixConvert1To8Cmap().
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">8 bpp, can be null</param>
	<param name="pixs">1 bpp</param>
	<param name="val0">8 bit value to be used for 0s in pixs</param>
	<param name="val1">8 bit value to be used for 1s in pixs</param>
	<returns>pixd 8 bpp</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert2To8(LeptonicaSharp.Pix,System.Byte,System.Byte,System.Byte,System.Byte,System.Int32)">
	<summary>
 Notes
 ~ A simple unpacking might use val0 = 0,
 val1 = 85 (0x55), val2 = 170 (0xaa), val3 = 255.
 ~ If cmapflag is TRUE
 ~ The 8 bpp image is made with a colormap.
 ~ If pixs has a colormap, the input values are ignored and
 the 8 bpp image is made using the colormap
 ~ If pixs does not have a colormap, the input values are
 used to build the colormap.
 ~ If cmapflag is FALSE
 ~ The 8 bpp image is made without a colormap.
 ~ If pixs has a colormap, the input values are ignored,
 the colormap is removed, and the values stored in the 8 bpp
 image are from the colormap.
 ~ If pixs does not have a colormap, the input values are
 used to populate the 8 bpp image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2 bpp</param>
	<param name="val0">8 bit value to be used for 00 in pixs</param>
	<param name="val1">8 bit value to be used for 01 in pixs</param>
	<param name="val2">8 bit value to be used for 10 in pixs</param>
	<param name="val3">8 bit value to be used for 11 in pixs</param>
	<param name="cmapflag">TRUE if pixd is to have a colormap; FALSE otherwise</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert4To8(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 ~ If cmapflag is TRUE
 ~ pixd is made with a colormap.
 ~ If pixs has a colormap, it is copied and the colormap
 index values are placed in pixd.
 ~ If pixs does not have a colormap, a colormap with linear
 trc is built and the pixel values in pixs are placed in
 pixd as colormap index values.
 ~ If cmapflag is FALSE
 ~ pixd is made without a colormap.
 ~ If pixs has a colormap, it is removed and the values stored
 in pixd are from the colormap (converted to gray).
 ~ If pixs does not have a colormap, the pixel values in pixs
 are used, with shift replication, to populate pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">4 bpp</param>
	<param name="cmapflag">TRUE if pixd is to have a colormap; FALSE otherwise</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert8To16(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) For left shift of 8, the 8 bit value is replicated in both
 the MSB and the LSB of the pixels in pixd.  That way, we get
 proportional mapping, with a correct map from 8 bpp white
 (0xff) to 16 bpp white (0xffff).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; colormap removed to gray</param>
	<param name="leftshift">number of bits 0 is no shift; 8 replicates in MSB and LSB of dest</param>
	<returns>pixd 16 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertTo2(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a top-level function, with simple default values
 used in pixConvertTo8() if unpacking is necessary.
 (2) Any existing colormap is removed; the result is always gray.
 (3) If the input image has 2 bpp and no colormap, the operation is
 lossless and a copy is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp; colormap OK but will be removed</param>
	<returns>pixd   2 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert8To2(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Any existing colormap is removed to gray.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; colormap OK</param>
	<returns>pixd  2 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertTo4(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a top-level function, with simple default values
 used in pixConvertTo8() if unpacking is necessary.
 (2) Any existing colormap is removed; the result is always gray.
 (3) If the input image has 4 bpp and no colormap, the operation is
 lossless and a copy is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp; colormap OK but will be removed</param>
	<returns>pixd   4 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert8To4(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Any existing colormap is removed to gray.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">8 bpp; colormap OK</param>
	<returns>pixd  4 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertTo1(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This is a top-level function, with simple default values
 used in pixConvertTo8() if unpacking is necessary.
 (2) Any existing colormap is removed.
 (3) If the input image has 1 bpp and no colormap, the operation is
 lossless and a copy is returned.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="threshold">for final binarization, relative to 8 bpp</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertTo1BySampling(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a quick and dirty, top-level converter.
 (2) See pixConvertTo1() for default values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="factor">submsampling factor; integer GT= 1</param>
	<param name="threshold">for final binarization, relative to 8 bpp</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertTo8(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This is a top-level function, with simple default values
 for unpacking.
 (2) The result, pixd, is made with a colormap if specified.
 It is always a new image -- never a clone.  For example,
 if d == 8, and cmapflag matches the existence of a cmap
 in pixs, the operation is lossless and it returns a copy.
 (3) The default values used are
 ~ 1 bpp val0 = 255, val1 = 0
 ~ 2 bpp 4 bpp  even increments over dynamic range
 ~ 8 bpp lossless if cmap matches cmapflag
 ~ 16 bpp use most significant byte
 (4) If 32 bpp RGB, this is converted to gray.  If you want
 to do color quantization, you must specify the type
 explicitly, using the color quantization code.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="cmapflag">TRUE if pixd is to have a colormap; FALSE otherwise</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertTo8BySampling(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a fast, quick/dirty, top-level converter.
 (2) See pixConvertTo8() for default values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="factor">submsampling factor; integer GT= 1</param>
	<param name="cmapflag">TRUE if pixd is to have a colormap; FALSE otherwise</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertTo8Colormap(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This is a top-level function, with simple default values
 for unpacking.
 (2) The result, pixd, is always made with a colormap.
 (3) If d == 8, the operation is lossless and it returns a copy.
 (4) The default values used for increasing depth are
 ~ 1 bpp val0 = 255, val1 = 0
 ~ 2 bpp 4 bpp  even increments over dynamic range
 (5) For 16 bpp, use the most significant byte.
 (6) For 32 bpp RGB, use octcube quantization with optional dithering.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="dither">1 to dither if necessary; 0 otherwise</param>
	<returns>pixd 8 bpp, cmapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertTo16(LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 bpp</param>
	<returns>pixd 16 bpp, or NULL on error Usage Top-level function, with simple default values for unpacking. 1 bpp  val0 = 0xffff, val1 = 0 8 bpp  replicates the 8 bit value in both the MSB and LSB of the 16 bit pixel.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertTo32(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Never returns a clone of pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<returns>pixd 32 bpp, or NULL on error Usage Top-level function, with simple default values for unpacking. 1 bpp  val0 = 255, val1 = 0 and then replication into R, G and B components 2 bpp  if colormapped, use the colormap values; otherwise, use val0 = 0, val1 = 0x55, val2 = 0xaa, val3 = 255 and replicate gray into R, G and B components 4 bpp  if colormapped, use the colormap values; otherwise, replicate 2 nybs into a byte, and then into R,G,B components 8 bpp  if colormapped, use the colormap values; otherwise, replicate gray values into R, G and B components 16 bpp replicate MSB into R, G and B components 24 bpp unpack the pixels, maintaining word alignment on each scanline 32 bpp makes a copy</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertTo32BySampling(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This is a fast, quick/dirty, top-level converter.
 (2) See pixConvertTo32() for default values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="factor">submsampling factor; integer GT= 1</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert8To32(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) If there is no colormap, replicates the gray value
 into the 3 MSB of the dest pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<returns>32 bpp rgb pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertTo8Or32(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_access_storage,System.Int32)">
	<summary>
 Notes
 (1) If there is a colormap, the colormap is removed to 8 or 32 bpp,
 depending on whether the colors in the colormap are all gray.
 (2) If the input is either rgb or 8 bpp without a colormap,
 this returns either a clone or a copy, depending on %copyflag.
 (3) Otherwise, the pix is converted to 8 bpp grayscale.
 In all cases, pixd does not have a colormap.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, with or without colormap; or 32 bpp rgb</param>
	<param name="copyflag">L_CLONE or L_COPY</param>
	<param name="warnflag">1 to issue warning if colormap is removed; else 0</param>
	<returns>pixd 8 bpp grayscale or 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert24To32(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) 24 bpp rgb pix are not supported in leptonica, except for a small
 number of formatted write operations.  The data is a byte array,
 with pixels in order r,g,b, and padded to 32 bit boundaries
 in each line.
 (2) Because 24 bpp rgb pix are conveniently generated by programs
 such as xpdf (which has SplashBitmaps that store the raster
 data in consecutive 24-bit rgb pixels), it is useful to provide
 24 bpp pix that simply incorporate that data.  The only things
 we can do with these are
 (a) write them to file in png, jpeg, tiff and pnm
 (b) interconvert between 24 and 32 bpp in memory (for testing).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">24 bpp rgb</param>
	<returns>pixd 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert32To24(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See pixconvert24To32().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<returns>pixd 24 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert32To16(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_16_bit_conversion)">
	<summary>
 Notes
 (1) The data in pixs is typically used for labelling.
 It is an array of l_uint32 values, not rgb or rgba.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, single component</param>
	<param name="type">L_LS_TWO_BYTES, L_MS_TWO_BYTES, L_CLIP_TO_FFFF</param>
	<returns>pixd 16 bpp , or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvert32To8(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_16_bit_conversion,LeptonicaSharp.Enumerations.L_16_bit_conversion)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, single component</param>
	<param name="type16">L_LS_TWO_BYTES, L_MS_TWO_BYTES, L_CLIP_TO_FFFF</param>
	<param name="type8">L_LS_BYTE, L_MS_BYTE, L_CLIP_TO_FF</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRemoveAlpha(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a wrapper on pixAlphaBlendUniform()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<returns>pixd        if 32 bpp rgba, pixs blended over a white background; a clone of pixs otherwise, and NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddAlphaTo1bpp(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) We don't use 1 bpp colormapped images with alpha in leptonica,
 but we support generating them (here), writing to png, and reading
 the png.  On reading, they are converted to 32 bpp RGBA.
 (2) The background (0) pixels in pixs become fully transparent, and the
 foreground (1) pixels are fully opaque.  Thus, pixd is a 1 bpp
 representation of a stencil, that can be used to paint over pixels
 of a backing image that are masked by the foreground in pixs.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">1 bpp, can be null or equal to pixs</param>
	<param name="pixs">1 bpp</param>
	<returns>pixd 1 bpp with colormap and non-opaque alpha, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertLossless(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This is a lossless unpacking (depth-increasing)
 conversion.  If ds is the depth of pixs, then
 ~ if d LT ds, returns NULL
 ~ if d == ds, returns a copy
 ~ if d GT ds, does the unpacking conversion
 (2) If pixs has a colormap, this is an error.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8 bpp, not cmapped</param>
	<param name="d">destination depth 2, 4 or 8</param>
	<returns>pixd 2, 4 or 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertForPSWrap(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) For wrapping in PostScript, we convert pixs to
 1 bpp, 8 bpp (gray) and 32 bpp (RGB color).
 (2) Colormaps are removed.  For pixs with colormaps, the
 images are converted to either 8 bpp gray or 32 bpp
 RGB, depending on whether the colormap has color content.
 (3) Images without colormaps, that are not 1 bpp or 32 bpp,
 are converted to 8 bpp gray.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp</param>
	<returns>pixd    1, 8, or 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertToSubpixelRGB(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_SUBPIXEL_ORDER,System.Single,System.Single)">
	<summary>
 Notes
 (1) If pixs has a colormap, it is removed based on its contents
 to either 8 bpp gray or rgb.
 (2) For horizontal subpixel splitting, the input image
 is rescaled by %scaley vertically and by 3.0 times
 %scalex horizontally.  Then each horizontal triplet
 of pixels is mapped back to a single rgb pixel, with the
 r, g and b values being assigned based on the pixel triplet.
 For gray triplets, the r, g, and b values are set equal to
 the three gray values.  For color triplets, the r, g and b
 values are set equal to the components from the appropriate
 subpixel.  Vertical subpixel splitting is handled similarly.
 (3) See pixConvertGrayToSubpixelRGB() and
 pixConvertColorToSubpixelRGB() for further details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, 32 bpp rgb, or colormapped</param>
	<param name="scalex">anisotropic scaling permitted between source and destination</param>
	<param name="scaley">anisotropic scaling permitted between source and destination</param>
	<param name="order">of subpixel rgb color components in composition of pixd L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR, L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertGrayToSubpixelRGB(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_SUBPIXEL_ORDER,System.Single,System.Single)">
	<summary>
 Notes
 (1) If pixs has a colormap, it is removed to 8 bpp.
 (2) For horizontal subpixel splitting, the input gray image
 is rescaled by %scaley vertically and by 3.0 times
 %scalex horizontally.  Then each horizontal triplet
 of pixels is mapped back to a single rgb pixel, with the
 r, g and b values being assigned from the triplet of gray values.
 Similar operations are used for vertical subpixel splitting.
 (3) This is a form of subpixel rendering that tends to give the
 resulting text a sharper and somewhat chromatic display.
 For horizontal subpixel splitting, the observable difference
 between %order=L_SUBPIXEL_ORDER_RGB and
 %order=L_SUBPIXEL_ORDER_BGR is reduced by optical diffusers
 in the display that make the pixel color appear to emerge
 from the entire pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp or colormapped</param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<param name="order">of subpixel rgb color components in composition of pixd L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR, L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConvertColorToSubpixelRGB(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_SUBPIXEL_ORDER,System.Single,System.Single)">
	<summary>
 Notes
 (1) If pixs has a colormap, it is removed to 32 bpp rgb.
 If the colormap has no color, pixConvertGrayToSubpixelRGB()
 should be called instead, because it will give the same result
 more efficiently.  The function pixConvertToSubpixelRGB()
 will do the best thing for all cases.
 (2) For horizontal subpixel splitting, the input rgb image
 is rescaled by %scaley vertically and by 3.0 times
 %scalex horizontally.  Then for each horizontal triplet
 of pixels, the r component of the final pixel is selected
 from the r component of the appropriate pixel in the triplet,
 and likewise for g and b.  Vertical subpixel splitting is
 handled similarly.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp or colormapped</param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<param name="order">of subpixel rgb color components in composition of pixd L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR, L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_setNeutralBoostVal(System.Int32)">
	<summary>
 Notes
 (1) This raises or lowers the selected min or max RGB component value,
 depending on if that component is above or below this value.
 </summary>
	<remarks>
	</remarks>
	<param name="val">between 1 and 255; typical value is 180</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConnCompTransform(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) pixd is 8, 16 or 32 bpp, and the pixel values label the
 fg component, starting with 1.  Pixels in the bg are labelled 0.
 (2) If %depth = 0, the depth of pixd is 8 if the number of c.c.
 is less than 254, 16 if the number of c.c is less than 0xfffe,
 and 32 otherwise.
 (3) If %depth = 8, the assigned label for the n-th component is
 1 + n % 254.  We use mod 254 because 0 is uniquely assigned
 to black e.g., see pixcmapCreateRandom().  Likewise,
 if %depth = 16, the assigned label uses mod(2^16 - 2), and
 if %depth = 32, no mod is taken.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connect">connectivity 4 or 8</param>
	<param name="depth">of pixd 8 or 16 bpp; use 0 for auto determination</param>
	<returns>pixd 8, 16 or 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConnCompAreaTransform(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) The pixel values in pixd label the area of the fg component
 to which the pixel belongs.  Pixels in the bg are labelled 0.
 (2) For purposes of visualization, the output can be converted
 to 8 bpp, using pixConvert32To8() or pixMaxDynamicRange().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connect">connectivity 4 or 8</param>
	<returns>pixd 32 bpp, 1 spp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConnCompIncrInit(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Ptaa@,System.Int32@)">
	<summary>
 Notes
 (1) This labels the connected components in a 1 bpp pix, and
 additionally sets up a ptaa that lists the locations of pixels
 in each of the components.
 (2) It can be used to initialize the output image and arrays for
 an application that maintains information about connected
 components incrementally as pixels are added.
 (3) pixs can be empty or have some foreground pixels.
 (4) The connectivity is stored in pixd-GTspecial.
 (5) Always initialize with the first pta in ptaa being empty
 and representing the background value (index 0) in the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="conn">connectivity 4 or 8</param>
	<param name="ppixd">32 bpp, with c.c. labelled</param>
	<param name="pptaa">with pixel locations indexed by c.c.</param>
	<param name="pncc">initial number of c.c.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixConnCompIncrAdd(LeptonicaSharp.Pix,LeptonicaSharp.Ptaa,System.Int32@,System.Single,System.Single@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This adds a pixel and updates the labeled connected components.
 Before calling this function, initialize the process using
 pixConnCompIncrInit().
 (2) As a result of adding a pixel, one of the following can happen,
 depending on the number of neighbors with non-zero value
 (a) nothing the pixel is already a member of a c.c.
 (b) no neighbors a new component is added, increasing the
 number of c.c.
 (c) one neighbor the pixel is added to an existing c.c.
 (d) more than one neighbor the added pixel causes joining of
 two or more c.c., reducing the number of c.c.  A maximum
 of 4 c.c. can be joined.
 (3) When two c.c. are joined, the pixels in the larger index are
 relabeled to those of the smaller in pixs, and their locations
 are transferred to the pta with the smaller index in the ptaa.
 The pta corresponding to the larger index is then deleted.
 (4) This is an efficient implementation of a "union-find" operation,
 which supports the generation and merging of disjoint sets
 of pixels.  This function can be called about 1.3 million times
 per second.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, with pixels labeled by c.c.</param>
	<param name="ptaa">with each pta of pixel locations indexed by c.c.</param>
	<param name="pncc">number of c.c</param>
	<param name="x">,y location of added pixel</param>
	<param name="debug">0 for no output; otherwise output whenever debug LT= nvals, up to debug == 3</param>
	<returns>-1 if nothing happens; 0 if a pixel is added; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetSortedNeighborValues(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Collections.Generic.List{System.Int32[]}@,System.Int32@)">
	<summary>
 Notes
 (1) The returned %neigh array is the unique set of neighboring
 pixel values, of size nvals, sorted from smallest to largest.
 The value 0, which represents background pixels that do
 not belong to any set of connected components, is discarded.
 (2) If there are no neighbors, this returns %neigh = NULL; otherwise,
 the caller must free the array.
 (3) For either 4 or 8 connectivity, the maximum number of unique
 neighbor values is 4.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8, 16 or 32 bpp, with pixels labeled by c.c.</param>
	<param name="x">location of pixel</param>
	<param name="y">location of pixel</param>
	<param name="conn">4 or 8 connected neighbors</param>
	<param name="pneigh">array of integers, to be filled with the values of the neighbors, if any</param>
	<param name="pnvals">the number of unique neighbor values found</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixLocToColorTransform(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This generates an RGB image where each component value
 is coded depending on the (x.y) location and the size
 of the fg connected component that the pixel in pixs belongs to.
 It is independent of the 4-fold orthogonal orientation, and
 only weakly depends on translations and small angle rotations.
 Background pixels are black.
 (2) Such encodings can be compared between two 1 bpp images
 by performing this transform and calculating the
 "earth-mover" distance on the resulting R,G,B histograms.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTilingCreate(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) We put a clone of pixs in the PixTiling.
 (2) The input to pixTilingCreate() for horizontal tiling can be
 either the number of tiles across the image or the approximate
 width of the tiles.  If the latter, the actual width will be
 determined by making all tiles but the last of equal width, and
 making the last as close to the others as possible.  The same
 consideration is applied independently to the vertical tiling.
 To specify tile width, set nx = 0; to specify the number of
 tiles horizontally across the image, set w = 0.
 (3) If pixs is to be tiled in one-dimensional strips, use ny = 1 for
 vertical strips and nx = 1 for horizontal strips.
 (4) The overlap must not be larger than the width or height of
 the leftmost or topmost tile(s).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">pix to be tiled; any depth; colormap OK</param>
	<param name="nx">number of tiles across image</param>
	<param name="ny">number of tiles down image</param>
	<param name="w">desired width of each tile</param>
	<param name="h">desired height of each tile</param>
	<param name="xoverlap">overlap into neighboring tiles on each side</param>
	<param name="yoverlap">overlap into neighboring tiles above and below</param>
	<returns>pixtiling, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTilingDestroy(LeptonicaSharp.PixTiling@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ppt">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTilingGetCount(LeptonicaSharp.PixTiling,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pt">pixtiling</param>
	<param name="pnx">nx; can be null</param>
	<param name="pny">ny; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTilingGetSize(LeptonicaSharp.PixTiling,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pt">pixtiling</param>
	<param name="pw">tile width; can be null</param>
	<param name="ph">tile height; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTilingGetTile(LeptonicaSharp.PixTiling,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pt">pixtiling</param>
	<param name="i">tile row index</param>
	<param name="j">tile column index</param>
	<returns>pixd tile with appropriate boundary (overlap) pixels added, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTilingNoStripOnPaint(LeptonicaSharp.PixTiling)">
	<summary>
 Notes
 (1) The default for paint is to strip out the overlap pixels
 that are added by pixTilingGetTile().  However, some
 operations will generate an image with these pixels
 stripped off.  This tells the paint operation not
 to strip the added boundary pixels when painting.
 </summary>
	<remarks>
	</remarks>
	<param name="pt">pixtiling</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTilingPaintTile(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.PixTiling)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd">dest paint tile onto this, without overlap</param>
	<param name="i">tile row index</param>
	<param name="j">tile column index</param>
	<param name="pixs">source tile to be painted from</param>
	<param name="pt">pixtiling struct</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadStreamPng(LeptonicaSharp.FILE)">
	<summary>
 Notes
 (1) If called from pixReadStream(), the stream is positioned
 at the beginning of the file.
 (2) To do sequential reads of png format images from a stream,
 use pixReadStreamPng()
 (3) Any image with alpha is converted to RGBA (spp = 4, with
 equal red, green and blue channels) on reading.
 There are three important cases with alpha
 (a) grayscale-with-alpha (spp = 2), where bpp = 8, and each
 pixel has an associated alpha (transparency) value
 in the second component of the image data.
 (b) spp = 1, d = 1 with colormap and alpha in the trans array.
 Transparency is usually associated with the white background.
 (c) spp = 1, d = 8 with colormap and alpha in the trans array.
 Each color in the colormap has a separate transparency value.
 (4) We use the high level png interface, where the transforms are set
 up in advance and the header and image are read with a single
 call.  The more complicated interface, where the header is
 read first and the buffers for the raster image are user-
 allocated before reading the image, works for single images,
 but I could not get it to work properly for the successive
 png reads that are required by pixaReadStream().
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readHeaderPng(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If there is a colormap, iscmap is returned as 1; else 0.
 (2) For gray+alpha, although the png records bps = 16, we
 consider this as two 8 bpp samples (gray and alpha).
 When a gray+alpha is read, it is converted to 32 bpp RGBA.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<param name="piscmap"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.freadHeaderPng(LeptonicaSharp.FILE,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) See readHeaderPng().  We only need the first 40 bytes in the file.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<param name="piscmap"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readHeaderMemPng(System.Byte[],System.UInt32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) See readHeaderPng().
 (2) png colortypes (see png.h PNG_COLOR_TYPE_)
 0  gray; fully transparent (with tRNS) (1 spp)
 2  RGB (3 spp)
 3  colormap; colormap+alpha (with tRNS) (1 spp)
 4  gray + alpha (2 spp)
 6  RGBA (4 spp)
 Note
 0 and 3 have the alpha information in a tRNS chunk
 4 and 6 have separate alpha samples with each pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="data"></param>
	<param name="size">40 bytes is sufficient</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<param name="piscmap">input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fgetPngResolution(LeptonicaSharp.FILE@,System.Object@,System.Object@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.isPngInterlaced(System.String,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pinterlaced">1 if interlaced png; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fgetPngColormapInfo(LeptonicaSharp.FILE@,LeptonicaSharp.PixColormap@,System.Object@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWritePng(System.String,LeptonicaSharp.Pix,System.Single)">
	<summary>
 Notes
 (1) Special version for writing png with a specified gamma.
 When using pixWrite(), no field is given for gamma.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pix"></param>
	<param name="gamma"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamPng(LeptonicaSharp.FILE,LeptonicaSharp.Pix,System.Single)">
	<summary>
 Notes
 (1) If called from pixWriteStream(), the stream is positioned
 at the beginning of the file.
 (2) To do sequential writes of png format images to a stream,
 use pixWriteStreamPng() directly.
 (3) gamma is an optional png chunk.  If no gamma value is to be
 placed into the file, use gamma = 0.0.  Otherwise, if
 gamma GT 0.0, its value is written into the header.
 (4) The use of gamma in png is highly problematic.  For an illuminating
 discussion, see  http//hsivonen.iki.fi/png-gamma/
 (5) What is the effect/meaning of gamma in the png file?  This
 gamma, which we can call the 'source' gamma, is the
 inverse of the gamma that was used in enhance.c to brighten
 or darken images.  The 'source' gamma is supposed to indicate
 the intensity mapping that was done at the time the
 image was captured.  Display programs typically apply a
 'display' gamma of 2.2 to the output, which is intended
 to linearize the intensity based on the response of
 thermionic tubes (CRTs).  Flat panel LCDs have typically
 been designed to give a similar response as CRTs (call it
 "backward compatibility").  The 'display' gamma is
 in some sense the inverse of the 'source' gamma.
 jpeg encoders attached to scanners and cameras will lighten
 the pixels, applying a gamma corresponding to approximately
 a square-root relation of output vs input
 output = input^(gamma)
 where gamma is often set near 0.4545  (1/gamma is 2.2).
 This is stored in the image file.  Then if the display
 program reads the gamma, it will apply a display gamma,
 typically about 2.2; the product is 1.0, and the
 display program produces a linear output.  This works because
 the dark colors were appropriately boosted by the scanner,
 as described by the 'source' gamma, so they should not
 be further boosted by the display program.
 (6) As an example, with xv and display, if no gamma is stored,
 the program acts as if gamma were 0.4545, multiplies this by 2.2,
 and does a linear rendering.  Taking this as a baseline
 brightness, if the stored gamma is
 GT 0.4545, the image is rendered lighter than baseline
 LT 0.4545, the image is rendered darker than baseline
 In contrast, gqview seems to ignore the gamma chunk in png.
 (7) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16
 and 32.  However, it is possible, and in some cases desirable,
 to write out a png file using an rgb pix that has 24 bpp.
 For example, the open source xpdf SplashBitmap class generates
 24 bpp rgb images.  Consequently, we enable writing 24 bpp pix.
 To generate such a pix, you can make a 24 bpp pix without data
 and assign the data array to the pix; e.g.,
 pix = pixCreateHeader(w, h, 24);
 pixSetData(pix, rgbdata);
 See pixConvert32To24() for an example, where we get rgbdata
 from the 32 bpp pix.  Caution do not call pixSetPadBits(),
 because the alignment is wrong and you may erase part of the
 last pixel on each line.
 (8) If the pix has a colormap, it is written to file.  In most
 situations, the alpha component is 255 for each colormap entry,
 which is opaque and indicates that it should be ignored.
 However, if any alpha component is not 255, it is assumed that
 the alpha values are valid, and they are written to the png
 file in a tRNS segment.  On readback, the tRNS segment is
 identified, and the colormapped image with alpha is converted
 to a 4 spp rgba image.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix"></param>
	<param name="gamma">use 0.0 if gamma is not defined</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetZlibCompression(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Valid zlib compression values are in the interval [0 ... 9],
 where, as defined in zlib.h
 0   Z_NO_COMPRESSION
 1   Z_BEST_SPEED (poorest compression)
 9   Z_BEST_COMPRESSION
 For the default value, use either of these
 6   Z_DEFAULT_COMPRESSION
 -1   (resolves to Z_DEFAULT_COMPRESSION)
 (2) If you use the defined constants in zlib.h instead of the
 compression integers given above, you must include zlib.h.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="compval">zlib compression value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_pngSetReadStrip16To8(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="flag">1 for stripping 16 bpp to 8 bpp on reading; 0 for leaving 16 bpp</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadMemPng(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) See pixReastreamPng().
 </summary>
	<remarks>
	</remarks>
	<param name="filedata">png compressed data in memory</param>
	<param name="filesize">number of bytes in data</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMemPng(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pix,System.Single)">
	<summary>
 Notes
 (1) See pixWriteStreamPng()
 </summary>
	<remarks>
	</remarks>
	<param name="pfiledata">png encoded data of pix</param>
	<param name="pfilesize">size of png encoded data</param>
	<param name="pix"></param>
	<param name="gamma">use 0.0 if gamma is not defined</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadStreamPnm(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for read</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readHeaderPnm(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pd"></param>
	<param name="ptype">pnm type</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.freadHeaderPnm(LeptonicaSharp.FILE,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for read</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pd"></param>
	<param name="ptype">pnm type</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamPnm(LeptonicaSharp.FILE,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This writes "raw" packed format only
 1 bpp --GT pbm (P4)
 2, 4, 8, 16 bpp, no colormap or grayscale colormap --GT pgm (P5)
 2, 4, 8 bpp with color-valued colormap, or rgb --GT rgb ppm (P6)
 (2) 24 bpp rgb are not supported in leptonica, but this will
 write them out as a packed array of bytes (3 to a pixel).
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for write</param>
	<param name="pix"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamAsciiPnm(LeptonicaSharp.FILE,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for write</param>
	<param name="pix"></param>
	<returns>0 if OK; 1 on error Writes "ASCII" format only 1 bpp --GT pbm P1 2, 4, 8, 16 bpp, no colormap or grayscale colormap --GT pgm P2 2, 4, 8 bpp with color-valued colormap, or rgb --GT rgb ppm P3</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamPam(LeptonicaSharp.FILE,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This writes arbitrary PAM (P7) packed format.
 (2) 24 bpp rgb are not supported in leptonica, but this will
 write them out as a packed array of bytes (3 to a pixel).
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for write</param>
	<param name="pix"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadMemPnm(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) The %size byte of %data must be a null character.
 </summary>
	<remarks>
	</remarks>
	<param name="data">const; pnm-encoded</param>
	<param name="size">of data</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readHeaderMemPnm(System.Byte[],System.UInt32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">const; pnm-encoded</param>
	<param name="size">of data</param>
	<param name="pw"></param>
	<param name="ph"></param>
	<param name="pd"></param>
	<param name="ptype">pnm type</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMemPnm(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See pixWriteStreamPnm() for usage.  This version writes to
 memory instead of to a file stream.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of PNM image</param>
	<param name="psize">size of returned data</param>
	<param name="pix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMemPam(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See pixWriteStreamPnm() for usage.  This version writes to
 memory instead of to a file stream.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of PAM image</param>
	<param name="psize">size of returned data</param>
	<param name="pix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixProjectiveSampledPta(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary.
 (2) Retains colormap, which you can do for a sampled transform..
 (3) No 3 of the 4 points may be collinear.
 (4) For 8 and 32 bpp pix, better quality is obtained by the
 somewhat slower pixProjectivePta().  See that
 function for relative timings between sampled and interpolated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixProjectiveSampled(LeptonicaSharp.Pix,System.Single[],LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary.
 (2) Retains colormap, which you can do for a sampled transform..
 (3) For 8 or 32 bpp, much better quality is obtained by the
 somewhat slower pixProjective().  See that function
 for relative timings between sampled and interpolated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="vc">vector of 8 coefficients for projective transformation</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixProjectivePta(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary
 (2) Removes any existing colormap, if necessary, before transforming
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixProjective(LeptonicaSharp.Pix,System.Single[],LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Brings in either black or white pixels from the boundary
 (2) Removes any existing colormap, if necessary, before transforming
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; colormap ok</param>
	<param name="vc">vector of 8 coefficients for projective transformation</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixProjectivePtaColor(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixProjectiveColor(LeptonicaSharp.Pix,System.Single[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="vc">vector of 8 coefficients for projective transformation</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixProjectivePtaGray(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixProjectiveGray(LeptonicaSharp.Pix,System.Single[],System.Byte)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="vc">vector of 8 coefficients for projective transformation</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixProjectivePtaWithAlpha(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.Single,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The alpha channel is transformed separately from pixs,
 and aligns with it, being fully transparent outside the
 boundary of the transformed pixs.  For pixels that are fully
 transparent, a blending function like pixBlendWithGrayMask()
 will give zero weight to corresponding pixels in pixs.
 (2) If pixg is NULL, it is generated as an alpha layer that is
 partially opaque, using %fract.  Otherwise, it is cropped
 to pixs if required and %fract is ignored.  The alpha channel
 in pixs is never used.
 (3) Colormaps are removed.
 (4) When pixs is transformed, it doesn't matter what color is brought
 in because the alpha channel will be transparent (0) there.
 (5) To avoid losing source pixels in the destination, it may be
 necessary to add a border to the source pix before doing
 the projective transformation.  This can be any non-negative
 number.
 (6) The input %ptad and %ptas are in a coordinate space before
 the border is added.  Internally, we compensate for this
 before doing the projective transform on the image after
 the border is added.
 (7) The default setting for the border values in the alpha channel
 is 0 (transparent) for the outermost ring of pixels and
 (0.5  fract  255) for the second ring.  When blended over
 a second image, this
 (a) shrinks the visible image to make a clean overlap edge
 with an image below, and
 (b) softens the edges by weakening the aliasing there.
 Use l_setAlphaMaskBorder() to change these values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="ptad">4 pts of final coordinate space</param>
	<param name="ptas">4 pts of initial coordinate space</param>
	<param name="pixg">8 bpp, for alpha channel, can be null</param>
	<param name="fract">between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	<param name="border">of pixels added to capture transformed source pixels</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getProjectiveXformCoeffs(LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.Collections.Generic.List{System.Single[]}@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas">source 4 points; unprimed</param>
	<param name="ptad">transformed 4 points; primed</param>
	<param name="pvc">vector of coefficients of transform</param>
	<returns>0 if OK; 1 on error We have a set of 8 equations, describing the projective transformation that takes 4 points ptas into 4 other points ptad.  These equations are x1' = c[0]x1 + c[1]y1 + c[2]) / (c[6]x1 + c[7]y1 + 1 y1' = c[3]x1 + c[4]y1 + c[5]) / (c[6]x1 + c[7]y1 + 1 x2' = c[0]x2 + c[1]y2 + c[2]) / (c[6]x2 + c[7]y2 + 1 y2' = c[3]x2 + c[4]y2 + c[5]) / (c[6]x2 + c[7]y2 + 1 x3' = c[0]x3 + c[1]y3 + c[2]) / (c[6]x3 + c[7]y3 + 1 y3' = c[3]x3 + c[4]y3 + c[5]) / (c[6]x3 + c[7]y3 + 1 x4' = c[0]x4 + c[1]y4 + c[2]) / (c[6]x4 + c[7]y4 + 1 y4' = c[3]x4 + c[4]y4 + c[5]) / (c[6]x4 + c[7]y4 + 1 Multiplying both sides of each eqn by the denominator, we get AC = B where B and C are column vectors B = [ x1' y1' x2' y2' x3' y3' x4' y4' ] C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] c[7] ] and A is the 8x8 matrix x1   y1     1     0   0    0   -x1x1'  -y1x1' 0    0     0    x1   y1   1   -x1y1'  -y1y1' x2   y2     1     0   0    0   -x2x2'  -y2x2' 0    0     0    x2   y2   1   -x2y2'  -y2y2' x3   y3     1     0   0    0   -x3x3'  -y3x3' 0    0     0    x3   y3   1   -x3y3'  -y3y3' x4   y4     1     0   0    0   -x4x4'  -y4x4' 0    0     0    x4   y4   1   -x4y4'  -y4y4' These eight equations are solved here for the coefficients C. These eight coefficients can then be used to find the mapping x,y) --GT (x',y' x' = c[0]x + c[1]y + c[2]) / (c[6]x + c[7]y + 1 y' = c[3]x + c[4]y + c[5]) / (c[6]x + c[7]y + 1 that is implemented in projectiveXformSampled and projectiveXFormInterpolated.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.projectiveXformSampledPt(System.Single[],System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This finds the nearest pixel coordinates of the transformed point.
 (2) It does not check ptrs for returned data!
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 8 coefficients</param>
	<param name="x">initial point</param>
	<param name="y">initial point</param>
	<param name="pxp">transformed point</param>
	<param name="pyp">transformed point</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.projectiveXformPt(System.Single[],System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This computes the floating point location of the transformed point.
 (2) It does not check ptrs for returned data!
 </summary>
	<remarks>
	</remarks>
	<param name="vc">vector of 8 coefficients</param>
	<param name="x">initial point</param>
	<param name="y">initial point</param>
	<param name="pxp">transformed point</param>
	<param name="pyp">transformed point</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertFilesToPS(System.String@,System.String@,System.Int32@,System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayConvertFilesToPS(LeptonicaSharp.Sarray@,System.Int32@,System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertFilesFittedToPS(System.String@,System.String@,System.Single@,System.Single@,System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayConvertFilesFittedToPS(LeptonicaSharp.Sarray@,System.Single@,System.Single@,System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.writeImageCompressedToPSFile(System.String@,System.String@,System.Int32@,System.Object@,System.Object@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertSegmentedPagesToPS(System.String@,System.String@,System.Int32@,System.String@,System.String@,System.Int32@,System.Int32@,System.Int32@,System.Single@,System.Single@,System.Int32@,System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteSegmentedPageToPS(LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,System.Single@,System.Single@,System.Int32@,System.Int32@,System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMixedToPS(LeptonicaSharp.Pix@,LeptonicaSharp.Pix@,System.Single@,System.Int32@,System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertToPSEmbed(System.String@,System.String@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaWriteCompressedToPS(LeptonicaSharp.Pixa@,System.String@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWritePSEmbed(System.String,System.String)">
	<summary>
 Notes
 (1) This is a simple wrapper function that generates an
 uncompressed PS file, with a bounding box.
 (2) The bounding box is required when a program such as TeX
 (through epsf) places and rescales the image.
 (3) The bounding box is sized for fitting the image to an
 8.5 x 11.0 inch page.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input file, all depths, colormap OK</param>
	<param name="fileout">output ps file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamPS(LeptonicaSharp.FILE,LeptonicaSharp.Pix,System.Int32,System.Single,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) This writes image in PS format, optionally scaled,
 adjusted for the printer resolution, and with
 a bounding box.
 (2) For details on use of parameters, see pixWriteStringPS().
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix"></param>
	<param name="box"></param>
	<param name="res">can use 0 for default of 300 ppi</param>
	<param name="scale">to prevent scaling, use either 1.0 or 0.0</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStringPS(LeptonicaSharp.Pix,LeptonicaSharp.Box,System.Int32,System.Single)">
	<summary>
 a) If %box == NULL, image is placed, optionally scaled,
 in a standard b.b. at the center of the page.
 This is to be used when another program like
 TeX through epsf places the image.
 b) If %box != NULL, image is placed without a
 b.b. at the specified page location and with
 optional scaling.  This is to be used when
 you want to specify exactly where and optionally
 how big you want the image to be.
 Note that all coordinates are in PS convention,
 with 0,0 at LL corner of the page
 x,y location of LL corner of image, in mils.
 w,h scaled size, in mils.  Use 0 to
 scale with "scale" and "res" input.
 %scale If no scaling is desired, use either 1.0 or 0.0.
 Scaling just resets the resolution parameter; the actual
 scaling is done in the interpreter at rendering time.
 This is important  it allows you to scale the image up
 without increasing the file size.
 Notes
 (1) OK, this seems a bit complicated, because there are various
 ways to scale and not to scale.  Here's a summary
 (2) If you don't want any scaling at all
 if you are using a box
 set w = 0, h = 0, and use scale = 1.0; it will print
 each pixel unscaled at printer resolution
 if you are not using a box
 set scale = 1.0; it will print at printer resolution
 (3) If you want the image to be a certain size in inches
 you must use a box and set the box (w,h) in mils
 (4) If you want the image to be scaled by a scale factor != 1.0
 if you are using a box
 set w = 0, h = 0, and use the desired scale factor;
 the higher the printer resolution, the smaller the
 image will actually appear.
 if you are not using a box
 set the desired scale factor; the higher the printer
 resolution, the smaller the image will actually appear.
 (5) Another complication is the proliferation of distance units
 The interface distances are in milli-inches.
 Three different units are used internally
 ~ pixels  (units of 1/res inch)
 ~ printer pts (units of 1/72 inch)
 ~ inches
 Here is a quiz on volume units from a reviewer
 How many UK milli-cups in a US kilo-teaspoon?
 (Hint 1.0 US cup = 0.75 UK cup + 0.2 US gill;
 1.0 US gill = 24.0 US teaspoons)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths, colormap OK</param>
	<param name="box">bounding box; can be NULL</param>
	<param name="res">resolution, in printer ppi.  Use 0 for default 300 ppi.</param>
	<param name="scale">scale factor.  If no scaling is desired, use either 1.0 or 0.0.   Scaling just resets the resolution parameter; the actual scaling is done in the interpreter at rendering time.  This is important it allows you to scale the image up without increasing the file size.</param>
	<returns>ps string if OK, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generateUncompressedPS(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Int32)">
	<summary>
 Notes
 (1) Low-level function.
 </summary>
	<remarks>
	</remarks>
	<param name="hexdata"></param>
	<param name="w">raster image size in pixels</param>
	<param name="h">raster image size in pixels</param>
	<param name="d">image depth in bpp; rgb is 32</param>
	<param name="psbpl">raster bytes/line, when packed to the byte boundary</param>
	<param name="bps">bits/sample either 1 or 8</param>
	<param name="xpt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="ypt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="wpt">rendered image size in pts</param>
	<param name="hpt">rendered image size in pts</param>
	<param name="boxflag">1 to print out bounding box hint; 0 to skip</param>
	<returns>PS string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getScaledParametersPS(System.Int32,System.Int32,System.Int32,System.Single,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) The image is always scaled, depending on res and scale.
 (2) If no box, the image is centered on the page.
 (3) If there is a box, the image is placed within it.
 </summary>
	<remarks>
	</remarks>
	<param name="box">location of image in mils; with x,y being the LL corner</param>
	<param name="wpix">pix width in pixels</param>
	<param name="hpix">pix height in pixels</param>
	<param name="res">of printer; use 0 for default</param>
	<param name="scale">use 1.0 or 0.0 for no scaling</param>
	<param name="pxpt">location of llx in pts</param>
	<param name="pypt">location of lly in pts</param>
	<param name="pwpt">image width in pts</param>
	<param name="phpt">image height in pts</param>
</member><member name="M:LeptonicaSharp._AllFunctions.convertByteToHexAscii(System.Byte,System.String@,System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="byteval">input byte</param>
	<param name="pnib1">two hex ascii characters</param>
	<param name="pnib2">two hex ascii characters</param>
</member><member name="M:LeptonicaSharp._AllFunctions.convertJpegToPSEmbed(System.String,System.String)">
	<summary>
 Notes
 (1) This function takes a jpeg file as input and generates a DCT
 compressed, ascii85 encoded PS file, with a bounding box.
 (2) The bounding box is required when a program such as TeX
 (through epsf) places and rescales the image.
 (3) The bounding box is sized for fitting the image to an
 8.5 x 11.0 inch page.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input jpeg file</param>
	<param name="fileout">output ps file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertJpegToPS(System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is simpler to use than pixWriteStringPS(), and
 it outputs in level 2 PS as compressed DCT (overlaid
 with ascii85 encoding).
 (2) An output file can contain multiple pages, each with
 multiple images.  The arguments to convertJpegToPS()
 allow you to control placement of jpeg images on multiple
 pages within a PostScript file.
 (3) For the first image written to a file, use "w", which
 opens for write and clears the file.  For all subsequent
 images written to that file, use "a".
 (4) The (x, y) parameters give the LL corner of the image
 relative to the LL corner of the page.  They are in
 units of pixels if scale = 1.0.  If you use (e.g.)
 scale = 2.0, the image is placed at (2x, 2y) on the page,
 and the image dimensions are also doubled.
 (5) Display vs printed resolution
 If your display is 75 ppi and your image was created
 at a resolution of 300 ppi, you can get the image
 to print at the same size as it appears on your display
 by either setting scale = 4.0 or by setting  res = 75.
 Both tell the printer to make a 4x enlarged image.
 If your image is generated at 150 ppi and you use scale = 1,
 it will be rendered such that 150 pixels correspond
 to 72 pts (1 inch on the printer).  This function does
 the conversion from pixels (with or without scaling) to
 pts, which are the units that the printer uses.
 The printer will choose its own resolution to use
 in rendering the image, which will not affect the size
 of the rendered image.  That is because the output
 PostScript file describes the geometry in terms of pts,
 which are defined to be 1/72 inch.  The printer will
 only see the size of the image in pts, through the
 scale and translate parameters and the affine
 transform (the ImageMatrix) of the image.
 (6) To render multiple images on the same page, set
 endpage = FALSE for each image until you get to the
 last, for which you set endpage = TRUE.  This causes the
 "showpage" command to be invoked.  Showpage outputs
 the entire page and clears the raster buffer for the
 next page to be added.  Without a "showpage",
 subsequent images from the next page will overlay those
 previously put down.
 (7) For multiple pages, increment the page number, starting
 with page 1.  This allows PostScript (and PDF) to build
 a page directory, which viewers use for navigation.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input jpeg file</param>
	<param name="fileout">output ps file</param>
	<param name="operation">"w" for write; "a" for append</param>
	<param name="x">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="y">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="res">resolution of the input image, in ppi; use 0 for default</param>
	<param name="scale">scaling by printer; use 0.0 or 1.0 for no scaling</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertJpegToPSString(System.String,System.String[]@,System.Int32@,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For usage, see convertJpegToPS()
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input jpeg file</param>
	<param name="poutstr">PS string</param>
	<param name="pnbytes">number of bytes in PS string</param>
	<param name="x">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="y">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="res">resolution of the input image, in ppi; use 0 for default</param>
	<param name="scale">scaling by printer; use 0.0 or 1.0 for no scaling</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generateJpegPS(LeptonicaSharp.L_Compressed_Data,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) Low-level function.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input jpeg filename; can be null</param>
	<param name="cid">jpeg compressed image data</param>
	<param name="xpt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="ypt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="wpt">rendered image size in pts</param>
	<param name="hpt">rendered image size in pts</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page.</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>PS string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertG4ToPSEmbed(System.String,System.String)">
	<summary>
 Notes
 (1) This function takes a g4 compressed tif file as input and
 generates a g4 compressed, ascii85 encoded PS file, with
 a bounding box.
 (2) The bounding box is required when a program such as TeX
 (through epsf) places and rescales the image.
 (3) The bounding box is sized for fitting the image to an
 8.5 x 11.0 inch page.
 (4) We paint this through a mask, over whatever is below.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input tiff file</param>
	<param name="fileout">output ps file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertG4ToPS(System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See the usage comments in convertJpegToPS(), some of
 which are repeated here.
 (2) This is a wrapper for tiff g4.  The PostScript that
 is generated is expanded by about 5/4 (due to the
 ascii85 encoding.  If you convert to pdf (ps2pdf), the
 ascii85 decoder is automatically invoked, so that the
 pdf wrapped g4 file is essentially the same size as
 the original g4 file.  It's useful to have the PS
 file ascii85 encoded, because many printers will not
 print binary PS files.
 (3) For the first image written to a file, use "w", which
 opens for write and clears the file.  For all subsequent
 images written to that file, use "a".
 (4) To render multiple images on the same page, set
 endpage = FALSE for each image until you get to the
 last, for which you set endpage = TRUE.  This causes the
 "showpage" command to be invoked.  Showpage outputs
 the entire page and clears the raster buffer for the
 next page to be added.  Without a "showpage",
 subsequent images from the next page will overlay those
 previously put down.
 (5) For multiple images to the same page, where you are writing
 both jpeg and tiff-g4, you have two options
 (a) write the g4 first, as either image (maskflag == FALSE)
 or imagemask (maskflag == TRUE), and then write the
 jpeg over it.
 (b) write the jpeg first and as the last item, write
 the g4 as an imagemask (maskflag == TRUE), to paint
 through the foreground only.
 We have this flexibility with the tiff-g4 because it is 1 bpp.
 (6) For multiple pages, increment the page number, starting
 with page 1.  This allows PostScript (and PDF) to build
 a page directory, which viewers use for navigation.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input tiff g4 file</param>
	<param name="fileout">output ps file</param>
	<param name="operation">"w" for write; "a" for append</param>
	<param name="x">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="y">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="res">resolution of the input image, in ppi; typ. values are 300 and 600; use 0 for automatic determination based on image size</param>
	<param name="scale">scaling by printer; use 0.0 or 1.0 for no scaling</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page.</param>
	<param name="maskflag">boolean use TRUE if just painting through fg; FALSE if painting both fg and bg.</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertG4ToPSString(System.String,System.String[]@,System.Int32@,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Generates PS string in G4 compressed tiff format from G4 tiff file.
 (2) For usage, see convertG4ToPS().
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input tiff g4 file</param>
	<param name="poutstr">PS string</param>
	<param name="pnbytes">number of bytes in PS string</param>
	<param name="x">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="y">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="res">resolution of the input image, in ppi; typ. values are 300 and 600; use 0 for automatic determination based on image size</param>
	<param name="scale">scaling by printer; use 0.0 or 1.0 for no scaling</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page.</param>
	<param name="maskflag">boolean use TRUE if just painting through fg; FALSE if painting both fg and bg.</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generateG4PS(LeptonicaSharp.L_Compressed_Data,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) Low-level function.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input tiff g4 file; can be null</param>
	<param name="cid">g4 compressed image data</param>
	<param name="xpt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="ypt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="wpt">rendered image size in pts</param>
	<param name="hpt">rendered image size in pts</param>
	<param name="maskflag">boolean use TRUE if just painting through fg; FALSE if painting both fg and bg.</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page.</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>PS string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertTiffMultipageToPS(System.String,System.String,System.Single)">
	<summary>
 Notes
 (1) This converts a multipage tiff file of binary page images
 into a ccitt g4 compressed PS file.
 (2) If the images are generated from a standard resolution fax,
 the vertical resolution is doubled to give a normal-looking
 aspect ratio.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input tiff multipage file</param>
	<param name="fileout">output ps file</param>
	<param name="fillfract">factor for filling 8.5 x 11 inch page; use 0.0 for DEFAULT_FILL_FRACTION</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertFlateToPSEmbed(System.String,System.String)">
	<summary>
 Notes
 (1) This function takes any image file as input and generates a
 flate-compressed, ascii85 encoded PS file, with a bounding box.
 (2) The bounding box is required when a program such as TeX
 (through epsf) places and rescales the image.
 (3) The bounding box is sized for fitting the image to an
 8.5 x 11.0 inch page.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input file -- any format</param>
	<param name="fileout">output ps file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertFlateToPS(System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This outputs level 3 PS as flate compressed (overlaid
 with ascii85 encoding).
 (2) An output file can contain multiple pages, each with
 multiple images.  The arguments to convertFlateToPS()
 allow you to control placement of png images on multiple
 pages within a PostScript file.
 (3) For the first image written to a file, use "w", which
 opens for write and clears the file.  For all subsequent
 images written to that file, use "a".
 (4) The (x, y) parameters give the LL corner of the image
 relative to the LL corner of the page.  They are in
 units of pixels if scale = 1.0.  If you use (e.g.)
 scale = 2.0, the image is placed at (2x, 2y) on the page,
 and the image dimensions are also doubled.
 (5) Display vs printed resolution
 If your display is 75 ppi and your image was created
 at a resolution of 300 ppi, you can get the image
 to print at the same size as it appears on your display
 by either setting scale = 4.0 or by setting  res = 75.
 Both tell the printer to make a 4x enlarged image.
 If your image is generated at 150 ppi and you use scale = 1,
 it will be rendered such that 150 pixels correspond
 to 72 pts (1 inch on the printer).  This function does
 the conversion from pixels (with or without scaling) to
 pts, which are the units that the printer uses.
 The printer will choose its own resolution to use
 in rendering the image, which will not affect the size
 of the rendered image.  That is because the output
 PostScript file describes the geometry in terms of pts,
 which are defined to be 1/72 inch.  The printer will
 only see the size of the image in pts, through the
 scale and translate parameters and the affine
 transform (the ImageMatrix) of the image.
 (6) To render multiple images on the same page, set
 endpage = FALSE for each image until you get to the
 last, for which you set endpage = TRUE.  This causes the
 "showpage" command to be invoked.  Showpage outputs
 the entire page and clears the raster buffer for the
 next page to be added.  Without a "showpage",
 subsequent images from the next page will overlay those
 previously put down.
 (7) For multiple pages, increment the page number, starting
 with page 1.  This allows PostScript (and PDF) to build
 a page directory, which viewers use for navigation.
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input file -- any format</param>
	<param name="fileout">output ps file</param>
	<param name="operation">"w" for write; "a" for append</param>
	<param name="x">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="y">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="res">resolution of the input image, in ppi; use 0 for default</param>
	<param name="scale">scaling by printer; use 0.0 or 1.0 for no scaling</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page.</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertFlateToPSString(System.String,System.String[]@,System.Int32@,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The returned PS character array is a null-terminated
 ascii string.  All the raster data is ascii85 encoded, so
 there are no null bytes embedded in it.
 (2) The raster encoding is made with gzip, the same as that
 in a png file that is compressed without prediction.
 The raster data itself is 25% larger than that in the
 binary form, due to the ascii85 encoding.
 Usage  See convertFlateToPS()
 </summary>
	<remarks>
	</remarks>
	<param name="filein">input image file</param>
	<param name="poutstr">PS string</param>
	<param name="pnbytes">number of bytes in PS string</param>
	<param name="x">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="y">location of LL corner of image, in pixels, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="res">resolution of the input image, in ppi; use 0 for default</param>
	<param name="scale">scaling by printer; use 0.0 or 1.0 for no scaling</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page.</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.generateFlatePS(LeptonicaSharp.L_Compressed_Data,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filein">input filename; can be null</param>
	<param name="cid">flate compressed image data</param>
	<param name="xpt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="ypt">location of LL corner of image, in pts, relative to the PostScript origin (0,0) at the LL corner of the page</param>
	<param name="wpt">rendered image size in pts</param>
	<param name="hpt">rendered image size in pts</param>
	<param name="pageno">page number; must start with 1; you can use 0 if there is only one page</param>
	<param name="endpage">boolean use TRUE if this is the last image to be added to the page; FALSE otherwise</param>
	<returns>PS string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMemPS(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pix,System.Int32,System.Single,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) See pixWriteStringPS() for usage.
 (2) This is just a wrapper for pixWriteStringPS(), which
 writes uncompressed image data to memory.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of tiff compressed image</param>
	<param name="psize">size of returned data</param>
	<param name="pix"></param>
	<param name="box"></param>
	<param name="res">can use 0 for default of 300 ppi</param>
	<param name="scale">to prevent scaling, use either 1.0 or 0.0</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getResLetterPage(System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="w">image width, pixels</param>
	<param name="h">image height, pixels</param>
	<param name="fillfract">fraction in linear dimension of full page, not to be exceeded; use 0 for default</param>
	<returns>resolution</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getResA4Page(System.Int32,System.Int32,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="w">image width, pixels</param>
	<param name="h">image height, pixels</param>
	<param name="fillfract">fraction in linear dimension of full page, not to be exceeded; use 0 for default</param>
	<returns>resolution</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_psWriteBoundingBox(System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">initial array sizes</param>
	<returns>pta, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaCreateFromNuma(LeptonicaSharp.Numa,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nax">can be null</param>
	<param name="nay"></param>
	<returns>pta, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaDestroy(LeptonicaSharp.Pta@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the pta.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppta">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaCopy(LeptonicaSharp.Pta)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>copy of pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaCopyRange(LeptonicaSharp.Pta,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="istart">starting index in ptas</param>
	<param name="iend">ending index in ptas; use 0 to copy to end</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaClone(LeptonicaSharp.Pta)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>ptr to same pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaEmpty(LeptonicaSharp.Pta)">
	<summary>
 Notes
 This only resets the Ptan field, for reuse
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaAddPt(LeptonicaSharp.Pta,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="x"></param>
	<param name="y"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaInsertPt(LeptonicaSharp.Pta,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="index">at which pt is to be inserted</param>
	<param name="x">point values</param>
	<param name="y">point values</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaRemovePt(LeptonicaSharp.Pta,System.Int32)">
	<summary>
 Notes
 (1) This shifts pta[i] --GT pta[i - 1] for all i GT index.
 (2) It should not be used repeatedly on large arrays,
 because the function is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="index">of point to be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetRefcount(LeptonicaSharp.Pta@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaChangeRefcount(LeptonicaSharp.Pta@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetCount(LeptonicaSharp.Pta)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>count, or 0 if no pta</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetPt(LeptonicaSharp.Pta,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="index">into arrays</param>
	<param name="px">float x value</param>
	<param name="py">float y value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetIPt(LeptonicaSharp.Pta,System.Int32,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="index">into arrays</param>
	<param name="px">integer x value</param>
	<param name="py">integer y value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaSetPt(LeptonicaSharp.Pta,System.Int32,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="index">into arrays</param>
	<param name="x"></param>
	<param name="y"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetArrays(LeptonicaSharp.Pta,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This copies the internal arrays into new Numas.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pnax">numa of x array</param>
	<param name="pnay">numa of y array</param>
	<returns>0 if OK; 1 on error or if pta is empty</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization in ascii</param>
	<param name="size">of data in bytes; can use strlen to get it</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaWriteDebug(System.String,LeptonicaSharp.Pta,System.Int32)">
	<summary>
 Notes
 (1) Debug version, intended for use in the library when writing
 to files in a temp directory with names that are compiled in.
 This is used instead of ptaWrite() for all such library calls.
 (2) The global variable LeptDebugOK defaults to 0, and can be set
 or cleared by the function setLeptDebugOK().
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pta"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaWrite(System.String,LeptonicaSharp.Pta,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pta"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.Pta,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pta"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pta,System.Int32)">
	<summary>
 Notes
 (1) Serializes a pta in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized pta; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="pta"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">initial number of ptrs</param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaDestroy(LeptonicaSharp.Ptaa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pptaa">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaAddPta(LeptonicaSharp.Ptaa,LeptonicaSharp.Pta,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<param name="pta">to be added</param>
	<param name="copyflag">L_INSERT, L_COPY, L_CLONE</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaGetCount(LeptonicaSharp.Ptaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<returns>count, or 0 if no ptaa</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaGetPta(LeptonicaSharp.Ptaa,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<param name="index">to the i-th pta</param>
	<param name="accessflag">L_COPY or L_CLONE</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaGetPt(LeptonicaSharp.Ptaa,System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<param name="ipta">to the i-th pta</param>
	<param name="jpt">index to the j-th pt in the pta</param>
	<param name="px">float x value</param>
	<param name="py">float y value</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaInitFull(LeptonicaSharp.Ptaa,LeptonicaSharp.Pta)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaa">can have non-null ptrs in the ptr array</param>
	<param name="pta">to be replicated into the entire ptr array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaReplacePta(LeptonicaSharp.Ptaa,System.Int32,LeptonicaSharp.Pta)">
	<summary>
 Notes
 (1) Any existing pta is destroyed, and the input one
 is inserted in its place.
 (2) If the index is invalid, return 1 (error)
 </summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<param name="index">to the index-th pta</param>
	<param name="pta">insert and replace any existing one</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaAddPt(LeptonicaSharp.Ptaa,System.Int32,System.Single,System.Single@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<param name="ipta">to the i-th pta</param>
	<param name="x">,y point coordinates</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaTruncate(LeptonicaSharp.Ptaa)">
	<summary>
 Notes
 (1) This identifies the largest index containing a pta that
 has any points within it, destroys all pta above that index,
 and resets the count.
 </summary>
	<remarks>
	</remarks>
	<param name="ptaa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization in ascii</param>
	<param name="size">of data in bytes; can use strlen to get it</param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaWriteDebug(System.String,LeptonicaSharp.Ptaa,System.Int32)">
	<summary>
 Notes
 (1) Debug version, intended for use in the library when writing
 to files in a temp directory with names that are compiled in.
 This is used instead of ptaaWrite() for all such library calls.
 (2) The global variable LeptDebugOK defaults to 0, and can be set
 or cleared by the function setLeptDebugOK().
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="ptaa"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaWrite(System.String,LeptonicaSharp.Ptaa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="ptaa"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.Ptaa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="ptaa"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.Ptaa,System.Int32)">
	<summary>
 Notes
 (1) Serializes a ptaa in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized ptaa; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="ptaa"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaSubsample(LeptonicaSharp.Pta,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="subfactor">subsample factor, GT= 1</param>
	<returns>ptad evenly sampled pt values from ptas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaJoin(LeptonicaSharp.Pta,LeptonicaSharp.Pta,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (2) iend LT 0 means 'read to the end'
 (3) if ptas == NULL, this is a no-op
 </summary>
	<remarks>
	</remarks>
	<param name="ptad">dest pta; add to this one</param>
	<param name="ptas">source pta; add from this one</param>
	<param name="istart">starting index in ptas</param>
	<param name="iend">ending index in ptas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaJoin(LeptonicaSharp.Ptaa,LeptonicaSharp.Ptaa,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) istart LT 0 is taken to mean 'read from the start' (istart = 0)
 (2) iend LT 0 means 'read to the end'
 (3) if ptas == NULL, this is a no-op
 </summary>
	<remarks>
	</remarks>
	<param name="ptaad">dest ptaa; add to this one</param>
	<param name="ptaas">source ptaa; add from this one</param>
	<param name="istart">starting index in ptaas</param>
	<param name="iend">ending index in ptaas; use -1 to cat all</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaReverse(LeptonicaSharp.Pta,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="type">0 for float values; 1 for integer values</param>
	<returns>ptad reversed pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaTranspose(LeptonicaSharp.Pta)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<returns>ptad with x and y values swapped, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaCyclicPerm(LeptonicaSharp.Pta,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Check to insure that (a) ptas is a closed path where
 the first and last points are identical, and (b) the
 resulting pta also starts and ends on the same point
 (which in this case is (xs, ys).
 </summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="xs">start point; must be in ptas</param>
	<param name="ys">start point; must be in ptas</param>
	<returns>ptad cyclic permutation, starting and ending at (xs, ys, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaSelectRange(LeptonicaSharp.Pta,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="first">use 0 to select from the beginning</param>
	<param name="last">use 0 to select to the end</param>
	<returns>ptad, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetBoundingRegion(LeptonicaSharp.Pta)">
	<summary>
 Notes
 (1) This is used when the pta represents a set of points in
 a two-dimensional image.  It returns the box of minimum
 size containing the pts in the pta.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetRange(LeptonicaSharp.Pta,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) We can use pts to represent pairs of floating values, that
 are not necessarily tied to a two-dimension region.  For
 example, the pts can represent a general function y(x).
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pminx">min value of x</param>
	<param name="pmaxx">max value of x</param>
	<param name="pminy">min value of y</param>
	<param name="pmaxy">max value of y</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetInsideBox(LeptonicaSharp.Pta,LeptonicaSharp.Box)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas">input pts</param>
	<param name="box"></param>
	<returns>ptad of pts in ptas that are inside the box, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindCornerPixels(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Finds the 4 corner-most pixels, as defined by a search
 inward from each corner, using a 45 degree line.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaContainsPt(LeptonicaSharp.Pta,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="x">point</param>
	<param name="y">point</param>
	<returns>1 if contained, 0 otherwise or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaTestIntersection(LeptonicaSharp.Pta,LeptonicaSharp.Pta)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta1"></param>
	<param name="pta2"></param>
	<returns>bval which is 1 if they have any elements in common; 0 otherwise or on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaTransform(LeptonicaSharp.Pta,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) Shift first, then scale.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="shiftx"></param>
	<param name="shifty"></param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaPtInsidePolygon(LeptonicaSharp.Pta,System.Single,System.Single,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta">vertices of a polygon</param>
	<param name="x">point to be tested</param>
	<param name="y">point to be tested</param>
	<param name="pinside">1 if inside; 0 if outside or on boundary</param>
	<returns>1 if OK, 0 on error The abs value of the sum of the angles subtended from a point by the sides of a polygon, when taken in order traversing the polygon, is 0 if the point is outside the polygon and 2pi if inside. The sign will be positive if traversed cw and negative if ccw.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_angleBetweenVectors(System.Single,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) This gives the angle between two vectors, going between
 vector1 (x1,y1) and vector2 (x2,y2).  The angle is swept
 out from 1 --GT 2.  If this is clockwise, the angle is
 positive, but the result is folded into the interval [-pi, pi].
 </summary>
	<remarks>
	</remarks>
	<param name="x1">end point of first vector</param>
	<param name="y1">end point of first vector</param>
	<param name="x2">end point of second vector</param>
	<param name="y2">end point of second vector</param>
	<returns>angle radians, or 0.0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetMinMax(LeptonicaSharp.Pta,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pxmin">min of x</param>
	<param name="pymin">min of y</param>
	<param name="pxmax">max of x</param>
	<param name="pymax">max of y</param>
	<returns>0 if OK, 1 on error.  If pta is empty, requested values are returned as -1.0.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaSelectByValue(LeptonicaSharp.Pta,System.Single,System.Single,LeptonicaSharp.Enumerations.L_SELECT,LeptonicaSharp.Enumerations.L_SELECT_IF)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="xth">threshold values</param>
	<param name="yth">threshold values</param>
	<param name="type">L_SELECT_XVAL, L_SELECT_YVAL, L_SELECT_IF_EITHER, L_SELECT_IF_BOTH</param>
	<param name="relation">L_SELECT_IF_LT, L_SELECT_IF_GT, L_SELECT_IF_LTE, L_SELECT_IF_GTE</param>
	<returns>ptad filtered set, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaCropToMask(LeptonicaSharp.Pta,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas">input pta</param>
	<param name="pixm">1 bpp mask</param>
	<returns>ptad  with only pts under the mask fg, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetLinearLSF(LeptonicaSharp.Pta,System.Single[]@,System.Single[]@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) Either or both a and b must be input.  They determine the
 type of line that is fit.
 (2) If both a and b are defined, this returns a and b that minimize
 sum (yi - axi -b)^2
 i
 The method is simple differentiate this expression w/rt a and b,
 and solve the resulting two equations for a and b in terms of
 various sums over the input data (xi, yi).
 (3) We also allow two special cases, where either a = 0 or b = 0
 (a) If a is given and b = null, find the linear LSF that
 goes through the origin (b = 0).
 (b) If b is given and a = null, find the linear LSF with
 zero slope (a = 0).
 (4) If nafit is defined, this returns an array of fitted values,
 corresponding to the two implicit Numa arrays (nax and nay) in pta.
 Thus, just as you can plot the data in pta as nay vs. nax,
 you can plot the linear least square fit as nafit vs. nax.
 Get the nax array using ptaGetArrays(pta, nax, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pa">slope a of least square fit y = ax + b</param>
	<param name="pb">intercept b of least square fit</param>
	<param name="pnafit">numa of least square fit</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetQuadraticLSF(LeptonicaSharp.Pta,System.Single[]@,System.Single[]@,System.Single[]@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This does a quadratic least square fit to the set of points
 in %pta.  That is, it finds coefficients a, b and c that minimize
 sum (yi - axixi -bxi -c)^2
 i
 The method is simple differentiate this expression w/rt
 a, b and c, and solve the resulting three equations for these
 coefficients in terms of various sums over the input data (xi, yi).
 The three equations are in the form
 f[0][0]a + f[0][1]b + f[0][2]c = g[0]
 f[1][0]a + f[1][1]b + f[1][2]c = g[1]
 f[2][0]a + f[2][1]b + f[2][2]c = g[2]
 (2) If nafit is defined, this returns an array of fitted values,
 corresponding to the two implicit Numa arrays (nax and nay) in pta.
 Thus, just as you can plot the data in pta as nay vs. nax,
 you can plot the linear least square fit as nafit vs. nax.
 Get the nax array using ptaGetArrays(pta, nax, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pa">coeff a of LSF y = ax^2 + bx + c</param>
	<param name="pb">coeff b of LSF y = ax^2 + bx + c</param>
	<param name="pc">coeff c of LSF y = ax^2 + bx + c</param>
	<param name="pnafit">numa of least square fit</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetCubicLSF(LeptonicaSharp.Pta,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This does a cubic least square fit to the set of points
 in %pta.  That is, it finds coefficients a, b, c and d
 that minimize
 sum (yi - axixixi -bxixi -cxi - d)^2
 i
 Differentiate this expression w/rt a, b, c and d, and solve
 the resulting four equations for these coefficients in
 terms of various sums over the input data (xi, yi).
 The four equations are in the form
 f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] = g[0]
 f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] = g[1]
 f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] = g[2]
 f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] = g[3]
 (2) If nafit is defined, this returns an array of fitted values,
 corresponding to the two implicit Numa arrays (nax and nay) in pta.
 Thus, just as you can plot the data in pta as nay vs. nax,
 you can plot the linear least square fit as nafit vs. nax.
 Get the nax array using ptaGetArrays(pta, nax, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pa">coeff a of LSF y = ax^3 + bx^2 + cx + d</param>
	<param name="pb">coeff b of LSF</param>
	<param name="pc">coeff c of LSF</param>
	<param name="pd">coeff d of LSF</param>
	<param name="pnafit">numa of least square fit</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetQuarticLSF(LeptonicaSharp.Pta,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This does a quartic least square fit to the set of points
 in %pta.  That is, it finds coefficients a, b, c, d and 3
 that minimize
 sum (yi - axixixixi -bxixixi -cxixi - dxi - e)^2
 i
 Differentiate this expression w/rt a, b, c, d and e, and solve
 the resulting five equations for these coefficients in
 terms of various sums over the input data (xi, yi).
 The five equations are in the form
 f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] + f[0][4] = g[0]
 f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] + f[1][4] = g[1]
 f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] + f[2][4] = g[2]
 f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] + f[3][4] = g[3]
 f[4][0]a + f[4][1]b + f[4][2]c + f[4][3] + f[4][4] = g[4]
 (2) If nafit is defined, this returns an array of fitted values,
 corresponding to the two implicit Numa arrays (nax and nay) in pta.
 Thus, just as you can plot the data in pta as nay vs. nax,
 you can plot the linear least square fit as nafit vs. nax.
 Get the nax array using ptaGetArrays(pta, nax, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pa">coeff a of LSF y = ax^4 + bx^3 + cx^2 + dx + e</param>
	<param name="pb">coeff b of LSF</param>
	<param name="pc">coeff c of LSF</param>
	<param name="pd">coeff d of LSF</param>
	<param name="pe">coeff e of LSF</param>
	<param name="pnafit">numa of least square fit</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaNoisyLinearLSF(LeptonicaSharp.Pta,System.Single,LeptonicaSharp.Pta@,System.Single[]@,System.Single[]@,System.Single[]@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This does a linear least square fit to the set of points
 in %pta.  It then evaluates the errors and removes points
 whose error is GT= factor  median_error.  It then re-runs
 the linear LSF on the resulting points.
 (2) Either or both a and b must be input.  They determine the
 type of line that is fit.
 (3) The median error can give an indication of how good the fit
 is likely to be.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="factor">reject outliers with error greater than this number of medians; typically ~ 3</param>
	<param name="pptad">with outliers removed</param>
	<param name="pa">slope a of least square fit y = ax + b</param>
	<param name="pb">intercept b of least square fit</param>
	<param name="pmederr">median error</param>
	<param name="pnafit">numa of least square fit to ptad</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaNoisyQuadraticLSF(LeptonicaSharp.Pta,System.Single,LeptonicaSharp.Pta@,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This does a quadratic least square fit to the set of points
 in %pta.  It then evaluates the errors and removes points
 whose error is GT= factor  median_error.  It then re-runs
 a quadratic LSF on the resulting points.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="factor">reject outliers with error greater than this number of medians; typically ~ 3</param>
	<param name="pptad">with outliers removed</param>
	<param name="pa">coeff a of LSF y = ax^2 + bx + c</param>
	<param name="pb">coeff b of LSF y = ax^2 + bx + c</param>
	<param name="pc">coeff c of LSF y = ax^2 + bx + c</param>
	<param name="pmederr">median error</param>
	<param name="pnafit">numa of least square fit to ptad</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.applyLinearFit(System.Single,System.Single,System.Single,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="a">linear fit coefficients</param>
	<param name="b">linear fit coefficients</param>
	<param name="x"></param>
	<param name="py">y = a  x + b</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.applyQuadraticFit(System.Single,System.Single,System.Single,System.Single,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="a">quadratic fit coefficients</param>
	<param name="b">quadratic fit coefficients</param>
	<param name="c">quadratic fit coefficients</param>
	<param name="x"></param>
	<param name="py">y = a  x^2 + b  x + c</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.applyCubicFit(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="a">cubic fit coefficients</param>
	<param name="b">cubic fit coefficients</param>
	<param name="c">cubic fit coefficients</param>
	<param name="d">cubic fit coefficients</param>
	<param name="x"></param>
	<param name="py">y = a  x^3 + b  x^2  + c  x + d</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.applyQuarticFit(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single[]@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="a">quartic fit coefficients</param>
	<param name="b">quartic fit coefficients</param>
	<param name="c">quartic fit coefficients</param>
	<param name="d">quartic fit coefficients</param>
	<param name="e">quartic fit coefficients</param>
	<param name="x"></param>
	<param name="py">y = a  x^4 + b  x^3  + c  x^2 + d  x + e</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixPlotAlongPta(LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Enumerations.GPLOT_OUTPUT,System.String)">
	<summary>
 Notes
 (1) This is a debugging function.
 (2) Removes existing colormaps and clips the pta to the input %pixs.
 (3) If the image is RGB, three separate plots are generated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="pta">set of points on which to plot</param>
	<param name="outformat">GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX</param>
	<param name="title">for plot; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetPixelsFromPix(LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) Generates a pta of fg pixels in the pix, within the box.
 If box == NULL, it uses the entire pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="box">can be null</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenerateFromPta(LeptonicaSharp.Pta,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Points are rounded to nearest ints.
 (2) Any points outside (w,h) are silently discarded.
 (3) Output 1 bpp pix has values 1 for each point in the pta.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="w">of pix</param>
	<param name="h">of pix</param>
	<returns>pix 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetBoundaryPixels(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_BOUNDARY_G)">
	<summary>
 Notes
 (1) This generates a pta of either fg or bg boundary pixels.
 (2) See also pixGeneratePtaBoundary() for rendering of
 fg boundary pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="type">L_BOUNDARY_FG, L_BOUNDARY_BG</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaGetBoundaryPixels(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_BOUNDARY_G,System.Int32,LeptonicaSharp.Boxa@,LeptonicaSharp.Pixa@)">
	<summary>
 Notes
 (1) This generates a ptaa of either fg or bg boundary pixels,
 where each pta has the boundary pixels for a connected
 component.
 (2) We can't simply find all the boundary pixels and then select
 those within the bounding box of each component, because
 bounding boxes can overlap.  It is necessary to extract and
 dilate or erode each component separately.  Note also that
 special handling is required for bg pixels when the
 component touches the pix boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="type">L_BOUNDARY_FG, L_BOUNDARY_BG</param>
	<param name="connectivity">4 or 8</param>
	<param name="pboxa">bounding boxes of the c.c.</param>
	<param name="ppixa">pixa of the c.c.</param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaIndexLabeledPixels(LeptonicaSharp.Pix,System.Int32@)">
	<summary>
 Notes
 (1) The pixel values in %pixs are the index of the connected component
 to which the pixel belongs; %pixs is typically generated from
 a 1 bpp pix by pixConnCompTransform().  Background pixels in
 the generating 1 bpp pix are represented in %pixs by 0.
 We do not check that the pixel values are correctly labelled.
 (2) Each pta in the returned ptaa gives the pixel locations
 correspnding to a connected component, with the label of each
 given by the index of the pta into the ptaa.
 (3) Initialize with the first pta in ptaa being empty and
 representing the background value (index 0) in the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, of indices of c.c.</param>
	<param name="pncc">number of connected components</param>
	<returns>ptaa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetNeighborPixLocs(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Generates a pta of all valid neighbor pixel locations,
 or NULL on error.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="x">pixel from which we search for nearest neighbors</param>
	<param name="y">pixel from which we search for nearest neighbors</param>
	<param name="conn">4 or 8 connectivity</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaConvertToPta1(LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="na">numa with implicit y(x)</param>
	<returns>pta if OK; null on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaConvertToPta2(LeptonicaSharp.Numa,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nax"></param>
	<param name="nay"></param>
	<returns>pta if OK; null on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaConvertToNuma(LeptonicaSharp.Pta,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="pnax">addr of nax</param>
	<param name="pnay">addr of nay</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDisplayPta(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pta)">
	<summary>
 Notes
 (1) To write on an existing pixs, pixs must be 32 bpp and
 call with pixd == pixs
 pixDisplayPta(pixs, pixs, pta);
 To write to a new pix, use pixd == NULL and call
 pixd = pixDisplayPta(NULL, pixs, pta);
 (2) On error, returns pixd to avoid losing pixs if called as
 pixs = pixDisplayPta(pixs, pixs, pta);
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be same as pixs or NULL; 32 bpp if in-place</param>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="pta">of path to be plotted</param>
	<returns>pixd 32 bpp RGB version of pixs, with path in green.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDisplayPtaaPattern(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Ptaa,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) To write on an existing pixs, pixs must be 32 bpp and
 call with pixd == pixs
 pixDisplayPtaPattern(pixs, pixs, pta, ...);
 To write to a new pix, use pixd == NULL and call
 pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...);
 (2) Puts a random color on each pattern associated with a pta.
 (3) On error, returns pixd to avoid losing pixs if called as
 pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...);
 (4) A typical pattern to be used is a circle, generated with
 generatePtaFilledCircle()
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp</param>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp; 32 bpp if in place</param>
	<param name="ptaa">giving locations at which the pattern is displayed</param>
	<param name="pixp">1 bpp pattern to be placed such that its reference point co-locates with each point in pta</param>
	<param name="cx">reference point in pattern</param>
	<param name="cy">reference point in pattern</param>
	<returns>pixd 32 bpp RGB version of pixs.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDisplayPtaPattern(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pta,LeptonicaSharp.Pix,System.Int32,System.Int32,System.UInt32)">
	<summary>
 Notes
 (1) To write on an existing pixs, pixs must be 32 bpp and
 call with pixd == pixs
 pixDisplayPtaPattern(pixs, pixs, pta, ...);
 To write to a new pix, use pixd == NULL and call
 pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...);
 (2) On error, returns pixd to avoid losing pixs if called as
 pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...);
 (3) A typical pattern to be used is a circle, generated with
 generatePtaFilledCircle()
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">can be same as pixs or NULL; 32 bpp if in-place</param>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="pta">giving locations at which the pattern is displayed</param>
	<param name="pixp">1 bpp pattern to be placed such that its reference point co-locates with each point in pta</param>
	<param name="cx">reference point in pattern</param>
	<param name="cy">reference point in pattern</param>
	<param name="color">in 0xrrggbb00 format</param>
	<returns>pixd 32 bpp RGB version of pixs.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaReplicatePattern(LeptonicaSharp.Pta,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.Pta)">
	<summary>
 Notes
 (1) You can use either the image %pixp or the set of pts %ptap.
 (2) The pattern is placed with its reference point at each point
 in ptas, and all the fg pixels are colleced into ptad.
 For %pixp, this is equivalent to blitting pixp at each point
 in ptas, and then converting the resulting pix to a pta.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">"sparse" input pta</param>
	<param name="pixp">1 bpp pattern, to be replicated in output pta</param>
	<param name="ptap">set of pts, to be replicated in output pta</param>
	<param name="cx">reference point in pattern</param>
	<param name="cy">reference point in pattern</param>
	<param name="w">clipping sizes for output pta</param>
	<param name="h">clipping sizes for output pta</param>
	<returns>ptad with all points of replicated pattern, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDisplayPtaa(LeptonicaSharp.Pix,LeptonicaSharp.Ptaa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 or 32 bpp</param>
	<param name="ptaa">array of paths to be plotted</param>
	<returns>pixd 32 bpp RGB version of pixs, with paths plotted in different colors, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaSort(LeptonicaSharp.Pta,LeptonicaSharp.Enumerations.L_SORT_BY,LeptonicaSharp.Enumerations.L_SORT_CREASING,LeptonicaSharp.Numa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y</param>
	<param name="sortorder">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<param name="pnaindex">index of sorted order into original array</param>
	<returns>ptad sorted version of ptas, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetSortIndex(LeptonicaSharp.Pta,LeptonicaSharp.Enumerations.L_SORT_BY,LeptonicaSharp.Enumerations.L_SORT_CREASING,LeptonicaSharp.Numa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y</param>
	<param name="sortorder">L_SORT_INCREASING, L_SORT_DECREASING</param>
	<param name="pnaindex">index of sorted order into original array</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaSortByIndex(LeptonicaSharp.Pta,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptas"></param>
	<param name="naindex">na that maps from the new pta to the input pta</param>
	<returns>ptad sorted, or NULL on  error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaaSortByIndex(LeptonicaSharp.Ptaa,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptaas"></param>
	<param name="naindex">na that maps from the new ptaa to the input ptaa</param>
	<returns>ptaad sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaGetRankValue(LeptonicaSharp.Pta,System.Single,LeptonicaSharp.Enumerations.L_SORT_BY,System.Single[]@,LeptonicaSharp.Pta)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="fract">use 0.0 for smallest, 1.0 for largest</param>
	<param name="ptasort">version of %pta sorted by %sorttype</param>
	<param name="sorttype">L_SORT_BY_X, L_SORT_BY_Y</param>
	<param name="pval">rankval the x or y value at %fract</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaUnionByAset(LeptonicaSharp.Pta,LeptonicaSharp.Pta)">
	<summary>
 Notes
 (1) See sarrayRemoveDupsByAset() for the approach.
 (2) The key is a 64-bit hash from the (x,y) pair.
 (3) This is slower than ptaUnionByHash(), mostly because of the
 nlogn sort to build up the rbtree.  Do not use for large
 numbers of points (say, GT 1M).
 (4) The Aset() functions use the sorted l_Aset, which is just
 an rbtree in disguise.
 </summary>
	<remarks>
	</remarks>
	<param name="pta1"></param>
	<param name="pta2"></param>
	<returns>ptad with the union of the set of points, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaRemoveDupsByAset(LeptonicaSharp.Pta)">
	<summary>
 Notes
 (1) This is slower than ptaRemoveDupsByHash(), mostly because
 of the nlogn sort to build up the rbtree.  Do not use for
 large numbers of points (say, GT 1M).
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">assumed to be integer values</param>
	<returns>ptad with duplicates removed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaIntersectionByAset(LeptonicaSharp.Pta,LeptonicaSharp.Pta)">
	<summary>
 Notes
 (1) See sarrayIntersectionByAset() for the approach.
 (2) The key is a 64-bit hash from the (x,y) pair.
 (3) This is slower than ptaIntersectionByHash(), mostly because
 of the nlogn sort to build up the rbtree.  Do not use for
 large numbers of points (say, GT 1M).
 </summary>
	<remarks>
	</remarks>
	<param name="pta1"></param>
	<param name="pta2"></param>
	<returns>ptad intersection of the point sets, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_asetCreateFromPta(LeptonicaSharp.Pta)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>set using a 64-bit hash of (x,y) as the key</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaUnionByHash(LeptonicaSharp.Pta,LeptonicaSharp.Pta)">
	<summary>
 Notes
 (1) This is faster than ptaUnionByAset(), because the
 bucket lookup is O(n).  It should be used if the pts are
 integers (e.g., representing pixel positions).
 </summary>
	<remarks>
	</remarks>
	<param name="pta1"></param>
	<param name="pta2"></param>
	<returns>ptad with the union of the set of points, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaRemoveDupsByHash(LeptonicaSharp.Pta,LeptonicaSharp.Pta@,LeptonicaSharp.L_DnaHash@)">
	<summary>
 Notes
 (1) Generates a pta with unique values.
 (2) The dnahash is built up with ptad to assure uniqueness.
 It can be used to find if a point is in the set
 ptaFindPtByHash(ptad, dahash, x, y, index)
 (3) The hash of the (x,y) location is simple and fast.  It scales
 up with the number of buckets to insure a fairly random
 bucket selection for adjacent points.
 (4) A Dna is used rather than a Numa because we need accurate
 representation of 32-bit integers that are indices into ptas.
 Integer --GT float --GT integer conversion makes errors for
 integers larger than 10M.
 (5) This is faster than ptaRemoveDupsByAset(), because the
 bucket lookup is O(n), although there is a double-loop
 lookup within the dna in each bucket.
 </summary>
	<remarks>
	</remarks>
	<param name="ptas">assumed to be integer values</param>
	<param name="pptad">unique set of pts; duplicates removed</param>
	<param name="pdahash">dnahash used for lookup</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaIntersectionByHash(LeptonicaSharp.Pta,LeptonicaSharp.Pta)">
	<summary>
 Notes
 (1) This is faster than ptaIntersectionByAset(), because the
 bucket lookup is O(n).  It should be used if the pts are
 integers (e.g., representing pixel positions).
 </summary>
	<remarks>
	</remarks>
	<param name="pta1"></param>
	<param name="pta2"></param>
	<returns>ptad intersection of the point sets, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptaFindPtByHash(LeptonicaSharp.Pta,LeptonicaSharp.L_DnaHash,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Fast lookup in dnaHash associated with a pta, to see if a
 random point (x,y) is already stored in the hash table.
 (2) We use a strong hash function to minimize the chance that
 two different points hash to the same key value.
 (3) We select the number of buckets to be about 5% of the size
 of the input %pta, so that when fully populated, each
 bucket (dna) will have about 20 entries, each being an index
 into %pta.  In lookup, after hashing to the key, and then
 again to the bucket, we traverse the bucket (dna), using the
 index into %pta to check if the point (x,y) has been found before.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="dahash">built from pta</param>
	<param name="x">arbitrary points</param>
	<param name="y">arbitrary points</param>
	<param name="pindex">index into pta if (x,y) is in pta; -1 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaHashCreateFromPta(LeptonicaSharp.Pta)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<returns>dahash, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of ptr array to be alloc'd 0 for default</param>
	<returns>pa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraDestroy(LeptonicaSharp.L_Ptra@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If %freeflag == TRUE, frees each item in the array.
 (2) If %freeflag == FALSE and %warnflag == TRUE, and there are
 items on the array, this gives a warning and destroys the array.
 If these items are not owned elsewhere, this will cause
 a memory leak of all the items that were on the array.
 So if the items are not owned elsewhere and require their
 own destroy function, they must be destroyed before the ptra.
 (3) If %warnflag == FALSE, no warnings will be issued.  This is
 useful if the items are owned elsewhere, such as a
 PixMemoryStore().
 (4) To destroy the ptra, we destroy the ptr array, then
 the ptra, and then null the contents of the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppa">ptra to be nulled</param>
	<param name="freeflag">TRUE to free each remaining item in the array</param>
	<param name="warnflag">TRUE to warn if any remaining items are not destroyed</param>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraAdd(LeptonicaSharp.L_Ptra,System.Object)">
	<summary>
 Notes
 (1) This adds the element to the next location beyond imax,
 which is the largest occupied ptr in the array.  This is
 what you expect from a stack, where all ptrs up to and
 including imax are occupied, but here the occuption of
 items in the array is entirely arbitrary.
 </summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="item">generic ptr to a struct</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraInsert(LeptonicaSharp.L_Ptra,System.Int32,System.Object,LeptonicaSharp.Enumerations.L_DOWNSHIFT)">
	<summary>
 Notes
 (1) This checks first to see if the location is valid, and
 then if there is presently an item there.  If there is not,
 it is simply inserted into that location.
 (2) If there is an item at the insert location, items must be
 moved down to make room for the insert.  In the downward
 shift there are three options, given by %shiftflag.
 ~ If %shiftflag == L_AUTO_DOWNSHIFT, a decision is made
 whether, in a cascade of items, to downshift a minimum
 amount or for all items above %index.  The decision is
 based on the expectation of finding holes (null ptrs)
 between %index and the bottom of the array.
 Assuming the holes are distributed uniformly, if 2 or more
 holes are expected, we do a minimum shift.
 ~ If %shiftflag == L_MIN_DOWNSHIFT, the downward shifting
 cascade of items progresses a minimum amount, until
 the first empty slot is reached.  This mode requires
 some computation before the actual shifting is done.
 ~ If %shiftflag == L_FULL_DOWNSHIFT, a shifting cascade is
 performed where pa[i] --GT pa[i + 1] for all i GT= index.
 Then, the item is inserted at pa[index].
 (3) If you are not using L_AUTO_DOWNSHIFT, the rule of thumb is
 to use L_FULL_DOWNSHIFT if the array is compacted (each
 element points to an item), and to use L_MIN_DOWNSHIFT
 if there are a significant number of null pointers.
 There is no penalty to using L_MIN_DOWNSHIFT for a
 compacted array, however, because the full shift is required
 and we don't do the O(n) computation to look for holes.
 (4) This should not be used repeatedly on large arrays,
 because the function is generally O(n).
 (5) However, it can be used repeatedly if we start with an empty
 ptr array and insert only once at each location.  For example,
 you can support an array of Numa, where at each ptr location
 you store either 0 or 1 Numa, and the Numa can be added
 randomly to the ptr array.
 </summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="index">location in ptra to insert new value</param>
	<param name="item">generic ptr to a struct; can be null</param>
	<param name="shiftflag">L_AUTO_DOWNSHIFT, L_MIN_DOWNSHIFT, L_FULL_DOWNSHIFT</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraRemove(LeptonicaSharp.L_Ptra,System.Int32,LeptonicaSharp.Enumerations.L_COMPACTION)">
	<summary>
 Notes
 (1) If flag == L_NO_COMPACTION, this removes the item and
 nulls the ptr on the array.  If it takes the last item
 in the array, pa-GTn is reduced to the next item.
 (2) If flag == L_COMPACTION, this compacts the array for
 for all i GT= index.  It should not be used repeatedly on
 large arrays, because compaction is O(n).
 (3) The ability to remove without automatic compaction allows
 removal with cost O(1).
 </summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="index">element to be removed</param>
	<param name="flag">L_NO_COMPACTION, L_COMPACTION</param>
	<returns>item, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraRemoveLast(LeptonicaSharp.L_Ptra)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<returns>item, or NULL on error or if the array is empty</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraReplace(LeptonicaSharp.L_Ptra,System.Int32,System.Object,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="index">element to be replaced</param>
	<param name="item">new generic ptr to a struct; can be null</param>
	<param name="freeflag">TRUE to free old item; FALSE to return it</param>
	<returns>item  old item, if it exists and is not freed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraSwap(LeptonicaSharp.L_Ptra,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="index1"></param>
	<param name="index2"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraCompactArray(LeptonicaSharp.L_Ptra)">
	<summary>
 Notes
 (1) This compacts the items on the array, filling any empty ptrs.
 (2) This does not change the size of the array of ptrs.
 </summary>
	<remarks>
	</remarks>
	<param name="pa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraReverse(LeptonicaSharp.L_Ptra)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraJoin(LeptonicaSharp.L_Ptra,LeptonicaSharp.L_Ptra)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pa1">add to this one</param>
	<param name="pa2">appended to pa1, and emptied of items; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraGetMaxIndex(LeptonicaSharp.L_Ptra,System.Int32@)">
	<summary>
 Notes
 (1) The largest index to an item in the array is %maxindex.
 %maxindex is one less than the number of items that would be
 in the array if there were no null pointers between 0
 and %maxindex - 1.  However, because the internal ptr array
 need not be compacted, there may be NULL pointers at
 indices below %maxindex; for example, if items have
 been removed.
 (2) When an item is added to the end of the array, it goes
 into pa-GTarray[maxindex + 1], and maxindex is then
 incremented by 1.
 (3) If there are no items in the array, this returns %maxindex = -1.
 </summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="pmaxindex">index of last item in the array;</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraGetActualCount(LeptonicaSharp.L_Ptra,System.Int32@)">
	<summary>
 Notes
 (1) The actual number of items on the ptr array, pa-GTnactual,
 will be smaller than pa-GTn if the array is not compacted.
 </summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="pcount">actual number of items on the ptr array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraGetPtrToItem(LeptonicaSharp.L_Ptra,System.Int32)">
	<summary>
 Notes
 (1) This returns a ptr to the item.  You must cast it to
 the type of item.  Do not destroy it; the item belongs
 to the Ptra.
 (2) This can access all possible items on the ptr array.
 If an item doesn't exist, it returns null.
 </summary>
	<remarks>
	</remarks>
	<param name="pa">ptra</param>
	<param name="index">of element to be retrieved</param>
	<returns>a ptr to the element, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraaCreate(System.Int32)">
	<summary>
 Notes
 (1) The ptraa is generated with a fixed size, that can not change.
 The ptra can be generated and inserted randomly into this array.
 </summary>
	<remarks>
	</remarks>
	<param name="n">size of ptr array to be alloc'd</param>
	<returns>paa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraaDestroy(LeptonicaSharp.L_Ptraa@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See ptraDestroy() for use of %freeflag and %warnflag.
 (2) To destroy the ptraa, we destroy each ptra, then the ptr array,
 then the ptraa, and then null the contents of the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="ppaa">to be nulled</param>
	<param name="freeflag">TRUE to free each remaining item in each ptra</param>
	<param name="warnflag">TRUE to warn if any remaining items are not destroyed</param>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraaGetSize(LeptonicaSharp.L_Ptraa,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="paa"></param>
	<param name="psize">size of ptr array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraaInsertPtra(LeptonicaSharp.L_Ptraa,System.Int32,LeptonicaSharp.L_Ptra)">
	<summary>
 Notes
 (1) Caller should check return value.  On success, the Ptra
 is inserted in the Ptraa and is owned by it.  However,
 on error, the Ptra remains owned by the caller.
 </summary>
	<remarks>
	</remarks>
	<param name="paa">ptraa</param>
	<param name="index">location in array for insertion</param>
	<param name="pa">to be inserted</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraaGetPtra(LeptonicaSharp.L_Ptraa,System.Int32,LeptonicaSharp.Enumerations.L_accessor__l_ptraa)">
	<summary>
 Notes
 (1) This returns the ptra ptr.  If %accessflag == L_HANDLE_ONLY,
 the ptra is left on the ptraa.  If %accessflag == L_REMOVE,
 the ptr in the ptraa is set to NULL, and the caller
 is responsible for disposing of the ptra (either putting it
 back on the ptraa, or destroying it).
 (2) This returns NULL if there is no Ptra at the index location.
 </summary>
	<remarks>
	</remarks>
	<param name="paa">ptraa</param>
	<param name="index">location in array</param>
	<param name="accessflag">L_HANDLE_ONLY, L_REMOVE</param>
	<returns>ptra at index location, or NULL on error or if there is no ptra there.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ptraaFlattenToPtra(LeptonicaSharp.L_Ptraa)">
	<summary>
 Notes
 (1) This 'flattens' the ptraa to a ptra, taking the items in
 each ptra, in order, starting with the first ptra, etc.
 (2) As a side-effect, the ptra are all removed from the ptraa
 and destroyed, leaving an empty ptraa.
 </summary>
	<remarks>
	</remarks>
	<param name="paa">ptraa</param>
	<returns>ptra, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixQuadtreeMean(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.FPixa@)">
	<summary>
 Notes
 (1) The returned fpixa has %nlevels of fpix, each containing
 the mean values at its level.  Level 0 has a
 single value; level 1 has 4 values; level 2 has 16; etc.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, no colormap</param>
	<param name="nlevels">in quadtree; max allowed depends on image size</param>
	<param name="pix_ma">input mean accumulator; can be null</param>
	<param name="pfpixa">mean values in quadtree</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixQuadtreeVariance(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Pix,LeptonicaSharp.DPix,LeptonicaSharp.FPixa@,LeptonicaSharp.FPixa@)">
	<summary>
 Notes
 (1) The returned fpixav and fpixarv have %nlevels of fpix,
 each containing at the respective levels the variance
 and root variance values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, no colormap</param>
	<param name="nlevels">in quadtree</param>
	<param name="pix_ma">input mean accumulator; can be null</param>
	<param name="dpix_msa">input mean square accumulator; can be null</param>
	<param name="pfpixa_v">variance values in quadtree</param>
	<param name="pfpixa_rv">root variance values in quadtree</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMeanInRectangle(LeptonicaSharp.Pix,LeptonicaSharp.Box,LeptonicaSharp.Pix,System.Single[]@)">
	<summary>
 Notes
 (1) This function is intended to be used for many rectangles
 on the same image.  It can find the mean within a
 rectangle in O(1), independent of the size of the rectangle.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="box">region to compute mean value</param>
	<param name="pixma">mean accumulator</param>
	<param name="pval">mean value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixVarianceInRectangle(LeptonicaSharp.Pix,LeptonicaSharp.Box,LeptonicaSharp.Pix,LeptonicaSharp.DPix,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This function is intended to be used for many rectangles
 on the same image.  It can find the variance and/or the
 square root of the variance within a rectangle in O(1),
 independent of the size of the rectangle.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="box">region to compute variance and/or root variance</param>
	<param name="pix_ma">mean accumulator</param>
	<param name="dpix_msa">mean square accumulator</param>
	<param name="pvar">variance</param>
	<param name="prvar">root variance</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.boxaaQuadtreeRegions(System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The returned boxaa has %nlevels of boxa, each containing
 the set of rectangles at that level.  The rectangle at
 level 0 is the entire region; at level 1 the region is
 divided into 4 rectangles, and at level n there are n^4
 rectangles.
 (2) At each level, the rectangles in the boxa are in "raster"
 order, with LR (fast scan) and TB (slow scan).
 </summary>
	<remarks>
	</remarks>
	<param name="w">size of pix that is being quadtree-ized</param>
	<param name="h">size of pix that is being quadtree-ized</param>
	<param name="nlevels">number of levels in quadtree</param>
	<returns>baa for quadtree regions at each level, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.quadtreeGetParent(LeptonicaSharp.FPixa,System.Int32,System.Int32@,System.Int32@,System.Single[]@)">
	<summary>
 Notes
 (1) Check return value for error.  On error, val is returned as 0.0.
 (2) The parent is located at
 level - 1
 (x/2, y/2)
 </summary>
	<remarks>
	</remarks>
	<param name="fpixa">mean, variance or root variance</param>
	<param name="level">x, y of current pixel</param>
	<param name="pval">parent pixel value, or 0.0 on error</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.quadtreeGetChildren(LeptonicaSharp.FPixa,System.Int32,System.Int32@,System.Int32@,System.Single[]@,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) Check return value for error.  On error, all return vals are 0.0.
 (2) The returned child pixels are located at
 level + 1
 (2x, 2y), (2x+1, 2y), (2x, 2y+1), (2x+1, 2y+1)
 </summary>
	<remarks>
	</remarks>
	<param name="fpixa">mean, variance or root variance</param>
	<param name="level">x, y of current pixel</param>
	<param name="pval00">four child pixel values</param>
	<param name="pval10">four child pixel values</param>
	<param name="pval01">four child pixel values</param>
	<param name="pval11">four child pixel values</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.quadtreeMaxLevels(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The criterion for maxlevels is that the subdivision not
 go down below the single pixel level.  The 1.5 factor
 is intended to keep any rectangle from accidentally
 having zero dimension due to integer truncation.
 </summary>
	<remarks>
	</remarks>
	<param name="w">dimensions of image</param>
	<param name="h">dimensions of image</param>
	<returns>maxlevels maximum number of levels allowed, or -1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fpixaDisplayQuadtree(LeptonicaSharp.FPixa,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The mean and root variance fall naturally in the 8 bpp range,
 but the variance is typically outside the range.  This
 function displays 8 bpp pix clipped to 255, so the image
 pixels will mostly be 255 (white).
 </summary>
	<remarks>
	</remarks>
	<param name="fpixa">mean, variance or root variance</param>
	<param name="factor">replication factor at lowest level</param>
	<param name="fontsize">4, ... 20</param>
	<returns>pixd 8 bpp, mosaic of quadtree images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lqueueCreate(System.Int32)">
	<summary>
 Notes
 (1) Allocates a ptr array of given size, and initializes counters.
 </summary>
	<remarks>
	</remarks>
	<param name="nalloc">size of ptr array to be alloc'd; 0 for default</param>
	<returns>lqueue, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lqueueDestroy(LeptonicaSharp.L_Queue@,System.Int32)">
	<summary>
 Notes
 (1) If freeflag is TRUE, frees each struct in the array.
 (2) If freeflag is FALSE but there are elements on the array,
 gives a warning and destroys the array.  This will
 cause a memory leak of all the items that were on the queue.
 So if the items require their own destroy function, they
 must be destroyed before the queue.  The same applies to the
 auxiliary stack, if it is used.
 (3) To destroy the L_Queue, we destroy the ptr array, then
 the lqueue, and then null the contents of the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="plq">to be nulled</param>
	<param name="freeflag">TRUE to free each remaining struct in the array</param>
</member><member name="M:LeptonicaSharp._AllFunctions.lqueueAdd(LeptonicaSharp.L_Queue,System.Object)">
	<summary>
 Notes
 (1) The algorithm is as follows.  If the queue is populated
 to the end of the allocated array, shift all ptrs toward
 the beginning of the array, so that the head of the queue
 is at the beginning of the array.  Then, if the array is
 more than 0.75 full, realloc with double the array size.
 Finally, add the item to the tail of the queue.
 </summary>
	<remarks>
	</remarks>
	<param name="lq">lqueue</param>
	<param name="item">to be added to the tail of the queue</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lqueueRemove(LeptonicaSharp.L_Queue)">
	<summary>
 Notes
 (1) If this is the last item on the queue, so that the queue
 becomes empty, nhead is reset to the beginning of the array.
 </summary>
	<remarks>
	</remarks>
	<param name="lq">lqueue</param>
	<returns>ptr to item popped from the head of the queue, or NULL if the queue is empty or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lqueueGetCount(LeptonicaSharp.L_Queue)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lq">lqueue</param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lqueuePrint(LeptonicaSharp.FILE,LeptonicaSharp.L_Queue)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="lq">lqueue</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRankFilter(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This defines, for each pixel in pixs, a neighborhood of
 pixels given by a rectangle "centered" on the pixel.
 This set of wfhf pixels has a distribution of values.
 For each component, if the values are sorted in increasing
 order, we choose the component such that rank(wfhf-1)
 pixels have a lower or equal value and
 (1-rank)(wfhf-1) pixels have an equal or greater value.
 (2) See notes in pixRankFilterGray() for further details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp; no colormap</param>
	<param name="wf">width and height of filter; each is GT= 1</param>
	<param name="hf">width and height of filter; each is GT= 1</param>
	<param name="rank">in [0.0 ... 1.0]</param>
	<returns>pixd of rank values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRankFilterRGB(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This defines, for each pixel in pixs, a neighborhood of
 pixels given by a rectangle "centered" on the pixel.
 This set of wfhf pixels has a distribution of values.
 For each component, if the values are sorted in increasing
 order, we choose the component such that rank(wfhf-1)
 pixels have a lower or equal value and
 (1-rank)(wfhf-1) pixels have an equal or greater value.
 (2) Apply gray rank filtering to each component independently.
 (3) See notes in pixRankFilterGray() for further details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="wf">width and height of filter; each is GT= 1</param>
	<param name="hf">width and height of filter; each is GT= 1</param>
	<param name="rank">in [0.0 ... 1.0]</param>
	<returns>pixd of rank values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRankFilterGray(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This defines, for each pixel in pixs, a neighborhood of
 pixels given by a rectangle "centered" on the pixel.
 This set of wfhf pixels has a distribution of values,
 and if they are sorted in increasing order, we choose
 the pixel such that rank(wfhf-1) pixels have a lower
 or equal value and (1-rank)(wfhf-1) pixels have an equal
 or greater value.
 (2) By this definition, the rank = 0.0 pixel has the lowest
 value, and the rank = 1.0 pixel has the highest value.
 (3) We add mirrored boundary pixels to avoid boundary effects,
 and put the filter center at (0, 0).
 (4) This dispatches to grayscale erosion or dilation if the
 filter dimensions are odd and the rank is 0.0 or 1.0, rsp.
 (5) Returns a copy if both wf and hf are 1.
 (6) Uses row-major or column-major incremental updates to the
 histograms depending on whether hf GT wf or hv LT= wf, rsp.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="wf">width and height of filter; each is GT= 1</param>
	<param name="hf">width and height of filter; each is GT= 1</param>
	<param name="rank">in [0.0 ... 1.0]</param>
	<returns>pixd of rank values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixMedianFilter(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp; no colormap</param>
	<param name="wf">width and height of filter; each is GT= 1</param>
	<param name="hf">width and height of filter; each is GT= 1</param>
	<returns>pixd of median values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRankFilterWithScaling(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) This is a convenience function that downscales, does
 the rank filtering, and upscales.  Because the down-
 and up-scaling functions are very fast compared to
 rank filtering, the time it takes is reduced from that
 for the simple rank filtering operation by approximately
 the square of the scaling factor.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp; no colormap</param>
	<param name="wf">width and height of filter; each is GT= 1</param>
	<param name="hf">width and height of filter; each is GT= 1</param>
	<param name="rank">in [0.0 ... 1.0]</param>
	<param name="scalefactor">scale factor; must be GT= 0.2 and LT= 0.7</param>
	<returns>pixd of rank values, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_rbtreeCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="keytype">defined by an enum for an RB_TYPE union</param>
	<returns>rbtree    container with empty ptr to the root</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_rbtreeLookup(LeptonicaSharp.L_Rbtree,LeptonicaSharp.Rb_Type)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="t">rbtree, including root node</param>
	<param name="key">find a node with this key</param>
	<returns>value     a pointer to a union, if the node exists; else NULL</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_rbtreeInsert(LeptonicaSharp.L_Rbtree,LeptonicaSharp.Rb_Type,LeptonicaSharp.Rb_Type)">
	<summary>
 Notes
 (1) If a node with the key already exists, this just updates the value.
 </summary>
	<remarks>
	</remarks>
	<param name="t">rbtree, including root node</param>
	<param name="key">insert a node with this key, if the key does not already exist in the tree</param>
	<param name="value">typically an int, used for an index</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_rbtreeDelete(LeptonicaSharp.L_Rbtree,LeptonicaSharp.Rb_Type)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="t">rbtree, including root node</param>
	<param name="key">(delete the node with this key</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_rbtreeDestroy(System.Collections.Generic.List{LeptonicaSharp.L_Rbtree})">
	<summary>
 Notes
 (1) Destroys the tree and nulls the input tree ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="pt">ptr to rbtree</param>
</member><member name="M:LeptonicaSharp._AllFunctions.l_rbtreeGetFirst(LeptonicaSharp.L_Rbtree)">
	<summary>
 Notes
 (1) This is the first node in an in-order traversal.
 </summary>
	<remarks>
	</remarks>
	<param name="t">rbtree, including root node</param>
	<returns>void</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_rbtreeGetNext(LeptonicaSharp.L_Rbtree_Node)">
	<summary>
 Notes
 (1) This finds the next node, in an in-order traversal, from
 the current node.
 (2) It is useful as an iterator for a map.
 (3) Call l_rbtreeGetFirst() to get the first node.
 </summary>
	<remarks>
	</remarks>
	<param name="n">current node</param>
	<returns>next node, or NULL if it's the last node</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_rbtreeGetLast(LeptonicaSharp.L_Rbtree)">
	<summary>
 Notes
 (1) This is the last node in an in-order traversal.
 </summary>
	<remarks>
	</remarks>
	<param name="t">rbtree, including root node</param>
	<returns>void</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_rbtreeGetPrev(LeptonicaSharp.L_Rbtree_Node)">
	<summary>
 Notes
 (1) This finds the previous node, in an in-order traversal, from
 the current node.
 (2) It is useful as an iterator for a map.
 (3) Call l_rbtreeGetLast() to get the last node.
 </summary>
	<remarks>
	</remarks>
	<param name="n">current node</param>
	<returns>next node, or NULL if it's the first node</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_rbtreeGetCount(LeptonicaSharp.L_Rbtree)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="t">rbtree</param>
	<returns>count  the number of nodes in the tree, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_rbtreePrint(LeptonicaSharp.FILE,LeptonicaSharp.L_Rbtree)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="t">rbtree</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixProcessBarcodes(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_BF,LeptonicaSharp.Enumerations.L_USE_WIS,System.Int32,LeptonicaSharp.Sarray@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="format">L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...</param>
	<param name="method">L_USE_WIDTHS, L_USE_WINDOWS</param>
	<param name="psaw">sarray of bar widths</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>sarray text of barcodes, or NULL if none found or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExtractBarcodes(LeptonicaSharp.Pix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, no colormap</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>pixa deskewed and cropped barcodes, or NULL if none found or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadBarcodes(LeptonicaSharp.Pixa,LeptonicaSharp.Enumerations.L_BF,LeptonicaSharp.Enumerations.L_USE_WIS,System.Int32,LeptonicaSharp.Sarray@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa">of 8 bpp deskewed and cropped barcodes</param>
	<param name="format">L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...</param>
	<param name="method">L_USE_WIDTHS, L_USE_WINDOWS;</param>
	<param name="psaw">sarray of bar widths</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>sa sarray of widths, one string for each barcode found, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadBarcodeWidths(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_USE_WIS,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">of 8 bpp deskewed and cropped barcode</param>
	<param name="method">L_USE_WIDTHS, L_USE_WINDOWS;</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>na numa of widths (each in set {1,2,3,4}, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixLocateBarcodes(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="thresh">for binarization of edge filter output; typ. 20</param>
	<param name="ppixb">binarized edge filtered input image</param>
	<param name="ppixm">mask over barcodes</param>
	<returns>boxa location of barcodes, or NULL if none found or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDeskewBarcode(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Box,System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) The (optional) angle returned is the angle in degrees (cw positive)
 necessary to rotate the image so that it is deskewed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image; 8 bpp</param>
	<param name="pixb">binarized edge-filtered input image</param>
	<param name="box">identified region containing barcode</param>
	<param name="margin">of extra pixels around box to extract</param>
	<param name="threshold">for binarization; ~20</param>
	<param name="pangle">in degrees, clockwise is positive</param>
	<param name="pconf">confidence</param>
	<returns>pixd deskewed barcode, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExtractBarcodeWidths1(LeptonicaSharp.Pix,System.Single,System.Single,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The widths are alternating black/white, starting with black
 and ending with black.
 (2) This method uses the widths of the bars directly, in terms
 of the (float) number of pixels between transitions.
 The histograms of these widths for black and white bars is
 generated and interpreted.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image; 8 bpp</param>
	<param name="thresh">estimated pixel threshold for crossing white LT--GT black; typ. ~120</param>
	<param name="binfract">histo binsize as a fraction of minsize; e.g., 0.25</param>
	<param name="pnaehist">histogram of black widths; NULL ok</param>
	<param name="pnaohist">histogram of white widths; NULL ok</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>nad numa of barcode widths in encoded integer units, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExtractBarcodeWidths2(LeptonicaSharp.Pix,System.Single,System.Int32,System.Single[]@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The widths are alternating black/white, starting with black
 and ending with black.
 (2) The optional best decoding window width is the width of the window
 that is used to make a decision about whether a transition occurs.
 It is approximately the average width in pixels of the narrowest
 white and black bars (i.e., those corresponding to unit width).
 (3) The optional return signal %nac is a sequence of 0s, 1s,
 and perhaps a few 2s, giving the number of crossings in each window.
 On the occasion where there is a '2', it is interpreted as
 as ending two runs the previous one and another one that has length 1.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image; 8 bpp</param>
	<param name="thresh">estimated pixel threshold for crossing white LT--GT black; typ. ~120</param>
	<param name="pwidth">best decoding window width, in pixels</param>
	<param name="pnac">number of transitions in each window</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>nad numa of barcode widths in encoded integer units, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExtractBarcodeCrossings(LeptonicaSharp.Pix,System.Single,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">input image; 8 bpp</param>
	<param name="thresh">estimated pixel threshold for crossing white LT--GT black; typ. ~120</param>
	<param name="debugflag">use 1 to generate debug output</param>
	<returns>numa of crossings, in pixel units, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaQuantizeCrossingsByWidth(LeptonicaSharp.Numa,System.Single,System.Int32,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This first computes the histogram of black and white bar widths,
 binned in appropriate units.  There should be well-defined
 peaks, each corresponding to a specific width.  The sequence
 of barcode widths (namely, the integers from the set {1,2,3,4})
 is returned.
 (2) The optional returned histograms are binned in width units
 that are inversely proportional to %binfract.  For example,
 if %binfract = 0.25, there are 4.0 bins in the distance of
 the width of the narrowest bar.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">numa of crossing locations, in pixel units</param>
	<param name="binfract">histo binsize as a fraction of minsize; e.g., 0.25</param>
	<param name="pnaehist">histo of even (black) bar widths</param>
	<param name="pnaohist">histo of odd (white) bar widths</param>
	<param name="debugflag">1 to generate plots of histograms of bar widths</param>
	<returns>nad sequence of widths, in unit sizes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.numaQuantizeCrossingsByWindow(LeptonicaSharp.Numa,System.Single,System.Int32,System.Single[]@,System.Single[]@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The minimum size of the window is set by the minimum
 distance between zero crossings.
 (2) The optional return signal %nac is a sequence of 0s, 1s,
 and perhaps a few 2s, giving the number of crossings in each window.
 On the occasion where there is a '2', it is interpreted as
 ending two runs the previous one and another one that has length 1.
 </summary>
	<remarks>
	</remarks>
	<param name="nas">numa of crossing locations</param>
	<param name="ratio">of max window size over min window size in search; typ. 2.0</param>
	<param name="pwidth">best window width</param>
	<param name="pfirstloc">center of window for first xing</param>
	<param name="pnac">array of window crossings (0, 1, 2)</param>
	<param name="debugflag">1 to generate various plots of intermediate results</param>
	<returns>nad sequence of widths, in unit sizes, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaReadFiles(System.String,System.String)">
	<summary>
 Notes
 (1) %dirname is the full path for the directory.
 (2) %substr is the part of the file name (excluding
 the directory) that is to be matched.  All matching
 filenames are read into the Pixa.  If substr is NULL,
 all filenames are read into the Pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname"></param>
	<param name="substr">substring filter on filenames; can be null</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaReadFilesSA(LeptonicaSharp.Sarray)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">full pathnames for all files</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRead(System.String)">
	<summary>
 Notes
 (1) See at top of file for supported formats.
 </summary>
	<remarks>
	</remarks>
	<param name="filename">with full pathname or in local directory</param>
	<returns>pix if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadWithHint(System.String,System.Int32)">
	<summary>
 Notes
 (1) The hint is not binding, but may be used to optimize jpeg decoding.
 Use 0 for no hinting.
 </summary>
	<remarks>
	</remarks>
	<param name="filename">with full pathname or in local directory</param>
	<param name="hint">bitwise OR of L_HINT_ values for jpeg; use 0 for no hint</param>
	<returns>pix if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadIndexed(LeptonicaSharp.Sarray,System.Int32)">
	<summary>
 Notes
 (1) This function is useful for selecting image files from a
 directory, where the integer %index is embedded into
 the file name.
 (2) This is typically done by generating the sarray using
 getNumberedPathnamesInDirectory(), so that the %index
 pathname would have the number %index in it.  The size
 of the sarray should be the largest number (plus 1) appearing
 in the file names, respecting the constraints in the
 call to getNumberedPathnamesInDirectory().
 (3) Consequently, for some indices into the sarray, there may
 be no pathnames in the directory containing that number.
 By convention, we place empty C strings ("") in those
 locations in the sarray, and it is not an error if such
 a string is encountered and no pix is returned.
 Therefore, the caller must verify that a pix is returned.
 (4) See convertSegmentedPagesToPS() in src/psio1.c for an
 example of usage.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of full pathnames</param>
	<param name="index">into pathname array</param>
	<returns>pix if OK; null if not found</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadStream(LeptonicaSharp.FILE,System.Int32)">
	<summary>
 Notes
 (1) The hint only applies to jpeg.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="hint">bitwise OR of L_HINT_ values for jpeg; use 0 for no hint</param>
	<returns>pix if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadHeader(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This reads the actual headers for jpeg, png, tiff and pnm.
 For bmp and gif, we cheat and read the entire file into a pix,
 from which we extract the "header" information.
 </summary>
	<remarks>
	</remarks>
	<param name="filename">with full pathname or in local directory</param>
	<param name="pformat">file format</param>
	<param name="pw">width and height</param>
	<param name="ph">width and height</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel 1, 3 or 4</param>
	<param name="piscmap">1 if cmap exists; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.findFileFormat(System.String,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pformat">found format</param>
	<returns>0 if OK, 1 on error or if format is not recognized</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.findFileFormatStream(LeptonicaSharp.FILE,System.Int32@)">
	<summary>
 Notes
 (1) Important Side effect -- this resets fp to BOF.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pformat">found format</param>
	<returns>0 if OK, 1 on error or if format is not recognized</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.findFileFormatBuffer(System.Byte[],System.Int32@)">
	<summary>
 Notes
 (1) This determines the file format from the first 12 bytes in
 the compressed data stream, which are stored in memory.
 (2) For tiff files, this returns IFF_TIFF.  The specific tiff
 compression is then determined using findTiffCompression().
 </summary>
	<remarks>
	</remarks>
	<param name="buf">byte buffer at least 12 bytes in size; we can't check</param>
	<param name="pformat">found format</param>
	<returns>0 if OK, 1 on error or if format is not recognized</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fileFormatIsTiff(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>1 if file is tiff; 0 otherwise or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadMem(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) This is a variation of pixReadStream(), where the data is read
 from a memory buffer rather than a file.
 (2) On windows, this only reads tiff formatted files directly from
 memory.  For other formats, it writes to a temp file and
 decompresses from file.
 (3) findFileFormatBuffer() requires up to 12 bytes to decide on
 the format.  That determines the constraint here.  But in
 fact the data must contain the entire compressed string for
 the image.
 </summary>
	<remarks>
	</remarks>
	<param name="data">const; encoded</param>
	<param name="size">size of data</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadHeaderMem(System.Byte[],System.UInt32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This reads the actual headers for jpeg, png, tiff, jp2k and pnm.
 For bmp and gif, we cheat and read all the data into a pix,
 from which we extract the "header" information.
 (2) The amount of data required depends on the format.  For
 png, it requires less than 30 bytes, but for jpeg it can
 require most of the compressed file.  In practice, the data
 is typically the entire compressed file in memory.
 (3) findFileFormatBuffer() requires up to 8 bytes to decide on
 the format, which we require.
 </summary>
	<remarks>
	</remarks>
	<param name="data">const; encoded</param>
	<param name="size">size of data</param>
	<param name="pformat">image format</param>
	<param name="pw">width and height</param>
	<param name="ph">width and height</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel 1, 3 or 4</param>
	<param name="piscmap">1 if cmap exists; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.writeImageFileInfo(System.String,LeptonicaSharp.FILE,System.Int32)">
	<summary>
 Notes
 (1) If headeronly == 0 and the image has spp == 4,this will
 also call pixDisplayLayersRGBA() to display the image
 in three views.
 (2) This is a debug function that changes the value of
 var_PNG_STRIP_16_TO_8 to 1 (the default).
 </summary>
	<remarks>
	</remarks>
	<param name="filename">input file</param>
	<param name="fpout">output file stream</param>
	<param name="headeronly">1 to read only the header; 0 to read both the header and the input file</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.ioFormatTest(System.String)">
	<summary>
 Notes
 (1) This writes and reads a set of output files losslessly
 in different formats to /tmp/format/, and tests that the
 result before and after is unchanged.
 (2) This should work properly on input images of any depth,
 with and without colormaps.
 (3) All supported formats are tested for bmp, png, tiff and
 non-ascii pnm.  Ascii pnm also works (but who'd ever want
 to use it?)   We allow 2 bpp bmp, although it's not
 supported elsewhere.  And we don't support reading
 16 bpp png, although this can be turned on in pngio.c.
 (4) This silently skips png or tiff testing if HAVE_LIBPNG
 or HAVE_LIBTIFF are 0, respectively.
 </summary>
	<remarks>
	</remarks>
	<param name="filename">input file</param>
	<returns>0 if OK; 1 on error or if the test fails</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogCreateFromRecog(LeptonicaSharp.L_Recog,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a convenience function that generates a recog using
 the unscaled training data in an existing recog.
 (2) It is recommended to use %maxyshift = 1 (the default value)
 (3) See recogCreate() for use of %scalew, %scaleh and %linew.
 </summary>
	<remarks>
	</remarks>
	<param name="recs">source recog with arbitrary input parameters</param>
	<param name="scalew">scale all widths to this; use 0 otherwise</param>
	<param name="scaleh">scale all heights to this; use 0 otherwise</param>
	<param name="linew">width of normalized strokes; use 0 to skip</param>
	<param name="threshold">for binarization; typically ~128</param>
	<param name="maxyshift">from nominal centroid alignment; default is 1</param>
	<returns>recd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogCreateFromPixa(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a convenience function for training from labeled data.
 The pixa can be read from file.
 (2) The pixa should contain the unscaled bitmaps used for training.
 (3) See recogCreate() for use of %scalew, %scaleh and %linew.
 (4) It is recommended to use %maxyshift = 1 (the default value)
 (5) All examples in the same class (i.e., with the same character
 label) should be similar.  They can be made similar by invoking
 recogRemoveOutliers[1,2]() on %pixa before calling this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of labeled, 1 bpp images</param>
	<param name="scalew">scale all widths to this; use 0 otherwise</param>
	<param name="scaleh">scale all heights to this; use 0 otherwise</param>
	<param name="linew">width of normalized strokes; use 0 to skip</param>
	<param name="threshold">for binarization; typically ~150</param>
	<param name="maxyshift">from nominal centroid alignment; default is 1</param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogCreateFromPixaNoFinish(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See recogCreateFromPixa() for details.
 (2) This is also used to generate a pixaa with templates
 in each class within a pixa.  For that, all args except for
 %pixa are ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of labeled, 1 bpp images</param>
	<param name="scalew">scale all widths to this; use 0 otherwise</param>
	<param name="scaleh">scale all heights to this; use 0 otherwise</param>
	<param name="linew">width of normalized strokes; use 0 to skip</param>
	<param name="threshold">for binarization; typically ~150</param>
	<param name="maxyshift">from nominal centroid alignment; default is 1</param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogCreate(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If %scalew == 0 and %scaleh == 0, no scaling is done.
 If one of these is 0 and the other is GT 0, scaling is isotropic
 to the requested size.  We typically do not set both GT 0.
 (2) Use linew GT 0 to convert the templates to images with fixed
 width strokes.  linew == 0 skips the conversion.
 (3) The only valid values for %maxyshift are 0, 1 and 2.
 It is recommended to use %maxyshift == 1 (default value).
 Using %maxyshift == 0 is much faster than %maxyshift == 1, but
 it is much less likely to find the template with the best
 correlation.  Use of anything but 1 results in a warning.
 (4) Scaling is used for finding outliers and for training a
 book-adapted recognizer (BAR) from a bootstrap recognizer (BSR).
 Scaling the height to a fixed value and scaling the width
 accordingly (e.g., %scaleh = 40, %scalew = 0) is recommended.
 (5) The storage for most of the arrays is allocated when training
 is finished.
 </summary>
	<remarks>
	</remarks>
	<param name="scalew">scale all widths to this; use 0 otherwise</param>
	<param name="scaleh">scale all heights to this; use 0 otherwise</param>
	<param name="linew">width of normalized strokes; use 0 to skip</param>
	<param name="threshold">for binarization; typically ~128; 0 for default</param>
	<param name="maxyshift">from nominal centroid alignment; default is 1</param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogDestroy(LeptonicaSharp.L_Recog@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="precog">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp._AllFunctions.recogGetCount(LeptonicaSharp.L_Recog)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>count of classes in recog; 0 if no recog or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogSetParams(LeptonicaSharp.L_Recog,System.Int32,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) This is called when a recog is created.
 (2) Default %min_nopad value allows for some padding.
 To disable padding, set %min_nopad = 0.  To pad only when
 no samples are available for the class, set %min_nopad = 1.
 (3) The %max_wh_ratio limits the width/height ratio for components
 that we attempt to split.  Splitting long components is expensive.
 (4) The %max_ht_ratio is a quality requirement on the training data.
 The recognizer will not run if the averages are computed and
 the templates do not satisfy it.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">to be padded, if necessary</param>
	<param name="type">type of char set; -1 for default; see enum in recog.h</param>
	<param name="min_nopad">min number in a class without padding; use -1 for default</param>
	<param name="max_wh_ratio">max width/height ratio allowed for splitting; use -1.0 for default</param>
	<param name="max_ht_ratio">max of max/min averaged template height ratio; use -1.0 for default</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogGetClassIndex(LeptonicaSharp.L_Recog,System.Int32,System.String,System.Int32@)">
	<summary>
 Notes
 (1) This is used during training.  There is one entry in
 recog-GTdna_tochar (integer value, e.g., ascii) and
 one in recog-GTsa_text (e.g, ascii letter in a string)
 for each character class.
 (2) This searches the dna character array for %val.  If it is
 not found, the template represents a character class not
 already seen it increments setsize (the number of character
 classes) by 1, and augments both the index (dna_tochar)
 and text (sa_text) arrays.
 (3) Returns the index in index, except on error.
 (4) Caller must check the function return value.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with LUT's pre-computed</param>
	<param name="val">integer value; can be up to 3 bytes for UTF-8</param>
	<param name="text">text from which %val was derived; used if not found</param>
	<param name="pindex">index into dna_tochar</param>
	<returns>0 if found; 1 if not found and added; 2 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogStringToIndex(LeptonicaSharp.L_Recog,System.String,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="text">text string for some class</param>
	<param name="pindex">index for that class; -1 if not found</param>
	<returns>0 if OK, 1 on error not finding the string is an error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogGetClassString(LeptonicaSharp.L_Recog,System.Int32,System.String[]@)">
	<summary>
 Notes
 (1) Extracts a copy of the string from sa_text, which
 the caller must free.
 (2) Caller must check the function return value.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="index">into array of char types</param>
	<param name="pcharstr">string representation; returns an empty string on error</param>
	<returns>0 if found, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_convertCharstrToInt(System.String,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="str">input string representing one UTF-8 character; not more than 4 bytes</param>
	<param name="pval">integer value for the input.  Think of it as a 1-to-1 hash code.</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogRead(System.String)">
	<summary>
 Notes
 (1) When a recog is serialized, a pixaa of the templates that are
 actually used for correlation is saved in the pixaa_u array
 of the recog.  These can be different from the templates that
 were used to generate the recog, because those original templates
 can be scaled and turned into normalized lines.  When recog1
 is deserialized to recog2, these templates are put in both the
 unscaled array (pixaa_u) and the modified array (pixaa) in recog2.
 Why not put it in only the unscaled array and let
 recogTrainingFinalized() regenerate the modified templates?
 The reason is that with normalized lines, the operation of
 thinning to a skeleton and dilating back to a fixed width
 is not idempotent.  Thinning to a skeleton saves pixels at
 the end of a line segment, and thickening the skeleton puts
 additional pixels at the end of the lines.  This tends to
 close gaps.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization of recog (not ascii)</param>
	<param name="size">of data in bytes</param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogWrite(System.String,LeptonicaSharp.L_Recog)">
	<summary>
 Notes
 (1) The pixaa of templates that is written is the modified one
 in the pixaa field. It is the pixaa that is actually used
 for correlation. This is not the unscaled array of labeled
 bitmaps, in pixaa_u, that was used to generate the recog in the
 first place.  See the notes in recogRead() for the rationale.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="recog"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.L_Recog)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for "wb"</param>
	<param name="recog"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.L_Recog)">
	<summary>
 Notes
 (1) Serializes a recog in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized recog (not ascii)</param>
	<param name="psize">size of returned data</param>
	<param name="recog"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogExtractPixa(LeptonicaSharp.L_Recog)">
	<summary>
 Notes
 (1) This generates a pixa of all the unscaled images in the
 recognizer, where each one has its character class label in
 the pix text field, by flattening pixaa_u to a pixa.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>pixa if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogDecode(LeptonicaSharp.L_Recog,LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) The input pixs has been filtered so that it is likely to be
 composed of more than one touching character.  Specifically,
 its height can only slightly exceed that of the tallest
 unscaled template, the width is somewhat larger than the
 width of the widest unscaled template, and the w/h aspect ratio
 is bounded by max_wh_ratio.
 (2) This uses the DID mechanism with labeled templates to
 segment the input %pixs.  The resulting segmentation is
 returned.  (It is given by did-GTboxa).
 (3) In debug mode, the Viterbi path is rescored based on all
 the templates.  In non-debug mode, the same procedure is
 carried out by recogIdentifyPix() on the result of the
 segmentation.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with LUT's pre-computed</param>
	<param name="pixs">typically of multiple touching characters, 1 bpp</param>
	<param name="nlevels">of templates; 2 for now</param>
	<param name="ppixdb">debug result; can be null</param>
	<returns>boxa  segmentation of pixs into characters, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogCreateDid(LeptonicaSharp.L_Recog,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pixs">of 1 bpp image to match</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogDestroyDid(LeptonicaSharp.L_Recog)">
	<summary>
 Notes
 (1) As the signature indicates, this is owned by the recog, and can
 only be destroyed using this function.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogDidExists(LeptonicaSharp.L_Recog)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>1 if recog-GTdid exists; 0 if not or on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogGetDid(LeptonicaSharp.L_Recog)">
	<summary>
 Notes
 (1) This also makes sure the arrays are defined.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>did still owned by the recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogSetChannelParams(LeptonicaSharp.L_Recog,System.Int32)">
	<summary>
 Notes
 (1) This converts the independent bit-flip probabilities in the
 "channel" into log-likelihood coefficients on image sums.
 These coefficients are only defined for the non-background
 template levels.  Thus for nlevels = 2 (one fg, one bg),
 only beta[1] and gamma[1] are used.  For nlevels = 4 (three
 fg templates), we use beta[1-3] and gamma[1-3].
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="nlevels"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogIdentifyMultiple(LeptonicaSharp.L_Recog,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Boxa@,LeptonicaSharp.Pixa@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This filters the input pixa and calls recogIdentifyPixa()
 (2) Splitting is relatively slow, because it tries to match all
 character templates to all locations.  This step can be skipped.
 (3) An attempt is made to order the (optionally) returned images
 and boxes in 2-dimensional sorted order.  These can then
 be used to aggregate identified characters into numbers or words.
 One typically wants the pixa, which contains a boxa of the
 extracted subimages.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with training finished</param>
	<param name="pixs">containing typically a small number of characters</param>
	<param name="minh">remove shorter components; use 0 for default</param>
	<param name="skipsplit">1 to skip the splitting step</param>
	<param name="pboxa">locations of identified components</param>
	<param name="ppixa">images of identified components</param>
	<param name="ppixdb">debug pix inputs and best fits</param>
	<param name="debugsplit">1 returns pix split debugging images</param>
	<returns>0 if OK; 1 if nothing is found; 2 for other errors.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogSplitIntoCharacters(LeptonicaSharp.L_Recog,LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Boxa@,LeptonicaSharp.Pixa@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This can be given an image that has an arbitrary number
 of text characters.  It optionally splits connected
 components based on document image decoding in recogDecode().
 The returned pixa includes the boxes from which the
 (possibly split) components are extracted.
 (2) After noise filtering, the resulting components are put in
 row-major (2D) order, and the smaller of overlapping
 components are removed if they satisfy conditions of
 relative size and fractional overlap.
 (3) Note that the splitting function uses unscaled templates
 and does not bother returning the class results and scores.
 These are more accurately found later using the scaled templates.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pixs">1 bpp, contains only mostly deskewed text</param>
	<param name="minh">remove shorter components; use 0 for default</param>
	<param name="skipsplit">1 to skip the splitting step</param>
	<param name="pboxa">character bounding boxes</param>
	<param name="ppixa">character images</param>
	<param name="debug">1 for results written to pixadb_split</param>
	<returns>0 if OK, 1 on error or if no components are returned</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogCorrelationBestRow(LeptonicaSharp.L_Recog,LeptonicaSharp.Pix,LeptonicaSharp.Boxa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Sarray@,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) Supervises character matching for (in general) a c.c with
 multiple touching characters.  Finds the best match greedily.
 Rejects small parts that are left over after splitting.
 (2) Matching is to the average, and without character scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with LUT's pre-computed</param>
	<param name="pixs">typically of multiple touching characters, 1 bpp</param>
	<param name="pboxa">bounding boxs of best fit character</param>
	<param name="pnascore">correlation scores</param>
	<param name="pnaindex">indices of classes</param>
	<param name="psachar">array of character strings</param>
	<param name="debug">1 for results written to pixadb_split</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogCorrelationBestChar(LeptonicaSharp.L_Recog,LeptonicaSharp.Pix,LeptonicaSharp.Box@,System.Single[]@,System.Int32@,System.String[]@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) Basic matching character splitter.  Finds the best match among
 all templates to some region of the image.  This can result
 in splitting the image into two parts.  This is "image decoding"
 without dynamic programming, because we don't use a setwidth
 and compute the best matching score for the entire image.
 (2) Matching is to the average templates, without character scaling.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with LUT's pre-computed</param>
	<param name="pixs">can be of multiple touching characters, 1 bpp</param>
	<param name="pbox">bounding box of best fit character</param>
	<param name="pscore">correlation score</param>
	<param name="pindex">index of class</param>
	<param name="pcharstr">character string of class</param>
	<param name="ppixdb">debug pix showing input and best fit</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogIdentifyPixa(LeptonicaSharp.L_Recog,LeptonicaSharp.Pixa,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This should be called by recogIdentifyMuliple(), which
 binarizes and splits characters before sending %pixa here.
 (2) This calls recogIdentifyPix(), which does the same operation
 on each pix in %pixa, and optionally returns the arrays
 of results (scores, class index and character string)
 for the best correlation match.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pixa">of 1 bpp images to match</param>
	<param name="ppixdb">pix showing inputs and best fits</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogIdentifyPix(LeptonicaSharp.L_Recog,LeptonicaSharp.Pix,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) Basic recognition function for a single character.
 (2) If templ_use == L_USE_ALL_TEMPLATES, which is the default
 situation, matching is attempted to every bitmap in the recog,
 and the identify of the best match is returned.
 (3) For finding outliers, templ_use == L_USE_AVERAGE_TEMPLATES, and
 matching is only attemplted to the averaged bitmaps.  For this
 case, the index of the bestsample is meaningless (0 is returned
 if requested).
 (4) The score is related to the confidence (probability of correct
 identification), in that a higher score is correlated with
 a higher probability.  However, the actual relation between
 the correlation (score) and the probability is not known;
 we call this a "score" because "confidence" can be misinterpreted
 as an actual probability.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with LUT's pre-computed</param>
	<param name="pixs">of a single character, 1 bpp</param>
	<param name="ppixdb">debug pix showing input and best fit</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogSkipIdentify(LeptonicaSharp.L_Recog)">
	<summary>
 Notes
 (1) This just writes a "dummy" result with 0 score and empty
 string id into the rch.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.rchaDestroy(LeptonicaSharp.L_Rcha@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="prcha">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.rchDestroy(LeptonicaSharp.L_Rch@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="prch">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.rchaExtract(LeptonicaSharp.L_Rcha,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Sarray@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This returns clones of the number and string arrays.  They must
 be destroyed by the caller.
 </summary>
	<remarks>
	</remarks>
	<param name="rcha"></param>
	<param name="pnaindex">indices of best templates</param>
	<param name="pnascore">correl scores of best templates</param>
	<param name="psatext">character strings of best templates</param>
	<param name="pnasample">indices of best samples</param>
	<param name="pnaxloc">x-locations of templates</param>
	<param name="pnayloc">y-locations of templates</param>
	<param name="pnawidth">widths of best templates</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.rchExtract(LeptonicaSharp.L_Rch,System.Int32@,System.Single[]@,System.String[]@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="rch"></param>
	<param name="pindex">index of best template</param>
	<param name="pscore">correlation score of best template</param>
	<param name="ptext">character string of best template</param>
	<param name="psample">index of best sample</param>
	<param name="pxloc">x-location of template</param>
	<param name="pyloc">y-location of template</param>
	<param name="pwidth">width of best template</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogProcessToIdentify(LeptonicaSharp.L_Recog,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This is a lightweight operation to insure that the input
 image is 1 bpp, properly cropped, and padded on each side.
 If bpp GT 1, the image is thresholded.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">with LUT's pre-computed</param>
	<param name="pixs">typ. single character, possibly d GT 1 and uncropped</param>
	<param name="pad">extra pixels added to left and right sides</param>
	<returns>pixd 1 bpp, clipped to foreground, or NULL if there are no fg pixels or on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogExtractNumbers(LeptonicaSharp.L_Recog,LeptonicaSharp.Boxa,System.Single,System.Int32,LeptonicaSharp.Boxaa@,LeptonicaSharp.Numaa@)">
	<summary>
 Notes
 (1) This extracts digit data after recogaIdentifyMultiple() or
 lower-level identification has taken place.
 (2) Each string in the returned sa contains a sequence of ascii
 digits in a number.
 (3) The horizontal distance between boxes (limited by %spacethresh)
 is the negative of the horizontal overlap.
 (4) Components with a score less than %scorethresh, which may
 be hyphens or other small characters, will signal the
 end of the current sequence of digits in the number.  A typical
 value for %scorethresh is 0.60.
 (5) We allow two digits to be combined if these conditions apply
 (a) the first is to the left of the second
 (b) the second has a horizontal separation less than %spacethresh
 (c) the vertical overlap GT= 0 (vertical separation LT 0)
 (d) both have a score that exceeds %scorethresh
 (6) Each numa in the optionally returned naa contains the digit
 scores of a number.  Each boxa in the optionally returned baa
 contains the bounding boxes of the digits in the number.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="boxas">location of components</param>
	<param name="scorethresh">min score for which we accept a component</param>
	<param name="spacethresh">max horizontal distance allowed between digits, use -1 for default</param>
	<param name="pbaa">bounding boxes of identified numbers</param>
	<param name="pnaa">scores of identified digits</param>
	<returns>sa of identified numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.showExtractNumbers(LeptonicaSharp.Pix,LeptonicaSharp.Sarray,LeptonicaSharp.Boxaa,LeptonicaSharp.Numaa,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This is a debugging routine on digit identification; e.g.
 recogIdentifyMultiple(recog, pixs, 0, 1, boxa, NULL, NULL, 0);
 sa = recogExtractNumbers(recog, boxa, 0.8, -1, baa, naa);
 pixa = showExtractNumbers(pixs, sa, baa, naa, NULL);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input 1 bpp image</param>
	<param name="sa">recognized text strings</param>
	<param name="baa">boxa array for location of characters in each string</param>
	<param name="naa">numa array for scores of characters in each string</param>
	<param name="ppixdb">input pixs with identified chars outlined</param>
	<returns>pixa   of identified strings with text and scores, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogTrainLabeled(LeptonicaSharp.L_Recog,LeptonicaSharp.Pix,LeptonicaSharp.Box,System.String,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) Training is restricted to the addition of a single
 character in an arbitrary (e.g., UTF8) charset
 (2) If box != null, it should represent the location in %pixs
 of the character image.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">in training mode</param>
	<param name="pixs">if depth GT 1, will be thresholded to 1 bpp</param>
	<param name="box">cropping box</param>
	<param name="text">if null, use text field in pix</param>
	<param name="debug">1 to display images of samples not captured</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogProcessLabeled(LeptonicaSharp.L_Recog,LeptonicaSharp.Pix,LeptonicaSharp.Pix@,LeptonicaSharp.Box,System.String)">
	<summary>
 Notes
 (1) This crops and binarizes the input image, generating a pix
 of one character where the charval is inserted into the pix.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">in training mode</param>
	<param name="pixs">if depth GT 1, will be thresholded to 1 bpp</param>
	<param name="box">cropping box</param>
	<param name="text">if null, use text field in pix</param>
	<param name="ppix">addr of pix, 1 bpp, labeled</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogAddSample(LeptonicaSharp.L_Recog,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) The pix is 1 bpp, with the character string label embedded.
 (2) The pixaa_u array of the recog is initialized to accept
 up to 256 different classes.  When training is finished,
 the arrays are truncated to the actual number of classes.
 To pad an existing recog from the boot recognizers, training
 is started again; if samples from a new class are added,
 the pixaa_u array is extended by adding a pixa to hold them.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pix">a single character, 1 bpp</param>
	<param name="debug"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogModifyTemplate(LeptonicaSharp.L_Recog,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pixs">1 bpp, to be optionally scaled and turned into strokes of fixed width</param>
	<returns>pixd   modified pix if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogAverageSamples(System.Collections.Generic.List{LeptonicaSharp.L_Recog},LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This is only called in two situations
 (a) When splitting characters using either the DID method
 recogDecode() or the the greedy splitter
 recogCorrelationBestRow()
 (b) By a special recognizer that is used to remove outliers.
 Both unscaled and scaled inputs are averaged.
 (2) If the data in any class is nonexistent (no samples), or
 very bad (no fg pixels in the average), or if the ratio
 of max/min average unscaled class template heights is
 greater than max_ht_ratio, this destroys the recog.
 The caller must check the return value of the recog.
 (3) Set debug = 1 to view the resulting templates and their centroids.
 </summary>
	<remarks>
	</remarks>
	<param name="precog">addr of existing recog; may be destroyed</param>
	<param name="debug"></param>
	<returns>0 on success, 1 on failure</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaAccumulateSamples(LeptonicaSharp.Pixa,LeptonicaSharp.Pix@,LeptonicaSharp.Pta,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This generates an aligned (by centroid) sum of the input pix.
 (2) We use only the first 256 samples; that's plenty.
 (3) If pta is not input, we generate two tables, and discard
 after use.  If this is called many times, it is better
 to precompute the pta.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of samples from the same class, 1 bpp</param>
	<param name="pta">of centroids of the samples</param>
	<param name="ppixd">accumulated samples, 8 bpp</param>
	<param name="px">average x coordinate of centroids</param>
	<param name="py">average y coordinate of centroids</param>
	<returns>0 on success, 1 on failure</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogTrainingFinished(System.Collections.Generic.List{LeptonicaSharp.L_Recog},System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This must be called after all training samples have been added.
 (2) If the templates are not good enough, the recog input is destroyed.
 (3) Usually, %modifyflag == 1, because we want to apply
 recogModifyTemplate() to generate the actual templates
 that will be used.  The one exception is when reading a
 serialized recog there we want to put the same set of
 templates in both the unscaled and modified pixaa.
 See recogReadStream() to see why we do this.
 (4) See recogTemplatesAreOK() for %minsize and %minfract usage.
 (5) The following things are done here
 (a) Allocate (or reallocate) storage for (possibly) modified
 bitmaps, centroids, and fg areas.
 (b) Generate the (possibly) modified bitmaps.
 (c) Compute centroid and fg area data for both unscaled and
 modified bitmaps.
 (d) Truncate the pixaa, ptaa and numaa arrays down from
 256 to the actual size.
 (6) Putting these operations here makes it simple to recompute
 the recog with different modifications on the bitmaps.
 (7) Call recogShowContent() to display the templates, both
 unscaled and modified.
 </summary>
	<remarks>
	</remarks>
	<param name="precog">addr of recog</param>
	<param name="modifyflag">1 to use recogModifyTemplate(); 0 otherwise</param>
	<param name="minsize">set to -1 for default</param>
	<param name="minfract">set to -1.0 for default</param>
	<returns>0 if OK, 1 on error (input recog will be destroyed)</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogFilterPixaBySize(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Single,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) The basic assumption is that the most common and larger
 templates in each class are more likely to represent the
 characters we are interested in.  For example, larger digits
 are more likely to represent page numbers, and smaller digits
 could be data in tables.  Therefore, we bias the first
 stage of filtering toward the larger characters by removing
 very small ones, and select based on proximity of the
 remaining characters to median height.
 (2) For each of the %setsize classes, order the templates
 increasingly by height.  Take the rank 0.9 height.  Eliminate
 all templates that are shorter by more than %max_ht_ratio.
 Of the remaining ones, select up to %maxkeep that are closest
 in rank order height to the median template.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">labeled templates</param>
	<param name="setsize">size of character set (number of classes)</param>
	<param name="maxkeep">max number of templates to keep in a class</param>
	<param name="max_ht_ratio">max allowed height ratio (see below)</param>
	<param name="pna">debug output, giving the number in each class after filtering; use NULL to skip</param>
	<returns>pixa   filtered templates, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogSortPixaByClass(LeptonicaSharp.Pixa,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixa">labeled templates</param>
	<param name="setsize">size of character set (number of classes)</param>
	<returns>paa   pixaa where each pixa has templates for one class, or null on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogRemoveOutliers1(System.Collections.Generic.List{LeptonicaSharp.L_Recog},System.Single,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This is a convenience wrapper when using default parameters
 for the recog.  See pixaRemoveOutliers1() for details.
 (2) If this succeeds, the new recog replaces the input recog;
 if it fails, the input recog is destroyed.
 </summary>
	<remarks>
	</remarks>
	<param name="precog">addr of recog with unscaled labeled templates</param>
	<param name="minscore">keep everything with at least this score</param>
	<param name="mintarget">minimum desired number to retain if possible</param>
	<param name="minsize">minimum number of samples required for a class</param>
	<param name="ppixsave">saved templates, with scores</param>
	<param name="ppixrem">removed templates, with scores</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaRemoveOutliers1(LeptonicaSharp.Pixa,System.Single,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) Removing outliers is particularly important when recognition
 goes against all the samples in the training set, as opposed
 to the averages for each class.  The reason is that we get
 an identification error if a mislabeled template is a best
 match for an input sample.
 (2) Because the score values depend strongly on the quality
 of the character images, to avoid losing too many samples
 we supplement a minimum score for retention with a score
 necessary to acquire the minimum target number of templates.
 To do this we are willing to use a lower threshold,
 LOWER_SCORE_THRESHOLD, on the score.  Consequently, with
 poor quality templates, we may keep samples with a score
 less than %minscore, but never less than LOWER_SCORE_THRESHOLD.
 And if the number of samples is less than %minsize, we do
 not use any.
 (3) This is meant to be used on a BAR, where the templates all
 come from the same book; use minscore ~0.75.
 (4) Method make a scaled recog from the input %pixas.  Then,
 for each class generate the averages, match each
 scaled template against the average, and save unscaled
 templates that had a sufficiently good match.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">unscaled labeled templates</param>
	<param name="minscore">keep everything with at least this score; use -1.0 for default.</param>
	<param name="mintarget">minimum desired number to retain if possible; use -1 for default.</param>
	<param name="minsize">minimum number of samples required for a class; use -1 for default.</param>
	<param name="ppixsave">saved templates, with scores</param>
	<param name="ppixrem">removed templates, with scores</param>
	<returns>pixa   of unscaled templates to be kept, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogRemoveOutliers2(System.Collections.Generic.List{LeptonicaSharp.L_Recog},System.Single,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This is a convenience wrapper when using default parameters
 for the recog.  See pixaRemoveOutliers2() for details.
 (2) If this succeeds, the new recog replaces the input recog;
 if it fails, the input recog is destroyed.
 </summary>
	<remarks>
	</remarks>
	<param name="precog">addr of recog with unscaled labeled templates</param>
	<param name="minscore">keep everything with at least this score</param>
	<param name="minsize">minimum number of samples required for a class</param>
	<param name="ppixsave">saved templates, with scores</param>
	<param name="ppixrem">removed templates, with scores</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaRemoveOutliers2(LeptonicaSharp.Pixa,System.Single,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) Removing outliers is particularly important when recognition
 goes against all the samples in the training set, as opposed
 to the averages for each class.  The reason is that we get
 an identification error if a mislabeled template is a best
 match for an input sample.
 (2) This method compares each template against the average templates
 of each class, and discards any template that has a higher
 correlation to a class different from its own.  It also
 sets a lower bound on correlation scores with its class average.
 (3) This is meant to be used on a BAR, where the templates all
 come from the same book; use minscore ~0.75.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">unscaled labeled templates</param>
	<param name="minscore">keep everything with at least this score; use -1.0 for default.</param>
	<param name="minsize">minimum number of samples required for a class; use -1 for default.</param>
	<param name="ppixsave">saved templates, with scores</param>
	<param name="ppixrem">removed templates, with scores</param>
	<returns>pixa   of unscaled templates to be kept, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogTrainFromBoot(LeptonicaSharp.L_Recog,LeptonicaSharp.Pixa,System.Single,System.Int32,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This takes %pixas of unscaled single characters and %recboot,
 a bootstrep recognizer (BSR) that has been set up with parameters
 scaleh scale all templates to this height
 linew width of normalized strokes, or 0 if using
 the input image
 It modifies the pix in %pixas accordingly and correlates
 with the templates in the BSR.  It returns those input
 images in %pixas whose best correlation with the BSR is at
 or above %minscore.  The returned pix have added text labels
 for the text string of the class to which the best
 correlated template belongs.
 (2) Identification occurs in scaled mode (typically with h = 40),
 optionally using a width-normalized line images derived
 from those in %pixas.
 </summary>
	<remarks>
	</remarks>
	<param name="recogboot">labeled boot recognizer</param>
	<param name="pixas">set of unlabeled input characters</param>
	<param name="minscore">min score for accepting the example; e.g., 0.75</param>
	<param name="threshold">for binarization, if needed</param>
	<param name="debug">1 for debug output saved to recogboot; 0 otherwise</param>
	<returns>pixad   labeled version of input pixas, trained on a BSR, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogPadDigitTrainingSet(LeptonicaSharp.L_Recog@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a no-op if padding is not needed.  However,
 if it is, this replaces the input recog with a new recog,
 padded appropriately with templates from a boot recognizer,
 and set up with correlation templates derived from
 %scaleh and %linew.
 </summary>
	<remarks>
	</remarks>
	<param name="precog">trained; if padding is needed, it is replaced by a a new padded recog</param>
	<param name="scaleh">must be GT 0; suggest ~40.</param>
	<param name="linew">use 0 for original scanned images</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogIsPaddingNeeded(LeptonicaSharp.L_Recog,LeptonicaSharp.Sarray@)">
	<summary>
 Notes
 (1) This returns a string array in sa containing character values
 for which extra templates are needed; this sarray is
 used by recogGetPadTemplates().  It returns NULL
 if no padding templates are needed.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">trained</param>
	<param name="psa">addr of returned string containing text value</param>
	<returns>1 on error; 0 if OK, whether or not additional padding templates are required.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogAddDigitPadTemplates(LeptonicaSharp.L_Recog,LeptonicaSharp.Sarray)">
	<summary>
 Notes
 (1) Call recogIsPaddingNeeded() first, which returns %sa of
 template text strings for classes where more templates
 are needed.
 </summary>
	<remarks>
	</remarks>
	<param name="recog">trained</param>
	<param name="sa">set of text strings that need to be padded</param>
	<returns>pixa   of all templates from %recog and the additional pad templates from a boot recognizer; or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogMakeBootDigitRecog(System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) This takes a set of pre-computed, labeled pixa of single
 digits, and generates a recognizer where the character templates
 that will be used are derived from the boot-generated pixa
 - extending by replicating the set with different widths,
 keeping the height the same
 - scaling (isotropically to fixed height)
 - optionally generating a skeleton and thickening so that
 all strokes have the same width.
 (2) The resulting templates are scaled versions of either the
 input bitmaps or images with fixed line widths.  To use the
 input bitmaps, set %linew = 0; otherwise, set %linew to the
 desired line width.
 </summary>
	<remarks>
	</remarks>
	<param name="scaleh">scale all heights to this; typ. use 40</param>
	<param name="linew">normalized line width; typ. use 5; 0 to skip</param>
	<param name="maxyshift">from nominal centroid alignment; typically 0 or 1</param>
	<param name="debug">1 for showing templates; 0 otherwise</param>
	<returns>recog, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogMakeBootDigitTemplates(LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) See recogMakeBootDigitRecog().
 </summary>
	<remarks>
	</remarks>
	<param name="debug">1 for display of templates</param>
	<returns>pixa   of templates; or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogShowContent(LeptonicaSharp.FILE,LeptonicaSharp.L_Recog,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file  stream</param>
	<param name="recog"></param>
	<param name="index">for naming of output files of template images</param>
	<param name="display">1 for showing template images, 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogDebugAverages(System.Collections.Generic.List{LeptonicaSharp.L_Recog},LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) Generates an image that pairs each of the input images used
 in training with the average template that it is best
 correlated to.  This is written into the recog.
 (2) It also generates pixa_tr of all the input training images,
 which can be used, e.g., in recogShowMatchesInRange().
 (3) Destroys the recog if the averaging function finds any bad classes.
 </summary>
	<remarks>
	</remarks>
	<param name="precog">addr of recog</param>
	<param name="debug">0 no output; 1 for images; 2 for text; 3 for both</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogShowAverageTemplates(LeptonicaSharp.L_Recog)">
	<summary>
 Notes
 (1) This debug routine generates a display of the averaged templates,
 both scaled and unscaled, with the centroid visible in red.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<returns>0 on success, 1 on failure</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogShowMatchesInRange(LeptonicaSharp.L_Recog,LeptonicaSharp.Pixa,System.Single,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This gives a visual output of the best matches for a given
 range of scores.  Each pair of images can optionally be
 labeled with the index of the best match and the correlation.
 (2) To use this, save a set of 1 bpp images (labeled or
 unlabeled) that can be given to a recognizer in a pixa.
 Then call this function with the pixa and parameters
 to filter a range of scores.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pixa">of 1 bpp images to match</param>
	<param name="minscore">range to include output</param>
	<param name="maxscore">range to include output</param>
	<param name="display">to display the result</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.recogShowMatch(LeptonicaSharp.L_Recog,LeptonicaSharp.Pix,System.Int32,System.Single,LeptonicaSharp.Pix,LeptonicaSharp.Box)">
	<summary>
 Notes
 (1) pix1 can be one of these
 (a) The input pix alone, which can be either a single character
 (box == NULL) or several characters that need to be
 segmented.  If more than character is present, the box
 region is displayed with an outline.
 (b) Both the input pix and the matching template.  In this case,
 pix2 and box will both be null.
 (2) If the bmf has been made (by a call to recogMakeBmf())
 and the index GT= 0, the text field, match score and index
 will be rendered; otherwise their values will be ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="recog"></param>
	<param name="pix1">input pix; several possibilities</param>
	<param name="pix2">matching template</param>
	<param name="box">region in pix1 for which pix2 matches</param>
	<param name="index">index of matching template; use -1 to disable printing</param>
	<param name="score">score of match</param>
	<returns>pixd pair of images, showing input pix and best template, optionally with matching information, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.regTestSetup(System.Int32,System.String[],LeptonicaSharp.L_RegParams@)">
	<summary>
 Notes
 (1) Call this function with the args to the reg test.  The first arg
 is the name of the reg test.  There are three cases
 Case 1
 There is either only one arg, or the second arg is "compare".
 This is the mode in which you run a regression test
 (or a set of them), looking for failures and logging
 the results to a file.  The output, which includes
 logging of all reg test failures plus a SUCCESS or
 FAILURE summary for each test, is appended to the file
 "/tmp/lept/reg_results.txt.  For this case, as in Case 2,
 the display field in rp is set to FALSE, preventing
 image display.
 Case 2
 The second arg is "generate".  This will cause
 generation of new golden files for the reg test.
 The results of the reg test are not recorded, and
 the display field in rp is set to FALSE.
 Case 3
 The second arg is "display".  The test will run and
 files will be written.  Comparisons with golden files
 will not be carried out, so the only notion of success
 or failure is with tests that do not involve golden files.
 The display field in rp is TRUE, and this is used by
 pixDisplayWithTitle().
 (2) See regutils.h for examples of usage.
 </summary>
	<remarks>
	</remarks>
	<param name="argc">from invocation; can be either 1 or 2</param>
	<param name="argv">to regtest %argv[1] is one of these "generate", "compare", "display"</param>
	<param name="prp">all regression params</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.regTestCleanup(LeptonicaSharp.L_RegParams)">
	<summary>
 Notes
 (1) This copies anything written to the temporary file to the
 output file /tmp/lept/reg_results.txt.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regression test parameters</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.regTestCompareValues(LeptonicaSharp.L_RegParams,System.Single,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="val1">typ. the golden value</param>
	<param name="val2">typ. the value computed</param>
	<param name="delta">allowed max absolute difference</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.regTestCompareStrings(LeptonicaSharp.L_RegParams,System.Byte[],System.UInt32,System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="string1">typ. the expected string</param>
	<param name="bytes1">size of string1</param>
	<param name="string2">typ. the computed string</param>
	<param name="bytes2">size of string2</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.regTestComparePix(LeptonicaSharp.L_RegParams,LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This function compares two pix for equality.  On failure,
 this writes to stderr.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="pix1">to be tested for equality</param>
	<param name="pix2">to be tested for equality</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.regTestCompareSimilarPix(LeptonicaSharp.L_RegParams,LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Single,System.Int32)">
	<summary>
 Notes
 (1) This function compares two pix for near equality.  On failure,
 this writes to stderr.
 (2) The pix are similar if the fraction of non-conforming pixels
 does not exceed %maxfract.  Pixels are non-conforming if
 the difference in pixel values equals or exceeds %mindiff.
 Typical values might be %mindiff = 15 and %maxfract = 0.01.
 (3) The input images must have the same size and depth.  The
 pixels for comparison are typically subsampled from the images.
 (4) Normally, use %printstats = 0.  In debugging mode, to see
 the relation between %mindiff and the minimum value of
 %maxfract for success, set this to 1.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="pix1">to be tested for near equality</param>
	<param name="pix2">to be tested for near equality</param>
	<param name="mindiff">minimum pixel difference to be counted; GT 0</param>
	<param name="maxfract">maximum fraction of pixels allowed to have diff greater than or equal to mindiff</param>
	<param name="printstats">use 1 to print normalized histogram to stderr</param>
	<returns>0 if OK, 1 on error a failure in similarity comparison is not an error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.regTestCheckFile(LeptonicaSharp.L_RegParams,System.String)">
	<summary>
 Notes
 (1) This function does one of three things, depending on the mode
 "generate" makes a "golden" file as a copy %localname.
 "compare" compares %localname contents with the golden file
 "display" makes the %localname file but does no comparison
 (2) The canonical format of the golden filenames is
 /tmp/lept/golden/[root of main name]_golden.[index].
 [ext of localname]
 e.g.,
 /tmp/lept/golden/maze_golden.0.png
 It is important to add an extension to the local name, because
 the extension is added to the name of the golden file.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="localname">name of output file from reg test</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.regTestCompareFiles(LeptonicaSharp.L_RegParams,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This only does something in "compare" mode.
 (2) The canonical format of the golden filenames is
 /tmp/lept/golden/[root of main name]_golden.[index].
 [ext of localname]
 e.g.,
 /tmp/lept/golden/maze_golden.0.png
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="index1">of one output file from reg test</param>
	<param name="index2">of another output file from reg test</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.regTestWritePixAndCheck(LeptonicaSharp.L_RegParams,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This function makes it easy to write the pix in a numbered
 sequence of files, and either to
 (a) write the golden file ("generate" arg to regression test)
 (b) make a local file and "compare" with the golden file
 (c) make a local file and "display" the results
 (2) The canonical format of the local filename is
 /tmp/lept/regout/[root of main name].[count].[format extension]
 e.g., for scale_reg,
 /tmp/lept/regout/scale.0.png
 The golden file name mirrors this in the usual way.
 (3) The check is done between the written files, which requires
 the files to be identical. The exception is for GIF, which
 only requires that all pixels in the decoded pix are identical.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="pix">to be written</param>
	<param name="format">of output pix</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.regTestWriteDataAndCheck(LeptonicaSharp.L_RegParams,System.Object,System.UInt32,System.String)">
	<summary>
 Notes
 (1) This function makes it easy to write data in a numbered
 sequence of files, and either to
 (a) write the golden file ("generate" arg to regression test)
 (b) make a local file and "compare" with the golden file
 (c) make a local file and "display" the results
 (2) The canonical format of the local filename is
 /tmp/lept/regout/[root of main name].[count].[ext]
 e.g., for the first boxaa in quadtree_reg,
 /tmp/lept/regout/quadtree.0.baa
 The golden file name mirrors this in the usual way.
 (3) The data can be anything.  It is most useful for serialized
 output of data, such as boxa, pta, etc.
 (4) The file extension is arbitrary.  It is included simply
 to make the content type obvious when examining written files.
 (5) The check is done between the written files, which requires
 the files to be identical.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="data">to be written</param>
	<param name="nbytes">of data to be written</param>
	<param name="ext">filename extension (e.g. "ba", "pta")</param>
	<returns>0 if OK, 1 on error a failure in comparison is not an error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.regTestGenLocalFilename(LeptonicaSharp.L_RegParams,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is used to get the name of a file in the regout
 subdirectory, that has been made and is used to test against
 the golden file.  You can either specify a particular index
 value, or with %index == -1, this returns the most recently
 written file.  The latter case lets you read a pix from a
 file that has just been written with regTestWritePixAndCheck(),
 which is useful for testing formatted read/write functions.
 </summary>
	<remarks>
	</remarks>
	<param name="rp">regtest parameters</param>
	<param name="index">use -1 for current index</param>
	<param name="format">of image; e.g., IFF_PNG</param>
	<returns>filename if OK, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRasterop(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This has the standard set of 9 args for rasterop.
 This function is your friend; it is worth memorizing!
 (2) If the operation involves only dest, this calls
 rasteropUniLow().  Otherwise, checks depth of the
 src and dest, and if they match, calls rasteropLow().
 (3) For the two-image operation, where both pixs and pixd
 are defined, they are typically different images.  However
 there are cases, such as pixSetMirroredBorder(), where
 in-place operations can be done, blitting pixels from
 one part of pixd to another.  Consequently, we permit
 such operations.  If you use them, be sure that there
 is no overlap between the source and destination rectangles
 in pixd (!)
 Background
 -----------
 There are 18 operations, described by the op codes in pix.h.
 One, PIX_DST, is a no-op.
 Three, PIX_CLR, PIX_SET, and PIX_NOT(PIX_DST) operate only on the dest.
 These are handled by the low-level rasteropUniLow().
 The other 14 involve the both the src and the dest, and depend on
 the bit values of either just the src or the bit values of both
 src and dest.  They are handled by rasteropLow()
 PIX_SRC  s
 PIX_NOT(PIX_SRC)    ~s
 PIX_SRC | PIX_DST    s | d
 PIX_SRC  PIX_DST    s  d
 PIX_SRC ^ PIX_DST    s ^ d
 PIX_NOT(PIX_SRC) | PIX_DST   ~s | d
 PIX_NOT(PIX_SRC)  PIX_DST   ~s  d
 PIX_NOT(PIX_SRC) ^ PIX_DST   ~s ^ d
 PIX_SRC | PIX_NOT(PIX_DST) s | ~d
 PIX_SRC  PIX_NOT(PIX_DST) s  ~d
 PIX_SRC ^ PIX_NOT(PIX_DST) s ^ ~d
 PIX_NOT(PIX_SRC | PIX_DST)   ~(s | d)
 PIX_NOT(PIX_SRC  PIX_DST)   ~(s  d)
 PIX_NOT(PIX_SRC ^ PIX_DST)   ~(s ^ d)
 Each of these is implemented with one of three low-level
 functions, depending on the alignment of the left edge
 of the src and dest rectangles
 a fastest implementation if both left edges are
 (32-bit) word aligned
 a very slightly slower implementation if both left
 edges have the same relative (32-bit) word alignment
 the general routine that is invoked when
 both left edges have different word alignment
 Of the 14 binary rasterops above, only 12 are unique
 logical combinations (out of a possible 16) of src
 and dst bits
 (sd)   (11)   (10)   (01)   (00)
 -----------------------------------------------
 s   1   1   0   0
 ~s   0   1   0   1
 s | d 1   1   1   0
 s  d 1   0   0   0
 s ^ d 0   1   1   0
 ~s | d 1   0   1   1
 ~s  d 0   0   1   0
 ~s ^ d 1   0   0   1
 s | ~d   1   1   0   1
 s  ~d   0   1   0   0
 s ^ ~d   1   0   0   1
 ~(s | d)  0   0   0   1
 ~(s  d)  0   1   1   1
 ~(s ^ d)  1   0   0   1
 Note that the following three operations are equivalent
 ~(s ^ d)
 ~s ^ d
 s ^ ~d
 and in the implementation, we call them out with the first form;
 namely, ~(s ^ d).
 Of the 16 possible binary combinations of src and dest bits,
 the remaining 4 unique ones are independent of the src bit.
 They depend on either just the dest bit or on neither
 the src nor dest bits
 d   1   0   1   0 (indep. of s)
 ~d   0   1   0   1 (indep. of s)
 CLR  0   0   0   0 (indep. of both s  d)
 SET  1   1   1   1 (indep. of both s  d)
 As mentioned above, three of these are implemented by
 rasteropUniLow(), and one is a no-op.
 How can these operation codes be represented by bits
 in such a way that when the basic operations are performed
 on the bits the results are unique for unique
 operations, and mimic the logic table given above?
 The answer is to choose a particular order of the pairings
 (sd)   (11)   (10)   (01)   (00)
 (which happens to be the same as in the above table)
 and to translate the result into 4-bit representations
 of s and d.  For example, the Sun rasterop choice
 (omitting the extra bit for clipping) is
 PIX_SRC   0xc
 PIX_DST   0xa
 This corresponds to our pairing order given above
 (sd)   (11)   (10)   (01)   (00)
 where for s = 1 we get the bit pattern
 PIX_SRC  1   1   0   0  (0xc)
 and for d = 1 we get the pattern
 PIX_DST   1   0   1   0 (0xa)
 OK, that's the pairing order that Sun chose.  How many different
 ways can we assign bit patterns to PIX_SRC and PIX_DST to get
 the boolean ops to work out?  Any of the 4 pairs can be put
 in the first position, any of the remaining 3 pairs can go
 in the second; and one of the remaining 2 pairs can go the the third.
 There is a total of 432 = 24 ways these pairs can be permuted.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">dest pix</param>
	<param name="dx">x val of UL corner of dest rectangle</param>
	<param name="dy">y val of UL corner of dest rectangle</param>
	<param name="dw">width of dest rectangle</param>
	<param name="dh">height of dest rectangle</param>
	<param name="op">op code</param>
	<param name="pixs">src pix</param>
	<param name="sx">x val of UL corner of src rectangle</param>
	<param name="sy">y val of UL corner of src rectangle</param>
	<returns>0 if OK; 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRasteropVip(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) This rasterop translates a vertical band of the
 image either up or down, bringing in either white
 or black pixels from outside the image.
 (2) The vertical band extends the full height of pixd.
 (3) If a colormap exists, the nearest color to white or black
 is brought in.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">in-place</param>
	<param name="bx">left edge of vertical band</param>
	<param name="bw">width of vertical band</param>
	<param name="vshift">vertical shift of band; vshift GT 0 is down</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRasteropHip(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) This rasterop translates a horizontal band of the
 image either left or right, bringing in either white
 or black pixels from outside the image.
 (2) The horizontal band extends the full width of pixd.
 (3) If a colormap exists, the nearest color to white or black
 is brought in.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">in-place operation</param>
	<param name="by">top of horizontal band</param>
	<param name="bh">height of horizontal band</param>
	<param name="hshift">horizontal shift of band; hshift GT 0 is to right</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixTranslate(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_BRING_IN,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The general pattern is
 pixd = pixTranslate(pixd, pixs, ...);
 For clarity, when you know the case, use one of these
 pixd = pixTranslate(NULL, pixs, ...);  // new
 pixTranslate(pixs, pixs, ...);   // in-place
 pixTranslate(pixd, pixs, ...);   // to existing pixd
 (2) If an existing pixd is not the same size as pixs, the
 image data will be reallocated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">destination this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs"></param>
	<param name="hshift">horizontal shift; hshift GT 0 is to right</param>
	<param name="vshift">vertical shift; vshift GT 0 is down</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRasteropIP(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixd">in-place translation</param>
	<param name="hshift">horizontal shift; hshift GT 0 is to right</param>
	<param name="vshift">vertical shift; vshift GT 0 is down</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRasteropFullImage(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 ~ this is a wrapper for a common 2-image raster operation
 ~ both pixs and pixd must be defined
 ~ the operation is performed with aligned UL corners of pixs and pixd
 ~ the operation clips to the smallest pix; if the width or height
 of pixd is larger than pixs, some pixels in pixd will be unchanged
 </summary>
	<remarks>
	</remarks>
	<param name="pixd"></param>
	<param name="pixs"></param>
	<param name="op">any of the op-codes</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.rasteropUniLow(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="datad">ptr to dest image data</param>
	<param name="dpixw">width of dest</param>
	<param name="dpixh">height of dest</param>
	<param name="depth">depth of src and dest</param>
	<param name="dwpl">wpl of dest</param>
	<param name="dx">x val of UL corner of dest rectangle</param>
	<param name="dy">y val of UL corner of dest rectangle</param>
	<param name="dw">width of dest rectangle</param>
	<param name="dh">height of dest rectangle</param>
	<param name="op">op code</param>
</member><member name="M:LeptonicaSharp._AllFunctions.rasteropLow(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="datad">ptr to dest image data</param>
	<param name="dpixw">width of dest</param>
	<param name="dpixh">height of dest</param>
	<param name="depth">depth of src and dest</param>
	<param name="dwpl">wpl of dest</param>
	<param name="dx">x val of UL corner of dest rectangle</param>
	<param name="dy">y val of UL corner of dest rectangle</param>
	<param name="dw">width of dest rectangle</param>
	<param name="dh">height of dest rectangle</param>
	<param name="op">op code</param>
	<param name="datas">ptr to src image data</param>
	<param name="spixw">width of src</param>
	<param name="spixh">height of src</param>
	<param name="swpl">wpl of src</param>
	<param name="sx">x val of UL corner of src rectangle</param>
	<param name="sy">y val of UL corner of src rectangle</param>
</member><member name="M:LeptonicaSharp._AllFunctions.rasteropVipLow(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This clears the pixels that are left exposed after the
 translation.  You can consider them as pixels that are
 shifted in from outside the image.  This can be later
 overridden by the incolor parameter in higher-level functions
 that call this.  For example, for images with depth GT 1,
 these pixels are cleared to black; to be white they
 must later be SET to white.  See, e.g., pixRasteropVip().
 (2) This function scales the width to accommodate any depth,
 performs clipping, and then does the in-place rasterop.
 </summary>
	<remarks>
	</remarks>
	<param name="data">ptr to image data</param>
	<param name="pixw">width</param>
	<param name="pixh">height</param>
	<param name="depth">depth</param>
	<param name="wpl">wpl</param>
	<param name="x">x val of UL corner of rectangle</param>
	<param name="w">width of rectangle</param>
	<param name="shift">+ shifts data downward in vertical column</param>
</member><member name="M:LeptonicaSharp._AllFunctions.rasteropHipLow(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This clears the pixels that are left exposed after the rasterop.
 Therefore, for Pix with depth GT 1, these pixels become black,
 and must be subsequently SET if they are to be white.
 For example, see pixRasteropHip().
 (2) This function performs clipping and calls shiftDataHorizontalLow()
 to do the in-place rasterop on each line.
 </summary>
	<remarks>
	</remarks>
	<param name="data">ptr to image data</param>
	<param name="pixh">height</param>
	<param name="depth">depth</param>
	<param name="wpl">wpl</param>
	<param name="y">y val of UL corner of rectangle</param>
	<param name="h">height of rectangle</param>
	<param name="shift">+ shifts data to the left in a horizontal column</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotate(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_ROTATE,LeptonicaSharp.Enumerations.L_BRING_IN,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a high-level, simple interface for rotating images
 about their center.
 (2) For very small rotations, just return a clone.
 (3) Rotation brings either white or black pixels in
 from outside the image.
 (4) The rotation type is adjusted if necessary for the image
 depth and size of rotation angle.  For 1 bpp images, we
 rotate either by shear or sampling.
 (5) Colormaps are removed for rotation by area mapping.
 (6) The dest can be expanded so that no image pixels
 are lost.  To invoke expansion, input the original
 width and height.  For repeated rotation, use of the
 original width and height allows the expansion to
 stop at the maximum required size, which is a square
 with side = sqrt(ww + hh).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp rgb</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="type">L_ROTATE_AREA_MAP, L_ROTATE_SHEAR, L_ROTATE_SAMPLING</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<param name="width">original width; use 0 to avoid embedding</param>
	<param name="height">original height; use 0 to avoid embedding</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixEmbedForRotation(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) For very small rotations, just return a clone.
 (2) Generate larger image to embed pixs if necessary, and
 place the center of the input image in the center.
 (3) Rotation brings either white or black pixels in
 from outside the image.  For colormapped images where
 there is no white or black, a new color is added if
 possible for these pixels; otherwise, either the
 lightest or darkest color is used.  In most cases,
 the colormap will be removed prior to rotation.
 (4) The dest is to be expanded so that no image pixels
 are lost after rotation.  Input of the original width
 and height allows the expansion to stop at the maximum
 required size, which is a square with side equal to
 sqrt(ww + hh).
 (5) For an arbitrary angle, the expansion can be found by
 considering the UL and UR corners.  As the image is
 rotated, these move in an arc centered at the center of
 the image.  Normalize to a unit circle by dividing by half
 the image diagonal.  After a rotation of T radians, the UL
 and UR corners are at points T radians along the unit
 circle.  Compute the x and y coordinates of both these
 points and take the max of absolute values; these represent
 the half width and half height of the containing rectangle.
 The arithmetic is done using formulas for sin(a+b) and cos(a+b),
 where b = T.  For the UR corner, sin(a) = h/d and cos(a) = w/d.
 For the UL corner, replace a by (pi - a), and you have
 sin(pi - a) = h/d, cos(pi - a) = -w/d.  The equations
 given below follow directly.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp rgb</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<param name="width">original width; use 0 to avoid embedding</param>
	<param name="height">original height; use 0 to avoid embedding</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateBySampling(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) For very small rotations, just return a clone.
 (2) Rotation brings either white or black pixels in
 from outside the image.
 (3) Colormaps are retained.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp rgb; can be cmapped</param>
	<param name="xcen">x value of center of rotation</param>
	<param name="ycen">y value of center of rotation</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateBinaryNice(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) For very small rotations, just return a clone.
 (2) This does a computationally expensive rotation of 1 bpp images.
 The fastest rotators (using shears or subsampling) leave
 visible horizontal and vertical shear lines across which
 the image shear changes by one pixel.  To ameliorate the
 visual effect one can introduce random dithering.  One
 way to do this in a not-too-random fashion is given here.
 We convert to 8 bpp, do a very small blur, rotate using
 linear interpolation (same as area mapping), do a
 small amount of sharpening to compensate for the initial
 blur, and threshold back to binary.  The shear lines
 are magically removed.
 (3) This operation is about 5x slower than rotation by sampling.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="angle">radians; clockwise is positive; about the center</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateWithAlpha(LeptonicaSharp.Pix,System.Single,System.Single,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The alpha channel is transformed separately from pixs,
 and aligns with it, being fully transparent outside the
 boundary of the transformed pixs.  For pixels that are fully
 transparent, a blending function like pixBlendWithGrayMask()
 will give zero weight to corresponding pixels in pixs.
 (2) Rotation is about the center of the image; for very small
 rotations, just return a clone.  The dest is automatically
 expanded so that no image pixels are lost.
 (3) Rotation is by area mapping.  It doesn't matter what
 color is brought in because the alpha channel will
 be transparent (black) there.
 (4) If pixg is NULL, it is generated as an alpha layer that is
 partially opaque, using %fract.  Otherwise, it is cropped
 to pixs if required and %fract is ignored.  The alpha
 channel in pixs is never used.
 (4) Colormaps are removed to 32 bpp.
 (5) The default setting for the border values in the alpha channel
 is 0 (transparent) for the outermost ring of pixels and
 (0.5  fract  255) for the second ring.  When blended over
 a second image, this
 (a) shrinks the visible image to make a clean overlap edge
 with an image below, and
 (b) softens the edges by weakening the aliasing there.
 Use l_setAlphaMaskBorder() to change these values.
 (6) A subtle use of gamma correction is to remove gamma correction
 before rotation and restore it afterwards.  This is done
 by sandwiching this function between a gamma/inverse-gamma
 photometric transform
 pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);
 pixd = pixRotateWithAlpha(pixt, angle, NULL, fract);
 pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);
 pixDestroy(pixt);
 This has the side-effect of producing artifacts in the very
 dark regions.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb or cmapped</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="pixg">8 bpp, can be null</param>
	<param name="fract">between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	<returns>pixd 32 bpp rgba, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateAM(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Rotates about image center.
 (2) A positive angle gives a clockwise rotation.
 (3) Brings in either black or white pixels from the boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4, 8 bpp gray or colormapped, or 32 bpp RGB</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateAMColor(LeptonicaSharp.Pix,System.Single,System.UInt32)">
	<summary>
 Notes
 (1) Rotates about image center.
 (2) A positive angle gives a clockwise rotation.
 (3) Specify the color to be brought in from outside the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateAMGray(LeptonicaSharp.Pix,System.Single,System.Byte)">
	<summary>
 Notes
 (1) Rotates about image center.
 (2) A positive angle gives a clockwise rotation.
 (3) Specify the grayvalue to be brought in from outside the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateAMCorner(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) Rotates about the UL corner of the image.
 (2) A positive angle gives a clockwise rotation.
 (3) Brings in either black or white pixels from the boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8 bpp gray or colormapped, or 32 bpp RGB</param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateAMColorCorner(LeptonicaSharp.Pix,System.Single,System.UInt32)">
	<summary>
 Notes
 (1) Rotates the image about the UL corner.
 (2) A positive angle gives a clockwise rotation.
 (3) Specify the color to be brought in from outside the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="fillval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateAMGrayCorner(LeptonicaSharp.Pix,System.Single,System.Byte)">
	<summary>
 Notes
 (1) Rotates the image about the UL corner.
 (2) A positive angle gives a clockwise rotation.
 (3) Specify the grayvalue to be brought in from outside the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="grayval">0 to bring in BLACK, 255 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateAMColorFast(LeptonicaSharp.Pix,System.Single,System.UInt32)">
	<summary>
 Notes
 (1) This rotates a color image about the image center.
 (2) A positive angle gives a clockwise rotation.
 (3) It uses area mapping, dividing each pixel into
 16 subpixels.
 (4) It is about 10% to 20% faster than the more accurate linear
 interpolation function pixRotateAMColor(),
 which uses 256 subpixels.
 (5) For some reason it shifts the image center.
 No attempt is made to rotate the alpha component.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="angle">radians; clockwise is positive</param>
	<param name="colorval">e.g., 0 to bring in BLACK, 0xffffff00 for WHITE</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateOrth(LeptonicaSharp.Pix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="quads">0-3; number of 90 degree cw rotations</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotate180(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This does a 180 rotation of the image about the center,
 which is equivalent to a left-right flip about a vertical
 line through the image center, followed by a top-bottom
 flip about a horizontal line through the image center.
 (2) There are 3 cases for input
 (a) pixd == null (creates a new pixd)
 (b) pixd == pixs (in-place operation)
 (c) pixd != pixs (existing pixd)
 (3) For clarity, use these three patterns, respectively
 (a) pixd = pixRotate180(NULL, pixs);
 (b) pixRotate180(pixs, pixs);
 (c) pixRotate180(pixd, pixs);
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">all depths</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotate90(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This does a 90 degree rotation of the image about the center,
 either cw or ccw, returning a new pix.
 (2) The direction must be either 1 (cw) or -1 (ccw).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths</param>
	<param name="direction">1 = clockwise,  -1 = counter-clockwise</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFlipLR(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This does a left-right flip of the image, which is
 equivalent to a rotation out of the plane about a
 vertical line through the image center.
 (2) There are 3 cases for input
 (a) pixd == null (creates a new pixd)
 (b) pixd == pixs (in-place operation)
 (c) pixd != pixs (existing pixd)
 (3) For clarity, use these three patterns, respectively
 (a) pixd = pixFlipLR(NULL, pixs);
 (b) pixFlipLR(pixs, pixs);
 (c) pixFlipLR(pixd, pixs);
 (4) If an existing pixd is not the same size as pixs, the
 image data will be reallocated.
 (5) The pixel access routines allow a trivial implementation.
 However, for d LT 8, it is more efficient to right-justify
 each line to a 32-bit boundary and then extract bytes and
 do pixel reversing.   In those cases, as in the 180 degree
 rotation, we right-shift the data (if necessary) to
 right-justify on the 32 bit boundary, and then read the
 bytes off each raster line in reverse order, reversing
 the pixels in each byte using a table.  These functions
 for 1, 2 and 4 bpp were tested against the "trivial"
 version (shown here for 4 bpp)
 for (i = 0; i LT h; i++) {
 line = data + i  wpl;
 memcpy(buffer, line, bpl);
 for (j = 0; j LT w; j++) {
 val = GET_DATA_QBIT(buffer, w - 1 - j);
 SET_DATA_QBIT(line, j, val);
 }
 }
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">all depths</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFlipTB(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This does a top-bottom flip of the image, which is
 equivalent to a rotation out of the plane about a
 horizontal line through the image center.
 (2) There are 3 cases for input
 (a) pixd == null (creates a new pixd)
 (b) pixd == pixs (in-place operation)
 (c) pixd != pixs (existing pixd)
 (3) For clarity, use these three patterns, respectively
 (a) pixd = pixFlipTB(NULL, pixs);
 (b) pixFlipTB(pixs, pixs);
 (c) pixFlipTB(pixd, pixs);
 (4) If an existing pixd is not the same size as pixs, the
 image data will be reallocated.
 (5) This is simple and fast.  We use the memcpy function
 to do all the work on aligned data, regardless of pixel
 depth.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">all depths</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateShear(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) This rotates an image about the given point, using
 either 2 or 3 shears.
 (2) A positive angle gives a clockwise rotation.
 (3) This brings in 'incolor' pixels from outside the image.
 (4) For rotation angles larger than about 0.35 radians, we issue
 a warning because you should probably be using another method
 (either sampling or area mapping)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="xcen">x value for which there is no horizontal shear</param>
	<param name="ycen">y value for which there is no vertical shear</param>
	<param name="angle">radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotate2Shear(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) This rotates the image about the given point, using the 2-shear
 method.  It should only be used for angles smaller than
 MAX_2_SHEAR_ANGLE.  For larger angles, a warning is issued.
 (2) A positive angle gives a clockwise rotation.
 (3) 2-shear rotation by a specified angle is equivalent
 to the sequential transformations
 x' = x + tan(angle)  (y - ycen)  for x-shear
 y' = y + tan(angle)  (x - xcen)  for y-shear
 (4) Computation of tan(angle) is performed within the shear operation.
 (5) This brings in 'incolor' pixels from outside the image.
 (6) If the image has an alpha layer, it is rotated separately by
 two shears.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="xcen">center of rotation</param>
	<param name="ycen">center of rotation</param>
	<param name="angle">radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotate3Shear(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) This rotates the image about the given point, using the 3-shear
 method.  It should only be used for angles smaller than
 LIMIT_SHEAR_ANGLE.  For larger angles, a warning is issued.
 (2) A positive angle gives a clockwise rotation.
 (3) 3-shear rotation by a specified angle is equivalent
 to the sequential transformations
 y' = y + tan(angle/2)  (x - xcen)  for first y-shear
 x' = x + sin(angle)  (y - ycen) for x-shear
 y' = y + tan(angle/2)  (x - xcen)  for second y-shear
 (4) Computation of tan(angle) is performed in the shear operations.
 (5) This brings in 'incolor' pixels from outside the image.
 (6) If the image has an alpha layer, it is rotated separately by
 two shears.
 (7) The algorithm was published by Alan Paeth "A Fast Algorithm
 for General Raster Rotation," Graphics Interface '86,
 pp. 77-81, May 1986.  A description of the method, along with
 an implementation, can be found in Graphics Gems, p. 179,
 edited by Andrew Glassner, published by Academic Press, 1990.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="xcen">center of rotation</param>
	<param name="ycen">center of rotation</param>
	<param name="angle">radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateShearIP(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) This does an in-place rotation of the image about the
 specified point, using the 3-shear method.  It should only
 be used for angles smaller than LIMIT_SHEAR_ANGLE.
 For larger angles, a warning is issued.
 (2) A positive angle gives a clockwise rotation.
 (3) 3-shear rotation by a specified angle is equivalent
 to the sequential transformations
 y' = y + tan(angle/2)  (x - xcen)   for first y-shear
 x' = x + sin(angle)  (y - ycen)  for x-shear
 y' = y + tan(angle/2)  (x - xcen)   for second y-shear
 (4) Computation of tan(angle) is performed in the shear operations.
 (5) This brings in 'incolor' pixels from outside the image.
 (6) The pix cannot be colormapped, because the in-place operation
 only blits in 0 or 1 bits, not an arbitrary colormap index.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth; not colormapped</param>
	<param name="xcen">center of rotation</param>
	<param name="ycen">center of rotation</param>
	<param name="angle">radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateShearCenter(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="angle">radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRotateShearCenterIP(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="angle">radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixStrokeWidthTransform(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The dest Pix is 8 or 16 bpp, with the pixel values
 equal to the stroke width in which it is a member.
 The values are clipped to the max pixel value if necessary.
 (2) The color determines if we're labelling white or black strokes.
 (3) A pixel that is not a member of the chosen color gets
 value 0; it belongs to a width of length 0 of the
 chosen color.
 (4) This chooses, for each dest pixel, the minimum of sets
 of runlengths through each pixel.  Here are the sets
 nangles increment set
 ------- --------- --------------------------------
 2 90 {0, 90}
 4 45 {0, 45, 90, 135}
 6 30 {0, 30, 60, 90, 120, 150}
 8 22.5  {0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5}
 (5) Runtime scales linearly with (nangles - 2).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="color">0 for white runs, 1 for black runs</param>
	<param name="depth">of pixd 8 or 16 bpp</param>
	<param name="nangles">2, 4, 6 or 8</param>
	<returns>pixd 8 or 16 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRunlengthTransform(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Enumerations.L_AL_RUNS,System.Int32)">
	<summary>
 Notes
 (1) The dest Pix is 8 or 16 bpp, with the pixel values
 equal to the runlength in which it is a member.
 The length is clipped to the max pixel value if necessary.
 (2) The color determines if we're labelling white or black runs.
 (3) A pixel that is not a member of the chosen color gets
 value 0; it belongs to a run of length 0 of the
 chosen color.
 (4) To convert for maximum dynamic range, either linear or
 log, use pixMaxDynamicRange().
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="color">0 for white runs, 1 for black runs</param>
	<param name="direction">L_HORIZONTAL_RUNS, L_VERTICAL_RUNS</param>
	<param name="depth">8 or 16 bpp</param>
	<returns>pixd 8 or 16 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindHorizontalRuns(LeptonicaSharp.Pix,System.Int32,System.Int32[],System.Int32[],System.Int32@)">
	<summary>
 Notes
 (1) This finds foreground horizontal runs on a single scanline.
 (2) To find background runs, use pixInvert() before applying
 this function.
 (3) The xstart and xend arrays are input.  They should be
 of size w/2 + 1 to insure that they can hold
 the maximum number of runs in the raster line.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="y">line to traverse</param>
	<param name="xstart">returns array of start positions for fg runs</param>
	<param name="xend">returns array of end positions for fg runs</param>
	<param name="pn">the number of runs found</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindVerticalRuns(LeptonicaSharp.Pix,System.Int32,System.Int32[],System.Int32[],System.Int32@)">
	<summary>
 Notes
 (1) This finds foreground vertical runs on a single scanline.
 (2) To find background runs, use pixInvert() before applying
 this function.
 (3) The ystart and yend arrays are input.  They should be
 of size h/2 + 1 to insure that they can hold
 the maximum number of runs in the raster line.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="x">line to traverse</param>
	<param name="ystart">returns array of start positions for fg runs</param>
	<param name="yend">returns array of end positions for fg runs</param>
	<param name="pn">the number of runs found</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindMaxRuns(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_AL_RUNS,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This finds the longest foreground runs by row or column
 (2) To find background runs, use pixInvert() before applying
 this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="direction">L_HORIZONTAL_RUNS or L_VERTICAL_RUNS</param>
	<param name="pnastart">start locations of longest runs</param>
	<returns>na of lengths of runs, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindMaxHorizontalRunOnLine(LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This finds the longest foreground horizontal run on a scanline.
 (2) To find background runs, use pixInvert() before applying
 this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="y">line to traverse</param>
	<param name="pxstart">start position</param>
	<param name="psize">the size of the run</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindMaxVerticalRunOnLine(LeptonicaSharp.Pix,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This finds the longest foreground vertical run on a scanline.
 (2) To find background runs, use pixInvert() before applying
 this function.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">1 bpp</param>
	<param name="x">column to traverse</param>
	<param name="pystart">start position</param>
	<param name="psize">the size of the run</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.runlengthMembershipOnLine(System.Int32[],System.Int32,System.Int32,System.Int32[],System.Object@,System.Int32)">
	<summary>
 Notes
 (1) Converts a set of runlengths into a buffer of
 runlength membership values.
 (2) Initialization of the array gives pixels that are
 not within a run the value 0.
 </summary>
	<remarks>
	</remarks>
	<param name="buffer">into which full line of data is placed</param>
	<param name="size">full size of line; w or h</param>
	<param name="depth">8 or 16 bpp</param>
	<param name="start">array of start positions for fg runs</param>
	<param name="n">the number of runs</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeMSBitLocTab(System.Int32)">
	<summary>
 Notes
 (1) If bitval == 1, it finds the leftmost ON pixel in a byte;
 otherwise if bitval == 0, it finds the leftmost OFF pixel.
 (2) If there are no pixels of the indicated color in the byte,
 this returns 8.
 </summary>
	<remarks>
	</remarks>
	<param name="bitval">either 0 or 1</param>
	<returns>table giving, for an input byte, the MS bit location, starting at 0 with the MSBit in the byte, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of string ptr array to be alloc'd; use 0 for default</param>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayCreateInitialized(System.Int32,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">size of string ptr array to be alloc'd</param>
	<param name="initstr">string to be initialized on the full array</param>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayCreateWordsFromString(System.String@)">
	<summary>
 Notes
 (1) This finds the number of word substrings, creates an sarray
 of this size, and puts copies of each substring into the sarray.
 </summary>
	<remarks>
	</remarks>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayCreateLinesFromString(System.String@,System.Int32)">
	<summary>
 Notes
 (1) This finds the number of line substrings, each of which
 ends with a newline, and puts a copy of each substring
 in a new sarray.
 (2) The newline characters are removed from each substring.
 </summary>
	<remarks>
	</remarks>
	<param name="blankflag">0 to exclude blank lines; 1 to include</param>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayDestroy(LeptonicaSharp.Sarray@)">
	<summary>
 Notes
 (1) Decrements the ref count and, if 0, destroys the sarray.
 (2) Always nulls the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="psa">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayCopy(LeptonicaSharp.Sarray)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<returns>copy of sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayClone(LeptonicaSharp.Sarray)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<returns>ptr to same sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayAddString(LeptonicaSharp.Sarray,System.String@,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) See usage comments at the top of this file.  L_INSERT is
 equivalent to L_NOCOPY.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="copyflag">L_INSERT, L_NOCOPY or L_COPY</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayRemoveString(LeptonicaSharp.Sarray,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="index">of string within sarray</param>
	<returns>removed string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayReplaceString(LeptonicaSharp.Sarray,System.Int32,System.String,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) This destroys an existing string and replaces it with
 the new string or a copy of it.
 (2) By design, an sarray is always compacted, so there are
 never any holes (null ptrs) in the ptr array up to the
 current count.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="index">of string within sarray to be replaced</param>
	<param name="newstr">string to replace existing one</param>
	<param name="copyflag">L_INSERT, L_COPY</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayClear(LeptonicaSharp.Sarray)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayGetCount(LeptonicaSharp.Sarray)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<returns>count, or 0 if no strings or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayGetArray(LeptonicaSharp.Sarray,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) Caution the returned array is not a copy, so caller
 must not destroy it!
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="pnalloc">number allocated string ptrs</param>
	<param name="pn">number allocated strings</param>
	<returns>ptr to string array, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayGetString(LeptonicaSharp.Sarray,System.Int32,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) See usage comments at the top of this file.
 (2) To get a pointer to the string itself, use L_NOCOPY.
 To get a copy of the string, use L_COPY.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="index">to the index-th string</param>
	<param name="copyflag">L_NOCOPY or L_COPY</param>
	<returns>string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayGetRefcount(LeptonicaSharp.Sarray)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<returns>refcount, or UNDEF on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayChangeRefcount(LeptonicaSharp.Sarray,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="delta">change to be applied</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayToString(LeptonicaSharp.Sarray,System.Int32)">
	<summary>
 Notes
 (1) Concatenates all the strings in the sarray, preserving
 all white space.
 (2) If addnlflag != 0, adds either a '\n' or a ' ' after
 each substring.
 (3) This function was NOT implemented as
 for (i = 0; i LT n; i++)
 strcat(dest, sarrayGetString(sa, i, L_NOCOPY));
 Do you see why?
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="addnlflag">flag 0 adds nothing to each substring 1 adds '\n' to each substring 2 adds ' ' to each substring</param>
	<returns>dest string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayToStringRange(LeptonicaSharp.Sarray,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Concatenates the specified strings inthe sarray, preserving
 all white space.
 (2) If addnlflag != 0, adds either a '\n' or a ' ' after
 each substring.
 (3) If the sarray is empty, this returns a string with just
 the character corresponding to %addnlflag.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array</param>
	<param name="first">index of first string to use; starts with 0</param>
	<param name="nstrings">number of strings to append into the result; use 0 to append to the end of the sarray</param>
	<param name="addnlflag">flag 0 adds nothing to each substring 1 adds '\n' to each substring 2 adds ' ' to each substring</param>
	<returns>dest string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayJoin(LeptonicaSharp.Sarray,LeptonicaSharp.Sarray)">
	<summary>
 Notes
 (1) Copies of the strings in sarray2 are added to sarray1.
 </summary>
	<remarks>
	</remarks>
	<param name="sa1">to be added to</param>
	<param name="sa2">append to sa1</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayAppendRange(LeptonicaSharp.Sarray,LeptonicaSharp.Sarray,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Copies of the strings in sarray2 are added to sarray1.
 (2) The [start ... end] range is truncated if necessary.
 (3) Use end == -1 to append to the end of sa2.
 </summary>
	<remarks>
	</remarks>
	<param name="sa1">to be added to</param>
	<param name="sa2">append specified range of strings in sa2 to sa1</param>
	<param name="start">index of first string of sa2 to append</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayPadToSameSize(LeptonicaSharp.Sarray,LeptonicaSharp.Sarray,System.String)">
	<summary>
 Notes
 (1) If two sarrays have different size, this adds enough
 instances of %padstring to the smaller so that they are
 the same size.  It is useful when two or more sarrays
 are being sequenced in parallel, and it is necessary to
 find a valid string at each index.
 </summary>
	<remarks>
	</remarks>
	<param name="sa1"></param>
	<param name="sa2"></param>
	<param name="padstring"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayConvertWordsToLines(LeptonicaSharp.Sarray,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa">sa of individual words</param>
	<param name="linesize">max num of chars in each line</param>
	<returns>saout sa of formatted lines, or NULL on error This is useful for re-typesetting text to a specific maximum line length.  The individual words in the input sarray are concatenated into textlines.  An input word string of zero length is taken to be a paragraph separator.  Each time such a string is found, the current line is ended and a new line is also produced that contains just the string of zero length "".  When the output sarray of lines is eventually converted to a string with newlines typically appended to each line string, the empty strings are just converted to newlines, producing the visible paragraph separation. What happens when a word is larger than linesize? We write it out as a single line anyway!  Words preceding or following this long word are placed on lines preceding or following the line with the long word.  Why this choice? Long "words" found in text documents are typically URLs, and it's often desirable not to put newlines in the middle of a URL. The text display program e.g., text editor will typically wrap the long "word" to fit in the window.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarraySplitString(LeptonicaSharp.Sarray@,System.String@,System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarraySelectBySubstring(LeptonicaSharp.Sarray,System.String)">
	<summary>
 Notes
 (1) This selects all strings in sain that have substr as a substring.
 Note that we can't use strncmp() because we're looking for
 a match to the substring anywhere within each filename.
 (2) If substr == NULL, returns a copy of the sarray.
 </summary>
	<remarks>
	</remarks>
	<param name="sain">input sarray</param>
	<param name="substr">substring for matching; can be NULL</param>
	<returns>saout output sarray, filtered with substring or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarraySelectByRange(LeptonicaSharp.Sarray,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This makes %saout consisting of copies of all strings in %sain
 in the index set [first ... last].  Use %last == 0 to get all
 strings from %first to the last string in the sarray.
 </summary>
	<remarks>
	</remarks>
	<param name="sain">input sarray</param>
	<param name="first">index of first string to be selected</param>
	<param name="last">index of last string to be selected; use 0 to go to the end of the sarray</param>
	<returns>saout output sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayParseRange(LeptonicaSharp.Sarray,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.String,System.Int32)">
	<summary>
 Notes
 (1) This finds the range of the next set of strings in SA,
 beginning the search at 'start', that does NOT have
 the substring 'substr' either at the indicated location
 in the string or anywhere in the string.  The input
 variable 'loc' is the specified offset within the string;
 use -1 to indicate 'anywhere in the string'.
 (2) Always check the return value to verify that a valid range
 was found.
 (3) If a valid range is not found, the values of actstart,
 end and newstart are all set to the size of sa.
 (4) If this is the last valid range, newstart returns the value n.
 In use, this should be tested before calling the function.
 (5) Usage example.  To find all the valid ranges in a file
 where the invalid lines begin with two dashes, copy each
 line in the file to a string in an sarray, and do
 start = 0;
 while (!sarrayParseRange(sa, start, actstart, end, start,
 "--", 0))
 fprintf(stderr, "start = %d, end = %d\n", actstart, end);
 </summary>
	<remarks>
	</remarks>
	<param name="sa">input sarray</param>
	<param name="start">index to start range search</param>
	<param name="pactualstart">index of actual start; may be GT 'start'</param>
	<param name="pend">index of end</param>
	<param name="pnewstart">index of start of next range</param>
	<param name="substr">substring for matching at beginning of string</param>
	<param name="loc">byte offset within the string for the pattern; use -1 if the location does not matter;</param>
	<returns>0 if valid range found; 1 otherwise</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayReadStream(LeptonicaSharp.FILE)">
	<summary>
 Notes
 (1) We store the size of each string along with the string.
 The limit on the number of strings is 2^24.
 The limit on the size of any string is 2^30 bytes.
 (2) This allows a string to have embedded newlines.  By reading
 the entire string, as determined by its size, we are
 not affected by any number of embedded newlines.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayReadMem(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">serialization in ascii</param>
	<param name="size">of data; can use strlen to get it</param>
	<returns>sarray, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayWrite(System.String,LeptonicaSharp.Sarray)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="sa">string array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.Sarray)">
	<summary>
 Notes
 (1) This appends a '\n' to each string, which is stripped
 off by sarrayReadStream().
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="sa">string array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.Sarray)">
	<summary>
 Notes
 (1) Serializes a sarray in memory and puts the result in a buffer.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized sarray; ascii</param>
	<param name="psize">size of returned data</param>
	<param name="sa"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayAppend(System.String,LeptonicaSharp.Sarray)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="sa"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getNumberedPathnamesInDirectory(System.String,System.Int32,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) Returns the full pathnames of the numbered filenames in
 the directory.  The number in the filename is the index
 into the sarray.  For indices for which there are no filenames,
 an empty string ("") is placed into the sarray.
 This makes reading numbered files very simple.  For example,
 the image whose filename includes number N can be retrieved using
 pixReadIndexed(sa, N);
 (2) If %substr is not NULL, only filenames that contain
 the substring can be included.  If %substr is NULL,
 all matching filenames are used.
 (3) If no numbered files are found, it returns an empty sarray,
 with no initialized strings.
 (4) It is assumed that the page number is contained within
 the basename (the filename without directory or extension).
 %numpre is the number of characters in the basename
 preceding the actual page number; %numpost is the number
 following the page number, up to either the end of the
 basename or a ".", whichever comes first.
 (5) This is useful when all filenames contain numbers that are
 not necessarily consecutive.  0-padding is not required.
 (6) To use a O(n) matching algorithm, the largest page number
 is found and two internal arrays of this size are created.
 This maximum is constrained not to exceed %maxsum,
 to make sure that an unrealistically large number is not
 accidentally used to determine the array sizes.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="numpre">number of characters in name before number</param>
	<param name="numpost">number of characters in name after the number, up to a dot before an extension</param>
	<param name="maxnum">only consider page numbers up to this value</param>
	<returns>sarray of numbered pathnames, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getSortedPathnamesInDirectory(System.String,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) Use %substr to filter filenames in the directory.  If
 %substr == NULL, this takes all files.
 (2) The files in the directory, after optional filtering by
 the substring, are lexically sorted in increasing order.
 Use %first and %nfiles to select a contiguous set of files.
 (3) The full pathnames are returned for the requested sequence.
 If no files are found after filtering, returns an empty sarray.
 </summary>
	<remarks>
	</remarks>
	<param name="dirname">directory name</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="first">0-based</param>
	<param name="nfiles">use 0 for all to the end</param>
	<returns>sarray of sorted pathnames, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertSortedToNumberedPathnames(LeptonicaSharp.Sarray,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Typically, numpre = numpost = 0; e.g., when the filename
 just has a number followed by an optional extension.
 </summary>
	<remarks>
	</remarks>
	<param name="sa">sorted pathnames including zero-padded integers</param>
	<param name="numpre">number of characters in name before number</param>
	<param name="numpost">number of characters in name after the number, up to a dot before an extension</param>
	<param name="maxnum">only consider page numbers up to this value</param>
	<returns>sarray of numbered pathnames, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getFilenamesInDirectory(System.String@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarraySort(LeptonicaSharp.Sarray,LeptonicaSharp.Sarray,LeptonicaSharp.Enumerations.L_SORT_CREASING)">
	<summary>
 Notes
 (1) Set saout = sain for in-place; otherwise, set naout = NULL.
 (2) Shell sort, modified from KR, 2nd edition, p.62.
 Slow but simple O(n logn) sort.
 </summary>
	<remarks>
	</remarks>
	<param name="saout">output sarray; can be NULL or equal to sain</param>
	<param name="sain">input sarray</param>
	<param name="sortorder">L_SORT_INCREASING or L_SORT_DECREASING</param>
	<returns>saout output sarray, sorted by ascii value, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarraySortByIndex(LeptonicaSharp.Sarray,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sain"></param>
	<param name="naindex">na that maps from the new sarray to the input sarray</param>
	<returns>saout sorted, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringCompareLexical(System.String,System.String)">
	<summary>
 Notes
 (1) If the lexical values are identical, return a 0, to
 indicate that no swapping is required to sort the strings.
 </summary>
	<remarks>
	</remarks>
	<param name="str1"></param>
	<param name="str2"></param>
	<returns>1 if str1 GT str2 lexically; 0 otherwise</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayUnionByAset(LeptonicaSharp.Sarray,LeptonicaSharp.Sarray)">
	<summary>
 Notes
 (1) Duplicates are removed from the concatenation of the two arrays.
 (2) The key for each string is a 64-bit hash.
 (2) Algorithm Concatenate the two sarrays.  Then build a set,
 using hashed strings as keys.  As the set is built, first do
 a find; if not found, add the key to the set and add the string
 to the output sarray.  This is O(nlogn).
 </summary>
	<remarks>
	</remarks>
	<param name="sa1"></param>
	<param name="sa2"></param>
	<returns>sad with the union of the string set, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayRemoveDupsByAset(LeptonicaSharp.Sarray)">
	<summary>
 Notes
 (1) This is O(nlogn), considerably slower than
 sarrayRemoveDupsByHash() for large string arrays.
 (2) The key for each string is a 64-bit hash.
 (3) Build a set, using hashed strings as keys.  As the set is
 built, first do a find; if not found, add the key to the
 set and add the string to the output sarray.
 </summary>
	<remarks>
	</remarks>
	<param name="sas"></param>
	<returns>sad with duplicates removed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayIntersectionByAset(LeptonicaSharp.Sarray,LeptonicaSharp.Sarray)">
	<summary>
 Notes
 (1) Algorithm put the larger sarray into a set, using the string
 hashes as the key values.  Then run through the smaller sarray,
 building an output sarray and a second set from the strings
 in the larger array if a string is in the first set but
 not in the second, add the string to the output sarray and hash
 it into the second set.  The second set is required to make
 sure only one instance of each string is put into the output sarray.
 This is O(mlogn), {m,n} = sizes of {smaller,larger} input arrays.
 </summary>
	<remarks>
	</remarks>
	<param name="sa1"></param>
	<param name="sa2"></param>
	<returns>sad with the intersection of the string set, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_asetCreateFromSarray(LeptonicaSharp.Sarray)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa"></param>
	<returns>set using a string hash into a uint64 as the key</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayRemoveDupsByHash(LeptonicaSharp.Sarray,LeptonicaSharp.Sarray@,LeptonicaSharp.L_DnaHash@)">
	<summary>
 Notes
 (1) Generates a sarray with unique values.
 (2) The dnahash is built up with sad to assure uniqueness.
 It can be used to find if a string is in the set
 sarrayFindValByHash(sad, dahash, str, index)
 (3) The hash of the string location is simple and fast.  It scales
 up with the number of buckets to insure a fairly random
 bucket selection input strings.
 (4) This is faster than sarrayRemoveDupsByAset(), because the
 bucket lookup is O(n), although there is a double-loop
 lookup within the dna in each bucket.
 </summary>
	<remarks>
	</remarks>
	<param name="sas"></param>
	<param name="psad">unique set of strings; duplicates removed</param>
	<param name="pdahash">dnahash used for lookup</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayIntersectionByHash(LeptonicaSharp.Sarray,LeptonicaSharp.Sarray)">
	<summary>
 Notes
 (1) This is faster than sarrayIntersectionByAset(), because the
 bucket lookup is O(n).
 </summary>
	<remarks>
	</remarks>
	<param name="sa1"></param>
	<param name="sa2"></param>
	<returns>sad intersection of the strings, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayFindStringByHash(LeptonicaSharp.Sarray,LeptonicaSharp.L_DnaHash,System.String,System.Int32@)">
	<summary>
 Notes
 (1) Fast lookup in dnaHash associated with a sarray, to see if a
 random string %str is already stored in the hash table.
 (2) We use a strong hash function to minimize the chance that
 two different strings hash to the same key value.
 (3) We select the number of buckets to be about 5% of the size
 of the input sarray, so that when fully populated, each
 bucket (dna) will have about 20 entries, each being an index
 into sa.  In lookup, after hashing to the key, and then
 again to the bucket, we traverse the bucket (dna), using the
 index into sa to check if %str has been found before.
 </summary>
	<remarks>
	</remarks>
	<param name="sa"></param>
	<param name="dahash">built from sa</param>
	<param name="str">arbitrary string</param>
	<param name="pindex">index into %sa if %str is in %sa; -1 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_dnaHashCreateFromSarray(LeptonicaSharp.Sarray)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sa"></param>
	<returns>dahash, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayGenerateIntegers(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n"></param>
	<returns>sa  (of printed numbers, 1 - n, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sarrayLookupCSKV(LeptonicaSharp.Sarray,System.String,System.String[]@)">
	<summary>
 Notes
 (1) The input %sa can have other strings that are not in
 comma-separated key-value format.  These will be ignored.
 (2) This returns a copy of the first value string in %sa whose
 key string matches the input %keystring.
 (3) White space is not ignored; all white space before the ','
 is used for the keystring in matching.  This allows the
 key and val strings to have white space (e.g., multiple words).
 </summary>
	<remarks>
	</remarks>
	<param name="sa">(of strings, each being a comma-separated pair of strings, the first being a key and the second a value)</param>
	<param name="keystring">(an input string to match with each key in %sa</param>
	<param name="pvalstring">(the returned value string corresponding to the input key string, if found; otherwise NULL)</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScale(LeptonicaSharp.Pix,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 and 32 bpp</param>
	<param name="scalex"></param>
	<param name="scaley"></param>
	<returns>pixd, or NULL on error This function scales 32 bpp RGB; 2, 4 or 8 bpp palette color; 2, 4, 8 or 16 bpp gray; and binary images. When the input has palette color, the colormap is removed and the result is either 8 bpp gray or 32 bpp RGB, depending on whether the colormap has color entries.  Images with 2, 4 or 16 bpp are converted to 8 bpp. Because pixScale is meant to be a very simple interface to a number of scaling functions, including the use of unsharp masking, the type of scaling and the sharpening parameters are chosen by default.  Grayscale and color images are scaled using one of four methods, depending on the scale factors 1 antialiased subsampling (lowpass filtering followed by subsampling, implemented here by area mapping), for scale factors less than 0.2 2 antialiased subsampling with sharpening, for scale factors between 0.2 and 0.7 3 linear interpolation with sharpening, for scale factors between 0.7 and 1.4 4 linear interpolation without sharpening, for scale factors GT= 1.4. One could use subsampling for scale factors very close to 1.0, because it preserves sharp edges.  Linear interpolation blurs edges because the dest pixels will typically straddle two src edge pixels.  Subsmpling removes entire columns and rows, so the edge is not blurred.  However, there are two reasons for not doing this. First, it moves edges, so that a straight line at a large angle to both horizontal and vertical will have noticeable kinks where horizontal and vertical rasters are removed.  Second, although it is very fast, you get good results on sharp edges by applying a sharpening filter. For images with sharp edges, sharpening substantially improves the image quality for scale factors between about 0.2 and about 2.0. pixScale uses a small amount of sharpening by default because it strengthens edge pixels that are weak due to anti-aliasing. The default sharpening factors are for scaling factors LT 0.7   sharpfract = 0.2    sharpwidth = 1 for scaling factors GT= 0.7  sharpfract = 0.4    sharpwidth = 2 The cases where the sharpening halfwidth is 1 or 2 have special implementations and are about twice as fast as the general case. However, sharpening is computationally expensive, and one needs to consider the speed-quality tradeoff For upscaling of RGB images, linear interpolation plus default sharpening is about 5 times slower than upscaling alone. For downscaling, area mapping plus default sharpening is about 10 times slower than downscaling alone. When the scale factor is larger than 1.4, the cost of sharpening, which is proportional to image area, is very large compared to the incremental quality improvement, so we cut off the default use of sharpening at 1.4.  Thus, for scale factors greater than 1.4, pixScale only does linear interpolation. In many situations you will get a satisfactory result by scaling without sharpening call pixScaleGeneral with %sharpfract = 0.0. Alternatively, if you wish to sharpen but not use the default value, first call pixScaleGeneral with %sharpfract = 0.0, and then sharpen explicitly using pixUnsharpMasking. Binary images are scaled to binary by sampling the closest pixel, without any low-pass filtering averaging of neighboring pixels. This will introduce aliasing for reductions.  Aliasing can be prevented by using pixScaleToGray instead.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleToSizeRel(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="delw">change in width, in pixels; 0 means no change</param>
	<param name="delh">change in height, in pixels; 0 means no change</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleToSize(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The output scaled image has the dimension(s) you specify
 To specify the width with isotropic scaling, set %hd = 0.
 To specify the height with isotropic scaling, set %wd = 0.
 If both %wd and %hd are specified, the image is scaled
 (in general, anisotropically) to that size.
 It is an error to set both %wd and %hd to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 and 32 bpp</param>
	<param name="wd">target width; use 0 if using height as target</param>
	<param name="hd">target height; use 0 if using width as target</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleGeneral(LeptonicaSharp.Pix,System.Single,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) See pixScale() for usage.
 (2) This interface may change in the future, as other special
 cases are added.
 (3) The actual sharpening factors used depend on the maximum
 of the two scale factors (maxscale)
 maxscale LT= 0.2  no sharpening
 0.2 LT maxscale LT 1.4   uses the input parameters
 maxscale GT= 1.4  no sharpening
 (4) To avoid sharpening for grayscale and color images with
 scaling factors between 0.2 and 1.4, call this function
 with %sharpfract == 0.0.
 (5) To use arbitrary sharpening in conjunction with scaling,
 call this function with %sharpfract = 0.0, and follow this
 with a call to pixUnsharpMasking() with your chosen parameters.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 and 32 bpp</param>
	<param name="scalex">both GT 0.0</param>
	<param name="scaley">both GT 0.0</param>
	<param name="sharpfract">use 0.0 to skip sharpening</param>
	<param name="sharpwidth">halfwidth of low-pass filter; typ. 1 or 2</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleLI(LeptonicaSharp.Pix,System.Single,System.Single)">
	<summary>
 Notes
 (1) This function should only be used when the scale factors are
 greater than or equal to 0.7, and typically greater than 1.
 If either scale factor is larger than 0.7, we issue a warning
 and call pixScaleGeneral(), which will invoke area mapping
 without sharpening.
 (2) This works on 2, 4, 8, 16 and 32 bpp images, as well as on
 2, 4 and 8 bpp images that have a colormap.  If there is a
 colormap, it is removed to either gray or RGB, depending
 on the colormap.
 (3) This does a linear interpolation on the src image.
 (4) It dispatches to much faster implementations for
 the special cases of 2x and 4x expansion.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4, 8 or 32 bpp; with or without colormap</param>
	<param name="scalex">must both be GT= 0.7</param>
	<param name="scaley">must both be GT= 0.7</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleColorLI(LeptonicaSharp.Pix,System.Single,System.Single)">
	<summary>
 Notes
 (1) If either scale factor is larger than 0.7, we issue a warning
 and call pixScaleGeneral(), which will invoke area mapping
 without sharpening.  This is particularly important for
 document images with sharp edges.
 (2) For the general case, it's about 4x faster to manipulate
 the color pixels directly, rather than to make images
 out of each of the 3 components, scale each component
 using the pixScaleGrayLI(), and combine the results back
 into an rgb image.
 (3) The speed on intel hardware for the general case (not 2x)
 is about 10  10^6 dest-pixels/sec/GHz.  (The special 2x
 case runs at about 80  10^6 dest-pixels/sec/GHz.)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, representing rgb</param>
	<param name="scalex">must both be GT= 0.7</param>
	<param name="scaley">must both be GT= 0.7</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleColor2xLI(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a special case of linear interpolated scaling,
 for 2x upscaling.  It is about 8x faster than using
 the generic pixScaleColorLI(), and about 4x faster than
 using the special 2x scale function pixScaleGray2xLI()
 on each of the three components separately.
 (2) The speed on intel hardware is about
 80  10^6 dest-pixels/sec/GHz.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, representing rgb</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleColor4xLI(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a special case of color linear interpolated scaling,
 for 4x upscaling.  It is about 3x faster than using
 the generic pixScaleColorLI().
 (2) The speed on intel hardware is about
 30  10^6 dest-pixels/sec/GHz
 (3) This scales each component separately, using pixScaleGray4xLI().
 It would be about 4x faster to inline the color code properly,
 in analogy to scaleColor4xLILow(), and I leave this as
 an exercise for someone who really needs it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp, representing rgb</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleGrayLI(LeptonicaSharp.Pix,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, no cmap</param>
	<param name="scalex">must both be GT= 0.7</param>
	<param name="scaley">must both be GT= 0.7</param>
	<returns>pixd, or NULL on error This function is appropriate for upscaling magnification, where the scale factor is GT 1, as well as for a small amount of downscaling reduction, with scale factor GT 0.7.  If the scale factor is LT 0.7, the best result is obtained by area mapping, but this is relatiely expensive.  A less expensive alternative with scale factor LT 0.7 is low-pass filtering followed by subsampling (pixScaleSmooth()), which is effectively a cheap form of area mapping. Some more details follow. For each pixel in the dest, this does a linear interpolation of 4 neighboring pixels in the src. Specifically, consider the UL corner of src and dest pixels.  The UL corner of the dest falls within a src pixel, whose four corners are the UL corners of 4 adjacent src pixels.  The value of the dest is taken by linear interpolation using the values of the four src pixels and the distance of the UL corner of the dest from each corner. If the image is expanded so that the dest pixel is smaller than the src pixel, such interpolation is a reasonable approach.  This interpolation is also good for a small image reduction factor that is not more than a 2x reduction. Note that the linear interpolation algorithm for scaling is identical in form to the area-mapping algorithm for grayscale rotation.  The latter corresponds to a translation of each pixel without scaling. This function is NOT optimal if the scaling involves a large reduction.    If the image is significantly reduced, so that the dest pixel is much larger than the src pixels, this interpolation, which is over src pixels only near the UL corner of the dest pixel, is not going to give a good area-mapping average. Because area mapping for image scaling is considerably more computationally intensive than linear interpolation, we choose not to use it.   For large image reduction, linear interpolation over adjacent src pixels degenerates asymptotically to subsampling.  But subsampling without a low-pass pre-filter causes aliasing by the nyquist theorem.  To avoid aliasing, a low-pass filter e.g., an averaging filter of size roughly equal to the dest pixel i.e., the reduction factor should be applied to the src before subsampling. As an alternative to low-pass filtering and subsampling for large reduction factors, linear interpolation can also be done between the widely separated src pixels in which the corners of the dest pixel lie.  This also is not optimal, as it samples src pixels only near the corners of the dest pixel, and it is not implemented. The speed on circa 2005 Intel hardware for the general case (not 2x) is about 13  10^6 dest-pixels/sec/GHz.  The special 2x case runs at about 100  10^6 dest-pixels/sec/GHz.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleGray2xLI(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a special case of gray linear interpolated scaling,
 for 2x upscaling.  It is about 6x faster than using
 the generic pixScaleGrayLI().
 (2) The speed on intel hardware is about
 100  10^6 dest-pixels/sec/GHz
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, not cmapped</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleGray4xLI(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is a special case of gray linear interpolated scaling,
 for 4x upscaling.  It is about 12x faster than using
 the generic pixScaleGrayLI().
 (2) The speed on intel hardware is about
 160  10^6 dest-pixels/sec/GHz.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale, not cmapped</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleGray2xLIThresh(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This does 2x upscale on pixs, using linear interpolation,
 followed by thresholding to binary.
 (2) Buffers are used to avoid making a large grayscale image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="thresh">between 0 and 256</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleGray2xLIDither(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This does 2x upscale on pixs, using linear interpolation,
 followed by Floyd-Steinberg dithering to binary.
 (2) Buffers are used to avoid making a large grayscale image.
 ~ Two line buffers are used for the src, required for the 2x
 LI upscale.
 ~ Three line buffers are used for the intermediate image.
 Two are filled with each 2xLI row operation; the third is
 needed because the upscale and dithering ops are out of sync.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleGray4xLIThresh(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This does 4x upscale on pixs, using linear interpolation,
 followed by thresholding to binary.
 (2) Buffers are used to avoid making a large grayscale image.
 (3) If a full 4x expanded grayscale image can be kept in memory,
 this function is only about 10% faster than separately doing
 a linear interpolation to a large grayscale image, followed
 by thresholding to binary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="thresh">between 0 and 256</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleGray4xLIDither(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This does 4x upscale on pixs, using linear interpolation,
 followed by Floyd-Steinberg dithering to binary.
 (2) Buffers are used to avoid making a large grayscale image.
 ~ Two line buffers are used for the src, required for the
 4xLI upscale.
 ~ Five line buffers are used for the intermediate image.
 Four are filled with each 4xLI row operation; the fifth
 is needed because the upscale and dithering ops are
 out of sync.
 (3) If a full 4x expanded grayscale image can be kept in memory,
 this function is only about 5% faster than separately doing
 a linear interpolation to a large grayscale image, followed
 by error-diffusion dithering to binary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleBySampling(LeptonicaSharp.Pix,System.Single,System.Single)">
	<summary>
 Notes
 (1) This function samples from the source without
 filtering.  As a result, aliasing will occur for
 subsampling (%scalex and/or %scaley LT 1.0).
 (2) If %scalex == 1.0 and %scaley == 1.0, returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp</param>
	<param name="scalex">both GT 0.0</param>
	<param name="scaley">both GT 0.0</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleBySamplingToSize(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This guarantees that the output scaled image has the
 dimension(s) you specify.
 ~ To specify the width with isotropic scaling, set %hd = 0.
 ~ To specify the height with isotropic scaling, set %wd = 0.
 ~ If both %wd and %hd are specified, the image is scaled
 (in general, anisotropically) to that size.
 ~ It is an error to set both %wd and %hd to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16 and 32 bpp</param>
	<param name="wd">target width; use 0 if using height as target</param>
	<param name="hd">target height; use 0 if using width as target</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleByIntSampling(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Simple interface to pixScaleBySampling(), for
 isotropic integer reduction.
 (2) If %factor == 1, returns a copy.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp</param>
	<param name="factor">integer subsampling</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleRGBToGrayFast(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does simultaneous subsampling by an integer factor and
 extraction of the color from the RGB pix.
 (2) It is designed for maximum speed, and is used for quickly
 generating a downsized grayscale image from a higher resolution
 RGB image.  This would typically be used for image analysis.
 (3) The standard color byte order (RGBA) is assumed.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="factor">integer reduction factor GT= 1</param>
	<param name="color">one of COLOR_RED, COLOR_GREEN, COLOR_BLUE</param>
	<returns>pixd 8 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleRGBToBinaryFast(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does simultaneous subsampling by an integer factor and
 conversion from RGB to gray to binary.
 (2) It is designed for maximum speed, and is used for quickly
 generating a downsized binary image from a higher resolution
 RGB image.  This would typically be used for image analysis.
 (3) It uses the green channel to represent the RGB pixel intensity.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp RGB</param>
	<param name="factor">integer reduction factor GT= 1</param>
	<param name="thresh">binarization threshold</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleGrayToBinaryFast(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This does simultaneous subsampling by an integer factor and
 thresholding from gray to binary.
 (2) It is designed for maximum speed, and is used for quickly
 generating a downsized binary image from a higher resolution
 gray image.  This would typically be used for image analysis.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp grayscale</param>
	<param name="factor">integer reduction factor GT= 1</param>
	<param name="thresh">binarization threshold</param>
	<returns>pixd 1 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleSmooth(LeptonicaSharp.Pix,System.Single,System.Single)">
	<summary>
 Notes
 (1) This function should only be used when the scale factors are less
 than or equal to 0.7 (i.e., more than about 1.42x reduction).
 If either scale factor is larger than 0.7, we issue a warning
 and call pixScaleGeneral(), which will invoke linear
 interpolation without sharpening.
 (2) This works only on 2, 4, 8 and 32 bpp images, and if there is
 a colormap, it is removed by converting to RGB.  In other
 cases, we issue a warning and call pixScaleGeneral().
 (3) It does simple (flat filter) convolution, with a filter size
 commensurate with the amount of reduction, to avoid antialiasing.
 (4) It does simple subsampling after smoothing, which is appropriate
 for this range of scaling.  Linear interpolation gives essentially
 the same result with more computation for these scale factors,
 so we don't use it.
 (5) The result is the same as doing a full block convolution followed by
 subsampling, but this is faster because the results of the block
 convolution are only computed at the subsampling locations.
 In fact, the computation time is approximately independent of
 the scale factor, because the convolution kernel is adjusted
 so that each source pixel is summed approximately once.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
	<param name="scalex">must both be LT 0.7</param>
	<param name="scaley">must both be LT 0.7</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleSmoothToSize(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See notes in pixScaleSmooth().
 (2) The output scaled image has the dimension(s) you specify
 To specify the width with isotropic scaling, set %hd = 0.
 To specify the height with isotropic scaling, set %wd = 0.
 If both %wd and %hd are specified, the image is scaled
 (in general, anisotropically) to that size.
 It is an error to set both %wd and %hd to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
	<param name="wd">target width; use 0 if using height as target</param>
	<param name="hd">target height; use 0 if using width as target</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleRGBToGray2(LeptonicaSharp.Pix,System.Single,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb</param>
	<param name="rwt">must sum to 1.0</param>
	<param name="gwt">must sum to 1.0</param>
	<param name="bwt">must sum to 1.0</param>
	<returns>pixd, 8 bpp, 2x reduced, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleAreaMap(LeptonicaSharp.Pix,System.Single,System.Single)">
	<summary>
 Notes
 (1) This function should only be used when the scale factors are less
 than or equal to 0.7 (i.e., more than about 1.42x reduction).
 If either scale factor is larger than 0.7, we issue a warning
 and call pixScaleGeneral(), which will invoke linear
 interpolation without sharpening.
 (2) This works only on 2, 4, 8 and 32 bpp images.  If there is
 a colormap, it is removed by converting to RGB.  In other
 cases, we issue a warning and call pixScaleGeneral().
 (3) This is faster than pixScale() because it does not do sharpening.
 (4) It does a relatively expensive area mapping computation, to
 avoid antialiasing.  It is about 2x slower than pixScaleSmooth(),
 but the results are much better on fine text.
 (5) This is typically about 20% faster for the special cases of
 2x, 4x, 8x and 16x reduction.
 (6) Surprisingly, there is no speedup (and a slight quality
 impairment) if you do as many successive 2x reductions as
 possible, ending with a reduction with a scale factor larger
 than 0.5.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
	<param name="scalex">must both be LT= 0.7</param>
	<param name="scaley">must both be LT= 0.7</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleAreaMap2(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This function does an area mapping (average) for 2x
 reduction.
 (2) This works only on 2, 4, 8 and 32 bpp images.  If there is
 a colormap, it is removed by converting to RGB.
 (3) Speed on 3 GHz processor
 Color 160 Mpix/sec
 Gray 700 Mpix/sec
 This contrasts with the speed of the general pixScaleAreaMap()
 Color 35 Mpix/sec
 Gray 50 Mpix/sec
 (4) From (3), we see that this special function is about 4.5x
 faster for color and 14x faster for grayscale
 (5) Consequently, pixScaleAreaMap2() is incorporated into the
 general area map scaling function, for the special cases
 of 2x, 4x, 8x and 16x reduction.
 </summary>
	<remarks>
	</remarks>
	<param name="pix">2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleAreaMapToSize(LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See notes in pixScaleAreaMap().
 (2) The output scaled image has the dimension(s) you specify
 To specify the width with isotropic scaling, set %hd = 0.
 To specify the height with isotropic scaling, set %wd = 0.
 If both %wd and %hd are specified, the image is scaled
 (in general, anisotropically) to that size.
 It is an error to set both %wd and %hd to 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap</param>
	<param name="wd">target width; use 0 if using height as target</param>
	<param name="hd">target height; use 0 if using width as target</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleBinary(LeptonicaSharp.Pix,System.Single,System.Single)">
	<summary>
 Notes
 (1) This function samples from the source without
 filtering.  As a result, aliasing will occur for
 subsampling (scalex and scaley LT 1.0).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="scalex">both GT 0.0</param>
	<param name="scaley">both GT 0.0</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleToGray(LeptonicaSharp.Pix,System.Single)">
	<summary>
 Notes
 For faster scaling in the range of scalefactors from 0.0625 to 0.5,
 with very little difference in quality, use pixScaleToGrayFast().
 Binary images have sharp edges, so they intrinsically have very
 high frequency content.  To avoid aliasing, they must be low-pass
 filtered, which tends to blur the edges.  How can we keep relatively
 crisp edges without aliasing?  The trick is to do binary upscaling
 followed by a power-of-2 scaleToGray.  For large reductions, where
 you don't end up with much detail, some corners can be cut.
 The intent here is to get high quality reduced grayscale
 images with relatively little computation.  We do binary
 pre-scaling followed by scaleToGrayN() for best results,
 esp. to avoid excess blur when the scale factor is near
 an inverse power of 2.  Where a low-pass filter is required,
 we use simple convolution kernels either the hat filter for
 linear interpolation or a flat filter for larger downscaling.
 Other choices, such as a perfect bandpass filter with infinite extent
 (the sinc) or various approximations to it (e.g., lanczos), are
 unnecessarily expensive.
 The choices made are as follows
 (1) Do binary upscaling before scaleToGrayN() for scalefactors GT 1/8
 (2) Do binary downscaling before scaleToGray8() for scalefactors
 between 1/16 and 1/8.
 (3) Use scaleToGray16() before grayscale downscaling for
 scalefactors less than 1/16
 Another reasonable choice would be to start binary downscaling
 for scalefactors below 1/4, rather than below 1/8 as we do here.
 The general scaling rules, not all of which are used here, go as follows
 (1) For grayscale upscaling, use pixScaleGrayLI().  However,
 note that edges will be visibly blurred for scalefactors
 near (but above) 1.0.  Replication will avoid edge blur,
 and should be considered for factors very near 1.0.
 (2) For grayscale downscaling with a scale factor larger than
 about 0.7, use pixScaleGrayLI().  For scalefactors near
 (but below) 1.0, you tread between Scylla and Charybdis.
 pixScaleGrayLI() again gives edge blurring, but
 pixScaleBySampling() gives visible aliasing.
 (3) For grayscale downscaling with a scale factor smaller than
 about 0.7, use pixScaleSmooth()
 (4) For binary input images, do as much scale to gray as possible
 using the special integer functions (2, 3, 4, 8 and 16).
 (5) It is better to upscale in binary, followed by scaleToGrayN()
 than to do scaleToGrayN() followed by an upscale using either
 LI or oversampling.
 (6) It may be better to downscale in binary, followed by
 scaleToGrayN() than to first use scaleToGrayN() followed by
 downscaling.  For downscaling between 8x and 16x, this is
 a reasonable option.
 (7) For reductions greater than 16x, it's reasonable to use
 scaleToGray16() followed by further grayscale downscaling.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="scalefactor">reduction must be GT 0.0 and LT 1.0</param>
	<returns>pixd 8 bpp, scaled down by scalefactor in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleToGrayFast(LeptonicaSharp.Pix,System.Single)">
	<summary>
 Notes
 (1) See notes in pixScaleToGray() for the basic approach.
 (2) This function is considerably less expensive than pixScaleToGray()
 for scalefactor in the range (0.0625 ... 0.5), and the
 quality is nearly as good.
 (3) Unlike pixScaleToGray(), which does binary upscaling before
 downscaling for scale factors GT= 0.0625, pixScaleToGrayFast()
 first downscales in binary for all scale factors LT 0.5, and
 then does a 2x scale-to-gray as the final step.  For
 scale factors LT 0.0625, both do a 16x scale-to-gray, followed
 by further grayscale reduction.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="scalefactor">reduction must be GT 0.0 and LT 1.0</param>
	<returns>pixd 8 bpp, scaled down by scalefactor in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleToGray2(LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, scaled down by 2x in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleToGray3(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) Speed is about 100 x 10^6 src-pixels/sec/GHz.
 Another way to express this is it processes 1 src pixel
 in about 10 cycles.
 (2) The width of pixd is truncated is truncated to a factor of 8.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, scaled down by 3x in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleToGray4(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The width of pixd is truncated is truncated to a factor of 2.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, scaled down by 4x in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleToGray6(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The width of pixd is truncated is truncated to a factor of 8.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, scaled down by 6x in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleToGray8(LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, scaled down by 8x in each direction, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleToGray16(LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<returns>pixd 8 bpp, scaled down by 16x in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleToGrayMipmap(LeptonicaSharp.Pix,System.Single)">
	<summary>
 Notes
 This function is here mainly for pedagogical reasons.
 Mip-mapping is widely used in graphics for texture mapping, because
 the texture changes smoothly with scale.  This is accomplished by
 constructing a multiresolution pyramid and, for each pixel,
 doing a linear interpolation between corresponding pixels in
 the two planes of the pyramid that bracket the desired resolution.
 The computation is very efficient, and is implemented in hardware
 in high-end graphics cards.
 We can use mip-mapping for scale-to-gray by using two scale-to-gray
 reduced images (we don't need the entire pyramid) selected from
 the set {2x, 4x, ... 16x}, and interpolating.  However, we get
 severe aliasing, probably because we are subsampling from the
 higher resolution image.  The method is very fast, but the result
 is very poor.  In fact, the results don't look any better than
 either subsampling off the higher-res grayscale image or oversampling
 on the lower-res image.  Consequently, this method should NOT be used
 for generating reduced images, scale-to-gray or otherwise.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="scalefactor">reduction must be GT 0.0 and LT 1.0</param>
	<returns>pixd 8 bpp, scaled down by scalefactor in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleMipmap(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Single)">
	<summary>
 Notes
 (1) See notes in pixScaleToGrayMipmap().
 (2) This function suffers from aliasing effects that are
 easily seen in document images.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">high res 8 bpp, no cmap</param>
	<param name="pixs2">low res -- 2x reduced -- 8 bpp, no cmap</param>
	<param name="scale">reduction with respect to high res image, GT 0.5</param>
	<returns>8 bpp pix, scaled down by reduction in each direction, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExpandReplicate(LeptonicaSharp.Pix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 16, 32 bpp</param>
	<param name="factor">integer scale factor for replicative expansion</param>
	<returns>pixd scaled up, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleGrayMinMax(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_CHOOSE_M)">
	<summary>
 Notes
 (1) The downscaled pixels in pixd are the min, max or (max - min)
 of the corresponding set of xfact  yfact pixels in pixs.
 (2) Using L_CHOOSE_MIN is equivalent to a grayscale erosion,
 using a brick Sel of size (xfact  yfact), followed by
 subsampling within each (xfact  yfact) cell.  Using
 L_CHOOSE_MAX is equivalent to the corresponding dilation.
 (3) Using L_CHOOSE_MAXDIFF finds the difference between max
 and min values in each cell.
 (4) For the special case of downscaling by 2x in both directions,
 pixScaleGrayMinMax2() is about 2x more efficient.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="xfact">x downscaling factor; integer</param>
	<param name="yfact">y downscaling factor; integer</param>
	<param name="type">L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF</param>
	<returns>pixd 8 bpp</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleGrayMinMax2(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_CHOOSE_M)">
	<summary>
 Notes
 (1) Special version for 2x reduction.  The downscaled pixels
 in pixd are the min, max or (max - min) of the corresponding
 set of 4 pixels in pixs.
 (2) The max and min operations are a special case (for levels 1
 and 4) of grayscale analog to the binary rank scaling operation
 pixReduceRankBinary2().  Note, however, that because of
 the photometric definition that higher gray values are
 lighter, the erosion-like L_CHOOSE_MIN will darken
 the resulting image, corresponding to a threshold level 1
 in the binary case.  Likewise, L_CHOOSE_MAX will lighten
 the pixd, corresponding to a threshold level of 4.
 (3) To choose any of the four rank levels in a 2x grayscale
 reduction, use pixScaleGrayRank2().
 (4) This runs at about 70 MPix/sec/GHz of source data for
 erosion and dilation.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="type">L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF</param>
	<returns>pixd 8 bpp downscaled by 2x</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleGrayRankCascade(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This performs up to four cascaded 2x rank reductions.
 (2) Use level = 0 to truncate the cascade.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, not cmapped</param>
	<param name="level1">rank thresholds, in set {0, 1, 2, 3, 4}</param>
	<param name="level2">rank thresholds, in set {0, 1, 2, 3, 4}</param>
	<param name="level3">rank thresholds, in set {0, 1, 2, 3, 4}</param>
	<param name="level4">rank thresholds, in set {0, 1, 2, 3, 4}</param>
	<returns>pixd 8 bpp, downscaled by up to 16x</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleGrayRank2(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Rank 2x reduction.  If rank == 1(4), the downscaled pixels
 in pixd are the min(max) of the corresponding set of
 4 pixels in pixs.  Values 2 and 3 are intermediate.
 (2) This is the grayscale analog to the binary rank scaling operation
 pixReduceRankBinary2().  Here, because of the photometric
 definition that higher gray values are lighter, rank 1 gives
 the darkest pixel, whereas rank 4 gives the lightest pixel.
 This is opposite to the binary rank operation.
 (3) For rank = 1 and 4, this calls pixScaleGrayMinMax2(),
 which runs at about 70 MPix/sec/GHz of source data.
 For rank 2 and 3, this runs 3x slower, at about 25 MPix/sec/GHz.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp, no cmap</param>
	<param name="rank">1 (darkest), 2, 3, 4 (lightest)</param>
	<returns>pixd 8 bpp, downscaled by 2x</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleAndTransferAlpha(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Single,System.Single)">
	<summary>
 Notes
 (1) This scales the alpha component of pixs and inserts into pixd.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">32 bpp, scaled image</param>
	<param name="pixs">32 bpp, original unscaled image</param>
	<param name="scalex">both GT 0.0</param>
	<param name="scaley">both GT 0.0</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixScaleWithAlpha(LeptonicaSharp.Pix,System.Single,System.Single,System.Single,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The alpha channel is transformed separately from pixs,
 and aligns with it, being fully transparent outside the
 boundary of the transformed pixs.  For pixels that are fully
 transparent, a blending function like pixBlendWithGrayMask()
 will give zero weight to corresponding pixels in pixs.
 (2) Scaling is done with area mapping or linear interpolation,
 depending on the scale factors.  Default sharpening is done.
 (3) If pixg is NULL, it is generated as an alpha layer that is
 partially opaque, using %fract.  Otherwise, it is cropped
 to pixs if required, and %fract is ignored.  The alpha
 channel in pixs is never used.
 (4) Colormaps are removed to 32 bpp.
 (5) The default setting for the border values in the alpha channel
 is 0 (transparent) for the outermost ring of pixels and
 (0.5  fract  255) for the second ring.  When blended over
 a second image, this
 (a) shrinks the visible image to make a clean overlap edge
 with an image below, and
 (b) softens the edges by weakening the aliasing there.
 Use l_setAlphaMaskBorder() to change these values.
 (6) A subtle use of gamma correction is to remove gamma correction
 before scaling and restore it afterwards.  This is done
 by sandwiching this function between a gamma/inverse-gamma
 photometric transform
 pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);
 pixd = pixScaleWithAlpha(pixt, scalex, scaley, NULL, fract);
 pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);
 pixDestroy(pixt);
 This has the side-effect of producing artifacts in the very
 dark regions.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">32 bpp rgb or cmapped</param>
	<param name="scalex">must be GT 0.0</param>
	<param name="scaley">must be GT 0.0</param>
	<param name="pixg">8 bpp, can be null</param>
	<param name="fract">between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque</param>
	<returns>pixd 32 bpp rgba, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfillBinary(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This is for binary seedfill (aka "binary reconstruction").
 (2) There are 3 cases
 (a) pixd == null (make a new pixd)
 (b) pixd == pixs (in-place)
 (c) pixd != pixs
 (3) If you know the case, use these patterns for clarity
 (a) pixd = pixSeedfillBinary(NULL, pixs, ...);
 (b) pixSeedfillBinary(pixs, pixs, ...);
 (c) pixSeedfillBinary(pixd, pixs, ...);
 (4) The resulting pixd contains the filled seed.  For some
 applications you want to OR it with the inverse of
 the filling mask.
 (5) The input seed and mask images can be different sizes, but
 in typical use the difference, if any, would be only
 a few pixels in each direction.  If the sizes differ,
 the clipping is handled by the low-level function
 seedfillBinaryLow().
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs; 1 bpp</param>
	<param name="pixs">1 bpp seed</param>
	<param name="pixm">1 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfillBinaryRestricted(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See usage for pixSeedfillBinary(), which has unrestricted fill.
 In pixSeedfillBinary(), the filling distance is unrestricted
 and can be larger than pixs, depending on the topology of
 th mask.
 (2) There are occasions where it is useful not to permit the
 fill to go more than a certain distance into the mask.
 %xmax specifies the maximum horizontal distance allowed
 in the fill; %ymax does likewise in the vertical direction.
 (3) Operationally, the max "distance" allowed for the fill
 is a linear distance from the original seed, independent
 of the actual mask topology.
 (4) Another formulation of this problem, not implemented,
 would use the manhattan distance from the seed, as
 determined by a breadth-first search starting at the seed
 boundaries and working outward where the mask fg allows.
 How this might use the constraints of separate xmax and ymax
 is not clear.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null, equal to pixs, or different from pixs; 1 bpp</param>
	<param name="pixs">1 bpp seed</param>
	<param name="pixm">1 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<param name="xmax">max distance in x direction of fill into the mask</param>
	<param name="ymax">max distance in y direction of fill into the mask</param>
	<returns>pixd always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixHolesByFilling(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) To get 4-c.c. holes of the 8-c.c. as foreground, use
 4-connected filling; to get 8-c.c. holes of the 4-c.c.
 as foreground, use 8-connected filling.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">4 or 8</param>
	<returns>pixd  inverted image of all holes, or NULL on error Action 1 Start with 1-pixel black border on otherwise white pixd 2 Use the inverted pixs as the filling mask to fill in all the pixels from the border to the pixs foreground 3 OR the result with pixs to have an image with all ON pixels except for the holes. 4 Invert the result to get the holes as foreground</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFillClosedBorders(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Start with 1-pixel black border on otherwise white pixd
 (2) Subtract input pixs to remove border pixels that were
 also on the closed border
 (3) Use the inverted pixs as the filling mask to fill in
 all the pixels from the outer border to the closed border
 on pixs
 (4) Invert the result to get the filled component, including
 the input border
 (5) If the borders are 4-c.c., use 8-c.c. filling, and v.v.
 (6) Closed borders within c.c. that represent holes, etc., are filled.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">filling connectivity 4 or 8</param>
	<returns>pixd  all topologically outer closed borders are filled as connected comonents, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixExtractBorderConnComps(LeptonicaSharp.Pix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">filling connectivity 4 or 8</param>
	<returns>pixd  all pixels in the src that are in connected components touching the border, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRemoveBorderConnComps(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This removes all fg components touching the border.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">filling connectivity 4 or 8</param>
	<returns>pixd  all pixels in the src that are not touching the border or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFillBgFromBorder(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This fills all bg components touching the border to fg.
 It is the photometric inverse of pixRemoveBorderConnComps().
 (2) Invert the result to get the "holes" left after this fill.
 This can be done multiple times, extracting holes within
 holes after each pair of fillings.  Specifically, this code
 peels away n successive embeddings of components
 \code
 pix1 = LTinitial imageGT
 for (i = 0; i LT 2  n; i++) {
 pix2 = pixFillBgFromBorder(pix1, 8);
 pixInvert(pix2, pix2);
 pixDestroy(pix1);
 pix1 = pix2;
 }
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="connectivity">filling connectivity 4 or 8</param>
	<returns>pixd with the background c.c. touching the border filled to foreground, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFillHolesToBoundingRect(LeptonicaSharp.Pix,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) This does not fill holes that are smaller in area than 'minsize'.
 (2) This does not fill holes with an area larger than
 'maxhfract' times the fg area of the c.c.
 (3) This does not expand the fg of the c.c. to bounding rect if
 the fg area is less than 'minfgfract' times the area of the
 bounding rect.
 (4) The decisions are made as follows
 ~ Decide if we are filling the holes; if so, when using
 the fg area, include the filled holes.
 ~ Decide based on the fg area if we are filling to a bounding rect.
 If so, do it.
 If not, fill the holes if the condition is satisfied.
 (5) The choice of minsize depends on the resolution.
 (6) For solidifying image mask regions on printed materials,
 which tend to be rectangular, values for maxhfract
 and minfgfract around 0.5 are reasonable.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="minsize">min number of pixels in the hole</param>
	<param name="maxhfract">max hole area as fraction of fg pixels in the cc</param>
	<param name="minfgfract">min fg area as fraction of bounding rectangle</param>
	<returns>pixd pixs, with some holes possibly filled and some c.c. possibly expanded to their bounding rects, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfillGray(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place filling operation on the seed, pixs,
 where the clipping mask is always above or at the level
 of the seed as it is filled.
 (2) For details of the operation, see the description in
 seedfillGrayLow() and the code there.
 (3) As an example of use, see the description in pixHDome().
 There, the seed is an image where each pixel is a fixed
 amount smaller than the corresponding mask pixel.
 (4) Reference paper 
 L. Vincent, Morphological grayscale reconstruction in image
 analysis applications and efficient algorithms, IEEE Transactions
 on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp seed; filled in place</param>
	<param name="pixm">8 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfillGrayInv(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place filling operation on the seed, pixs,
 where the clipping mask is always below or at the level
 of the seed as it is filled.  Think of filling up a basin
 to a particular level, given by the maximum seed value
 in the basin.  Outside the filled region, the mask
 is above the filling level.
 (2) Contrast this with pixSeedfillGray(), where the clipping mask
 is always above or at the level of the fill.  An example
 of its use is the hdome fill, where the seed is an image
 where each pixel is a fixed amount smaller than the
 corresponding mask pixel.
 (3) The basin fill, pixSeedfillGrayBasin(), is a special case
 where the seed pixel values are generated from the mask,
 and where the implementation uses pixSeedfillGray() by
 inverting both the seed and mask.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp seed; filled in place</param>
	<param name="pixm">8 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfillGraySimple(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place filling operation on the seed, pixs,
 where the clipping mask is always above or at the level
 of the seed as it is filled.
 (2) For details of the operation, see the description in
 seedfillGrayLowSimple() and the code there.
 (3) As an example of use, see the description in pixHDome().
 There, the seed is an image where each pixel is a fixed
 amount smaller than the corresponding mask pixel.
 (4) Reference paper 
 L. Vincent, Morphological grayscale reconstruction in image
 analysis applications and efficient algorithms, IEEE Transactions
 on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp seed; filled in place</param>
	<param name="pixm">8 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfillGrayInvSimple(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This is an in-place filling operation on the seed, pixs,
 where the clipping mask is always below or at the level
 of the seed as it is filled.  Think of filling up a basin
 to a particular level, given by the maximum seed value
 in the basin.  Outside the filled region, the mask
 is above the filling level.
 (2) Contrast this with pixSeedfillGraySimple(), where the clipping mask
 is always above or at the level of the fill.  An example
 of its use is the hdome fill, where the seed is an image
 where each pixel is a fixed amount smaller than the
 corresponding mask pixel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp seed; filled in place</param>
	<param name="pixm">8 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedfillGrayBasin(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This fills from a seed within basins defined by a filling mask.
 The seed value(s) are greater than the corresponding
 filling mask value, and the result has the bottoms of
 the basins raised by the initial seed value.
 (2) The seed has value 255 except where pixb has fg (1), which
 are the seed 'locations'.  At the seed locations, the seed
 value is the corresponding value of the mask pixel in pixm
 plus %delta.  If %delta == 0, we return a copy of pixm.
 (3) The actual filling is done using the standard grayscale filling
 operation on the inverse of the mask and using the inverse
 of the seed image.  After filling, we return the inverse of
 the filled seed.
 (4) As an example of use pixm can describe a grayscale image
 of text, where the (dark) text pixels are basins of
 low values; pixb can identify the local minima in pixm (say, at
 the bottom of the basins); and delta is the amount that we wish
 to raise (lighten) the basins.  We construct the seed
 (a.k.a marker) image from pixb, pixm and %delta.
 </summary>
	<remarks>
	</remarks>
	<param name="pixb">binary mask giving seed locations</param>
	<param name="pixm">8 bpp basin-type filling mask</param>
	<param name="delta">amount of seed value above mask</param>
	<param name="connectivity">4 or 8</param>
	<returns>pixd filled seed if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDistanceFunction(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_BOUNDARY_G)">
	<summary>
 Notes
 (1) This computes the distance of each pixel from the nearest
 background pixel.  All bg pixels therefore have a distance of 0,
 and the fg pixel distances increase linearly from 1 at the
 boundary.  It can also be used to compute the distance of
 each pixel from the nearest fg pixel, by inverting the input
 image before calling this function.  Then all fg pixels have
 a distance 0 and the bg pixel distances increase linearly
 from 1 at the boundary.
 (2) The algorithm, described in Leptonica on the page on seed
 filling and connected components, is due to Luc Vincent.
 In brief, we generate an 8 or 16 bpp image, initialized
 with the fg pixels of the input pix set to 1 and the
 1-boundary pixels (i.e., the boundary pixels of width 1 on
 the four sides set as either
 L_BOUNDARY_BG 0
 L_BOUNDARY_FG  max
 where max = 0xff for 8 bpp and 0xffff for 16 bpp.
 Then do raster/anti-raster sweeps over all pixels interior
 to the 1-boundary, where the value of each new pixel is
 taken to be 1 more than the minimum of the previously-seen
 connected pixels (using either 4 or 8 connectivity).
 Finally, set the 1-boundary pixels using the mirrored method;
 this removes the max values there.
 (3) Using L_BOUNDARY_BG clamps the distance to 0 at the
 boundary.  Using L_BOUNDARY_FG allows the distance
 at the image boundary to "float".
 (4) For 4-connected, one could initialize only the left and top
 1-boundary pixels, and go all the way to the right
 and bottom; then coming back reset left and top.  But we
 instead use a method that works for both 4- and 8-connected.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp source</param>
	<param name="connectivity">4 or 8</param>
	<param name="outdepth">8 or 16 bits for pixd</param>
	<param name="boundcond">L_BOUNDARY_BG, L_BOUNDARY_FG</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSeedspread(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) The raster/anti-raster method for implementing this filling
 operation was suggested by Ray Smith.
 (2) This takes an arbitrary set of nonzero pixels in pixs, which
 can be sparse, and spreads (extrapolates) the values to
 fill all the pixels in pixd with the nonzero value it is
 closest to in pixs.  This is similar (though not completely
 equivalent) to doing a Voronoi tiling of the image, with a
 tile surrounding each pixel that has a nonzero value.
 All pixels within a tile are then closer to its "central"
 pixel than to any others.  Then assign the value of the
 "central" pixel to each pixel in the tile.
 (3) This is implemented by computing a distance function in parallel
 with the fill.  The distance function uses free boundary
 conditions (assumed maxval outside), and it controls the
 propagation of the pixels in pixd away from the nonzero
 (seed) values.  This is done in 2 traversals (raster/antiraster).
 In the raster direction, whenever the distance function
 is nonzero, the spread pixel takes on the value of its
 predecessor that has the minimum distance value.  In the
 antiraster direction, whenever the distance function is nonzero
 and its value is replaced by a smaller value, the spread
 pixel takes the value of the predecessor with the minimum
 distance value.
 (4) At boundaries where a pixel is equidistant from two
 nearest nonzero (seed) pixels, the decision of which value
 to use is arbitrary (greedy in search for minimum distance).
 This can give rise to strange-looking results, particularly
 for 4-connectivity where the L1 distance is computed from
 steps in N,S,E and W directions (no diagonals).
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp source</param>
	<param name="connectivity">4 or 8</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixLocalExtrema(LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This gives the actual local minima and maxima.
 A local minimum is a pixel whose surrounding pixels all
 have values at least as large, and likewise for a local
 maximum.  For the local minima, %maxmin is the upper
 bound for the value of pixs.  Likewise, for the local maxima,
 %minmax is the lower bound for the value of pixs.
 (2) The minima are found by starting with the erosion-and-equality
 approach of pixSelectedLocalExtrema().  This is followed
 by a qualification step, where each c.c. in the resulting
 minimum mask is extracted, the pixels bordering it are
 located, and they are queried.  If all of those pixels
 are larger than the value of that minimum, it is a true
 minimum and its c.c. is saved; otherwise the c.c. is
 rejected.  Note that if a bordering pixel has the
 same value as the minimum, it must then have a
 neighbor that is smaller, so the component is not a
 true minimum.
 (3) The maxima are found by inverting the image and looking
 for the minima there.
 (4) The generated masks can be used as markers for
 further operations.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="maxmin">max allowed for the min in a 3x3 neighborhood; use 0 for default which is to have no upper bound</param>
	<param name="minmax">min allowed for the max in a 3x3 neighborhood; use 0 for default which is to have no lower bound</param>
	<param name="ppixmin">mask of local minima</param>
	<param name="ppixmax">mask of local maxima</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSelectedLocalExtrema(LeptonicaSharp.Pix,System.Int32,LeptonicaSharp.Pix@,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) This selects those local 3x3 minima that are at least a
 specified distance from the nearest local 3x3 maxima, and v.v.
 for the selected set of local 3x3 maxima.
 The local 3x3 minima is the set of pixels whose value equals
 the value after a 3x3 brick erosion, and the local 3x3 maxima
 is the set of pixels whose value equals the value after
 a 3x3 brick dilation.
 (2) mindist is the minimum distance allowed between
 local 3x3 minima and local 3x3 maxima, in an 8-connected sense.
 mindist == 1 keeps all pixels found in step 1.
 mindist == 0 removes all pixels from each mask that are
 both a local 3x3 minimum and a local 3x3 maximum.
 mindist == 1 removes any local 3x3 minimum pixel that touches a
 local 3x3 maximum pixel, and likewise for the local maxima.
 To make the decision, visualize each local 3x3 minimum pixel
 as being surrounded by a square of size (2  mindist + 1)
 on each side, such that no local 3x3 maximum pixel is within
 that square; and v.v.
 (3) The generated masks can be used as markers for further operations.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="mindist">-1 for keeping all pixels; GT= 0 specifies distance</param>
	<param name="ppixmin">mask of local minima</param>
	<param name="ppixmax">mask of local maxima</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindEqualValues(LeptonicaSharp.Pix,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) The two images are aligned at the UL corner, and the returned
 image has ON pixels where the pixels in pixs1 and pixs2
 have equal values.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs1">8 bpp</param>
	<param name="pixs2">8 bpp</param>
	<returns>pixd 1 bpp mask, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSelectMinInConnComp(LeptonicaSharp.Pix,LeptonicaSharp.Pix,LeptonicaSharp.Pta@,LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) For each 8 connected component in pixm, this finds
 a pixel in pixs that has the lowest value, and saves
 it in a Pta.  If several pixels in pixs have the same
 minimum value, it picks the first one found.
 (2) For a mask pixm of true local minima, all pixels in each
 connected component have the same value in pixs, so it is
 fastest to select one of them using a special seedfill
 operation.  Not yet implemented.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp</param>
	<param name="pixm">1 bpp</param>
	<param name="ppta">pta of min pixel locations</param>
	<param name="pnav">numa of minima values</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRemoveSeededComponents(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This removes each component in pixm for which there is
 at least one seed in pixs.  If pixd == NULL, this returns
 the result in a new pixd.  Otherwise, it is an in-place
 operation on pixm.  In no situation is pixs altered,
 because we do the filling with a copy of pixs.
 (2) If bordersize GT 0, it also clears all pixels within a
 distance %bordersize of the edge of pixd.  This is here
 because pixLocalExtrema() typically finds local minima
 at the border.  Use %bordersize GT= 2 to remove these.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">; this can be null or equal to pixm; 1 bpp</param>
	<param name="pixs">1 bpp seed</param>
	<param name="pixm">1 bpp filling mask</param>
	<param name="connectivity">4 or 8</param>
	<param name="bordersize">amount of border clearing</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">initial number of sel ptrs; use 0 for default</param>
	<returns>sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaDestroy(LeptonicaSharp.Sela@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="psela">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.selCreate(System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) selCreate() initializes all values to 0.
 (2) After this call, (cy,cx) and nonzero data values must be
 assigned.  If a text name is not assigned here, it will
 be needed later when the sel is put into a sela.
 </summary>
	<remarks>
	</remarks>
	<param name="height"></param>
	<param name="width"></param>
	<param name="name">sel name; can be null</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selDestroy(LeptonicaSharp.Sel@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="psel">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.selCopy(LeptonicaSharp.Sel)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<returns>a copy of the sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selCreateBrick(System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Enumerations.SEL)">
	<summary>
 Notes
 (1) This is a rectangular sel of all hits, misses or don't cares.
 </summary>
	<remarks>
	</remarks>
	<param name="h">height, width</param>
	<param name="w">height, width</param>
	<param name="cy">origin, relative to UL corner at 0,0</param>
	<param name="cx">origin, relative to UL corner at 0,0</param>
	<param name="type">SEL_HIT, SEL_MISS, or SEL_DONT_CARE</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selCreateComb(System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_direction)">
	<summary>
 Notes
 (1) This generates a comb Sel of hits with the origin as
 near the center as possible.
 (2) In use, this is complemented by a brick sel of size %factor1,
 Both brick and comb sels are made by selectComposableSels().
 </summary>
	<remarks>
	</remarks>
	<param name="factor1">contiguous space between comb tines</param>
	<param name="factor2">number of comb tines</param>
	<param name="direction">L_HORIZ, L_VERT</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.create2dIntArray(System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The array[sy][sx] is indexed in standard "matrix notation",
 with the row index first.
 </summary>
	<remarks>
	</remarks>
	<param name="sy">rows == height</param>
	<param name="sx">columns == width</param>
	<returns>doubly indexed array i.e., an array of sy row pointers, each of which points to an array of sx ints</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaAddSel(LeptonicaSharp.Sela,LeptonicaSharp.Sel,System.String,LeptonicaSharp.Enumerations.L_access_storage)">
	<summary>
 Notes
 (1) This adds a sel, either inserting or making a copy.
 (2) Because every sel in a sela must have a name, it copies
 the input name if necessary.  You can input NULL for
 selname if the sel already has a name.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="sel">to be added</param>
	<param name="selname">ignored if already defined in sel; req'd in sel when added to a sela</param>
	<param name="copyflag">L_INSERT or L_COPY</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaGetCount(LeptonicaSharp.Sela)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaGetSel(LeptonicaSharp.Sela,System.Int32)">
	<summary>
 Notes
 (1) This returns a ptr to the sel, not a copy, so the caller
 must not destroy it!
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="i">index of sel to be retrieved not copied</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selGetName(LeptonicaSharp.Sel)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<returns>sel name not copied, or NULL if no name or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selSetName(LeptonicaSharp.Sel,System.String)">
	<summary>
 Notes
 (1) Always frees the existing sel name, if defined.
 (2) If name is not defined, just clears any existing sel name.
 </summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="name">; can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaFindSelByName(LeptonicaSharp.Sela,System.String,System.Int32@,System.Collections.Generic.List{LeptonicaSharp.Sel})">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="name">sel name</param>
	<param name="pindex"></param>
	<param name="psel">sel (not a copy)</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selGetElement(LeptonicaSharp.Sel,System.Int32,System.Int32,LeptonicaSharp.Enumerations.SEL@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="row"></param>
	<param name="col"></param>
	<param name="ptype">SEL_HIT, SEL_MISS, SEL_DONT_CARE</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selSetElement(LeptonicaSharp.Sel,System.Int32,System.Int32,LeptonicaSharp.Enumerations.SEL)">
	<summary>
 Notes
 (1) Because we use row and column to index into an array,
 they are always non-negative.  The location of the origin
 (and the type of operation) determine the actual
 direction of the rasterop.
 </summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="row"></param>
	<param name="col"></param>
	<param name="type">SEL_HIT, SEL_MISS, SEL_DONT_CARE</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selGetParameters(LeptonicaSharp.Sel,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="psy">each can be null</param>
	<param name="psx">each can be null</param>
	<param name="pcy">each can be null</param>
	<param name="pcx">each can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selSetOrigin(LeptonicaSharp.Sel,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="cy"></param>
	<param name="cx"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selGetTypeAtOrigin(LeptonicaSharp.Sel,LeptonicaSharp.Enumerations.SEL@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="ptype">SEL_HIT, SEL_MISS, SEL_DONT_CARE</param>
	<returns>0 if OK; 1 on error or if origin is not found</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaGetBrickName(LeptonicaSharp.Sela,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="hsize">of brick sel</param>
	<param name="vsize">of brick sel</param>
	<returns>sel name new string, or NULL if no name or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaGetCombName(LeptonicaSharp.Sela,System.Int32,LeptonicaSharp.Enumerations.L_direction)">
	<summary>
 Notes
 (1) Combs are by definition 1-dimensional, either horiz or vert.
 (2) Use this with comb Sels; e.g., from selaAddDwaCombs().
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="size">the product of sizes of the brick and comb parts</param>
	<param name="direction">L_HORIZ, L_VERT</param>
	<returns>sel name new string, or NULL if name not found or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getCompositeParameters(System.Int32,System.Int32@,System.Int32@,System.String[]@,System.String[]@,System.String[]@,System.String[]@)">
	<summary>
 Notes
 (1) This uses the big lookup table at the top of this file.
 (2) All returned strings are copies that must be freed.
 </summary>
	<remarks>
	</remarks>
	<param name="size"></param>
	<param name="psize1">brick factor size</param>
	<param name="psize2">comb factor size</param>
	<param name="pnameh1">name of horiz brick</param>
	<param name="pnameh2">name of horiz comb</param>
	<param name="pnamev1">name of vert brick</param>
	<param name="pnamev2">name of vert comb</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaGetSelnames(LeptonicaSharp.Sela)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sa of all sel names, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selFindMaxTranslations(LeptonicaSharp.Sel,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
  These are the maximum shifts for the erosion operation.
 For example, when j LT cx, the shift of the image
 is +x to the cx.  This is a positive xp shift.
 </summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="pxp">max shifts</param>
	<param name="pyp">max shifts</param>
	<param name="pxn">max shifts</param>
	<param name="pyn">max shifts</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selRotateOrth(LeptonicaSharp.Sel,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="quads">0 - 4; number of 90 degree cw rotations</param>
	<returns>seld, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">filename</param>
	<returns>sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selRead(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">filename</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selReadStream(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaWrite(System.String,LeptonicaSharp.Sela)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">filename</param>
	<param name="sela"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.Sela)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="sela"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selWrite(System.String,LeptonicaSharp.Sel)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname">filename</param>
	<param name="sel"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.Sel)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="sel"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selCreateFromString(System.String,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) The text is an array of chars (in row-major order) where
 each char can be one of the following
 'x' hit
 'o' miss
 ' ' don't-care
 (2) When the origin falls on a hit or miss, use an upper case
 char (e.g., 'X' or 'O') to indicate it.  When the origin
 falls on a don't-care, indicate this with a 'C'.
 The string must have exactly one origin specified.
 (3) The advantage of this method is that the text can be input
 in a format that shows the 2D layout of the Sel; e.g.,
 \code
 static const char seltext = "x "
 "x Oo "
 "x "
 "xxxxx";
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="text"></param>
	<param name="h">height, width</param>
	<param name="w">height, width</param>
	<param name="name">sel name; can be null</param>
	<returns>sel of the given size, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selPrintToString(LeptonicaSharp.Sel)">
	<summary>
 Notes
 (1) This is an inverse function of selCreateFromString.
 It prints a textual representation of the SEL to a malloc'd
 string.  The format is the same as selCreateFromString
 except that newlines are inserted into the output
 between rows.
 (2) This is useful for debugging.  However, if you want to
 save some Sels in a file, put them in a Sela and write
 them out with selaWrite().  They can then be read in
 with selaRead().
 </summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<returns>str string; caller must free</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaCreateFromFile(System.String)">
	<summary>
 Notes
 (1) The file contains a sequence of Sel descriptions.
 (2) Each Sel is formatted as follows
 ~ Any number of comment lines starting with '#' are ignored
 ~ The next line contains the selname
 ~ The next lines contain the Sel data.  They must be
 formatted similarly to the string format in
 selCreateFromString(), with each line beginning and
 ending with a double-quote, and showing the 2D layout.
 ~ Each Sel ends when a blank line, a comment line, or
 the end of file is reached.
 (3) See selCreateFromString() for a description of the string
 format for the Sel data.  As an example, here are the lines
 of is a valid file for a single Sel.  In the file, all lines
 are left-justified
 # diagonal sel
 sel_5diag
 "x "
 " x   "
 "  X  "
 "   x "
 " x"
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selCreateFromPta(LeptonicaSharp.Pta,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) The origin and all points in the pta must be positive.
 </summary>
	<remarks>
	</remarks>
	<param name="pta"></param>
	<param name="cy">origin of sel</param>
	<param name="cx">origin of sel</param>
	<param name="name">sel name; can be null</param>
	<returns>sel of minimum required size, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selCreateFromPix(LeptonicaSharp.Pix,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) The origin must be positive.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<param name="cy">origin of sel</param>
	<param name="cx">origin of sel</param>
	<param name="name">sel name; can be null</param>
	<returns>sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selReadFromColorImage(System.String)">
	<summary>
 Notes
 (1) Loads an image from a file and creates a (hit-miss) sel.
 (2) The sel name is taken from the pathname without the directory
 and extension.
 </summary>
	<remarks>
	</remarks>
	<param name="pathname"></param>
	<returns>sel if OK; NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selCreateFromColorPix(LeptonicaSharp.Pix,System.String)">
	<summary>
 Notes
 (1) The sel size is given by the size of pixs.
 (2) In pixs, hits are represented by green pixels, misses by red
 pixels, and don't-cares by white pixels.
 (3) In pixs, there may be no misses, but there must be at least 1 hit.
 (4) At most there can be only one origin pixel, which is optionally
 specified by using a lower-intensity pixel
 if a hit  dark green
 if a miss dark red
 if a don't care gray
 If there is no such pixel, the origin defaults to the approximate
 center of the sel.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">cmapped or rgb</param>
	<param name="selname">sel name; can be null</param>
	<returns>sel if OK, NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selDisplayInPix(LeptonicaSharp.Sel,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This gives a visual representation of a general (hit-miss) sel.
 (2) The empty sel is represented by a grid of intersecting lines.
 (3) Three different patterns are generated for the sel elements
 ~ hit (solid black circle)
 ~ miss (black ring; inner radius is radius2)
 ~ origin (cross, XORed with whatever is there)
 </summary>
	<remarks>
	</remarks>
	<param name="sel"></param>
	<param name="size">of grid interiors; odd; minimum size of 13 is enforced</param>
	<param name="gthick">grid thickness; minimum size of 2 is enforced</param>
	<returns>pix display of sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaDisplayInPix(LeptonicaSharp.Sela,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This gives a visual representation of all the sels in a sela.
 (2) See notes in selDisplayInPix() for display params of each sel.
 (3) This gives the nicest results when all sels in the sela
 are the same size.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="size">of grid interiors; odd; minimum size of 13 is enforced</param>
	<param name="gthick">grid thickness; minimum size of 2 is enforced</param>
	<param name="spacing">between sels, both horizontally and vertically</param>
	<param name="ncols">number of sels per "line"</param>
	<returns>pix display of all sels in sela, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaAddBasic(LeptonicaSharp.Sela)">
	<summary>
 Notes
 (1) Adds the following sels
 ~ all linear (horiz, vert) brick sels that are
 necessary for decomposable sels up to size 63
 ~ square brick sels up to size 10
 ~ 4 diagonal sels
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaAddHitMiss(LeptonicaSharp.Sela)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaAddDwaLinear(LeptonicaSharp.Sela)">
	<summary>
 Notes
 (1) Adds all linear (horizontal, vertical) sels from
 2 to 63 pixels in length, which are the sizes over
 which dwa code can be generated.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaAddDwaCombs(LeptonicaSharp.Sela)">
	<summary>
 Notes
 (1) Adds all comb (horizontal, vertical) Sels that are
 used in composite linear morphological operations
 up to 63 pixels in length, which are the sizes over
 which dwa code can be generated.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaAddCrossJunctions(System.Single,System.Single,System.Int32,System.Int32,LeptonicaSharp.Sela)">
	<summary>
 Notes
 (1) Adds hitmiss Sels for the intersection of two lines.
 If the lines are very thin, they must be nearly orthogonal
 to register.
 (2) The number of Sels generated is equal to %norient.
 (3) If %norient == 2, this generates 2 Sels of crosses, each with
 two perpendicular lines of hits.  One Sel has horizontal and
 vertical hits; the other has hits along lines at +-45 degrees.
 Likewise, if %norient == 3, this generates 3 Sels of crosses
 oriented at 30 degrees with each other.
 (4) It is suggested that %hlsize be chosen at least 1 greater
 than %mdist.  Try values of (%hlsize, %mdist) such as
 (6,5), (7,6), (8,7), (9,7), etc.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="hlsize">length of each line of hits from origin</param>
	<param name="mdist">distance of misses from the origin</param>
	<param name="norient">number of orientations; max of 8</param>
	<param name="debugflag">1 for debug output</param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.selaAddTJunctions(System.Single,System.Single,System.Int32,System.Int32,LeptonicaSharp.Sela)">
	<summary>
 Notes
 (1) Adds hitmiss Sels for the T-junction of two lines.
 If the lines are very thin, they must be nearly orthogonal
 to register.
 (2) The number of Sels generated is 4  %norient.
 (3) It is suggested that %hlsize be chosen at least 1 greater
 than %mdist.  Try values of (%hlsize, %mdist) such as
 (6,5), (7,6), (8,7), (9,7), etc.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<param name="hlsize">length of each line of hits from origin</param>
	<param name="mdist">distance of misses from the origin</param>
	<param name="norient">number of orientations; max of 8</param>
	<param name="debugflag">1 for debug output</param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sela4ccThin(LeptonicaSharp.Sela)">
	<summary>
 Notes
 (1) Adds the 9 basic sels for 4-cc thinning.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sela8ccThin(LeptonicaSharp.Sela)">
	<summary>
 Notes
 (1) Adds the 9 basic sels for 8-cc thinning.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sela4and8ccThin(LeptonicaSharp.Sela)">
	<summary>
 Notes
 (1) Adds the 2 basic sels for either 4-cc or 8-cc thinning.
 </summary>
	<remarks>
	</remarks>
	<param name="sela"></param>
	<returns>sela with additional sels, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenerateSelWithRuns(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) The horizontal and vertical lines along which elements are
 selected are roughly equally spaced.  The actual locations of
 the hits and misses are the centers of respective run-lengths.
 (2) No elements are selected that are less than 'distance' pixels away
 from a boundary pixel of the same color.  This makes the
 match much more robust to edge noise.  Valid inputs of
 'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or
 greater than 4, we reset it to the default value.
 (3) The 4 numbers for adding rectangles of pixels outside the fg
 can be use if the pattern is expected to be surrounded by bg
 (white) pixels.  On the other hand, if the pattern may be near
 other fg (black) components on some sides, use 0 for those sides.
 (4) The pixels added to a side allow you to have miss elements there.
 There is a constraint between distance, minlength, and
 the added pixels for this to work.  We illustrate using the
 default values.  If you add 5 pixels to the top, and use a
 distance of 1, then you end up with a vertical run of at least
 4 bg pixels along the top edge of the image.  If you use a
 minimum runlength of 3, each vertical line will always find
 a miss near the center of its run.  However, if you use a
 minimum runlength of 5, you will not get a miss on every vertical
 line.  As another example, if you have 7 added pixels and a
 distance of 2, you can use a runlength up to 5 to guarantee
 that the miss element is recorded.  We give a warning if the
 constraint does not guarantee a miss element outside the
 image proper.
 (5) The input pix, as extended by the extra pixels on selected sides,
 can optionally be returned.  For debugging, call
 pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
 on the generating bitmap.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, typically small, to be used as a pattern</param>
	<param name="nhlines">number of hor lines along which elements are found</param>
	<param name="nvlines">number of vert lines along which elements are found</param>
	<param name="distance">min distance from boundary pixel; use 0 for default</param>
	<param name="minlength">min runlength to set hit or miss; use 0 for default</param>
	<param name="toppix">number of extra pixels of bg added above</param>
	<param name="botpix">number of extra pixels of bg added below</param>
	<param name="leftpix">number of extra pixels of bg added to left</param>
	<param name="rightpix">number of extra pixels of bg added to right</param>
	<param name="ppixe">input pix expanded by extra pixels</param>
	<returns>sel hit-miss for input pattern, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenerateSelRandom(LeptonicaSharp.Pix,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) Either of hitfract and missfract can be zero.  If both are zero,
 the sel would be empty, and NULL is returned.
 (2) No elements are selected that are less than 'distance' pixels away
 from a boundary pixel of the same color.  This makes the
 match much more robust to edge noise.  Valid inputs of
 'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or
 greater than 4, we reset it to the default value.
 (3) The 4 numbers for adding rectangles of pixels outside the fg
 can be use if the pattern is expected to be surrounded by bg
 (white) pixels.  On the other hand, if the pattern may be near
 other fg (black) components on some sides, use 0 for those sides.
 (4) The input pix, as extended by the extra pixels on selected sides,
 can optionally be returned.  For debugging, call
 pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
 on the generating bitmap.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, typically small, to be used as a pattern</param>
	<param name="hitfract">fraction of allowable fg pixels that are hits</param>
	<param name="missfract">fraction of allowable bg pixels that are misses</param>
	<param name="distance">min distance from boundary pixel; use 0 for default</param>
	<param name="toppix">number of extra pixels of bg added above</param>
	<param name="botpix">number of extra pixels of bg added below</param>
	<param name="leftpix">number of extra pixels of bg added to left</param>
	<param name="rightpix">number of extra pixels of bg added to right</param>
	<param name="ppixe">input pix expanded by extra pixels</param>
	<returns>sel hit-miss for input pattern, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGenerateSelBoundary(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,LeptonicaSharp.Pix@)">
	<summary>
 Notes
 (1) All fg elements selected are exactly hitdist pixels away from
 the nearest fg boundary pixel, and ditto for bg elements.
 Valid inputs of hitdist and missdist are 0, 1, 2, 3 and 4.
 For example, a hitdist of 0 puts the hits at the fg boundary.
 Usually, the distances should be GT 0 avoid the effect of
 noise at the boundary.
 (2) Set hitskip LT 0 if no hits are to be used.  Ditto for missskip.
 If both hitskip and missskip are LT 0, the sel would be empty,
 and NULL is returned.
 (3) The 4 flags determine whether the sel is increased on that side
 to allow bg misses to be placed all along that boundary.
 The increase in sel size on that side is the minimum necessary
 to allow the misses to be placed at mindist.  For text characters,
 the topflag and botflag are typically set to 1, and the leftflag
 and rightflag to 0.
 (4) The input pix, as extended by the extra pixels on selected sides,
 can optionally be returned.  For debugging, call
 pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
 on the generating bitmap.
 (5) This is probably the best of the three sel generators, in the
 sense that you have the most flexibility with the smallest number
 of hits and misses.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, typically small, to be used as a pattern</param>
	<param name="hitdist">min distance from fg boundary pixel</param>
	<param name="missdist">min distance from bg boundary pixel</param>
	<param name="hitskip">number of boundary pixels skipped between hits</param>
	<param name="missskip">number of boundary pixels skipped between misses</param>
	<param name="topflag">flag for extra pixels of bg added above</param>
	<param name="botflag">flag for extra pixels of bg added below</param>
	<param name="leftflag">flag for extra pixels of bg added to left</param>
	<param name="rightflag">flag for extra pixels of bg added to right</param>
	<param name="ppixe">input pix expanded by extra pixels</param>
	<returns>sel hit-miss for input pattern, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRunCentersOnLine(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Action this function computes the fg (black) and bg (white)
 pixel runlengths along the specified horizontal or vertical line,
 and returns a Numa of the "center" pixels of each fg run
 whose length equals or exceeds the minimum length.
 (2) This only works on horizontal and vertical lines.
 (3) For horizontal runs, set x = -1 and y to the value
 for all points along the raster line.  For vertical runs,
 set y = -1 and x to the value for all points along the
 pixel column.
 (4) For horizontal runs, the points in the Numa are the x
 values in the center of fg runs that are of length at
 least 'minlength'.  For vertical runs, the points in the
 Numa are the y values in the center of fg runs, again
 of length 'minlength' or greater.
 (5) If there are no fg runs along the line that satisfy the
 minlength constraint, the returned Numa is empty.  This
 is not an error.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="x">set one of these to -1; see notes</param>
	<param name="y">set one of these to -1; see notes</param>
	<param name="minlength">minimum length of acceptable run</param>
	<returns>numa of fg runs, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetRunsOnLine(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Action this function uses the bresenham algorithm to compute
 the pixels along the specified line.  It returns a Numa of the
 runlengths of the fg (black) and bg (white) runs, always
 starting with a white run.
 (2) If the first pixel on the line is black, the length of the
 first returned run (which is white) is 0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="x1"></param>
	<param name="y1"></param>
	<param name="x2"></param>
	<param name="y2"></param>
	<returns>numa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSubsampleBoundaryPixels(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) If skip = 0, we take all the fg pixels.
 (2) We try to traverse the boundaries in a regular way.
 Some pixels may be missed, and these are then subsampled
 randomly with a fraction determined by 'skip'.
 (3) The most natural approach is to use a depth first (stack-based)
 method to find the fg pixels.  However, the pixel runs are
 4-connected and there are relatively few branches.  So
 instead of doing a proper depth-first search, we get nearly
 the same result using two nested while loops the outer
 one continues a raster-based search for the next fg pixel,
 and the inner one does a reasonable job running along
 each 4-connected coutour.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp, with only boundary pixels in fg</param>
	<param name="skip">number to skip between samples as you traverse boundary</param>
	<returns>pta, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.adjacentOnPixelInRaster(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) Search is in 4-connected directions first; then on diagonals.
 This allows traversal along a 4-connected boundary.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="x">current pixel</param>
	<param name="y">current pixel</param>
	<param name="pxa">adjacent ON pixel, found by simple CCW search</param>
	<param name="pya">adjacent ON pixel, found by simple CCW search</param>
	<returns>1 if a pixel is found; 0 otherwise or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDisplayHitMissSel(LeptonicaSharp.Pix,LeptonicaSharp.Sel,System.Int32,System.UInt32,System.UInt32)">
	<summary>
 Notes
 (1) We don't allow scalefactor to be larger than MAX_SEL_SCALEFACTOR
 (2) The colors are conveniently given as 4 bytes in hex format,
 such as 0xff008800.  The least significant byte is ignored.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="sel">hit-miss in general</param>
	<param name="scalefactor">an integer GT= 1; use 0 for default</param>
	<param name="hitcolor">RGB0 color for center of hit pixels</param>
	<param name="misscolor">RGB0 color for center of miss pixels</param>
	<returns>pixd RGB showing both pixs and sel, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixHShear(LeptonicaSharp.Pix,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) There are 3 cases
 (a) pixd == null (make a new pixd)
 (b) pixd == pixs (in-place)
 (c) pixd != pixs
 (2) For these three cases, use these patterns, respectively
 pixd = pixHShear(NULL, pixs, ...);
 pixHShear(pixs, pixs, ...);
 pixHShear(pixd, pixs, ...);
 (3) This shear leaves the horizontal line of pixels at y = yloc
 invariant.  For a positive shear angle, pixels above this
 line are shoved to the right, and pixels below this line
 move to the left.
 (4) With positive shear angle, this can be used, along with
 pixVShear(), to perform a cw rotation, either with 2 shears
 (for small angles) or in the general case with 3 shears.
 (5) Changing the value of yloc is equivalent to translating
 the result horizontally.
 (6) This brings in 'incolor' pixels from outside the image.
 (7) For in-place operation, pixs cannot be colormapped,
 because the in-place operation only blits in 0 or 1 bits,
 not an arbitrary colormap index.
 (8) The angle is brought into the range [-pi, -pi].  It is
 not permitted to be within MIN_DIFF_FROM_HALF_PI radians
 from either -pi/2 or pi/2.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">, this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">no restrictions on depth</param>
	<param name="yloc">location of horizontal line, measured from origin</param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, always</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixVShear(LeptonicaSharp.Pix,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) There are 3 cases
 (a) pixd == null (make a new pixd)
 (b) pixd == pixs (in-place)
 (c) pixd != pixs
 (2) For these three cases, use these patterns, respectively
 pixd = pixVShear(NULL, pixs, ...);
 pixVShear(pixs, pixs, ...);
 pixVShear(pixd, pixs, ...);
 (3) This shear leaves the vertical line of pixels at x = xloc
 invariant.  For a positive shear angle, pixels to the right
 of this line are shoved downward, and pixels to the left
 of the line move upward.
 (4) With positive shear angle, this can be used, along with
 pixHShear(), to perform a cw rotation, either with 2 shears
 (for small angles) or in the general case with 3 shears.
 (5) Changing the value of xloc is equivalent to translating
 the result vertically.
 (6) This brings in 'incolor' pixels from outside the image.
 (7) For in-place operation, pixs cannot be colormapped,
 because the in-place operation only blits in 0 or 1 bits,
 not an arbitrary colormap index.
 (8) The angle is brought into the range [-pi, -pi].  It is
 not permitted to be within MIN_DIFF_FROM_HALF_PI radians
 from either -pi/2 or pi/2.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">, this can be null, equal to pixs, or different from pixs</param>
	<param name="pixs">no restrictions on depth</param>
	<param name="xloc">location of vertical line, measured from origin</param>
	<param name="radang">angle in radians; not too close to +-(pi / 2)</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixHShearCorner(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See pixHShear() for usage.
 (2) This does a horizontal shear about the UL corner, with (+) shear
 pushing increasingly leftward (-x) with increasing y.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">, if not null, must be equal to pixs</param>
	<param name="pixs"></param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixVShearCorner(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See pixVShear() for usage.
 (2) This does a vertical shear about the UL corner, with (+) shear
 pushing increasingly downward (+y) with increasing x.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">, if not null, must be equal to pixs</param>
	<param name="pixs"></param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixHShearCenter(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See pixHShear() for usage.
 (2) This does a horizontal shear about the center, with (+) shear
 pushing increasingly leftward (-x) with increasing y.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">, if not null, must be equal to pixs</param>
	<param name="pixs"></param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixVShearCenter(LeptonicaSharp.Pix,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN,LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) See pixVShear() for usage.
 (2) This does a vertical shear about the center, with (+) shear
 pushing increasingly downward (+y) with increasing x.
 </summary>
	<remarks>
	</remarks>
	<param name="pixd">, if not null, must be equal to pixs</param>
	<param name="pixs"></param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixHShearIP(LeptonicaSharp.Pix,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) This is an in-place version of pixHShear(); see comments there.
 (2) This brings in 'incolor' pixels from outside the image.
 (3) pixs cannot be colormapped, because the in-place operation
 only blits in 0 or 1 bits, not an arbitrary colormap index.
 (4) Does a horizontal full-band shear about the line with (+) shear
 pushing increasingly leftward (-x) with increasing y.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="yloc">location of horizontal line, measured from origin</param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixVShearIP(LeptonicaSharp.Pix,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) This is an in-place version of pixVShear(); see comments there.
 (2) This brings in 'incolor' pixels from outside the image.
 (3) pixs cannot be colormapped, because the in-place operation
 only blits in 0 or 1 bits, not an arbitrary colormap index.
 (4) Does a vertical full-band shear about the line with (+) shear
 pushing increasingly downward (+y) with increasing x.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths; not colormapped</param>
	<param name="xloc">location of vertical line, measured from origin</param>
	<param name="radang">angle in radians</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixHShearLI(LeptonicaSharp.Pix,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) This does horizontal shear with linear interpolation for
 accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.
 It is relatively slow compared to the sampled version
 implemented by rasterop, but the result is much smoother.
 (2) This shear leaves the horizontal line of pixels at y = yloc
 invariant.  For a positive shear angle, pixels above this
 line are shoved to the right, and pixels below this line
 move to the left.
 (3) Any colormap is removed.
 (4) The angle is brought into the range [-pi/2 + del, pi/2 - del],
 where del == MIN_DIFF_FROM_HALF_PI.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp or 32 bpp, or colormapped</param>
	<param name="yloc">location of horizontal line, measured from origin</param>
	<param name="radang">angle in radians, in range (-pi/2 ... pi/2)</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd sheared, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixVShearLI(LeptonicaSharp.Pix,System.Int32,System.Single,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) This does vertical shear with linear interpolation for
 accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.
 It is relatively slow compared to the sampled version
 implemented by rasterop, but the result is much smoother.
 (2) This shear leaves the vertical line of pixels at x = xloc
 invariant.  For a positive shear angle, pixels to the right
 of this line are shoved downward, and pixels to the left
 of the line move upward.
 (3) Any colormap is removed.
 (4) The angle is brought into the range [-pi/2 + del, pi/2 - del],
 where del == MIN_DIFF_FROM_HALF_PI.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp or 32 bpp, or colormapped</param>
	<param name="xloc">location of vertical line, measured from origin</param>
	<param name="radang">angle in radians, in range (-pi/2 ... pi/2)</param>
	<param name="incolor">L_BRING_IN_WHITE, L_BRING_IN_BLACK;</param>
	<returns>pixd sheared, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDeskewBoth(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This binarizes if necessary and does both horizontal
 and vertical deskewing, using the default parameters in
 the underlying pixDeskew().  See usage there.
 (2) This may return a clone.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="redsearch">for binary search reduction factor = 1, 2 or 4; use 0 for default</param>
	<returns>pixd deskewed pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDeskew(LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) This binarizes if necessary and finds the skew angle.  If the
 angle is large enough and there is sufficient confidence,
 it returns a deskewed image; otherwise, it returns a clone.
 (2) Typical values at 300 ppi for %redsearch are 2 and 4.
 At 75 ppi, one should use %redsearch = 1.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="redsearch">for binary search reduction factor = 1, 2 or 4; use 0 for default</param>
	<returns>pixd deskewed pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindSkewAndDeskew(LeptonicaSharp.Pix,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This binarizes if necessary and finds the skew angle.  If the
 angle is large enough and there is sufficient confidence,
 it returns a deskewed image; otherwise, it returns a clone.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="redsearch">for binary search reduction factor = 1, 2 or 4; use 0 for default</param>
	<param name="pangle">angle required to deskew, in degrees; use NULL to skip</param>
	<param name="pconf">conf value is ratio of max/min scores; use NULL to skip</param>
	<returns>pixd deskewed pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDeskewGeneral(LeptonicaSharp.Pix,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This binarizes if necessary and finds the skew angle.  If the
 angle is large enough and there is sufficient confidence,
 it returns a deskewed image; otherwise, it returns a clone.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth</param>
	<param name="redsweep">for linear search reduction factor = 1, 2 or 4; use 0 for default</param>
	<param name="sweeprange">in degrees in each direction from 0; use 0.0 for default</param>
	<param name="sweepdelta">in degrees; use 0.0 for default</param>
	<param name="redsearch">for binary search reduction factor = 1, 2 or 4; use 0 for default;</param>
	<param name="thresh">for binarizing the image; use 0 for default</param>
	<param name="pangle">angle required to deskew, in degrees; use NULL to skip</param>
	<param name="pconf">conf value is ratio of max/min scores; use NULL to skip</param>
	<returns>pixd deskewed pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindSkew(LeptonicaSharp.Pix,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) This is a simple high-level interface, that uses default
 values of the parameters for reasonable speed and accuracy.
 (2) The angle returned is the negative of the skew angle of
 the image.  It is the angle required for deskew.
 Clockwise rotations are positive angles.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pangle">angle required to deskew, in degrees</param>
	<param name="pconf">confidence value is ratio max/min scores</param>
	<returns>0 if OK, 1 on error or if angle measurement not valid</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindSkewSweep(LeptonicaSharp.Pix,System.Single[]@,System.Int32,System.Single,System.Single)">
	<summary>
 Notes
 (1) This examines the 'score' for skew angles with equal intervals.
 (2) Caller must check the return value for validity of the result.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pangle">angle required to deskew, in degrees</param>
	<param name="reduction">factor = 1, 2, 4 or 8</param>
	<param name="sweeprange">half the full range; assumed about 0; in degrees</param>
	<param name="sweepdelta">angle increment of sweep; in degrees</param>
	<returns>0 if OK, 1 on error or if angle measurement not valid</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindSkewSweepAndSearch(LeptonicaSharp.Pix,System.Single[]@,System.Single[]@,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This finds the skew angle, doing first a sweep through a set
 of equal angles, and then doing a binary search until
 convergence.
 (2) Caller must check the return value for validity of the result.
 (3) In computing the differential line sum variance score, we sum
 the result over scanlines, but we always skip
 ~ at least one scanline
 ~ not more than 10% of the image height
 ~ not more than 5% of the image width
 (4) See also notes in pixFindSkewSweepAndSearchScore()
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pangle">angle required to deskew; in degrees</param>
	<param name="pconf">confidence given by ratio of max/min score</param>
	<param name="redsweep">sweep reduction factor = 1, 2, 4 or 8</param>
	<param name="redsearch">binary search reduction factor = 1, 2, 4 or 8; and must not exceed redsweep</param>
	<param name="sweeprange">half the full range, assumed about 0; in degrees</param>
	<param name="sweepdelta">angle increment of sweep; in degrees</param>
	<param name="minbsdelta">min binary search increment angle; in degrees</param>
	<returns>0 if OK, 1 on error or if angle measurement not valid</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindSkewSweepAndSearchScore(LeptonicaSharp.Pix,System.Single[]@,System.Single[]@,System.Single,System.Single,System.Single,System.Single,System.Single[]@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This finds the skew angle, doing first a sweep through a set
 of equal angles, and then doing a binary search until convergence.
 (2) There are two built-in constants that determine if the
 returned confidence is nonzero
 ~ MIN_VALID_MAXSCORE (minimum allowed maxscore)
 ~ MINSCORE_THRESHOLD_CONSTANT (determines minimum allowed
 minscore, by multiplying by (height  width^2)
 If either of these conditions is not satisfied, the returned
 confidence value will be zero.  The maxscore is optionally
 returned in this function to allow evaluation of the
 resulting angle by a method that is independent of the
 returned confidence value.
 (3) The larger the confidence value, the greater the probability
 that the proper alignment is given by the angle that maximizes
 variance.  It should be compared to a threshold, which depends
 on the application.  Values between 3.0 and 6.0 are common.
 (4) By default, the shear is about the UL corner.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pangle">angle required to deskew; in degrees</param>
	<param name="pconf">confidence given by ratio of max/min score</param>
	<param name="pendscore">max score; use NULL to ignore</param>
	<param name="redsweep">sweep reduction factor = 1, 2, 4 or 8</param>
	<param name="redsearch">binary search reduction factor = 1, 2, 4 or 8; and must not exceed redsweep</param>
	<param name="sweepcenter">angle about which sweep is performed; in degrees</param>
	<param name="sweeprange">half the full range, taken about sweepcenter; in degrees</param>
	<param name="sweepdelta">angle increment of sweep; in degrees</param>
	<param name="minbsdelta">min binary search increment angle; in degrees</param>
	<returns>0 if OK, 1 on error or if angle measurement not valid</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindSkewSweepAndSearchScorePivot(LeptonicaSharp.Pix,System.Single[]@,System.Single[]@,System.Single,System.Single,System.Single,System.Single,LeptonicaSharp.Enumerations.L_SHEAR_ABOUT_CER,System.Single[]@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See notes in pixFindSkewSweepAndSearchScore().
 (2) This allows choice of shear pivoting from either the UL corner
 or the center.  For small angles, the ability to discriminate
 angles is better with shearing from the UL corner.  However,
 for large angles (say, greater than 20 degrees), it is better
 to shear about the center because a shear from the UL corner
 loses too much of the image.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="pangle">angle required to deskew; in degrees</param>
	<param name="pconf">confidence given by ratio of max/min score</param>
	<param name="pendscore">max score; use NULL to ignore</param>
	<param name="redsweep">sweep reduction factor = 1, 2, 4 or 8</param>
	<param name="redsearch">binary search reduction factor = 1, 2, 4 or 8; and must not exceed redsweep</param>
	<param name="sweepcenter">angle about which sweep is performed; in degrees</param>
	<param name="sweeprange">half the full range, taken about sweepcenter; in degrees</param>
	<param name="sweepdelta">angle increment of sweep; in degrees</param>
	<param name="minbsdelta">min binary search increment angle; in degrees</param>
	<param name="pivot">L_SHEAR_ABOUT_CORNER, L_SHEAR_ABOUT_CENTER</param>
	<returns>0 if OK, 1 on error or if angle measurement not valid</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindSkewOrthogonalRange(LeptonicaSharp.Pix@,System.Single[]@,System.Single[]@,System.Single@,System.Single@,System.Single@,System.Single@,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindDifferentialSquareSum(LeptonicaSharp.Pix,System.Single[]@)">
	<summary>
 Notes
 (1) At the top and bottom, we skip
 ~ at least one scanline
 ~ not more than 10% of the image height
 ~ not more than 5% of the image width
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="psum">result</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindNormalizedSquareSum(LeptonicaSharp.Pix,System.Single[]@,System.Single[]@,System.Single[]@)">
	<summary>
 Notes
 (1) Let the image have h scanlines and N fg pixels.
 If the pixels were uniformly distributed on scanlines,
 the sum of squares of fg pixels on each scanline would be
 h  (N / h)^2.  However, if the pixels are not uniformly
 distributed (e.g., for text), the sum of squares of fg
 pixels will be larger.  We return in hratio and vratio the
 ratio of these two values.
 (2) If there are no fg pixels, hratio and vratio are returned as 0.0.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs"></param>
	<param name="phratio">ratio of normalized horiz square sum to result if the pixel distribution were uniform</param>
	<param name="pvratio">ratio of normalized vert square sum to result if the pixel distribution were uniform</param>
	<param name="pfract">ratio of fg pixels to total pixels</param>
	<returns>0 if OK, 1 on error or if there are no fg pixels</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadStreamSpix(LeptonicaSharp.FILE)">
	<summary>
 Notes
 (1) If called from pixReadStream(), the stream is positioned
 at the beginning of the file.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>pix, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readHeaderSpix(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If there is a colormap, iscmap is returned as 1; else 0.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pwidth">width</param>
	<param name="pheight">height</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<param name="piscmap">input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.freadHeaderSpix(LeptonicaSharp.FILE,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If there is a colormap, iscmap is returned as 1; else 0.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pwidth">width</param>
	<param name="pheight">height</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<param name="piscmap">input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sreadHeaderSpix(System.Byte[],System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If there is a colormap, iscmap is returned as 1; else 0.
 </summary>
	<remarks>
	</remarks>
	<param name="data"></param>
	<param name="pwidth">width</param>
	<param name="pheight">height</param>
	<param name="pbps">bits/sample</param>
	<param name="pspp">samples/pixel</param>
	<param name="piscmap">input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamSpix(LeptonicaSharp.FILE,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadMemSpix(System.Byte[],System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="data">const; uncompressed</param>
	<param name="size">bytes of data</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMemSpix(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdata">data of serialized, uncompressed pix</param>
	<param name="psize">size of returned data</param>
	<param name="pix">all depths; colormap OK</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSerializeToMemory(LeptonicaSharp.Pix,System.Byte[]@,System.UInt32@)">
	<summary>
 Notes
 (1) This does a fast serialization of the principal elements
 of the pix, as follows
 "spix" (4 bytes) -- ID for file type
 w   (4 bytes)
 h   (4 bytes)
 d   (4 bytes)
 wpl (4 bytes)
 ncolors   (4 bytes) -- in colormap; 0 if there is no colormap
 cdata  (4  ncolors)  -- size of serialized colormap array
 rdatasize (4 bytes) -- size of serialized raster data
 = 4  wpl  h
 rdata  (rdatasize)
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">all depths, colormap OK</param>
	<param name="pdata">serialized data in memory</param>
	<param name="pnbytes">number of bytes in data string</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDeserializeFromMemory(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) See pixSerializeToMemory() for the binary format.
 (2) Note the image size limits.
 </summary>
	<remarks>
	</remarks>
	<param name="data">serialized data in memory</param>
	<param name="nbytes">number of bytes in data string</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lstackCreate(System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="nalloc">initial ptr array size; use 0 for default</param>
	<returns>lstack, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lstackDestroy(LeptonicaSharp.L_Stack@,System.Int32)">
	<summary>
 Notes
 (1) If freeflag is TRUE, frees each struct in the array.
 (2) If freeflag is FALSE but there are elements on the array,
 gives a warning and destroys the array.  This will
 cause a memory leak of all the items that were on the lstack.
 So if the items require their own destroy function, they
 must be destroyed before the lstack.
 (3) To destroy the lstack, we destroy the ptr array, then
 the lstack, and then null the contents of the input ptr.
 </summary>
	<remarks>
	</remarks>
	<param name="plstack">to be nulled</param>
	<param name="freeflag">TRUE to free each remaining struct in the array</param>
</member><member name="M:LeptonicaSharp._AllFunctions.lstackAdd(LeptonicaSharp.L_Stack,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lstack"></param>
	<param name="item">to be added to the lstack</param>
	<returns>0 if OK; 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lstackRemove(LeptonicaSharp.L_Stack)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lstack"></param>
	<returns>ptr to item popped from the top of the lstack, or NULL if the lstack is empty or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lstackGetCount(LeptonicaSharp.L_Stack)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="lstack"></param>
	<returns>count, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lstackPrint(LeptonicaSharp.FILE,LeptonicaSharp.L_Stack)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="lstack"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.strcodeCreate(System.Int32)">
	<summary>
 Notes
 (1) This struct exists to build two files containing code for
 any number of data objects.  The two files are named
 autogen.[fileno].c
 autogen.[fileno].h
 </summary>
	<remarks>
	</remarks>
	<param name="fileno">integer that labels the two output files</param>
	<returns>initialized L_StrCode, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.strcodeCreateFromFile(System.String,System.Int32,System.String)">
	<summary>
 Notes
 (1) The %filein has one filename on each line.
 Comment lines begin with "#".
 (2) The output is 2 files
 autogen.[fileno].c
 autogen.[fileno].h
 </summary>
	<remarks>
	</remarks>
	<param name="filein">containing filenames of serialized data</param>
	<param name="fileno">integer that labels the two output files</param>
	<param name="outdir">if null, files are made in /tmp/lept/auto</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.strcodeGenerate(LeptonicaSharp.L_StrCode,System.String,System.String)">
	<summary>
 Notes
 (1) The generated function name is
 l_autodecode_[fileno]()
 where [fileno] is the index label for the pair of output files.
 (2) To deserialize this data, the function is called with the
 argument 'ifunc', which increments each time strcodeGenerate()
 is called.
 </summary>
	<remarks>
	</remarks>
	<param name="strcode">for accumulating data</param>
	<param name="filein">input file with serialized data</param>
	<param name="type">of data; use the typedef string</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.strcodeFinalize(LeptonicaSharp.L_StrCode@,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pstrcode">destroys after .c and .h files have been generated</param>
	<param name="outdir">if NULL, files are made in /tmp/lept/auto</param>
	<returns>void</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_getStructStrFromFile(System.String,LeptonicaSharp.Enumerations.L_STR,System.String[]@)">
	<summary>
 Notes
 (1) For example, if %field == L_STR_NAME, and the file is a serialized
 pixa, this will return "Pixa", the name of the struct.
 (2) Caller must free the returned string.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="field">(L_STR_TYPE, L_STR_NAME, L_STR_READER, L_STR_MEMREADER)</param>
	<param name="pstr">struct string for this file</param>
	<returns>0 if found, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindStrokeLength(LeptonicaSharp.Pix,System.Int32@,System.Int32[])">
	<summary>
 Notes
 (1) Returns half the number of fg boundary pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="tab8">table for counting fg pixels; can be NULL</param>
	<param name="plength">estimated length of the strokes</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixFindStrokeWidth(LeptonicaSharp.Pix,System.Single,System.Single[]@,System.Int32[],LeptonicaSharp.Numa@)">
	<summary>
 Notes
 (1) This uses two methods to estimate the stroke width
 (a) half the fg boundary length
 (b) a value derived from the histogram of the fg distance transform
 (2) Distance is measured in 8-connected
 (3) %thresh is the minimum fraction N(dist=d)/N(dist=1) of pixels
 required to determine if the pixels at distance d are above
 the noise. It is typically about 0.15.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp</param>
	<param name="thresh">fractional count threshold relative to distance 1</param>
	<param name="tab8">table for counting fg pixels; can be NULL</param>
	<param name="pwidth">estimated width of the strokes</param>
	<param name="pnahisto">histo of pixel distances from bg</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaFindStrokeWidth(LeptonicaSharp.Pixa,System.Single,System.Int32[],LeptonicaSharp.Enumerations.DebugOnOff)">
	<summary>
 Notes
 (1) See pixFindStrokeWidth() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa">of 1 bpp images</param>
	<param name="thresh">fractional count threshold relative to distance 1</param>
	<param name="tab8">table for counting fg pixels; can be NULL</param>
	<param name="debug">1 for debug output; 0 to skip</param>
	<returns>na  array of stroke widths for each pix in %pixa; NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaModifyStrokeWidth(LeptonicaSharp.Pixa,System.Single@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixas">of 1 bpp pix</param>
	<param name="targetw">desired width for strokes in each pix</param>
	<returns>pixa  with modified stroke widths, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixModifyStrokeWidth(LeptonicaSharp.Pix,System.Single,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">of 1 bpp pix</param>
	<param name="width">measured average stroke width</param>
	<param name="targetw">desired stroke width</param>
	<returns>pix  with modified stroke width, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaSetStrokeWidth(LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) If %thinfirst == 1, thin to a skeleton using the specified
 %connectivity.  Use %thinfirst == 0 if all pix in pixas
 have already been thinned as far as possible.
 (2) The image is dilated to the required %width.  This dilation
 is not connectivity preserving, so this is typically
 used in a situation where merging of c.c. in the individual
 pix is not a problem; e.g., where each pix is a single c.c.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">of 1 bpp pix</param>
	<param name="width">set stroke width to this value, in [1 ... 100].</param>
	<param name="thinfirst">1 to thin all pix to a skeleton first; 0 to skip</param>
	<param name="connectivity">4 or 8, to be used if %thinfirst == 1</param>
	<returns>pixa  with all stroke widths being %width, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetStrokeWidth(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) See notes in pixaSetStrokeWidth().
 (2) A white border of sufficient width to avoid boundary
 artifacts in the thickening step is added before thinning.
 (3) %connectivity == 8 usually gives a slightly smoother result.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1 bpp pix</param>
	<param name="width">set stroke width to this value, in [1 ... 100].</param>
	<param name="thinfirst">1 to thin all pix to a skeleton first; 0 to skip</param>
	<param name="connectivity">4 or 8, to be used if %thinfirst == 1</param>
	<returns>pixd  with stroke width set to %width, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sudokuReadFile(System.String)">
	<summary>
 Notes
 (1) The file format has
 any number of comment lines beginning with '#'
 a set of 9 lines, each having 9 digits (0-9) separated
 by a space
 </summary>
	<remarks>
	</remarks>
	<param name="filename">of formatted sudoku file</param>
	<returns>array of 81 numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sudokuReadString(System.String)">
	<summary>
 Notes
 (1) The string is formatted as 81 single digits, each separated
 by 81 spaces.
 </summary>
	<remarks>
	</remarks>
	<param name="str">of input data</param>
	<returns>array of 81 numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sudokuCreate(System.Int32[])">
	<summary>
 Notes
 (1) The input array has 0 for the unknown values, and 1-9
 for the known initial values.  It is generated from
 a file using sudokuReadInput(), which checks that the file
 data has 81 numbers in 9 rows.
 </summary>
	<remarks>
	</remarks>
	<param name="array">of 81 numbers, 9 rows of 9 numbers each</param>
	<returns>l_sudoku, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sudokuDestroy(LeptonicaSharp.L_Sudoku@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="psud">to be nulled</param>
</member><member name="M:LeptonicaSharp._AllFunctions.sudokuSolve(LeptonicaSharp.L_Sudoku)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="sud">l_sudoku starting in initial state</param>
	<returns>1 on success, 0 on failure to solve note reversal of typical unix returns</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sudokuTestUniqueness(System.Int32[],System.Int32@)">
	<summary>
 Notes
 (1) This applies the brute force method to all four 90 degree
 rotations.  If there is more than one solution, it is highly
 unlikely that all four results will be the same;
 consequently, if they are the same, the solution is
 most likely to be unique.
 </summary>
	<remarks>
	</remarks>
	<param name="array">of 81 numbers, 9 lines of 9 numbers each</param>
	<param name="punique">1 if unique, 0 if not</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sudokuGenerate(System.Int32[],System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is a brute force generator.  It starts with a completed
 sudoku solution and, by removing elements (setting them to 0),
 generates a valid (unique) sudoku initial condition.
 (2) The process stops when either %minelems, the minimum
 number of non-zero elements, is reached, or when the
 number of attempts to remove the next element exceeds %maxtries.
 (3) No sudoku is known with less than 17 nonzero elements.
 </summary>
	<remarks>
	</remarks>
	<param name="array">of 81 numbers, 9 rows of 9 numbers each</param>
	<param name="seed">random number</param>
	<param name="minelems">min non-zero elements allowed; LT= 80</param>
	<param name="maxtries">max tries to remove a number and get a valid sudoku</param>
	<returns>l_sudoku, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.sudokuOutput(LeptonicaSharp.L_Sudoku,LeptonicaSharp.Enumerations.L_SUDOKU)">
	<summary>
 Notes
 (1) Prints either the initial array or the current state
 of the solution.
 </summary>
	<remarks>
	</remarks>
	<param name="sud">l_sudoku at any stage</param>
	<param name="arraytype">L_SUDOKU_INIT, L_SUDOKU_STATE</param>
	<returns>void</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddSingleTextblock(LeptonicaSharp.Pix,LeptonicaSharp.L_Bmf,System.UInt32,LeptonicaSharp.Enumerations.L_ADD,System.String,System.Int32@)">
	<summary>
 Notes
 (1) This function paints a set of lines of text over an image.
 If %location is L_ADD_ABOVE or L_ADD_BELOW, the pix size
 is expanded with a border and rendered over the border.
 (2) %val is the pixel value to be painted through the font mask.
 It should be chosen to agree with the depth of pixs.
 If it is out of bounds, an intermediate value is chosen.
 For RGB, use hex notation 0xRRGGBB00, where RR is the
 hex representation of the red intensity, etc.
 (3) If textstr == NULL, use the text field in the pix.
 (4) If there is a colormap, this does the best it can to use
 the requested color, or something similar to it.
 (5) Typical usage is for labelling a pix with some text data.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input pix; colormap ok</param>
	<param name="bmf">bitmap font data</param>
	<param name="textstr">text string to be added</param>
	<param name="val">color to set the text</param>
	<param name="location">L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW</param>
	<param name="poverflow">1 if text overflows allocated region and is clipped; 0 otherwise</param>
	<returns>pixd new pix with rendered text, or either a copy or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixAddTextlines(LeptonicaSharp.Pix,LeptonicaSharp.L_Bmf,System.UInt32,LeptonicaSharp.Enumerations.L_ADD,System.String)">
	<summary>
 Notes
 (1) This function expands an image as required to paint one or
 more lines of text adjacent to the image.  If %bmf == NULL,
 this returns a copy.  If above or below, the lines are
 centered with respect to the image; if left or right, they
 are left justified.
 (2) %val is the pixel value to be painted through the font mask.
 It should be chosen to agree with the depth of pixs.
 If it is out of bounds, an intermediate value is chosen.
 For RGB, use hex notation 0xRRGGBB00, where RR is the
 hex representation of the red intensity, etc.
 (3) If textstr == NULL, use the text field in the pix.  The
 text field contains one or most "lines" of text, where newlines
 are used as line separators.
 (4) If there is a colormap, this does the best it can to use
 the requested color, or something similar to it.
 (5) Typical usage is for labelling a pix with some text data.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input pix; colormap ok</param>
	<param name="bmf">bitmap font data</param>
	<param name="textstr">text string to be added</param>
	<param name="val">color to set the text</param>
	<param name="location">L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
	<returns>pixd new pix with rendered text, or either a copy or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetTextblock(LeptonicaSharp.Pix,LeptonicaSharp.L_Bmf,System.String,System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) This function paints a set of lines of text over an image.
 (2) %val is the pixel value to be painted through the font mask.
 It should be chosen to agree with the depth of pixs.
 If it is out of bounds, an intermediate value is chosen.
 For RGB, use hex notation 0xRRGGBB00, where RR is the
 hex representation of the red intensity, etc.
 The last two hex digits are 00 (byte value 0), assigned to
 the A component.  Note that, as usual, RGBA proceeds from
 left to right in the order from MSB to LSB (see pix.h
 for details).
 (3) If there is a colormap, this does the best it can to use
 the requested color, or something similar to it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image</param>
	<param name="bmf">bitmap font data</param>
	<param name="textstr">block text string to be set</param>
	<param name="val">color to set the text</param>
	<param name="x0">left edge for each line of text</param>
	<param name="y0">baseline location for the first text line</param>
	<param name="wtext">max width of each line of generated text</param>
	<param name="firstindent">indentation of first line, in x-widths</param>
	<param name="poverflow">0 if text is contained in input pix; 1 if it is clipped</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSetTextline(LeptonicaSharp.Pix,LeptonicaSharp.L_Bmf,System.String,System.UInt32,System.Int32,System.Int32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) This function paints a line of text over an image.
 (2) %val is the pixel value to be painted through the font mask.
 It should be chosen to agree with the depth of pixs.
 If it is out of bounds, an intermediate value is chosen.
 For RGB, use hex notation 0xRRGGBB00, where RR is the
 hex representation of the red intensity, etc.
 The last two hex digits are 00 (byte value 0), assigned to
 the A component.  Note that, as usual, RGBA proceeds from
 left to right in the order from MSB to LSB (see pix.h
 for details).
 (3) If there is a colormap, this does the best it can to use
 the requested color, or something similar to it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">input image</param>
	<param name="bmf">bitmap font data</param>
	<param name="textstr">text string to be set on the line</param>
	<param name="val">color to set the text</param>
	<param name="x0">left edge for first char</param>
	<param name="y0">baseline location for all text on line</param>
	<param name="pwidth">width of generated text</param>
	<param name="poverflow">0 if text is contained in input pix; 1 if it is clipped</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaAddTextNumber(LeptonicaSharp.Pixa,LeptonicaSharp.L_Bmf,System.UInt32,LeptonicaSharp.Enumerations.L_ADD,LeptonicaSharp.Numa)">
	<summary>
 Notes
 (1) Typical usage is for labelling each pix in a pixa with a number.
 (2) This function paints numbers external to each pix, in a position
 given by %location.  In all cases, the pix is expanded on
 on side and the number is painted over white in the added region.
 (3) %val is the pixel value to be painted through the font mask.
 It should be chosen to agree with the depth of pixs.
 If it is out of bounds, an intermediate value is chosen.
 For RGB, use hex notation 0xRRGGBB00, where RR is the
 hex representation of the red intensity, etc.
 (4) If na == NULL, number each pix sequentially, starting with 1.
 (5) If there is a colormap, this does the best it can to use
 the requested color, or something similar to it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">input pixa; colormap ok</param>
	<param name="bmf">bitmap font data</param>
	<param name="na">number array; use 1 ... n if null</param>
	<param name="val">color to set the text</param>
	<param name="location">L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
	<returns>pixad new pixa with rendered numbers, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaAddTextlines(LeptonicaSharp.Pixa,LeptonicaSharp.L_Bmf,System.UInt32,LeptonicaSharp.Enumerations.L_ADD,LeptonicaSharp.Sarray)">
	<summary>
 Notes
 (1) This function adds one or more lines of text externally to
 each pix, in a position given by %location.  In all cases,
 the pix is expanded as necessary to accommodate the text.
 (2) %val is the pixel value to be painted through the font mask.
 It should be chosen to agree with the depth of pixs.
 If it is out of bounds, an intermediate value is chosen.
 For RGB, use hex notation 0xRRGGBB00, where RR is the
 hex representation of the red intensity, etc.
 (3) If sa == NULL, use the text embedded in each pix.  In all
 cases, newlines in the text string are used to separate the
 lines of text that are added to the pix.
 (4) If sa has a smaller count than pixa, issue a warning
 and do not use any embedded text.
 (5) If there is a colormap, this does the best it can to use
 the requested color, or something similar to it.
 </summary>
	<remarks>
	</remarks>
	<param name="pixas">input pixa; colormap ok</param>
	<param name="bmf">bitmap font data</param>
	<param name="sa">sarray; use text embedded in each pix if null</param>
	<param name="val">color to set the text</param>
	<param name="location">L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
	<returns>pixad new pixa with rendered text, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaAddPixWithText(LeptonicaSharp.Pixa,LeptonicaSharp.Pix,System.Int32,System.UInt32,LeptonicaSharp.Enumerations.L_ADD,LeptonicaSharp.L_Bmf,System.String)">
	<summary>
 Notes
 (1) This function generates a new pix with added text, and adds
 it by insertion into the pixa.
 (2) If the input pixs is not cmapped and not 32 bpp, it is
 converted to 32 bpp rgb.  %val is a standard 32 bpp pixel,
 expressed as 0xrrggbb00.  If there is a colormap, this does
 the best it can to use the requested color, or something close.
 (3) if %bmf == NULL, generate an 8 pt font; this takes about 5 msec.
 (4) If %textstr == NULL, use the text field in the pix.
 (5) In general, the text string can be written in multiple lines;
 use newlines as the separators.
 (6) Typical usage is for debugging, where the pixa of labeled images
 is used to generate a pdf.  Suggest using 1.0 for scalefactor.
 </summary>
	<remarks>
	</remarks>
	<param name="pixa"></param>
	<param name="pixs">any depth, colormap ok</param>
	<param name="reduction">integer subsampling factor</param>
	<param name="bmf">bitmap font data</param>
	<param name="textstr">text string to be added</param>
	<param name="val">color to set the text</param>
	<param name="location">L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bmfGetLineStrings(LeptonicaSharp.L_Bmf,System.String,System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) Divides the input text string into an array of text strings,
 each of which will fit within maxw bits of width.
 </summary>
	<remarks>
	</remarks>
	<param name="bmf"></param>
	<param name="textstr"></param>
	<param name="maxw">max width of a text line in pixels</param>
	<param name="firstindent">indentation of first line, in x-widths</param>
	<param name="ph">height required to hold text bitmap</param>
	<returns>sarray of text strings for each line, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bmfGetWordWidths(LeptonicaSharp.L_Bmf,System.String,LeptonicaSharp.Sarray)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bmf"></param>
	<param name="textstr"></param>
	<param name="sa">of individual words</param>
	<returns>numa of word lengths in pixels for the font represented by the bmf, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.bmfGetStringWidth(LeptonicaSharp.L_Bmf,System.String,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="bmf"></param>
	<param name="textstr"></param>
	<param name="pw">width of text string, in pixels for the font represented by the bmf</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.splitStringToParagraphs(System.String,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="textstr">text string</param>
	<param name="splitflag">see enum in bmf.h; valid values in {1,2,3}</param>
	<returns>sarray where each string is a paragraph of the input, or NULL on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadTiff(System.String,System.Int32)">
	<summary>
 Notes
 (1) This is a version of pixRead(), specialized for tiff
 files, that allows specification of the page to be returned
 (2) No warning messages on failure, because of how multi-page
 TIFF reading works. You are supposed to keep trying until
 it stops working.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="n">page number 0 based</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadStreamTiff(LeptonicaSharp.FILE,System.Int32)">
	<summary>
 Notes
 (1) No warning messages on failure, because of how multi-page
 TIFF reading works. You are supposed to keep trying until
 it stops working.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="n">page number 0 based</param>
	<returns>pix, or NULL on error or if there are no more images in the file</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteTiff(System.String,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.IFF,System.String)">
	<summary>
 Notes
 (1) For multipage tiff, write the first pix with mode "w" and
 all subsequent pix with mode "a".
 (2) For multipage tiff, there is considerable overhead in the
 machinery to append an image and add the directory entry,
 and the time required for each image increases linearly
 with the number of images in the file.
 </summary>
	<remarks>
	</remarks>
	<param name="filename">to write to</param>
	<param name="pix"></param>
	<param name="comptype">IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	<param name="modestr">"a" or "w"</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteTiffCustom(System.String,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.IFF,System.String,LeptonicaSharp.Numa,LeptonicaSharp.Sarray,LeptonicaSharp.Sarray,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename">to write to</param>
	<param name="pix"></param>
	<param name="comptype">IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	<param name="modestr">"a" or "w"</param>
	<param name="natags">NUMA of custom tiff tags</param>
	<param name="savals">SARRAY of values</param>
	<param name="satypes">SARRAY of types</param>
	<param name="nasizes">NUMA of sizes</param>
	<returns>0 if OK, 1 on error Usage 1 This writes a page image to a tiff file, with optional extra tags defined in tiff.h 2 For multipage tiff, write the first pix with mode "w" and all subsequent pix with mode "a". 3 For the custom tiff tags a The three arrays {natags, savals, satypes} must all be either NULL or defined and of equal size. b If they are defined, the tags are an array of integers, the vals are an array of values in string format, and the types are an array of types in string format. c All valid tags are definined in tiff.h. d The types allowed are the set of strings "char" "l_uint8" "l_uint16" "l_uint32" "l_int32" "l_float64" "l_uint16-l_uint16" note the dash; use it between the two l_uint16 vals in the val string Of these, "char" and "l_uint16" are the most commonly used. e The last array, nasizes, is also optional.  It is for tags that take an array of bytes for a value, a number of elements in the array, and a type that is either "char" or "l_uint8" probably either will work. Use NULL if there are no such tags. f VERY IMPORTANT if there are any tags that require the extra size value, stored in nasizes, they must be written first!</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamTiff(LeptonicaSharp.FILE,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.IFF)">
	<summary>
 Notes
 (1) This writes a single image to a file stream opened for writing.
 (2) For images with bpp GT 1, this resets the comptype, if
 necessary, to write uncompressed data.
 (3) G3 and G4 are only defined for 1 bpp.
 (4) We only allow PACKBITS for bpp = 1, because for bpp GT 1
 it typically expands images that are not synthetically generated.
 (5) G4 compression is typically about twice as good as G3.
 G4 is excellent for binary compression of text/line-art,
 but terrible for halftones and dithered patterns.  (In
 fact, G4 on halftones can give a file that is larger
 than uncompressed!)  If a binary image has dithered
 regions, it is usually better to compress with png.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix"></param>
	<param name="comptype">IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamTiffWA(LeptonicaSharp.FILE,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.IFF,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for append or write</param>
	<param name="pix"></param>
	<param name="comptype">IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	<param name="modestr">"w" or "a"</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadFromMultipageTiff(System.String,System.UInt32@)">
	<summary>
 Notes
 (1) This allows overhead for traversal of a multipage tiff file
 to be linear in the number of images.  This will also work
 with a singlepage tiff file.
 (2) No TIFF internal data structures are exposed to the caller
 (thanks to Jeff Breidenbach).
 (3) offset is the byte offset of a particular image in a multipage
 tiff file. To get the first image in the file, input the
 special offset value of 0.
 (4) The offset is updated to point to the next image, for a
 subsequent call.
 (5) On the last image, the offset returned is 0.  Exit the loop
 when the returned offset is 0.
 (6) For reading a multipage tiff from a memory buffer, see
 pixReadMemFromMultipageTiff()
 (7) Example usage for reading all the images in the tif file
 size_t offset = 0;
 do {
 Pix pix = pixReadFromMultipageTiff(filename, offset);
 // do something with pix
 } while (offset != 0);
 </summary>
	<remarks>
	</remarks>
	<param name="fname">filename</param>
	<param name="poffset">set offset to 0 for first image</param>
	<returns>pix, or NULL on error or if previous call returned the last image</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaReadMultipageTiff(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename">input tiff file</param>
	<returns>pixa of page images, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaWriteMultipageTiff(System.String,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) The tiff directory overhead is O(n^2).  I have not been
 able to reduce it to O(n).  The overhead for n = 2000 is
 about 1 second.
 </summary>
	<remarks>
	</remarks>
	<param name="fname">input tiff file</param>
	<param name="pixa">any depth; colormap will be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.writeMultipageTiff(System.String,System.String,System.String)">
	<summary>
 Notes
 (1) This writes a set of image files in a directory out
 as a multipage tiff file.  The images can be in any
 initial file format.
 (2) Images with a colormap have the colormap removed before
 re-encoding as tiff.
 (3) All images are encoded losslessly.  Those with 1 bpp are
 encoded 'g4'.  The rest are encoded as 'zip' (flate encoding).
 Because it is lossless, this is an expensive method for
 saving most rgb images.
 (4) The tiff directory overhead is quadratic in the number of
 images.  To avoid this for very large numbers of images to be
 written, apply the method used in pixaWriteMultipageTiff().
 </summary>
	<remarks>
	</remarks>
	<param name="dirin">input directory</param>
	<param name="substr">substring filter on filenames; can be NULL</param>
	<param name="fileout">output multipage tiff file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.writeMultipageTiffSA(LeptonicaSharp.Sarray,System.String)">
	<summary>
 Notes
 (1) See writeMultipageTiff()
 </summary>
	<remarks>
	</remarks>
	<param name="sa">string array of full path names</param>
	<param name="fileout">output ps file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fprintTiffInfo(LeptonicaSharp.FILE,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fpout">stream for output of tag data</param>
	<param name="tiffile">input</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.tiffGetCount(LeptonicaSharp.FILE,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for read</param>
	<param name="pn">number of images</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getTiffResolution(LeptonicaSharp.FILE,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If neither resolution field is set, this is not an error;
 the returned resolution values are 0 (designating 'unknown').
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened for read</param>
	<param name="pxres">resolution in ppi</param>
	<param name="pyres">resolution in ppi</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readHeaderTiff(System.String,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If there is a colormap, cmap is returned as 1; else 0.
 (2) If %n is equal to or greater than the number of images, returns 1.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="n">page image number 0-based</param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<param name="pbps">bits per sample -- 1, 2, 4 or 8</param>
	<param name="pspp">samples per pixel -- 1 or 3</param>
	<param name="pres">resolution in x dir; NULL to ignore</param>
	<param name="pcmap">colormap exists; input NULL to ignore</param>
	<param name="pformat">tiff format; input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.freadHeaderTiff(LeptonicaSharp.FILE,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) If there is a colormap, cmap is returned as 1; else 0.
 (2) If %n is equal to or greater than the number of images, returns 1.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="n">page image number 0-based</param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<param name="pbps">bits per sample -- 1, 2, 4 or 8</param>
	<param name="pspp">samples per pixel -- 1 or 3</param>
	<param name="pres">resolution in x dir; NULL to ignore</param>
	<param name="pcmap">colormap exists; input NULL to ignore</param>
	<param name="pformat">tiff format; input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readHeaderMemTiff(System.Byte[],System.UInt32,System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.
 </summary>
	<remarks>
	</remarks>
	<param name="cdata">const; tiff-encoded</param>
	<param name="size">size of data</param>
	<param name="n">page image number 0-based</param>
	<param name="pw">width</param>
	<param name="ph">height</param>
	<param name="pbps">bits per sample -- 1, 2, 4 or 8</param>
	<param name="pspp">samples per pixel -- 1 or 3</param>
	<param name="pres">resolution in x dir; NULL to ignore</param>
	<param name="pcmap">colormap exists; input NULL to ignore</param>
	<param name="pformat">tiff format; input NULL to ignore</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.findTiffCompression(LeptonicaSharp.FILE,System.Int32@)">
	<summary>
 Notes
 (1) The returned compression type is that defined in
 the enum in imageio.h.  It is not the tiff flag value.
 (2) The compression type is initialized to IFF_UNKNOWN.
 If it is not one of the specified types, the returned
 type is IFF_TIFF, which indicates no compression.
 (3) When this function is called, the stream must be at BOF.
 If the opened stream is to be used again to read the
 file, it must be rewound to BOF after calling this function.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream; must be rewound to BOF</param>
	<param name="pcomptype">compression type</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.extractG4DataFromFile(System.String,System.Byte[]@,System.UInt32@,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filein"></param>
	<param name="pdata">binary data of ccitt g4 encoded stream</param>
	<param name="pnbytes">size of binary data</param>
	<param name="pw">image width</param>
	<param name="ph">image height</param>
	<param name="pminisblack">boolean</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadMemTiff(System.Byte[],System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) This is a version of pixReadTiff(), where the data is read
 from a memory buffer and uncompressed.
 (2) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.
 (3) No warning messages on failure, because of how multi-page
 TIFF reading works. You are supposed to keep trying until
 it stops working.
 (4) Tiff directory overhead is linear in the input page number.
 If reading many images, use pixReadMemFromMultipageTiff().
 </summary>
	<remarks>
	</remarks>
	<param name="cdata">const; tiff-encoded</param>
	<param name="size">size of cdata</param>
	<param name="n">page image number 0-based</param>
	<returns>pix, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadMemFromMultipageTiff(System.Byte[],System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) This is a read-from-memory version of pixReadFromMultipageTiff().
 See that function for usage.
 (2) If reading sequentially from the tiff data, this is more
 efficient than pixReadMemTiff(), which has an overhead
 proportional to the image index n.
 (3) Example usage for reading all the images
 size_t offset = 0;
 do {
 Pix pix = pixReadMemFromMultipageTiff(data, size, offset);
 // do something with pix
 } while (offset != 0);
 </summary>
	<remarks>
	</remarks>
	<param name="cdata">const; tiff-encoded</param>
	<param name="size">size of cdata</param>
	<param name="poffset">set offset to 0 for first image</param>
	<returns>pix, or NULL on error or if previous call returned the last image</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaReadMemMultipageTiff(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) This is an O(n) read-from-memory version of pixaReadMultipageTiff().
 </summary>
	<remarks>
	</remarks>
	<param name="data">const; multiple pages; tiff-encoded</param>
	<param name="size">size of cdata</param>
	<returns>pixa, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaWriteMemMultipageTiff(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pixa)">
	<summary>
 Notes
 (1) fopenTiffMemstream() does not work in append mode, so we
 must work-around with a temporary file.
 (2) Getting a file stream from
 open_memstream((char )pdata, psize)
 does not work with the tiff directory.
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">const; tiff-encoded</param>
	<param name="psize">size of data</param>
	<param name="pixa">any depth; colormap will be removed</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMemTiff(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.IFF)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdata">data of tiff compressed image</param>
	<param name="psize">size of returned data</param>
	<param name="pix"></param>
	<param name="comptype">IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	<returns>0 if OK, 1 on error Usage 1) See pixWriteTiff(.  This version writes to memory instead of to a file.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMemTiffCustom(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.IFF,LeptonicaSharp.Numa,LeptonicaSharp.Sarray,LeptonicaSharp.Sarray,LeptonicaSharp.Numa)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pdata">data of tiff compressed image</param>
	<param name="psize">size of returned data</param>
	<param name="pix"></param>
	<param name="comptype">IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS, IFF_TIFF_G3, IFF_TIFF_G4, IFF_TIFF_LZW, IFF_TIFF_ZIP</param>
	<param name="natags">NUMA of custom tiff tags</param>
	<param name="savals">SARRAY of values</param>
	<param name="satypes">SARRAY of types</param>
	<param name="nasizes">NUMA of sizes</param>
	<returns>0 if OK, 1 on error Usage 1) See pixWriteTiffCustom(.  This version writes to memory instead of to a file. 2) Use TIFFClose(); TIFFCleanup( doesn't free internal memstream.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.setMsgSeverity(System.Int32)">
	<summary>
 Notes
 (1) setMsgSeverity() allows the user to specify the desired
 message severity threshold.  Messages of equal or greater
 severity will be output.  The previous message severity is
 returned when the new severity is set.
 (2) If L_SEVERITY_EXTERNAL is passed, then the severity will be
 obtained from the LEPT_MSG_SEVERITY environment variable.
 </summary>
	<remarks>
	</remarks>
	<param name="newsev"></param>
	<returns>oldsev</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.returnErrorInt(System.String,System.String,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="msg">error message</param>
	<param name="procname"></param>
	<param name="ival">return val</param>
	<returns>ival typically 1 for an error return</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.returnErrorFloat(System.String,System.String,System.Single)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="msg">error message</param>
	<param name="procname"></param>
	<param name="fval">return val</param>
	<returns>fval</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.returnErrorPtr(System.String,System.String,System.Object)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="msg">error message</param>
	<param name="procname"></param>
	<param name="pval">return val</param>
	<returns>pval typically null</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.filesAreIdentical(System.String,System.String,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fname1"></param>
	<param name="fname2"></param>
	<param name="psame">1 if identical; 0 if different</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertOnLittleEnd16(System.UInt16@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertOnBigEnd16(System.UInt16@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertOnLittleEnd32(System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertOnBigEnd32(System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fileCorruptByDeletion(System.String,System.Single,System.Single,System.String)">
	<summary>
 Notes
 (1) %loc and %size are expressed as a fraction of the file size.
 (2) This makes a copy of the data in %filein, where bytes in the
 specified region have deleted.
 (3) If (%loc + %size) GT= 1.0, this deletes from the position
 represented by %loc to the end of the file.
 (4) It is useful for testing robustness of I/O wrappers when the
 data is corrupted, by simulating data corruption by deletion.
 </summary>
	<remarks>
	</remarks>
	<param name="filein"></param>
	<param name="loc">fractional location of start of deletion</param>
	<param name="size">fractional size of deletion</param>
	<param name="fileout">corrupted file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fileCorruptByMutation(System.String,System.Single,System.Single,System.String)">
	<summary>
 Notes
 (1) %loc and %size are expressed as a fraction of the file size.
 (2) This makes a copy of the data in %filein, where bytes in the
 specified region have been replaced by random data.
 (3) If (%loc + %size) GT= 1.0, this modifies data from the position
 represented by %loc to the end of the file.
 (4) It is useful for testing robustness of I/O wrappers when the
 data is corrupted, by simulating data corruption.
 </summary>
	<remarks>
	</remarks>
	<param name="filein"></param>
	<param name="loc">fractional location of start of randomization</param>
	<param name="size">fractional size of randomization</param>
	<param name="fileout">corrupted file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.genRandomIntegerInRange(System.Int32,System.Int32,System.Int32@)">
	<summary>
 Notes
 (1) For example, to choose a rand integer between 0 and 99,
 use %range = 100.
 </summary>
	<remarks>
	</remarks>
	<param name="range">size of range; must be GT= 2</param>
	<param name="seed">use 0 to skip; otherwise call srand</param>
	<param name="pval">random integer in range {0 ... range-1}</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_roundftoi(System.Single)">
	<summary>
 Notes
 (1) For fval GT= 0, fval --GT round(fval) == floor(fval + 0.5)
 For fval LT 0, fval --GT -round(-fval))
 This is symmetric around 0.
 e.g., for fval in (-0.5 ... 0.5), fval --GT 0
 </summary>
	<remarks>
	</remarks>
	<param name="fval"></param>
	<returns>value rounded to int</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_hashStringToUint64(System.String,System.UInt64@)">
	<summary>
 Notes
 (1) The intent of the hash is to avoid collisions by mapping
 the string as randomly as possible into 64 bits.
 (2) To the extent that the hashes are random, the probability of
 a collision can be approximated by the square of the number
 of strings divided by 2^64.  For 1 million strings, the
 collision probability is about 1 in 16 million.
 (3) I expect non-randomness of the distribution to be most evident
 for small text strings.  This hash function has been tested
 for all 5-character text strings composed of 26 letters,
 of which there are 26^5 = 12356630.  There are no hash
 collisions for this set.
 </summary>
	<remarks>
	</remarks>
	<param name="str"></param>
	<param name="phash">hash vale</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_hashPtToUint64(System.Int32,System.Int32,System.UInt64@)">
	<summary>
 Notes
 (1) I found that a simple hash function has no collisions for
 any of 400 million points with x and y up to 20000.
 (2) Previously used a much more complicated and slower function
 mulp = 26544357894361;
 hash = 104395301;
 hash += (x  mulp) ^ (hash GTGT 5);
 hash ^= (hash LTLT 7);
 hash += (y  mulp) ^ (hash GTGT 7);
 hash = hash ^ (hash LTLT 11);
 Such logical gymnastics to get coverage over the 2^64
 values are not required.
 </summary>
	<remarks>
	</remarks>
	<param name="x"></param>
	<param name="y"></param>
	<param name="phash">hash value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_hashFloat64ToUint64(System.Int32,System.Double,System.UInt64@)">
	<summary>
 Notes
 (1) Simple, fast hash for using dnaHash with 64-bit data
 (e.g., sets and histograms).
 (2) The resulting hash is called a "key" in a lookup
 operation.  The bucket for %val in a dnaHash is simply
 found by taking the mod of the hash with the number of
 buckets (which is prime).  What gets stored in the
 dna in that bucket could depend on use, but for the most
 flexibility, we store an index into the associated dna.
 This is all that is required for generating either a hash set
 or a histogram (an example of a hash map).
 (3) For example, to generate a histogram, the histogram dna,
 a histogram of unique values aligned with the histogram dna,
 and a dnahash hashmap are built.  See l_dnaMakeHistoByHash().
 </summary>
	<remarks>
	</remarks>
	<param name="nbuckets"></param>
	<param name="val"></param>
	<param name="phash">hash value</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.findNextLargerPrime(System.Int32,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="start"></param>
	<param name="pprime">first prime larger than %start</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_isPrime(System.UInt64,System.Int32@,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="n">64-bit unsigned</param>
	<param name="pis_prime">1 if prime, 0 otherwise</param>
	<param name="pfactor">smallest divisor, or 0 on error or if prime</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertIntToGrayCode(System.UInt32)">
	<summary>
 Notes
 (1) Gray code values corresponding to integers differ by
 only one bit transition between successive integers.
 </summary>
	<remarks>
	</remarks>
	<param name="val">integer value</param>
	<returns>corresponding gray code value</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertGrayCodeToInt(System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="val">gray code value</param>
	<returns>corresponding integer value</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getLeptonicaVersion">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.startTimer">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.stopTimer">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.startTimerNested">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stopTimerNested(System.IntPtr@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_getCurrentTime(System.Object@,System.Object@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.startWallTimer">
	<summary>
 Notes
 (1) These measure the wall clock time  elapsed between the two calls
 L_WALLTIMER timer = startWallTimer();
 ....
 fprintf(stderr, "Elapsed time = %f sec\n", stopWallTimer(timer);
 (2) Note that the timer object is destroyed by stopWallTimer().
 </summary>
	<remarks>
	</remarks>
	<returns>walltimer-ptr</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stopWallTimer(LeptonicaSharp.L_WallTimer@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="ptimer">walltimer-ptr</param>
	<returns>time wall time elapsed in seconds</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_getFormattedDate">
	<summary>
 Notes
 (1) This is used in pdf, in the form specified in section 3.8.2 of
 http//partners.adobe.com/public/developer/en/pdf/PDFReference.pdf
 (2) Contributed by Dave Bryan.  Works on all platforms.
 </summary>
	<remarks>
	</remarks>
	<returns>formatted date string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringNew(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="src">string</param>
	<returns>dest copy of src string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringCopy(System.String,System.String,System.Int32)">
	<summary>
 Notes
 (1) Relatively safe wrapper for strncpy, that checks the input,
 and does not complain if %src is null or %n LT 1.
 If %n LT 1, this is a no-op.
 (2) %dest needs to be at least %n bytes in size.
 (3) We don't call strncpy() because valgrind complains about
 use of uninitialized values.
 </summary>
	<remarks>
	</remarks>
	<param name="dest">existing byte buffer</param>
	<param name="src">string [optional] can be null</param>
	<param name="n">max number of characters to copy</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringReplace(System.String[]@,System.String)">
	<summary>
 Notes
 (1) Frees any existing dest string
 (2) Puts a copy of src string in the dest
 (3) If either or both strings are null, does something reasonable.
 </summary>
	<remarks>
	</remarks>
	<param name="pdest">string copy</param>
	<param name="src">string [optional] can be null</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringLength(System.String,System.UInt32)">
	<summary>
 Notes
 (1) Safe implementation of strlen that only checks size bytes
 for trailing NUL.
 (2) Valid returned string lengths are between 0 and size - 1.
 If size bytes are checked without finding a NUL byte, then
 an error is indicated by returning size.
 </summary>
	<remarks>
	</remarks>
	<param name="src">string can be null or NULL-terminated string</param>
	<param name="size">size of src buffer</param>
	<returns>length of src in bytes.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringCat(System.String,System.UInt32,System.String)">
	<summary>
 Notes
 (1) Alternative implementation of strncat, that checks the input,
 is easier to use (since the size of the dest buffer is specified
 rather than the number of bytes to copy), and does not complain
 if %src is null.
 (2) Never writes past end of dest.
 (3) If it can't append src (an error), it does nothing.
 (4) N.B. The order of 2nd and 3rd args is reversed from that in
 strncat, as in the Windows function strcat_s().
 </summary>
	<remarks>
	</remarks>
	<param name="dest">null-terminated byte buffer</param>
	<param name="size">size of dest</param>
	<param name="src">string can be null or NULL-terminated string</param>
	<returns>number of bytes added to dest; -1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringConcatNew(System.String)">
	<summary>
 Notes
 (1) The last arg in the list of strings must be NULL.
 (2) Caller must free the returned string.
 </summary>
	<remarks>
	</remarks>
	<param name="first">first string in list</param>
	<returns>result new string concatenating the input strings, or NULL if first == NULL</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringJoin(System.String,System.String)">
	<summary>
 Notes
 (1) This is a safe version of strcat; it makes a new string.
 (2) It is not an error if either or both of the strings
 are empty, or if either or both of the pointers are null.
 </summary>
	<remarks>
	</remarks>
	<param name="src1">string [optional] can be null</param>
	<param name="src2">string [optional] can be null</param>
	<returns>concatenated string, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringJoinIP(System.String[]@,System.String)">
	<summary>
 Notes
 (1) This is a safe in-place version of strcat.  The contents of
 src1 is replaced by the concatenation of src1 and src2.
 (2) It is not an error if either or both of the strings
 are empty (""), or if the pointers to the strings (psrc1, src2)
 are null.
 (3) src1 should be initialized to null or an empty string
 before the first call.  Use one of these
 char src1 = NULL;
 char src1 = stringNew("");
 Then call with
 stringJoinIP(src1, src2);
 (4) This can also be implemented as a macro
 \code
 #define stringJoinIP(src1, src2) \
 {tmpstr = stringJoin((src1),(src2)); \
 LEPT_FREE(src1); \
 (src1) = tmpstr;}
 \endcode
 (5) Another function to consider for joining many strings is
 stringConcatNew().
 </summary>
	<remarks>
	</remarks>
	<param name="psrc1">string address of src1; cannot be on the stack</param>
	<param name="src2">string [optional] can be null</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringReverse(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="src">string</param>
	<returns>dest newly-allocated reversed string</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.strtokSafe(System.String@,System.String,System.String[]@)">
	<summary>
 Notes
 (1) This is a thread-safe implementation of strtok.
 (2) It has the same interface as strtok_r.
 (3) It differs from strtok_r in usage in two respects
 (a) the input string is not altered
 (b) each returned substring is newly allocated and must
 be freed after use.
 (4) Let me repeat that.  This is "safe" because the input
 string is not altered and because each returned string
 is newly allocated on the heap.
 (5) It is here because, surprisingly, some C libraries don't
 include strtok_r.
 (6) Important usage points
 ~ Input the string to be parsed on the first invocation.
 ~ Then input NULL after that; the value returned in saveptr
 is used in all subsequent calls.
 (7) This is only slightly slower than strtok_r.
 </summary>
	<remarks>
	</remarks>
	<param name="seps">a string of character separators</param>
	<param name="psaveptr">ptr to the next char after the last encountered separator</param>
	<returns>substr a new string that is copied from the previous saveptr up to but not including the next separator character, or NULL if end of cstr.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringSplitOnToken(System.String@,System.String,System.String[]@,System.String[]@)">
	<summary>
 Notes
 (1) The input string is not altered; all split parts are new strings.
 (2) The split occurs around the first consecutive sequence of
 tokens encountered.
 (3) The head goes from the beginning of the string up to
 but not including the first token found.
 (4) The tail contains the second part of the string, starting
 with the first char in that part that is NOT a token.
 (5) If no separator token is found, 'head' contains a copy
 of the input string and 'tail' is null.
 </summary>
	<remarks>
	</remarks>
	<param name="seps">a string of character separators</param>
	<param name="phead">ptr to copy of the input string, up to the first separator token encountered</param>
	<param name="ptail">ptr to copy of the part of the input string starting with the first non-separator character that occurs after the first separator is found</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringCheckForChars(System.String,System.String,System.Int32@)">
	<summary>
 Notes
 (1) This can be used to sanitize an operation by checking for
 special characters that don't belong in a string.
 </summary>
	<remarks>
	</remarks>
	<param name="src">input string; can be of zero length</param>
	<param name="chars">string of chars to be searched for in %src</param>
	<param name="pfound">1 if any characters are found; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringRemoveChars(System.String,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="src">input string; can be of zero length</param>
	<param name="remchars">string of chars to be removed from src</param>
	<returns>dest string with specified chars removed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringFindSubstr(System.String,System.String@,System.Int32@)">
	<summary>
 Notes
 (1) This is a wrapper around strstr().
 (2) Both %src and %sub must be defined, and %sub must have
 length of at least 1.
 (3) If the substring is not found and loc is returned, it has
 the value -1.
 </summary>
	<remarks>
	</remarks>
	<param name="src">input string; can be of zero length</param>
	<param name="ploc">location of substring in src</param>
	<returns>1 if found; 0 if not found or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringReplaceSubstr(System.String,System.String,System.String,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) Replaces the first instance.
 (2) To only remove sub1, use "" for sub2
 (3) Returns a new string if sub1 and sub2 are the same.
 (4) The optional loc is input as the byte offset within the src
 from which the search starts, and after the search it is the
 char position in the string of the next character after
 the substituted string.
 (5) N.B. If ploc is not null, loc must always be initialized.
 To search the string from the beginning, set loc = 0.
 </summary>
	<remarks>
	</remarks>
	<param name="src">input string; can be of zero length</param>
	<param name="sub1">substring to be replaced</param>
	<param name="sub2">substring to put in; can be ""</param>
	<param name="pfound">1 if sub1 is found; 0 otherwise</param>
	<param name="ploc">location of ptr after replacement</param>
	<returns>dest string with substring replaced, or NULL if the substring not found or on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.stringReplaceEachSubstr(System.String,System.String,System.String,System.Int32@)">
	<summary>
 Notes
 (1) Replaces every instance.
 (2) To only remove each instance of sub1, use "" for sub2
 (3) Returns NULL if sub1 and sub2 are the same.
 </summary>
	<remarks>
	</remarks>
	<param name="src">input string; can be of zero length</param>
	<param name="sub1">substring to be replaced</param>
	<param name="sub2">substring to put in; can be ""</param>
	<param name="pcount">the number of times that sub1 is found in src; 0 if not found</param>
	<returns>dest string with substring replaced, or NULL if the substring not found or on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.arrayFindEachSequence(System.Byte[],System.UInt32,System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) The byte arrays %data and %sequence are not C strings,
 as they can contain null bytes.  Therefore, for each
 we must give the length of the array.
 (2) This finds every occurrence in %data of %sequence.
 </summary>
	<remarks>
	</remarks>
	<param name="data">byte array</param>
	<param name="datalen">length of data, in bytes</param>
	<param name="sequence">subarray of bytes to find in data</param>
	<param name="seqlen">length of sequence, in bytes</param>
	<returns>dna of offsets where the sequence is found, or NULL if none are found or on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.arrayFindSequence(System.Byte[],System.UInt32,System.Byte[],System.UInt32,System.Int32@,System.Int32@)">
	<summary>
 Notes
 (1) The byte arrays 'data' and 'sequence' are not C strings,
 as they can contain null bytes.  Therefore, for each
 we must give the length of the array.
 (2) This searches for the first occurrence in %data of %sequence,
 which consists of %seqlen bytes.  The parameter %seqlen
 must not exceed the actual length of the %sequence byte array.
 (3) If the sequence is not found, the offset will be 0, so you
 must check %found.
 </summary>
	<remarks>
	</remarks>
	<param name="data">byte array</param>
	<param name="datalen">length of data, in bytes</param>
	<param name="sequence">subarray of bytes to find in data</param>
	<param name="seqlen">length of sequence, in bytes</param>
	<param name="poffset">offset from beginning of data where the sequence begins</param>
	<param name="pfound">1 if sequence is found; 0 otherwise</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.reallocNew(System.Int32,System.Int32,System.IntPtr[]@)">
	<summary>
 Notes
 (1) If newsize LT=0, just frees input data and nulls ptr
 (2) If input ptr is null, just callocs new memory
 (3) This differs from realloc in that it always allocates
 new memory (if newsize GT 0) and initializes it to 0,
 it requires the amount of old data to be copied,
 and it takes the address of the input ptr and
 nulls the handle.
 </summary>
	<remarks>
	</remarks>
	<param name="pindata">; nulls indata</param>
	<param name="oldsize">size of input data to be copied, in bytes</param>
	<param name="newsize">size of data to be reallocated in bytes</param>
	<returns>ptr to new data, or NULL on error Action !N.B. 3) and (4! 1 Allocates memory, initialized to 0 2 Copies as much of the input data as possible to the new block, truncating the copy if necessary 3 Frees the input data 4 Zeroes the input data ptr</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_binaryRead(System.String,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pnbytes">number of bytes read</param>
	<returns>data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_binaryReadStream(LeptonicaSharp.FILE,System.UInt32@)">
	<summary>
 Notes
 (1) The returned array is terminated with a null byte so that it can
 be used to read ascii data from a file into a proper C string.
 (2) This can be used to capture data that is piped in via stdin,
 because it does not require seeking within the file.
 (3) For example, you can read an image from stdin into memory
 using shell redirection, with one of these shell commands
 \code
 cat LTimagefileGT | readprog
 readprog LT LTimagefileGT
 \endcode
 where readprog is
 \code
 l_uint8 data = l_binaryReadStream(stdin, nbytes);
 Pix pix = pixReadMem(data, nbytes);
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream opened to read; can be stdin</param>
	<param name="pnbytes">number of bytes read</param>
	<returns>null-terminated array, or NULL on error reading 0 bytes is not an error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_binaryReadSelect(System.String,System.UInt32,System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) The returned array is terminated with a null byte so that it can
 be used to read ascii data from a file into a proper C string.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="start">first byte to read</param>
	<param name="nbytes">number of bytes to read; use 0 to read to end of file</param>
	<param name="pnread">number of bytes actually read</param>
	<returns>data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_binaryReadSelectStream(LeptonicaSharp.FILE,System.UInt32,System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) The returned array is terminated with a null byte so that it can
 be used to read ascii data from a file into a proper C string.
 If the file to be read is empty and %start == 0, an array
 with a single null byte is returned.
 (2) Side effect the stream pointer is re-positioned to the
 beginning of the file.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="start">first byte to read</param>
	<param name="nbytes">number of bytes to read; use 0 to read to end of file</param>
	<param name="pnread">number of bytes actually read</param>
	<returns>null-terminated array, or NULL on error reading 0 bytes is not an error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_binaryWrite(System.String,System.String,System.Object,System.UInt32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename">output</param>
	<param name="operation">"w" for write; "a" for append</param>
	<param name="data">binary data to be written</param>
	<param name="nbytes">size of data array</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.nbytesInFile(System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>nbytes in file; 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fnbytesInFile(LeptonicaSharp.FILE)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>nbytes in file; 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_binaryCopy(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) We add 4 bytes to the zeroed output because in some cases
 (e.g., string handling) it is important to have the data
 be null terminated.  This guarantees that after the memcpy,
 the result is automatically null terminated.
 </summary>
	<remarks>
	</remarks>
	<param name="datas"></param>
	<param name="size">of data array</param>
	<returns>datad on heap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fileCopy(System.String,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="srcfile">copy this file</param>
	<param name="newfile">to this file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fileConcatenate(System.String,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="srcfile">file to append</param>
	<param name="destfile">file to add to</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fileAppendString(System.String,System.String)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="str">string to append to file</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fopenReadStream(System.String)">
	<summary>
 Notes
 (1) This should be used whenever you want to run fopen() to
 read from a stream.  Never call fopen() directory.
 (2) This handles the temp directory pathname conversion on windows
 /tmp  ==GT  [Windows Temp directory]
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>stream, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fopenWriteStream(System.String,System.String)">
	<summary>
 Notes
 (1) This should be used whenever you want to run fopen() to
 write or append to a stream.  Never call fopen() directory.
 (2) This handles the temp directory pathname conversion on windows
 /tmp  ==GT  [Windows Temp directory]
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="modestring"></param>
	<returns>stream, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fopenReadFromMemory(System.Byte[],System.UInt32)">
	<summary>
 Notes
 (1) Work-around if fmemopen() not available.
 (2) Windows tmpfile() writes into the root C\ directory, which
 requires admin privileges.  This also works around that.
 </summary>
	<remarks>
	</remarks>
	<param name="data"></param>
	<param name="size"></param>
	<returns>file stream, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.fopenWriteWinTempfile">
	<summary>
 Notes
 (1) The Windows version of tmpfile() writes into the root
 C\ directory, which requires admin privileges.  This
 function provides an alternative implementation.
 </summary>
	<remarks>
	</remarks>
	<returns>file stream, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_fopen(System.String,System.String)">
	<summary>
 Notes
 (1) This must be used by any application that passes
 a file handle to a leptonica Windows DLL.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="mode">same as for fopen(); e.g., "rb"</param>
	<returns>stream or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_fclose(LeptonicaSharp.FILE)">
	<summary>
 Notes
 (1) This should be used by any application that accepts
 a file handle generated by a leptonica Windows DLL.
 </summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_calloc(System.UInt32,System.UInt32)">
	<summary>
 Notes
 (1) For safety with windows DLLs, this can be used in conjunction
 with lept_free() to avoid C-runtime boundary problems.
 Just use these two functions throughout your application.
 </summary>
	<remarks>
	</remarks>
	<param name="nmemb">number of members</param>
	<param name="size">of each member</param>
	<returns>void ptr, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_free(System.Object)">
	<summary>
 Notes
 (1) This should be used by any application that accepts
 heap data allocated by a leptonica Windows DLL.
 </summary>
	<remarks>
	</remarks>
	<param name="ptr"></param>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_mkdir(System.String)">
	<summary>
 Notes
 (1) %subdir is a partial path that can consist of one or more
 directories.
 (2) This makes any subdirectories of /tmp that are required.
 (3) The root temp directory is
 /tmp (unix)  [default]
 [Temp]  (windows)
 </summary>
	<remarks>
	</remarks>
	<param name="subdir">of /tmp or its equivalent on Windows</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_rmdir(System.String)">
	<summary>
 Notes
 (1) %subdir is a partial path that can consist of one or more
 directories.
 (2) This removes all files from the specified subdirectory of
 the root temp directory
 /tmp (unix)
 [Temp]  (windows)
 and then removes the subdirectory.
 (3) The combination
 lept_rmdir(subdir);
 lept_mkdir(subdir);
 is guaranteed to give you an empty subdirectory.
 </summary>
	<remarks>
	</remarks>
	<param name="subdir">of /tmp or its equivalent on Windows</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_direxists(System.String,System.Int32@)">
	<summary>
 Notes
 (1) Always use unix pathname separators.
 (2) By calling genPathname(), if the pathname begins with "/tmp"
 this does an automatic directory translation on windows
 to a path in the windows [Temp] directory
 "/tmp"  ==GT  [Temp] (windows)
 </summary>
	<remarks>
	</remarks>
	<param name="dir"></param>
	<param name="pexists">1 if it exists; 0 otherwise</param>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_rm_match(System.String,System.String)">
	<summary>
 Notes
 (1) This removes the matched files in /tmp or a subdirectory of /tmp.
 Use NULL for %subdir if the files are in /tmp.
 (2) If %substr == NULL, this removes all files in the directory.
 If %substr == "" (empty), this removes no files.
 If both %subdir == NULL and %substr == NULL, this removes
 all files in /tmp.
 (3) Use unix pathname separators.
 (4) By calling genPathname(), if the pathname begins with "/tmp"
 this does an automatic directory translation on windows
 to a path in the windows [Temp] directory
 "/tmp"  ==GT  [Temp] (windows)
 (5) Error conditions
 returns -1 if the directory is not found
 returns the number of files (GT 0) that it was unable to remove.
 </summary>
	<remarks>
	</remarks>
	<param name="subdir">If NULL, the removed files are in /tmp</param>
	<param name="substr">pattern to match in filename</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_rm(System.String,System.String)">
	<summary>
 Notes
 (1) By calling genPathname(), this does an automatic directory
 translation on windows to a path in the windows [Temp] directory
 "/tmp/..."  ==GT  [Temp]/... (windows)
 </summary>
	<remarks>
	</remarks>
	<param name="subdir">of '/tmp'; can be NULL</param>
	<param name="tail">filename without the directory</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_rmfile(System.String)">
	<summary>
 Notes
 (1) This removes the named file.
 (2) Use unix pathname separators.
 (3) There is no name translation.
 (4) Unlike the other lept_ functions in this section, this can remove
 any file -- it is not restricted to files that are in /tmp or a
 subdirectory of it.
 </summary>
	<remarks>
	</remarks>
	<param name="filepath">full path to file including the directory</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_mv(System.String,System.String,System.String,System.String[]@)">
	<summary>
 Notes
 (1) This moves %srcfile to /tmp or to a subdirectory of /tmp.
 (2) %srcfile can either be a full path or relative to the
 current directory.
 (3) %newdir can either specify an existing subdirectory of /tmp
 or can be NULL.  In the latter case, the file will be written
 into /tmp.
 (4) %newtail can either specify a filename tail or, if NULL,
 the filename is taken from src-tail, the tail of %srcfile.
 (5) For debugging, the computed newpath can be returned.  It must
 be freed by the caller.
 (6) Reminders
 (a) specify files using unix pathnames
 (b) for windows, translates
 /tmp  ==GT  [Temp]
 where [Temp] is the windows temp directory
 (7) Examples
 newdir = NULL, newtail = NULL ==GT /tmp/src-tail
 newdir = NULL, newtail = abc  ==GT /tmp/abc
 newdir = def/ghi, newtail = NULL ==GT /tmp/def/ghi/src-tail
 newdir = def/ghi, newtail = abc  ==GT /tmp/def/ghi/abc
 </summary>
	<remarks>
	</remarks>
	<param name="srcfile"></param>
	<param name="newdir">; can be NULL</param>
	<param name="newtail">; can be NULL</param>
	<param name="pnewpath">of actual path; can be NULL</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.lept_cp(System.String,System.String,System.String,System.String[]@)">
	<summary>
 Notes
 (1) This copies %srcfile to /tmp or to a subdirectory of /tmp.
 (2) %srcfile can either be a full path or relative to the
 current directory.
 (3) %newdir can either specify an existing subdirectory of /tmp,
 or can be NULL.  In the latter case, the file will be written
 into /tmp.
 (4) %newtail can either specify a filename tail or, if NULL,
 the filename is taken from src-tail, the tail of %srcfile.
 (5) For debugging, the computed newpath can be returned.  It must
 be freed by the caller.
 (6) Reminders
 (a) specify files using unix pathnames
 (b) for windows, translates
 /tmp  ==GT  [Temp]
 where [Temp] is the windows temp directory
 (7) Examples
 newdir = NULL, newtail = NULL ==GT /tmp/src-tail
 newdir = NULL, newtail = abc  ==GT /tmp/abc
 newdir = def/ghi, newtail = NULL ==GT /tmp/def/ghi/src-tail
 newdir = def/ghi, newtail = abc  ==GT /tmp/def/ghi/abc
 </summary>
	<remarks>
	</remarks>
	<param name="srcfile"></param>
	<param name="newdir">; can be NULL</param>
	<param name="newtail">; can be NULL</param>
	<param name="pnewpath">of actual path; can be NULL</param>
	<returns>0 on success, non-zero on failure</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.callSystemDebug(System.String)">
	<summary>
 Notes
 (1) The C library 'system' call is only made through this function.
 It only works in debug/test mode, where the global variable
 LeptDebugOK == TRUE.  This variable is set to FALSE in the
 library as distributed, and calling this function will
 generate an error message.
 </summary>
	<remarks>
	</remarks>
	<param name="cmd">command to be exec'd</param>
</member><member name="M:LeptonicaSharp._AllFunctions.splitPathAtDirectory(System.String,System.String[]@,System.String[]@)">
	<summary>
 Notes
 (1) If you only want the tail, input null for the root directory ptr.
 (2) If you only want the root directory name, input null for the
 tail ptr.
 (3) This function makes decisions based only on the lexical
 structure of the input.  Examples
 /usr/tmp/abc  --GT  dir /usr/tmp/ tail abc
 /usr/tmp/  --GT  dir /usr/tmp/ tail [empty string]
 /usr/tmp   --GT  dir /usr/  tail tmp
 abc  --GT  dir [empty string]  tail abc
 (4) The input can have either forward (unix) or backward (win)
 slash separators.  The output has unix separators.
 Note that Win32 pathname functions generally accept both
 slash forms, but the windows command line interpreter
 only accepts backward slashes, because forward slashes are
 used to demarcate switches (vs. dashes in unix).
 </summary>
	<remarks>
	</remarks>
	<param name="pathname">full path; can be a directory</param>
	<param name="pdir">root directory name of input path, including trailing '/'</param>
	<param name="ptail">path tail, which is either the file name within the root directory or the last sub-directory in the path</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.splitPathAtExtension(System.String,System.String[]@,System.String[]@)">
	<summary>
 Notes
 (1) If you only want the extension, input null for the basename ptr.
 (2) If you only want the basename without extension, input null
 for the extension ptr.
 (3) This function makes decisions based only on the lexical
 structure of the input.  Examples
 /usr/tmp/abc.jpg  --GT  basename /usr/tmp/abc ext .jpg
 /usr/tmp/.jpg  --GT  basename /usr/tmp/ ext .jpg
 /usr/tmp.jpg/  --GT  basename /usr/tmp.jpg/   ext [empty str]
 ./.jpg   --GT  basename ./  ext .jpg
 (4) The input can have either forward (unix) or backward (win)
 slash separators.  The output has unix separators.
 </summary>
	<remarks>
	</remarks>
	<param name="pathname">full path; can be a directory</param>
	<param name="pbasename">pathname not including the last dot and characters after that</param>
	<param name="pextension">path extension, which is the last dot and the characters after it.  If there is no extension, it returns the empty string</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pathJoin(System.String,System.String)">
	<summary>
 Notes
 (1) Use unix-style pathname separators ('/').
 (2) %fname can be the entire path, or part of the path containing
 at least one directory, or a tail without a directory, or NULL.
 (3) It produces a path that strips multiple slashes to a single
 slash, joins %dir and %fname by a slash, and has no trailing
 slashes (except in the cases where %dir == "/" and
 %fname == NULL, or v.v.).
 (4) If both %dir and %fname are null, produces an empty string.
 (5) Neither %dir nor %fname can begin with '..'.
 (6) The result is not canonicalized or tested for correctness
 garbage in (e.g., /%), garbage out.
 (7) Examples
 //tmp// + //abc/  --GT  /tmp/abc
 tmp/ + /abc/   --GT  tmp/abc
 tmp/ + abc/ --GT  tmp/abc
 /tmp/ + /// --GT  /tmp
 /tmp/ + NULL   --GT  /tmp
 // + /abc// --GT  /abc
 // + NULL   --GT  /
 NULL + /abc/def/  --GT  /abc/def
 NULL + abc//   --GT  abc
 NULL + //   --GT  /
 NULL + NULL --GT  (empty string)
 "" + ""  --GT  (empty string)
 "" + /   --GT  /
 ".." + /etc/foo   --GT  NULL
 /tmp + ".." --GT  NULL
 </summary>
	<remarks>
	</remarks>
	<param name="dir">can be null</param>
	<param name="fname">can be null</param>
	<returns>specially concatenated path, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.appendSubdirs(System.String,System.String)">
	<summary>
 Notes
 (1) Use unix pathname separators
 (2) Allocates a new string  [basedir]/[subdirs]
 </summary>
	<remarks>
	</remarks>
	<param name="basedir"></param>
	<param name="subdirs"></param>
	<returns>concatenated full directory path without trailing slash, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.convertSepCharsInPath(System.String,LeptonicaSharp.Enumerations.PATH_SEPCHAR)">
	<summary>
 Notes
 (1) In-place conversion.
 (2) Type is the resulting type
 UNIX_PATH_SEPCHAR  '\\' ==GT '/'
 WIN_PATH_SEPCHAR   '/' ==GT '\\'
 (3) Virtually all path operations in leptonica use unix separators.
 </summary>
	<remarks>
	</remarks>
	<param name="path"></param>
	<param name="type">UNIX_PATH_SEPCHAR, WIN_PATH_SEPCHAR</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.genPathname(System.String,System.String)">
	<summary>
 Notes
 (1) This function generates actual paths in the following ways
 from two sub-parts (e.g., a directory and a file name).
 from a single path full path, placed in %dir, with
 %fname == NULL.
 from the name of a file in the local directory placed in
 %fname, with %dir == NULL.
 if in a "/tmp" directory and on windows, the windows
 temp directory is used.
 (2) On windows, if the root of %dir is '/tmp', this does a name
 translation
 "/tmp"  ==GT  [Temp] (windows)
 where [Temp] is the windows temp directory.
 (3) On unix, the TMPDIR variable is ignored.  No rewriting
 of temp directories is permitted.
 (4) There are four cases for the input
 (a) %dir is a directory and %fname is defined result is a full path
 (b) %dir is a directory and %fname is null result is a directory
 (c) %dir is a full path and %fname is null result is a full path
 (d) %dir is null or an empty string start in the current dir;
 result is a full path
 (5) In all cases, the resulting pathname is not terminated with a slash
 (6) The caller is responsible for freeing the returned pathname.
 </summary>
	<remarks>
	</remarks>
	<param name="dir">directory or full path name, with or without trailing '/'</param>
	<param name="fname">file name within a directory</param>
	<returns>pathname either a directory or full path, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.makeTempDirname(System.String,System.UInt32,System.String)">
	<summary>
 Notes
 (1) This generates the directory path for output temp files,
 written into %result with unix separators.
 (2) Caller allocates %result, large enough to hold the path,
 which is
 /tmp/%subdir (unix)
 [Temp]/%subdir  (windows)
 where [Temp] is a path on windows determined by GenTempPath()
 and %subdir is in general a set of nested subdirectories
 dir1/dir2/.../dirN
 which in use would not typically exceed 2 levels.
 (3) Usage example
 \code
 char  result[256];
 makeTempDirname(result, 256, "lept/golden");
 \endcode
 </summary>
	<remarks>
	</remarks>
	<param name="result">preallocated on stack or heap and passed in</param>
	<param name="nbytes">size of %result array, in bytes</param>
	<param name="subdir">; can be NULL or an empty string</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.modifyTrailingSlash(System.String,System.UInt32,LeptonicaSharp.Enumerations.L_TRAIL_SLASH)">
	<summary>
 Notes
 (1) This carries out the requested action if necessary.
 </summary>
	<remarks>
	</remarks>
	<param name="path">preallocated on stack or heap and passed in</param>
	<param name="nbytes">size of %path array, in bytes</param>
	<param name="flag">L_ADD_TRAIL_SLASH or L_REMOVE_TRAIL_SLASH</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_makeTempFilename">
	<summary>
 Notes
 (1) On unix, this makes a filename of the form
 "/tmp/lept.XXXXXX",
 where each X is a random character.
 (2) On windows, this makes a filename of the form
 "/[Temp]/lp.XXXXXX".
 (3) On all systems, this fails if the file is not writable.
 (4) Safest usage is to write to a subdirectory in debug code.
 (5) The returned filename must be freed by the caller, using lept_free.
 (6) The tail of the filename has a '.', so that cygwin interprets
 the file as having an extension.  Otherwise, cygwin assumes it
 is an executable and appends ".exe" to the filename.
 (7) On unix, whenever possible use tmpfile() instead.  tmpfile()
 hides the file name, returns a stream opened for write,
 and deletes the temp file when the stream is closed.
 </summary>
	<remarks>
	</remarks>
	<returns>fname  heap allocated filename; returns NULL on failure.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.extractNumberFromFilename(System.String,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) The number is to be found in the basename, which is the
 filename without either the directory or the last extension.
 (2) When a number is found, it is non-negative.  If no number
 is found, this returns -1, without an error message.  The
 caller needs to check.
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="numpre">number of characters before the digits to be found</param>
	<param name="numpost">number of characters after the digits to be found</param>
	<returns>num number embedded in the filename; -1 on error or if not found</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSimpleCaptcha(LeptonicaSharp.Pix,System.Int32,System.Int32,System.UInt32,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) This uses typical default values for generating captchas.
 The magnitudes of the harmonic warp are typically to be
 smaller when more terms are used, even though the phases
 are random.  See, for example, prog/warptest.c.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="border">added white pixels on each side</param>
	<param name="nterms">number of x and y harmonic terms</param>
	<param name="seed">of random number generator</param>
	<param name="color">for colorizing; in 0xrrggbb00 format; use 0 for black</param>
	<param name="cmapflag">1 for colormap output; 0 for rgb</param>
	<returns>pixd 8 bpp cmap or 32 bpp rgb, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixRandomHarmonicWarp(LeptonicaSharp.Pix,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.UInt32,System.Int32)">
	<summary>
 Notes
 (1) To generate the warped image p(x',y'), set up the transforms
 that are in getWarpTransform().  For each (x',y') in the
 dest, the warp function computes the originating location
 (x, y) in the src.  The differences (x - x') and (y - y')
 are given as a sum of products of sinusoidal terms.  Each
 term is multiplied by a maximum amplitude (in pixels), and the
 angle is determined by a frequency and phase, and depends
 on the (x', y') value of the dest.  Random numbers with
 a variable input seed are used to allow the warping to be
 unpredictable.  A linear interpolation is used to find
 the value for the source at (x, y); this value is written
 into the dest.
 (2) This can be used to generate 'captcha's, which are somewhat
 randomly distorted images of text.  A typical set of parameters
 for a captcha are
 xmag = 4.0  ymag = 6.0
 xfreq = 0.10   yfreq = 0.13
 nx = 3   ny = 3
 Other examples can be found in prog/warptest.c.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp; no colormap</param>
	<param name="xmag">maximum magnitude of x and y distortion</param>
	<param name="ymag">maximum magnitude of x and y distortion</param>
	<param name="xfreq">maximum magnitude of x and y frequency</param>
	<param name="yfreq">maximum magnitude of x and y frequency</param>
	<param name="nx">number of x and y harmonic terms</param>
	<param name="ny">number of x and y harmonic terms</param>
	<param name="seed">of random number generator</param>
	<param name="grayval">color brought in from the outside; 0 for black, 255 for white</param>
	<returns>pixd 8 bpp; no colormap, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWarpStereoscopic(LeptonicaSharp.Pix,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This function splits out the red channel, mucks around with
 it, then recombines with the unmolested cyan channel.
 (2) By using a quadratically increasing shift of the red
 pixels horizontally and away from the vertical centerline,
 the image appears to bend quadratically out of the image
 plane, symmetrically with respect to the vertical center
 line.  A positive value of %zbend causes the plane to be
 curved away from the viewer.  We use linearly interpolated
 stretching to avoid the appearance of kinks in the curve.
 (3) The parameters %zshiftt and %zshiftb tilt the image plane
 about a horizontal line through the center, and at the
 same time move that line either in toward the viewer or away.
 This is implemented by a combination of horizontal shear
 about the center line (for the tilt) and horizontal
 translation (to move the entire plane in or out).
 A positive value of %zshiftt moves the top of the plane
 away from the viewer, and a positive value of %zshiftb
 moves the bottom of the plane away.  We use linear interpolated
 shear to avoid visible vertical steps in the tilted image.
 (4) The image can be bent in the plane and about the vertical
 centerline.  The centerline does not shift, and the
 parameter %ybend gives the relative shift at left and right
 edges, with a downward shift for positive values of %ybend.
 (6) When writing out a steroscopic (red/cyan) image in jpeg,
 first call pixSetChromaSampling(pix, 0) to get sufficient
 resolution in the red channel.
 (7) Typical values are
 zbend = 20
 zshiftt = 15
 zshiftb = -15
 ybendt = 30
 ybendb = 0
 If the disparity z-values are too large, it is difficult for
 the brain to register the two images.
 (8) This function has been cleverly reimplemented by Jeff Breidenbach.
 The original implementation used two 32 bpp rgb images,
 and merged them at the end.  The result is somewhat faded,
 and has a parameter "thresh" that controls the amount of
 color in the result.  (The present implementation avoids these
 two problems, skipping both the colorization and the alpha
 blending at the end, and is about 3x faster)
 The basic operations with 32 bpp are as follows
 // Immediate conversion to 32 bpp
 Pix pixt1 = pixConvertTo32(pixs);
 // Do vertical shear
 Pix pixr = pixQuadraticVerticalShear(pixt1, L_WARP_TO_RIGHT,
 ybendt, ybendb,
 L_BRING_IN_WHITE);
 // Colorize two versions, toward red and cyan
 Pix pixc = pixCopy(NULL, pixr);
 l_int32 thresh = 150;  // if higher, get less original color
 pixColorGray(pixr, NULL, L_PAINT_DARK, thresh, 255, 0, 0);
 pixColorGray(pixc, NULL, L_PAINT_DARK, thresh, 0, 255, 255);
 // Shift the red pixels; e.g., by stretching
 Pix pixrs = pixStretchHorizontal(pixr, L_WARP_TO_RIGHT,
 L_QUADRATIC_WARP, zbend,
 L_INTERPOLATED,
 L_BRING_IN_WHITE);
 // Blend the shifted red and unshifted cyan 5050
 Pix pixg = pixCreate(w, h, 8);
 pixSetAllArbitrary(pixg, 128);
 pixd = pixBlendWithGrayMask(pixrs, pixc, pixg, 0, 0);
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">any depth, colormap ok</param>
	<param name="zbend">horizontal separation in pixels of red and cyan at the left and right sides, that gives rise to quadratic curvature out of the image plane</param>
	<param name="zshiftt">uniform pixel translation difference between red and cyan, that pushes the top of the image plane away from the viewer (zshiftt GT 0) or towards the viewer (zshiftt LT 0)</param>
	<param name="zshiftb">uniform pixel translation difference between red and cyan, that pushes the bottom of the image plane away from the viewer (zshiftb GT 0) or towards the viewer (zshiftb LT 0)</param>
	<param name="ybendt">multiplicative parameter for in-plane vertical displacement at the left or right edge at the top y = ybendt  (2x/w - 1)^2</param>
	<param name="ybendb">same as ybendt, except at the left or right edge at the bottom</param>
	<param name="redleft">1 if the red filter is on the left; 0 otherwise</param>
	<returns>pixd 32 bpp, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixStretchHorizontal(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_WARP_TO_T,LeptonicaSharp.Enumerations.L_WARP,System.Int32,LeptonicaSharp.Enumerations.L_ED,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) If %hmax GT 0, this is an increase in the coordinate value of
 pixels in pixd, relative to the same pixel in pixs.
 (2) If %dir == L_WARP_TO_LEFT, the pixels on the right edge of
 the image are not moved. So, for example, if %hmax GT 0
 and %dir == L_WARP_TO_LEFT, the pixels in pixd are
 contracted toward the right edge of the image, relative
 to those in pixs.
 (3) If %type == L_LINEAR_WARP, the pixel positions are moved
 to the left or right by an amount that varies linearly with
 the horizontal location.
 (4) If %operation == L_SAMPLED, the dest pixels are taken from
 the nearest src pixel.  Otherwise, we use linear interpolation
 between pairs of sampled pixels.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 or 32 bpp</param>
	<param name="dir">L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	<param name="type">L_LINEAR_WARP or L_QUADRATIC_WARP</param>
	<param name="hmax">horizontal displacement at edge</param>
	<param name="operation">L_SAMPLED or L_INTERPOLATED</param>
	<param name="incolor">L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	<returns>pixd stretched/compressed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixStretchHorizontalSampled(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_WARP_TO_T,LeptonicaSharp.Enumerations.L_WARP,System.Int32,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) See pixStretchHorizontal() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 or 32 bpp</param>
	<param name="dir">L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	<param name="type">L_LINEAR_WARP or L_QUADRATIC_WARP</param>
	<param name="hmax">horizontal displacement at edge</param>
	<param name="incolor">L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	<returns>pixd stretched/compressed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixStretchHorizontalLI(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_WARP_TO_T,LeptonicaSharp.Enumerations.L_WARP,System.Int32,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) See pixStretchHorizontal() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 or 32 bpp</param>
	<param name="dir">L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	<param name="type">L_LINEAR_WARP or L_QUADRATIC_WARP</param>
	<param name="hmax">horizontal displacement at edge</param>
	<param name="incolor">L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	<returns>pixd stretched/compressed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixQuadraticVShear(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_WARP_TO_T,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_ED,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) This gives a quadratic bending, upward or downward, as you
 move to the left or right.
 (2) If %dir == L_WARP_TO_LEFT, the right edge is unchanged, and
 the left edge pixels are moved maximally up or down.
 (3) Parameters %vmaxt and %vmaxb control the maximum amount of
 vertical pixel shear at the top and bottom, respectively.
 If %vmaxt GT 0, the vertical displacement of pixels at the
 top is downward.  Likewise, if %vmaxb GT 0, the vertical
 displacement of pixels at the bottom is downward.
 (4) If %operation == L_SAMPLED, the dest pixels are taken from
 the nearest src pixel.  Otherwise, we use linear interpolation
 between pairs of sampled pixels.
 (5) This is for quadratic shear.  For uniform (linear) shear,
 use the standard shear operators.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 or 32 bpp</param>
	<param name="dir">L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	<param name="vmaxt">max vertical displacement at edge and at top</param>
	<param name="vmaxb">max vertical displacement at edge and at bottom</param>
	<param name="operation">L_SAMPLED or L_INTERPOLATED</param>
	<param name="incolor">L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	<returns>pixd stretched, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixQuadraticVShearSampled(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_WARP_TO_T,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) See pixQuadraticVShear() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 8 or 32 bpp</param>
	<param name="dir">L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	<param name="vmaxt">max vertical displacement at edge and at top</param>
	<param name="vmaxb">max vertical displacement at edge and at bottom</param>
	<param name="incolor">L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	<returns>pixd stretched, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixQuadraticVShearLI(LeptonicaSharp.Pix,LeptonicaSharp.Enumerations.L_WARP_TO_T,System.Int32,System.Int32,LeptonicaSharp.Enumerations.L_BRING_IN)">
	<summary>
 Notes
 (1) See pixQuadraticVShear() for details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 or 32 bpp, or colormapped</param>
	<param name="dir">L_WARP_TO_LEFT or L_WARP_TO_RIGHT</param>
	<param name="vmaxt">max vertical displacement at edge and at top</param>
	<param name="vmaxb">max vertical displacement at edge and at bottom</param>
	<param name="incolor">L_BRING_IN_WHITE or L_BRING_IN_BLACK</param>
	<returns>pixd stretched, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixStereoFromPair(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Single,System.Single,System.Single)">
	<summary>
 Notes
 (1) pix1 and pix2 are a pair of stereo images, ideally taken
 concurrently in the same plane, with some lateral translation.
 (2) The output red channel is determined from %pix1.
 The output green and blue channels are taken from the green
 and blue channels, respectively, of %pix2.
 (3) The weights determine how much of each component in %pix1
 goes into the output red channel.  The sum of weights
 must be 1.0.  If it's not, we scale the weights to
 satisfy this criterion.
 (4) The most general pixel mapping allowed here is
 rval = rwt  r1 + gwt  g1 + bwt  b1  (from pix1)
 gval = g2   (from pix2)
 bval = b2   (from pix2)
 (5) The simplest method is to use rwt = 1.0, gwt = 0.0, bwt = 0.0,
 but this causes unpleasant visual artifacts with red in the image.
 Use of green and blue from %pix1 in the red channel,
 instead of red, tends to fix that problem.
 </summary>
	<remarks>
	</remarks>
	<param name="pix1">32 bpp rgb</param>
	<param name="pix2">32 bpp rgb</param>
	<param name="rwt">weighting factors used for each component in                                pix1 to determine the output red channel</param>
	<param name="gwt">weighting factors used for each component in                                pix1 to determine the output red channel</param>
	<param name="bwt">weighting factors used for each component in                                pix1 to determine the output red channel</param>
	<returns>pixd stereo enhanced, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.wshedCreate(LeptonicaSharp.Pix,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) It is not necessary for the fg pixels in the seed image
 be at minima, or that they be isolated.  We extract a
 single pixel from each connected component, and a seed
 anywhere in a watershed will eventually label the watershed
 when the filling level reaches it.
 (2) Set mindepth to some value to ignore noise in pixs that
 can create small local minima.  Any watershed shallower
 than mindepth, even if it has a seed, will not be saved;
 It will either be incorporated in another watershed or
 eliminated.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">8 bpp source</param>
	<param name="pixm">1 bpp 'marker' seed</param>
	<param name="mindepth">minimum depth; anything less is not saved</param>
	<param name="debugflag">1 for debug output</param>
	<returns>WShed, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.wshedDestroy(LeptonicaSharp.L_WShed@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pwshed">will be set to null before returning</param>
</member><member name="M:LeptonicaSharp._AllFunctions.wshedApply(LeptonicaSharp.L_WShed)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="wshed">generated from wshedCreate()</param>
	<returns>0 if OK, 1 on error Iportant note 1 This is buggy.  It seems to locate watersheds that are duplicates.  The watershed extraction after complete fill grabs some regions belonging to existing watersheds. See prog/watershedtest.c for testing.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.wshedBasins(LeptonicaSharp.L_WShed,LeptonicaSharp.Pixa@,LeptonicaSharp.Numa@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="wshed"></param>
	<param name="ppixa">mask of watershed basins</param>
	<param name="pnalevels">watershed levels</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.wshedRenderFill(LeptonicaSharp.L_WShed)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="wshed"></param>
	<returns>pixd initial image with all basins filled, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.wshedRenderColors(LeptonicaSharp.L_WShed)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="wshed"></param>
	<returns>pixd initial image with all basins filled, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadStreamWebP(LeptonicaSharp.FILE@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixReadMemWebP(System.Byte[]@,System.UInt32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readHeaderWebP(System.String@,System.Object@,System.Object@,System.Object@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.readHeaderMemWebP(System.Byte[]@,System.UInt32@,System.Object@,System.Object@,System.Object@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteWebP(System.String@,LeptonicaSharp.Pix@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStreamWebP(LeptonicaSharp.FILE@,LeptonicaSharp.Pix@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMemWebP(System.Object@,System.Object@,LeptonicaSharp.Pix@,System.Int32@,System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<returns></returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_jpegSetQuality(System.Int32)">
	<summary>
 Notes
 (1) This variable is used in pixWriteStream() and pixWriteMem(),
 to control the jpeg quality.  The default is 75.
 (2) It returns the previous quality, so for example
 l_int32  prev = l_jpegSetQuality(85);  //sets to 85
 pixWriteStream(...);
 l_jpegSetQuality(prev);   // resets to previous value
 (3) On error, logs a message and does not change the variable.
 </summary>
	<remarks>
	</remarks>
	<param name="new_quality">1 - 100; 75 is default; 0 defaults to 75</param>
	<returns>prev           previous quality</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.setLeptDebugOK(System.Int32)">
	<summary>
 Notes
 (1) This sets or clears the global variable LeptDebugOK, to
 control writing files in a temp directory with names that
 are compiled in.
 (2) The default in the library distribution is 0.  Call with
 %allow = 1 for development and debugging.
 </summary>
	<remarks>
	</remarks>
	<param name="allow">TRUE (1) or FALSE (0)</param>
</member><member name="M:LeptonicaSharp._AllFunctions.pixaWriteFiles(System.String,LeptonicaSharp.Pixa,System.Int32)">
	<summary>
 Notes
 (1) Use %format = IFF_DEFAULT to decide the output format
 individually for each pix.
 </summary>
	<remarks>
	</remarks>
	<param name="rootname"></param>
	<param name="pixa"></param>
	<param name="format">defined in imageio.h; see notes for default</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteDebug(System.String,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Debug version, intended for use in the library when writing
 to files in a temp directory with names that are compiled in.
 This is used instead of pixWrite() for all such library calls.
 (2) The global variable LeptDebugOK defaults to 0, and can be set
 or cleared by the function setLeptDebugOK().
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="pix"></param>
	<param name="format">defined in imageio.h</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWrite(System.String,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) Open for write using binary mode (with the "b" flag)
 to avoid having Windows automatically translate the NL
 into CRLF, which corrupts image files.  On non-windows
 systems this flag should be ignored, per ISO C90.
 Thanks to Dave Bryan for pointing this out.
 (2) If the default image format IFF_DEFAULT is requested
 use the input format if known; otherwise, use a lossless format.
 (3) The default jpeg quality is 75.  For some other value,
 Use l_jpegSetQuality().
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="pix"></param>
	<param name="format">defined in imageio.h</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteAutoFormat(System.String,LeptonicaSharp.Pix)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pix"></param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteStream(LeptonicaSharp.FILE,LeptonicaSharp.Pix,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="fp">file stream</param>
	<param name="pix"></param>
	<param name="format"></param>
	<returns>0 if OK; 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteImpliedFormat(System.String,LeptonicaSharp.Pix,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This determines the output format from the filename extension.
 (2) The last two args are ignored except for requests for jpeg files.
 (3) The jpeg default quality is 75.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<param name="pix"></param>
	<param name="quality">iff JPEG; 1 - 100, 0 for default</param>
	<param name="progressive">iff JPEG; 0 for baseline seq., 1 for progressive</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixChooseOutputFormat(LeptonicaSharp.Pix)">
	<summary>
 Notes
 (1) This should only be called if the requested format is IFF_DEFAULT.
 (2) If the pix wasn't read from a file, its input format value
 will be IFF_UNKNOWN, and in that case it is written out
 in a compressed but lossless format.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>output format, or 0 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getImpliedFileFormat(System.String)">
	<summary>
 Notes
 (1) This determines the output file format from the extension
 of the input filename.
 </summary>
	<remarks>
	</remarks>
	<param name="filename"></param>
	<returns>output format, or IFF_UNKNOWN on error or invalid extension.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixGetAutoFormat(LeptonicaSharp.Pix,System.Object@)">
	<summary>
 Notes
 (1) The output formats are restricted to tiff, jpeg and png
 because these are the most commonly used image formats and
 the ones that are typically installed with leptonica.
 (2) This decides what compression to use based on the pix.
 It chooses tiff-g4 if 1 bpp without a colormap, jpeg with
 quality 75 if grayscale, rgb or rgba (where it loses
 the alpha layer), and lossless png for all other situations.
 </summary>
	<remarks>
	</remarks>
	<param name="pix"></param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.getFormatExtension(System.Int32)">
	<summary>
 Notes
 (1) This string is NOT owned by the caller; it is just a pointer
 to a global string.  Do not free it.
 </summary>
	<remarks>
	</remarks>
	<param name="format">integer</param>
	<returns>extension string, or NULL if format is out of range</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixWriteMem(System.Byte[]@,System.UInt32@,LeptonicaSharp.Pix,System.Int32)">
	<summary>
 Notes
 (1) On windows, this will only write tiff and PostScript to memory.
 For other formats, it requires open_memstream(3).
 (2) PostScript output is uncompressed, in hex ascii.
 Most printers support level 2 compression (tiff_g4 for 1 bpp,
 jpeg for 8 and 32 bpp).
 (3) The default jpeg quality is 75.  For some other value,
 Use l_jpegSetQuality().
 </summary>
	<remarks>
	</remarks>
	<param name="pdata">data of tiff compressed image</param>
	<param name="psize">size of returned data</param>
	<param name="pix"></param>
	<param name="format">defined in imageio.h</param>
	<returns>0 if OK, 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_fileDisplay(System.String,System.Int32,System.Int32,System.Single)">
	<summary>
 Notes
 (1) This is a convenient wrapper for displaying image files.
 (2) It does nothing unless LeptDebugOK == TRUE.
 (2) Set %scale = 0 to disable display.
 (3) This downscales 1 bpp to gray.
 </summary>
	<remarks>
	</remarks>
	<param name="fname"></param>
	<param name="x">location of display frame on the screen</param>
	<param name="y">location of display frame on the screen</param>
	<param name="scale">scale factor (use 0 to skip display)</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDisplay(LeptonicaSharp.Pix@,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) This is debugging code that displays an image on the screen.
 It uses a static internal variable to number the output files
 written by a single process.  Behavior with a shared library
 may be unpredictable.
 (2) It does nothing unless LeptDebugOK == TRUE.
 (3) It uses these programs to display the image
 On Unix xzgv, xli or xv
 On Windows i_view
 The display program must be on your $PATH variable.  It is
 chosen by setting the global var_DISPLAY_PROG, using
 l_chooseDisplayProg().  Default on Unix is xzgv.
 (4) Images with dimensions larger than MAX_DISPLAY_WIDTH or
 MAX_DISPLAY_HEIGHT are downscaled to fit those constraints.
 This is particularly important for displaying 1 bpp images
 with xv, because xv automatically downscales large images
 by subsampling, which looks poor.  For 1 bpp, we use
 scale-to-gray to get decent-looking anti-aliased images.
 In all cases, we write a temporary file to /tmp/lept/disp,
 that is read by the display program.
 (5) The temporary file is written as png if, after initial
 processing for special cases, any of these obtain
 pix dimensions are smaller than some thresholds
 pix depth is less than 8 bpp
 pix is colormapped
 (6) For spp == 4, we call pixDisplayLayersRGBA() to show 3
 versions of the image the image with a fully opaque
 alpha, the alpha, and the image as it would appear with
 a white background.
 </summary>
	<remarks>
	</remarks>
	<param name="x">location of display frame on the screen</param>
	<param name="y">location of display frame on the screen</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDisplayWithTitle(LeptonicaSharp.Pix@,System.Int32,System.Int32,System.Int32,System.String)">
	<summary>
 Notes
 (1) See notes for pixDisplay().
 (2) This displays the image if dispflag == 1; otherwise it punts.
 </summary>
	<remarks>
	</remarks>
	<param name="x">location of display frame</param>
	<param name="y">location of display frame</param>
	<param name="title">on frame; can be NULL;</param>
	<param name="dispflag">1 to write, else disabled</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSaveTiled(LeptonicaSharp.Pix,LeptonicaSharp.Pixa,System.Single,System.Int32,System.Int32,System.Int32)">
	<summary>
	</summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp</param>
	<param name="pixa">the pix are accumulated here</param>
	<param name="scalefactor">0.0 to disable; otherwise this is a scale factor</param>
	<param name="newrow">0 if placed on the same row as previous; 1 otherwise</param>
	<param name="space">horizontal and vertical spacing, in pixels</param>
	<param name="dp">depth of pixa; 8 or 32 bpp; only used on first call</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSaveTiledOutline(LeptonicaSharp.Pix,LeptonicaSharp.Pixa,System.Single,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Notes
 (1) Before calling this function for the first time, use
 pixaCreate() to make the %pixa that will accumulate the pix.
 This is passed in each time pixSaveTiled() is called.
 (2) %scalefactor scales the input image.  After scaling and
 possible depth conversion, the image is saved in the input
 pixa, along with a box that specifies the location to
 place it when tiled later.  Disable saving the pix by
 setting %scalefactor == 0.0.
 (3) %newrow and %space specify the location of the new pix
 with respect to the last one(s) that were entered.
 (4) %dp specifies the depth at which all pix are saved.  It can
 be only 8 or 32 bpp.  Any colormap is removed.  This is only
 used at the first invocation.
 (5) This function uses two variables from call to call.
 If they were static, the function would not be .so or thread
 safe, and furthermore, there would be interference with two or
 more pixa accumulating images at a time.  Consequently,
 we use the first pix in the pixa to store and obtain both
 the depth and the current position of the bottom (one pixel
 below the lowest image raster line when laid out using
 the boxa).  The bottom variable is stored in the input format
 field, which is the only field available for storing an int.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp</param>
	<param name="pixa">the pix are accumulated here</param>
	<param name="scalefactor">0.0 to disable; otherwise this is a scale factor</param>
	<param name="newrow">0 if placed on the same row as previous; 1 otherwise</param>
	<param name="space">horizontal and vertical spacing, in pixels</param>
	<param name="linewidth">width of added outline for image; 0 for no outline</param>
	<param name="dp">depth of pixa; 8 or 32 bpp; only used on first call</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.pixSaveTiledWithText(LeptonicaSharp.Pix,LeptonicaSharp.Pixa,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32,LeptonicaSharp.Enumerations.L_ADD,LeptonicaSharp.L_Bmf,System.String)">
	<summary>
 Notes
 (1) Before calling this function for the first time, use
 pixaCreate() to make the %pixa that will accumulate the pix.
 This is passed in each time pixSaveTiled() is called.
 (2) %outwidth is the scaled width.  After scaling, the image is
 saved in the input pixa, along with a box that specifies
 the location to place it when tiled later.  Disable saving
 the pix by setting %outwidth == 0.
 (3) %newrow and %space specify the location of the new pix
 with respect to the last one(s) that were entered.
 (4) All pix are saved as 32 bpp RGB.
 (5) If both %bmf and %textstr are defined, this generates a pix
 with the additional text; otherwise, no text is written.
 (6) The text is written before scaling, so it is properly
 antialiased in the scaled pix.  However, if the pix on
 different calls have different widths, the size of the
 text will vary.
 (7) See pixSaveTiledOutline() for other implementation details.
 </summary>
	<remarks>
	</remarks>
	<param name="pixs">1, 2, 4, 8, 32 bpp</param>
	<param name="pixa">the pix are accumulated here; as 32 bpp</param>
	<param name="outwidth">in pixels; use 0 to disable entirely</param>
	<param name="newrow">1 to start a new row; 0 to go on same row as previous</param>
	<param name="space">horizontal and vertical spacing, in pixels</param>
	<param name="linewidth">width of added outline for image; 0 for no outline</param>
	<param name="bmf">font struct</param>
	<param name="textstr">text string to be added</param>
	<param name="val">color to set the text</param>
	<param name="location">L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW</param>
	<returns>0 if OK, 1 on error.</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.l_chooseDisplayProg(System.Int32@)">
	<summary>
	</summary>
	<remarks>
	</remarks>
</member><member name="M:LeptonicaSharp._AllFunctions.pixDisplayWrite(LeptonicaSharp.Pix@,System.Int32)">
	<summary>
 Notes
 (0) Deprecated.
 (1) This is a simple interface for writing a set of files.
 (2) This uses jpeg output for pix that are 32 bpp or 8 bpp
 without a colormap; otherwise, it uses png.
 (3) To erase any previously written files in the output directory
 pixDisplayWrite(NULL, -1);
 (4) If reduction GT 1 and depth == 1, this does a scale-to-gray
 reduction.
 (5) This function uses a static internal variable to number
 output files written by a single process.  Behavior
 with a shared library may be unpredictable.
 (6) For 16 bpp, this displays the full dynamic range with log scale.
 Alternative image transforms to generate 8 bpp pix are
 pix8 = pixMaxDynamicRange(pixt, L_LINEAR_SCALE);
 pix8 = pixConvert16To8(pixt, 0);  // low order byte
 pix8 = pixConvert16To8(pixt, 1);  // high order byte
 </summary>
	<remarks>
	</remarks>
	<param name="reduction">-1 to reset/erase; 0 to disable; otherwise this is a reduction factor</param>
	<returns>0 if OK; 1 on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.zlibCompress(System.Byte[],System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) We repeatedly read in and fill up an input buffer,
 compress the data, and read it back out.  zlib
 uses two byte buffers internally in the z_stream
 data structure.  We use the bbuffers to feed data
 into the fixed bufferin, and feed it out of bufferout,
 in the same way that a pair of streams would normally
 be used if the data were being read from one file
 and written to another.  This is done iteratively,
 compressing L_BUF_SIZE bytes of input data at a time.
 </summary>
	<remarks>
	</remarks>
	<param name="datain">byte buffer with input data</param>
	<param name="nin">number of bytes of input data</param>
	<param name="pnout">number of bytes of output data</param>
	<returns>dataout compressed data, or NULL on error</returns>
</member><member name="M:LeptonicaSharp._AllFunctions.zlibUncompress(System.Byte[],System.UInt32,System.UInt32@)">
	<summary>
 Notes
 (1) See zlibCompress().
 </summary>
	<remarks>
	</remarks>
	<param name="datain">byte buffer with compressed input data</param>
	<param name="nin">number of bytes of input data</param>
	<param name="pnout">number of bytes of output data</param>
	<returns>dataout uncompressed data, or NULL on error</returns>
</member><member name="F:LeptonicaSharp.Enumerations.L_FOUND.L_NOT_FOUND">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_FOUND.L_FOUND">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_FOUND">
	<summary>
 Simple search state variables
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.PATH_SEPCHAR.UNIX_PATH_SEPCHAR">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.PATH_SEPCHAR.WIN_PATH_SEPCHAR">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.PATH_SEPCHAR">
	<summary>
 Path separator conversion
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SEVERITY.L_SEVERITY_EXTERNAL">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SEVERITY.L_SEVERITY_ALL">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SEVERITY.L_SEVERITY_DEBUG">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SEVERITY.L_SEVERITY_INFO">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SEVERITY.L_SEVERITY_WARNING">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SEVERITY.L_SEVERITY_ERROR">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SEVERITY.L_SEVERITY_NONE">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_SEVERITY">
	<summary>
 Control printing of error, warning and info messages
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_INTERP.L_LINEAR_INTERP">
	<summary>linear</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_INTERP.L_QUADRATIC_INTERP">
	<summary>quadratic</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_INTERP">
	<summary>
 Flags for interpolation in Numa
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BORDER.L_CONTINUED_BORDER">
	<summary>extended with same value</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BORDER.L_SLOPE_BORDER">
	<summary>extended with constant normal derivative</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BORDER.L_MIRRORED_BORDER">
	<summary>mirrored</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_BORDER">
	<summary>
 Flags for added borders in Numa and Fpix
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_VALUE.L_INTEGER_VALUE">
	<summary>convert to integer</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_VALUE.L_FLOAT_VALUE">
	<summary>convert to float</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_VALUE">
	<summary>
 Flags for data type converted from Numa
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_COMPACTION.L_NO_COMPACTION">
	<summary>null the pointer only</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_COMPACTION.L_COMPACTION">
	<summary>compact the array</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_COMPACTION">
	<summary>
 Flags for removal from L_Ptra
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DOWNSHIFT.L_AUTO_DOWNSHIFT">
	<summary>choose based on number of holes</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DOWNSHIFT.L_MIN_DOWNSHIFT">
	<summary>downshifts min # of ptrs below insert</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DOWNSHIFT.L_FULL_DOWNSHIFT">
	<summary>downshifts all ptrs below insert</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_DOWNSHIFT">
	<summary>
 Flags for insertion into L_Ptra
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_accessor__l_ptraa.L_HANDLE_ONLY">
	<summary>ptr to L_Ptra; caller can inspect only</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_accessor__l_ptraa.L_REMOVE">
	<summary>caller owns; destroy or save in L_Ptraa</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_accessor__l_ptraa">
	<summary>
 Accessor flags for L_Ptraa
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_T_TYPE.L_INT_TYPE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_T_TYPE.L_UINT_TYPE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_T_TYPE.L_FLOAT_TYPE">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_T_TYPE">
	<summary>
 The three valid key types for red-black trees, maps and sets.
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.SPLIT_ON.SPLIT_ON_LEADING_WHITE">
	<summary>tab or space at beginning of line</summary>
</member><member name="F:LeptonicaSharp.Enumerations.SPLIT_ON.SPLIT_ON_BLANK_LINE">
	<summary>newline with optional white space</summary>
</member><member name="F:LeptonicaSharp.Enumerations.SPLIT_ON.SPLIT_ON_BOTH">
	<summary>leading white space or newline</summary>
</member><member name="T:LeptonicaSharp.Enumerations.SPLIT_ON">
	<summary>
 Constants for deciding when text block is divided into paragraphs
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.CCB_AL_COORDS.CCB_LOCAL_COORDS">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.CCB_AL_COORDS.CCB_GLOBAL_COORDS">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.CCB_AL_COORDS">
	<summary>
 Use in ccbaStepChainsToPixCoords()
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.CCB_SAVE_PTS.CCB_SAVE_ALL_PTS">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.CCB_SAVE_PTS.CCB_SAVE_TURNING_PTS">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.CCB_SAVE_PTS">
	<summary>
 Use in ccbaGenerateSPGlobalLocs()
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_STYLE.GPLOT_LINES">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_STYLE.GPLOT_POINTS">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_STYLE.GPLOT_IMPULSES">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_STYLE.GPLOT_LINESPOINTS">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_STYLE.GPLOT_DOTS">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.GPLOT_STYLE">
	<summary>
	</summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_OUTPUT.GPLOT_NONE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_OUTPUT.GPLOT_PNG">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_OUTPUT.GPLOT_PS">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_OUTPUT.GPLOT_EPS">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_OUTPUT.GPLOT_LATEX">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.GPLOT_OUTPUT">
	<summary>
	</summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_SCALING.GPLOT_LINEAR_SCALE">
	<summary>default</summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_SCALING.GPLOT_LOG_SCALE_X">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_SCALING.GPLOT_LOG_SCALE_Y">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.GPLOT_SCALING.GPLOT_LOG_SCALE_X_Y">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.GPLOT_SCALING">
	<summary>
	</summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_UNKNOWN">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_BMP">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_JFIF_JPEG">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_PNG">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_TIFF">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_TIFF_PACKBITS">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_TIFF_RLE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_TIFF_G3">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_TIFF_G4">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_TIFF_LZW">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_TIFF_ZIP">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_PNM">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_PS">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_GIF">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_JP2">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_WEBP">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_LPDF">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_DEFAULT">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.IFF.IFF_SPIX">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.IFF">
	<summary>
 Image file format types
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.ID.BMP_ID">
	<summary>BM - for bitmaps</summary>
</member><member name="F:LeptonicaSharp.Enumerations.ID.TIFF_BIGEND_ID">
	<summary>MM - for 'motorola'</summary>
</member><member name="F:LeptonicaSharp.Enumerations.ID.TIFF_LITTLEEND_ID">
	<summary>II - for 'intel'</summary>
</member><member name="T:LeptonicaSharp.Enumerations.ID">
	<summary>
 Format header ids
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_JPEG.L_JPEG_READ_LUMINANCE">
	<summary>only want luminance data; no chroma</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_JPEG.L_JPEG_FAIL_ON_BAD_DATA">
	<summary>don't return possibly damaged pix</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_JPEG">
	<summary>
 Hinting bit flags in jpeg reader
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ENCODE.L_DEFAULT_ENCODE">
	<summary>use default encoding based on image</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ENCODE.L_JPEG_ENCODE">
	<summary>use dct encoding: 8 and 32 bpp, no cmap</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ENCODE.L_G4_ENCODE">
	<summary>use ccitt g4 fax encoding: 1 bpp</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ENCODE.L_FLATE_ENCODE">
	<summary>use flate encoding: any depth, cmap ok</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ENCODE.L_JP2K_ENCODE">
	<summary>use jp2k encoding: 8 and 32 bpp, no cmap</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_ENCODE">
	<summary>
 Pdf formatted encoding types
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_T_IMAGE.L_FIRST_IMAGE">
	<summary>first image to be used</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_T_IMAGE.L_NEXT_IMAGE">
	<summary>intermediate image; not first or last</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_T_IMAGE.L_LAST_IMAGE">
	<summary>last image to be used</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_T_IMAGE">
	<summary>
 Pdf multi image flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.JB.JB_RANKHAUS">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.JB.JB_CORRELATION">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.JB">
	<summary>
 Classifier methods
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.JB_S.JB_CONN_COMPS">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.JB_S.JB_CHARACTERS">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.JB_S.JB_WORDS">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.JB_S">
	<summary>
 For jbGetComponents(): type of component to extract from images
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.MMETRIC_MORPH_BC.SYMMETRIC_MORPH_BC">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.MMETRIC_MORPH_BC.ASYMMETRIC_MORPH_BC">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.MMETRIC_MORPH_BC">
	<summary>
 Morphological boundary condition flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.SEL.SEL_DONT_CARE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.SEL.SEL_HIT">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.SEL.SEL_MISS">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.SEL">
	<summary>
 Structuring element types
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_RUN_O.L_RUN_OFF">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_RUN_O.L_RUN_ON">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_RUN_O">
	<summary>
 Runlength flags for granulometry
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_direction.L_HORIZ">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_direction.L_VERT">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_direction.L_BOTH_DIRECTIONS">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_direction">
	<summary>
 Direction flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_MORPH.L_MORPH_DILATE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_MORPH.L_MORPH_ERODE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_MORPH.L_MORPH_OPEN">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_MORPH.L_MORPH_CLOSE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_MORPH.L_MORPH_HMT">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_MORPH">
	<summary>
 Morphological operation flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_L_SCALE.L_LINEAR_SCALE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_L_SCALE.L_LOG_SCALE">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_L_SCALE">
	<summary>
 Grayscale intensity scaling flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_TOPHAT.L_TOPHAT_WHITE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_TOPHAT.L_TOPHAT_BLACK">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_TOPHAT">
	<summary>
 Morphological tophat flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_arithmetic_logical_operator.L_ARITH_ADD">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_arithmetic_logical_operator.L_ARITH_SUBTRACT">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_arithmetic_logical_operator.L_ARITH_MULTIPLY">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_arithmetic_logical_operator.L_ARITH_DIVIDE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_arithmetic_logical_operator.L_UNION">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_arithmetic_logical_operator.L_INTERSECTION">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_arithmetic_logical_operator.L_SUBTRACTION">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_arithmetic_logical_operator.L_EXCLUSIVE_OR">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_arithmetic_logical_operator">
	<summary>
 Arithmetic and logical operator flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_CHOOSE_M.L_CHOOSE_MIN">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_CHOOSE_M.L_CHOOSE_MAX">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_CHOOSE_M.L_CHOOSE_MAXDIFF">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_CHOOSE_M.L_CHOOSE_MIN_BOOST">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_CHOOSE_M.L_CHOOSE_MAX_BOOST">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_CHOOSE_M">
	<summary>
 Min/max selection flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BOUNDARY_G.L_BOUNDARY_BG">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BOUNDARY_G.L_BOUNDARY_FG">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_BOUNDARY_G">
	<summary>
 Distance function b.c. flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_COMPARE.L_COMPARE_XOR">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_COMPARE.L_COMPARE_SUBTRACT">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_COMPARE.L_COMPARE_ABS_DIFF">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_COMPARE">
	<summary>
 Image comparison flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_MAX.L_MAX_DIFF_FROM_AVERAGE_2">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_MAX.L_MAX_MIN_DIFF_FROM_2">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_MAX.L_MAX_DIFF">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_MAX">
	<summary>
 Color content flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.colors_32_bpp.COLOR_RED">
	<summary>red color index in RGBA_QUAD</summary>
</member><member name="F:LeptonicaSharp.Enumerations.colors_32_bpp.COLOR_GREEN">
	<summary>green color index in RGBA_QUAD</summary>
</member><member name="F:LeptonicaSharp.Enumerations.colors_32_bpp.COLOR_BLUE">
	<summary>blue color index in RGBA_QUAD</summary>
</member><member name="F:LeptonicaSharp.Enumerations.colors_32_bpp.L_ALPHA_CHANNEL">
	<summary>alpha value index in RGBA_QUAD</summary>
</member><member name="T:LeptonicaSharp.Enumerations.colors_32_bpp">
	<summary>
 Colors for 32 bpp
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DRAW.L_DRAW_RED">
	<summary>draw in red</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DRAW.L_DRAW_GREEN">
	<summary>draw in green</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DRAW.L_DRAW_BLUE">
	<summary>draw in blue</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DRAW.L_DRAW_SPECIFIED">
	<summary>draw specified color</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DRAW.L_DRAW_RGB">
	<summary>draw as sequence of r,g,b</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DRAW.L_DRAW_RANDOM">
	<summary>draw randomly chosen colors</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_DRAW">
	<summary>
 Colors for drawing boxes
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.REMOVE_CMAP.REMOVE_CMAP_TO_BINARY">
	<summary>remove colormap for conv to 1 bpp</summary>
</member><member name="F:LeptonicaSharp.Enumerations.REMOVE_CMAP.REMOVE_CMAP_TO_GRAYSCALE">
	<summary>remove colormap for conv to 8 bpp</summary>
</member><member name="F:LeptonicaSharp.Enumerations.REMOVE_CMAP.REMOVE_CMAP_TO_FULL_COLOR">
	<summary>remove colormap for conv to 32 bpp</summary>
</member><member name="F:LeptonicaSharp.Enumerations.REMOVE_CMAP.REMOVE_CMAP_WITH_ALPHA">
	<summary>remove colormap and alpha</summary>
</member><member name="F:LeptonicaSharp.Enumerations.REMOVE_CMAP.REMOVE_CMAP_BASED_ON_SRC">
	<summary>remove depending on src format</summary>
</member><member name="T:LeptonicaSharp.Enumerations.REMOVE_CMAP">
	<summary>
 Flags for colormap conversion
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_access_storage.L_NOCOPY">
	<summary>do not copy the object; do not delete the ptr</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_access_storage.L_INSERT">
	<summary>stuff it in; do not copy or clone</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_access_storage.L_COPY">
	<summary>make/use a copy of the object</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_access_storage.L_CLONE">
	<summary>make/use clone (ref count) of the object</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_access_storage.L_COPY_CLONE">
	<summary>make a new array object (e.g., pixa) and fill    the array with clones (e.g., pix)</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_access_storage">
	<summary>
 Access and storage flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT.L_SHELL_SORT">
	<summary>use shell sort</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT.L_BIN_SORT">
	<summary>use bin sort</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_SORT">
	<summary>
 Sort mode flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT_CREASING.L_SORT_INCREASING">
	<summary>sort in increasing order</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT_CREASING.L_SORT_DECREASING">
	<summary>sort in decreasing order</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_SORT_CREASING">
	<summary>
 Sort order flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT_BY.L_SORT_BY_X">
	<summary>sort box or c.c. by left edge location</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT_BY.L_SORT_BY_Y">
	<summary>sort box or c.c. by top edge location</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT_BY.L_SORT_BY_RIGHT">
	<summary>sort box or c.c. by right edge location</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT_BY.L_SORT_BY_BOT">
	<summary>sort box or c.c. by bot edge location</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT_BY.L_SORT_BY_WIDTH">
	<summary>sort box or c.c. by width</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT_BY.L_SORT_BY_HEIGHT">
	<summary>sort box or c.c. by height</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT_BY.L_SORT_BY_MIN_DIMENSION">
	<summary>sort box or c.c. by min dimension</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT_BY.L_SORT_BY_MAX_DIMENSION">
	<summary>sort box or c.c. by max dimension</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT_BY.L_SORT_BY_PERIMETER">
	<summary>sort box or c.c. by perimeter</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT_BY.L_SORT_BY_AREA">
	<summary>sort box or c.c. by area</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SORT_BY.L_SORT_BY_ASPECT_RATIO">
	<summary>sort box or c.c. by width/height ratio</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_SORT_BY">
	<summary>
 Sort type flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BLEND.L_BLEND_WITH_INVERSE">
	<summary>add some of src inverse to itself</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BLEND.L_BLEND_TO_WHITE">
	<summary>shift src colors towards white</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BLEND.L_BLEND_TO_BLACK">
	<summary>shift src colors towards black</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BLEND.L_BLEND_GRAY">
	<summary>blend src directly with blender</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BLEND.L_BLEND_GRAY_WITH_INVERSE">
	<summary>add amount of src inverse to itself,    based on blender pix value</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_BLEND">
	<summary>
 Blend flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_PAINT.L_PAINT_LIGHT">
	<summary>colorize non-black pixels</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_PAINT.L_PAINT_DARK">
	<summary>colorize non-white pixels</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_PAINT">
	<summary>
	</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_PIXELS.L_SET_PIXELS">
	<summary>set all bits in each pixel to 1</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_PIXELS.L_CLEAR_PIXELS">
	<summary>set all bits in each pixel to 0</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_PIXELS.L_FLIP_PIXELS">
	<summary>flip all bits in each pixel</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_PIXELS">
	<summary>
 Graphics pixel setting
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT.L_SELECT_WIDTH">
	<summary>width must satisfy constraint</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT.L_SELECT_HEIGHT">
	<summary>height must satisfy constraint</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT.L_SELECT_XVAL">
	<summary>x value satisfy constraint</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT.L_SELECT_YVAL">
	<summary>y value must satisfy constraint</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT.L_SELECT_IF_EITHER">
	<summary>either width or height (or xval    or yval) can satisfy</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT.L_SELECT_IF_BOTH">
	<summary>both width and height (or xval     and yval must satisfy</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_SELECT">
	<summary>
 Location filter flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT_IF.L_SELECT_IF_LT">
	<summary>save if value is less than threshold</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT_IF.L_SELECT_IF_GT">
	<summary>save if value is more than threshold</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT_IF.L_SELECT_IF_LTE">
	<summary>save if value is  smaller = to the threshold</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT_IF.L_SELECT_IF_GTE">
	<summary>save if value is  bigger = to the threshold</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_SELECT_IF">
	<summary>
 Size filter flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT_.L_SELECT_RED">
	<summary>use red component</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT_.L_SELECT_GREEN">
	<summary>use green component</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT_.L_SELECT_BLUE">
	<summary>use blue component</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT_.L_SELECT_MIN">
	<summary>use min color component</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT_.L_SELECT_MAX">
	<summary>use max color component</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT_.L_SELECT_AVERAGE">
	<summary>use average of color components</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT_.L_SELECT_HUE">
	<summary>use hue value (in HSV color space)</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SELECT_.L_SELECT_SATURATION">
	<summary>use saturation value (in HSV space)</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_SELECT_">
	<summary>
 Color component selection flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_16_bit_conversion.L_LS_BYTE">
	<summary>use LSB</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_16_bit_conversion.L_MS_BYTE">
	<summary>use MSB</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_16_bit_conversion.L_AUTO_BYTE">
	<summary>use LSB if max(val)  smaller  256; else MSB</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_16_bit_conversion.L_CLIP_TO_FF">
	<summary>use max(val, 255)</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_16_bit_conversion.L_LS_TWO_BYTES">
	<summary>use two LSB</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_16_bit_conversion.L_MS_TWO_BYTES">
	<summary>use two MSB</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_16_bit_conversion.L_CLIP_TO_FFFF">
	<summary>use max(val, 65535)</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_16_bit_conversion">
	<summary>
 16-bit conversion flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ROTATE.L_ROTATE_AREA_MAP">
	<summary>use area map rotation, if possible</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ROTATE.L_ROTATE_SHEAR">
	<summary>use shear rotation</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ROTATE.L_ROTATE_SAMPLING">
	<summary>use sampling</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_ROTATE">
	<summary>
 Rotate flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BRING_IN.L_BRING_IN_WHITE">
	<summary>bring in white pixels from the outside</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BRING_IN.L_BRING_IN_BLACK">
	<summary>bring in black pixels from the outside</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_BRING_IN">
	<summary>
 Background flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SHEAR_ABOUT_CER.L_SHEAR_ABOUT_CORNER">
	<summary>shear image about UL corner</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SHEAR_ABOUT_CER.L_SHEAR_ABOUT_CENTER">
	<summary>shear image about center</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_SHEAR_ABOUT_CER">
	<summary>
 Shear flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_affine_transm_order.L_TR_SC_RO">
	<summary>translate, scale, rotate</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_affine_transm_order.L_SC_RO_TR">
	<summary>scale, rotate, translate</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_affine_transm_order.L_RO_TR_SC">
	<summary>rotate, translate, scale</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_affine_transm_order.L_TR_RO_SC">
	<summary>translate, rotate, scale</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_affine_transm_order.L_RO_SC_TR">
	<summary>rotate, scale, translate</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_affine_transm_order.L_SC_TR_RO">
	<summary>scale, translate, rotate</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_affine_transm_order">
	<summary>
 Affine transform order flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_FILL.L_FILL_WHITE">
	<summary>fill white pixels (e.g, in fg map)</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_FILL.L_FILL_BLACK">
	<summary>fill black pixels (e.g., in bg map)</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_FILL">
	<summary>
 Grayscale filling flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SET.L_SET_WHITE">
	<summary>set pixels to white</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SET.L_SET_BLACK">
	<summary>set pixels to black</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_SET">
	<summary>
 Flags for setting to white or black
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_GET_VAL.L_GET_WHITE_VAL">
	<summary>get white pixel value</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_GET_VAL.L_GET_BLACK_VAL">
	<summary>get black pixel value</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_GET_VAL">
	<summary>
 Flags for getting white or black value
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_IS_MAX.L_WHITE_IS_MAX">
	<summary>white pixels are 0xff or 0xffff; black are 0</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_IS_MAX.L_BLACK_IS_MAX">
	<summary>black pixels are 0xff or 0xffff; white are 0</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_IS_MAX">
	<summary>
 Flags for 8 bit and 16 bit pixel sums
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.DEFAULT_CLIP.DEFAULT_CLIP_LOWER_1">
	<summary>dist to black with no prop; 1 bpp</summary>
</member><member name="F:LeptonicaSharp.Enumerations.DEFAULT_CLIP.DEFAULT_CLIP_UPPER_1">
	<summary>dist to black with no prop; 1 bpp</summary>
</member><member name="F:LeptonicaSharp.Enumerations.DEFAULT_CLIP.DEFAULT_CLIP_LOWER_2">
	<summary>dist to black with no prop; 2 bpp</summary>
</member><member name="F:LeptonicaSharp.Enumerations.DEFAULT_CLIP.DEFAULT_CLIP_UPPER_2">
	<summary>dist to black with no prop; 2 bpp</summary>
</member><member name="T:LeptonicaSharp.Enumerations.DEFAULT_CLIP">
	<summary>
 Dither parameters
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_AN_DISTANCE.L_MANHATTAN_DISTANCE">
	<summary>L1 distance (e.g., in color space)</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_AN_DISTANCE.L_EUCLIDEAN_DISTANCE">
	<summary>L2 distance</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_AN_DISTANCE">
	<summary>
 Distance flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_value_.L_NEGATIVE">
	<summary>values  smaller  0</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_value_.L_NON_NEGATIVE">
	<summary>values  bigger = 0</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_value_.L_POSITIVE">
	<summary>values  bigger  0</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_value_.L_NON_POSITIVE">
	<summary>values  smaller = 0</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_value_.L_ZERO">
	<summary>values = 0</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_value_.L_ALL">
	<summary>all values</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_value_">
	<summary>
 Value flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_statistical_measures.L_MEAN_ABSVAL">
	<summary>average of abs values</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_statistical_measures.L_MEDIAN_VAL">
	<summary>median value of set</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_statistical_measures.L_MODE_VAL">
	<summary>mode value of set</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_statistical_measures.L_MODE_COUNT">
	<summary>mode count of set</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_statistical_measures.L_ROOT_MEAN_SQUARE">
	<summary>rms of values</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_statistical_measures.L_STANDARD_DEVIATION">
	<summary>standard deviation from mean</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_statistical_measures.L_VARIANCE">
	<summary>variance of values</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_statistical_measures">
	<summary>
 Statistical measures
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_CHOOSE.L_CHOOSE_CONSECUTIVE">
	<summary>select 'n' consecutive</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_CHOOSE.L_CHOOSE_SKIP_BY">
	<summary>select at intervals of 'n'</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_CHOOSE">
	<summary>
 Set selection flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_TEXT_ORIENT.L_TEXT_ORIENT_UNKNOWN">
	<summary>low confidence on text orientation</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_TEXT_ORIENT.L_TEXT_ORIENT_UP">
	<summary>portrait, text rightside-up</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_TEXT_ORIENT.L_TEXT_ORIENT_LEFT">
	<summary>landscape, text up to left</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_TEXT_ORIENT.L_TEXT_ORIENT_DOWN">
	<summary>portrait, text upside-down</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_TEXT_ORIENT.L_TEXT_ORIENT_RIGHT">
	<summary>landscape, text up to right</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_TEXT_ORIENT">
	<summary>
 Text orientation flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_L_EDGES.L_HORIZONTAL_EDGES">
	<summary>filters for horizontal edges</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_L_EDGES.L_VERTICAL_EDGES">
	<summary>filters for vertical edges</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_L_EDGES.L_ALL_EDGES">
	<summary>filters for all edges</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_L_EDGES">
	<summary>
 Edge orientation flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_LINE.L_HORIZONTAL_LINE">
	<summary>horizontal line</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_LINE.L_POS_SLOPE_LINE">
	<summary>45 degree line with positive slope</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_LINE.L_VERTICAL_LINE">
	<summary>vertical line</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_LINE.L_NEG_SLOPE_LINE">
	<summary>45 degree line with negative slope</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_LINE.L_OBLIQUE_LINE">
	<summary>neither horizontal nor vertical</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_LINE">
	<summary>
 Line orientation flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_MODE.L_PORTRAIT_MODE">
	<summary>typical: page is viewed with height  bigger  width</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_MODE.L_LANDSCAPE_MODE">
	<summary>page is viewed at 90 deg to portrait mode</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_MODE">
	<summary>
 Image orientation flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_scan_direction.L_FROM_LEFT">
	<summary>scan from left</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_scan_direction.L_FROM_RIGHT">
	<summary>scan from right</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_scan_direction.L_FROM_TOP">
	<summary>scan from top</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_scan_direction.L_FROM_BOT">
	<summary>scan from bottom</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_scan_direction.L_SCAN_NEGATIVE">
	<summary>scan in negative direction</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_scan_direction.L_SCAN_POSITIVE">
	<summary>scan in positive direction</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_scan_direction.L_SCAN_BOTH">
	<summary>scan in both directions</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_scan_direction.L_SCAN_HORIZONTAL">
	<summary>horizontal scan (direction unimportant)</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_scan_direction.L_SCAN_VERTICAL">
	<summary>vertical scan (direction unimportant)</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_scan_direction">
	<summary>
 Scan direction flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_ADJUST_SKIP">
	<summary>do not adjust</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_ADJUST_LEFT">
	<summary>adjust left edge</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_ADJUST_RIGHT">
	<summary>adjust right edge</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_ADJUST_LEFT_AND_RIGHT">
	<summary>adjust both left and right edges</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_ADJUST_TOP">
	<summary>adjust top edge</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_ADJUST_BOT">
	<summary>adjust bottom edge</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_ADJUST_TOP_AND_BOT">
	<summary>adjust both top and bottom edges</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_ADJUST_CHOOSE_MIN">
	<summary>choose the min median value</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_ADJUST_CHOOSE_MAX">
	<summary>choose the max median value</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_SET_LEFT">
	<summary>set left side to a given value</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_SET_RIGHT">
	<summary>set right side to a given value</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_SET_TOP">
	<summary>set top side to a given value</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_SET_BOT">
	<summary>set bottom side to a given value</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_GET_LEFT">
	<summary>get left side location</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_GET_RIGHT">
	<summary>get right side location</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_GET_TOP">
	<summary>get top side location</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_box_size_adjustment_location.L_GET_BOT">
	<summary>get bottom side location</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_box_size_adjustment_location">
	<summary>
 Box size adjustment and location flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box.L_USE_MINSIZE">
	<summary>use boundaries giving min size</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box.L_USE_MAXSIZE">
	<summary>use boundaries giving max size</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box.L_SUB_ON_LOC_DIFF">
	<summary>modify boundary if big location diff</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box.L_SUB_ON_SIZE_DIFF">
	<summary>modify boundary if big size diff</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box.L_USE_CAPPED_MIN">
	<summary>modify boundary with capped min</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box.L_USE_CAPPED_MAX">
	<summary>modify boundary with capped max</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L__modifying_box_boundaries_using_a_second_box">
	<summary>
 Flags for modifying box boundaries using a second box
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_hling_overlapping_bounding_boxes_in_boxa.L_COMBINE">
	<summary>resize to bounding region; remove smaller</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_hling_overlapping_bounding_boxes_in_boxa.L_REMOVE_SMALL">
	<summary>only remove smaller</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_hling_overlapping_bounding_boxes_in_boxa">
	<summary>
 Handling overlapping bounding boxes in Boxa
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_USE_BOXES.L_USE_ALL_BOXES">
	<summary>consider all boxes in the sequence</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_USE_BOXES.L_USE_SAME_PARITY_BOXES">
	<summary>consider boxes with the same parity</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_USE_BOXES">
	<summary>
 Flags for replacing invalid boxes
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_WARP_TO_T.L_WARP_TO_LEFT">
	<summary>increasing stretch or contraction to left</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_WARP_TO_T.L_WARP_TO_RIGHT">
	<summary>increasing stretch or contraction to right</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_WARP_TO_T">
	<summary>
 Horizontal warp direction
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_WARP.L_LINEAR_WARP">
	<summary>stretch or contraction grows linearly</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_WARP.L_QUADRATIC_WARP">
	<summary>stretch or contraction grows quadratically</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_WARP">
	<summary>
 Horizontal warp stretch mode
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ED.L_INTERPOLATED">
	<summary>linear interpolation from src pixels</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ED.L_SAMPLED">
	<summary>nearest src pixel sampling only</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_ED">
	<summary>
 Pixel selection for resampling
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_THIN_G.L_THIN_FG">
	<summary>thin foreground of 1 bpp image</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_THIN_G.L_THIN_BG">
	<summary>thin background of 1 bpp image</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_THIN_G">
	<summary>
 Thinning flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_AL_RUNS.L_HORIZONTAL_RUNS">
	<summary>determine runlengths of horizontal runs</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_AL_RUNS.L_VERTICAL_RUNS">
	<summary>determine runlengths of vertical runs</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_AL_RUNS">
	<summary>
 Runlength flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_EDGE.L_SOBEL_EDGE">
	<summary>Sobel edge filter</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_EDGE.L_TWO_SIDED_EDGE">
	<summary>Two-sided edge filter</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_EDGE">
	<summary>
 Edge filter flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SUBPIXEL_ORDER.L_SUBPIXEL_ORDER_RGB">
	<summary>sensor order left-to-right RGB</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SUBPIXEL_ORDER.L_SUBPIXEL_ORDER_BGR">
	<summary>sensor order left-to-right BGR</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SUBPIXEL_ORDER.L_SUBPIXEL_ORDER_VRGB">
	<summary>sensor order top-to-bottom RGB</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SUBPIXEL_ORDER.L_SUBPIXEL_ORDER_VBGR">
	<summary>sensor order top-to-bottom BGR</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_SUBPIXEL_ORDER">
	<summary>
 Subpixel color component ordering in LC display
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_HISTO.L_HS_HISTO">
	<summary>Use hue-saturation histogram</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_HISTO.L_HV_HISTO">
	<summary>Use hue-value histogram</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_HISTO.L_SV_HISTO">
	<summary>Use saturation-value histogram</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_HISTO">
	<summary>
 HSV histogram flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_CLUDE_REGION.L_INCLUDE_REGION">
	<summary>Use hue-saturation histogram</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_CLUDE_REGION.L_EXCLUDE_REGION">
	<summary>Use hue-value histogram</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_CLUDE_REGION">
	<summary>
 Region flags (inclusion, exclusion)
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ADD.L_ADD_ABOVE">
	<summary>Add text above the image</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ADD.L_ADD_BELOW">
	<summary>Add text below the image</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ADD.L_ADD_LEFT">
	<summary>Add text to the left of the image</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ADD.L_ADD_RIGHT">
	<summary>Add text to the right of the image</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ADD.L_ADD_AT_TOP">
	<summary>Add text over the top of the image</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ADD.L_ADD_AT_BOT">
	<summary>Add text over the bottom of the image</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ADD.L_ADD_AT_LEFT">
	<summary>Add text over left side of the image</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ADD.L_ADD_AT_RIGHT">
	<summary>Add text over right side of the image</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_ADD">
	<summary>
 Flags for adding text to a Pix
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_PLOT_AT.L_PLOT_AT_TOP">
	<summary>Plot horizontally at top</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_PLOT_AT.L_PLOT_AT_MID_HORIZ">
	<summary>Plot horizontally at middle</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_PLOT_AT.L_PLOT_AT_BOT">
	<summary>Plot horizontally at bottom</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_PLOT_AT.L_PLOT_AT_LEFT">
	<summary>Plot vertically at left</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_PLOT_AT.L_PLOT_AT_MID_VERT">
	<summary>Plot vertically at middle</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_PLOT_AT.L_PLOT_AT_RIGHT">
	<summary>Plot vertically at right</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_PLOT_AT">
	<summary>
 Flags for plotting on a Pix
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DISPLAY_WITH.L_DISPLAY_WITH_XZGV">
	<summary>Use xzgv with pixDisplay()</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DISPLAY_WITH.L_DISPLAY_WITH_XLI">
	<summary>Use xli with pixDisplay()</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DISPLAY_WITH.L_DISPLAY_WITH_XV">
	<summary>Use xv with pixDisplay()</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DISPLAY_WITH.L_DISPLAY_WITH_IV">
	<summary>Use irfvanview (win) with pixDisplay()</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_DISPLAY_WITH.L_DISPLAY_WITH_OPEN">
	<summary>Use open (apple) with pixDisplay()</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_DISPLAY_WITH">
	<summary>
 Flags for selecting display program
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.Unnamed_Enum_1.L_NO_CHROMA_SAMPLING_JPEG">
	<summary>Write full resolution chroma</summary>
</member><member name="T:LeptonicaSharp.Enumerations.Unnamed_Enum_1">
	<summary>
 Flags used in Pix::special
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_hling_negative_values_in_conversion_to_unsigned_int.L_CLIP_TO_ZERO">
	<summary>Clip negative values to 0</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_hling_negative_values_in_conversion_to_unsigned_int.L_TAKE_ABSVAL">
	<summary>Convert to positive using L_ABS()</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_hling_negative_values_in_conversion_to_unsigned_int">
	<summary>
 Handling negative values in conversion to unsigned int
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ZERO.L_LESS_THAN_ZERO">
	<summary>Choose values less than zero</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ZERO.L_EQUAL_TO_ZERO">
	<summary>Choose values equal to zero</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_ZERO.L_GREATER_THAN_ZERO">
	<summary>Choose values greater than zero</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_ZERO">
	<summary>
 Relative to zero flags
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_TRAIL_SLASH.L_ADD_TRAIL_SLASH">
	<summary>Add trailing slash to string</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_TRAIL_SLASH.L_REMOVE_TRAIL_SLASH">
	<summary>Remove trailing slash from string</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_TRAIL_SLASH">
	<summary>
 Flags for adding or removing traling slash from string
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L__describing_limited_character_sets.L_UNKNOWN">
	<summary>character set type is not specified</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L__describing_limited_character_sets.L_ARABIC_NUMERALS">
	<summary>10 digits</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L__describing_limited_character_sets.L_LC_ROMAN_NUMERALS">
	<summary>7 lower-case letters (i,v,x,l,c,d,m)</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L__describing_limited_character_sets.L_UC_ROMAN_NUMERALS">
	<summary>7 upper-case letters (I,V,X,L,C,D,M)</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L__describing_limited_character_sets.L_LC_ALPHA">
	<summary>26 lower-case letters</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L__describing_limited_character_sets.L_UC_ALPHA">
	<summary>26 upper-case letters</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L__describing_limited_character_sets">
	<summary>
 Flags for describing limited character sets
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_USE_A_TEMPLATES.L_USE_ALL_TEMPLATES">
	<summary>use all templates; default</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_USE_A_TEMPLATES.L_USE_AVERAGE_TEMPLATES">
	<summary>use average templates; special cases</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_USE_A_TEMPLATES">
	<summary>
 Flags for selecting average or all templates: recog-&gt;templ_use
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_REG.L_REG_GENERATE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_REG.L_REG_COMPARE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_REG.L_REG_DISPLAY">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_REG">
	<summary>
 Running modes for the test
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_STR.L_STR_TYPE">
	<summary>typedef for the data type</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_STR.L_STR_NAME">
	<summary>name of the data type</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_STR.L_STR_READER">
	<summary>reader to get the data type from file</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_STR.L_STR_MEMREADER">
	<summary>reader to get the compressed string in memory</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_STR">
	<summary>
 Select string in stringcode for a specific serializable data type
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SUDOKU.L_SUDOKU_INIT">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_SUDOKU.L_SUDOKU_STATE">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_SUDOKU">
	<summary>
 For printing out array data
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_USE_WIS.L_USE_WIDTHS">
	<summary>use histogram of barcode widths</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_USE_WIS.L_USE_WINDOWS">
	<summary>find best window for decoding transitions</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_USE_WIS">
	<summary>
 Flags for method of extracting barcode widths
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BF.L_BF_UNKNOWN">
	<summary>unknown format</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BF.L_BF_ANY">
	<summary>try decoding with all known formats</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BF.L_BF_CODE128">
	<summary>decode with Code128 format</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BF.L_BF_EAN8">
	<summary>decode with EAN8 format</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BF.L_BF_EAN13">
	<summary>decode with EAN13 format</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BF.L_BF_CODE2OF5">
	<summary>decode with Code 2 of 5 format</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BF.L_BF_CODEI2OF5">
	<summary>decode with Interleaved 2 of 5 format</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BF.L_BF_CODE39">
	<summary>decode with Code39 format</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BF.L_BF_CODE93">
	<summary>decode with Code93 format</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BF.L_BF_CODABAR">
	<summary>decode with Code93 format</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_BF.L_BF_UPCA">
	<summary>decode with UPC A format</summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_BF">
	<summary>
 Flags for barcode formats
 </summary>
</member><member name="F:LeptonicaSharp.Enumerations.Unnamed_Enum_2.START_LOC">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.Unnamed_Enum_2.DIR_NORTH">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.Unnamed_Enum_2.DIR_SOUTH">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.Unnamed_Enum_2.DIR_WEST">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.Unnamed_Enum_2.DIR_EAST">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.Unnamed_Enum_2">
	<summary>
	</summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_NODE.L_RED_NODE">
	<summary></summary>
</member><member name="F:LeptonicaSharp.Enumerations.L_NODE.L_BLACK_NODE">
	<summary></summary>
</member><member name="T:LeptonicaSharp.Enumerations.L_NODE">
	<summary>
	</summary>
</member>
</members>
</doc>